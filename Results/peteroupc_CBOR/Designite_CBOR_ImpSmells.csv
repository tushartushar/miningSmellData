Implementation smell,Namespace,Class,File,Method,Description
Long Method,PeterO,DataUtilities,C:\repos\peteroupc_CBOR\CBOR\PeterO\DataUtilities.cs,WriteUtf8,The method has 125 lines of code.
Long Method,PeterO,DataUtilities,C:\repos\peteroupc_CBOR\CBOR\PeterO\DataUtilities.cs,ReadUtf8FromBytes,The method has 106 lines of code.
Long Method,PeterO,DataUtilities,C:\repos\peteroupc_CBOR\CBOR\PeterO\DataUtilities.cs,ReadUtf8,The method has 122 lines of code.
Long Method,PeterO.Cbor,CBORDataUtilities,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORDataUtilities.cs,ParseJSONNumber,The method has 225 lines of code.
Long Method,PeterO.Cbor,CBORJson,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORJson.cs,NextJSONString,The method has 117 lines of code.
Long Method,PeterO.Cbor,CBORJson,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORJson.cs,NextJSONValue,The method has 152 lines of code.
Long Method,PeterO.Cbor,CBORJson,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORJson.cs,WriteJSONToInternal,The method has 216 lines of code.
Long Method,PeterO.Cbor,CBORObject,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORObject.cs,FromObject,The method has 122 lines of code.
Long Method,PeterO.Cbor,CBORObject,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORObject.cs,CompareTo,The method has 214 lines of code.
Long Method,PeterO.Cbor,CBORObject,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORObject.cs,EncodeToBytes,The method has 113 lines of code.
Long Method,PeterO.Cbor,CBORObject,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORObject.cs,ToString,The method has 166 lines of code.
Long Method,PeterO.Cbor,CBORObject,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORObject.cs,GetFixedLengthObject,The method has 121 lines of code.
Long Method,PeterO.Cbor,CBORObjectMath,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORObjectMath.cs,Divide,The method has 107 lines of code.
Long Method,PeterO.Cbor,CBORReader,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORReader.cs,ReadForFirstByte,The method has 414 lines of code.
Long Method,PeterO.Cbor,CharacterReader,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CharacterReader.cs,DetectUtf8Or16Or32,The method has 123 lines of code.
Long Method,PeterO.Cbor,MutableNumber,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\FastInteger2.cs,Multiply,The method has 109 lines of code.
Long Method,PeterO.Cbor,URIUtility,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\URIUtility.cs,escapeURI,The method has 110 lines of code.
Long Method,PeterO.Cbor,URIUtility,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\URIUtility.cs,parseIPLiteral,The method has 210 lines of code.
Long Method,PeterO.Cbor,URIUtility,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\URIUtility.cs,splitIRI,The method has 247 lines of code.
Complex Method,PeterO,DataUtilities,C:\repos\peteroupc_CBOR\CBOR\PeterO\DataUtilities.cs,GetUtf8String,Cyclomatic complexity of the method is 8
Complex Method,PeterO,DataUtilities,C:\repos\peteroupc_CBOR\CBOR\PeterO\DataUtilities.cs,CodePointCompare,Cyclomatic complexity of the method is 10
Complex Method,PeterO,DataUtilities,C:\repos\peteroupc_CBOR\CBOR\PeterO\DataUtilities.cs,WriteUtf8,Cyclomatic complexity of the method is 16
Complex Method,PeterO,DataUtilities,C:\repos\peteroupc_CBOR\CBOR\PeterO\DataUtilities.cs,ReadUtf8FromBytes,Cyclomatic complexity of the method is 15
Complex Method,PeterO,DataUtilities,C:\repos\peteroupc_CBOR\CBOR\PeterO\DataUtilities.cs,ReadUtf8,Cyclomatic complexity of the method is 17
Complex Method,PeterO.Cbor,Base64,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\Base64.cs,WriteBase64,Cyclomatic complexity of the method is 11
Complex Method,PeterO.Cbor,CBORDataUtilities,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORDataUtilities.cs,ParseJSONNumber,Cyclomatic complexity of the method is 34
Complex Method,PeterO.Cbor,CBORObject,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORObject.cs,DecodeFromBytes,Cyclomatic complexity of the method is 9
Complex Method,PeterO.Cbor,CBORObject,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORObject.cs,FromObject,Cyclomatic complexity of the method is 34
Complex Method,PeterO.Cbor,CBORObject,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORObject.cs,CompareTo,Cyclomatic complexity of the method is 10
Complex Method,PeterO.Cbor,CBORObject,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORObject.cs,GetFixedLengthObject,Cyclomatic complexity of the method is 11
Complex Method,PeterO.Cbor,CBORObject,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORObject.cs,GetOptimizedBytesIfShortAscii,Cyclomatic complexity of the method is 8
Complex Method,PeterO.Cbor,CBORObject,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORObject.cs,MapCompare,Cyclomatic complexity of the method is 13
Complex Method,PeterO.Cbor,CBORObjectMath,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORObjectMath.cs,Addition,Cyclomatic complexity of the method is 10
Complex Method,PeterO.Cbor,CBORObjectMath,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORObjectMath.cs,Subtract,Cyclomatic complexity of the method is 10
Complex Method,PeterO.Cbor,CBORObjectMath,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORObjectMath.cs,Multiply,Cyclomatic complexity of the method is 10
Complex Method,PeterO.Cbor,CBORObjectMath,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORObjectMath.cs,Divide,Cyclomatic complexity of the method is 15
Complex Method,PeterO.Cbor,CBORObjectMath,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORObjectMath.cs,Remainder,Cyclomatic complexity of the method is 9
Complex Method,PeterO.Cbor,CBORReader,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORReader.cs,ReadForFirstByte,Cyclomatic complexity of the method is 55
Complex Method,PeterO.Cbor,CBORTag2,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORTag2.cs,ConvertToBigNum,Cyclomatic complexity of the method is 9
Complex Method,PeterO.Cbor,CBORTypeFilter,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORTypeFilter.cs,TagAllowed,Cyclomatic complexity of the method is 8
Complex Method,PeterO.Cbor,CBORUtilities,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORUtilities.cs,BigIntegerFromSingle,Cyclomatic complexity of the method is 9
Complex Method,PeterO.Cbor,CBORUtilities,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORUtilities.cs,LongToString,Cyclomatic complexity of the method is 10
Complex Method,PeterO.Cbor,CBORUtilities,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORUtilities.cs,BigIntegerFromDouble,Cyclomatic complexity of the method is 9
Complex Method,PeterO.Cbor,CharacterInputWithCount,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CharacterInputWithCount.cs,Read,Cyclomatic complexity of the method is 8
Complex Method,PeterO.Cbor,CharacterReader,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CharacterReader.cs,Read,Cyclomatic complexity of the method is 9
Complex Method,PeterO.Cbor,Utf16Reader,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CharacterReader.cs,ReadChar,Cyclomatic complexity of the method is 11
Complex Method,PeterO.Cbor,Utf8Reader,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CharacterReader.cs,ReadChar,Cyclomatic complexity of the method is 12
Complex Method,PeterO.Cbor,MutableNumber,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\FastInteger2.cs,Multiply,Cyclomatic complexity of the method is 11
Complex Method,PeterO.Cbor,URIUtility,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\URIUtility.cs,escapeURI,Cyclomatic complexity of the method is 10
Complex Method,PeterO.Cbor,URIUtility,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\URIUtility.cs,isValidCurieReference,Cyclomatic complexity of the method is 15
Complex Method,PeterO.Cbor,URIUtility,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\URIUtility.cs,normalizePath,Cyclomatic complexity of the method is 18
Complex Method,PeterO.Cbor,URIUtility,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\URIUtility.cs,parseIPLiteral,Cyclomatic complexity of the method is 35
Complex Method,PeterO.Cbor,URIUtility,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\URIUtility.cs,splitIRI,Cyclomatic complexity of the method is 35
Long Parameter List,PeterO,DataUtilities,C:\repos\peteroupc_CBOR\CBOR\PeterO\DataUtilities.cs,WriteUtf8,The method has 5 parameters. Parameters: str' offset' length' stream' replace
Long Parameter List,PeterO,DataUtilities,C:\repos\peteroupc_CBOR\CBOR\PeterO\DataUtilities.cs,WriteUtf8,The method has 6 parameters. Parameters: str' offset' length' stream' replace' lenientLineBreaks
Long Parameter List,PeterO,DataUtilities,C:\repos\peteroupc_CBOR\CBOR\PeterO\DataUtilities.cs,ReadUtf8FromBytes,The method has 5 parameters. Parameters: data' offset' bytesCount' builder' replace
Long Parameter List,PeterO,PrecisionContext,C:\repos\peteroupc_CBOR\CBOR\PeterO\PrecisionContext.cs,PrecisionContext,The method has 5 parameters. Parameters: precision' rounding' exponentMinSmall' exponentMaxSmall' clampNormalExponents
Long Parameter List,PeterO.Cbor,Base64,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\Base64.cs,WriteBase64,The method has 5 parameters. Parameters: writer' data' offset' count' padding
Long Parameter List,PeterO.Cbor,Base64,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\Base64.cs,WriteBase64URL,The method has 5 parameters. Parameters: writer' data' offset' count' padding
Long Parameter List,PeterO.Cbor,Base64,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\Base64.cs,WriteBase64,The method has 6 parameters. Parameters: writer' data' offset' count' alphabet' padding
Long Parameter List,PeterO.Cbor,CBORObject,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORObject.cs,WriteChildObject,The method has 5 parameters. Parameters: parentThisItem' child' outputStream' stack' options
Long Parameter List,PeterO.Cbor,CharacterReader,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CharacterReader.cs,CharacterReader,The method has 5 parameters. Parameters: str' offset' length' skipByteOrderMark' errorThrow
Long Parameter List,PeterO.Cbor,URIUtility,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\URIUtility.cs,parseDecOctet,The method has 5 parameters. Parameters: s' index' endOffset' c' delim
Long Identifier,PeterO.Cbor,CBORObject,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORObject.cs,,The length of the parameter CBORObjectTypeExtendedRational is 30.
Complex Conditional,PeterO,DataUtilities,C:\repos\peteroupc_CBOR\CBOR\PeterO\DataUtilities.cs,CodePointBefore,The conditional expression  "(c & 0xfc00) == 0xdc00 && index - 2 >= 0 &&           str[index - 2] >= 0xd800 && str[index - 2] <= 0xdbff"  is complex.
Complex Conditional,PeterO,DataUtilities,C:\repos\peteroupc_CBOR\CBOR\PeterO\DataUtilities.cs,CodePointAt,The conditional expression  "(c & 0xfc00) == 0xd800 && index + 1 < str.Length &&           str[index + 1] >= 0xdc00 && str[index + 1] <= 0xdfff"  is complex.
Complex Conditional,PeterO,DataUtilities,C:\repos\peteroupc_CBOR\CBOR\PeterO\DataUtilities.cs,CodePointCompare,The conditional expression  "(ca & 0xfc00) == 0xd800 && i + 1 < strA.Length &&               strA[i + 1] >= 0xdc00 && strA[i + 1] <= 0xdfff"  is complex.
Complex Conditional,PeterO,DataUtilities,C:\repos\peteroupc_CBOR\CBOR\PeterO\DataUtilities.cs,CodePointCompare,The conditional expression  "(cb & 0xfc00) == 0xd800 && i + 1 < strB.Length &&               strB[i + 1] >= 0xdc00 && strB[i + 1] <= 0xdfff"  is complex.
Complex Conditional,PeterO,DataUtilities,C:\repos\peteroupc_CBOR\CBOR\PeterO\DataUtilities.cs,WriteUtf8,The conditional expression  "(c & 0xfc00) == 0xd800 && index + 1 < endIndex &&               str[index + 1] >= 0xdc00 && str[index + 1] <= 0xdfff"  is complex.
Complex Conditional,PeterO.Cbor,CBORDataUtilities,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORDataUtilities.cs,ParseJSONNumber,The conditional expression  "offset >= 0 && newScaleInt == 0 && newScale == null && exp == null"  is complex.
Complex Conditional,PeterO.Cbor,CBORDataUtilities,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORDataUtilities.cs,ParseJSONNumber,The conditional expression  "(newScale == null && newScaleInt == 0) || (newScale != null &&                     newScale.Sign == 0)"  is complex.
Complex Conditional,PeterO.Cbor,CBORJson,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORJson.cs,SkipWhitespaceJSON,The conditional expression  "c == -1 || (c != 0x20 && c != 0x0a && c != 0x0d && c != 0x09)"  is complex.
Complex Conditional,PeterO.Cbor,CBORJson,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORJson.cs,NextJSONValue,The conditional expression  "this.reader.ReadChar() != 'a' || this.reader.ReadChar() != 'l' ||               this.reader.ReadChar() != 's' || this.reader.ReadChar() != 'e'"  is complex.
Complex Conditional,PeterO.Cbor,CBORJson,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORJson.cs,NextJSONValue,The conditional expression  "c == '-' || c == '+' || c == '.' || (c >= '0' && c <= '9') ||                    c == 'e' || c == 'E'"  is complex.
Complex Conditional,PeterO.Cbor,CBORJson,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORJson.cs,NextJSONValue,The conditional expression  "c == -1 || (c != 0x20 && c != 0x0a && c != 0x0d && c != 0x09)"  is complex.
Complex Conditional,PeterO.Cbor,CBORJson,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORJson.cs,NextJSONValue,The conditional expression  "c == '-' || c == '+' || c == '.' || (c >= '0' && c <= '9') ||                    c == 'e' || c == 'E'"  is complex.
Complex Conditional,PeterO.Cbor,CBORJson,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORJson.cs,NextJSONValue,The conditional expression  "c == -1 || (c != 0x20 && c != 0x0a && c != 0x0d && c != 0x09)"  is complex.
Complex Conditional,PeterO.Cbor,CBORJson,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORJson.cs,WriteJSONStringUnquoted,The conditional expression  "c < 0x20 || (c >= 0x7f && (c == 0x2028 || c == 0x2029 ||                     (c >= 0x7f && c <= 0xa0) || c == 0xfeff || c == 0xfffe ||                     c == 0xffff))"  is complex.
Complex Conditional,PeterO.Cbor,CBORObject,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORObject.cs,Write,The conditional expression  "(bignum.IsZero && bignum.IsNegative) || bignum.IsInfinity() ||           bignum.IsNaN()"  is complex.
Complex Conditional,PeterO.Cbor,CBORObject,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORObject.cs,Write,The conditional expression  "(bignum.IsZero && bignum.IsNegative) || bignum.IsInfinity() ||           bignum.IsNaN()"  is complex.
Complex Conditional,PeterO.Cbor,CBORObject,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORObject.cs,CompareTo,The conditional expression  "typeA == CBORObjectTypeExtendedFloat || typeB ==                     CBORObjectTypeExtendedFloat ||                     typeA == CBORObjectTypeDouble || typeB ==                     CBORObjectTypeDouble ||                     typeA == CBORObjectTypeSingle || typeB ==                     CBORObjectTypeSingle"  is complex.
Complex Conditional,PeterO.Cbor,CBORObject,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORObject.cs,EncodeToBytes,The conditional expression  "taggedItem.IsTagged || this.tagHigh != 0 ||             (this.tagLow >> 16) != 0 || this.tagLow >= 24"  is complex.
Complex Conditional,PeterO.Cbor,CBORObject,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORObject.cs,WriteStreamedString,The conditional expression  "(c & 0xfc00) == 0xd800 && index + 1 < str.Length &&               str[index + 1] >= 0xdc00 && str[index + 1] <= 0xdfff"  is complex.
Complex Conditional,PeterO.Cbor,CBORObjectMath,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORObjectMath.cs,Addition,The conditional expression  "(valueA < 0 && valueB < Int64.MinValue - valueA) ||                 (valueA > 0 && valueB > Int64.MaxValue - valueA)"  is complex.
Complex Conditional,PeterO.Cbor,CBORObjectMath,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORObjectMath.cs,Addition,The conditional expression  "typeA == CBORObject.CBORObjectTypeExtendedFloat || typeB ==       CBORObject.CBORObjectTypeExtendedFloat ||                typeA == CBORObject.CBORObjectTypeDouble || typeB ==                CBORObject.CBORObjectTypeDouble ||                typeA == CBORObject.CBORObjectTypeSingle || typeB ==                CBORObject.CBORObjectTypeSingle"  is complex.
Complex Conditional,PeterO.Cbor,CBORObjectMath,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORObjectMath.cs,Subtract,The conditional expression  "(valueB < 0 && Int64.MaxValue + valueB < valueA) ||                 (valueB > 0 && Int64.MinValue + valueB > valueA)"  is complex.
Complex Conditional,PeterO.Cbor,CBORObjectMath,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORObjectMath.cs,Subtract,The conditional expression  "typeA == CBORObject.CBORObjectTypeExtendedFloat || typeB ==       CBORObject.CBORObjectTypeExtendedFloat ||                typeA == CBORObject.CBORObjectTypeDouble || typeB ==                CBORObject.CBORObjectTypeDouble ||                typeA == CBORObject.CBORObjectTypeSingle || typeB ==                CBORObject.CBORObjectTypeSingle"  is complex.
Complex Conditional,PeterO.Cbor,CBORObjectMath,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORObjectMath.cs,Multiply,The conditional expression  "(apos && ((!bpos && (Int64.MinValue / valueA) > valueB) ||           (bpos && valueA > (Int64.MaxValue / valueB)))) ||           (!apos && ((!bpos && valueA != 0L &&           (Int64.MaxValue / valueA) > valueB) ||           (bpos && valueA < (Int64.MinValue / valueB))))"  is complex.
Complex Conditional,PeterO.Cbor,CBORObjectMath,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORObjectMath.cs,Multiply,The conditional expression  "typeA == CBORObject.CBORObjectTypeExtendedFloat || typeB ==       CBORObject.CBORObjectTypeExtendedFloat ||                typeA == CBORObject.CBORObjectTypeDouble || typeB ==                CBORObject.CBORObjectTypeDouble ||                typeA == CBORObject.CBORObjectTypeSingle || typeB ==                CBORObject.CBORObjectTypeSingle"  is complex.
Complex Conditional,PeterO.Cbor,CBORObjectMath,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORObjectMath.cs,Divide,The conditional expression  "typeA == CBORObject.CBORObjectTypeExtendedFloat || typeB ==       CBORObject.CBORObjectTypeExtendedFloat ||                typeA == CBORObject.CBORObjectTypeDouble || typeB ==                CBORObject.CBORObjectTypeDouble ||                typeA == CBORObject.CBORObjectTypeSingle || typeB ==                CBORObject.CBORObjectTypeSingle"  is complex.
Complex Conditional,PeterO.Cbor,CBORObjectMath,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORObjectMath.cs,Remainder,The conditional expression  "typeA == CBORObject.CBORObjectTypeExtendedFloat || typeB ==       CBORObject.CBORObjectTypeExtendedFloat ||                typeA == CBORObject.CBORObjectTypeDouble || typeB ==                CBORObject.CBORObjectTypeDouble ||                typeA == CBORObject.CBORObjectTypeSingle || typeB ==                CBORObject.CBORObjectTypeSingle"  is complex.
Complex Conditional,PeterO.Cbor,CBORReader,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORReader.cs,ReadForFirstByte,The conditional expression  "firstbyte >= 0xe0 && firstbyte <= 0xff && firstbyte != 0xf9 &&         firstbyte != 0xfa && firstbyte != 0xfb"  is complex.
Complex Conditional,PeterO.Cbor,CharacterReader,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CharacterReader.cs,ReadChar,The conditional expression  "(c & 0xfc00) == 0xd800 && this.offset + 1 < this.strLength &&                 this.str[this.offset + 1] >= 0xdc00 && this.str[this.offset + 1]                 <= 0xdfff"  is complex.
Complex Conditional,PeterO.Cbor,CharacterReader,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CharacterReader.cs,DetectUtf8Or16Or32,The conditional expression  "c2 == 0 &&            ((c3 == 0xfe && c4 == 0xff) ||             (c3 == 0 && c4 >= 0x01 && c4 <= 0x7f))"  is complex.
Complex Conditional,PeterO.Cbor,FastInteger2,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\FastInteger2.cs,Multiply,The conditional expression  "(apos && ((!bpos && (Int32.MinValue / this.smallValue) > val) ||                     (bpos && this.smallValue > (Int32.MaxValue / val)))) ||               (!apos && ((!bpos && this.smallValue != 0L &&                     (Int32.MaxValue / this.smallValue) > val) ||                     (bpos && this.smallValue < (Int32.MinValue / val))))"  is complex.
Complex Conditional,PeterO.Cbor,FastInteger2,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\FastInteger2.cs,Subtract,The conditional expression  "(vsv < 0 && Int32.MaxValue + vsv < this.smallValue) ||                 (vsv > 0 && Int32.MinValue + vsv > this.smallValue)"  is complex.
Complex Conditional,PeterO.Cbor,FastInteger2,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\FastInteger2.cs,SubtractInt,The conditional expression  "(val < 0 && Int32.MaxValue + val < this.smallValue) ||                 (val > 0 && Int32.MinValue + val > this.smallValue)"  is complex.
Complex Conditional,PeterO.Cbor,FastInteger2,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\FastInteger2.cs,Add,The conditional expression  "(this.smallValue < 0 && (int)val.smallValue < Int32.MinValue             - this.smallValue) ||                 (this.smallValue > 0 && (int)val.smallValue > Int32.MaxValue                 - this.smallValue)"  is complex.
Complex Conditional,PeterO.Cbor,FastInteger2,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\FastInteger2.cs,AddInt,The conditional expression  "(this.smallValue < 0 && (int)val < Int32.MinValue -         this.smallValue) || (this.smallValue > 0 && (int)val >             Int32.MaxValue - this.smallValue)"  is complex.
Complex Conditional,PeterO.Cbor,PropertyMap,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\PropertyMap.cs,GetPropertyList,The conditional expression  "pi.CanRead && (pi.CanWrite || anonymous) &&           pi.GetIndexParameters().Length == 0"  is complex.
Complex Conditional,PeterO.Cbor,PropertyMap,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\PropertyMap.cs,GetPropertyList,The conditional expression  "pd.Name.Length >= 3 && pd.Name[0] == 'I' && pd.Name[1] == 's' &&                 pd.Name[2] >= 'A' && pd.Name[2] == 'Z'"  is complex.
Complex Conditional,PeterO.Cbor,URIUtility,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\URIUtility.cs,escapeURI,The conditional expression  "(c & 0xfc00) == 0xd800 && index + 1 < valueSLength &&             s[index + 1] >= 0xdc00 && s[index + 1] <= 0xdfff"  is complex.
Complex Conditional,PeterO.Cbor,URIUtility,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\URIUtility.cs,escapeURI,The conditional expression  "c >= 0x7f || c <= 0x20 ||               ((c & 0x7f) == c && "{}|^\\`<>\"".IndexOf((char)c) >= 0)"  is complex.
Complex Conditional,PeterO.Cbor,URIUtility,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\URIUtility.cs,isValidCurieReference,The conditional expression  "(c & 0xfc00) == 0xd800 && index + 1 < valueSLength &&             s[index + 1] >= 0xdc00 && s[index + 1] <= 0xdfff"  is complex.
Complex Conditional,PeterO.Cbor,URIUtility,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\URIUtility.cs,normalizePath,The conditional expression  "(index + 3 <= len && c == '/' && path[index + 1] == '.' &&              path[index + 2] == '/') || (index + 2 == len && c == '.' &&              path[index + 1] == '.')"  is complex.
Complex Conditional,PeterO.Cbor,URIUtility,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\URIUtility.cs,normalizePath,The conditional expression  "index + 3 <= len && c == '.' &&             path[index + 1] == '.' && path[index + 2] == '/'"  is complex.
Complex Conditional,PeterO.Cbor,URIUtility,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\URIUtility.cs,normalizePath,The conditional expression  "(index + 2 <= len && c == '.' &&              path[index + 1] == '/') || (index + 1 == len && c == '.')"  is complex.
Complex Conditional,PeterO.Cbor,URIUtility,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\URIUtility.cs,normalizePath,The conditional expression  "index + 3 == len && c == '/' &&             path[index + 1] == '.' && path[index + 2] == '.'"  is complex.
Complex Conditional,PeterO.Cbor,URIUtility,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\URIUtility.cs,normalizePath,The conditional expression  "index + 4 <= len && c == '/' && path[index + 1] == '.' &&             path[index + 2] == '.' && path[index + 3] == '/'"  is complex.
Complex Conditional,PeterO.Cbor,URIUtility,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\URIUtility.cs,parseDecOctet,The conditional expression  "c >= '1' && c <= '9' && index + 2 < endOffset &&           s[index + 1] >= '0' && s[index + 1] <= '9' &&           s[index + 2] == delim"  is complex.
Complex Conditional,PeterO.Cbor,URIUtility,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\URIUtility.cs,parseDecOctet,The conditional expression  "c == '2' && index + 3 < endOffset &&        (s[index + 1] == '5') && (s[index + 2] >= '0' && s[index + 2] <= '5') &&           s[index + 3] == delim"  is complex.
Complex Conditional,PeterO.Cbor,URIUtility,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\URIUtility.cs,parseDecOctet,The conditional expression  "c == '2' && index + 3 < endOffset &&           s[index + 1] >= '0' && s[index + 1] <= '4' &&           s[index + 2] >= '0' && s[index + 2] <= '9' &&           s[index + 3] == delim"  is complex.
Complex Conditional,PeterO.Cbor,URIUtility,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\URIUtility.cs,parseDecOctet,The conditional expression  "c == '1' && index + 3 < endOffset &&           s[index + 1] >= '0' && s[index + 1] <= '9' &&           s[index + 2] >= '0' && s[index + 2] <= '9' &&           s[index + 3] == delim"  is complex.
Complex Conditional,PeterO.Cbor,URIUtility,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\URIUtility.cs,parseIPLiteral,The conditional expression  "(c >= 'a' && c <= 'z') || (c >= 'A' && c <= 'Z') ||               (c >= '0' && c <= '9') ||               ((c & 0x7F) == c && ":-._~!$&'()*+';=".IndexOf(c) >= 0)"  is complex.
Complex Conditional,PeterO.Cbor,URIUtility,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\URIUtility.cs,parseIPLiteral,The conditional expression  "(c >= '0' && c <= '9') && !expectColon &&               (phased || (phase1 + (phased ? 1 : 0) + phase2) == 6)"  is complex.
Complex Conditional,PeterO.Cbor,URIUtility,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\URIUtility.cs,parseIPLiteral,The conditional expression  "(c >= 'a' && c <= 'z') || (c >= 'A' && c <= 'Z') ||              (c >= '0' && c <= '9') || c == '.' || c == '_' || c == '-' ||                 c == '~'"  is complex.
Complex Conditional,PeterO.Cbor,URIUtility,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\URIUtility.cs,splitIRI,The conditional expression  "strict && index == offset && !((c >= 'a' && c <= 'z') ||                 (c >= 'A' && c <= 'Z'))"  is complex.
Complex Conditional,PeterO.Cbor,URIUtility,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\URIUtility.cs,splitIRI,The conditional expression  "strict && index > offset &&         !((c >= 'a' && c <= 'z') || (c >= 'A' && c <= 'Z') || (c >= '0' &&               c <= '9') || c == '+' || c == '-' || c == '.')"  is complex.
Complex Conditional,PeterO.Cbor,URIUtility,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\URIUtility.cs,splitIRI,The conditional expression  "!strict && (c == '#' || c == ':' || c == '?' || c == '/')"  is complex.
Complex Conditional,PeterO.Cbor,URIUtility,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\URIUtility.cs,splitIRI,The conditional expression  "(c & 0xfc00) == 0xd800 && index + 1 < valueSLength &&               s[index + 1] >= 0xdc00 && s[index + 1] <= 0xdfff"  is complex.
Complex Conditional,PeterO.Cbor,URIUtility,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\URIUtility.cs,splitIRI,The conditional expression  "c == '%' && (state == 0 || state == 1) && strict"  is complex.
Complex Conditional,PeterO.Cbor,URIUtility,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\URIUtility.cs,splitIRI,The conditional expression  "(c & 0xfc00) == 0xd800 && index + 1 < valueSLength &&             s[index + 1] >= 0xdc00 && s[index + 1] <= 0xdfff"  is complex.
Complex Conditional,PeterO.Cbor,URIUtility,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\URIUtility.cs,splitIRI,The conditional expression  "strict && fullyRelative && colon && !segment"  is complex.
Magic Number,PeterO,DataUtilities,C:\repos\peteroupc_CBOR\CBOR\PeterO\DataUtilities.cs,GetUtf8Bytes,The following statement contains a magic number: if (!lenientLineBreaks && str.Length == 1) {         int c = str[0];         if ((c & 0xf800) == 0xd800) {           if (replace) {  c = 0xfffd; } else {  throw new ArgumentException("Unpaired surrogate code point"); }         }         if (c <= 0x80) {           return new byte[] { (byte)c };         } else if (c <= 0x7ff) {           return new byte[] { (byte)(0xc0 | ((c >> 6) & 0x1f))'             (byte)(0x80 | (c & 0x3f)) };         } else {           return new byte[] { (byte)(0xe0 | ((c >> 12) & 0x0f))'             (byte)(0x80 | ((c >> 6) & 0x3f))'             (byte)(0x80 | (c & 0x3f)) };         }       } else if (str.Length == 2) {         int c = str[0];         int c2 = str[1];         if ((c & 0xfc00) == 0xd800 && (c2 & 0xfc00) == 0xdc00) {           c = 0x10000 + ((c - 0xd800) << 10) + (c2 - 0xdc00);           return new byte[] { (byte)(0xf0 | ((c >> 18) & 0x07))'             (byte)(0x80 | ((c >> 12) & 0x3f))'             (byte)(0x80 | ((c >> 6) & 0x3f))'             (byte)(0x80 | (c & 0x3f)) };         } else if (!lenientLineBreaks && c <= 0x80 && c2 <= 0x80) {           return new byte[] { (byte)c' (byte)c2 };         }       }
Magic Number,PeterO,DataUtilities,C:\repos\peteroupc_CBOR\CBOR\PeterO\DataUtilities.cs,GetUtf8Bytes,The following statement contains a magic number: if (!lenientLineBreaks && str.Length == 1) {         int c = str[0];         if ((c & 0xf800) == 0xd800) {           if (replace) {  c = 0xfffd; } else {  throw new ArgumentException("Unpaired surrogate code point"); }         }         if (c <= 0x80) {           return new byte[] { (byte)c };         } else if (c <= 0x7ff) {           return new byte[] { (byte)(0xc0 | ((c >> 6) & 0x1f))'             (byte)(0x80 | (c & 0x3f)) };         } else {           return new byte[] { (byte)(0xe0 | ((c >> 12) & 0x0f))'             (byte)(0x80 | ((c >> 6) & 0x3f))'             (byte)(0x80 | (c & 0x3f)) };         }       } else if (str.Length == 2) {         int c = str[0];         int c2 = str[1];         if ((c & 0xfc00) == 0xd800 && (c2 & 0xfc00) == 0xdc00) {           c = 0x10000 + ((c - 0xd800) << 10) + (c2 - 0xdc00);           return new byte[] { (byte)(0xf0 | ((c >> 18) & 0x07))'             (byte)(0x80 | ((c >> 12) & 0x3f))'             (byte)(0x80 | ((c >> 6) & 0x3f))'             (byte)(0x80 | (c & 0x3f)) };         } else if (!lenientLineBreaks && c <= 0x80 && c2 <= 0x80) {           return new byte[] { (byte)c' (byte)c2 };         }       }
Magic Number,PeterO,DataUtilities,C:\repos\peteroupc_CBOR\CBOR\PeterO\DataUtilities.cs,GetUtf8Bytes,The following statement contains a magic number: if (!lenientLineBreaks && str.Length == 1) {         int c = str[0];         if ((c & 0xf800) == 0xd800) {           if (replace) {  c = 0xfffd; } else {  throw new ArgumentException("Unpaired surrogate code point"); }         }         if (c <= 0x80) {           return new byte[] { (byte)c };         } else if (c <= 0x7ff) {           return new byte[] { (byte)(0xc0 | ((c >> 6) & 0x1f))'             (byte)(0x80 | (c & 0x3f)) };         } else {           return new byte[] { (byte)(0xe0 | ((c >> 12) & 0x0f))'             (byte)(0x80 | ((c >> 6) & 0x3f))'             (byte)(0x80 | (c & 0x3f)) };         }       } else if (str.Length == 2) {         int c = str[0];         int c2 = str[1];         if ((c & 0xfc00) == 0xd800 && (c2 & 0xfc00) == 0xdc00) {           c = 0x10000 + ((c - 0xd800) << 10) + (c2 - 0xdc00);           return new byte[] { (byte)(0xf0 | ((c >> 18) & 0x07))'             (byte)(0x80 | ((c >> 12) & 0x3f))'             (byte)(0x80 | ((c >> 6) & 0x3f))'             (byte)(0x80 | (c & 0x3f)) };         } else if (!lenientLineBreaks && c <= 0x80 && c2 <= 0x80) {           return new byte[] { (byte)c' (byte)c2 };         }       }
Magic Number,PeterO,DataUtilities,C:\repos\peteroupc_CBOR\CBOR\PeterO\DataUtilities.cs,GetUtf8Bytes,The following statement contains a magic number: if (!lenientLineBreaks && str.Length == 1) {         int c = str[0];         if ((c & 0xf800) == 0xd800) {           if (replace) {  c = 0xfffd; } else {  throw new ArgumentException("Unpaired surrogate code point"); }         }         if (c <= 0x80) {           return new byte[] { (byte)c };         } else if (c <= 0x7ff) {           return new byte[] { (byte)(0xc0 | ((c >> 6) & 0x1f))'             (byte)(0x80 | (c & 0x3f)) };         } else {           return new byte[] { (byte)(0xe0 | ((c >> 12) & 0x0f))'             (byte)(0x80 | ((c >> 6) & 0x3f))'             (byte)(0x80 | (c & 0x3f)) };         }       } else if (str.Length == 2) {         int c = str[0];         int c2 = str[1];         if ((c & 0xfc00) == 0xd800 && (c2 & 0xfc00) == 0xdc00) {           c = 0x10000 + ((c - 0xd800) << 10) + (c2 - 0xdc00);           return new byte[] { (byte)(0xf0 | ((c >> 18) & 0x07))'             (byte)(0x80 | ((c >> 12) & 0x3f))'             (byte)(0x80 | ((c >> 6) & 0x3f))'             (byte)(0x80 | (c & 0x3f)) };         } else if (!lenientLineBreaks && c <= 0x80 && c2 <= 0x80) {           return new byte[] { (byte)c' (byte)c2 };         }       }
Magic Number,PeterO,DataUtilities,C:\repos\peteroupc_CBOR\CBOR\PeterO\DataUtilities.cs,GetUtf8Bytes,The following statement contains a magic number: if (!lenientLineBreaks && str.Length == 1) {         int c = str[0];         if ((c & 0xf800) == 0xd800) {           if (replace) {  c = 0xfffd; } else {  throw new ArgumentException("Unpaired surrogate code point"); }         }         if (c <= 0x80) {           return new byte[] { (byte)c };         } else if (c <= 0x7ff) {           return new byte[] { (byte)(0xc0 | ((c >> 6) & 0x1f))'             (byte)(0x80 | (c & 0x3f)) };         } else {           return new byte[] { (byte)(0xe0 | ((c >> 12) & 0x0f))'             (byte)(0x80 | ((c >> 6) & 0x3f))'             (byte)(0x80 | (c & 0x3f)) };         }       } else if (str.Length == 2) {         int c = str[0];         int c2 = str[1];         if ((c & 0xfc00) == 0xd800 && (c2 & 0xfc00) == 0xdc00) {           c = 0x10000 + ((c - 0xd800) << 10) + (c2 - 0xdc00);           return new byte[] { (byte)(0xf0 | ((c >> 18) & 0x07))'             (byte)(0x80 | ((c >> 12) & 0x3f))'             (byte)(0x80 | ((c >> 6) & 0x3f))'             (byte)(0x80 | (c & 0x3f)) };         } else if (!lenientLineBreaks && c <= 0x80 && c2 <= 0x80) {           return new byte[] { (byte)c' (byte)c2 };         }       }
Magic Number,PeterO,DataUtilities,C:\repos\peteroupc_CBOR\CBOR\PeterO\DataUtilities.cs,GetUtf8Bytes,The following statement contains a magic number: if (!lenientLineBreaks && str.Length == 1) {         int c = str[0];         if ((c & 0xf800) == 0xd800) {           if (replace) {  c = 0xfffd; } else {  throw new ArgumentException("Unpaired surrogate code point"); }         }         if (c <= 0x80) {           return new byte[] { (byte)c };         } else if (c <= 0x7ff) {           return new byte[] { (byte)(0xc0 | ((c >> 6) & 0x1f))'             (byte)(0x80 | (c & 0x3f)) };         } else {           return new byte[] { (byte)(0xe0 | ((c >> 12) & 0x0f))'             (byte)(0x80 | ((c >> 6) & 0x3f))'             (byte)(0x80 | (c & 0x3f)) };         }       } else if (str.Length == 2) {         int c = str[0];         int c2 = str[1];         if ((c & 0xfc00) == 0xd800 && (c2 & 0xfc00) == 0xdc00) {           c = 0x10000 + ((c - 0xd800) << 10) + (c2 - 0xdc00);           return new byte[] { (byte)(0xf0 | ((c >> 18) & 0x07))'             (byte)(0x80 | ((c >> 12) & 0x3f))'             (byte)(0x80 | ((c >> 6) & 0x3f))'             (byte)(0x80 | (c & 0x3f)) };         } else if (!lenientLineBreaks && c <= 0x80 && c2 <= 0x80) {           return new byte[] { (byte)c' (byte)c2 };         }       }
Magic Number,PeterO,DataUtilities,C:\repos\peteroupc_CBOR\CBOR\PeterO\DataUtilities.cs,GetUtf8Bytes,The following statement contains a magic number: if (!lenientLineBreaks && str.Length == 1) {         int c = str[0];         if ((c & 0xf800) == 0xd800) {           if (replace) {  c = 0xfffd; } else {  throw new ArgumentException("Unpaired surrogate code point"); }         }         if (c <= 0x80) {           return new byte[] { (byte)c };         } else if (c <= 0x7ff) {           return new byte[] { (byte)(0xc0 | ((c >> 6) & 0x1f))'             (byte)(0x80 | (c & 0x3f)) };         } else {           return new byte[] { (byte)(0xe0 | ((c >> 12) & 0x0f))'             (byte)(0x80 | ((c >> 6) & 0x3f))'             (byte)(0x80 | (c & 0x3f)) };         }       } else if (str.Length == 2) {         int c = str[0];         int c2 = str[1];         if ((c & 0xfc00) == 0xd800 && (c2 & 0xfc00) == 0xdc00) {           c = 0x10000 + ((c - 0xd800) << 10) + (c2 - 0xdc00);           return new byte[] { (byte)(0xf0 | ((c >> 18) & 0x07))'             (byte)(0x80 | ((c >> 12) & 0x3f))'             (byte)(0x80 | ((c >> 6) & 0x3f))'             (byte)(0x80 | (c & 0x3f)) };         } else if (!lenientLineBreaks && c <= 0x80 && c2 <= 0x80) {           return new byte[] { (byte)c' (byte)c2 };         }       }
Magic Number,PeterO,DataUtilities,C:\repos\peteroupc_CBOR\CBOR\PeterO\DataUtilities.cs,GetUtf8Bytes,The following statement contains a magic number: if (!lenientLineBreaks && str.Length == 1) {         int c = str[0];         if ((c & 0xf800) == 0xd800) {           if (replace) {  c = 0xfffd; } else {  throw new ArgumentException("Unpaired surrogate code point"); }         }         if (c <= 0x80) {           return new byte[] { (byte)c };         } else if (c <= 0x7ff) {           return new byte[] { (byte)(0xc0 | ((c >> 6) & 0x1f))'             (byte)(0x80 | (c & 0x3f)) };         } else {           return new byte[] { (byte)(0xe0 | ((c >> 12) & 0x0f))'             (byte)(0x80 | ((c >> 6) & 0x3f))'             (byte)(0x80 | (c & 0x3f)) };         }       } else if (str.Length == 2) {         int c = str[0];         int c2 = str[1];         if ((c & 0xfc00) == 0xd800 && (c2 & 0xfc00) == 0xdc00) {           c = 0x10000 + ((c - 0xd800) << 10) + (c2 - 0xdc00);           return new byte[] { (byte)(0xf0 | ((c >> 18) & 0x07))'             (byte)(0x80 | ((c >> 12) & 0x3f))'             (byte)(0x80 | ((c >> 6) & 0x3f))'             (byte)(0x80 | (c & 0x3f)) };         } else if (!lenientLineBreaks && c <= 0x80 && c2 <= 0x80) {           return new byte[] { (byte)c' (byte)c2 };         }       }
Magic Number,PeterO,DataUtilities,C:\repos\peteroupc_CBOR\CBOR\PeterO\DataUtilities.cs,GetUtf8Length,The following statement contains a magic number: for (var i = 0; i < str.Length; ++i) {         int c = str[i];         if (c <= 0x7f) {           ++size;         } else if (c <= 0x7ff) {           size += 2;         } else if (c <= 0xd7ff || c >= 0xe000) {           size += 3;         } else if (c <= 0xdbff) {  // UTF-16 leading surrogate           ++i;           if (i >= str.Length || str[i] < 0xdc00 || str[i] > 0xdfff) {             if (replace) {               size += 3;               --i;             } else {               return -1;             }           } else {             size += 4;           }         } else {           if (replace) {             size += 3;           } else {             return -1;           }         }       }
Magic Number,PeterO,DataUtilities,C:\repos\peteroupc_CBOR\CBOR\PeterO\DataUtilities.cs,GetUtf8Length,The following statement contains a magic number: for (var i = 0; i < str.Length; ++i) {         int c = str[i];         if (c <= 0x7f) {           ++size;         } else if (c <= 0x7ff) {           size += 2;         } else if (c <= 0xd7ff || c >= 0xe000) {           size += 3;         } else if (c <= 0xdbff) {  // UTF-16 leading surrogate           ++i;           if (i >= str.Length || str[i] < 0xdc00 || str[i] > 0xdfff) {             if (replace) {               size += 3;               --i;             } else {               return -1;             }           } else {             size += 4;           }         } else {           if (replace) {             size += 3;           } else {             return -1;           }         }       }
Magic Number,PeterO,DataUtilities,C:\repos\peteroupc_CBOR\CBOR\PeterO\DataUtilities.cs,GetUtf8Length,The following statement contains a magic number: for (var i = 0; i < str.Length; ++i) {         int c = str[i];         if (c <= 0x7f) {           ++size;         } else if (c <= 0x7ff) {           size += 2;         } else if (c <= 0xd7ff || c >= 0xe000) {           size += 3;         } else if (c <= 0xdbff) {  // UTF-16 leading surrogate           ++i;           if (i >= str.Length || str[i] < 0xdc00 || str[i] > 0xdfff) {             if (replace) {               size += 3;               --i;             } else {               return -1;             }           } else {             size += 4;           }         } else {           if (replace) {             size += 3;           } else {             return -1;           }         }       }
Magic Number,PeterO,DataUtilities,C:\repos\peteroupc_CBOR\CBOR\PeterO\DataUtilities.cs,GetUtf8Length,The following statement contains a magic number: for (var i = 0; i < str.Length; ++i) {         int c = str[i];         if (c <= 0x7f) {           ++size;         } else if (c <= 0x7ff) {           size += 2;         } else if (c <= 0xd7ff || c >= 0xe000) {           size += 3;         } else if (c <= 0xdbff) {  // UTF-16 leading surrogate           ++i;           if (i >= str.Length || str[i] < 0xdc00 || str[i] > 0xdfff) {             if (replace) {               size += 3;               --i;             } else {               return -1;             }           } else {             size += 4;           }         } else {           if (replace) {             size += 3;           } else {             return -1;           }         }       }
Magic Number,PeterO,DataUtilities,C:\repos\peteroupc_CBOR\CBOR\PeterO\DataUtilities.cs,GetUtf8Length,The following statement contains a magic number: for (var i = 0; i < str.Length; ++i) {         int c = str[i];         if (c <= 0x7f) {           ++size;         } else if (c <= 0x7ff) {           size += 2;         } else if (c <= 0xd7ff || c >= 0xe000) {           size += 3;         } else if (c <= 0xdbff) {  // UTF-16 leading surrogate           ++i;           if (i >= str.Length || str[i] < 0xdc00 || str[i] > 0xdfff) {             if (replace) {               size += 3;               --i;             } else {               return -1;             }           } else {             size += 4;           }         } else {           if (replace) {             size += 3;           } else {             return -1;           }         }       }
Magic Number,PeterO,DataUtilities,C:\repos\peteroupc_CBOR\CBOR\PeterO\DataUtilities.cs,CodePointBefore,The following statement contains a magic number: if ((c & 0xfc00) == 0xdc00 && index - 2 >= 0 &&           str[index - 2] >= 0xd800 && str[index - 2] <= 0xdbff) {         // Get the Unicode code point for the surrogate pair         return 0x10000 + ((str[index - 2] - 0xd800) << 10) + (c - 0xdc00);       }
Magic Number,PeterO,DataUtilities,C:\repos\peteroupc_CBOR\CBOR\PeterO\DataUtilities.cs,CodePointBefore,The following statement contains a magic number: if ((c & 0xfc00) == 0xdc00 && index - 2 >= 0 &&           str[index - 2] >= 0xd800 && str[index - 2] <= 0xdbff) {         // Get the Unicode code point for the surrogate pair         return 0x10000 + ((str[index - 2] - 0xd800) << 10) + (c - 0xdc00);       }
Magic Number,PeterO,DataUtilities,C:\repos\peteroupc_CBOR\CBOR\PeterO\DataUtilities.cs,CodePointBefore,The following statement contains a magic number: if ((c & 0xfc00) == 0xdc00 && index - 2 >= 0 &&           str[index - 2] >= 0xd800 && str[index - 2] <= 0xdbff) {         // Get the Unicode code point for the surrogate pair         return 0x10000 + ((str[index - 2] - 0xd800) << 10) + (c - 0xdc00);       }
Magic Number,PeterO,DataUtilities,C:\repos\peteroupc_CBOR\CBOR\PeterO\DataUtilities.cs,CodePointBefore,The following statement contains a magic number: if ((c & 0xfc00) == 0xdc00 && index - 2 >= 0 &&           str[index - 2] >= 0xd800 && str[index - 2] <= 0xdbff) {         // Get the Unicode code point for the surrogate pair         return 0x10000 + ((str[index - 2] - 0xd800) << 10) + (c - 0xdc00);       }
Magic Number,PeterO,DataUtilities,C:\repos\peteroupc_CBOR\CBOR\PeterO\DataUtilities.cs,CodePointBefore,The following statement contains a magic number: if ((c & 0xfc00) == 0xdc00 && index - 2 >= 0 &&           str[index - 2] >= 0xd800 && str[index - 2] <= 0xdbff) {         // Get the Unicode code point for the surrogate pair         return 0x10000 + ((str[index - 2] - 0xd800) << 10) + (c - 0xdc00);       }
Magic Number,PeterO,DataUtilities,C:\repos\peteroupc_CBOR\CBOR\PeterO\DataUtilities.cs,CodePointAt,The following statement contains a magic number: if ((c & 0xfc00) == 0xd800 && index + 1 < str.Length &&           str[index + 1] >= 0xdc00 && str[index + 1] <= 0xdfff) {         // Get the Unicode code point for the surrogate pair         c = 0x10000 + ((c - 0xd800) << 10) + (str[index + 1] - 0xdc00);         ++index;       } else if ((c & 0xf800) == 0xd800) {         // unpaired surrogate         return (surrogateBehavior == 0) ? 0xfffd : ((surrogateBehavior == 1) ?                     c : (-1));       }
Magic Number,PeterO,DataUtilities,C:\repos\peteroupc_CBOR\CBOR\PeterO\DataUtilities.cs,CodePointCompare,The following statement contains a magic number: for (var i = 0; i < len; ++i) {          ca = strA[i];          cb = strB[i];         if (ca == cb) {           // normal code units and illegal surrogates           // are treated as single code points           if ((ca & 0xf800) != 0xd800) {             continue;           }           var incindex = false;           if (i + 1 < strA.Length && strA[i + 1] >= 0xdc00 && strA[i + 1] <=               0xdfff) {             ca = 0x10000 + ((ca - 0xd800) << 10) + (strA[i + 1] - 0xdc00);             incindex = true;           }           if (i + 1 < strB.Length && strB[i + 1] >= 0xdc00 && strB[i + 1] <=               0xdfff) {             cb = 0x10000 + ((cb - 0xd800) << 10) + (strB[i + 1] - 0xdc00);             incindex = true;           }           if (ca != cb) {             return ca - cb;           }           if (incindex) {             ++i;           }         } else {           if ((ca & 0xf800) != 0xd800 && (cb & 0xf800) != 0xd800) {             return ca - cb;           }           if ((ca & 0xfc00) == 0xd800 && i + 1 < strA.Length &&               strA[i + 1] >= 0xdc00 && strA[i + 1] <= 0xdfff) {             ca = 0x10000 + ((ca - 0xd800) << 10) + (strA[i + 1] - 0xdc00);           }           if ((cb & 0xfc00) == 0xd800 && i + 1 < strB.Length &&               strB[i + 1] >= 0xdc00 && strB[i + 1] <= 0xdfff) {             cb = 0x10000 + ((cb - 0xd800) << 10) + (strB[i + 1] - 0xdc00);           }           return ca - cb;         }       }
Magic Number,PeterO,DataUtilities,C:\repos\peteroupc_CBOR\CBOR\PeterO\DataUtilities.cs,CodePointCompare,The following statement contains a magic number: for (var i = 0; i < len; ++i) {          ca = strA[i];          cb = strB[i];         if (ca == cb) {           // normal code units and illegal surrogates           // are treated as single code points           if ((ca & 0xf800) != 0xd800) {             continue;           }           var incindex = false;           if (i + 1 < strA.Length && strA[i + 1] >= 0xdc00 && strA[i + 1] <=               0xdfff) {             ca = 0x10000 + ((ca - 0xd800) << 10) + (strA[i + 1] - 0xdc00);             incindex = true;           }           if (i + 1 < strB.Length && strB[i + 1] >= 0xdc00 && strB[i + 1] <=               0xdfff) {             cb = 0x10000 + ((cb - 0xd800) << 10) + (strB[i + 1] - 0xdc00);             incindex = true;           }           if (ca != cb) {             return ca - cb;           }           if (incindex) {             ++i;           }         } else {           if ((ca & 0xf800) != 0xd800 && (cb & 0xf800) != 0xd800) {             return ca - cb;           }           if ((ca & 0xfc00) == 0xd800 && i + 1 < strA.Length &&               strA[i + 1] >= 0xdc00 && strA[i + 1] <= 0xdfff) {             ca = 0x10000 + ((ca - 0xd800) << 10) + (strA[i + 1] - 0xdc00);           }           if ((cb & 0xfc00) == 0xd800 && i + 1 < strB.Length &&               strB[i + 1] >= 0xdc00 && strB[i + 1] <= 0xdfff) {             cb = 0x10000 + ((cb - 0xd800) << 10) + (strB[i + 1] - 0xdc00);           }           return ca - cb;         }       }
Magic Number,PeterO,DataUtilities,C:\repos\peteroupc_CBOR\CBOR\PeterO\DataUtilities.cs,CodePointCompare,The following statement contains a magic number: for (var i = 0; i < len; ++i) {          ca = strA[i];          cb = strB[i];         if (ca == cb) {           // normal code units and illegal surrogates           // are treated as single code points           if ((ca & 0xf800) != 0xd800) {             continue;           }           var incindex = false;           if (i + 1 < strA.Length && strA[i + 1] >= 0xdc00 && strA[i + 1] <=               0xdfff) {             ca = 0x10000 + ((ca - 0xd800) << 10) + (strA[i + 1] - 0xdc00);             incindex = true;           }           if (i + 1 < strB.Length && strB[i + 1] >= 0xdc00 && strB[i + 1] <=               0xdfff) {             cb = 0x10000 + ((cb - 0xd800) << 10) + (strB[i + 1] - 0xdc00);             incindex = true;           }           if (ca != cb) {             return ca - cb;           }           if (incindex) {             ++i;           }         } else {           if ((ca & 0xf800) != 0xd800 && (cb & 0xf800) != 0xd800) {             return ca - cb;           }           if ((ca & 0xfc00) == 0xd800 && i + 1 < strA.Length &&               strA[i + 1] >= 0xdc00 && strA[i + 1] <= 0xdfff) {             ca = 0x10000 + ((ca - 0xd800) << 10) + (strA[i + 1] - 0xdc00);           }           if ((cb & 0xfc00) == 0xd800 && i + 1 < strB.Length &&               strB[i + 1] >= 0xdc00 && strB[i + 1] <= 0xdfff) {             cb = 0x10000 + ((cb - 0xd800) << 10) + (strB[i + 1] - 0xdc00);           }           return ca - cb;         }       }
Magic Number,PeterO,DataUtilities,C:\repos\peteroupc_CBOR\CBOR\PeterO\DataUtilities.cs,CodePointCompare,The following statement contains a magic number: for (var i = 0; i < len; ++i) {          ca = strA[i];          cb = strB[i];         if (ca == cb) {           // normal code units and illegal surrogates           // are treated as single code points           if ((ca & 0xf800) != 0xd800) {             continue;           }           var incindex = false;           if (i + 1 < strA.Length && strA[i + 1] >= 0xdc00 && strA[i + 1] <=               0xdfff) {             ca = 0x10000 + ((ca - 0xd800) << 10) + (strA[i + 1] - 0xdc00);             incindex = true;           }           if (i + 1 < strB.Length && strB[i + 1] >= 0xdc00 && strB[i + 1] <=               0xdfff) {             cb = 0x10000 + ((cb - 0xd800) << 10) + (strB[i + 1] - 0xdc00);             incindex = true;           }           if (ca != cb) {             return ca - cb;           }           if (incindex) {             ++i;           }         } else {           if ((ca & 0xf800) != 0xd800 && (cb & 0xf800) != 0xd800) {             return ca - cb;           }           if ((ca & 0xfc00) == 0xd800 && i + 1 < strA.Length &&               strA[i + 1] >= 0xdc00 && strA[i + 1] <= 0xdfff) {             ca = 0x10000 + ((ca - 0xd800) << 10) + (strA[i + 1] - 0xdc00);           }           if ((cb & 0xfc00) == 0xd800 && i + 1 < strB.Length &&               strB[i + 1] >= 0xdc00 && strB[i + 1] <= 0xdfff) {             cb = 0x10000 + ((cb - 0xd800) << 10) + (strB[i + 1] - 0xdc00);           }           return ca - cb;         }       }
Magic Number,PeterO,DataUtilities,C:\repos\peteroupc_CBOR\CBOR\PeterO\DataUtilities.cs,WriteUtf8,The following statement contains a magic number: for (int index = offset; index < endIndex; ++index) {          c = str[index];         if (c <= 0x7f) {           if (lenientLineBreaks) {             if (c == 0x0d && (index + 1 >= endIndex || str[index + 1] !=                     0x0a)) {               // bare CR' convert to CRLF               if (byteIndex + 2 > StreamedStringBufferLength) {                 // Write bytes retrieved so far                 stream.Write(bytes' 0' byteIndex);                 byteIndex = 0;               }               bytes[byteIndex++] = 0x0d;               bytes[byteIndex++] = 0x0a;               continue;             } else if (c == 0x0d) {               // CR-LF pair               if (byteIndex + 2 > StreamedStringBufferLength) {                 // Write bytes retrieved so far                 stream.Write(bytes' 0' byteIndex);                 byteIndex = 0;               }               bytes[byteIndex++] = 0x0d;               bytes[byteIndex++] = 0x0a;               ++index;               continue;             }             if (c == 0x0a) {               // bare LF' convert to CRLF               if (byteIndex + 2 > StreamedStringBufferLength) {                 // Write bytes retrieved so far                 stream.Write(bytes' 0' byteIndex);                 byteIndex = 0;               }               bytes[byteIndex++] = 0x0d;               bytes[byteIndex++] = 0x0a;               continue;             }           }           if (byteIndex >= StreamedStringBufferLength) {             // Write bytes retrieved so far             stream.Write(bytes' 0' byteIndex);             byteIndex = 0;           }           bytes[byteIndex++] = (byte)c;         } else if (c <= 0x7ff) {           if (byteIndex + 2 > StreamedStringBufferLength) {             // Write bytes retrieved so far             stream.Write(bytes' 0' byteIndex);             byteIndex = 0;           }           bytes[byteIndex++] = (byte)(0xc0 | ((c >> 6) & 0x1f));           bytes[byteIndex++] = (byte)(0x80 | (c & 0x3f));         } else {           if ((c & 0xfc00) == 0xd800 && index + 1 < endIndex &&               str[index + 1] >= 0xdc00 && str[index + 1] <= 0xdfff) {             // Get the Unicode code point for the surrogate pair             c = 0x10000 + ((c - 0xd800) << 10) + (str[index + 1] - 0xdc00);             ++index;           } else if ((c & 0xf800) == 0xd800) {             // unpaired surrogate             if (!replace) {               retval = -1;               break;  // write bytes read so far             }             c = 0xfffd;           }           if (c <= 0xffff) {             if (byteIndex + 3 > StreamedStringBufferLength) {               // Write bytes retrieved so far               stream.Write(bytes' 0' byteIndex);               byteIndex = 0;             }             bytes[byteIndex++] = (byte)(0xe0 | ((c >> 12) & 0x0f));             bytes[byteIndex++] = (byte)(0x80 | ((c >> 6) & 0x3f));             bytes[byteIndex++] = (byte)(0x80 | (c & 0x3f));           } else {             if (byteIndex + 4 > StreamedStringBufferLength) {               // Write bytes retrieved so far               stream.Write(bytes' 0' byteIndex);               byteIndex = 0;             }             bytes[byteIndex++] = (byte)(0xf0 | ((c >> 18) & 0x07));             bytes[byteIndex++] = (byte)(0x80 | ((c >> 12) & 0x3f));             bytes[byteIndex++] = (byte)(0x80 | ((c >> 6) & 0x3f));             bytes[byteIndex++] = (byte)(0x80 | (c & 0x3f));           }         }       }
Magic Number,PeterO,DataUtilities,C:\repos\peteroupc_CBOR\CBOR\PeterO\DataUtilities.cs,WriteUtf8,The following statement contains a magic number: for (int index = offset; index < endIndex; ++index) {          c = str[index];         if (c <= 0x7f) {           if (lenientLineBreaks) {             if (c == 0x0d && (index + 1 >= endIndex || str[index + 1] !=                     0x0a)) {               // bare CR' convert to CRLF               if (byteIndex + 2 > StreamedStringBufferLength) {                 // Write bytes retrieved so far                 stream.Write(bytes' 0' byteIndex);                 byteIndex = 0;               }               bytes[byteIndex++] = 0x0d;               bytes[byteIndex++] = 0x0a;               continue;             } else if (c == 0x0d) {               // CR-LF pair               if (byteIndex + 2 > StreamedStringBufferLength) {                 // Write bytes retrieved so far                 stream.Write(bytes' 0' byteIndex);                 byteIndex = 0;               }               bytes[byteIndex++] = 0x0d;               bytes[byteIndex++] = 0x0a;               ++index;               continue;             }             if (c == 0x0a) {               // bare LF' convert to CRLF               if (byteIndex + 2 > StreamedStringBufferLength) {                 // Write bytes retrieved so far                 stream.Write(bytes' 0' byteIndex);                 byteIndex = 0;               }               bytes[byteIndex++] = 0x0d;               bytes[byteIndex++] = 0x0a;               continue;             }           }           if (byteIndex >= StreamedStringBufferLength) {             // Write bytes retrieved so far             stream.Write(bytes' 0' byteIndex);             byteIndex = 0;           }           bytes[byteIndex++] = (byte)c;         } else if (c <= 0x7ff) {           if (byteIndex + 2 > StreamedStringBufferLength) {             // Write bytes retrieved so far             stream.Write(bytes' 0' byteIndex);             byteIndex = 0;           }           bytes[byteIndex++] = (byte)(0xc0 | ((c >> 6) & 0x1f));           bytes[byteIndex++] = (byte)(0x80 | (c & 0x3f));         } else {           if ((c & 0xfc00) == 0xd800 && index + 1 < endIndex &&               str[index + 1] >= 0xdc00 && str[index + 1] <= 0xdfff) {             // Get the Unicode code point for the surrogate pair             c = 0x10000 + ((c - 0xd800) << 10) + (str[index + 1] - 0xdc00);             ++index;           } else if ((c & 0xf800) == 0xd800) {             // unpaired surrogate             if (!replace) {               retval = -1;               break;  // write bytes read so far             }             c = 0xfffd;           }           if (c <= 0xffff) {             if (byteIndex + 3 > StreamedStringBufferLength) {               // Write bytes retrieved so far               stream.Write(bytes' 0' byteIndex);               byteIndex = 0;             }             bytes[byteIndex++] = (byte)(0xe0 | ((c >> 12) & 0x0f));             bytes[byteIndex++] = (byte)(0x80 | ((c >> 6) & 0x3f));             bytes[byteIndex++] = (byte)(0x80 | (c & 0x3f));           } else {             if (byteIndex + 4 > StreamedStringBufferLength) {               // Write bytes retrieved so far               stream.Write(bytes' 0' byteIndex);               byteIndex = 0;             }             bytes[byteIndex++] = (byte)(0xf0 | ((c >> 18) & 0x07));             bytes[byteIndex++] = (byte)(0x80 | ((c >> 12) & 0x3f));             bytes[byteIndex++] = (byte)(0x80 | ((c >> 6) & 0x3f));             bytes[byteIndex++] = (byte)(0x80 | (c & 0x3f));           }         }       }
Magic Number,PeterO,DataUtilities,C:\repos\peteroupc_CBOR\CBOR\PeterO\DataUtilities.cs,WriteUtf8,The following statement contains a magic number: for (int index = offset; index < endIndex; ++index) {          c = str[index];         if (c <= 0x7f) {           if (lenientLineBreaks) {             if (c == 0x0d && (index + 1 >= endIndex || str[index + 1] !=                     0x0a)) {               // bare CR' convert to CRLF               if (byteIndex + 2 > StreamedStringBufferLength) {                 // Write bytes retrieved so far                 stream.Write(bytes' 0' byteIndex);                 byteIndex = 0;               }               bytes[byteIndex++] = 0x0d;               bytes[byteIndex++] = 0x0a;               continue;             } else if (c == 0x0d) {               // CR-LF pair               if (byteIndex + 2 > StreamedStringBufferLength) {                 // Write bytes retrieved so far                 stream.Write(bytes' 0' byteIndex);                 byteIndex = 0;               }               bytes[byteIndex++] = 0x0d;               bytes[byteIndex++] = 0x0a;               ++index;               continue;             }             if (c == 0x0a) {               // bare LF' convert to CRLF               if (byteIndex + 2 > StreamedStringBufferLength) {                 // Write bytes retrieved so far                 stream.Write(bytes' 0' byteIndex);                 byteIndex = 0;               }               bytes[byteIndex++] = 0x0d;               bytes[byteIndex++] = 0x0a;               continue;             }           }           if (byteIndex >= StreamedStringBufferLength) {             // Write bytes retrieved so far             stream.Write(bytes' 0' byteIndex);             byteIndex = 0;           }           bytes[byteIndex++] = (byte)c;         } else if (c <= 0x7ff) {           if (byteIndex + 2 > StreamedStringBufferLength) {             // Write bytes retrieved so far             stream.Write(bytes' 0' byteIndex);             byteIndex = 0;           }           bytes[byteIndex++] = (byte)(0xc0 | ((c >> 6) & 0x1f));           bytes[byteIndex++] = (byte)(0x80 | (c & 0x3f));         } else {           if ((c & 0xfc00) == 0xd800 && index + 1 < endIndex &&               str[index + 1] >= 0xdc00 && str[index + 1] <= 0xdfff) {             // Get the Unicode code point for the surrogate pair             c = 0x10000 + ((c - 0xd800) << 10) + (str[index + 1] - 0xdc00);             ++index;           } else if ((c & 0xf800) == 0xd800) {             // unpaired surrogate             if (!replace) {               retval = -1;               break;  // write bytes read so far             }             c = 0xfffd;           }           if (c <= 0xffff) {             if (byteIndex + 3 > StreamedStringBufferLength) {               // Write bytes retrieved so far               stream.Write(bytes' 0' byteIndex);               byteIndex = 0;             }             bytes[byteIndex++] = (byte)(0xe0 | ((c >> 12) & 0x0f));             bytes[byteIndex++] = (byte)(0x80 | ((c >> 6) & 0x3f));             bytes[byteIndex++] = (byte)(0x80 | (c & 0x3f));           } else {             if (byteIndex + 4 > StreamedStringBufferLength) {               // Write bytes retrieved so far               stream.Write(bytes' 0' byteIndex);               byteIndex = 0;             }             bytes[byteIndex++] = (byte)(0xf0 | ((c >> 18) & 0x07));             bytes[byteIndex++] = (byte)(0x80 | ((c >> 12) & 0x3f));             bytes[byteIndex++] = (byte)(0x80 | ((c >> 6) & 0x3f));             bytes[byteIndex++] = (byte)(0x80 | (c & 0x3f));           }         }       }
Magic Number,PeterO,DataUtilities,C:\repos\peteroupc_CBOR\CBOR\PeterO\DataUtilities.cs,WriteUtf8,The following statement contains a magic number: for (int index = offset; index < endIndex; ++index) {          c = str[index];         if (c <= 0x7f) {           if (lenientLineBreaks) {             if (c == 0x0d && (index + 1 >= endIndex || str[index + 1] !=                     0x0a)) {               // bare CR' convert to CRLF               if (byteIndex + 2 > StreamedStringBufferLength) {                 // Write bytes retrieved so far                 stream.Write(bytes' 0' byteIndex);                 byteIndex = 0;               }               bytes[byteIndex++] = 0x0d;               bytes[byteIndex++] = 0x0a;               continue;             } else if (c == 0x0d) {               // CR-LF pair               if (byteIndex + 2 > StreamedStringBufferLength) {                 // Write bytes retrieved so far                 stream.Write(bytes' 0' byteIndex);                 byteIndex = 0;               }               bytes[byteIndex++] = 0x0d;               bytes[byteIndex++] = 0x0a;               ++index;               continue;             }             if (c == 0x0a) {               // bare LF' convert to CRLF               if (byteIndex + 2 > StreamedStringBufferLength) {                 // Write bytes retrieved so far                 stream.Write(bytes' 0' byteIndex);                 byteIndex = 0;               }               bytes[byteIndex++] = 0x0d;               bytes[byteIndex++] = 0x0a;               continue;             }           }           if (byteIndex >= StreamedStringBufferLength) {             // Write bytes retrieved so far             stream.Write(bytes' 0' byteIndex);             byteIndex = 0;           }           bytes[byteIndex++] = (byte)c;         } else if (c <= 0x7ff) {           if (byteIndex + 2 > StreamedStringBufferLength) {             // Write bytes retrieved so far             stream.Write(bytes' 0' byteIndex);             byteIndex = 0;           }           bytes[byteIndex++] = (byte)(0xc0 | ((c >> 6) & 0x1f));           bytes[byteIndex++] = (byte)(0x80 | (c & 0x3f));         } else {           if ((c & 0xfc00) == 0xd800 && index + 1 < endIndex &&               str[index + 1] >= 0xdc00 && str[index + 1] <= 0xdfff) {             // Get the Unicode code point for the surrogate pair             c = 0x10000 + ((c - 0xd800) << 10) + (str[index + 1] - 0xdc00);             ++index;           } else if ((c & 0xf800) == 0xd800) {             // unpaired surrogate             if (!replace) {               retval = -1;               break;  // write bytes read so far             }             c = 0xfffd;           }           if (c <= 0xffff) {             if (byteIndex + 3 > StreamedStringBufferLength) {               // Write bytes retrieved so far               stream.Write(bytes' 0' byteIndex);               byteIndex = 0;             }             bytes[byteIndex++] = (byte)(0xe0 | ((c >> 12) & 0x0f));             bytes[byteIndex++] = (byte)(0x80 | ((c >> 6) & 0x3f));             bytes[byteIndex++] = (byte)(0x80 | (c & 0x3f));           } else {             if (byteIndex + 4 > StreamedStringBufferLength) {               // Write bytes retrieved so far               stream.Write(bytes' 0' byteIndex);               byteIndex = 0;             }             bytes[byteIndex++] = (byte)(0xf0 | ((c >> 18) & 0x07));             bytes[byteIndex++] = (byte)(0x80 | ((c >> 12) & 0x3f));             bytes[byteIndex++] = (byte)(0x80 | ((c >> 6) & 0x3f));             bytes[byteIndex++] = (byte)(0x80 | (c & 0x3f));           }         }       }
Magic Number,PeterO,DataUtilities,C:\repos\peteroupc_CBOR\CBOR\PeterO\DataUtilities.cs,WriteUtf8,The following statement contains a magic number: for (int index = offset; index < endIndex; ++index) {          c = str[index];         if (c <= 0x7f) {           if (lenientLineBreaks) {             if (c == 0x0d && (index + 1 >= endIndex || str[index + 1] !=                     0x0a)) {               // bare CR' convert to CRLF               if (byteIndex + 2 > StreamedStringBufferLength) {                 // Write bytes retrieved so far                 stream.Write(bytes' 0' byteIndex);                 byteIndex = 0;               }               bytes[byteIndex++] = 0x0d;               bytes[byteIndex++] = 0x0a;               continue;             } else if (c == 0x0d) {               // CR-LF pair               if (byteIndex + 2 > StreamedStringBufferLength) {                 // Write bytes retrieved so far                 stream.Write(bytes' 0' byteIndex);                 byteIndex = 0;               }               bytes[byteIndex++] = 0x0d;               bytes[byteIndex++] = 0x0a;               ++index;               continue;             }             if (c == 0x0a) {               // bare LF' convert to CRLF               if (byteIndex + 2 > StreamedStringBufferLength) {                 // Write bytes retrieved so far                 stream.Write(bytes' 0' byteIndex);                 byteIndex = 0;               }               bytes[byteIndex++] = 0x0d;               bytes[byteIndex++] = 0x0a;               continue;             }           }           if (byteIndex >= StreamedStringBufferLength) {             // Write bytes retrieved so far             stream.Write(bytes' 0' byteIndex);             byteIndex = 0;           }           bytes[byteIndex++] = (byte)c;         } else if (c <= 0x7ff) {           if (byteIndex + 2 > StreamedStringBufferLength) {             // Write bytes retrieved so far             stream.Write(bytes' 0' byteIndex);             byteIndex = 0;           }           bytes[byteIndex++] = (byte)(0xc0 | ((c >> 6) & 0x1f));           bytes[byteIndex++] = (byte)(0x80 | (c & 0x3f));         } else {           if ((c & 0xfc00) == 0xd800 && index + 1 < endIndex &&               str[index + 1] >= 0xdc00 && str[index + 1] <= 0xdfff) {             // Get the Unicode code point for the surrogate pair             c = 0x10000 + ((c - 0xd800) << 10) + (str[index + 1] - 0xdc00);             ++index;           } else if ((c & 0xf800) == 0xd800) {             // unpaired surrogate             if (!replace) {               retval = -1;               break;  // write bytes read so far             }             c = 0xfffd;           }           if (c <= 0xffff) {             if (byteIndex + 3 > StreamedStringBufferLength) {               // Write bytes retrieved so far               stream.Write(bytes' 0' byteIndex);               byteIndex = 0;             }             bytes[byteIndex++] = (byte)(0xe0 | ((c >> 12) & 0x0f));             bytes[byteIndex++] = (byte)(0x80 | ((c >> 6) & 0x3f));             bytes[byteIndex++] = (byte)(0x80 | (c & 0x3f));           } else {             if (byteIndex + 4 > StreamedStringBufferLength) {               // Write bytes retrieved so far               stream.Write(bytes' 0' byteIndex);               byteIndex = 0;             }             bytes[byteIndex++] = (byte)(0xf0 | ((c >> 18) & 0x07));             bytes[byteIndex++] = (byte)(0x80 | ((c >> 12) & 0x3f));             bytes[byteIndex++] = (byte)(0x80 | ((c >> 6) & 0x3f));             bytes[byteIndex++] = (byte)(0x80 | (c & 0x3f));           }         }       }
Magic Number,PeterO,DataUtilities,C:\repos\peteroupc_CBOR\CBOR\PeterO\DataUtilities.cs,WriteUtf8,The following statement contains a magic number: for (int index = offset; index < endIndex; ++index) {          c = str[index];         if (c <= 0x7f) {           if (lenientLineBreaks) {             if (c == 0x0d && (index + 1 >= endIndex || str[index + 1] !=                     0x0a)) {               // bare CR' convert to CRLF               if (byteIndex + 2 > StreamedStringBufferLength) {                 // Write bytes retrieved so far                 stream.Write(bytes' 0' byteIndex);                 byteIndex = 0;               }               bytes[byteIndex++] = 0x0d;               bytes[byteIndex++] = 0x0a;               continue;             } else if (c == 0x0d) {               // CR-LF pair               if (byteIndex + 2 > StreamedStringBufferLength) {                 // Write bytes retrieved so far                 stream.Write(bytes' 0' byteIndex);                 byteIndex = 0;               }               bytes[byteIndex++] = 0x0d;               bytes[byteIndex++] = 0x0a;               ++index;               continue;             }             if (c == 0x0a) {               // bare LF' convert to CRLF               if (byteIndex + 2 > StreamedStringBufferLength) {                 // Write bytes retrieved so far                 stream.Write(bytes' 0' byteIndex);                 byteIndex = 0;               }               bytes[byteIndex++] = 0x0d;               bytes[byteIndex++] = 0x0a;               continue;             }           }           if (byteIndex >= StreamedStringBufferLength) {             // Write bytes retrieved so far             stream.Write(bytes' 0' byteIndex);             byteIndex = 0;           }           bytes[byteIndex++] = (byte)c;         } else if (c <= 0x7ff) {           if (byteIndex + 2 > StreamedStringBufferLength) {             // Write bytes retrieved so far             stream.Write(bytes' 0' byteIndex);             byteIndex = 0;           }           bytes[byteIndex++] = (byte)(0xc0 | ((c >> 6) & 0x1f));           bytes[byteIndex++] = (byte)(0x80 | (c & 0x3f));         } else {           if ((c & 0xfc00) == 0xd800 && index + 1 < endIndex &&               str[index + 1] >= 0xdc00 && str[index + 1] <= 0xdfff) {             // Get the Unicode code point for the surrogate pair             c = 0x10000 + ((c - 0xd800) << 10) + (str[index + 1] - 0xdc00);             ++index;           } else if ((c & 0xf800) == 0xd800) {             // unpaired surrogate             if (!replace) {               retval = -1;               break;  // write bytes read so far             }             c = 0xfffd;           }           if (c <= 0xffff) {             if (byteIndex + 3 > StreamedStringBufferLength) {               // Write bytes retrieved so far               stream.Write(bytes' 0' byteIndex);               byteIndex = 0;             }             bytes[byteIndex++] = (byte)(0xe0 | ((c >> 12) & 0x0f));             bytes[byteIndex++] = (byte)(0x80 | ((c >> 6) & 0x3f));             bytes[byteIndex++] = (byte)(0x80 | (c & 0x3f));           } else {             if (byteIndex + 4 > StreamedStringBufferLength) {               // Write bytes retrieved so far               stream.Write(bytes' 0' byteIndex);               byteIndex = 0;             }             bytes[byteIndex++] = (byte)(0xf0 | ((c >> 18) & 0x07));             bytes[byteIndex++] = (byte)(0x80 | ((c >> 12) & 0x3f));             bytes[byteIndex++] = (byte)(0x80 | ((c >> 6) & 0x3f));             bytes[byteIndex++] = (byte)(0x80 | (c & 0x3f));           }         }       }
Magic Number,PeterO,DataUtilities,C:\repos\peteroupc_CBOR\CBOR\PeterO\DataUtilities.cs,WriteUtf8,The following statement contains a magic number: for (int index = offset; index < endIndex; ++index) {          c = str[index];         if (c <= 0x7f) {           if (lenientLineBreaks) {             if (c == 0x0d && (index + 1 >= endIndex || str[index + 1] !=                     0x0a)) {               // bare CR' convert to CRLF               if (byteIndex + 2 > StreamedStringBufferLength) {                 // Write bytes retrieved so far                 stream.Write(bytes' 0' byteIndex);                 byteIndex = 0;               }               bytes[byteIndex++] = 0x0d;               bytes[byteIndex++] = 0x0a;               continue;             } else if (c == 0x0d) {               // CR-LF pair               if (byteIndex + 2 > StreamedStringBufferLength) {                 // Write bytes retrieved so far                 stream.Write(bytes' 0' byteIndex);                 byteIndex = 0;               }               bytes[byteIndex++] = 0x0d;               bytes[byteIndex++] = 0x0a;               ++index;               continue;             }             if (c == 0x0a) {               // bare LF' convert to CRLF               if (byteIndex + 2 > StreamedStringBufferLength) {                 // Write bytes retrieved so far                 stream.Write(bytes' 0' byteIndex);                 byteIndex = 0;               }               bytes[byteIndex++] = 0x0d;               bytes[byteIndex++] = 0x0a;               continue;             }           }           if (byteIndex >= StreamedStringBufferLength) {             // Write bytes retrieved so far             stream.Write(bytes' 0' byteIndex);             byteIndex = 0;           }           bytes[byteIndex++] = (byte)c;         } else if (c <= 0x7ff) {           if (byteIndex + 2 > StreamedStringBufferLength) {             // Write bytes retrieved so far             stream.Write(bytes' 0' byteIndex);             byteIndex = 0;           }           bytes[byteIndex++] = (byte)(0xc0 | ((c >> 6) & 0x1f));           bytes[byteIndex++] = (byte)(0x80 | (c & 0x3f));         } else {           if ((c & 0xfc00) == 0xd800 && index + 1 < endIndex &&               str[index + 1] >= 0xdc00 && str[index + 1] <= 0xdfff) {             // Get the Unicode code point for the surrogate pair             c = 0x10000 + ((c - 0xd800) << 10) + (str[index + 1] - 0xdc00);             ++index;           } else if ((c & 0xf800) == 0xd800) {             // unpaired surrogate             if (!replace) {               retval = -1;               break;  // write bytes read so far             }             c = 0xfffd;           }           if (c <= 0xffff) {             if (byteIndex + 3 > StreamedStringBufferLength) {               // Write bytes retrieved so far               stream.Write(bytes' 0' byteIndex);               byteIndex = 0;             }             bytes[byteIndex++] = (byte)(0xe0 | ((c >> 12) & 0x0f));             bytes[byteIndex++] = (byte)(0x80 | ((c >> 6) & 0x3f));             bytes[byteIndex++] = (byte)(0x80 | (c & 0x3f));           } else {             if (byteIndex + 4 > StreamedStringBufferLength) {               // Write bytes retrieved so far               stream.Write(bytes' 0' byteIndex);               byteIndex = 0;             }             bytes[byteIndex++] = (byte)(0xf0 | ((c >> 18) & 0x07));             bytes[byteIndex++] = (byte)(0x80 | ((c >> 12) & 0x3f));             bytes[byteIndex++] = (byte)(0x80 | ((c >> 6) & 0x3f));             bytes[byteIndex++] = (byte)(0x80 | (c & 0x3f));           }         }       }
Magic Number,PeterO,DataUtilities,C:\repos\peteroupc_CBOR\CBOR\PeterO\DataUtilities.cs,WriteUtf8,The following statement contains a magic number: for (int index = offset; index < endIndex; ++index) {          c = str[index];         if (c <= 0x7f) {           if (lenientLineBreaks) {             if (c == 0x0d && (index + 1 >= endIndex || str[index + 1] !=                     0x0a)) {               // bare CR' convert to CRLF               if (byteIndex + 2 > StreamedStringBufferLength) {                 // Write bytes retrieved so far                 stream.Write(bytes' 0' byteIndex);                 byteIndex = 0;               }               bytes[byteIndex++] = 0x0d;               bytes[byteIndex++] = 0x0a;               continue;             } else if (c == 0x0d) {               // CR-LF pair               if (byteIndex + 2 > StreamedStringBufferLength) {                 // Write bytes retrieved so far                 stream.Write(bytes' 0' byteIndex);                 byteIndex = 0;               }               bytes[byteIndex++] = 0x0d;               bytes[byteIndex++] = 0x0a;               ++index;               continue;             }             if (c == 0x0a) {               // bare LF' convert to CRLF               if (byteIndex + 2 > StreamedStringBufferLength) {                 // Write bytes retrieved so far                 stream.Write(bytes' 0' byteIndex);                 byteIndex = 0;               }               bytes[byteIndex++] = 0x0d;               bytes[byteIndex++] = 0x0a;               continue;             }           }           if (byteIndex >= StreamedStringBufferLength) {             // Write bytes retrieved so far             stream.Write(bytes' 0' byteIndex);             byteIndex = 0;           }           bytes[byteIndex++] = (byte)c;         } else if (c <= 0x7ff) {           if (byteIndex + 2 > StreamedStringBufferLength) {             // Write bytes retrieved so far             stream.Write(bytes' 0' byteIndex);             byteIndex = 0;           }           bytes[byteIndex++] = (byte)(0xc0 | ((c >> 6) & 0x1f));           bytes[byteIndex++] = (byte)(0x80 | (c & 0x3f));         } else {           if ((c & 0xfc00) == 0xd800 && index + 1 < endIndex &&               str[index + 1] >= 0xdc00 && str[index + 1] <= 0xdfff) {             // Get the Unicode code point for the surrogate pair             c = 0x10000 + ((c - 0xd800) << 10) + (str[index + 1] - 0xdc00);             ++index;           } else if ((c & 0xf800) == 0xd800) {             // unpaired surrogate             if (!replace) {               retval = -1;               break;  // write bytes read so far             }             c = 0xfffd;           }           if (c <= 0xffff) {             if (byteIndex + 3 > StreamedStringBufferLength) {               // Write bytes retrieved so far               stream.Write(bytes' 0' byteIndex);               byteIndex = 0;             }             bytes[byteIndex++] = (byte)(0xe0 | ((c >> 12) & 0x0f));             bytes[byteIndex++] = (byte)(0x80 | ((c >> 6) & 0x3f));             bytes[byteIndex++] = (byte)(0x80 | (c & 0x3f));           } else {             if (byteIndex + 4 > StreamedStringBufferLength) {               // Write bytes retrieved so far               stream.Write(bytes' 0' byteIndex);               byteIndex = 0;             }             bytes[byteIndex++] = (byte)(0xf0 | ((c >> 18) & 0x07));             bytes[byteIndex++] = (byte)(0x80 | ((c >> 12) & 0x3f));             bytes[byteIndex++] = (byte)(0x80 | ((c >> 6) & 0x3f));             bytes[byteIndex++] = (byte)(0x80 | (c & 0x3f));           }         }       }
Magic Number,PeterO,DataUtilities,C:\repos\peteroupc_CBOR\CBOR\PeterO\DataUtilities.cs,WriteUtf8,The following statement contains a magic number: for (int index = offset; index < endIndex; ++index) {          c = str[index];         if (c <= 0x7f) {           if (lenientLineBreaks) {             if (c == 0x0d && (index + 1 >= endIndex || str[index + 1] !=                     0x0a)) {               // bare CR' convert to CRLF               if (byteIndex + 2 > StreamedStringBufferLength) {                 // Write bytes retrieved so far                 stream.Write(bytes' 0' byteIndex);                 byteIndex = 0;               }               bytes[byteIndex++] = 0x0d;               bytes[byteIndex++] = 0x0a;               continue;             } else if (c == 0x0d) {               // CR-LF pair               if (byteIndex + 2 > StreamedStringBufferLength) {                 // Write bytes retrieved so far                 stream.Write(bytes' 0' byteIndex);                 byteIndex = 0;               }               bytes[byteIndex++] = 0x0d;               bytes[byteIndex++] = 0x0a;               ++index;               continue;             }             if (c == 0x0a) {               // bare LF' convert to CRLF               if (byteIndex + 2 > StreamedStringBufferLength) {                 // Write bytes retrieved so far                 stream.Write(bytes' 0' byteIndex);                 byteIndex = 0;               }               bytes[byteIndex++] = 0x0d;               bytes[byteIndex++] = 0x0a;               continue;             }           }           if (byteIndex >= StreamedStringBufferLength) {             // Write bytes retrieved so far             stream.Write(bytes' 0' byteIndex);             byteIndex = 0;           }           bytes[byteIndex++] = (byte)c;         } else if (c <= 0x7ff) {           if (byteIndex + 2 > StreamedStringBufferLength) {             // Write bytes retrieved so far             stream.Write(bytes' 0' byteIndex);             byteIndex = 0;           }           bytes[byteIndex++] = (byte)(0xc0 | ((c >> 6) & 0x1f));           bytes[byteIndex++] = (byte)(0x80 | (c & 0x3f));         } else {           if ((c & 0xfc00) == 0xd800 && index + 1 < endIndex &&               str[index + 1] >= 0xdc00 && str[index + 1] <= 0xdfff) {             // Get the Unicode code point for the surrogate pair             c = 0x10000 + ((c - 0xd800) << 10) + (str[index + 1] - 0xdc00);             ++index;           } else if ((c & 0xf800) == 0xd800) {             // unpaired surrogate             if (!replace) {               retval = -1;               break;  // write bytes read so far             }             c = 0xfffd;           }           if (c <= 0xffff) {             if (byteIndex + 3 > StreamedStringBufferLength) {               // Write bytes retrieved so far               stream.Write(bytes' 0' byteIndex);               byteIndex = 0;             }             bytes[byteIndex++] = (byte)(0xe0 | ((c >> 12) & 0x0f));             bytes[byteIndex++] = (byte)(0x80 | ((c >> 6) & 0x3f));             bytes[byteIndex++] = (byte)(0x80 | (c & 0x3f));           } else {             if (byteIndex + 4 > StreamedStringBufferLength) {               // Write bytes retrieved so far               stream.Write(bytes' 0' byteIndex);               byteIndex = 0;             }             bytes[byteIndex++] = (byte)(0xf0 | ((c >> 18) & 0x07));             bytes[byteIndex++] = (byte)(0x80 | ((c >> 12) & 0x3f));             bytes[byteIndex++] = (byte)(0x80 | ((c >> 6) & 0x3f));             bytes[byteIndex++] = (byte)(0x80 | (c & 0x3f));           }         }       }
Magic Number,PeterO,DataUtilities,C:\repos\peteroupc_CBOR\CBOR\PeterO\DataUtilities.cs,WriteUtf8,The following statement contains a magic number: for (int index = offset; index < endIndex; ++index) {          c = str[index];         if (c <= 0x7f) {           if (lenientLineBreaks) {             if (c == 0x0d && (index + 1 >= endIndex || str[index + 1] !=                     0x0a)) {               // bare CR' convert to CRLF               if (byteIndex + 2 > StreamedStringBufferLength) {                 // Write bytes retrieved so far                 stream.Write(bytes' 0' byteIndex);                 byteIndex = 0;               }               bytes[byteIndex++] = 0x0d;               bytes[byteIndex++] = 0x0a;               continue;             } else if (c == 0x0d) {               // CR-LF pair               if (byteIndex + 2 > StreamedStringBufferLength) {                 // Write bytes retrieved so far                 stream.Write(bytes' 0' byteIndex);                 byteIndex = 0;               }               bytes[byteIndex++] = 0x0d;               bytes[byteIndex++] = 0x0a;               ++index;               continue;             }             if (c == 0x0a) {               // bare LF' convert to CRLF               if (byteIndex + 2 > StreamedStringBufferLength) {                 // Write bytes retrieved so far                 stream.Write(bytes' 0' byteIndex);                 byteIndex = 0;               }               bytes[byteIndex++] = 0x0d;               bytes[byteIndex++] = 0x0a;               continue;             }           }           if (byteIndex >= StreamedStringBufferLength) {             // Write bytes retrieved so far             stream.Write(bytes' 0' byteIndex);             byteIndex = 0;           }           bytes[byteIndex++] = (byte)c;         } else if (c <= 0x7ff) {           if (byteIndex + 2 > StreamedStringBufferLength) {             // Write bytes retrieved so far             stream.Write(bytes' 0' byteIndex);             byteIndex = 0;           }           bytes[byteIndex++] = (byte)(0xc0 | ((c >> 6) & 0x1f));           bytes[byteIndex++] = (byte)(0x80 | (c & 0x3f));         } else {           if ((c & 0xfc00) == 0xd800 && index + 1 < endIndex &&               str[index + 1] >= 0xdc00 && str[index + 1] <= 0xdfff) {             // Get the Unicode code point for the surrogate pair             c = 0x10000 + ((c - 0xd800) << 10) + (str[index + 1] - 0xdc00);             ++index;           } else if ((c & 0xf800) == 0xd800) {             // unpaired surrogate             if (!replace) {               retval = -1;               break;  // write bytes read so far             }             c = 0xfffd;           }           if (c <= 0xffff) {             if (byteIndex + 3 > StreamedStringBufferLength) {               // Write bytes retrieved so far               stream.Write(bytes' 0' byteIndex);               byteIndex = 0;             }             bytes[byteIndex++] = (byte)(0xe0 | ((c >> 12) & 0x0f));             bytes[byteIndex++] = (byte)(0x80 | ((c >> 6) & 0x3f));             bytes[byteIndex++] = (byte)(0x80 | (c & 0x3f));           } else {             if (byteIndex + 4 > StreamedStringBufferLength) {               // Write bytes retrieved so far               stream.Write(bytes' 0' byteIndex);               byteIndex = 0;             }             bytes[byteIndex++] = (byte)(0xf0 | ((c >> 18) & 0x07));             bytes[byteIndex++] = (byte)(0x80 | ((c >> 12) & 0x3f));             bytes[byteIndex++] = (byte)(0x80 | ((c >> 6) & 0x3f));             bytes[byteIndex++] = (byte)(0x80 | (c & 0x3f));           }         }       }
Magic Number,PeterO,DataUtilities,C:\repos\peteroupc_CBOR\CBOR\PeterO\DataUtilities.cs,WriteUtf8,The following statement contains a magic number: for (int index = offset; index < endIndex; ++index) {          c = str[index];         if (c <= 0x7f) {           if (lenientLineBreaks) {             if (c == 0x0d && (index + 1 >= endIndex || str[index + 1] !=                     0x0a)) {               // bare CR' convert to CRLF               if (byteIndex + 2 > StreamedStringBufferLength) {                 // Write bytes retrieved so far                 stream.Write(bytes' 0' byteIndex);                 byteIndex = 0;               }               bytes[byteIndex++] = 0x0d;               bytes[byteIndex++] = 0x0a;               continue;             } else if (c == 0x0d) {               // CR-LF pair               if (byteIndex + 2 > StreamedStringBufferLength) {                 // Write bytes retrieved so far                 stream.Write(bytes' 0' byteIndex);                 byteIndex = 0;               }               bytes[byteIndex++] = 0x0d;               bytes[byteIndex++] = 0x0a;               ++index;               continue;             }             if (c == 0x0a) {               // bare LF' convert to CRLF               if (byteIndex + 2 > StreamedStringBufferLength) {                 // Write bytes retrieved so far                 stream.Write(bytes' 0' byteIndex);                 byteIndex = 0;               }               bytes[byteIndex++] = 0x0d;               bytes[byteIndex++] = 0x0a;               continue;             }           }           if (byteIndex >= StreamedStringBufferLength) {             // Write bytes retrieved so far             stream.Write(bytes' 0' byteIndex);             byteIndex = 0;           }           bytes[byteIndex++] = (byte)c;         } else if (c <= 0x7ff) {           if (byteIndex + 2 > StreamedStringBufferLength) {             // Write bytes retrieved so far             stream.Write(bytes' 0' byteIndex);             byteIndex = 0;           }           bytes[byteIndex++] = (byte)(0xc0 | ((c >> 6) & 0x1f));           bytes[byteIndex++] = (byte)(0x80 | (c & 0x3f));         } else {           if ((c & 0xfc00) == 0xd800 && index + 1 < endIndex &&               str[index + 1] >= 0xdc00 && str[index + 1] <= 0xdfff) {             // Get the Unicode code point for the surrogate pair             c = 0x10000 + ((c - 0xd800) << 10) + (str[index + 1] - 0xdc00);             ++index;           } else if ((c & 0xf800) == 0xd800) {             // unpaired surrogate             if (!replace) {               retval = -1;               break;  // write bytes read so far             }             c = 0xfffd;           }           if (c <= 0xffff) {             if (byteIndex + 3 > StreamedStringBufferLength) {               // Write bytes retrieved so far               stream.Write(bytes' 0' byteIndex);               byteIndex = 0;             }             bytes[byteIndex++] = (byte)(0xe0 | ((c >> 12) & 0x0f));             bytes[byteIndex++] = (byte)(0x80 | ((c >> 6) & 0x3f));             bytes[byteIndex++] = (byte)(0x80 | (c & 0x3f));           } else {             if (byteIndex + 4 > StreamedStringBufferLength) {               // Write bytes retrieved so far               stream.Write(bytes' 0' byteIndex);               byteIndex = 0;             }             bytes[byteIndex++] = (byte)(0xf0 | ((c >> 18) & 0x07));             bytes[byteIndex++] = (byte)(0x80 | ((c >> 12) & 0x3f));             bytes[byteIndex++] = (byte)(0x80 | ((c >> 6) & 0x3f));             bytes[byteIndex++] = (byte)(0x80 | (c & 0x3f));           }         }       }
Magic Number,PeterO,DataUtilities,C:\repos\peteroupc_CBOR\CBOR\PeterO\DataUtilities.cs,WriteUtf8,The following statement contains a magic number: for (int index = offset; index < endIndex; ++index) {          c = str[index];         if (c <= 0x7f) {           if (lenientLineBreaks) {             if (c == 0x0d && (index + 1 >= endIndex || str[index + 1] !=                     0x0a)) {               // bare CR' convert to CRLF               if (byteIndex + 2 > StreamedStringBufferLength) {                 // Write bytes retrieved so far                 stream.Write(bytes' 0' byteIndex);                 byteIndex = 0;               }               bytes[byteIndex++] = 0x0d;               bytes[byteIndex++] = 0x0a;               continue;             } else if (c == 0x0d) {               // CR-LF pair               if (byteIndex + 2 > StreamedStringBufferLength) {                 // Write bytes retrieved so far                 stream.Write(bytes' 0' byteIndex);                 byteIndex = 0;               }               bytes[byteIndex++] = 0x0d;               bytes[byteIndex++] = 0x0a;               ++index;               continue;             }             if (c == 0x0a) {               // bare LF' convert to CRLF               if (byteIndex + 2 > StreamedStringBufferLength) {                 // Write bytes retrieved so far                 stream.Write(bytes' 0' byteIndex);                 byteIndex = 0;               }               bytes[byteIndex++] = 0x0d;               bytes[byteIndex++] = 0x0a;               continue;             }           }           if (byteIndex >= StreamedStringBufferLength) {             // Write bytes retrieved so far             stream.Write(bytes' 0' byteIndex);             byteIndex = 0;           }           bytes[byteIndex++] = (byte)c;         } else if (c <= 0x7ff) {           if (byteIndex + 2 > StreamedStringBufferLength) {             // Write bytes retrieved so far             stream.Write(bytes' 0' byteIndex);             byteIndex = 0;           }           bytes[byteIndex++] = (byte)(0xc0 | ((c >> 6) & 0x1f));           bytes[byteIndex++] = (byte)(0x80 | (c & 0x3f));         } else {           if ((c & 0xfc00) == 0xd800 && index + 1 < endIndex &&               str[index + 1] >= 0xdc00 && str[index + 1] <= 0xdfff) {             // Get the Unicode code point for the surrogate pair             c = 0x10000 + ((c - 0xd800) << 10) + (str[index + 1] - 0xdc00);             ++index;           } else if ((c & 0xf800) == 0xd800) {             // unpaired surrogate             if (!replace) {               retval = -1;               break;  // write bytes read so far             }             c = 0xfffd;           }           if (c <= 0xffff) {             if (byteIndex + 3 > StreamedStringBufferLength) {               // Write bytes retrieved so far               stream.Write(bytes' 0' byteIndex);               byteIndex = 0;             }             bytes[byteIndex++] = (byte)(0xe0 | ((c >> 12) & 0x0f));             bytes[byteIndex++] = (byte)(0x80 | ((c >> 6) & 0x3f));             bytes[byteIndex++] = (byte)(0x80 | (c & 0x3f));           } else {             if (byteIndex + 4 > StreamedStringBufferLength) {               // Write bytes retrieved so far               stream.Write(bytes' 0' byteIndex);               byteIndex = 0;             }             bytes[byteIndex++] = (byte)(0xf0 | ((c >> 18) & 0x07));             bytes[byteIndex++] = (byte)(0x80 | ((c >> 12) & 0x3f));             bytes[byteIndex++] = (byte)(0x80 | ((c >> 6) & 0x3f));             bytes[byteIndex++] = (byte)(0x80 | (c & 0x3f));           }         }       }
Magic Number,PeterO,DataUtilities,C:\repos\peteroupc_CBOR\CBOR\PeterO\DataUtilities.cs,WriteUtf8,The following statement contains a magic number: for (int index = offset; index < endIndex; ++index) {          c = str[index];         if (c <= 0x7f) {           if (lenientLineBreaks) {             if (c == 0x0d && (index + 1 >= endIndex || str[index + 1] !=                     0x0a)) {               // bare CR' convert to CRLF               if (byteIndex + 2 > StreamedStringBufferLength) {                 // Write bytes retrieved so far                 stream.Write(bytes' 0' byteIndex);                 byteIndex = 0;               }               bytes[byteIndex++] = 0x0d;               bytes[byteIndex++] = 0x0a;               continue;             } else if (c == 0x0d) {               // CR-LF pair               if (byteIndex + 2 > StreamedStringBufferLength) {                 // Write bytes retrieved so far                 stream.Write(bytes' 0' byteIndex);                 byteIndex = 0;               }               bytes[byteIndex++] = 0x0d;               bytes[byteIndex++] = 0x0a;               ++index;               continue;             }             if (c == 0x0a) {               // bare LF' convert to CRLF               if (byteIndex + 2 > StreamedStringBufferLength) {                 // Write bytes retrieved so far                 stream.Write(bytes' 0' byteIndex);                 byteIndex = 0;               }               bytes[byteIndex++] = 0x0d;               bytes[byteIndex++] = 0x0a;               continue;             }           }           if (byteIndex >= StreamedStringBufferLength) {             // Write bytes retrieved so far             stream.Write(bytes' 0' byteIndex);             byteIndex = 0;           }           bytes[byteIndex++] = (byte)c;         } else if (c <= 0x7ff) {           if (byteIndex + 2 > StreamedStringBufferLength) {             // Write bytes retrieved so far             stream.Write(bytes' 0' byteIndex);             byteIndex = 0;           }           bytes[byteIndex++] = (byte)(0xc0 | ((c >> 6) & 0x1f));           bytes[byteIndex++] = (byte)(0x80 | (c & 0x3f));         } else {           if ((c & 0xfc00) == 0xd800 && index + 1 < endIndex &&               str[index + 1] >= 0xdc00 && str[index + 1] <= 0xdfff) {             // Get the Unicode code point for the surrogate pair             c = 0x10000 + ((c - 0xd800) << 10) + (str[index + 1] - 0xdc00);             ++index;           } else if ((c & 0xf800) == 0xd800) {             // unpaired surrogate             if (!replace) {               retval = -1;               break;  // write bytes read so far             }             c = 0xfffd;           }           if (c <= 0xffff) {             if (byteIndex + 3 > StreamedStringBufferLength) {               // Write bytes retrieved so far               stream.Write(bytes' 0' byteIndex);               byteIndex = 0;             }             bytes[byteIndex++] = (byte)(0xe0 | ((c >> 12) & 0x0f));             bytes[byteIndex++] = (byte)(0x80 | ((c >> 6) & 0x3f));             bytes[byteIndex++] = (byte)(0x80 | (c & 0x3f));           } else {             if (byteIndex + 4 > StreamedStringBufferLength) {               // Write bytes retrieved so far               stream.Write(bytes' 0' byteIndex);               byteIndex = 0;             }             bytes[byteIndex++] = (byte)(0xf0 | ((c >> 18) & 0x07));             bytes[byteIndex++] = (byte)(0x80 | ((c >> 12) & 0x3f));             bytes[byteIndex++] = (byte)(0x80 | ((c >> 6) & 0x3f));             bytes[byteIndex++] = (byte)(0x80 | (c & 0x3f));           }         }       }
Magic Number,PeterO,DataUtilities,C:\repos\peteroupc_CBOR\CBOR\PeterO\DataUtilities.cs,ReadUtf8FromBytes,The following statement contains a magic number: while (pointer < endpointer) {          b = data[pointer] & (int)0xff;         ++pointer;         if (bytesNeeded == 0) {           if ((b & 0x7f) == b) {             builder.Append((char)b);           } else if (b >= 0xc2 && b <= 0xdf) {             bytesNeeded = 1;             cp = (b - 0xc0) << 6;           } else if (b >= 0xe0 && b <= 0xef) {             lower = (b == 0xe0) ? 0xa0 : 0x80;             upper = (b == 0xed) ? 0x9f : 0xbf;             bytesNeeded = 2;             cp = (b - 0xe0) << 12;           } else if (b >= 0xf0 && b <= 0xf4) {             lower = (b == 0xf0) ? 0x90 : 0x80;             upper = (b == 0xf4) ? 0x8f : 0xbf;             bytesNeeded = 3;             cp = (b - 0xf0) << 18;           } else {             if (replace) {               builder.Append((char)0xfffd);             } else {               return -1;             }           }           continue;         }         if (b < lower || b > upper) {           cp = bytesNeeded = bytesSeen = 0;           lower = 0x80;           upper = 0xbf;           if (replace) {             --pointer;             builder.Append((char)0xfffd);             continue;           }           return -1;         } else {           lower = 0x80;           upper = 0xbf;           ++bytesSeen;           cp += (b - 0x80) << (6 * (bytesNeeded - bytesSeen));           if (bytesSeen != bytesNeeded) {             continue;           }           int ret' ch' lead' trail;            ret = cp;           cp = 0;           bytesSeen = 0;           bytesNeeded = 0;           if (ret <= 0xffff) {             builder.Append((char)ret);           } else {              ch = ret - 0x10000;              lead = (ch >> 10) + 0xd800;              trail = (ch & 0x3ff) + 0xdc00;             builder.Append((char)lead);             builder.Append((char)trail);           }         }       }
Magic Number,PeterO,DataUtilities,C:\repos\peteroupc_CBOR\CBOR\PeterO\DataUtilities.cs,ReadUtf8FromBytes,The following statement contains a magic number: while (pointer < endpointer) {          b = data[pointer] & (int)0xff;         ++pointer;         if (bytesNeeded == 0) {           if ((b & 0x7f) == b) {             builder.Append((char)b);           } else if (b >= 0xc2 && b <= 0xdf) {             bytesNeeded = 1;             cp = (b - 0xc0) << 6;           } else if (b >= 0xe0 && b <= 0xef) {             lower = (b == 0xe0) ? 0xa0 : 0x80;             upper = (b == 0xed) ? 0x9f : 0xbf;             bytesNeeded = 2;             cp = (b - 0xe0) << 12;           } else if (b >= 0xf0 && b <= 0xf4) {             lower = (b == 0xf0) ? 0x90 : 0x80;             upper = (b == 0xf4) ? 0x8f : 0xbf;             bytesNeeded = 3;             cp = (b - 0xf0) << 18;           } else {             if (replace) {               builder.Append((char)0xfffd);             } else {               return -1;             }           }           continue;         }         if (b < lower || b > upper) {           cp = bytesNeeded = bytesSeen = 0;           lower = 0x80;           upper = 0xbf;           if (replace) {             --pointer;             builder.Append((char)0xfffd);             continue;           }           return -1;         } else {           lower = 0x80;           upper = 0xbf;           ++bytesSeen;           cp += (b - 0x80) << (6 * (bytesNeeded - bytesSeen));           if (bytesSeen != bytesNeeded) {             continue;           }           int ret' ch' lead' trail;            ret = cp;           cp = 0;           bytesSeen = 0;           bytesNeeded = 0;           if (ret <= 0xffff) {             builder.Append((char)ret);           } else {              ch = ret - 0x10000;              lead = (ch >> 10) + 0xd800;              trail = (ch & 0x3ff) + 0xdc00;             builder.Append((char)lead);             builder.Append((char)trail);           }         }       }
Magic Number,PeterO,DataUtilities,C:\repos\peteroupc_CBOR\CBOR\PeterO\DataUtilities.cs,ReadUtf8FromBytes,The following statement contains a magic number: while (pointer < endpointer) {          b = data[pointer] & (int)0xff;         ++pointer;         if (bytesNeeded == 0) {           if ((b & 0x7f) == b) {             builder.Append((char)b);           } else if (b >= 0xc2 && b <= 0xdf) {             bytesNeeded = 1;             cp = (b - 0xc0) << 6;           } else if (b >= 0xe0 && b <= 0xef) {             lower = (b == 0xe0) ? 0xa0 : 0x80;             upper = (b == 0xed) ? 0x9f : 0xbf;             bytesNeeded = 2;             cp = (b - 0xe0) << 12;           } else if (b >= 0xf0 && b <= 0xf4) {             lower = (b == 0xf0) ? 0x90 : 0x80;             upper = (b == 0xf4) ? 0x8f : 0xbf;             bytesNeeded = 3;             cp = (b - 0xf0) << 18;           } else {             if (replace) {               builder.Append((char)0xfffd);             } else {               return -1;             }           }           continue;         }         if (b < lower || b > upper) {           cp = bytesNeeded = bytesSeen = 0;           lower = 0x80;           upper = 0xbf;           if (replace) {             --pointer;             builder.Append((char)0xfffd);             continue;           }           return -1;         } else {           lower = 0x80;           upper = 0xbf;           ++bytesSeen;           cp += (b - 0x80) << (6 * (bytesNeeded - bytesSeen));           if (bytesSeen != bytesNeeded) {             continue;           }           int ret' ch' lead' trail;            ret = cp;           cp = 0;           bytesSeen = 0;           bytesNeeded = 0;           if (ret <= 0xffff) {             builder.Append((char)ret);           } else {              ch = ret - 0x10000;              lead = (ch >> 10) + 0xd800;              trail = (ch & 0x3ff) + 0xdc00;             builder.Append((char)lead);             builder.Append((char)trail);           }         }       }
Magic Number,PeterO,DataUtilities,C:\repos\peteroupc_CBOR\CBOR\PeterO\DataUtilities.cs,ReadUtf8FromBytes,The following statement contains a magic number: while (pointer < endpointer) {          b = data[pointer] & (int)0xff;         ++pointer;         if (bytesNeeded == 0) {           if ((b & 0x7f) == b) {             builder.Append((char)b);           } else if (b >= 0xc2 && b <= 0xdf) {             bytesNeeded = 1;             cp = (b - 0xc0) << 6;           } else if (b >= 0xe0 && b <= 0xef) {             lower = (b == 0xe0) ? 0xa0 : 0x80;             upper = (b == 0xed) ? 0x9f : 0xbf;             bytesNeeded = 2;             cp = (b - 0xe0) << 12;           } else if (b >= 0xf0 && b <= 0xf4) {             lower = (b == 0xf0) ? 0x90 : 0x80;             upper = (b == 0xf4) ? 0x8f : 0xbf;             bytesNeeded = 3;             cp = (b - 0xf0) << 18;           } else {             if (replace) {               builder.Append((char)0xfffd);             } else {               return -1;             }           }           continue;         }         if (b < lower || b > upper) {           cp = bytesNeeded = bytesSeen = 0;           lower = 0x80;           upper = 0xbf;           if (replace) {             --pointer;             builder.Append((char)0xfffd);             continue;           }           return -1;         } else {           lower = 0x80;           upper = 0xbf;           ++bytesSeen;           cp += (b - 0x80) << (6 * (bytesNeeded - bytesSeen));           if (bytesSeen != bytesNeeded) {             continue;           }           int ret' ch' lead' trail;            ret = cp;           cp = 0;           bytesSeen = 0;           bytesNeeded = 0;           if (ret <= 0xffff) {             builder.Append((char)ret);           } else {              ch = ret - 0x10000;              lead = (ch >> 10) + 0xd800;              trail = (ch & 0x3ff) + 0xdc00;             builder.Append((char)lead);             builder.Append((char)trail);           }         }       }
Magic Number,PeterO,DataUtilities,C:\repos\peteroupc_CBOR\CBOR\PeterO\DataUtilities.cs,ReadUtf8FromBytes,The following statement contains a magic number: while (pointer < endpointer) {          b = data[pointer] & (int)0xff;         ++pointer;         if (bytesNeeded == 0) {           if ((b & 0x7f) == b) {             builder.Append((char)b);           } else if (b >= 0xc2 && b <= 0xdf) {             bytesNeeded = 1;             cp = (b - 0xc0) << 6;           } else if (b >= 0xe0 && b <= 0xef) {             lower = (b == 0xe0) ? 0xa0 : 0x80;             upper = (b == 0xed) ? 0x9f : 0xbf;             bytesNeeded = 2;             cp = (b - 0xe0) << 12;           } else if (b >= 0xf0 && b <= 0xf4) {             lower = (b == 0xf0) ? 0x90 : 0x80;             upper = (b == 0xf4) ? 0x8f : 0xbf;             bytesNeeded = 3;             cp = (b - 0xf0) << 18;           } else {             if (replace) {               builder.Append((char)0xfffd);             } else {               return -1;             }           }           continue;         }         if (b < lower || b > upper) {           cp = bytesNeeded = bytesSeen = 0;           lower = 0x80;           upper = 0xbf;           if (replace) {             --pointer;             builder.Append((char)0xfffd);             continue;           }           return -1;         } else {           lower = 0x80;           upper = 0xbf;           ++bytesSeen;           cp += (b - 0x80) << (6 * (bytesNeeded - bytesSeen));           if (bytesSeen != bytesNeeded) {             continue;           }           int ret' ch' lead' trail;            ret = cp;           cp = 0;           bytesSeen = 0;           bytesNeeded = 0;           if (ret <= 0xffff) {             builder.Append((char)ret);           } else {              ch = ret - 0x10000;              lead = (ch >> 10) + 0xd800;              trail = (ch & 0x3ff) + 0xdc00;             builder.Append((char)lead);             builder.Append((char)trail);           }         }       }
Magic Number,PeterO,DataUtilities,C:\repos\peteroupc_CBOR\CBOR\PeterO\DataUtilities.cs,ReadUtf8FromBytes,The following statement contains a magic number: while (pointer < endpointer) {          b = data[pointer] & (int)0xff;         ++pointer;         if (bytesNeeded == 0) {           if ((b & 0x7f) == b) {             builder.Append((char)b);           } else if (b >= 0xc2 && b <= 0xdf) {             bytesNeeded = 1;             cp = (b - 0xc0) << 6;           } else if (b >= 0xe0 && b <= 0xef) {             lower = (b == 0xe0) ? 0xa0 : 0x80;             upper = (b == 0xed) ? 0x9f : 0xbf;             bytesNeeded = 2;             cp = (b - 0xe0) << 12;           } else if (b >= 0xf0 && b <= 0xf4) {             lower = (b == 0xf0) ? 0x90 : 0x80;             upper = (b == 0xf4) ? 0x8f : 0xbf;             bytesNeeded = 3;             cp = (b - 0xf0) << 18;           } else {             if (replace) {               builder.Append((char)0xfffd);             } else {               return -1;             }           }           continue;         }         if (b < lower || b > upper) {           cp = bytesNeeded = bytesSeen = 0;           lower = 0x80;           upper = 0xbf;           if (replace) {             --pointer;             builder.Append((char)0xfffd);             continue;           }           return -1;         } else {           lower = 0x80;           upper = 0xbf;           ++bytesSeen;           cp += (b - 0x80) << (6 * (bytesNeeded - bytesSeen));           if (bytesSeen != bytesNeeded) {             continue;           }           int ret' ch' lead' trail;            ret = cp;           cp = 0;           bytesSeen = 0;           bytesNeeded = 0;           if (ret <= 0xffff) {             builder.Append((char)ret);           } else {              ch = ret - 0x10000;              lead = (ch >> 10) + 0xd800;              trail = (ch & 0x3ff) + 0xdc00;             builder.Append((char)lead);             builder.Append((char)trail);           }         }       }
Magic Number,PeterO,DataUtilities,C:\repos\peteroupc_CBOR\CBOR\PeterO\DataUtilities.cs,ReadUtf8FromBytes,The following statement contains a magic number: while (pointer < endpointer) {          b = data[pointer] & (int)0xff;         ++pointer;         if (bytesNeeded == 0) {           if ((b & 0x7f) == b) {             builder.Append((char)b);           } else if (b >= 0xc2 && b <= 0xdf) {             bytesNeeded = 1;             cp = (b - 0xc0) << 6;           } else if (b >= 0xe0 && b <= 0xef) {             lower = (b == 0xe0) ? 0xa0 : 0x80;             upper = (b == 0xed) ? 0x9f : 0xbf;             bytesNeeded = 2;             cp = (b - 0xe0) << 12;           } else if (b >= 0xf0 && b <= 0xf4) {             lower = (b == 0xf0) ? 0x90 : 0x80;             upper = (b == 0xf4) ? 0x8f : 0xbf;             bytesNeeded = 3;             cp = (b - 0xf0) << 18;           } else {             if (replace) {               builder.Append((char)0xfffd);             } else {               return -1;             }           }           continue;         }         if (b < lower || b > upper) {           cp = bytesNeeded = bytesSeen = 0;           lower = 0x80;           upper = 0xbf;           if (replace) {             --pointer;             builder.Append((char)0xfffd);             continue;           }           return -1;         } else {           lower = 0x80;           upper = 0xbf;           ++bytesSeen;           cp += (b - 0x80) << (6 * (bytesNeeded - bytesSeen));           if (bytesSeen != bytesNeeded) {             continue;           }           int ret' ch' lead' trail;            ret = cp;           cp = 0;           bytesSeen = 0;           bytesNeeded = 0;           if (ret <= 0xffff) {             builder.Append((char)ret);           } else {              ch = ret - 0x10000;              lead = (ch >> 10) + 0xd800;              trail = (ch & 0x3ff) + 0xdc00;             builder.Append((char)lead);             builder.Append((char)trail);           }         }       }
Magic Number,PeterO,DataUtilities,C:\repos\peteroupc_CBOR\CBOR\PeterO\DataUtilities.cs,ReadUtf8,The following statement contains a magic number: while (pointer < bytesCount || bytesCount < 0) {         b = stream.ReadByte();         if (b < 0) {           if (bytesNeeded != 0) {             bytesNeeded = 0;             if (replace) {               builder.Append((char)0xfffd);               if (bytesCount >= 0) {                 return -2;               }               break;  // end of stream             }             return -1;           }           if (bytesCount >= 0) {             return -2;           }           break;  // end of stream         }         if (bytesCount > 0) {           ++pointer;         }         if (bytesNeeded == 0) {           if ((b & 0x7f) == b) {             builder.Append((char)b);           } else if (b >= 0xc2 && b <= 0xdf) {             bytesNeeded = 1;             cp = (b - 0xc0) << 6;           } else if (b >= 0xe0 && b <= 0xef) {             lower = (b == 0xe0) ? 0xa0 : 0x80;             upper = (b == 0xed) ? 0x9f : 0xbf;             bytesNeeded = 2;             cp = (b - 0xe0) << 12;           } else if (b >= 0xf0 && b <= 0xf4) {             lower = (b == 0xf0) ? 0x90 : 0x80;             upper = (b == 0xf4) ? 0x8f : 0xbf;             bytesNeeded = 3;             cp = (b - 0xf0) << 18;           } else {             if (replace) {               builder.Append((char)0xfffd);             } else {               return -1;             }           }           continue;         }         if (b < lower || b > upper) {           cp = bytesNeeded = bytesSeen = 0;           lower = 0x80;           upper = 0xbf;           if (replace) {             builder.Append((char)0xfffd);             // "Read" the last byte again             if (b < 0x80) {               builder.Append((char)b);             } else if (b >= 0xc2 && b <= 0xdf) {               bytesNeeded = 1;               cp = (b - 0xc0) << 6;             } else if (b >= 0xe0 && b <= 0xef) {               lower = (b == 0xe0) ? 0xa0 : 0x80;               upper = (b == 0xed) ? 0x9f : 0xbf;               bytesNeeded = 2;               cp = (b - 0xe0) << 12;             } else if (b >= 0xf0 && b <= 0xf4) {               lower = (b == 0xf0) ? 0x90 : 0x80;               upper = (b == 0xf4) ? 0x8f : 0xbf;               bytesNeeded = 3;               cp = (b - 0xf0) << 18;             } else {               builder.Append((char)0xfffd);             }             continue;           }           return -1;         } else {           lower = 0x80;           upper = 0xbf;           ++bytesSeen;           cp += (b - 0x80) << (6 * (bytesNeeded - bytesSeen));           if (bytesSeen != bytesNeeded) {             continue;           }           int ret' ch' lead' trail;           ret = cp;           cp = 0;           bytesSeen = 0;           bytesNeeded = 0;           if (ret <= 0xffff) {             builder.Append((char)ret);           } else {              ch = ret - 0x10000;              lead = (ch >> 10) + 0xd800;              trail = (ch & 0x3ff) + 0xdc00;             builder.Append((char)lead);             builder.Append((char)trail);           }         }       }
Magic Number,PeterO,DataUtilities,C:\repos\peteroupc_CBOR\CBOR\PeterO\DataUtilities.cs,ReadUtf8,The following statement contains a magic number: while (pointer < bytesCount || bytesCount < 0) {         b = stream.ReadByte();         if (b < 0) {           if (bytesNeeded != 0) {             bytesNeeded = 0;             if (replace) {               builder.Append((char)0xfffd);               if (bytesCount >= 0) {                 return -2;               }               break;  // end of stream             }             return -1;           }           if (bytesCount >= 0) {             return -2;           }           break;  // end of stream         }         if (bytesCount > 0) {           ++pointer;         }         if (bytesNeeded == 0) {           if ((b & 0x7f) == b) {             builder.Append((char)b);           } else if (b >= 0xc2 && b <= 0xdf) {             bytesNeeded = 1;             cp = (b - 0xc0) << 6;           } else if (b >= 0xe0 && b <= 0xef) {             lower = (b == 0xe0) ? 0xa0 : 0x80;             upper = (b == 0xed) ? 0x9f : 0xbf;             bytesNeeded = 2;             cp = (b - 0xe0) << 12;           } else if (b >= 0xf0 && b <= 0xf4) {             lower = (b == 0xf0) ? 0x90 : 0x80;             upper = (b == 0xf4) ? 0x8f : 0xbf;             bytesNeeded = 3;             cp = (b - 0xf0) << 18;           } else {             if (replace) {               builder.Append((char)0xfffd);             } else {               return -1;             }           }           continue;         }         if (b < lower || b > upper) {           cp = bytesNeeded = bytesSeen = 0;           lower = 0x80;           upper = 0xbf;           if (replace) {             builder.Append((char)0xfffd);             // "Read" the last byte again             if (b < 0x80) {               builder.Append((char)b);             } else if (b >= 0xc2 && b <= 0xdf) {               bytesNeeded = 1;               cp = (b - 0xc0) << 6;             } else if (b >= 0xe0 && b <= 0xef) {               lower = (b == 0xe0) ? 0xa0 : 0x80;               upper = (b == 0xed) ? 0x9f : 0xbf;               bytesNeeded = 2;               cp = (b - 0xe0) << 12;             } else if (b >= 0xf0 && b <= 0xf4) {               lower = (b == 0xf0) ? 0x90 : 0x80;               upper = (b == 0xf4) ? 0x8f : 0xbf;               bytesNeeded = 3;               cp = (b - 0xf0) << 18;             } else {               builder.Append((char)0xfffd);             }             continue;           }           return -1;         } else {           lower = 0x80;           upper = 0xbf;           ++bytesSeen;           cp += (b - 0x80) << (6 * (bytesNeeded - bytesSeen));           if (bytesSeen != bytesNeeded) {             continue;           }           int ret' ch' lead' trail;           ret = cp;           cp = 0;           bytesSeen = 0;           bytesNeeded = 0;           if (ret <= 0xffff) {             builder.Append((char)ret);           } else {              ch = ret - 0x10000;              lead = (ch >> 10) + 0xd800;              trail = (ch & 0x3ff) + 0xdc00;             builder.Append((char)lead);             builder.Append((char)trail);           }         }       }
Magic Number,PeterO,DataUtilities,C:\repos\peteroupc_CBOR\CBOR\PeterO\DataUtilities.cs,ReadUtf8,The following statement contains a magic number: while (pointer < bytesCount || bytesCount < 0) {         b = stream.ReadByte();         if (b < 0) {           if (bytesNeeded != 0) {             bytesNeeded = 0;             if (replace) {               builder.Append((char)0xfffd);               if (bytesCount >= 0) {                 return -2;               }               break;  // end of stream             }             return -1;           }           if (bytesCount >= 0) {             return -2;           }           break;  // end of stream         }         if (bytesCount > 0) {           ++pointer;         }         if (bytesNeeded == 0) {           if ((b & 0x7f) == b) {             builder.Append((char)b);           } else if (b >= 0xc2 && b <= 0xdf) {             bytesNeeded = 1;             cp = (b - 0xc0) << 6;           } else if (b >= 0xe0 && b <= 0xef) {             lower = (b == 0xe0) ? 0xa0 : 0x80;             upper = (b == 0xed) ? 0x9f : 0xbf;             bytesNeeded = 2;             cp = (b - 0xe0) << 12;           } else if (b >= 0xf0 && b <= 0xf4) {             lower = (b == 0xf0) ? 0x90 : 0x80;             upper = (b == 0xf4) ? 0x8f : 0xbf;             bytesNeeded = 3;             cp = (b - 0xf0) << 18;           } else {             if (replace) {               builder.Append((char)0xfffd);             } else {               return -1;             }           }           continue;         }         if (b < lower || b > upper) {           cp = bytesNeeded = bytesSeen = 0;           lower = 0x80;           upper = 0xbf;           if (replace) {             builder.Append((char)0xfffd);             // "Read" the last byte again             if (b < 0x80) {               builder.Append((char)b);             } else if (b >= 0xc2 && b <= 0xdf) {               bytesNeeded = 1;               cp = (b - 0xc0) << 6;             } else if (b >= 0xe0 && b <= 0xef) {               lower = (b == 0xe0) ? 0xa0 : 0x80;               upper = (b == 0xed) ? 0x9f : 0xbf;               bytesNeeded = 2;               cp = (b - 0xe0) << 12;             } else if (b >= 0xf0 && b <= 0xf4) {               lower = (b == 0xf0) ? 0x90 : 0x80;               upper = (b == 0xf4) ? 0x8f : 0xbf;               bytesNeeded = 3;               cp = (b - 0xf0) << 18;             } else {               builder.Append((char)0xfffd);             }             continue;           }           return -1;         } else {           lower = 0x80;           upper = 0xbf;           ++bytesSeen;           cp += (b - 0x80) << (6 * (bytesNeeded - bytesSeen));           if (bytesSeen != bytesNeeded) {             continue;           }           int ret' ch' lead' trail;           ret = cp;           cp = 0;           bytesSeen = 0;           bytesNeeded = 0;           if (ret <= 0xffff) {             builder.Append((char)ret);           } else {              ch = ret - 0x10000;              lead = (ch >> 10) + 0xd800;              trail = (ch & 0x3ff) + 0xdc00;             builder.Append((char)lead);             builder.Append((char)trail);           }         }       }
Magic Number,PeterO,DataUtilities,C:\repos\peteroupc_CBOR\CBOR\PeterO\DataUtilities.cs,ReadUtf8,The following statement contains a magic number: while (pointer < bytesCount || bytesCount < 0) {         b = stream.ReadByte();         if (b < 0) {           if (bytesNeeded != 0) {             bytesNeeded = 0;             if (replace) {               builder.Append((char)0xfffd);               if (bytesCount >= 0) {                 return -2;               }               break;  // end of stream             }             return -1;           }           if (bytesCount >= 0) {             return -2;           }           break;  // end of stream         }         if (bytesCount > 0) {           ++pointer;         }         if (bytesNeeded == 0) {           if ((b & 0x7f) == b) {             builder.Append((char)b);           } else if (b >= 0xc2 && b <= 0xdf) {             bytesNeeded = 1;             cp = (b - 0xc0) << 6;           } else if (b >= 0xe0 && b <= 0xef) {             lower = (b == 0xe0) ? 0xa0 : 0x80;             upper = (b == 0xed) ? 0x9f : 0xbf;             bytesNeeded = 2;             cp = (b - 0xe0) << 12;           } else if (b >= 0xf0 && b <= 0xf4) {             lower = (b == 0xf0) ? 0x90 : 0x80;             upper = (b == 0xf4) ? 0x8f : 0xbf;             bytesNeeded = 3;             cp = (b - 0xf0) << 18;           } else {             if (replace) {               builder.Append((char)0xfffd);             } else {               return -1;             }           }           continue;         }         if (b < lower || b > upper) {           cp = bytesNeeded = bytesSeen = 0;           lower = 0x80;           upper = 0xbf;           if (replace) {             builder.Append((char)0xfffd);             // "Read" the last byte again             if (b < 0x80) {               builder.Append((char)b);             } else if (b >= 0xc2 && b <= 0xdf) {               bytesNeeded = 1;               cp = (b - 0xc0) << 6;             } else if (b >= 0xe0 && b <= 0xef) {               lower = (b == 0xe0) ? 0xa0 : 0x80;               upper = (b == 0xed) ? 0x9f : 0xbf;               bytesNeeded = 2;               cp = (b - 0xe0) << 12;             } else if (b >= 0xf0 && b <= 0xf4) {               lower = (b == 0xf0) ? 0x90 : 0x80;               upper = (b == 0xf4) ? 0x8f : 0xbf;               bytesNeeded = 3;               cp = (b - 0xf0) << 18;             } else {               builder.Append((char)0xfffd);             }             continue;           }           return -1;         } else {           lower = 0x80;           upper = 0xbf;           ++bytesSeen;           cp += (b - 0x80) << (6 * (bytesNeeded - bytesSeen));           if (bytesSeen != bytesNeeded) {             continue;           }           int ret' ch' lead' trail;           ret = cp;           cp = 0;           bytesSeen = 0;           bytesNeeded = 0;           if (ret <= 0xffff) {             builder.Append((char)ret);           } else {              ch = ret - 0x10000;              lead = (ch >> 10) + 0xd800;              trail = (ch & 0x3ff) + 0xdc00;             builder.Append((char)lead);             builder.Append((char)trail);           }         }       }
Magic Number,PeterO,DataUtilities,C:\repos\peteroupc_CBOR\CBOR\PeterO\DataUtilities.cs,ReadUtf8,The following statement contains a magic number: while (pointer < bytesCount || bytesCount < 0) {         b = stream.ReadByte();         if (b < 0) {           if (bytesNeeded != 0) {             bytesNeeded = 0;             if (replace) {               builder.Append((char)0xfffd);               if (bytesCount >= 0) {                 return -2;               }               break;  // end of stream             }             return -1;           }           if (bytesCount >= 0) {             return -2;           }           break;  // end of stream         }         if (bytesCount > 0) {           ++pointer;         }         if (bytesNeeded == 0) {           if ((b & 0x7f) == b) {             builder.Append((char)b);           } else if (b >= 0xc2 && b <= 0xdf) {             bytesNeeded = 1;             cp = (b - 0xc0) << 6;           } else if (b >= 0xe0 && b <= 0xef) {             lower = (b == 0xe0) ? 0xa0 : 0x80;             upper = (b == 0xed) ? 0x9f : 0xbf;             bytesNeeded = 2;             cp = (b - 0xe0) << 12;           } else if (b >= 0xf0 && b <= 0xf4) {             lower = (b == 0xf0) ? 0x90 : 0x80;             upper = (b == 0xf4) ? 0x8f : 0xbf;             bytesNeeded = 3;             cp = (b - 0xf0) << 18;           } else {             if (replace) {               builder.Append((char)0xfffd);             } else {               return -1;             }           }           continue;         }         if (b < lower || b > upper) {           cp = bytesNeeded = bytesSeen = 0;           lower = 0x80;           upper = 0xbf;           if (replace) {             builder.Append((char)0xfffd);             // "Read" the last byte again             if (b < 0x80) {               builder.Append((char)b);             } else if (b >= 0xc2 && b <= 0xdf) {               bytesNeeded = 1;               cp = (b - 0xc0) << 6;             } else if (b >= 0xe0 && b <= 0xef) {               lower = (b == 0xe0) ? 0xa0 : 0x80;               upper = (b == 0xed) ? 0x9f : 0xbf;               bytesNeeded = 2;               cp = (b - 0xe0) << 12;             } else if (b >= 0xf0 && b <= 0xf4) {               lower = (b == 0xf0) ? 0x90 : 0x80;               upper = (b == 0xf4) ? 0x8f : 0xbf;               bytesNeeded = 3;               cp = (b - 0xf0) << 18;             } else {               builder.Append((char)0xfffd);             }             continue;           }           return -1;         } else {           lower = 0x80;           upper = 0xbf;           ++bytesSeen;           cp += (b - 0x80) << (6 * (bytesNeeded - bytesSeen));           if (bytesSeen != bytesNeeded) {             continue;           }           int ret' ch' lead' trail;           ret = cp;           cp = 0;           bytesSeen = 0;           bytesNeeded = 0;           if (ret <= 0xffff) {             builder.Append((char)ret);           } else {              ch = ret - 0x10000;              lead = (ch >> 10) + 0xd800;              trail = (ch & 0x3ff) + 0xdc00;             builder.Append((char)lead);             builder.Append((char)trail);           }         }       }
Magic Number,PeterO,DataUtilities,C:\repos\peteroupc_CBOR\CBOR\PeterO\DataUtilities.cs,ReadUtf8,The following statement contains a magic number: while (pointer < bytesCount || bytesCount < 0) {         b = stream.ReadByte();         if (b < 0) {           if (bytesNeeded != 0) {             bytesNeeded = 0;             if (replace) {               builder.Append((char)0xfffd);               if (bytesCount >= 0) {                 return -2;               }               break;  // end of stream             }             return -1;           }           if (bytesCount >= 0) {             return -2;           }           break;  // end of stream         }         if (bytesCount > 0) {           ++pointer;         }         if (bytesNeeded == 0) {           if ((b & 0x7f) == b) {             builder.Append((char)b);           } else if (b >= 0xc2 && b <= 0xdf) {             bytesNeeded = 1;             cp = (b - 0xc0) << 6;           } else if (b >= 0xe0 && b <= 0xef) {             lower = (b == 0xe0) ? 0xa0 : 0x80;             upper = (b == 0xed) ? 0x9f : 0xbf;             bytesNeeded = 2;             cp = (b - 0xe0) << 12;           } else if (b >= 0xf0 && b <= 0xf4) {             lower = (b == 0xf0) ? 0x90 : 0x80;             upper = (b == 0xf4) ? 0x8f : 0xbf;             bytesNeeded = 3;             cp = (b - 0xf0) << 18;           } else {             if (replace) {               builder.Append((char)0xfffd);             } else {               return -1;             }           }           continue;         }         if (b < lower || b > upper) {           cp = bytesNeeded = bytesSeen = 0;           lower = 0x80;           upper = 0xbf;           if (replace) {             builder.Append((char)0xfffd);             // "Read" the last byte again             if (b < 0x80) {               builder.Append((char)b);             } else if (b >= 0xc2 && b <= 0xdf) {               bytesNeeded = 1;               cp = (b - 0xc0) << 6;             } else if (b >= 0xe0 && b <= 0xef) {               lower = (b == 0xe0) ? 0xa0 : 0x80;               upper = (b == 0xed) ? 0x9f : 0xbf;               bytesNeeded = 2;               cp = (b - 0xe0) << 12;             } else if (b >= 0xf0 && b <= 0xf4) {               lower = (b == 0xf0) ? 0x90 : 0x80;               upper = (b == 0xf4) ? 0x8f : 0xbf;               bytesNeeded = 3;               cp = (b - 0xf0) << 18;             } else {               builder.Append((char)0xfffd);             }             continue;           }           return -1;         } else {           lower = 0x80;           upper = 0xbf;           ++bytesSeen;           cp += (b - 0x80) << (6 * (bytesNeeded - bytesSeen));           if (bytesSeen != bytesNeeded) {             continue;           }           int ret' ch' lead' trail;           ret = cp;           cp = 0;           bytesSeen = 0;           bytesNeeded = 0;           if (ret <= 0xffff) {             builder.Append((char)ret);           } else {              ch = ret - 0x10000;              lead = (ch >> 10) + 0xd800;              trail = (ch & 0x3ff) + 0xdc00;             builder.Append((char)lead);             builder.Append((char)trail);           }         }       }
Magic Number,PeterO,DataUtilities,C:\repos\peteroupc_CBOR\CBOR\PeterO\DataUtilities.cs,ReadUtf8,The following statement contains a magic number: while (pointer < bytesCount || bytesCount < 0) {         b = stream.ReadByte();         if (b < 0) {           if (bytesNeeded != 0) {             bytesNeeded = 0;             if (replace) {               builder.Append((char)0xfffd);               if (bytesCount >= 0) {                 return -2;               }               break;  // end of stream             }             return -1;           }           if (bytesCount >= 0) {             return -2;           }           break;  // end of stream         }         if (bytesCount > 0) {           ++pointer;         }         if (bytesNeeded == 0) {           if ((b & 0x7f) == b) {             builder.Append((char)b);           } else if (b >= 0xc2 && b <= 0xdf) {             bytesNeeded = 1;             cp = (b - 0xc0) << 6;           } else if (b >= 0xe0 && b <= 0xef) {             lower = (b == 0xe0) ? 0xa0 : 0x80;             upper = (b == 0xed) ? 0x9f : 0xbf;             bytesNeeded = 2;             cp = (b - 0xe0) << 12;           } else if (b >= 0xf0 && b <= 0xf4) {             lower = (b == 0xf0) ? 0x90 : 0x80;             upper = (b == 0xf4) ? 0x8f : 0xbf;             bytesNeeded = 3;             cp = (b - 0xf0) << 18;           } else {             if (replace) {               builder.Append((char)0xfffd);             } else {               return -1;             }           }           continue;         }         if (b < lower || b > upper) {           cp = bytesNeeded = bytesSeen = 0;           lower = 0x80;           upper = 0xbf;           if (replace) {             builder.Append((char)0xfffd);             // "Read" the last byte again             if (b < 0x80) {               builder.Append((char)b);             } else if (b >= 0xc2 && b <= 0xdf) {               bytesNeeded = 1;               cp = (b - 0xc0) << 6;             } else if (b >= 0xe0 && b <= 0xef) {               lower = (b == 0xe0) ? 0xa0 : 0x80;               upper = (b == 0xed) ? 0x9f : 0xbf;               bytesNeeded = 2;               cp = (b - 0xe0) << 12;             } else if (b >= 0xf0 && b <= 0xf4) {               lower = (b == 0xf0) ? 0x90 : 0x80;               upper = (b == 0xf4) ? 0x8f : 0xbf;               bytesNeeded = 3;               cp = (b - 0xf0) << 18;             } else {               builder.Append((char)0xfffd);             }             continue;           }           return -1;         } else {           lower = 0x80;           upper = 0xbf;           ++bytesSeen;           cp += (b - 0x80) << (6 * (bytesNeeded - bytesSeen));           if (bytesSeen != bytesNeeded) {             continue;           }           int ret' ch' lead' trail;           ret = cp;           cp = 0;           bytesSeen = 0;           bytesNeeded = 0;           if (ret <= 0xffff) {             builder.Append((char)ret);           } else {              ch = ret - 0x10000;              lead = (ch >> 10) + 0xd800;              trail = (ch & 0x3ff) + 0xdc00;             builder.Append((char)lead);             builder.Append((char)trail);           }         }       }
Magic Number,PeterO,DataUtilities,C:\repos\peteroupc_CBOR\CBOR\PeterO\DataUtilities.cs,ReadUtf8,The following statement contains a magic number: while (pointer < bytesCount || bytesCount < 0) {         b = stream.ReadByte();         if (b < 0) {           if (bytesNeeded != 0) {             bytesNeeded = 0;             if (replace) {               builder.Append((char)0xfffd);               if (bytesCount >= 0) {                 return -2;               }               break;  // end of stream             }             return -1;           }           if (bytesCount >= 0) {             return -2;           }           break;  // end of stream         }         if (bytesCount > 0) {           ++pointer;         }         if (bytesNeeded == 0) {           if ((b & 0x7f) == b) {             builder.Append((char)b);           } else if (b >= 0xc2 && b <= 0xdf) {             bytesNeeded = 1;             cp = (b - 0xc0) << 6;           } else if (b >= 0xe0 && b <= 0xef) {             lower = (b == 0xe0) ? 0xa0 : 0x80;             upper = (b == 0xed) ? 0x9f : 0xbf;             bytesNeeded = 2;             cp = (b - 0xe0) << 12;           } else if (b >= 0xf0 && b <= 0xf4) {             lower = (b == 0xf0) ? 0x90 : 0x80;             upper = (b == 0xf4) ? 0x8f : 0xbf;             bytesNeeded = 3;             cp = (b - 0xf0) << 18;           } else {             if (replace) {               builder.Append((char)0xfffd);             } else {               return -1;             }           }           continue;         }         if (b < lower || b > upper) {           cp = bytesNeeded = bytesSeen = 0;           lower = 0x80;           upper = 0xbf;           if (replace) {             builder.Append((char)0xfffd);             // "Read" the last byte again             if (b < 0x80) {               builder.Append((char)b);             } else if (b >= 0xc2 && b <= 0xdf) {               bytesNeeded = 1;               cp = (b - 0xc0) << 6;             } else if (b >= 0xe0 && b <= 0xef) {               lower = (b == 0xe0) ? 0xa0 : 0x80;               upper = (b == 0xed) ? 0x9f : 0xbf;               bytesNeeded = 2;               cp = (b - 0xe0) << 12;             } else if (b >= 0xf0 && b <= 0xf4) {               lower = (b == 0xf0) ? 0x90 : 0x80;               upper = (b == 0xf4) ? 0x8f : 0xbf;               bytesNeeded = 3;               cp = (b - 0xf0) << 18;             } else {               builder.Append((char)0xfffd);             }             continue;           }           return -1;         } else {           lower = 0x80;           upper = 0xbf;           ++bytesSeen;           cp += (b - 0x80) << (6 * (bytesNeeded - bytesSeen));           if (bytesSeen != bytesNeeded) {             continue;           }           int ret' ch' lead' trail;           ret = cp;           cp = 0;           bytesSeen = 0;           bytesNeeded = 0;           if (ret <= 0xffff) {             builder.Append((char)ret);           } else {              ch = ret - 0x10000;              lead = (ch >> 10) + 0xd800;              trail = (ch & 0x3ff) + 0xdc00;             builder.Append((char)lead);             builder.Append((char)trail);           }         }       }
Magic Number,PeterO,DataUtilities,C:\repos\peteroupc_CBOR\CBOR\PeterO\DataUtilities.cs,ReadUtf8,The following statement contains a magic number: while (pointer < bytesCount || bytesCount < 0) {         b = stream.ReadByte();         if (b < 0) {           if (bytesNeeded != 0) {             bytesNeeded = 0;             if (replace) {               builder.Append((char)0xfffd);               if (bytesCount >= 0) {                 return -2;               }               break;  // end of stream             }             return -1;           }           if (bytesCount >= 0) {             return -2;           }           break;  // end of stream         }         if (bytesCount > 0) {           ++pointer;         }         if (bytesNeeded == 0) {           if ((b & 0x7f) == b) {             builder.Append((char)b);           } else if (b >= 0xc2 && b <= 0xdf) {             bytesNeeded = 1;             cp = (b - 0xc0) << 6;           } else if (b >= 0xe0 && b <= 0xef) {             lower = (b == 0xe0) ? 0xa0 : 0x80;             upper = (b == 0xed) ? 0x9f : 0xbf;             bytesNeeded = 2;             cp = (b - 0xe0) << 12;           } else if (b >= 0xf0 && b <= 0xf4) {             lower = (b == 0xf0) ? 0x90 : 0x80;             upper = (b == 0xf4) ? 0x8f : 0xbf;             bytesNeeded = 3;             cp = (b - 0xf0) << 18;           } else {             if (replace) {               builder.Append((char)0xfffd);             } else {               return -1;             }           }           continue;         }         if (b < lower || b > upper) {           cp = bytesNeeded = bytesSeen = 0;           lower = 0x80;           upper = 0xbf;           if (replace) {             builder.Append((char)0xfffd);             // "Read" the last byte again             if (b < 0x80) {               builder.Append((char)b);             } else if (b >= 0xc2 && b <= 0xdf) {               bytesNeeded = 1;               cp = (b - 0xc0) << 6;             } else if (b >= 0xe0 && b <= 0xef) {               lower = (b == 0xe0) ? 0xa0 : 0x80;               upper = (b == 0xed) ? 0x9f : 0xbf;               bytesNeeded = 2;               cp = (b - 0xe0) << 12;             } else if (b >= 0xf0 && b <= 0xf4) {               lower = (b == 0xf0) ? 0x90 : 0x80;               upper = (b == 0xf4) ? 0x8f : 0xbf;               bytesNeeded = 3;               cp = (b - 0xf0) << 18;             } else {               builder.Append((char)0xfffd);             }             continue;           }           return -1;         } else {           lower = 0x80;           upper = 0xbf;           ++bytesSeen;           cp += (b - 0x80) << (6 * (bytesNeeded - bytesSeen));           if (bytesSeen != bytesNeeded) {             continue;           }           int ret' ch' lead' trail;           ret = cp;           cp = 0;           bytesSeen = 0;           bytesNeeded = 0;           if (ret <= 0xffff) {             builder.Append((char)ret);           } else {              ch = ret - 0x10000;              lead = (ch >> 10) + 0xd800;              trail = (ch & 0x3ff) + 0xdc00;             builder.Append((char)lead);             builder.Append((char)trail);           }         }       }
Magic Number,PeterO,DataUtilities,C:\repos\peteroupc_CBOR\CBOR\PeterO\DataUtilities.cs,ReadUtf8,The following statement contains a magic number: while (pointer < bytesCount || bytesCount < 0) {         b = stream.ReadByte();         if (b < 0) {           if (bytesNeeded != 0) {             bytesNeeded = 0;             if (replace) {               builder.Append((char)0xfffd);               if (bytesCount >= 0) {                 return -2;               }               break;  // end of stream             }             return -1;           }           if (bytesCount >= 0) {             return -2;           }           break;  // end of stream         }         if (bytesCount > 0) {           ++pointer;         }         if (bytesNeeded == 0) {           if ((b & 0x7f) == b) {             builder.Append((char)b);           } else if (b >= 0xc2 && b <= 0xdf) {             bytesNeeded = 1;             cp = (b - 0xc0) << 6;           } else if (b >= 0xe0 && b <= 0xef) {             lower = (b == 0xe0) ? 0xa0 : 0x80;             upper = (b == 0xed) ? 0x9f : 0xbf;             bytesNeeded = 2;             cp = (b - 0xe0) << 12;           } else if (b >= 0xf0 && b <= 0xf4) {             lower = (b == 0xf0) ? 0x90 : 0x80;             upper = (b == 0xf4) ? 0x8f : 0xbf;             bytesNeeded = 3;             cp = (b - 0xf0) << 18;           } else {             if (replace) {               builder.Append((char)0xfffd);             } else {               return -1;             }           }           continue;         }         if (b < lower || b > upper) {           cp = bytesNeeded = bytesSeen = 0;           lower = 0x80;           upper = 0xbf;           if (replace) {             builder.Append((char)0xfffd);             // "Read" the last byte again             if (b < 0x80) {               builder.Append((char)b);             } else if (b >= 0xc2 && b <= 0xdf) {               bytesNeeded = 1;               cp = (b - 0xc0) << 6;             } else if (b >= 0xe0 && b <= 0xef) {               lower = (b == 0xe0) ? 0xa0 : 0x80;               upper = (b == 0xed) ? 0x9f : 0xbf;               bytesNeeded = 2;               cp = (b - 0xe0) << 12;             } else if (b >= 0xf0 && b <= 0xf4) {               lower = (b == 0xf0) ? 0x90 : 0x80;               upper = (b == 0xf4) ? 0x8f : 0xbf;               bytesNeeded = 3;               cp = (b - 0xf0) << 18;             } else {               builder.Append((char)0xfffd);             }             continue;           }           return -1;         } else {           lower = 0x80;           upper = 0xbf;           ++bytesSeen;           cp += (b - 0x80) << (6 * (bytesNeeded - bytesSeen));           if (bytesSeen != bytesNeeded) {             continue;           }           int ret' ch' lead' trail;           ret = cp;           cp = 0;           bytesSeen = 0;           bytesNeeded = 0;           if (ret <= 0xffff) {             builder.Append((char)ret);           } else {              ch = ret - 0x10000;              lead = (ch >> 10) + 0xd800;              trail = (ch & 0x3ff) + 0xdc00;             builder.Append((char)lead);             builder.Append((char)trail);           }         }       }
Magic Number,PeterO,DataUtilities,C:\repos\peteroupc_CBOR\CBOR\PeterO\DataUtilities.cs,ReadUtf8,The following statement contains a magic number: while (pointer < bytesCount || bytesCount < 0) {         b = stream.ReadByte();         if (b < 0) {           if (bytesNeeded != 0) {             bytesNeeded = 0;             if (replace) {               builder.Append((char)0xfffd);               if (bytesCount >= 0) {                 return -2;               }               break;  // end of stream             }             return -1;           }           if (bytesCount >= 0) {             return -2;           }           break;  // end of stream         }         if (bytesCount > 0) {           ++pointer;         }         if (bytesNeeded == 0) {           if ((b & 0x7f) == b) {             builder.Append((char)b);           } else if (b >= 0xc2 && b <= 0xdf) {             bytesNeeded = 1;             cp = (b - 0xc0) << 6;           } else if (b >= 0xe0 && b <= 0xef) {             lower = (b == 0xe0) ? 0xa0 : 0x80;             upper = (b == 0xed) ? 0x9f : 0xbf;             bytesNeeded = 2;             cp = (b - 0xe0) << 12;           } else if (b >= 0xf0 && b <= 0xf4) {             lower = (b == 0xf0) ? 0x90 : 0x80;             upper = (b == 0xf4) ? 0x8f : 0xbf;             bytesNeeded = 3;             cp = (b - 0xf0) << 18;           } else {             if (replace) {               builder.Append((char)0xfffd);             } else {               return -1;             }           }           continue;         }         if (b < lower || b > upper) {           cp = bytesNeeded = bytesSeen = 0;           lower = 0x80;           upper = 0xbf;           if (replace) {             builder.Append((char)0xfffd);             // "Read" the last byte again             if (b < 0x80) {               builder.Append((char)b);             } else if (b >= 0xc2 && b <= 0xdf) {               bytesNeeded = 1;               cp = (b - 0xc0) << 6;             } else if (b >= 0xe0 && b <= 0xef) {               lower = (b == 0xe0) ? 0xa0 : 0x80;               upper = (b == 0xed) ? 0x9f : 0xbf;               bytesNeeded = 2;               cp = (b - 0xe0) << 12;             } else if (b >= 0xf0 && b <= 0xf4) {               lower = (b == 0xf0) ? 0x90 : 0x80;               upper = (b == 0xf4) ? 0x8f : 0xbf;               bytesNeeded = 3;               cp = (b - 0xf0) << 18;             } else {               builder.Append((char)0xfffd);             }             continue;           }           return -1;         } else {           lower = 0x80;           upper = 0xbf;           ++bytesSeen;           cp += (b - 0x80) << (6 * (bytesNeeded - bytesSeen));           if (bytesSeen != bytesNeeded) {             continue;           }           int ret' ch' lead' trail;           ret = cp;           cp = 0;           bytesSeen = 0;           bytesNeeded = 0;           if (ret <= 0xffff) {             builder.Append((char)ret);           } else {              ch = ret - 0x10000;              lead = (ch >> 10) + 0xd800;              trail = (ch & 0x3ff) + 0xdc00;             builder.Append((char)lead);             builder.Append((char)trail);           }         }       }
Magic Number,PeterO,DataUtilities,C:\repos\peteroupc_CBOR\CBOR\PeterO\DataUtilities.cs,ReadUtf8,The following statement contains a magic number: while (pointer < bytesCount || bytesCount < 0) {         b = stream.ReadByte();         if (b < 0) {           if (bytesNeeded != 0) {             bytesNeeded = 0;             if (replace) {               builder.Append((char)0xfffd);               if (bytesCount >= 0) {                 return -2;               }               break;  // end of stream             }             return -1;           }           if (bytesCount >= 0) {             return -2;           }           break;  // end of stream         }         if (bytesCount > 0) {           ++pointer;         }         if (bytesNeeded == 0) {           if ((b & 0x7f) == b) {             builder.Append((char)b);           } else if (b >= 0xc2 && b <= 0xdf) {             bytesNeeded = 1;             cp = (b - 0xc0) << 6;           } else if (b >= 0xe0 && b <= 0xef) {             lower = (b == 0xe0) ? 0xa0 : 0x80;             upper = (b == 0xed) ? 0x9f : 0xbf;             bytesNeeded = 2;             cp = (b - 0xe0) << 12;           } else if (b >= 0xf0 && b <= 0xf4) {             lower = (b == 0xf0) ? 0x90 : 0x80;             upper = (b == 0xf4) ? 0x8f : 0xbf;             bytesNeeded = 3;             cp = (b - 0xf0) << 18;           } else {             if (replace) {               builder.Append((char)0xfffd);             } else {               return -1;             }           }           continue;         }         if (b < lower || b > upper) {           cp = bytesNeeded = bytesSeen = 0;           lower = 0x80;           upper = 0xbf;           if (replace) {             builder.Append((char)0xfffd);             // "Read" the last byte again             if (b < 0x80) {               builder.Append((char)b);             } else if (b >= 0xc2 && b <= 0xdf) {               bytesNeeded = 1;               cp = (b - 0xc0) << 6;             } else if (b >= 0xe0 && b <= 0xef) {               lower = (b == 0xe0) ? 0xa0 : 0x80;               upper = (b == 0xed) ? 0x9f : 0xbf;               bytesNeeded = 2;               cp = (b - 0xe0) << 12;             } else if (b >= 0xf0 && b <= 0xf4) {               lower = (b == 0xf0) ? 0x90 : 0x80;               upper = (b == 0xf4) ? 0x8f : 0xbf;               bytesNeeded = 3;               cp = (b - 0xf0) << 18;             } else {               builder.Append((char)0xfffd);             }             continue;           }           return -1;         } else {           lower = 0x80;           upper = 0xbf;           ++bytesSeen;           cp += (b - 0x80) << (6 * (bytesNeeded - bytesSeen));           if (bytesSeen != bytesNeeded) {             continue;           }           int ret' ch' lead' trail;           ret = cp;           cp = 0;           bytesSeen = 0;           bytesNeeded = 0;           if (ret <= 0xffff) {             builder.Append((char)ret);           } else {              ch = ret - 0x10000;              lead = (ch >> 10) + 0xd800;              trail = (ch & 0x3ff) + 0xdc00;             builder.Append((char)lead);             builder.Append((char)trail);           }         }       }
Magic Number,PeterO,DataUtilities,C:\repos\peteroupc_CBOR\CBOR\PeterO\DataUtilities.cs,ReadUtf8,The following statement contains a magic number: while (pointer < bytesCount || bytesCount < 0) {         b = stream.ReadByte();         if (b < 0) {           if (bytesNeeded != 0) {             bytesNeeded = 0;             if (replace) {               builder.Append((char)0xfffd);               if (bytesCount >= 0) {                 return -2;               }               break;  // end of stream             }             return -1;           }           if (bytesCount >= 0) {             return -2;           }           break;  // end of stream         }         if (bytesCount > 0) {           ++pointer;         }         if (bytesNeeded == 0) {           if ((b & 0x7f) == b) {             builder.Append((char)b);           } else if (b >= 0xc2 && b <= 0xdf) {             bytesNeeded = 1;             cp = (b - 0xc0) << 6;           } else if (b >= 0xe0 && b <= 0xef) {             lower = (b == 0xe0) ? 0xa0 : 0x80;             upper = (b == 0xed) ? 0x9f : 0xbf;             bytesNeeded = 2;             cp = (b - 0xe0) << 12;           } else if (b >= 0xf0 && b <= 0xf4) {             lower = (b == 0xf0) ? 0x90 : 0x80;             upper = (b == 0xf4) ? 0x8f : 0xbf;             bytesNeeded = 3;             cp = (b - 0xf0) << 18;           } else {             if (replace) {               builder.Append((char)0xfffd);             } else {               return -1;             }           }           continue;         }         if (b < lower || b > upper) {           cp = bytesNeeded = bytesSeen = 0;           lower = 0x80;           upper = 0xbf;           if (replace) {             builder.Append((char)0xfffd);             // "Read" the last byte again             if (b < 0x80) {               builder.Append((char)b);             } else if (b >= 0xc2 && b <= 0xdf) {               bytesNeeded = 1;               cp = (b - 0xc0) << 6;             } else if (b >= 0xe0 && b <= 0xef) {               lower = (b == 0xe0) ? 0xa0 : 0x80;               upper = (b == 0xed) ? 0x9f : 0xbf;               bytesNeeded = 2;               cp = (b - 0xe0) << 12;             } else if (b >= 0xf0 && b <= 0xf4) {               lower = (b == 0xf0) ? 0x90 : 0x80;               upper = (b == 0xf4) ? 0x8f : 0xbf;               bytesNeeded = 3;               cp = (b - 0xf0) << 18;             } else {               builder.Append((char)0xfffd);             }             continue;           }           return -1;         } else {           lower = 0x80;           upper = 0xbf;           ++bytesSeen;           cp += (b - 0x80) << (6 * (bytesNeeded - bytesSeen));           if (bytesSeen != bytesNeeded) {             continue;           }           int ret' ch' lead' trail;           ret = cp;           cp = 0;           bytesSeen = 0;           bytesNeeded = 0;           if (ret <= 0xffff) {             builder.Append((char)ret);           } else {              ch = ret - 0x10000;              lead = (ch >> 10) + 0xd800;              trail = (ch & 0x3ff) + 0xdc00;             builder.Append((char)lead);             builder.Append((char)trail);           }         }       }
Magic Number,PeterO,DataUtilities,C:\repos\peteroupc_CBOR\CBOR\PeterO\DataUtilities.cs,ReadUtf8,The following statement contains a magic number: while (pointer < bytesCount || bytesCount < 0) {         b = stream.ReadByte();         if (b < 0) {           if (bytesNeeded != 0) {             bytesNeeded = 0;             if (replace) {               builder.Append((char)0xfffd);               if (bytesCount >= 0) {                 return -2;               }               break;  // end of stream             }             return -1;           }           if (bytesCount >= 0) {             return -2;           }           break;  // end of stream         }         if (bytesCount > 0) {           ++pointer;         }         if (bytesNeeded == 0) {           if ((b & 0x7f) == b) {             builder.Append((char)b);           } else if (b >= 0xc2 && b <= 0xdf) {             bytesNeeded = 1;             cp = (b - 0xc0) << 6;           } else if (b >= 0xe0 && b <= 0xef) {             lower = (b == 0xe0) ? 0xa0 : 0x80;             upper = (b == 0xed) ? 0x9f : 0xbf;             bytesNeeded = 2;             cp = (b - 0xe0) << 12;           } else if (b >= 0xf0 && b <= 0xf4) {             lower = (b == 0xf0) ? 0x90 : 0x80;             upper = (b == 0xf4) ? 0x8f : 0xbf;             bytesNeeded = 3;             cp = (b - 0xf0) << 18;           } else {             if (replace) {               builder.Append((char)0xfffd);             } else {               return -1;             }           }           continue;         }         if (b < lower || b > upper) {           cp = bytesNeeded = bytesSeen = 0;           lower = 0x80;           upper = 0xbf;           if (replace) {             builder.Append((char)0xfffd);             // "Read" the last byte again             if (b < 0x80) {               builder.Append((char)b);             } else if (b >= 0xc2 && b <= 0xdf) {               bytesNeeded = 1;               cp = (b - 0xc0) << 6;             } else if (b >= 0xe0 && b <= 0xef) {               lower = (b == 0xe0) ? 0xa0 : 0x80;               upper = (b == 0xed) ? 0x9f : 0xbf;               bytesNeeded = 2;               cp = (b - 0xe0) << 12;             } else if (b >= 0xf0 && b <= 0xf4) {               lower = (b == 0xf0) ? 0x90 : 0x80;               upper = (b == 0xf4) ? 0x8f : 0xbf;               bytesNeeded = 3;               cp = (b - 0xf0) << 18;             } else {               builder.Append((char)0xfffd);             }             continue;           }           return -1;         } else {           lower = 0x80;           upper = 0xbf;           ++bytesSeen;           cp += (b - 0x80) << (6 * (bytesNeeded - bytesSeen));           if (bytesSeen != bytesNeeded) {             continue;           }           int ret' ch' lead' trail;           ret = cp;           cp = 0;           bytesSeen = 0;           bytesNeeded = 0;           if (ret <= 0xffff) {             builder.Append((char)ret);           } else {              ch = ret - 0x10000;              lead = (ch >> 10) + 0xd800;              trail = (ch & 0x3ff) + 0xdc00;             builder.Append((char)lead);             builder.Append((char)trail);           }         }       }
Magic Number,PeterO.Cbor,Base64,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\Base64.cs,WriteBase64,The following statement contains a magic number: var buffer = new char[4];
Magic Number,PeterO.Cbor,Base64,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\Base64.cs,WriteBase64,The following statement contains a magic number: for (i = offset; i < (length - 2); i += 3) {         buffer[0] = (char)alphabet[(data[i] >> 2) & 63];         buffer[1] = (char)alphabet[((data[i] & 3) << 4) +                 ((data[i + 1] >> 4) & 15)];         buffer[2] = (char)alphabet[((data[i + 1] & 15) << 2) + ((data[i +                 2] >> 6) & 3)];         buffer[3] = (char)alphabet[data[i + 2] & 63];         writer.WriteCodePoint((int)buffer[0]);         writer.WriteCodePoint((int)buffer[1]);         writer.WriteCodePoint((int)buffer[2]);         writer.WriteCodePoint((int)buffer[3]);       }
Magic Number,PeterO.Cbor,Base64,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\Base64.cs,WriteBase64,The following statement contains a magic number: for (i = offset; i < (length - 2); i += 3) {         buffer[0] = (char)alphabet[(data[i] >> 2) & 63];         buffer[1] = (char)alphabet[((data[i] & 3) << 4) +                 ((data[i + 1] >> 4) & 15)];         buffer[2] = (char)alphabet[((data[i + 1] & 15) << 2) + ((data[i +                 2] >> 6) & 3)];         buffer[3] = (char)alphabet[data[i + 2] & 63];         writer.WriteCodePoint((int)buffer[0]);         writer.WriteCodePoint((int)buffer[1]);         writer.WriteCodePoint((int)buffer[2]);         writer.WriteCodePoint((int)buffer[3]);       }
Magic Number,PeterO.Cbor,Base64,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\Base64.cs,WriteBase64,The following statement contains a magic number: for (i = offset; i < (length - 2); i += 3) {         buffer[0] = (char)alphabet[(data[i] >> 2) & 63];         buffer[1] = (char)alphabet[((data[i] & 3) << 4) +                 ((data[i + 1] >> 4) & 15)];         buffer[2] = (char)alphabet[((data[i + 1] & 15) << 2) + ((data[i +                 2] >> 6) & 3)];         buffer[3] = (char)alphabet[data[i + 2] & 63];         writer.WriteCodePoint((int)buffer[0]);         writer.WriteCodePoint((int)buffer[1]);         writer.WriteCodePoint((int)buffer[2]);         writer.WriteCodePoint((int)buffer[3]);       }
Magic Number,PeterO.Cbor,Base64,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\Base64.cs,WriteBase64,The following statement contains a magic number: for (i = offset; i < (length - 2); i += 3) {         buffer[0] = (char)alphabet[(data[i] >> 2) & 63];         buffer[1] = (char)alphabet[((data[i] & 3) << 4) +                 ((data[i + 1] >> 4) & 15)];         buffer[2] = (char)alphabet[((data[i + 1] & 15) << 2) + ((data[i +                 2] >> 6) & 3)];         buffer[3] = (char)alphabet[data[i + 2] & 63];         writer.WriteCodePoint((int)buffer[0]);         writer.WriteCodePoint((int)buffer[1]);         writer.WriteCodePoint((int)buffer[2]);         writer.WriteCodePoint((int)buffer[3]);       }
Magic Number,PeterO.Cbor,Base64,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\Base64.cs,WriteBase64,The following statement contains a magic number: for (i = offset; i < (length - 2); i += 3) {         buffer[0] = (char)alphabet[(data[i] >> 2) & 63];         buffer[1] = (char)alphabet[((data[i] & 3) << 4) +                 ((data[i + 1] >> 4) & 15)];         buffer[2] = (char)alphabet[((data[i + 1] & 15) << 2) + ((data[i +                 2] >> 6) & 3)];         buffer[3] = (char)alphabet[data[i + 2] & 63];         writer.WriteCodePoint((int)buffer[0]);         writer.WriteCodePoint((int)buffer[1]);         writer.WriteCodePoint((int)buffer[2]);         writer.WriteCodePoint((int)buffer[3]);       }
Magic Number,PeterO.Cbor,Base64,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\Base64.cs,WriteBase64,The following statement contains a magic number: for (i = offset; i < (length - 2); i += 3) {         buffer[0] = (char)alphabet[(data[i] >> 2) & 63];         buffer[1] = (char)alphabet[((data[i] & 3) << 4) +                 ((data[i + 1] >> 4) & 15)];         buffer[2] = (char)alphabet[((data[i + 1] & 15) << 2) + ((data[i +                 2] >> 6) & 3)];         buffer[3] = (char)alphabet[data[i + 2] & 63];         writer.WriteCodePoint((int)buffer[0]);         writer.WriteCodePoint((int)buffer[1]);         writer.WriteCodePoint((int)buffer[2]);         writer.WriteCodePoint((int)buffer[3]);       }
Magic Number,PeterO.Cbor,Base64,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\Base64.cs,WriteBase64,The following statement contains a magic number: for (i = offset; i < (length - 2); i += 3) {         buffer[0] = (char)alphabet[(data[i] >> 2) & 63];         buffer[1] = (char)alphabet[((data[i] & 3) << 4) +                 ((data[i + 1] >> 4) & 15)];         buffer[2] = (char)alphabet[((data[i + 1] & 15) << 2) + ((data[i +                 2] >> 6) & 3)];         buffer[3] = (char)alphabet[data[i + 2] & 63];         writer.WriteCodePoint((int)buffer[0]);         writer.WriteCodePoint((int)buffer[1]);         writer.WriteCodePoint((int)buffer[2]);         writer.WriteCodePoint((int)buffer[3]);       }
Magic Number,PeterO.Cbor,Base64,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\Base64.cs,WriteBase64,The following statement contains a magic number: for (i = offset; i < (length - 2); i += 3) {         buffer[0] = (char)alphabet[(data[i] >> 2) & 63];         buffer[1] = (char)alphabet[((data[i] & 3) << 4) +                 ((data[i + 1] >> 4) & 15)];         buffer[2] = (char)alphabet[((data[i + 1] & 15) << 2) + ((data[i +                 2] >> 6) & 3)];         buffer[3] = (char)alphabet[data[i + 2] & 63];         writer.WriteCodePoint((int)buffer[0]);         writer.WriteCodePoint((int)buffer[1]);         writer.WriteCodePoint((int)buffer[2]);         writer.WriteCodePoint((int)buffer[3]);       }
Magic Number,PeterO.Cbor,Base64,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\Base64.cs,WriteBase64,The following statement contains a magic number: for (i = offset; i < (length - 2); i += 3) {         buffer[0] = (char)alphabet[(data[i] >> 2) & 63];         buffer[1] = (char)alphabet[((data[i] & 3) << 4) +                 ((data[i + 1] >> 4) & 15)];         buffer[2] = (char)alphabet[((data[i + 1] & 15) << 2) + ((data[i +                 2] >> 6) & 3)];         buffer[3] = (char)alphabet[data[i + 2] & 63];         writer.WriteCodePoint((int)buffer[0]);         writer.WriteCodePoint((int)buffer[1]);         writer.WriteCodePoint((int)buffer[2]);         writer.WriteCodePoint((int)buffer[3]);       }
Magic Number,PeterO.Cbor,Base64,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\Base64.cs,WriteBase64,The following statement contains a magic number: for (i = offset; i < (length - 2); i += 3) {         buffer[0] = (char)alphabet[(data[i] >> 2) & 63];         buffer[1] = (char)alphabet[((data[i] & 3) << 4) +                 ((data[i + 1] >> 4) & 15)];         buffer[2] = (char)alphabet[((data[i + 1] & 15) << 2) + ((data[i +                 2] >> 6) & 3)];         buffer[3] = (char)alphabet[data[i + 2] & 63];         writer.WriteCodePoint((int)buffer[0]);         writer.WriteCodePoint((int)buffer[1]);         writer.WriteCodePoint((int)buffer[2]);         writer.WriteCodePoint((int)buffer[3]);       }
Magic Number,PeterO.Cbor,Base64,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\Base64.cs,WriteBase64,The following statement contains a magic number: for (i = offset; i < (length - 2); i += 3) {         buffer[0] = (char)alphabet[(data[i] >> 2) & 63];         buffer[1] = (char)alphabet[((data[i] & 3) << 4) +                 ((data[i + 1] >> 4) & 15)];         buffer[2] = (char)alphabet[((data[i + 1] & 15) << 2) + ((data[i +                 2] >> 6) & 3)];         buffer[3] = (char)alphabet[data[i + 2] & 63];         writer.WriteCodePoint((int)buffer[0]);         writer.WriteCodePoint((int)buffer[1]);         writer.WriteCodePoint((int)buffer[2]);         writer.WriteCodePoint((int)buffer[3]);       }
Magic Number,PeterO.Cbor,Base64,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\Base64.cs,WriteBase64,The following statement contains a magic number: for (i = offset; i < (length - 2); i += 3) {         buffer[0] = (char)alphabet[(data[i] >> 2) & 63];         buffer[1] = (char)alphabet[((data[i] & 3) << 4) +                 ((data[i + 1] >> 4) & 15)];         buffer[2] = (char)alphabet[((data[i + 1] & 15) << 2) + ((data[i +                 2] >> 6) & 3)];         buffer[3] = (char)alphabet[data[i + 2] & 63];         writer.WriteCodePoint((int)buffer[0]);         writer.WriteCodePoint((int)buffer[1]);         writer.WriteCodePoint((int)buffer[2]);         writer.WriteCodePoint((int)buffer[3]);       }
Magic Number,PeterO.Cbor,Base64,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\Base64.cs,WriteBase64,The following statement contains a magic number: for (i = offset; i < (length - 2); i += 3) {         buffer[0] = (char)alphabet[(data[i] >> 2) & 63];         buffer[1] = (char)alphabet[((data[i] & 3) << 4) +                 ((data[i + 1] >> 4) & 15)];         buffer[2] = (char)alphabet[((data[i + 1] & 15) << 2) + ((data[i +                 2] >> 6) & 3)];         buffer[3] = (char)alphabet[data[i + 2] & 63];         writer.WriteCodePoint((int)buffer[0]);         writer.WriteCodePoint((int)buffer[1]);         writer.WriteCodePoint((int)buffer[2]);         writer.WriteCodePoint((int)buffer[3]);       }
Magic Number,PeterO.Cbor,Base64,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\Base64.cs,WriteBase64,The following statement contains a magic number: for (i = offset; i < (length - 2); i += 3) {         buffer[0] = (char)alphabet[(data[i] >> 2) & 63];         buffer[1] = (char)alphabet[((data[i] & 3) << 4) +                 ((data[i + 1] >> 4) & 15)];         buffer[2] = (char)alphabet[((data[i + 1] & 15) << 2) + ((data[i +                 2] >> 6) & 3)];         buffer[3] = (char)alphabet[data[i + 2] & 63];         writer.WriteCodePoint((int)buffer[0]);         writer.WriteCodePoint((int)buffer[1]);         writer.WriteCodePoint((int)buffer[2]);         writer.WriteCodePoint((int)buffer[3]);       }
Magic Number,PeterO.Cbor,Base64,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\Base64.cs,WriteBase64,The following statement contains a magic number: for (i = offset; i < (length - 2); i += 3) {         buffer[0] = (char)alphabet[(data[i] >> 2) & 63];         buffer[1] = (char)alphabet[((data[i] & 3) << 4) +                 ((data[i + 1] >> 4) & 15)];         buffer[2] = (char)alphabet[((data[i + 1] & 15) << 2) + ((data[i +                 2] >> 6) & 3)];         buffer[3] = (char)alphabet[data[i + 2] & 63];         writer.WriteCodePoint((int)buffer[0]);         writer.WriteCodePoint((int)buffer[1]);         writer.WriteCodePoint((int)buffer[2]);         writer.WriteCodePoint((int)buffer[3]);       }
Magic Number,PeterO.Cbor,Base64,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\Base64.cs,WriteBase64,The following statement contains a magic number: for (i = offset; i < (length - 2); i += 3) {         buffer[0] = (char)alphabet[(data[i] >> 2) & 63];         buffer[1] = (char)alphabet[((data[i] & 3) << 4) +                 ((data[i + 1] >> 4) & 15)];         buffer[2] = (char)alphabet[((data[i + 1] & 15) << 2) + ((data[i +                 2] >> 6) & 3)];         buffer[3] = (char)alphabet[data[i + 2] & 63];         writer.WriteCodePoint((int)buffer[0]);         writer.WriteCodePoint((int)buffer[1]);         writer.WriteCodePoint((int)buffer[2]);         writer.WriteCodePoint((int)buffer[3]);       }
Magic Number,PeterO.Cbor,Base64,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\Base64.cs,WriteBase64,The following statement contains a magic number: for (i = offset; i < (length - 2); i += 3) {         buffer[0] = (char)alphabet[(data[i] >> 2) & 63];         buffer[1] = (char)alphabet[((data[i] & 3) << 4) +                 ((data[i + 1] >> 4) & 15)];         buffer[2] = (char)alphabet[((data[i + 1] & 15) << 2) + ((data[i +                 2] >> 6) & 3)];         buffer[3] = (char)alphabet[data[i + 2] & 63];         writer.WriteCodePoint((int)buffer[0]);         writer.WriteCodePoint((int)buffer[1]);         writer.WriteCodePoint((int)buffer[2]);         writer.WriteCodePoint((int)buffer[3]);       }
Magic Number,PeterO.Cbor,Base64,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\Base64.cs,WriteBase64,The following statement contains a magic number: for (i = offset; i < (length - 2); i += 3) {         buffer[0] = (char)alphabet[(data[i] >> 2) & 63];         buffer[1] = (char)alphabet[((data[i] & 3) << 4) +                 ((data[i + 1] >> 4) & 15)];         buffer[2] = (char)alphabet[((data[i + 1] & 15) << 2) + ((data[i +                 2] >> 6) & 3)];         buffer[3] = (char)alphabet[data[i + 2] & 63];         writer.WriteCodePoint((int)buffer[0]);         writer.WriteCodePoint((int)buffer[1]);         writer.WriteCodePoint((int)buffer[2]);         writer.WriteCodePoint((int)buffer[3]);       }
Magic Number,PeterO.Cbor,Base64,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\Base64.cs,WriteBase64,The following statement contains a magic number: for (i = offset; i < (length - 2); i += 3) {         buffer[0] = (char)alphabet[(data[i] >> 2) & 63];         buffer[1] = (char)alphabet[((data[i] & 3) << 4) +                 ((data[i + 1] >> 4) & 15)];         buffer[2] = (char)alphabet[((data[i + 1] & 15) << 2) + ((data[i +                 2] >> 6) & 3)];         buffer[3] = (char)alphabet[data[i + 2] & 63];         writer.WriteCodePoint((int)buffer[0]);         writer.WriteCodePoint((int)buffer[1]);         writer.WriteCodePoint((int)buffer[2]);         writer.WriteCodePoint((int)buffer[3]);       }
Magic Number,PeterO.Cbor,Base64,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\Base64.cs,WriteBase64,The following statement contains a magic number: int lenmod3 = count % 3;
Magic Number,PeterO.Cbor,Base64,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\Base64.cs,WriteBase64,The following statement contains a magic number: if (lenmod3 != 0) {         i = length - lenmod3;         buffer[0] = (char)alphabet[(data[i] >> 2) & 63];         if (lenmod3 == 2) {           buffer[1] = (char)alphabet[((data[i] & 3) << 4) + ((data[i + 1] >>                 4) & 15)];           buffer[2] = (char)alphabet[(data[i + 1] & 15) << 2];           writer.WriteCodePoint((int)buffer[0]);           writer.WriteCodePoint((int)buffer[1]);           writer.WriteCodePoint((int)buffer[2]);           if (padding) {             writer.WriteCodePoint((int)'=');           }         } else {           buffer[1] = (char)alphabet[(data[i] & 3) << 4];           writer.WriteCodePoint((int)buffer[0]);           writer.WriteCodePoint((int)buffer[1]);           if (padding) {             writer.WriteCodePoint((int)'=');             writer.WriteCodePoint((int)'=');           }         }       }
Magic Number,PeterO.Cbor,Base64,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\Base64.cs,WriteBase64,The following statement contains a magic number: if (lenmod3 != 0) {         i = length - lenmod3;         buffer[0] = (char)alphabet[(data[i] >> 2) & 63];         if (lenmod3 == 2) {           buffer[1] = (char)alphabet[((data[i] & 3) << 4) + ((data[i + 1] >>                 4) & 15)];           buffer[2] = (char)alphabet[(data[i + 1] & 15) << 2];           writer.WriteCodePoint((int)buffer[0]);           writer.WriteCodePoint((int)buffer[1]);           writer.WriteCodePoint((int)buffer[2]);           if (padding) {             writer.WriteCodePoint((int)'=');           }         } else {           buffer[1] = (char)alphabet[(data[i] & 3) << 4];           writer.WriteCodePoint((int)buffer[0]);           writer.WriteCodePoint((int)buffer[1]);           if (padding) {             writer.WriteCodePoint((int)'=');             writer.WriteCodePoint((int)'=');           }         }       }
Magic Number,PeterO.Cbor,Base64,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\Base64.cs,WriteBase64,The following statement contains a magic number: if (lenmod3 != 0) {         i = length - lenmod3;         buffer[0] = (char)alphabet[(data[i] >> 2) & 63];         if (lenmod3 == 2) {           buffer[1] = (char)alphabet[((data[i] & 3) << 4) + ((data[i + 1] >>                 4) & 15)];           buffer[2] = (char)alphabet[(data[i + 1] & 15) << 2];           writer.WriteCodePoint((int)buffer[0]);           writer.WriteCodePoint((int)buffer[1]);           writer.WriteCodePoint((int)buffer[2]);           if (padding) {             writer.WriteCodePoint((int)'=');           }         } else {           buffer[1] = (char)alphabet[(data[i] & 3) << 4];           writer.WriteCodePoint((int)buffer[0]);           writer.WriteCodePoint((int)buffer[1]);           if (padding) {             writer.WriteCodePoint((int)'=');             writer.WriteCodePoint((int)'=');           }         }       }
Magic Number,PeterO.Cbor,Base64,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\Base64.cs,WriteBase64,The following statement contains a magic number: if (lenmod3 != 0) {         i = length - lenmod3;         buffer[0] = (char)alphabet[(data[i] >> 2) & 63];         if (lenmod3 == 2) {           buffer[1] = (char)alphabet[((data[i] & 3) << 4) + ((data[i + 1] >>                 4) & 15)];           buffer[2] = (char)alphabet[(data[i + 1] & 15) << 2];           writer.WriteCodePoint((int)buffer[0]);           writer.WriteCodePoint((int)buffer[1]);           writer.WriteCodePoint((int)buffer[2]);           if (padding) {             writer.WriteCodePoint((int)'=');           }         } else {           buffer[1] = (char)alphabet[(data[i] & 3) << 4];           writer.WriteCodePoint((int)buffer[0]);           writer.WriteCodePoint((int)buffer[1]);           if (padding) {             writer.WriteCodePoint((int)'=');             writer.WriteCodePoint((int)'=');           }         }       }
Magic Number,PeterO.Cbor,Base64,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\Base64.cs,WriteBase64,The following statement contains a magic number: if (lenmod3 != 0) {         i = length - lenmod3;         buffer[0] = (char)alphabet[(data[i] >> 2) & 63];         if (lenmod3 == 2) {           buffer[1] = (char)alphabet[((data[i] & 3) << 4) + ((data[i + 1] >>                 4) & 15)];           buffer[2] = (char)alphabet[(data[i + 1] & 15) << 2];           writer.WriteCodePoint((int)buffer[0]);           writer.WriteCodePoint((int)buffer[1]);           writer.WriteCodePoint((int)buffer[2]);           if (padding) {             writer.WriteCodePoint((int)'=');           }         } else {           buffer[1] = (char)alphabet[(data[i] & 3) << 4];           writer.WriteCodePoint((int)buffer[0]);           writer.WriteCodePoint((int)buffer[1]);           if (padding) {             writer.WriteCodePoint((int)'=');             writer.WriteCodePoint((int)'=');           }         }       }
Magic Number,PeterO.Cbor,Base64,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\Base64.cs,WriteBase64,The following statement contains a magic number: if (lenmod3 != 0) {         i = length - lenmod3;         buffer[0] = (char)alphabet[(data[i] >> 2) & 63];         if (lenmod3 == 2) {           buffer[1] = (char)alphabet[((data[i] & 3) << 4) + ((data[i + 1] >>                 4) & 15)];           buffer[2] = (char)alphabet[(data[i + 1] & 15) << 2];           writer.WriteCodePoint((int)buffer[0]);           writer.WriteCodePoint((int)buffer[1]);           writer.WriteCodePoint((int)buffer[2]);           if (padding) {             writer.WriteCodePoint((int)'=');           }         } else {           buffer[1] = (char)alphabet[(data[i] & 3) << 4];           writer.WriteCodePoint((int)buffer[0]);           writer.WriteCodePoint((int)buffer[1]);           if (padding) {             writer.WriteCodePoint((int)'=');             writer.WriteCodePoint((int)'=');           }         }       }
Magic Number,PeterO.Cbor,Base64,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\Base64.cs,WriteBase64,The following statement contains a magic number: if (lenmod3 != 0) {         i = length - lenmod3;         buffer[0] = (char)alphabet[(data[i] >> 2) & 63];         if (lenmod3 == 2) {           buffer[1] = (char)alphabet[((data[i] & 3) << 4) + ((data[i + 1] >>                 4) & 15)];           buffer[2] = (char)alphabet[(data[i + 1] & 15) << 2];           writer.WriteCodePoint((int)buffer[0]);           writer.WriteCodePoint((int)buffer[1]);           writer.WriteCodePoint((int)buffer[2]);           if (padding) {             writer.WriteCodePoint((int)'=');           }         } else {           buffer[1] = (char)alphabet[(data[i] & 3) << 4];           writer.WriteCodePoint((int)buffer[0]);           writer.WriteCodePoint((int)buffer[1]);           if (padding) {             writer.WriteCodePoint((int)'=');             writer.WriteCodePoint((int)'=');           }         }       }
Magic Number,PeterO.Cbor,Base64,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\Base64.cs,WriteBase64,The following statement contains a magic number: if (lenmod3 != 0) {         i = length - lenmod3;         buffer[0] = (char)alphabet[(data[i] >> 2) & 63];         if (lenmod3 == 2) {           buffer[1] = (char)alphabet[((data[i] & 3) << 4) + ((data[i + 1] >>                 4) & 15)];           buffer[2] = (char)alphabet[(data[i + 1] & 15) << 2];           writer.WriteCodePoint((int)buffer[0]);           writer.WriteCodePoint((int)buffer[1]);           writer.WriteCodePoint((int)buffer[2]);           if (padding) {             writer.WriteCodePoint((int)'=');           }         } else {           buffer[1] = (char)alphabet[(data[i] & 3) << 4];           writer.WriteCodePoint((int)buffer[0]);           writer.WriteCodePoint((int)buffer[1]);           if (padding) {             writer.WriteCodePoint((int)'=');             writer.WriteCodePoint((int)'=');           }         }       }
Magic Number,PeterO.Cbor,Base64,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\Base64.cs,WriteBase64,The following statement contains a magic number: if (lenmod3 != 0) {         i = length - lenmod3;         buffer[0] = (char)alphabet[(data[i] >> 2) & 63];         if (lenmod3 == 2) {           buffer[1] = (char)alphabet[((data[i] & 3) << 4) + ((data[i + 1] >>                 4) & 15)];           buffer[2] = (char)alphabet[(data[i + 1] & 15) << 2];           writer.WriteCodePoint((int)buffer[0]);           writer.WriteCodePoint((int)buffer[1]);           writer.WriteCodePoint((int)buffer[2]);           if (padding) {             writer.WriteCodePoint((int)'=');           }         } else {           buffer[1] = (char)alphabet[(data[i] & 3) << 4];           writer.WriteCodePoint((int)buffer[0]);           writer.WriteCodePoint((int)buffer[1]);           if (padding) {             writer.WriteCodePoint((int)'=');             writer.WriteCodePoint((int)'=');           }         }       }
Magic Number,PeterO.Cbor,Base64,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\Base64.cs,WriteBase64,The following statement contains a magic number: if (lenmod3 != 0) {         i = length - lenmod3;         buffer[0] = (char)alphabet[(data[i] >> 2) & 63];         if (lenmod3 == 2) {           buffer[1] = (char)alphabet[((data[i] & 3) << 4) + ((data[i + 1] >>                 4) & 15)];           buffer[2] = (char)alphabet[(data[i + 1] & 15) << 2];           writer.WriteCodePoint((int)buffer[0]);           writer.WriteCodePoint((int)buffer[1]);           writer.WriteCodePoint((int)buffer[2]);           if (padding) {             writer.WriteCodePoint((int)'=');           }         } else {           buffer[1] = (char)alphabet[(data[i] & 3) << 4];           writer.WriteCodePoint((int)buffer[0]);           writer.WriteCodePoint((int)buffer[1]);           if (padding) {             writer.WriteCodePoint((int)'=');             writer.WriteCodePoint((int)'=');           }         }       }
Magic Number,PeterO.Cbor,Base64,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\Base64.cs,WriteBase64,The following statement contains a magic number: if (lenmod3 != 0) {         i = length - lenmod3;         buffer[0] = (char)alphabet[(data[i] >> 2) & 63];         if (lenmod3 == 2) {           buffer[1] = (char)alphabet[((data[i] & 3) << 4) + ((data[i + 1] >>                 4) & 15)];           buffer[2] = (char)alphabet[(data[i + 1] & 15) << 2];           writer.WriteCodePoint((int)buffer[0]);           writer.WriteCodePoint((int)buffer[1]);           writer.WriteCodePoint((int)buffer[2]);           if (padding) {             writer.WriteCodePoint((int)'=');           }         } else {           buffer[1] = (char)alphabet[(data[i] & 3) << 4];           writer.WriteCodePoint((int)buffer[0]);           writer.WriteCodePoint((int)buffer[1]);           if (padding) {             writer.WriteCodePoint((int)'=');             writer.WriteCodePoint((int)'=');           }         }       }
Magic Number,PeterO.Cbor,Base64,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\Base64.cs,WriteBase64,The following statement contains a magic number: if (lenmod3 != 0) {         i = length - lenmod3;         buffer[0] = (char)alphabet[(data[i] >> 2) & 63];         if (lenmod3 == 2) {           buffer[1] = (char)alphabet[((data[i] & 3) << 4) + ((data[i + 1] >>                 4) & 15)];           buffer[2] = (char)alphabet[(data[i + 1] & 15) << 2];           writer.WriteCodePoint((int)buffer[0]);           writer.WriteCodePoint((int)buffer[1]);           writer.WriteCodePoint((int)buffer[2]);           if (padding) {             writer.WriteCodePoint((int)'=');           }         } else {           buffer[1] = (char)alphabet[(data[i] & 3) << 4];           writer.WriteCodePoint((int)buffer[0]);           writer.WriteCodePoint((int)buffer[1]);           if (padding) {             writer.WriteCodePoint((int)'=');             writer.WriteCodePoint((int)'=');           }         }       }
Magic Number,PeterO.Cbor,Base64,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\Base64.cs,WriteBase64,The following statement contains a magic number: if (lenmod3 != 0) {         i = length - lenmod3;         buffer[0] = (char)alphabet[(data[i] >> 2) & 63];         if (lenmod3 == 2) {           buffer[1] = (char)alphabet[((data[i] & 3) << 4) + ((data[i + 1] >>                 4) & 15)];           buffer[2] = (char)alphabet[(data[i + 1] & 15) << 2];           writer.WriteCodePoint((int)buffer[0]);           writer.WriteCodePoint((int)buffer[1]);           writer.WriteCodePoint((int)buffer[2]);           if (padding) {             writer.WriteCodePoint((int)'=');           }         } else {           buffer[1] = (char)alphabet[(data[i] & 3) << 4];           writer.WriteCodePoint((int)buffer[0]);           writer.WriteCodePoint((int)buffer[1]);           if (padding) {             writer.WriteCodePoint((int)'=');             writer.WriteCodePoint((int)'=');           }         }       }
Magic Number,PeterO.Cbor,CBOREInteger,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORBigInteger.cs,CanFitInInt64,The following statement contains a magic number: return bi.GetSignedBitLength() <= 63;
Magic Number,PeterO.Cbor,CBORDataUtilities,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORDataUtilities.cs,ParseJSONNumber,The following statement contains a magic number: for (; i < str.Length; ++i) {         if (str[i] >= '0' && str[i] <= '9') {           var thisdigit = (int)(str[i] - '0');           if (mantInt > MaxSafeInt) {             if (mant == null) {               mant = new FastInteger2(mantInt);               mantBuffer = thisdigit;               mantBufferMult = 10;             } else {               if (mantBufferMult >= 1000000000) {                 mant.Multiply(mantBufferMult).AddInt(mantBuffer);                 mantBuffer = thisdigit;                 mantBufferMult = 10;               } else {                 mantBufferMult *= 10;                 mantBuffer = (mantBuffer << 3) + (mantBuffer << 1);                 mantBuffer += thisdigit;               }             }           } else {             mantInt *= 10;             mantInt += thisdigit;           }           haveDigits = true;           if (haveDecimalPoint) {             haveDigitsAfterDecimal = true;             if (newScaleInt == Int32.MinValue) { newScale = newScale ?? (new FastInteger2(newScaleInt));               newScale.AddInt(-1);             } else {               --newScaleInt;             }           }         } else if (!integersOnly && str[i] == '.') {           if (!haveDigits) {             // no digits before the decimal point             return null;           }           if (haveDecimalPoint) {             return null;           }           haveDecimalPoint = true;         } else if (!integersOnly && (str[i] == 'E' || str[i] == 'e')) {           haveExponent = true;           ++i;           break;         } else {           return null;         }       }
Magic Number,PeterO.Cbor,CBORDataUtilities,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORDataUtilities.cs,ParseJSONNumber,The following statement contains a magic number: for (; i < str.Length; ++i) {         if (str[i] >= '0' && str[i] <= '9') {           var thisdigit = (int)(str[i] - '0');           if (mantInt > MaxSafeInt) {             if (mant == null) {               mant = new FastInteger2(mantInt);               mantBuffer = thisdigit;               mantBufferMult = 10;             } else {               if (mantBufferMult >= 1000000000) {                 mant.Multiply(mantBufferMult).AddInt(mantBuffer);                 mantBuffer = thisdigit;                 mantBufferMult = 10;               } else {                 mantBufferMult *= 10;                 mantBuffer = (mantBuffer << 3) + (mantBuffer << 1);                 mantBuffer += thisdigit;               }             }           } else {             mantInt *= 10;             mantInt += thisdigit;           }           haveDigits = true;           if (haveDecimalPoint) {             haveDigitsAfterDecimal = true;             if (newScaleInt == Int32.MinValue) { newScale = newScale ?? (new FastInteger2(newScaleInt));               newScale.AddInt(-1);             } else {               --newScaleInt;             }           }         } else if (!integersOnly && str[i] == '.') {           if (!haveDigits) {             // no digits before the decimal point             return null;           }           if (haveDecimalPoint) {             return null;           }           haveDecimalPoint = true;         } else if (!integersOnly && (str[i] == 'E' || str[i] == 'e')) {           haveExponent = true;           ++i;           break;         } else {           return null;         }       }
Magic Number,PeterO.Cbor,CBORDataUtilities,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORDataUtilities.cs,ParseJSONNumber,The following statement contains a magic number: for (; i < str.Length; ++i) {         if (str[i] >= '0' && str[i] <= '9') {           var thisdigit = (int)(str[i] - '0');           if (mantInt > MaxSafeInt) {             if (mant == null) {               mant = new FastInteger2(mantInt);               mantBuffer = thisdigit;               mantBufferMult = 10;             } else {               if (mantBufferMult >= 1000000000) {                 mant.Multiply(mantBufferMult).AddInt(mantBuffer);                 mantBuffer = thisdigit;                 mantBufferMult = 10;               } else {                 mantBufferMult *= 10;                 mantBuffer = (mantBuffer << 3) + (mantBuffer << 1);                 mantBuffer += thisdigit;               }             }           } else {             mantInt *= 10;             mantInt += thisdigit;           }           haveDigits = true;           if (haveDecimalPoint) {             haveDigitsAfterDecimal = true;             if (newScaleInt == Int32.MinValue) { newScale = newScale ?? (new FastInteger2(newScaleInt));               newScale.AddInt(-1);             } else {               --newScaleInt;             }           }         } else if (!integersOnly && str[i] == '.') {           if (!haveDigits) {             // no digits before the decimal point             return null;           }           if (haveDecimalPoint) {             return null;           }           haveDecimalPoint = true;         } else if (!integersOnly && (str[i] == 'E' || str[i] == 'e')) {           haveExponent = true;           ++i;           break;         } else {           return null;         }       }
Magic Number,PeterO.Cbor,CBORDataUtilities,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORDataUtilities.cs,ParseJSONNumber,The following statement contains a magic number: for (; i < str.Length; ++i) {         if (str[i] >= '0' && str[i] <= '9') {           var thisdigit = (int)(str[i] - '0');           if (mantInt > MaxSafeInt) {             if (mant == null) {               mant = new FastInteger2(mantInt);               mantBuffer = thisdigit;               mantBufferMult = 10;             } else {               if (mantBufferMult >= 1000000000) {                 mant.Multiply(mantBufferMult).AddInt(mantBuffer);                 mantBuffer = thisdigit;                 mantBufferMult = 10;               } else {                 mantBufferMult *= 10;                 mantBuffer = (mantBuffer << 3) + (mantBuffer << 1);                 mantBuffer += thisdigit;               }             }           } else {             mantInt *= 10;             mantInt += thisdigit;           }           haveDigits = true;           if (haveDecimalPoint) {             haveDigitsAfterDecimal = true;             if (newScaleInt == Int32.MinValue) { newScale = newScale ?? (new FastInteger2(newScaleInt));               newScale.AddInt(-1);             } else {               --newScaleInt;             }           }         } else if (!integersOnly && str[i] == '.') {           if (!haveDigits) {             // no digits before the decimal point             return null;           }           if (haveDecimalPoint) {             return null;           }           haveDecimalPoint = true;         } else if (!integersOnly && (str[i] == 'E' || str[i] == 'e')) {           haveExponent = true;           ++i;           break;         } else {           return null;         }       }
Magic Number,PeterO.Cbor,CBORDataUtilities,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORDataUtilities.cs,ParseJSONNumber,The following statement contains a magic number: for (; i < str.Length; ++i) {         if (str[i] >= '0' && str[i] <= '9') {           var thisdigit = (int)(str[i] - '0');           if (mantInt > MaxSafeInt) {             if (mant == null) {               mant = new FastInteger2(mantInt);               mantBuffer = thisdigit;               mantBufferMult = 10;             } else {               if (mantBufferMult >= 1000000000) {                 mant.Multiply(mantBufferMult).AddInt(mantBuffer);                 mantBuffer = thisdigit;                 mantBufferMult = 10;               } else {                 mantBufferMult *= 10;                 mantBuffer = (mantBuffer << 3) + (mantBuffer << 1);                 mantBuffer += thisdigit;               }             }           } else {             mantInt *= 10;             mantInt += thisdigit;           }           haveDigits = true;           if (haveDecimalPoint) {             haveDigitsAfterDecimal = true;             if (newScaleInt == Int32.MinValue) { newScale = newScale ?? (new FastInteger2(newScaleInt));               newScale.AddInt(-1);             } else {               --newScaleInt;             }           }         } else if (!integersOnly && str[i] == '.') {           if (!haveDigits) {             // no digits before the decimal point             return null;           }           if (haveDecimalPoint) {             return null;           }           haveDecimalPoint = true;         } else if (!integersOnly && (str[i] == 'E' || str[i] == 'e')) {           haveExponent = true;           ++i;           break;         } else {           return null;         }       }
Magic Number,PeterO.Cbor,CBORDataUtilities,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORDataUtilities.cs,ParseJSONNumber,The following statement contains a magic number: for (; i < str.Length; ++i) {         if (str[i] >= '0' && str[i] <= '9') {           var thisdigit = (int)(str[i] - '0');           if (mantInt > MaxSafeInt) {             if (mant == null) {               mant = new FastInteger2(mantInt);               mantBuffer = thisdigit;               mantBufferMult = 10;             } else {               if (mantBufferMult >= 1000000000) {                 mant.Multiply(mantBufferMult).AddInt(mantBuffer);                 mantBuffer = thisdigit;                 mantBufferMult = 10;               } else {                 mantBufferMult *= 10;                 mantBuffer = (mantBuffer << 3) + (mantBuffer << 1);                 mantBuffer += thisdigit;               }             }           } else {             mantInt *= 10;             mantInt += thisdigit;           }           haveDigits = true;           if (haveDecimalPoint) {             haveDigitsAfterDecimal = true;             if (newScaleInt == Int32.MinValue) { newScale = newScale ?? (new FastInteger2(newScaleInt));               newScale.AddInt(-1);             } else {               --newScaleInt;             }           }         } else if (!integersOnly && str[i] == '.') {           if (!haveDigits) {             // no digits before the decimal point             return null;           }           if (haveDecimalPoint) {             return null;           }           haveDecimalPoint = true;         } else if (!integersOnly && (str[i] == 'E' || str[i] == 'e')) {           haveExponent = true;           ++i;           break;         } else {           return null;         }       }
Magic Number,PeterO.Cbor,CBORDataUtilities,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORDataUtilities.cs,ParseJSONNumber,The following statement contains a magic number: if (haveExponent) {         FastInteger2 exp = null;         var expInt = 0;         offset = 1;         haveDigits = false;         if (i == str.Length) {           return null;         }         if (str[i] == '+' || str[i] == '-') {           if (str[i] == '-') {             offset = -1;           }           ++i;         }         for (; i < str.Length; ++i) {           if (str[i] >= '0' && str[i] <= '9') {             haveDigits = true;             var thisdigit = (int)(str[i] - '0');             if (expInt > MaxSafeInt) {               if (exp == null) {                 exp = new FastInteger2(expInt);                 expBuffer = thisdigit;                 expBufferMult = 10;               } else {                 if (expBufferMult >= 1000000000) {                   exp.Multiply(expBufferMult).AddInt(expBuffer);                   expBuffer = thisdigit;                   expBufferMult = 10;                 } else {                   // multiply expBufferMult and expBuffer each by 10                   expBufferMult = (expBufferMult << 3) + (expBufferMult << 1);                   expBuffer = (expBuffer << 3) + (expBuffer << 1);                   expBuffer += thisdigit;                 }               }             } else {               expInt *= 10;               expInt += thisdigit;             }           } else {             return null;           }         }         if (!haveDigits) {           return null;         }         if (exp != null && (expBufferMult != 1 || expBuffer != 0)) {           exp.Multiply(expBufferMult).AddInt(expBuffer);         }       if (offset >= 0 && newScaleInt == 0 && newScale == null && exp == null) {           newScaleInt = expInt;         } else if (exp == null) { newScale = newScale ?? (new FastInteger2(newScaleInt));           if (offset < 0) {             newScale.SubtractInt(expInt);           } else if (expInt != 0) {             newScale.AddInt(expInt);           }         } else { newScale = newScale ?? (new FastInteger2(newScaleInt));           if (offset < 0) {             newScale.Subtract(exp);           } else {             newScale.Add(exp);           }         }       }
Magic Number,PeterO.Cbor,CBORDataUtilities,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORDataUtilities.cs,ParseJSONNumber,The following statement contains a magic number: if (haveExponent) {         FastInteger2 exp = null;         var expInt = 0;         offset = 1;         haveDigits = false;         if (i == str.Length) {           return null;         }         if (str[i] == '+' || str[i] == '-') {           if (str[i] == '-') {             offset = -1;           }           ++i;         }         for (; i < str.Length; ++i) {           if (str[i] >= '0' && str[i] <= '9') {             haveDigits = true;             var thisdigit = (int)(str[i] - '0');             if (expInt > MaxSafeInt) {               if (exp == null) {                 exp = new FastInteger2(expInt);                 expBuffer = thisdigit;                 expBufferMult = 10;               } else {                 if (expBufferMult >= 1000000000) {                   exp.Multiply(expBufferMult).AddInt(expBuffer);                   expBuffer = thisdigit;                   expBufferMult = 10;                 } else {                   // multiply expBufferMult and expBuffer each by 10                   expBufferMult = (expBufferMult << 3) + (expBufferMult << 1);                   expBuffer = (expBuffer << 3) + (expBuffer << 1);                   expBuffer += thisdigit;                 }               }             } else {               expInt *= 10;               expInt += thisdigit;             }           } else {             return null;           }         }         if (!haveDigits) {           return null;         }         if (exp != null && (expBufferMult != 1 || expBuffer != 0)) {           exp.Multiply(expBufferMult).AddInt(expBuffer);         }       if (offset >= 0 && newScaleInt == 0 && newScale == null && exp == null) {           newScaleInt = expInt;         } else if (exp == null) { newScale = newScale ?? (new FastInteger2(newScaleInt));           if (offset < 0) {             newScale.SubtractInt(expInt);           } else if (expInt != 0) {             newScale.AddInt(expInt);           }         } else { newScale = newScale ?? (new FastInteger2(newScaleInt));           if (offset < 0) {             newScale.Subtract(exp);           } else {             newScale.Add(exp);           }         }       }
Magic Number,PeterO.Cbor,CBORDataUtilities,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORDataUtilities.cs,ParseJSONNumber,The following statement contains a magic number: if (haveExponent) {         FastInteger2 exp = null;         var expInt = 0;         offset = 1;         haveDigits = false;         if (i == str.Length) {           return null;         }         if (str[i] == '+' || str[i] == '-') {           if (str[i] == '-') {             offset = -1;           }           ++i;         }         for (; i < str.Length; ++i) {           if (str[i] >= '0' && str[i] <= '9') {             haveDigits = true;             var thisdigit = (int)(str[i] - '0');             if (expInt > MaxSafeInt) {               if (exp == null) {                 exp = new FastInteger2(expInt);                 expBuffer = thisdigit;                 expBufferMult = 10;               } else {                 if (expBufferMult >= 1000000000) {                   exp.Multiply(expBufferMult).AddInt(expBuffer);                   expBuffer = thisdigit;                   expBufferMult = 10;                 } else {                   // multiply expBufferMult and expBuffer each by 10                   expBufferMult = (expBufferMult << 3) + (expBufferMult << 1);                   expBuffer = (expBuffer << 3) + (expBuffer << 1);                   expBuffer += thisdigit;                 }               }             } else {               expInt *= 10;               expInt += thisdigit;             }           } else {             return null;           }         }         if (!haveDigits) {           return null;         }         if (exp != null && (expBufferMult != 1 || expBuffer != 0)) {           exp.Multiply(expBufferMult).AddInt(expBuffer);         }       if (offset >= 0 && newScaleInt == 0 && newScale == null && exp == null) {           newScaleInt = expInt;         } else if (exp == null) { newScale = newScale ?? (new FastInteger2(newScaleInt));           if (offset < 0) {             newScale.SubtractInt(expInt);           } else if (expInt != 0) {             newScale.AddInt(expInt);           }         } else { newScale = newScale ?? (new FastInteger2(newScaleInt));           if (offset < 0) {             newScale.Subtract(exp);           } else {             newScale.Add(exp);           }         }       }
Magic Number,PeterO.Cbor,CBORDataUtilities,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORDataUtilities.cs,ParseJSONNumber,The following statement contains a magic number: if (haveExponent) {         FastInteger2 exp = null;         var expInt = 0;         offset = 1;         haveDigits = false;         if (i == str.Length) {           return null;         }         if (str[i] == '+' || str[i] == '-') {           if (str[i] == '-') {             offset = -1;           }           ++i;         }         for (; i < str.Length; ++i) {           if (str[i] >= '0' && str[i] <= '9') {             haveDigits = true;             var thisdigit = (int)(str[i] - '0');             if (expInt > MaxSafeInt) {               if (exp == null) {                 exp = new FastInteger2(expInt);                 expBuffer = thisdigit;                 expBufferMult = 10;               } else {                 if (expBufferMult >= 1000000000) {                   exp.Multiply(expBufferMult).AddInt(expBuffer);                   expBuffer = thisdigit;                   expBufferMult = 10;                 } else {                   // multiply expBufferMult and expBuffer each by 10                   expBufferMult = (expBufferMult << 3) + (expBufferMult << 1);                   expBuffer = (expBuffer << 3) + (expBuffer << 1);                   expBuffer += thisdigit;                 }               }             } else {               expInt *= 10;               expInt += thisdigit;             }           } else {             return null;           }         }         if (!haveDigits) {           return null;         }         if (exp != null && (expBufferMult != 1 || expBuffer != 0)) {           exp.Multiply(expBufferMult).AddInt(expBuffer);         }       if (offset >= 0 && newScaleInt == 0 && newScale == null && exp == null) {           newScaleInt = expInt;         } else if (exp == null) { newScale = newScale ?? (new FastInteger2(newScaleInt));           if (offset < 0) {             newScale.SubtractInt(expInt);           } else if (expInt != 0) {             newScale.AddInt(expInt);           }         } else { newScale = newScale ?? (new FastInteger2(newScaleInt));           if (offset < 0) {             newScale.Subtract(exp);           } else {             newScale.Add(exp);           }         }       }
Magic Number,PeterO.Cbor,CBORDataUtilities,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORDataUtilities.cs,ParseJSONNumber,The following statement contains a magic number: if (haveExponent) {         FastInteger2 exp = null;         var expInt = 0;         offset = 1;         haveDigits = false;         if (i == str.Length) {           return null;         }         if (str[i] == '+' || str[i] == '-') {           if (str[i] == '-') {             offset = -1;           }           ++i;         }         for (; i < str.Length; ++i) {           if (str[i] >= '0' && str[i] <= '9') {             haveDigits = true;             var thisdigit = (int)(str[i] - '0');             if (expInt > MaxSafeInt) {               if (exp == null) {                 exp = new FastInteger2(expInt);                 expBuffer = thisdigit;                 expBufferMult = 10;               } else {                 if (expBufferMult >= 1000000000) {                   exp.Multiply(expBufferMult).AddInt(expBuffer);                   expBuffer = thisdigit;                   expBufferMult = 10;                 } else {                   // multiply expBufferMult and expBuffer each by 10                   expBufferMult = (expBufferMult << 3) + (expBufferMult << 1);                   expBuffer = (expBuffer << 3) + (expBuffer << 1);                   expBuffer += thisdigit;                 }               }             } else {               expInt *= 10;               expInt += thisdigit;             }           } else {             return null;           }         }         if (!haveDigits) {           return null;         }         if (exp != null && (expBufferMult != 1 || expBuffer != 0)) {           exp.Multiply(expBufferMult).AddInt(expBuffer);         }       if (offset >= 0 && newScaleInt == 0 && newScale == null && exp == null) {           newScaleInt = expInt;         } else if (exp == null) { newScale = newScale ?? (new FastInteger2(newScaleInt));           if (offset < 0) {             newScale.SubtractInt(expInt);           } else if (expInt != 0) {             newScale.AddInt(expInt);           }         } else { newScale = newScale ?? (new FastInteger2(newScaleInt));           if (offset < 0) {             newScale.Subtract(exp);           } else {             newScale.Add(exp);           }         }       }
Magic Number,PeterO.Cbor,CBORDataUtilities,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORDataUtilities.cs,ParseJSONNumber,The following statement contains a magic number: if (haveExponent) {         FastInteger2 exp = null;         var expInt = 0;         offset = 1;         haveDigits = false;         if (i == str.Length) {           return null;         }         if (str[i] == '+' || str[i] == '-') {           if (str[i] == '-') {             offset = -1;           }           ++i;         }         for (; i < str.Length; ++i) {           if (str[i] >= '0' && str[i] <= '9') {             haveDigits = true;             var thisdigit = (int)(str[i] - '0');             if (expInt > MaxSafeInt) {               if (exp == null) {                 exp = new FastInteger2(expInt);                 expBuffer = thisdigit;                 expBufferMult = 10;               } else {                 if (expBufferMult >= 1000000000) {                   exp.Multiply(expBufferMult).AddInt(expBuffer);                   expBuffer = thisdigit;                   expBufferMult = 10;                 } else {                   // multiply expBufferMult and expBuffer each by 10                   expBufferMult = (expBufferMult << 3) + (expBufferMult << 1);                   expBuffer = (expBuffer << 3) + (expBuffer << 1);                   expBuffer += thisdigit;                 }               }             } else {               expInt *= 10;               expInt += thisdigit;             }           } else {             return null;           }         }         if (!haveDigits) {           return null;         }         if (exp != null && (expBufferMult != 1 || expBuffer != 0)) {           exp.Multiply(expBufferMult).AddInt(expBuffer);         }       if (offset >= 0 && newScaleInt == 0 && newScale == null && exp == null) {           newScaleInt = expInt;         } else if (exp == null) { newScale = newScale ?? (new FastInteger2(newScaleInt));           if (offset < 0) {             newScale.SubtractInt(expInt);           } else if (expInt != 0) {             newScale.AddInt(expInt);           }         } else { newScale = newScale ?? (new FastInteger2(newScaleInt));           if (offset < 0) {             newScale.Subtract(exp);           } else {             newScale.Add(exp);           }         }       }
Magic Number,PeterO.Cbor,CBORDouble,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORDouble.cs,AsInt64,The following statement contains a magic number: if (fltItem >= -9223372036854775808.0 && fltItem <       9223372036854775808.0) {         return (long)fltItem;       }
Magic Number,PeterO.Cbor,CBORDouble,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORDouble.cs,AsInt64,The following statement contains a magic number: if (fltItem >= -9223372036854775808.0 && fltItem <       9223372036854775808.0) {         return (long)fltItem;       }
Magic Number,PeterO.Cbor,CBORDouble,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORDouble.cs,CanTruncatedIntFitInInt64,The following statement contains a magic number: return fltItem2 >= -9223372036854775808.0 && fltItem2 <       9223372036854775808.0;
Magic Number,PeterO.Cbor,CBORDouble,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORDouble.cs,CanTruncatedIntFitInInt64,The following statement contains a magic number: return fltItem2 >= -9223372036854775808.0 && fltItem2 <       9223372036854775808.0;
Magic Number,PeterO.Cbor,CBORDouble,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORDouble.cs,Sign,The following statement contains a magic number: return Double.IsNaN(flt) ? 2 : ((double)flt == 0.0 ? 0 : (flt < 0.0f ?       -1 : 1));
Magic Number,PeterO.Cbor,CBORDouble,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORDouble.cs,IsNegative,The following statement contains a magic number: return (lvalue >> 63) != 0;
Magic Number,PeterO.Cbor,CBORExtendedDecimal,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORExtendedDecimal.cs,CanTruncatedIntFitInInt64,The following statement contains a magic number: if (ef.Exponent.CompareTo((EInteger)21) >= 0) {         return false;       }
Magic Number,PeterO.Cbor,CBORExtendedDecimal,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORExtendedDecimal.cs,CanTruncatedIntFitInInt64,The following statement contains a magic number: return bi.GetSignedBitLength() <= 63;
Magic Number,PeterO.Cbor,CBORExtendedDecimal,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORExtendedDecimal.cs,CanTruncatedIntFitInInt32,The following statement contains a magic number: if (ef.Exponent.CompareTo((EInteger)11) >= 0) {         return false;       }
Magic Number,PeterO.Cbor,CBORExtendedDecimal,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORExtendedDecimal.cs,Sign,The following statement contains a magic number: return ed.IsNaN() ? 2 : ed.Sign;
Magic Number,PeterO.Cbor,CBORExtendedFloat,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORExtendedFloat.cs,CanTruncatedIntFitInInt64,The following statement contains a magic number: if (ef.Exponent.CompareTo((EInteger)65) >= 0) {         return false;       }
Magic Number,PeterO.Cbor,CBORExtendedFloat,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORExtendedFloat.cs,CanTruncatedIntFitInInt64,The following statement contains a magic number: return bi.GetSignedBitLength() <= 63;
Magic Number,PeterO.Cbor,CBORExtendedFloat,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORExtendedFloat.cs,CanTruncatedIntFitInInt32,The following statement contains a magic number: if (ef.Exponent.CompareTo((EInteger)33) >= 0) {         return false;       }
Magic Number,PeterO.Cbor,CBORExtendedFloat,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORExtendedFloat.cs,Sign,The following statement contains a magic number: return ef.IsNaN() ? 2 : ef.Sign;
Magic Number,PeterO.Cbor,CBORExtendedRational,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORExtendedRational.cs,AsInt64,The following statement contains a magic number: if (ef.IsFinite) {         EInteger bi = ef.ToEInteger();         if (bi.GetSignedBitLength() <= 63) {           return (long)bi;         }       }
Magic Number,PeterO.Cbor,CBORExtendedRational,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORExtendedRational.cs,CanTruncatedIntFitInInt64,The following statement contains a magic number: return bi.GetSignedBitLength() <= 63;
Magic Number,PeterO.Cbor,CBORInteger,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORInteger.cs,Abs,The following statement contains a magic number: return (val == Int32.MinValue) ? (EInteger.One << 63) : ((val < 0) ?       -val : obj);
Magic Number,PeterO.Cbor,CBORInteger,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORInteger.cs,CanFitInDouble,The following statement contains a magic number: while (intItem >= (1L << 53) && (intItem & 1) == 0) {         intItem >>= 1;       }
Magic Number,PeterO.Cbor,CBORInteger,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORInteger.cs,CanFitInDouble,The following statement contains a magic number: return intItem < (1L << 53);
Magic Number,PeterO.Cbor,CBORInteger,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORInteger.cs,CanFitInSingle,The following statement contains a magic number: while (intItem >= (1L << 24) && (intItem & 1) == 0) {         intItem >>= 1;       }
Magic Number,PeterO.Cbor,CBORInteger,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORInteger.cs,CanFitInSingle,The following statement contains a magic number: return intItem < (1L << 24);
Magic Number,PeterO.Cbor,CBORInteger,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORInteger.cs,Negate,The following statement contains a magic number: return (((long)obj) == Int64.MinValue) ? (EInteger.One << 63) :       (-((long)obj));
Magic Number,PeterO.Cbor,CBORJson,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORJson.cs,NextJSONString,The following statement contains a magic number: while (true) {         c = this.reader.ReadChar();         if (c == -1 || c < 0x20) {           this.reader.RaiseError("Unterminated string");         }         switch (c) {           case '\\':             c = this.reader.ReadChar();             switch (c) {               case '\\':                 this.sb.Append('\\');                 break;               case '/':                 // Now allowed to be escaped under RFC 7159                 this.sb.Append('/');                 break;               case '\"':                 this.sb.Append('\"');                 break;               case 'b':                 this.sb.Append('\b');                 break;               case 'f':                 this.sb.Append('\f');                 break;               case 'n':                 this.sb.Append('\n');                 break;               case 'r':                 this.sb.Append('\r');                 break;               case 't':                 this.sb.Append('\t');                 break;                 case 'u': {  // Unicode escape                   c = 0;                   // Consists of 4 hex digits                   for (var i = 0; i < 4; ++i) {                     int ch = this.reader.ReadChar();                     if (ch >= '0' && ch <= '9') {                     c <<= 4;                     c |= ch - '0';                     } else if (ch >= 'A' && ch <= 'F') {                     c <<= 4;                     c |= ch + 10 - 'A';                     } else if (ch >= 'a' && ch <= 'f') {                     c <<= 4;                     c |= ch + 10 - 'a';                     } else {                 this.reader.RaiseError("Invalid Unicode escaped character");                     }                   }                   if ((c & 0xf800) != 0xd800) {                     // Non-surrogate                     this.sb.Append((char)c);                   } else if ((c & 0xfc00) == 0xd800) {                     int ch = this.reader.ReadChar();                     if (ch != '\\' || this.reader.ReadChar() != 'u') {                     this.reader.RaiseError("Invalid escaped character");                     }                     var c2 = 0;                     for (var i = 0; i < 4; ++i) {                     ch = this.reader.ReadChar();                     if (ch >= '0' && ch <= '9') {                     c2 <<= 4;                     c2 |= ch - '0';                     } else if (ch >= 'A' && ch <= 'F') {                     c2 <<= 4;                     c2 |= ch + 10 - 'A';                     } else if (ch >= 'a' && ch <= 'f') {                     c2 <<= 4;                     c2 |= ch + 10 - 'a';                     } else {                     this.reader.RaiseError("Invalid Unicode escaped character");                     }                     }                     if ((c2 & 0xfc00) != 0xdc00) {                     this.reader.RaiseError("Unpaired surrogate code point");                     } else {                     this.sb.Append((char)c);                     this.sb.Append((char)c2);                     }                   } else {                     this.reader.RaiseError("Unpaired surrogate code point");                   }                   break;                 }               default:                 {                   this.reader.RaiseError("Invalid escaped character");                   break;                 }             }             break;           case 0x22:  // double quote             return this.sb.ToString();           default: {               // NOTE: Assumes the character reader               // throws an error on finding illegal surrogate               // pairs in the string or invalid encoding               // in the stream               if ((c >> 16) == 0) {                 this.sb.Append((char)c);               } else {               this.sb.Append((char)((((c - 0x10000) >> 10) & 0x3ff) +                   0xd800));                 this.sb.Append((char)(((c - 0x10000) & 0x3ff) + 0xdc00));               }               break;             }         }       }
Magic Number,PeterO.Cbor,CBORJson,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORJson.cs,NextJSONString,The following statement contains a magic number: while (true) {         c = this.reader.ReadChar();         if (c == -1 || c < 0x20) {           this.reader.RaiseError("Unterminated string");         }         switch (c) {           case '\\':             c = this.reader.ReadChar();             switch (c) {               case '\\':                 this.sb.Append('\\');                 break;               case '/':                 // Now allowed to be escaped under RFC 7159                 this.sb.Append('/');                 break;               case '\"':                 this.sb.Append('\"');                 break;               case 'b':                 this.sb.Append('\b');                 break;               case 'f':                 this.sb.Append('\f');                 break;               case 'n':                 this.sb.Append('\n');                 break;               case 'r':                 this.sb.Append('\r');                 break;               case 't':                 this.sb.Append('\t');                 break;                 case 'u': {  // Unicode escape                   c = 0;                   // Consists of 4 hex digits                   for (var i = 0; i < 4; ++i) {                     int ch = this.reader.ReadChar();                     if (ch >= '0' && ch <= '9') {                     c <<= 4;                     c |= ch - '0';                     } else if (ch >= 'A' && ch <= 'F') {                     c <<= 4;                     c |= ch + 10 - 'A';                     } else if (ch >= 'a' && ch <= 'f') {                     c <<= 4;                     c |= ch + 10 - 'a';                     } else {                 this.reader.RaiseError("Invalid Unicode escaped character");                     }                   }                   if ((c & 0xf800) != 0xd800) {                     // Non-surrogate                     this.sb.Append((char)c);                   } else if ((c & 0xfc00) == 0xd800) {                     int ch = this.reader.ReadChar();                     if (ch != '\\' || this.reader.ReadChar() != 'u') {                     this.reader.RaiseError("Invalid escaped character");                     }                     var c2 = 0;                     for (var i = 0; i < 4; ++i) {                     ch = this.reader.ReadChar();                     if (ch >= '0' && ch <= '9') {                     c2 <<= 4;                     c2 |= ch - '0';                     } else if (ch >= 'A' && ch <= 'F') {                     c2 <<= 4;                     c2 |= ch + 10 - 'A';                     } else if (ch >= 'a' && ch <= 'f') {                     c2 <<= 4;                     c2 |= ch + 10 - 'a';                     } else {                     this.reader.RaiseError("Invalid Unicode escaped character");                     }                     }                     if ((c2 & 0xfc00) != 0xdc00) {                     this.reader.RaiseError("Unpaired surrogate code point");                     } else {                     this.sb.Append((char)c);                     this.sb.Append((char)c2);                     }                   } else {                     this.reader.RaiseError("Unpaired surrogate code point");                   }                   break;                 }               default:                 {                   this.reader.RaiseError("Invalid escaped character");                   break;                 }             }             break;           case 0x22:  // double quote             return this.sb.ToString();           default: {               // NOTE: Assumes the character reader               // throws an error on finding illegal surrogate               // pairs in the string or invalid encoding               // in the stream               if ((c >> 16) == 0) {                 this.sb.Append((char)c);               } else {               this.sb.Append((char)((((c - 0x10000) >> 10) & 0x3ff) +                   0xd800));                 this.sb.Append((char)(((c - 0x10000) & 0x3ff) + 0xdc00));               }               break;             }         }       }
Magic Number,PeterO.Cbor,CBORJson,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORJson.cs,NextJSONString,The following statement contains a magic number: while (true) {         c = this.reader.ReadChar();         if (c == -1 || c < 0x20) {           this.reader.RaiseError("Unterminated string");         }         switch (c) {           case '\\':             c = this.reader.ReadChar();             switch (c) {               case '\\':                 this.sb.Append('\\');                 break;               case '/':                 // Now allowed to be escaped under RFC 7159                 this.sb.Append('/');                 break;               case '\"':                 this.sb.Append('\"');                 break;               case 'b':                 this.sb.Append('\b');                 break;               case 'f':                 this.sb.Append('\f');                 break;               case 'n':                 this.sb.Append('\n');                 break;               case 'r':                 this.sb.Append('\r');                 break;               case 't':                 this.sb.Append('\t');                 break;                 case 'u': {  // Unicode escape                   c = 0;                   // Consists of 4 hex digits                   for (var i = 0; i < 4; ++i) {                     int ch = this.reader.ReadChar();                     if (ch >= '0' && ch <= '9') {                     c <<= 4;                     c |= ch - '0';                     } else if (ch >= 'A' && ch <= 'F') {                     c <<= 4;                     c |= ch + 10 - 'A';                     } else if (ch >= 'a' && ch <= 'f') {                     c <<= 4;                     c |= ch + 10 - 'a';                     } else {                 this.reader.RaiseError("Invalid Unicode escaped character");                     }                   }                   if ((c & 0xf800) != 0xd800) {                     // Non-surrogate                     this.sb.Append((char)c);                   } else if ((c & 0xfc00) == 0xd800) {                     int ch = this.reader.ReadChar();                     if (ch != '\\' || this.reader.ReadChar() != 'u') {                     this.reader.RaiseError("Invalid escaped character");                     }                     var c2 = 0;                     for (var i = 0; i < 4; ++i) {                     ch = this.reader.ReadChar();                     if (ch >= '0' && ch <= '9') {                     c2 <<= 4;                     c2 |= ch - '0';                     } else if (ch >= 'A' && ch <= 'F') {                     c2 <<= 4;                     c2 |= ch + 10 - 'A';                     } else if (ch >= 'a' && ch <= 'f') {                     c2 <<= 4;                     c2 |= ch + 10 - 'a';                     } else {                     this.reader.RaiseError("Invalid Unicode escaped character");                     }                     }                     if ((c2 & 0xfc00) != 0xdc00) {                     this.reader.RaiseError("Unpaired surrogate code point");                     } else {                     this.sb.Append((char)c);                     this.sb.Append((char)c2);                     }                   } else {                     this.reader.RaiseError("Unpaired surrogate code point");                   }                   break;                 }               default:                 {                   this.reader.RaiseError("Invalid escaped character");                   break;                 }             }             break;           case 0x22:  // double quote             return this.sb.ToString();           default: {               // NOTE: Assumes the character reader               // throws an error on finding illegal surrogate               // pairs in the string or invalid encoding               // in the stream               if ((c >> 16) == 0) {                 this.sb.Append((char)c);               } else {               this.sb.Append((char)((((c - 0x10000) >> 10) & 0x3ff) +                   0xd800));                 this.sb.Append((char)(((c - 0x10000) & 0x3ff) + 0xdc00));               }               break;             }         }       }
Magic Number,PeterO.Cbor,CBORJson,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORJson.cs,NextJSONString,The following statement contains a magic number: while (true) {         c = this.reader.ReadChar();         if (c == -1 || c < 0x20) {           this.reader.RaiseError("Unterminated string");         }         switch (c) {           case '\\':             c = this.reader.ReadChar();             switch (c) {               case '\\':                 this.sb.Append('\\');                 break;               case '/':                 // Now allowed to be escaped under RFC 7159                 this.sb.Append('/');                 break;               case '\"':                 this.sb.Append('\"');                 break;               case 'b':                 this.sb.Append('\b');                 break;               case 'f':                 this.sb.Append('\f');                 break;               case 'n':                 this.sb.Append('\n');                 break;               case 'r':                 this.sb.Append('\r');                 break;               case 't':                 this.sb.Append('\t');                 break;                 case 'u': {  // Unicode escape                   c = 0;                   // Consists of 4 hex digits                   for (var i = 0; i < 4; ++i) {                     int ch = this.reader.ReadChar();                     if (ch >= '0' && ch <= '9') {                     c <<= 4;                     c |= ch - '0';                     } else if (ch >= 'A' && ch <= 'F') {                     c <<= 4;                     c |= ch + 10 - 'A';                     } else if (ch >= 'a' && ch <= 'f') {                     c <<= 4;                     c |= ch + 10 - 'a';                     } else {                 this.reader.RaiseError("Invalid Unicode escaped character");                     }                   }                   if ((c & 0xf800) != 0xd800) {                     // Non-surrogate                     this.sb.Append((char)c);                   } else if ((c & 0xfc00) == 0xd800) {                     int ch = this.reader.ReadChar();                     if (ch != '\\' || this.reader.ReadChar() != 'u') {                     this.reader.RaiseError("Invalid escaped character");                     }                     var c2 = 0;                     for (var i = 0; i < 4; ++i) {                     ch = this.reader.ReadChar();                     if (ch >= '0' && ch <= '9') {                     c2 <<= 4;                     c2 |= ch - '0';                     } else if (ch >= 'A' && ch <= 'F') {                     c2 <<= 4;                     c2 |= ch + 10 - 'A';                     } else if (ch >= 'a' && ch <= 'f') {                     c2 <<= 4;                     c2 |= ch + 10 - 'a';                     } else {                     this.reader.RaiseError("Invalid Unicode escaped character");                     }                     }                     if ((c2 & 0xfc00) != 0xdc00) {                     this.reader.RaiseError("Unpaired surrogate code point");                     } else {                     this.sb.Append((char)c);                     this.sb.Append((char)c2);                     }                   } else {                     this.reader.RaiseError("Unpaired surrogate code point");                   }                   break;                 }               default:                 {                   this.reader.RaiseError("Invalid escaped character");                   break;                 }             }             break;           case 0x22:  // double quote             return this.sb.ToString();           default: {               // NOTE: Assumes the character reader               // throws an error on finding illegal surrogate               // pairs in the string or invalid encoding               // in the stream               if ((c >> 16) == 0) {                 this.sb.Append((char)c);               } else {               this.sb.Append((char)((((c - 0x10000) >> 10) & 0x3ff) +                   0xd800));                 this.sb.Append((char)(((c - 0x10000) & 0x3ff) + 0xdc00));               }               break;             }         }       }
Magic Number,PeterO.Cbor,CBORJson,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORJson.cs,NextJSONString,The following statement contains a magic number: while (true) {         c = this.reader.ReadChar();         if (c == -1 || c < 0x20) {           this.reader.RaiseError("Unterminated string");         }         switch (c) {           case '\\':             c = this.reader.ReadChar();             switch (c) {               case '\\':                 this.sb.Append('\\');                 break;               case '/':                 // Now allowed to be escaped under RFC 7159                 this.sb.Append('/');                 break;               case '\"':                 this.sb.Append('\"');                 break;               case 'b':                 this.sb.Append('\b');                 break;               case 'f':                 this.sb.Append('\f');                 break;               case 'n':                 this.sb.Append('\n');                 break;               case 'r':                 this.sb.Append('\r');                 break;               case 't':                 this.sb.Append('\t');                 break;                 case 'u': {  // Unicode escape                   c = 0;                   // Consists of 4 hex digits                   for (var i = 0; i < 4; ++i) {                     int ch = this.reader.ReadChar();                     if (ch >= '0' && ch <= '9') {                     c <<= 4;                     c |= ch - '0';                     } else if (ch >= 'A' && ch <= 'F') {                     c <<= 4;                     c |= ch + 10 - 'A';                     } else if (ch >= 'a' && ch <= 'f') {                     c <<= 4;                     c |= ch + 10 - 'a';                     } else {                 this.reader.RaiseError("Invalid Unicode escaped character");                     }                   }                   if ((c & 0xf800) != 0xd800) {                     // Non-surrogate                     this.sb.Append((char)c);                   } else if ((c & 0xfc00) == 0xd800) {                     int ch = this.reader.ReadChar();                     if (ch != '\\' || this.reader.ReadChar() != 'u') {                     this.reader.RaiseError("Invalid escaped character");                     }                     var c2 = 0;                     for (var i = 0; i < 4; ++i) {                     ch = this.reader.ReadChar();                     if (ch >= '0' && ch <= '9') {                     c2 <<= 4;                     c2 |= ch - '0';                     } else if (ch >= 'A' && ch <= 'F') {                     c2 <<= 4;                     c2 |= ch + 10 - 'A';                     } else if (ch >= 'a' && ch <= 'f') {                     c2 <<= 4;                     c2 |= ch + 10 - 'a';                     } else {                     this.reader.RaiseError("Invalid Unicode escaped character");                     }                     }                     if ((c2 & 0xfc00) != 0xdc00) {                     this.reader.RaiseError("Unpaired surrogate code point");                     } else {                     this.sb.Append((char)c);                     this.sb.Append((char)c2);                     }                   } else {                     this.reader.RaiseError("Unpaired surrogate code point");                   }                   break;                 }               default:                 {                   this.reader.RaiseError("Invalid escaped character");                   break;                 }             }             break;           case 0x22:  // double quote             return this.sb.ToString();           default: {               // NOTE: Assumes the character reader               // throws an error on finding illegal surrogate               // pairs in the string or invalid encoding               // in the stream               if ((c >> 16) == 0) {                 this.sb.Append((char)c);               } else {               this.sb.Append((char)((((c - 0x10000) >> 10) & 0x3ff) +                   0xd800));                 this.sb.Append((char)(((c - 0x10000) & 0x3ff) + 0xdc00));               }               break;             }         }       }
Magic Number,PeterO.Cbor,CBORJson,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORJson.cs,NextJSONString,The following statement contains a magic number: while (true) {         c = this.reader.ReadChar();         if (c == -1 || c < 0x20) {           this.reader.RaiseError("Unterminated string");         }         switch (c) {           case '\\':             c = this.reader.ReadChar();             switch (c) {               case '\\':                 this.sb.Append('\\');                 break;               case '/':                 // Now allowed to be escaped under RFC 7159                 this.sb.Append('/');                 break;               case '\"':                 this.sb.Append('\"');                 break;               case 'b':                 this.sb.Append('\b');                 break;               case 'f':                 this.sb.Append('\f');                 break;               case 'n':                 this.sb.Append('\n');                 break;               case 'r':                 this.sb.Append('\r');                 break;               case 't':                 this.sb.Append('\t');                 break;                 case 'u': {  // Unicode escape                   c = 0;                   // Consists of 4 hex digits                   for (var i = 0; i < 4; ++i) {                     int ch = this.reader.ReadChar();                     if (ch >= '0' && ch <= '9') {                     c <<= 4;                     c |= ch - '0';                     } else if (ch >= 'A' && ch <= 'F') {                     c <<= 4;                     c |= ch + 10 - 'A';                     } else if (ch >= 'a' && ch <= 'f') {                     c <<= 4;                     c |= ch + 10 - 'a';                     } else {                 this.reader.RaiseError("Invalid Unicode escaped character");                     }                   }                   if ((c & 0xf800) != 0xd800) {                     // Non-surrogate                     this.sb.Append((char)c);                   } else if ((c & 0xfc00) == 0xd800) {                     int ch = this.reader.ReadChar();                     if (ch != '\\' || this.reader.ReadChar() != 'u') {                     this.reader.RaiseError("Invalid escaped character");                     }                     var c2 = 0;                     for (var i = 0; i < 4; ++i) {                     ch = this.reader.ReadChar();                     if (ch >= '0' && ch <= '9') {                     c2 <<= 4;                     c2 |= ch - '0';                     } else if (ch >= 'A' && ch <= 'F') {                     c2 <<= 4;                     c2 |= ch + 10 - 'A';                     } else if (ch >= 'a' && ch <= 'f') {                     c2 <<= 4;                     c2 |= ch + 10 - 'a';                     } else {                     this.reader.RaiseError("Invalid Unicode escaped character");                     }                     }                     if ((c2 & 0xfc00) != 0xdc00) {                     this.reader.RaiseError("Unpaired surrogate code point");                     } else {                     this.sb.Append((char)c);                     this.sb.Append((char)c2);                     }                   } else {                     this.reader.RaiseError("Unpaired surrogate code point");                   }                   break;                 }               default:                 {                   this.reader.RaiseError("Invalid escaped character");                   break;                 }             }             break;           case 0x22:  // double quote             return this.sb.ToString();           default: {               // NOTE: Assumes the character reader               // throws an error on finding illegal surrogate               // pairs in the string or invalid encoding               // in the stream               if ((c >> 16) == 0) {                 this.sb.Append((char)c);               } else {               this.sb.Append((char)((((c - 0x10000) >> 10) & 0x3ff) +                   0xd800));                 this.sb.Append((char)(((c - 0x10000) & 0x3ff) + 0xdc00));               }               break;             }         }       }
Magic Number,PeterO.Cbor,CBORJson,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORJson.cs,NextJSONString,The following statement contains a magic number: while (true) {         c = this.reader.ReadChar();         if (c == -1 || c < 0x20) {           this.reader.RaiseError("Unterminated string");         }         switch (c) {           case '\\':             c = this.reader.ReadChar();             switch (c) {               case '\\':                 this.sb.Append('\\');                 break;               case '/':                 // Now allowed to be escaped under RFC 7159                 this.sb.Append('/');                 break;               case '\"':                 this.sb.Append('\"');                 break;               case 'b':                 this.sb.Append('\b');                 break;               case 'f':                 this.sb.Append('\f');                 break;               case 'n':                 this.sb.Append('\n');                 break;               case 'r':                 this.sb.Append('\r');                 break;               case 't':                 this.sb.Append('\t');                 break;                 case 'u': {  // Unicode escape                   c = 0;                   // Consists of 4 hex digits                   for (var i = 0; i < 4; ++i) {                     int ch = this.reader.ReadChar();                     if (ch >= '0' && ch <= '9') {                     c <<= 4;                     c |= ch - '0';                     } else if (ch >= 'A' && ch <= 'F') {                     c <<= 4;                     c |= ch + 10 - 'A';                     } else if (ch >= 'a' && ch <= 'f') {                     c <<= 4;                     c |= ch + 10 - 'a';                     } else {                 this.reader.RaiseError("Invalid Unicode escaped character");                     }                   }                   if ((c & 0xf800) != 0xd800) {                     // Non-surrogate                     this.sb.Append((char)c);                   } else if ((c & 0xfc00) == 0xd800) {                     int ch = this.reader.ReadChar();                     if (ch != '\\' || this.reader.ReadChar() != 'u') {                     this.reader.RaiseError("Invalid escaped character");                     }                     var c2 = 0;                     for (var i = 0; i < 4; ++i) {                     ch = this.reader.ReadChar();                     if (ch >= '0' && ch <= '9') {                     c2 <<= 4;                     c2 |= ch - '0';                     } else if (ch >= 'A' && ch <= 'F') {                     c2 <<= 4;                     c2 |= ch + 10 - 'A';                     } else if (ch >= 'a' && ch <= 'f') {                     c2 <<= 4;                     c2 |= ch + 10 - 'a';                     } else {                     this.reader.RaiseError("Invalid Unicode escaped character");                     }                     }                     if ((c2 & 0xfc00) != 0xdc00) {                     this.reader.RaiseError("Unpaired surrogate code point");                     } else {                     this.sb.Append((char)c);                     this.sb.Append((char)c2);                     }                   } else {                     this.reader.RaiseError("Unpaired surrogate code point");                   }                   break;                 }               default:                 {                   this.reader.RaiseError("Invalid escaped character");                   break;                 }             }             break;           case 0x22:  // double quote             return this.sb.ToString();           default: {               // NOTE: Assumes the character reader               // throws an error on finding illegal surrogate               // pairs in the string or invalid encoding               // in the stream               if ((c >> 16) == 0) {                 this.sb.Append((char)c);               } else {               this.sb.Append((char)((((c - 0x10000) >> 10) & 0x3ff) +                   0xd800));                 this.sb.Append((char)(((c - 0x10000) & 0x3ff) + 0xdc00));               }               break;             }         }       }
Magic Number,PeterO.Cbor,CBORJson,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORJson.cs,NextJSONString,The following statement contains a magic number: while (true) {         c = this.reader.ReadChar();         if (c == -1 || c < 0x20) {           this.reader.RaiseError("Unterminated string");         }         switch (c) {           case '\\':             c = this.reader.ReadChar();             switch (c) {               case '\\':                 this.sb.Append('\\');                 break;               case '/':                 // Now allowed to be escaped under RFC 7159                 this.sb.Append('/');                 break;               case '\"':                 this.sb.Append('\"');                 break;               case 'b':                 this.sb.Append('\b');                 break;               case 'f':                 this.sb.Append('\f');                 break;               case 'n':                 this.sb.Append('\n');                 break;               case 'r':                 this.sb.Append('\r');                 break;               case 't':                 this.sb.Append('\t');                 break;                 case 'u': {  // Unicode escape                   c = 0;                   // Consists of 4 hex digits                   for (var i = 0; i < 4; ++i) {                     int ch = this.reader.ReadChar();                     if (ch >= '0' && ch <= '9') {                     c <<= 4;                     c |= ch - '0';                     } else if (ch >= 'A' && ch <= 'F') {                     c <<= 4;                     c |= ch + 10 - 'A';                     } else if (ch >= 'a' && ch <= 'f') {                     c <<= 4;                     c |= ch + 10 - 'a';                     } else {                 this.reader.RaiseError("Invalid Unicode escaped character");                     }                   }                   if ((c & 0xf800) != 0xd800) {                     // Non-surrogate                     this.sb.Append((char)c);                   } else if ((c & 0xfc00) == 0xd800) {                     int ch = this.reader.ReadChar();                     if (ch != '\\' || this.reader.ReadChar() != 'u') {                     this.reader.RaiseError("Invalid escaped character");                     }                     var c2 = 0;                     for (var i = 0; i < 4; ++i) {                     ch = this.reader.ReadChar();                     if (ch >= '0' && ch <= '9') {                     c2 <<= 4;                     c2 |= ch - '0';                     } else if (ch >= 'A' && ch <= 'F') {                     c2 <<= 4;                     c2 |= ch + 10 - 'A';                     } else if (ch >= 'a' && ch <= 'f') {                     c2 <<= 4;                     c2 |= ch + 10 - 'a';                     } else {                     this.reader.RaiseError("Invalid Unicode escaped character");                     }                     }                     if ((c2 & 0xfc00) != 0xdc00) {                     this.reader.RaiseError("Unpaired surrogate code point");                     } else {                     this.sb.Append((char)c);                     this.sb.Append((char)c2);                     }                   } else {                     this.reader.RaiseError("Unpaired surrogate code point");                   }                   break;                 }               default:                 {                   this.reader.RaiseError("Invalid escaped character");                   break;                 }             }             break;           case 0x22:  // double quote             return this.sb.ToString();           default: {               // NOTE: Assumes the character reader               // throws an error on finding illegal surrogate               // pairs in the string or invalid encoding               // in the stream               if ((c >> 16) == 0) {                 this.sb.Append((char)c);               } else {               this.sb.Append((char)((((c - 0x10000) >> 10) & 0x3ff) +                   0xd800));                 this.sb.Append((char)(((c - 0x10000) & 0x3ff) + 0xdc00));               }               break;             }         }       }
Magic Number,PeterO.Cbor,CBORJson,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORJson.cs,NextJSONString,The following statement contains a magic number: while (true) {         c = this.reader.ReadChar();         if (c == -1 || c < 0x20) {           this.reader.RaiseError("Unterminated string");         }         switch (c) {           case '\\':             c = this.reader.ReadChar();             switch (c) {               case '\\':                 this.sb.Append('\\');                 break;               case '/':                 // Now allowed to be escaped under RFC 7159                 this.sb.Append('/');                 break;               case '\"':                 this.sb.Append('\"');                 break;               case 'b':                 this.sb.Append('\b');                 break;               case 'f':                 this.sb.Append('\f');                 break;               case 'n':                 this.sb.Append('\n');                 break;               case 'r':                 this.sb.Append('\r');                 break;               case 't':                 this.sb.Append('\t');                 break;                 case 'u': {  // Unicode escape                   c = 0;                   // Consists of 4 hex digits                   for (var i = 0; i < 4; ++i) {                     int ch = this.reader.ReadChar();                     if (ch >= '0' && ch <= '9') {                     c <<= 4;                     c |= ch - '0';                     } else if (ch >= 'A' && ch <= 'F') {                     c <<= 4;                     c |= ch + 10 - 'A';                     } else if (ch >= 'a' && ch <= 'f') {                     c <<= 4;                     c |= ch + 10 - 'a';                     } else {                 this.reader.RaiseError("Invalid Unicode escaped character");                     }                   }                   if ((c & 0xf800) != 0xd800) {                     // Non-surrogate                     this.sb.Append((char)c);                   } else if ((c & 0xfc00) == 0xd800) {                     int ch = this.reader.ReadChar();                     if (ch != '\\' || this.reader.ReadChar() != 'u') {                     this.reader.RaiseError("Invalid escaped character");                     }                     var c2 = 0;                     for (var i = 0; i < 4; ++i) {                     ch = this.reader.ReadChar();                     if (ch >= '0' && ch <= '9') {                     c2 <<= 4;                     c2 |= ch - '0';                     } else if (ch >= 'A' && ch <= 'F') {                     c2 <<= 4;                     c2 |= ch + 10 - 'A';                     } else if (ch >= 'a' && ch <= 'f') {                     c2 <<= 4;                     c2 |= ch + 10 - 'a';                     } else {                     this.reader.RaiseError("Invalid Unicode escaped character");                     }                     }                     if ((c2 & 0xfc00) != 0xdc00) {                     this.reader.RaiseError("Unpaired surrogate code point");                     } else {                     this.sb.Append((char)c);                     this.sb.Append((char)c2);                     }                   } else {                     this.reader.RaiseError("Unpaired surrogate code point");                   }                   break;                 }               default:                 {                   this.reader.RaiseError("Invalid escaped character");                   break;                 }             }             break;           case 0x22:  // double quote             return this.sb.ToString();           default: {               // NOTE: Assumes the character reader               // throws an error on finding illegal surrogate               // pairs in the string or invalid encoding               // in the stream               if ((c >> 16) == 0) {                 this.sb.Append((char)c);               } else {               this.sb.Append((char)((((c - 0x10000) >> 10) & 0x3ff) +                   0xd800));                 this.sb.Append((char)(((c - 0x10000) & 0x3ff) + 0xdc00));               }               break;             }         }       }
Magic Number,PeterO.Cbor,CBORJson,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORJson.cs,NextJSONString,The following statement contains a magic number: while (true) {         c = this.reader.ReadChar();         if (c == -1 || c < 0x20) {           this.reader.RaiseError("Unterminated string");         }         switch (c) {           case '\\':             c = this.reader.ReadChar();             switch (c) {               case '\\':                 this.sb.Append('\\');                 break;               case '/':                 // Now allowed to be escaped under RFC 7159                 this.sb.Append('/');                 break;               case '\"':                 this.sb.Append('\"');                 break;               case 'b':                 this.sb.Append('\b');                 break;               case 'f':                 this.sb.Append('\f');                 break;               case 'n':                 this.sb.Append('\n');                 break;               case 'r':                 this.sb.Append('\r');                 break;               case 't':                 this.sb.Append('\t');                 break;                 case 'u': {  // Unicode escape                   c = 0;                   // Consists of 4 hex digits                   for (var i = 0; i < 4; ++i) {                     int ch = this.reader.ReadChar();                     if (ch >= '0' && ch <= '9') {                     c <<= 4;                     c |= ch - '0';                     } else if (ch >= 'A' && ch <= 'F') {                     c <<= 4;                     c |= ch + 10 - 'A';                     } else if (ch >= 'a' && ch <= 'f') {                     c <<= 4;                     c |= ch + 10 - 'a';                     } else {                 this.reader.RaiseError("Invalid Unicode escaped character");                     }                   }                   if ((c & 0xf800) != 0xd800) {                     // Non-surrogate                     this.sb.Append((char)c);                   } else if ((c & 0xfc00) == 0xd800) {                     int ch = this.reader.ReadChar();                     if (ch != '\\' || this.reader.ReadChar() != 'u') {                     this.reader.RaiseError("Invalid escaped character");                     }                     var c2 = 0;                     for (var i = 0; i < 4; ++i) {                     ch = this.reader.ReadChar();                     if (ch >= '0' && ch <= '9') {                     c2 <<= 4;                     c2 |= ch - '0';                     } else if (ch >= 'A' && ch <= 'F') {                     c2 <<= 4;                     c2 |= ch + 10 - 'A';                     } else if (ch >= 'a' && ch <= 'f') {                     c2 <<= 4;                     c2 |= ch + 10 - 'a';                     } else {                     this.reader.RaiseError("Invalid Unicode escaped character");                     }                     }                     if ((c2 & 0xfc00) != 0xdc00) {                     this.reader.RaiseError("Unpaired surrogate code point");                     } else {                     this.sb.Append((char)c);                     this.sb.Append((char)c2);                     }                   } else {                     this.reader.RaiseError("Unpaired surrogate code point");                   }                   break;                 }               default:                 {                   this.reader.RaiseError("Invalid escaped character");                   break;                 }             }             break;           case 0x22:  // double quote             return this.sb.ToString();           default: {               // NOTE: Assumes the character reader               // throws an error on finding illegal surrogate               // pairs in the string or invalid encoding               // in the stream               if ((c >> 16) == 0) {                 this.sb.Append((char)c);               } else {               this.sb.Append((char)((((c - 0x10000) >> 10) & 0x3ff) +                   0xd800));                 this.sb.Append((char)(((c - 0x10000) & 0x3ff) + 0xdc00));               }               break;             }         }       }
Magic Number,PeterO.Cbor,CBORJson,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORJson.cs,NextJSONString,The following statement contains a magic number: while (true) {         c = this.reader.ReadChar();         if (c == -1 || c < 0x20) {           this.reader.RaiseError("Unterminated string");         }         switch (c) {           case '\\':             c = this.reader.ReadChar();             switch (c) {               case '\\':                 this.sb.Append('\\');                 break;               case '/':                 // Now allowed to be escaped under RFC 7159                 this.sb.Append('/');                 break;               case '\"':                 this.sb.Append('\"');                 break;               case 'b':                 this.sb.Append('\b');                 break;               case 'f':                 this.sb.Append('\f');                 break;               case 'n':                 this.sb.Append('\n');                 break;               case 'r':                 this.sb.Append('\r');                 break;               case 't':                 this.sb.Append('\t');                 break;                 case 'u': {  // Unicode escape                   c = 0;                   // Consists of 4 hex digits                   for (var i = 0; i < 4; ++i) {                     int ch = this.reader.ReadChar();                     if (ch >= '0' && ch <= '9') {                     c <<= 4;                     c |= ch - '0';                     } else if (ch >= 'A' && ch <= 'F') {                     c <<= 4;                     c |= ch + 10 - 'A';                     } else if (ch >= 'a' && ch <= 'f') {                     c <<= 4;                     c |= ch + 10 - 'a';                     } else {                 this.reader.RaiseError("Invalid Unicode escaped character");                     }                   }                   if ((c & 0xf800) != 0xd800) {                     // Non-surrogate                     this.sb.Append((char)c);                   } else if ((c & 0xfc00) == 0xd800) {                     int ch = this.reader.ReadChar();                     if (ch != '\\' || this.reader.ReadChar() != 'u') {                     this.reader.RaiseError("Invalid escaped character");                     }                     var c2 = 0;                     for (var i = 0; i < 4; ++i) {                     ch = this.reader.ReadChar();                     if (ch >= '0' && ch <= '9') {                     c2 <<= 4;                     c2 |= ch - '0';                     } else if (ch >= 'A' && ch <= 'F') {                     c2 <<= 4;                     c2 |= ch + 10 - 'A';                     } else if (ch >= 'a' && ch <= 'f') {                     c2 <<= 4;                     c2 |= ch + 10 - 'a';                     } else {                     this.reader.RaiseError("Invalid Unicode escaped character");                     }                     }                     if ((c2 & 0xfc00) != 0xdc00) {                     this.reader.RaiseError("Unpaired surrogate code point");                     } else {                     this.sb.Append((char)c);                     this.sb.Append((char)c2);                     }                   } else {                     this.reader.RaiseError("Unpaired surrogate code point");                   }                   break;                 }               default:                 {                   this.reader.RaiseError("Invalid escaped character");                   break;                 }             }             break;           case 0x22:  // double quote             return this.sb.ToString();           default: {               // NOTE: Assumes the character reader               // throws an error on finding illegal surrogate               // pairs in the string or invalid encoding               // in the stream               if ((c >> 16) == 0) {                 this.sb.Append((char)c);               } else {               this.sb.Append((char)((((c - 0x10000) >> 10) & 0x3ff) +                   0xd800));                 this.sb.Append((char)(((c - 0x10000) & 0x3ff) + 0xdc00));               }               break;             }         }       }
Magic Number,PeterO.Cbor,CBORJson,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORJson.cs,NextJSONString,The following statement contains a magic number: while (true) {         c = this.reader.ReadChar();         if (c == -1 || c < 0x20) {           this.reader.RaiseError("Unterminated string");         }         switch (c) {           case '\\':             c = this.reader.ReadChar();             switch (c) {               case '\\':                 this.sb.Append('\\');                 break;               case '/':                 // Now allowed to be escaped under RFC 7159                 this.sb.Append('/');                 break;               case '\"':                 this.sb.Append('\"');                 break;               case 'b':                 this.sb.Append('\b');                 break;               case 'f':                 this.sb.Append('\f');                 break;               case 'n':                 this.sb.Append('\n');                 break;               case 'r':                 this.sb.Append('\r');                 break;               case 't':                 this.sb.Append('\t');                 break;                 case 'u': {  // Unicode escape                   c = 0;                   // Consists of 4 hex digits                   for (var i = 0; i < 4; ++i) {                     int ch = this.reader.ReadChar();                     if (ch >= '0' && ch <= '9') {                     c <<= 4;                     c |= ch - '0';                     } else if (ch >= 'A' && ch <= 'F') {                     c <<= 4;                     c |= ch + 10 - 'A';                     } else if (ch >= 'a' && ch <= 'f') {                     c <<= 4;                     c |= ch + 10 - 'a';                     } else {                 this.reader.RaiseError("Invalid Unicode escaped character");                     }                   }                   if ((c & 0xf800) != 0xd800) {                     // Non-surrogate                     this.sb.Append((char)c);                   } else if ((c & 0xfc00) == 0xd800) {                     int ch = this.reader.ReadChar();                     if (ch != '\\' || this.reader.ReadChar() != 'u') {                     this.reader.RaiseError("Invalid escaped character");                     }                     var c2 = 0;                     for (var i = 0; i < 4; ++i) {                     ch = this.reader.ReadChar();                     if (ch >= '0' && ch <= '9') {                     c2 <<= 4;                     c2 |= ch - '0';                     } else if (ch >= 'A' && ch <= 'F') {                     c2 <<= 4;                     c2 |= ch + 10 - 'A';                     } else if (ch >= 'a' && ch <= 'f') {                     c2 <<= 4;                     c2 |= ch + 10 - 'a';                     } else {                     this.reader.RaiseError("Invalid Unicode escaped character");                     }                     }                     if ((c2 & 0xfc00) != 0xdc00) {                     this.reader.RaiseError("Unpaired surrogate code point");                     } else {                     this.sb.Append((char)c);                     this.sb.Append((char)c2);                     }                   } else {                     this.reader.RaiseError("Unpaired surrogate code point");                   }                   break;                 }               default:                 {                   this.reader.RaiseError("Invalid escaped character");                   break;                 }             }             break;           case 0x22:  // double quote             return this.sb.ToString();           default: {               // NOTE: Assumes the character reader               // throws an error on finding illegal surrogate               // pairs in the string or invalid encoding               // in the stream               if ((c >> 16) == 0) {                 this.sb.Append((char)c);               } else {               this.sb.Append((char)((((c - 0x10000) >> 10) & 0x3ff) +                   0xd800));                 this.sb.Append((char)(((c - 0x10000) & 0x3ff) + 0xdc00));               }               break;             }         }       }
Magic Number,PeterO.Cbor,CBORJson,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORJson.cs,NextJSONString,The following statement contains a magic number: while (true) {         c = this.reader.ReadChar();         if (c == -1 || c < 0x20) {           this.reader.RaiseError("Unterminated string");         }         switch (c) {           case '\\':             c = this.reader.ReadChar();             switch (c) {               case '\\':                 this.sb.Append('\\');                 break;               case '/':                 // Now allowed to be escaped under RFC 7159                 this.sb.Append('/');                 break;               case '\"':                 this.sb.Append('\"');                 break;               case 'b':                 this.sb.Append('\b');                 break;               case 'f':                 this.sb.Append('\f');                 break;               case 'n':                 this.sb.Append('\n');                 break;               case 'r':                 this.sb.Append('\r');                 break;               case 't':                 this.sb.Append('\t');                 break;                 case 'u': {  // Unicode escape                   c = 0;                   // Consists of 4 hex digits                   for (var i = 0; i < 4; ++i) {                     int ch = this.reader.ReadChar();                     if (ch >= '0' && ch <= '9') {                     c <<= 4;                     c |= ch - '0';                     } else if (ch >= 'A' && ch <= 'F') {                     c <<= 4;                     c |= ch + 10 - 'A';                     } else if (ch >= 'a' && ch <= 'f') {                     c <<= 4;                     c |= ch + 10 - 'a';                     } else {                 this.reader.RaiseError("Invalid Unicode escaped character");                     }                   }                   if ((c & 0xf800) != 0xd800) {                     // Non-surrogate                     this.sb.Append((char)c);                   } else if ((c & 0xfc00) == 0xd800) {                     int ch = this.reader.ReadChar();                     if (ch != '\\' || this.reader.ReadChar() != 'u') {                     this.reader.RaiseError("Invalid escaped character");                     }                     var c2 = 0;                     for (var i = 0; i < 4; ++i) {                     ch = this.reader.ReadChar();                     if (ch >= '0' && ch <= '9') {                     c2 <<= 4;                     c2 |= ch - '0';                     } else if (ch >= 'A' && ch <= 'F') {                     c2 <<= 4;                     c2 |= ch + 10 - 'A';                     } else if (ch >= 'a' && ch <= 'f') {                     c2 <<= 4;                     c2 |= ch + 10 - 'a';                     } else {                     this.reader.RaiseError("Invalid Unicode escaped character");                     }                     }                     if ((c2 & 0xfc00) != 0xdc00) {                     this.reader.RaiseError("Unpaired surrogate code point");                     } else {                     this.sb.Append((char)c);                     this.sb.Append((char)c2);                     }                   } else {                     this.reader.RaiseError("Unpaired surrogate code point");                   }                   break;                 }               default:                 {                   this.reader.RaiseError("Invalid escaped character");                   break;                 }             }             break;           case 0x22:  // double quote             return this.sb.ToString();           default: {               // NOTE: Assumes the character reader               // throws an error on finding illegal surrogate               // pairs in the string or invalid encoding               // in the stream               if ((c >> 16) == 0) {                 this.sb.Append((char)c);               } else {               this.sb.Append((char)((((c - 0x10000) >> 10) & 0x3ff) +                   0xd800));                 this.sb.Append((char)(((c - 0x10000) & 0x3ff) + 0xdc00));               }               break;             }         }       }
Magic Number,PeterO.Cbor,CBORJson,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORJson.cs,NextJSONString,The following statement contains a magic number: while (true) {         c = this.reader.ReadChar();         if (c == -1 || c < 0x20) {           this.reader.RaiseError("Unterminated string");         }         switch (c) {           case '\\':             c = this.reader.ReadChar();             switch (c) {               case '\\':                 this.sb.Append('\\');                 break;               case '/':                 // Now allowed to be escaped under RFC 7159                 this.sb.Append('/');                 break;               case '\"':                 this.sb.Append('\"');                 break;               case 'b':                 this.sb.Append('\b');                 break;               case 'f':                 this.sb.Append('\f');                 break;               case 'n':                 this.sb.Append('\n');                 break;               case 'r':                 this.sb.Append('\r');                 break;               case 't':                 this.sb.Append('\t');                 break;                 case 'u': {  // Unicode escape                   c = 0;                   // Consists of 4 hex digits                   for (var i = 0; i < 4; ++i) {                     int ch = this.reader.ReadChar();                     if (ch >= '0' && ch <= '9') {                     c <<= 4;                     c |= ch - '0';                     } else if (ch >= 'A' && ch <= 'F') {                     c <<= 4;                     c |= ch + 10 - 'A';                     } else if (ch >= 'a' && ch <= 'f') {                     c <<= 4;                     c |= ch + 10 - 'a';                     } else {                 this.reader.RaiseError("Invalid Unicode escaped character");                     }                   }                   if ((c & 0xf800) != 0xd800) {                     // Non-surrogate                     this.sb.Append((char)c);                   } else if ((c & 0xfc00) == 0xd800) {                     int ch = this.reader.ReadChar();                     if (ch != '\\' || this.reader.ReadChar() != 'u') {                     this.reader.RaiseError("Invalid escaped character");                     }                     var c2 = 0;                     for (var i = 0; i < 4; ++i) {                     ch = this.reader.ReadChar();                     if (ch >= '0' && ch <= '9') {                     c2 <<= 4;                     c2 |= ch - '0';                     } else if (ch >= 'A' && ch <= 'F') {                     c2 <<= 4;                     c2 |= ch + 10 - 'A';                     } else if (ch >= 'a' && ch <= 'f') {                     c2 <<= 4;                     c2 |= ch + 10 - 'a';                     } else {                     this.reader.RaiseError("Invalid Unicode escaped character");                     }                     }                     if ((c2 & 0xfc00) != 0xdc00) {                     this.reader.RaiseError("Unpaired surrogate code point");                     } else {                     this.sb.Append((char)c);                     this.sb.Append((char)c2);                     }                   } else {                     this.reader.RaiseError("Unpaired surrogate code point");                   }                   break;                 }               default:                 {                   this.reader.RaiseError("Invalid escaped character");                   break;                 }             }             break;           case 0x22:  // double quote             return this.sb.ToString();           default: {               // NOTE: Assumes the character reader               // throws an error on finding illegal surrogate               // pairs in the string or invalid encoding               // in the stream               if ((c >> 16) == 0) {                 this.sb.Append((char)c);               } else {               this.sb.Append((char)((((c - 0x10000) >> 10) & 0x3ff) +                   0xd800));                 this.sb.Append((char)(((c - 0x10000) & 0x3ff) + 0xdc00));               }               break;             }         }       }
Magic Number,PeterO.Cbor,CBORJson,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORJson.cs,ParseJSONObject,The following statement contains a magic number: if (depth > 1000) {         this.reader.RaiseError("Too deeply nested");       }
Magic Number,PeterO.Cbor,CBORJson,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORJson.cs,ParseJSONArray,The following statement contains a magic number: if (depth > 1000) {         this.reader.RaiseError("Too deeply nested");       }
Magic Number,PeterO.Cbor,CBORJson,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORJson.cs,WriteJSONStringUnquoted,The following statement contains a magic number: for (var i = 0; i < str.Length; ++i) {         char c = str[i];         if (c == '\\' || c == '"') {           if (first) {             first = false;             sb.WriteString(str' 0' i);           }           sb.WriteCodePoint((int)'\\');           sb.WriteCodePoint((int)c);         } else if (c < 0x20 || (c >= 0x7f && (c == 0x2028 || c == 0x2029 ||                     (c >= 0x7f && c <= 0xa0) || c == 0xfeff || c == 0xfffe ||                     c == 0xffff))) {           // Control characters' and also the line and paragraph separators           // which apparently can't appear in JavaScript (as opposed to           // JSON) strings           if (first) {             first = false;             sb.WriteString(str' 0' i);           }           if (c == 0x0d) {             sb.WriteString("\\r");           } else if (c == 0x0a) {             sb.WriteString("\\n");           } else if (c == 0x08) {             sb.WriteString("\\b");           } else if (c == 0x0c) {             sb.WriteString("\\f");           } else if (c == 0x09) {             sb.WriteString("\\t");           } else if (c == 0x85) {             sb.WriteString("\\u0085");           } else if (c >= 0x100) {             sb.WriteString("\\u");             sb.WriteCodePoint((int)Hex16[(int)((c >> 12) & 15)]);             sb.WriteCodePoint((int)Hex16[(int)((c >> 8) & 15)]);             sb.WriteCodePoint((int)Hex16[(int)((c >> 4) & 15)]);             sb.WriteCodePoint((int)Hex16[(int)(c & 15)]);           } else {             sb.WriteString("\\u00");             sb.WriteCodePoint((int)Hex16[(int)(c >> 4)]);             sb.WriteCodePoint((int)Hex16[(int)(c & 15)]);           }         } else if (!first) {           if ((c & 0xfc00) == 0xd800) {             sb.WriteString(str' i' 2);             ++i;           } else {             sb.WriteCodePoint((int)c);           }         }       }
Magic Number,PeterO.Cbor,CBORJson,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORJson.cs,WriteJSONStringUnquoted,The following statement contains a magic number: for (var i = 0; i < str.Length; ++i) {         char c = str[i];         if (c == '\\' || c == '"') {           if (first) {             first = false;             sb.WriteString(str' 0' i);           }           sb.WriteCodePoint((int)'\\');           sb.WriteCodePoint((int)c);         } else if (c < 0x20 || (c >= 0x7f && (c == 0x2028 || c == 0x2029 ||                     (c >= 0x7f && c <= 0xa0) || c == 0xfeff || c == 0xfffe ||                     c == 0xffff))) {           // Control characters' and also the line and paragraph separators           // which apparently can't appear in JavaScript (as opposed to           // JSON) strings           if (first) {             first = false;             sb.WriteString(str' 0' i);           }           if (c == 0x0d) {             sb.WriteString("\\r");           } else if (c == 0x0a) {             sb.WriteString("\\n");           } else if (c == 0x08) {             sb.WriteString("\\b");           } else if (c == 0x0c) {             sb.WriteString("\\f");           } else if (c == 0x09) {             sb.WriteString("\\t");           } else if (c == 0x85) {             sb.WriteString("\\u0085");           } else if (c >= 0x100) {             sb.WriteString("\\u");             sb.WriteCodePoint((int)Hex16[(int)((c >> 12) & 15)]);             sb.WriteCodePoint((int)Hex16[(int)((c >> 8) & 15)]);             sb.WriteCodePoint((int)Hex16[(int)((c >> 4) & 15)]);             sb.WriteCodePoint((int)Hex16[(int)(c & 15)]);           } else {             sb.WriteString("\\u00");             sb.WriteCodePoint((int)Hex16[(int)(c >> 4)]);             sb.WriteCodePoint((int)Hex16[(int)(c & 15)]);           }         } else if (!first) {           if ((c & 0xfc00) == 0xd800) {             sb.WriteString(str' i' 2);             ++i;           } else {             sb.WriteCodePoint((int)c);           }         }       }
Magic Number,PeterO.Cbor,CBORJson,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORJson.cs,WriteJSONStringUnquoted,The following statement contains a magic number: for (var i = 0; i < str.Length; ++i) {         char c = str[i];         if (c == '\\' || c == '"') {           if (first) {             first = false;             sb.WriteString(str' 0' i);           }           sb.WriteCodePoint((int)'\\');           sb.WriteCodePoint((int)c);         } else if (c < 0x20 || (c >= 0x7f && (c == 0x2028 || c == 0x2029 ||                     (c >= 0x7f && c <= 0xa0) || c == 0xfeff || c == 0xfffe ||                     c == 0xffff))) {           // Control characters' and also the line and paragraph separators           // which apparently can't appear in JavaScript (as opposed to           // JSON) strings           if (first) {             first = false;             sb.WriteString(str' 0' i);           }           if (c == 0x0d) {             sb.WriteString("\\r");           } else if (c == 0x0a) {             sb.WriteString("\\n");           } else if (c == 0x08) {             sb.WriteString("\\b");           } else if (c == 0x0c) {             sb.WriteString("\\f");           } else if (c == 0x09) {             sb.WriteString("\\t");           } else if (c == 0x85) {             sb.WriteString("\\u0085");           } else if (c >= 0x100) {             sb.WriteString("\\u");             sb.WriteCodePoint((int)Hex16[(int)((c >> 12) & 15)]);             sb.WriteCodePoint((int)Hex16[(int)((c >> 8) & 15)]);             sb.WriteCodePoint((int)Hex16[(int)((c >> 4) & 15)]);             sb.WriteCodePoint((int)Hex16[(int)(c & 15)]);           } else {             sb.WriteString("\\u00");             sb.WriteCodePoint((int)Hex16[(int)(c >> 4)]);             sb.WriteCodePoint((int)Hex16[(int)(c & 15)]);           }         } else if (!first) {           if ((c & 0xfc00) == 0xd800) {             sb.WriteString(str' i' 2);             ++i;           } else {             sb.WriteCodePoint((int)c);           }         }       }
Magic Number,PeterO.Cbor,CBORJson,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORJson.cs,WriteJSONStringUnquoted,The following statement contains a magic number: for (var i = 0; i < str.Length; ++i) {         char c = str[i];         if (c == '\\' || c == '"') {           if (first) {             first = false;             sb.WriteString(str' 0' i);           }           sb.WriteCodePoint((int)'\\');           sb.WriteCodePoint((int)c);         } else if (c < 0x20 || (c >= 0x7f && (c == 0x2028 || c == 0x2029 ||                     (c >= 0x7f && c <= 0xa0) || c == 0xfeff || c == 0xfffe ||                     c == 0xffff))) {           // Control characters' and also the line and paragraph separators           // which apparently can't appear in JavaScript (as opposed to           // JSON) strings           if (first) {             first = false;             sb.WriteString(str' 0' i);           }           if (c == 0x0d) {             sb.WriteString("\\r");           } else if (c == 0x0a) {             sb.WriteString("\\n");           } else if (c == 0x08) {             sb.WriteString("\\b");           } else if (c == 0x0c) {             sb.WriteString("\\f");           } else if (c == 0x09) {             sb.WriteString("\\t");           } else if (c == 0x85) {             sb.WriteString("\\u0085");           } else if (c >= 0x100) {             sb.WriteString("\\u");             sb.WriteCodePoint((int)Hex16[(int)((c >> 12) & 15)]);             sb.WriteCodePoint((int)Hex16[(int)((c >> 8) & 15)]);             sb.WriteCodePoint((int)Hex16[(int)((c >> 4) & 15)]);             sb.WriteCodePoint((int)Hex16[(int)(c & 15)]);           } else {             sb.WriteString("\\u00");             sb.WriteCodePoint((int)Hex16[(int)(c >> 4)]);             sb.WriteCodePoint((int)Hex16[(int)(c & 15)]);           }         } else if (!first) {           if ((c & 0xfc00) == 0xd800) {             sb.WriteString(str' i' 2);             ++i;           } else {             sb.WriteCodePoint((int)c);           }         }       }
Magic Number,PeterO.Cbor,CBORJson,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORJson.cs,WriteJSONStringUnquoted,The following statement contains a magic number: for (var i = 0; i < str.Length; ++i) {         char c = str[i];         if (c == '\\' || c == '"') {           if (first) {             first = false;             sb.WriteString(str' 0' i);           }           sb.WriteCodePoint((int)'\\');           sb.WriteCodePoint((int)c);         } else if (c < 0x20 || (c >= 0x7f && (c == 0x2028 || c == 0x2029 ||                     (c >= 0x7f && c <= 0xa0) || c == 0xfeff || c == 0xfffe ||                     c == 0xffff))) {           // Control characters' and also the line and paragraph separators           // which apparently can't appear in JavaScript (as opposed to           // JSON) strings           if (first) {             first = false;             sb.WriteString(str' 0' i);           }           if (c == 0x0d) {             sb.WriteString("\\r");           } else if (c == 0x0a) {             sb.WriteString("\\n");           } else if (c == 0x08) {             sb.WriteString("\\b");           } else if (c == 0x0c) {             sb.WriteString("\\f");           } else if (c == 0x09) {             sb.WriteString("\\t");           } else if (c == 0x85) {             sb.WriteString("\\u0085");           } else if (c >= 0x100) {             sb.WriteString("\\u");             sb.WriteCodePoint((int)Hex16[(int)((c >> 12) & 15)]);             sb.WriteCodePoint((int)Hex16[(int)((c >> 8) & 15)]);             sb.WriteCodePoint((int)Hex16[(int)((c >> 4) & 15)]);             sb.WriteCodePoint((int)Hex16[(int)(c & 15)]);           } else {             sb.WriteString("\\u00");             sb.WriteCodePoint((int)Hex16[(int)(c >> 4)]);             sb.WriteCodePoint((int)Hex16[(int)(c & 15)]);           }         } else if (!first) {           if ((c & 0xfc00) == 0xd800) {             sb.WriteString(str' i' 2);             ++i;           } else {             sb.WriteCodePoint((int)c);           }         }       }
Magic Number,PeterO.Cbor,CBORJson,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORJson.cs,WriteJSONStringUnquoted,The following statement contains a magic number: for (var i = 0; i < str.Length; ++i) {         char c = str[i];         if (c == '\\' || c == '"') {           if (first) {             first = false;             sb.WriteString(str' 0' i);           }           sb.WriteCodePoint((int)'\\');           sb.WriteCodePoint((int)c);         } else if (c < 0x20 || (c >= 0x7f && (c == 0x2028 || c == 0x2029 ||                     (c >= 0x7f && c <= 0xa0) || c == 0xfeff || c == 0xfffe ||                     c == 0xffff))) {           // Control characters' and also the line and paragraph separators           // which apparently can't appear in JavaScript (as opposed to           // JSON) strings           if (first) {             first = false;             sb.WriteString(str' 0' i);           }           if (c == 0x0d) {             sb.WriteString("\\r");           } else if (c == 0x0a) {             sb.WriteString("\\n");           } else if (c == 0x08) {             sb.WriteString("\\b");           } else if (c == 0x0c) {             sb.WriteString("\\f");           } else if (c == 0x09) {             sb.WriteString("\\t");           } else if (c == 0x85) {             sb.WriteString("\\u0085");           } else if (c >= 0x100) {             sb.WriteString("\\u");             sb.WriteCodePoint((int)Hex16[(int)((c >> 12) & 15)]);             sb.WriteCodePoint((int)Hex16[(int)((c >> 8) & 15)]);             sb.WriteCodePoint((int)Hex16[(int)((c >> 4) & 15)]);             sb.WriteCodePoint((int)Hex16[(int)(c & 15)]);           } else {             sb.WriteString("\\u00");             sb.WriteCodePoint((int)Hex16[(int)(c >> 4)]);             sb.WriteCodePoint((int)Hex16[(int)(c & 15)]);           }         } else if (!first) {           if ((c & 0xfc00) == 0xd800) {             sb.WriteString(str' i' 2);             ++i;           } else {             sb.WriteCodePoint((int)c);           }         }       }
Magic Number,PeterO.Cbor,CBORJson,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORJson.cs,WriteJSONStringUnquoted,The following statement contains a magic number: for (var i = 0; i < str.Length; ++i) {         char c = str[i];         if (c == '\\' || c == '"') {           if (first) {             first = false;             sb.WriteString(str' 0' i);           }           sb.WriteCodePoint((int)'\\');           sb.WriteCodePoint((int)c);         } else if (c < 0x20 || (c >= 0x7f && (c == 0x2028 || c == 0x2029 ||                     (c >= 0x7f && c <= 0xa0) || c == 0xfeff || c == 0xfffe ||                     c == 0xffff))) {           // Control characters' and also the line and paragraph separators           // which apparently can't appear in JavaScript (as opposed to           // JSON) strings           if (first) {             first = false;             sb.WriteString(str' 0' i);           }           if (c == 0x0d) {             sb.WriteString("\\r");           } else if (c == 0x0a) {             sb.WriteString("\\n");           } else if (c == 0x08) {             sb.WriteString("\\b");           } else if (c == 0x0c) {             sb.WriteString("\\f");           } else if (c == 0x09) {             sb.WriteString("\\t");           } else if (c == 0x85) {             sb.WriteString("\\u0085");           } else if (c >= 0x100) {             sb.WriteString("\\u");             sb.WriteCodePoint((int)Hex16[(int)((c >> 12) & 15)]);             sb.WriteCodePoint((int)Hex16[(int)((c >> 8) & 15)]);             sb.WriteCodePoint((int)Hex16[(int)((c >> 4) & 15)]);             sb.WriteCodePoint((int)Hex16[(int)(c & 15)]);           } else {             sb.WriteString("\\u00");             sb.WriteCodePoint((int)Hex16[(int)(c >> 4)]);             sb.WriteCodePoint((int)Hex16[(int)(c & 15)]);           }         } else if (!first) {           if ((c & 0xfc00) == 0xd800) {             sb.WriteString(str' i' 2);             ++i;           } else {             sb.WriteCodePoint((int)c);           }         }       }
Magic Number,PeterO.Cbor,CBORJson,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORJson.cs,WriteJSONStringUnquoted,The following statement contains a magic number: for (var i = 0; i < str.Length; ++i) {         char c = str[i];         if (c == '\\' || c == '"') {           if (first) {             first = false;             sb.WriteString(str' 0' i);           }           sb.WriteCodePoint((int)'\\');           sb.WriteCodePoint((int)c);         } else if (c < 0x20 || (c >= 0x7f && (c == 0x2028 || c == 0x2029 ||                     (c >= 0x7f && c <= 0xa0) || c == 0xfeff || c == 0xfffe ||                     c == 0xffff))) {           // Control characters' and also the line and paragraph separators           // which apparently can't appear in JavaScript (as opposed to           // JSON) strings           if (first) {             first = false;             sb.WriteString(str' 0' i);           }           if (c == 0x0d) {             sb.WriteString("\\r");           } else if (c == 0x0a) {             sb.WriteString("\\n");           } else if (c == 0x08) {             sb.WriteString("\\b");           } else if (c == 0x0c) {             sb.WriteString("\\f");           } else if (c == 0x09) {             sb.WriteString("\\t");           } else if (c == 0x85) {             sb.WriteString("\\u0085");           } else if (c >= 0x100) {             sb.WriteString("\\u");             sb.WriteCodePoint((int)Hex16[(int)((c >> 12) & 15)]);             sb.WriteCodePoint((int)Hex16[(int)((c >> 8) & 15)]);             sb.WriteCodePoint((int)Hex16[(int)((c >> 4) & 15)]);             sb.WriteCodePoint((int)Hex16[(int)(c & 15)]);           } else {             sb.WriteString("\\u00");             sb.WriteCodePoint((int)Hex16[(int)(c >> 4)]);             sb.WriteCodePoint((int)Hex16[(int)(c & 15)]);           }         } else if (!first) {           if ((c & 0xfc00) == 0xd800) {             sb.WriteString(str' i' 2);             ++i;           } else {             sb.WriteCodePoint((int)c);           }         }       }
Magic Number,PeterO.Cbor,CBORJson,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORJson.cs,WriteJSONStringUnquoted,The following statement contains a magic number: for (var i = 0; i < str.Length; ++i) {         char c = str[i];         if (c == '\\' || c == '"') {           if (first) {             first = false;             sb.WriteString(str' 0' i);           }           sb.WriteCodePoint((int)'\\');           sb.WriteCodePoint((int)c);         } else if (c < 0x20 || (c >= 0x7f && (c == 0x2028 || c == 0x2029 ||                     (c >= 0x7f && c <= 0xa0) || c == 0xfeff || c == 0xfffe ||                     c == 0xffff))) {           // Control characters' and also the line and paragraph separators           // which apparently can't appear in JavaScript (as opposed to           // JSON) strings           if (first) {             first = false;             sb.WriteString(str' 0' i);           }           if (c == 0x0d) {             sb.WriteString("\\r");           } else if (c == 0x0a) {             sb.WriteString("\\n");           } else if (c == 0x08) {             sb.WriteString("\\b");           } else if (c == 0x0c) {             sb.WriteString("\\f");           } else if (c == 0x09) {             sb.WriteString("\\t");           } else if (c == 0x85) {             sb.WriteString("\\u0085");           } else if (c >= 0x100) {             sb.WriteString("\\u");             sb.WriteCodePoint((int)Hex16[(int)((c >> 12) & 15)]);             sb.WriteCodePoint((int)Hex16[(int)((c >> 8) & 15)]);             sb.WriteCodePoint((int)Hex16[(int)((c >> 4) & 15)]);             sb.WriteCodePoint((int)Hex16[(int)(c & 15)]);           } else {             sb.WriteString("\\u00");             sb.WriteCodePoint((int)Hex16[(int)(c >> 4)]);             sb.WriteCodePoint((int)Hex16[(int)(c & 15)]);           }         } else if (!first) {           if ((c & 0xfc00) == 0xd800) {             sb.WriteString(str' i' 2);             ++i;           } else {             sb.WriteCodePoint((int)c);           }         }       }
Magic Number,PeterO.Cbor,CBORJson,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORJson.cs,WriteJSONStringUnquoted,The following statement contains a magic number: for (var i = 0; i < str.Length; ++i) {         char c = str[i];         if (c == '\\' || c == '"') {           if (first) {             first = false;             sb.WriteString(str' 0' i);           }           sb.WriteCodePoint((int)'\\');           sb.WriteCodePoint((int)c);         } else if (c < 0x20 || (c >= 0x7f && (c == 0x2028 || c == 0x2029 ||                     (c >= 0x7f && c <= 0xa0) || c == 0xfeff || c == 0xfffe ||                     c == 0xffff))) {           // Control characters' and also the line and paragraph separators           // which apparently can't appear in JavaScript (as opposed to           // JSON) strings           if (first) {             first = false;             sb.WriteString(str' 0' i);           }           if (c == 0x0d) {             sb.WriteString("\\r");           } else if (c == 0x0a) {             sb.WriteString("\\n");           } else if (c == 0x08) {             sb.WriteString("\\b");           } else if (c == 0x0c) {             sb.WriteString("\\f");           } else if (c == 0x09) {             sb.WriteString("\\t");           } else if (c == 0x85) {             sb.WriteString("\\u0085");           } else if (c >= 0x100) {             sb.WriteString("\\u");             sb.WriteCodePoint((int)Hex16[(int)((c >> 12) & 15)]);             sb.WriteCodePoint((int)Hex16[(int)((c >> 8) & 15)]);             sb.WriteCodePoint((int)Hex16[(int)((c >> 4) & 15)]);             sb.WriteCodePoint((int)Hex16[(int)(c & 15)]);           } else {             sb.WriteString("\\u00");             sb.WriteCodePoint((int)Hex16[(int)(c >> 4)]);             sb.WriteCodePoint((int)Hex16[(int)(c & 15)]);           }         } else if (!first) {           if ((c & 0xfc00) == 0xd800) {             sb.WriteString(str' i' 2);             ++i;           } else {             sb.WriteCodePoint((int)c);           }         }       }
Magic Number,PeterO.Cbor,CBORJson,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORJson.cs,WriteJSONToInternal,The following statement contains a magic number: switch (type) {           case CBORObject.CBORObjectTypeSimpleValue: {             if (obj.IsTrue) {               writer.WriteString("true");               return;             }             if (obj.IsFalse) {               writer.WriteString("false");               return;             }             writer.WriteString("null");             return;           }           case CBORObject.CBORObjectTypeSingle: {             var f = (float)thisItem;             if (Single.IsNegativeInfinity(f) ||                 Single.IsPositiveInfinity(f) || Single.IsNaN(f)) {               writer.WriteString("null");               return;             }             writer.WriteString(               CBORObject.TrimDotZero(                 CBORUtilities.SingleToString(f)));             return;           }           case CBORObject.CBORObjectTypeDouble: {             var f = (double)thisItem;             if (Double.IsNegativeInfinity(f) || Double.IsPositiveInfinity(f) ||                 Double.IsNaN(f)) {               writer.WriteString("null");               return;             }             string dblString = CBORUtilities.DoubleToString(f);             writer.WriteString(               CBORObject.TrimDotZero(dblString));             return;           }           case CBORObject.CBORObjectTypeInteger: {             var longItem = (long)thisItem;             writer.WriteString(CBORUtilities.LongToString(longItem));             return;           }           case CBORObject.CBORObjectTypeBigInteger: {             writer.WriteString(               CBORUtilities.BigIntToString((EInteger)thisItem));             return;           }           case CBORObject.CBORObjectTypeExtendedDecimal: {             var dec = (EDecimal)thisItem;             if (dec.IsInfinity() || dec.IsNaN()) {               writer.WriteString("null");             } else {               writer.WriteString(dec.ToString());             }             return;           }           case CBORObject.CBORObjectTypeExtendedFloat: {             var flo = (EFloat)thisItem;             if (flo.IsInfinity() || flo.IsNaN()) {               writer.WriteString("null");               return;             }             if (flo.IsFinite &&                 flo.Exponent.Abs().CompareTo((EInteger)2500) > 0) {               // Too inefficient to convert to a decimal number               // from a bigfloat with a very high exponent'               // so convert to double instead               double f = flo.ToDouble();               if (Double.IsNegativeInfinity(f) ||                   Double.IsPositiveInfinity(f) || Double.IsNaN(f)) {                 writer.WriteString("null");                 return;               }               string dblString =                   CBORUtilities.DoubleToString(f);               writer.WriteString(                 CBORObject.TrimDotZero(dblString));               return;             }             writer.WriteString(flo.ToString());             return;           }         case CBORObject.CBORObjectTypeByteString:           {             var byteArray = (byte[])thisItem;             if (byteArray.Length == 0) {               writer.WriteString("\"\"");               return;             }             writer.WriteCodePoint((int)'\"');             if (obj.HasTag(22)) {               Base64.WriteBase64(                 writer'                 byteArray'                 0'                 byteArray.Length'                 false);             } else if (obj.HasTag(23)) {               // Write as base16               for (int i = 0; i < byteArray.Length; ++i) {                 writer.WriteCodePoint((int)Hex16[(byteArray[i] >> 4) & 15]);                 writer.WriteCodePoint((int)Hex16[byteArray[i] & 15]);               }             } else {               Base64.WriteBase64URL(                 writer'                 byteArray'                 0'                 byteArray.Length'                 false);             }             writer.WriteCodePoint((int)'\"');             break;           }           case CBORObject.CBORObjectTypeTextString: {             var thisString = (string)thisItem;             if (thisString.Length == 0) {               writer.WriteString("\"\"");               return;             }             writer.WriteCodePoint((int)'\"');             WriteJSONStringUnquoted(thisString' writer);             writer.WriteCodePoint((int)'\"');             break;           }           case CBORObject.CBORObjectTypeArray: {             var first = true;             writer.WriteCodePoint((int)'[');             foreach (CBORObject i in obj.AsList()) {               if (!first) {                 writer.WriteCodePoint((int)''');               }               WriteJSONToInternal(i' writer);               first = false;             }             writer.WriteCodePoint((int)']');             break;           }           case CBORObject.CBORObjectTypeExtendedRational: {             var dec = (ERational)thisItem;             EDecimal f = dec.ToEDecimalExactIfPossible(               EContext.Decimal128.WithUnlimitedExponents());             if (!f.IsFinite) {               writer.WriteString("null");             } else {               writer.WriteString(f.ToString());             }             break;           }           case CBORObject.CBORObjectTypeMap: {             var first = true;             var hasNonStringKeys = false;             IDictionary<CBORObject' CBORObject> objMap = obj.AsMap();             foreach (KeyValuePair<CBORObject' CBORObject> entry in objMap) {               CBORObject key = entry.Key;               if (key.ItemType != CBORObject.CBORObjectTypeTextString) {                 hasNonStringKeys = true;                 break;               }             }             if (!hasNonStringKeys) {               writer.WriteCodePoint((int)'{');               foreach (KeyValuePair<CBORObject' CBORObject> entry in objMap) {                 CBORObject key = entry.Key;                 CBORObject value = entry.Value;                 if (!first) {                   writer.WriteCodePoint((int)''');                 }                 writer.WriteCodePoint((int)'\"');                 WriteJSONStringUnquoted((string)key.ThisItem' writer);                 writer.WriteCodePoint((int)'\"');                 writer.WriteCodePoint((int)':');                 WriteJSONToInternal(value' writer);                 first = false;               }               writer.WriteCodePoint((int)'}');             } else {               // This map has non-string keys               IDictionary<string' CBORObject> stringMap = new                 Dictionary<string' CBORObject>();               // Copy to a map with String keys' since               // some keys could be duplicates               // when serialized to strings               foreach (KeyValuePair<CBORObject' CBORObject> entry in objMap) {                 CBORObject key = entry.Key;                 CBORObject value = entry.Value;            string str = (key.ItemType == CBORObject.CBORObjectTypeTextString) ?                   ((string)key.ThisItem) : key.ToJSONString();                 stringMap[str] = value;               }               first = true;               writer.WriteCodePoint((int)'{');               foreach (KeyValuePair<string' CBORObject> entry in stringMap) {                 string key = entry.Key;                 CBORObject value = entry.Value;                 if (!first) {                   writer.WriteCodePoint((int)''');                 }                 writer.WriteCodePoint((int)'\"');                 WriteJSONStringUnquoted((string)key' writer);                 writer.WriteCodePoint((int)'\"');                 writer.WriteCodePoint((int)':');                 WriteJSONToInternal(value' writer);                 first = false;               }               writer.WriteCodePoint((int)'}');             }             break;           }         default:           throw new InvalidOperationException("Unexpected item type");       }
Magic Number,PeterO.Cbor,CBORJson,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORJson.cs,WriteJSONToInternal,The following statement contains a magic number: switch (type) {           case CBORObject.CBORObjectTypeSimpleValue: {             if (obj.IsTrue) {               writer.WriteString("true");               return;             }             if (obj.IsFalse) {               writer.WriteString("false");               return;             }             writer.WriteString("null");             return;           }           case CBORObject.CBORObjectTypeSingle: {             var f = (float)thisItem;             if (Single.IsNegativeInfinity(f) ||                 Single.IsPositiveInfinity(f) || Single.IsNaN(f)) {               writer.WriteString("null");               return;             }             writer.WriteString(               CBORObject.TrimDotZero(                 CBORUtilities.SingleToString(f)));             return;           }           case CBORObject.CBORObjectTypeDouble: {             var f = (double)thisItem;             if (Double.IsNegativeInfinity(f) || Double.IsPositiveInfinity(f) ||                 Double.IsNaN(f)) {               writer.WriteString("null");               return;             }             string dblString = CBORUtilities.DoubleToString(f);             writer.WriteString(               CBORObject.TrimDotZero(dblString));             return;           }           case CBORObject.CBORObjectTypeInteger: {             var longItem = (long)thisItem;             writer.WriteString(CBORUtilities.LongToString(longItem));             return;           }           case CBORObject.CBORObjectTypeBigInteger: {             writer.WriteString(               CBORUtilities.BigIntToString((EInteger)thisItem));             return;           }           case CBORObject.CBORObjectTypeExtendedDecimal: {             var dec = (EDecimal)thisItem;             if (dec.IsInfinity() || dec.IsNaN()) {               writer.WriteString("null");             } else {               writer.WriteString(dec.ToString());             }             return;           }           case CBORObject.CBORObjectTypeExtendedFloat: {             var flo = (EFloat)thisItem;             if (flo.IsInfinity() || flo.IsNaN()) {               writer.WriteString("null");               return;             }             if (flo.IsFinite &&                 flo.Exponent.Abs().CompareTo((EInteger)2500) > 0) {               // Too inefficient to convert to a decimal number               // from a bigfloat with a very high exponent'               // so convert to double instead               double f = flo.ToDouble();               if (Double.IsNegativeInfinity(f) ||                   Double.IsPositiveInfinity(f) || Double.IsNaN(f)) {                 writer.WriteString("null");                 return;               }               string dblString =                   CBORUtilities.DoubleToString(f);               writer.WriteString(                 CBORObject.TrimDotZero(dblString));               return;             }             writer.WriteString(flo.ToString());             return;           }         case CBORObject.CBORObjectTypeByteString:           {             var byteArray = (byte[])thisItem;             if (byteArray.Length == 0) {               writer.WriteString("\"\"");               return;             }             writer.WriteCodePoint((int)'\"');             if (obj.HasTag(22)) {               Base64.WriteBase64(                 writer'                 byteArray'                 0'                 byteArray.Length'                 false);             } else if (obj.HasTag(23)) {               // Write as base16               for (int i = 0; i < byteArray.Length; ++i) {                 writer.WriteCodePoint((int)Hex16[(byteArray[i] >> 4) & 15]);                 writer.WriteCodePoint((int)Hex16[byteArray[i] & 15]);               }             } else {               Base64.WriteBase64URL(                 writer'                 byteArray'                 0'                 byteArray.Length'                 false);             }             writer.WriteCodePoint((int)'\"');             break;           }           case CBORObject.CBORObjectTypeTextString: {             var thisString = (string)thisItem;             if (thisString.Length == 0) {               writer.WriteString("\"\"");               return;             }             writer.WriteCodePoint((int)'\"');             WriteJSONStringUnquoted(thisString' writer);             writer.WriteCodePoint((int)'\"');             break;           }           case CBORObject.CBORObjectTypeArray: {             var first = true;             writer.WriteCodePoint((int)'[');             foreach (CBORObject i in obj.AsList()) {               if (!first) {                 writer.WriteCodePoint((int)''');               }               WriteJSONToInternal(i' writer);               first = false;             }             writer.WriteCodePoint((int)']');             break;           }           case CBORObject.CBORObjectTypeExtendedRational: {             var dec = (ERational)thisItem;             EDecimal f = dec.ToEDecimalExactIfPossible(               EContext.Decimal128.WithUnlimitedExponents());             if (!f.IsFinite) {               writer.WriteString("null");             } else {               writer.WriteString(f.ToString());             }             break;           }           case CBORObject.CBORObjectTypeMap: {             var first = true;             var hasNonStringKeys = false;             IDictionary<CBORObject' CBORObject> objMap = obj.AsMap();             foreach (KeyValuePair<CBORObject' CBORObject> entry in objMap) {               CBORObject key = entry.Key;               if (key.ItemType != CBORObject.CBORObjectTypeTextString) {                 hasNonStringKeys = true;                 break;               }             }             if (!hasNonStringKeys) {               writer.WriteCodePoint((int)'{');               foreach (KeyValuePair<CBORObject' CBORObject> entry in objMap) {                 CBORObject key = entry.Key;                 CBORObject value = entry.Value;                 if (!first) {                   writer.WriteCodePoint((int)''');                 }                 writer.WriteCodePoint((int)'\"');                 WriteJSONStringUnquoted((string)key.ThisItem' writer);                 writer.WriteCodePoint((int)'\"');                 writer.WriteCodePoint((int)':');                 WriteJSONToInternal(value' writer);                 first = false;               }               writer.WriteCodePoint((int)'}');             } else {               // This map has non-string keys               IDictionary<string' CBORObject> stringMap = new                 Dictionary<string' CBORObject>();               // Copy to a map with String keys' since               // some keys could be duplicates               // when serialized to strings               foreach (KeyValuePair<CBORObject' CBORObject> entry in objMap) {                 CBORObject key = entry.Key;                 CBORObject value = entry.Value;            string str = (key.ItemType == CBORObject.CBORObjectTypeTextString) ?                   ((string)key.ThisItem) : key.ToJSONString();                 stringMap[str] = value;               }               first = true;               writer.WriteCodePoint((int)'{');               foreach (KeyValuePair<string' CBORObject> entry in stringMap) {                 string key = entry.Key;                 CBORObject value = entry.Value;                 if (!first) {                   writer.WriteCodePoint((int)''');                 }                 writer.WriteCodePoint((int)'\"');                 WriteJSONStringUnquoted((string)key' writer);                 writer.WriteCodePoint((int)'\"');                 writer.WriteCodePoint((int)':');                 WriteJSONToInternal(value' writer);                 first = false;               }               writer.WriteCodePoint((int)'}');             }             break;           }         default:           throw new InvalidOperationException("Unexpected item type");       }
Magic Number,PeterO.Cbor,CBORJson,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORJson.cs,WriteJSONToInternal,The following statement contains a magic number: switch (type) {           case CBORObject.CBORObjectTypeSimpleValue: {             if (obj.IsTrue) {               writer.WriteString("true");               return;             }             if (obj.IsFalse) {               writer.WriteString("false");               return;             }             writer.WriteString("null");             return;           }           case CBORObject.CBORObjectTypeSingle: {             var f = (float)thisItem;             if (Single.IsNegativeInfinity(f) ||                 Single.IsPositiveInfinity(f) || Single.IsNaN(f)) {               writer.WriteString("null");               return;             }             writer.WriteString(               CBORObject.TrimDotZero(                 CBORUtilities.SingleToString(f)));             return;           }           case CBORObject.CBORObjectTypeDouble: {             var f = (double)thisItem;             if (Double.IsNegativeInfinity(f) || Double.IsPositiveInfinity(f) ||                 Double.IsNaN(f)) {               writer.WriteString("null");               return;             }             string dblString = CBORUtilities.DoubleToString(f);             writer.WriteString(               CBORObject.TrimDotZero(dblString));             return;           }           case CBORObject.CBORObjectTypeInteger: {             var longItem = (long)thisItem;             writer.WriteString(CBORUtilities.LongToString(longItem));             return;           }           case CBORObject.CBORObjectTypeBigInteger: {             writer.WriteString(               CBORUtilities.BigIntToString((EInteger)thisItem));             return;           }           case CBORObject.CBORObjectTypeExtendedDecimal: {             var dec = (EDecimal)thisItem;             if (dec.IsInfinity() || dec.IsNaN()) {               writer.WriteString("null");             } else {               writer.WriteString(dec.ToString());             }             return;           }           case CBORObject.CBORObjectTypeExtendedFloat: {             var flo = (EFloat)thisItem;             if (flo.IsInfinity() || flo.IsNaN()) {               writer.WriteString("null");               return;             }             if (flo.IsFinite &&                 flo.Exponent.Abs().CompareTo((EInteger)2500) > 0) {               // Too inefficient to convert to a decimal number               // from a bigfloat with a very high exponent'               // so convert to double instead               double f = flo.ToDouble();               if (Double.IsNegativeInfinity(f) ||                   Double.IsPositiveInfinity(f) || Double.IsNaN(f)) {                 writer.WriteString("null");                 return;               }               string dblString =                   CBORUtilities.DoubleToString(f);               writer.WriteString(                 CBORObject.TrimDotZero(dblString));               return;             }             writer.WriteString(flo.ToString());             return;           }         case CBORObject.CBORObjectTypeByteString:           {             var byteArray = (byte[])thisItem;             if (byteArray.Length == 0) {               writer.WriteString("\"\"");               return;             }             writer.WriteCodePoint((int)'\"');             if (obj.HasTag(22)) {               Base64.WriteBase64(                 writer'                 byteArray'                 0'                 byteArray.Length'                 false);             } else if (obj.HasTag(23)) {               // Write as base16               for (int i = 0; i < byteArray.Length; ++i) {                 writer.WriteCodePoint((int)Hex16[(byteArray[i] >> 4) & 15]);                 writer.WriteCodePoint((int)Hex16[byteArray[i] & 15]);               }             } else {               Base64.WriteBase64URL(                 writer'                 byteArray'                 0'                 byteArray.Length'                 false);             }             writer.WriteCodePoint((int)'\"');             break;           }           case CBORObject.CBORObjectTypeTextString: {             var thisString = (string)thisItem;             if (thisString.Length == 0) {               writer.WriteString("\"\"");               return;             }             writer.WriteCodePoint((int)'\"');             WriteJSONStringUnquoted(thisString' writer);             writer.WriteCodePoint((int)'\"');             break;           }           case CBORObject.CBORObjectTypeArray: {             var first = true;             writer.WriteCodePoint((int)'[');             foreach (CBORObject i in obj.AsList()) {               if (!first) {                 writer.WriteCodePoint((int)''');               }               WriteJSONToInternal(i' writer);               first = false;             }             writer.WriteCodePoint((int)']');             break;           }           case CBORObject.CBORObjectTypeExtendedRational: {             var dec = (ERational)thisItem;             EDecimal f = dec.ToEDecimalExactIfPossible(               EContext.Decimal128.WithUnlimitedExponents());             if (!f.IsFinite) {               writer.WriteString("null");             } else {               writer.WriteString(f.ToString());             }             break;           }           case CBORObject.CBORObjectTypeMap: {             var first = true;             var hasNonStringKeys = false;             IDictionary<CBORObject' CBORObject> objMap = obj.AsMap();             foreach (KeyValuePair<CBORObject' CBORObject> entry in objMap) {               CBORObject key = entry.Key;               if (key.ItemType != CBORObject.CBORObjectTypeTextString) {                 hasNonStringKeys = true;                 break;               }             }             if (!hasNonStringKeys) {               writer.WriteCodePoint((int)'{');               foreach (KeyValuePair<CBORObject' CBORObject> entry in objMap) {                 CBORObject key = entry.Key;                 CBORObject value = entry.Value;                 if (!first) {                   writer.WriteCodePoint((int)''');                 }                 writer.WriteCodePoint((int)'\"');                 WriteJSONStringUnquoted((string)key.ThisItem' writer);                 writer.WriteCodePoint((int)'\"');                 writer.WriteCodePoint((int)':');                 WriteJSONToInternal(value' writer);                 first = false;               }               writer.WriteCodePoint((int)'}');             } else {               // This map has non-string keys               IDictionary<string' CBORObject> stringMap = new                 Dictionary<string' CBORObject>();               // Copy to a map with String keys' since               // some keys could be duplicates               // when serialized to strings               foreach (KeyValuePair<CBORObject' CBORObject> entry in objMap) {                 CBORObject key = entry.Key;                 CBORObject value = entry.Value;            string str = (key.ItemType == CBORObject.CBORObjectTypeTextString) ?                   ((string)key.ThisItem) : key.ToJSONString();                 stringMap[str] = value;               }               first = true;               writer.WriteCodePoint((int)'{');               foreach (KeyValuePair<string' CBORObject> entry in stringMap) {                 string key = entry.Key;                 CBORObject value = entry.Value;                 if (!first) {                   writer.WriteCodePoint((int)''');                 }                 writer.WriteCodePoint((int)'\"');                 WriteJSONStringUnquoted((string)key' writer);                 writer.WriteCodePoint((int)'\"');                 writer.WriteCodePoint((int)':');                 WriteJSONToInternal(value' writer);                 first = false;               }               writer.WriteCodePoint((int)'}');             }             break;           }         default:           throw new InvalidOperationException("Unexpected item type");       }
Magic Number,PeterO.Cbor,CBORJson,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORJson.cs,WriteJSONToInternal,The following statement contains a magic number: switch (type) {           case CBORObject.CBORObjectTypeSimpleValue: {             if (obj.IsTrue) {               writer.WriteString("true");               return;             }             if (obj.IsFalse) {               writer.WriteString("false");               return;             }             writer.WriteString("null");             return;           }           case CBORObject.CBORObjectTypeSingle: {             var f = (float)thisItem;             if (Single.IsNegativeInfinity(f) ||                 Single.IsPositiveInfinity(f) || Single.IsNaN(f)) {               writer.WriteString("null");               return;             }             writer.WriteString(               CBORObject.TrimDotZero(                 CBORUtilities.SingleToString(f)));             return;           }           case CBORObject.CBORObjectTypeDouble: {             var f = (double)thisItem;             if (Double.IsNegativeInfinity(f) || Double.IsPositiveInfinity(f) ||                 Double.IsNaN(f)) {               writer.WriteString("null");               return;             }             string dblString = CBORUtilities.DoubleToString(f);             writer.WriteString(               CBORObject.TrimDotZero(dblString));             return;           }           case CBORObject.CBORObjectTypeInteger: {             var longItem = (long)thisItem;             writer.WriteString(CBORUtilities.LongToString(longItem));             return;           }           case CBORObject.CBORObjectTypeBigInteger: {             writer.WriteString(               CBORUtilities.BigIntToString((EInteger)thisItem));             return;           }           case CBORObject.CBORObjectTypeExtendedDecimal: {             var dec = (EDecimal)thisItem;             if (dec.IsInfinity() || dec.IsNaN()) {               writer.WriteString("null");             } else {               writer.WriteString(dec.ToString());             }             return;           }           case CBORObject.CBORObjectTypeExtendedFloat: {             var flo = (EFloat)thisItem;             if (flo.IsInfinity() || flo.IsNaN()) {               writer.WriteString("null");               return;             }             if (flo.IsFinite &&                 flo.Exponent.Abs().CompareTo((EInteger)2500) > 0) {               // Too inefficient to convert to a decimal number               // from a bigfloat with a very high exponent'               // so convert to double instead               double f = flo.ToDouble();               if (Double.IsNegativeInfinity(f) ||                   Double.IsPositiveInfinity(f) || Double.IsNaN(f)) {                 writer.WriteString("null");                 return;               }               string dblString =                   CBORUtilities.DoubleToString(f);               writer.WriteString(                 CBORObject.TrimDotZero(dblString));               return;             }             writer.WriteString(flo.ToString());             return;           }         case CBORObject.CBORObjectTypeByteString:           {             var byteArray = (byte[])thisItem;             if (byteArray.Length == 0) {               writer.WriteString("\"\"");               return;             }             writer.WriteCodePoint((int)'\"');             if (obj.HasTag(22)) {               Base64.WriteBase64(                 writer'                 byteArray'                 0'                 byteArray.Length'                 false);             } else if (obj.HasTag(23)) {               // Write as base16               for (int i = 0; i < byteArray.Length; ++i) {                 writer.WriteCodePoint((int)Hex16[(byteArray[i] >> 4) & 15]);                 writer.WriteCodePoint((int)Hex16[byteArray[i] & 15]);               }             } else {               Base64.WriteBase64URL(                 writer'                 byteArray'                 0'                 byteArray.Length'                 false);             }             writer.WriteCodePoint((int)'\"');             break;           }           case CBORObject.CBORObjectTypeTextString: {             var thisString = (string)thisItem;             if (thisString.Length == 0) {               writer.WriteString("\"\"");               return;             }             writer.WriteCodePoint((int)'\"');             WriteJSONStringUnquoted(thisString' writer);             writer.WriteCodePoint((int)'\"');             break;           }           case CBORObject.CBORObjectTypeArray: {             var first = true;             writer.WriteCodePoint((int)'[');             foreach (CBORObject i in obj.AsList()) {               if (!first) {                 writer.WriteCodePoint((int)''');               }               WriteJSONToInternal(i' writer);               first = false;             }             writer.WriteCodePoint((int)']');             break;           }           case CBORObject.CBORObjectTypeExtendedRational: {             var dec = (ERational)thisItem;             EDecimal f = dec.ToEDecimalExactIfPossible(               EContext.Decimal128.WithUnlimitedExponents());             if (!f.IsFinite) {               writer.WriteString("null");             } else {               writer.WriteString(f.ToString());             }             break;           }           case CBORObject.CBORObjectTypeMap: {             var first = true;             var hasNonStringKeys = false;             IDictionary<CBORObject' CBORObject> objMap = obj.AsMap();             foreach (KeyValuePair<CBORObject' CBORObject> entry in objMap) {               CBORObject key = entry.Key;               if (key.ItemType != CBORObject.CBORObjectTypeTextString) {                 hasNonStringKeys = true;                 break;               }             }             if (!hasNonStringKeys) {               writer.WriteCodePoint((int)'{');               foreach (KeyValuePair<CBORObject' CBORObject> entry in objMap) {                 CBORObject key = entry.Key;                 CBORObject value = entry.Value;                 if (!first) {                   writer.WriteCodePoint((int)''');                 }                 writer.WriteCodePoint((int)'\"');                 WriteJSONStringUnquoted((string)key.ThisItem' writer);                 writer.WriteCodePoint((int)'\"');                 writer.WriteCodePoint((int)':');                 WriteJSONToInternal(value' writer);                 first = false;               }               writer.WriteCodePoint((int)'}');             } else {               // This map has non-string keys               IDictionary<string' CBORObject> stringMap = new                 Dictionary<string' CBORObject>();               // Copy to a map with String keys' since               // some keys could be duplicates               // when serialized to strings               foreach (KeyValuePair<CBORObject' CBORObject> entry in objMap) {                 CBORObject key = entry.Key;                 CBORObject value = entry.Value;            string str = (key.ItemType == CBORObject.CBORObjectTypeTextString) ?                   ((string)key.ThisItem) : key.ToJSONString();                 stringMap[str] = value;               }               first = true;               writer.WriteCodePoint((int)'{');               foreach (KeyValuePair<string' CBORObject> entry in stringMap) {                 string key = entry.Key;                 CBORObject value = entry.Value;                 if (!first) {                   writer.WriteCodePoint((int)''');                 }                 writer.WriteCodePoint((int)'\"');                 WriteJSONStringUnquoted((string)key' writer);                 writer.WriteCodePoint((int)'\"');                 writer.WriteCodePoint((int)':');                 WriteJSONToInternal(value' writer);                 first = false;               }               writer.WriteCodePoint((int)'}');             }             break;           }         default:           throw new InvalidOperationException("Unexpected item type");       }
Magic Number,PeterO.Cbor,CBORJson,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORJson.cs,WriteJSONToInternal,The following statement contains a magic number: switch (type) {           case CBORObject.CBORObjectTypeSimpleValue: {             if (obj.IsTrue) {               writer.WriteString("true");               return;             }             if (obj.IsFalse) {               writer.WriteString("false");               return;             }             writer.WriteString("null");             return;           }           case CBORObject.CBORObjectTypeSingle: {             var f = (float)thisItem;             if (Single.IsNegativeInfinity(f) ||                 Single.IsPositiveInfinity(f) || Single.IsNaN(f)) {               writer.WriteString("null");               return;             }             writer.WriteString(               CBORObject.TrimDotZero(                 CBORUtilities.SingleToString(f)));             return;           }           case CBORObject.CBORObjectTypeDouble: {             var f = (double)thisItem;             if (Double.IsNegativeInfinity(f) || Double.IsPositiveInfinity(f) ||                 Double.IsNaN(f)) {               writer.WriteString("null");               return;             }             string dblString = CBORUtilities.DoubleToString(f);             writer.WriteString(               CBORObject.TrimDotZero(dblString));             return;           }           case CBORObject.CBORObjectTypeInteger: {             var longItem = (long)thisItem;             writer.WriteString(CBORUtilities.LongToString(longItem));             return;           }           case CBORObject.CBORObjectTypeBigInteger: {             writer.WriteString(               CBORUtilities.BigIntToString((EInteger)thisItem));             return;           }           case CBORObject.CBORObjectTypeExtendedDecimal: {             var dec = (EDecimal)thisItem;             if (dec.IsInfinity() || dec.IsNaN()) {               writer.WriteString("null");             } else {               writer.WriteString(dec.ToString());             }             return;           }           case CBORObject.CBORObjectTypeExtendedFloat: {             var flo = (EFloat)thisItem;             if (flo.IsInfinity() || flo.IsNaN()) {               writer.WriteString("null");               return;             }             if (flo.IsFinite &&                 flo.Exponent.Abs().CompareTo((EInteger)2500) > 0) {               // Too inefficient to convert to a decimal number               // from a bigfloat with a very high exponent'               // so convert to double instead               double f = flo.ToDouble();               if (Double.IsNegativeInfinity(f) ||                   Double.IsPositiveInfinity(f) || Double.IsNaN(f)) {                 writer.WriteString("null");                 return;               }               string dblString =                   CBORUtilities.DoubleToString(f);               writer.WriteString(                 CBORObject.TrimDotZero(dblString));               return;             }             writer.WriteString(flo.ToString());             return;           }         case CBORObject.CBORObjectTypeByteString:           {             var byteArray = (byte[])thisItem;             if (byteArray.Length == 0) {               writer.WriteString("\"\"");               return;             }             writer.WriteCodePoint((int)'\"');             if (obj.HasTag(22)) {               Base64.WriteBase64(                 writer'                 byteArray'                 0'                 byteArray.Length'                 false);             } else if (obj.HasTag(23)) {               // Write as base16               for (int i = 0; i < byteArray.Length; ++i) {                 writer.WriteCodePoint((int)Hex16[(byteArray[i] >> 4) & 15]);                 writer.WriteCodePoint((int)Hex16[byteArray[i] & 15]);               }             } else {               Base64.WriteBase64URL(                 writer'                 byteArray'                 0'                 byteArray.Length'                 false);             }             writer.WriteCodePoint((int)'\"');             break;           }           case CBORObject.CBORObjectTypeTextString: {             var thisString = (string)thisItem;             if (thisString.Length == 0) {               writer.WriteString("\"\"");               return;             }             writer.WriteCodePoint((int)'\"');             WriteJSONStringUnquoted(thisString' writer);             writer.WriteCodePoint((int)'\"');             break;           }           case CBORObject.CBORObjectTypeArray: {             var first = true;             writer.WriteCodePoint((int)'[');             foreach (CBORObject i in obj.AsList()) {               if (!first) {                 writer.WriteCodePoint((int)''');               }               WriteJSONToInternal(i' writer);               first = false;             }             writer.WriteCodePoint((int)']');             break;           }           case CBORObject.CBORObjectTypeExtendedRational: {             var dec = (ERational)thisItem;             EDecimal f = dec.ToEDecimalExactIfPossible(               EContext.Decimal128.WithUnlimitedExponents());             if (!f.IsFinite) {               writer.WriteString("null");             } else {               writer.WriteString(f.ToString());             }             break;           }           case CBORObject.CBORObjectTypeMap: {             var first = true;             var hasNonStringKeys = false;             IDictionary<CBORObject' CBORObject> objMap = obj.AsMap();             foreach (KeyValuePair<CBORObject' CBORObject> entry in objMap) {               CBORObject key = entry.Key;               if (key.ItemType != CBORObject.CBORObjectTypeTextString) {                 hasNonStringKeys = true;                 break;               }             }             if (!hasNonStringKeys) {               writer.WriteCodePoint((int)'{');               foreach (KeyValuePair<CBORObject' CBORObject> entry in objMap) {                 CBORObject key = entry.Key;                 CBORObject value = entry.Value;                 if (!first) {                   writer.WriteCodePoint((int)''');                 }                 writer.WriteCodePoint((int)'\"');                 WriteJSONStringUnquoted((string)key.ThisItem' writer);                 writer.WriteCodePoint((int)'\"');                 writer.WriteCodePoint((int)':');                 WriteJSONToInternal(value' writer);                 first = false;               }               writer.WriteCodePoint((int)'}');             } else {               // This map has non-string keys               IDictionary<string' CBORObject> stringMap = new                 Dictionary<string' CBORObject>();               // Copy to a map with String keys' since               // some keys could be duplicates               // when serialized to strings               foreach (KeyValuePair<CBORObject' CBORObject> entry in objMap) {                 CBORObject key = entry.Key;                 CBORObject value = entry.Value;            string str = (key.ItemType == CBORObject.CBORObjectTypeTextString) ?                   ((string)key.ThisItem) : key.ToJSONString();                 stringMap[str] = value;               }               first = true;               writer.WriteCodePoint((int)'{');               foreach (KeyValuePair<string' CBORObject> entry in stringMap) {                 string key = entry.Key;                 CBORObject value = entry.Value;                 if (!first) {                   writer.WriteCodePoint((int)''');                 }                 writer.WriteCodePoint((int)'\"');                 WriteJSONStringUnquoted((string)key' writer);                 writer.WriteCodePoint((int)'\"');                 writer.WriteCodePoint((int)':');                 WriteJSONToInternal(value' writer);                 first = false;               }               writer.WriteCodePoint((int)'}');             }             break;           }         default:           throw new InvalidOperationException("Unexpected item type");       }
Magic Number,PeterO.Cbor,CBORJson,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORJson.cs,WriteJSONToInternal,The following statement contains a magic number: switch (type) {           case CBORObject.CBORObjectTypeSimpleValue: {             if (obj.IsTrue) {               writer.WriteString("true");               return;             }             if (obj.IsFalse) {               writer.WriteString("false");               return;             }             writer.WriteString("null");             return;           }           case CBORObject.CBORObjectTypeSingle: {             var f = (float)thisItem;             if (Single.IsNegativeInfinity(f) ||                 Single.IsPositiveInfinity(f) || Single.IsNaN(f)) {               writer.WriteString("null");               return;             }             writer.WriteString(               CBORObject.TrimDotZero(                 CBORUtilities.SingleToString(f)));             return;           }           case CBORObject.CBORObjectTypeDouble: {             var f = (double)thisItem;             if (Double.IsNegativeInfinity(f) || Double.IsPositiveInfinity(f) ||                 Double.IsNaN(f)) {               writer.WriteString("null");               return;             }             string dblString = CBORUtilities.DoubleToString(f);             writer.WriteString(               CBORObject.TrimDotZero(dblString));             return;           }           case CBORObject.CBORObjectTypeInteger: {             var longItem = (long)thisItem;             writer.WriteString(CBORUtilities.LongToString(longItem));             return;           }           case CBORObject.CBORObjectTypeBigInteger: {             writer.WriteString(               CBORUtilities.BigIntToString((EInteger)thisItem));             return;           }           case CBORObject.CBORObjectTypeExtendedDecimal: {             var dec = (EDecimal)thisItem;             if (dec.IsInfinity() || dec.IsNaN()) {               writer.WriteString("null");             } else {               writer.WriteString(dec.ToString());             }             return;           }           case CBORObject.CBORObjectTypeExtendedFloat: {             var flo = (EFloat)thisItem;             if (flo.IsInfinity() || flo.IsNaN()) {               writer.WriteString("null");               return;             }             if (flo.IsFinite &&                 flo.Exponent.Abs().CompareTo((EInteger)2500) > 0) {               // Too inefficient to convert to a decimal number               // from a bigfloat with a very high exponent'               // so convert to double instead               double f = flo.ToDouble();               if (Double.IsNegativeInfinity(f) ||                   Double.IsPositiveInfinity(f) || Double.IsNaN(f)) {                 writer.WriteString("null");                 return;               }               string dblString =                   CBORUtilities.DoubleToString(f);               writer.WriteString(                 CBORObject.TrimDotZero(dblString));               return;             }             writer.WriteString(flo.ToString());             return;           }         case CBORObject.CBORObjectTypeByteString:           {             var byteArray = (byte[])thisItem;             if (byteArray.Length == 0) {               writer.WriteString("\"\"");               return;             }             writer.WriteCodePoint((int)'\"');             if (obj.HasTag(22)) {               Base64.WriteBase64(                 writer'                 byteArray'                 0'                 byteArray.Length'                 false);             } else if (obj.HasTag(23)) {               // Write as base16               for (int i = 0; i < byteArray.Length; ++i) {                 writer.WriteCodePoint((int)Hex16[(byteArray[i] >> 4) & 15]);                 writer.WriteCodePoint((int)Hex16[byteArray[i] & 15]);               }             } else {               Base64.WriteBase64URL(                 writer'                 byteArray'                 0'                 byteArray.Length'                 false);             }             writer.WriteCodePoint((int)'\"');             break;           }           case CBORObject.CBORObjectTypeTextString: {             var thisString = (string)thisItem;             if (thisString.Length == 0) {               writer.WriteString("\"\"");               return;             }             writer.WriteCodePoint((int)'\"');             WriteJSONStringUnquoted(thisString' writer);             writer.WriteCodePoint((int)'\"');             break;           }           case CBORObject.CBORObjectTypeArray: {             var first = true;             writer.WriteCodePoint((int)'[');             foreach (CBORObject i in obj.AsList()) {               if (!first) {                 writer.WriteCodePoint((int)''');               }               WriteJSONToInternal(i' writer);               first = false;             }             writer.WriteCodePoint((int)']');             break;           }           case CBORObject.CBORObjectTypeExtendedRational: {             var dec = (ERational)thisItem;             EDecimal f = dec.ToEDecimalExactIfPossible(               EContext.Decimal128.WithUnlimitedExponents());             if (!f.IsFinite) {               writer.WriteString("null");             } else {               writer.WriteString(f.ToString());             }             break;           }           case CBORObject.CBORObjectTypeMap: {             var first = true;             var hasNonStringKeys = false;             IDictionary<CBORObject' CBORObject> objMap = obj.AsMap();             foreach (KeyValuePair<CBORObject' CBORObject> entry in objMap) {               CBORObject key = entry.Key;               if (key.ItemType != CBORObject.CBORObjectTypeTextString) {                 hasNonStringKeys = true;                 break;               }             }             if (!hasNonStringKeys) {               writer.WriteCodePoint((int)'{');               foreach (KeyValuePair<CBORObject' CBORObject> entry in objMap) {                 CBORObject key = entry.Key;                 CBORObject value = entry.Value;                 if (!first) {                   writer.WriteCodePoint((int)''');                 }                 writer.WriteCodePoint((int)'\"');                 WriteJSONStringUnquoted((string)key.ThisItem' writer);                 writer.WriteCodePoint((int)'\"');                 writer.WriteCodePoint((int)':');                 WriteJSONToInternal(value' writer);                 first = false;               }               writer.WriteCodePoint((int)'}');             } else {               // This map has non-string keys               IDictionary<string' CBORObject> stringMap = new                 Dictionary<string' CBORObject>();               // Copy to a map with String keys' since               // some keys could be duplicates               // when serialized to strings               foreach (KeyValuePair<CBORObject' CBORObject> entry in objMap) {                 CBORObject key = entry.Key;                 CBORObject value = entry.Value;            string str = (key.ItemType == CBORObject.CBORObjectTypeTextString) ?                   ((string)key.ThisItem) : key.ToJSONString();                 stringMap[str] = value;               }               first = true;               writer.WriteCodePoint((int)'{');               foreach (KeyValuePair<string' CBORObject> entry in stringMap) {                 string key = entry.Key;                 CBORObject value = entry.Value;                 if (!first) {                   writer.WriteCodePoint((int)''');                 }                 writer.WriteCodePoint((int)'\"');                 WriteJSONStringUnquoted((string)key' writer);                 writer.WriteCodePoint((int)'\"');                 writer.WriteCodePoint((int)':');                 WriteJSONToInternal(value' writer);                 first = false;               }               writer.WriteCodePoint((int)'}');             }             break;           }         default:           throw new InvalidOperationException("Unexpected item type");       }
Magic Number,PeterO.Cbor,CBORObject,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORObject.cs,AddTagHandler,The following statement contains a magic number: if (bigintTag.GetSignedBitLength() > 64) {         throw new ArgumentException("bigintTag.bitLength (" +                     (long)bigintTag.GetSignedBitLength() + ") is more than " +                     "64");       }
Magic Number,PeterO.Cbor,CBORObject,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORObject.cs,FromObject,The following statement contains a magic number: return (value >= 0 && value < 24) ? valueFixedObjects[value] :         FromObject((long)value);
Magic Number,PeterO.Cbor,CBORObject,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORObject.cs,FromObject,The following statement contains a magic number: return (value >= 0 && value < 24) ? valueFixedObjects[value] :         FromObject((long)value);
Magic Number,PeterO.Cbor,CBORObject,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORObject.cs,FromObjectAndTag,The following statement contains a magic number: if (bigintTag.GetSignedBitLength() <= 16) {         // Low-numbered' commonly used tags         return FromObjectAndTag(c' bigintTag.ToInt32Checked());       } else {         var tagLow = 0;         var tagHigh = 0;         byte[] bytes = bigintTag.ToBytes(true);         for (var i = 0; i < Math.Min(4' bytes.Length); ++i) {           int b = ((int)bytes[i]) & 0xff;           tagLow = unchecked(tagLow | (((int)b) << (i * 8)));         }         for (int i = 4; i < Math.Min(8' bytes.Length); ++i) {           int b = ((int)bytes[i]) & 0xff;           tagHigh = unchecked(tagHigh | (((int)b) << (i * 8)));         }         var c2 = new CBORObject(c' tagLow' tagHigh);         ICBORTag tagconv = FindTagConverter(bigintTag);         if (tagconv != null) {           c2 = tagconv.ValidateObject(c2);         }         return c2;       }
Magic Number,PeterO.Cbor,CBORObject,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORObject.cs,FromObjectAndTag,The following statement contains a magic number: if (bigintTag.GetSignedBitLength() <= 16) {         // Low-numbered' commonly used tags         return FromObjectAndTag(c' bigintTag.ToInt32Checked());       } else {         var tagLow = 0;         var tagHigh = 0;         byte[] bytes = bigintTag.ToBytes(true);         for (var i = 0; i < Math.Min(4' bytes.Length); ++i) {           int b = ((int)bytes[i]) & 0xff;           tagLow = unchecked(tagLow | (((int)b) << (i * 8)));         }         for (int i = 4; i < Math.Min(8' bytes.Length); ++i) {           int b = ((int)bytes[i]) & 0xff;           tagHigh = unchecked(tagHigh | (((int)b) << (i * 8)));         }         var c2 = new CBORObject(c' tagLow' tagHigh);         ICBORTag tagconv = FindTagConverter(bigintTag);         if (tagconv != null) {           c2 = tagconv.ValidateObject(c2);         }         return c2;       }
Magic Number,PeterO.Cbor,CBORObject,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORObject.cs,FromObjectAndTag,The following statement contains a magic number: if (bigintTag.GetSignedBitLength() <= 16) {         // Low-numbered' commonly used tags         return FromObjectAndTag(c' bigintTag.ToInt32Checked());       } else {         var tagLow = 0;         var tagHigh = 0;         byte[] bytes = bigintTag.ToBytes(true);         for (var i = 0; i < Math.Min(4' bytes.Length); ++i) {           int b = ((int)bytes[i]) & 0xff;           tagLow = unchecked(tagLow | (((int)b) << (i * 8)));         }         for (int i = 4; i < Math.Min(8' bytes.Length); ++i) {           int b = ((int)bytes[i]) & 0xff;           tagHigh = unchecked(tagHigh | (((int)b) << (i * 8)));         }         var c2 = new CBORObject(c' tagLow' tagHigh);         ICBORTag tagconv = FindTagConverter(bigintTag);         if (tagconv != null) {           c2 = tagconv.ValidateObject(c2);         }         return c2;       }
Magic Number,PeterO.Cbor,CBORObject,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORObject.cs,FromObjectAndTag,The following statement contains a magic number: if (bigintTag.GetSignedBitLength() <= 16) {         // Low-numbered' commonly used tags         return FromObjectAndTag(c' bigintTag.ToInt32Checked());       } else {         var tagLow = 0;         var tagHigh = 0;         byte[] bytes = bigintTag.ToBytes(true);         for (var i = 0; i < Math.Min(4' bytes.Length); ++i) {           int b = ((int)bytes[i]) & 0xff;           tagLow = unchecked(tagLow | (((int)b) << (i * 8)));         }         for (int i = 4; i < Math.Min(8' bytes.Length); ++i) {           int b = ((int)bytes[i]) & 0xff;           tagHigh = unchecked(tagHigh | (((int)b) << (i * 8)));         }         var c2 = new CBORObject(c' tagLow' tagHigh);         ICBORTag tagconv = FindTagConverter(bigintTag);         if (tagconv != null) {           c2 = tagconv.ValidateObject(c2);         }         return c2;       }
Magic Number,PeterO.Cbor,CBORObject,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORObject.cs,FromObjectAndTag,The following statement contains a magic number: if (bigintTag.GetSignedBitLength() <= 16) {         // Low-numbered' commonly used tags         return FromObjectAndTag(c' bigintTag.ToInt32Checked());       } else {         var tagLow = 0;         var tagHigh = 0;         byte[] bytes = bigintTag.ToBytes(true);         for (var i = 0; i < Math.Min(4' bytes.Length); ++i) {           int b = ((int)bytes[i]) & 0xff;           tagLow = unchecked(tagLow | (((int)b) << (i * 8)));         }         for (int i = 4; i < Math.Min(8' bytes.Length); ++i) {           int b = ((int)bytes[i]) & 0xff;           tagHigh = unchecked(tagHigh | (((int)b) << (i * 8)));         }         var c2 = new CBORObject(c' tagLow' tagHigh);         ICBORTag tagconv = FindTagConverter(bigintTag);         if (tagconv != null) {           c2 = tagconv.ValidateObject(c2);         }         return c2;       }
Magic Number,PeterO.Cbor,CBORObject,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORObject.cs,FromObjectAndTag,The following statement contains a magic number: if (bigintTag.GetSignedBitLength() <= 16) {         // Low-numbered' commonly used tags         return FromObjectAndTag(c' bigintTag.ToInt32Checked());       } else {         var tagLow = 0;         var tagHigh = 0;         byte[] bytes = bigintTag.ToBytes(true);         for (var i = 0; i < Math.Min(4' bytes.Length); ++i) {           int b = ((int)bytes[i]) & 0xff;           tagLow = unchecked(tagLow | (((int)b) << (i * 8)));         }         for (int i = 4; i < Math.Min(8' bytes.Length); ++i) {           int b = ((int)bytes[i]) & 0xff;           tagHigh = unchecked(tagHigh | (((int)b) << (i * 8)));         }         var c2 = new CBORObject(c' tagLow' tagHigh);         ICBORTag tagconv = FindTagConverter(bigintTag);         if (tagconv != null) {           c2 = tagconv.ValidateObject(c2);         }         return c2;       }
Magic Number,PeterO.Cbor,CBORObject,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORObject.cs,FromSimpleValue,The following statement contains a magic number: if (simpleValue > 255) {         throw new ArgumentException("simpleValue (" + simpleValue +                     ") is more than " + "255");       }
Magic Number,PeterO.Cbor,CBORObject,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORObject.cs,FromSimpleValue,The following statement contains a magic number: if (simpleValue >= 24 && simpleValue < 32) {         throw new ArgumentException("Simple value is from 24 to 31: " +                     simpleValue);       }
Magic Number,PeterO.Cbor,CBORObject,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORObject.cs,FromSimpleValue,The following statement contains a magic number: if (simpleValue >= 24 && simpleValue < 32) {         throw new ArgumentException("Simple value is from 24 to 31: " +                     simpleValue);       }
Magic Number,PeterO.Cbor,CBORObject,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORObject.cs,FromSimpleValue,The following statement contains a magic number: if (simpleValue < 32) {         return valueFixedObjects[0xe0 + simpleValue];       }
Magic Number,PeterO.Cbor,CBORObject,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORObject.cs,ReadJSON,The following statement contains a magic number: var reader = new CharacterInputWithCount(         new CharacterReader(stream' 2' true));
Magic Number,PeterO.Cbor,CBORObject,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORObject.cs,Write,The following statement contains a magic number: if (str == null) {         stream.WriteByte(0xf6);  // Write null instead of string       } else {         CBOREncodeOptions noIndef =           options.And(CBOREncodeOptions.NoIndefLengthStrings);         if (noIndef.Value != 0) {           // NOTE: Length of a String object won't be higher than the maximum           // allowed for definite-length strings           long codePointLength = DataUtilities.GetUtf8Length(str' true);           WritePositiveInt64(3' codePointLength' stream);           DataUtilities.WriteUtf8(str' stream' true);         } else {           WriteStreamedString(str' stream);         }       }
Magic Number,PeterO.Cbor,CBORObject,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORObject.cs,Write,The following statement contains a magic number: if (bigint.CompareTo(Int64MaxValue) <= 0) {         // If the big integer is representable as a long and in         // major type 0 or 1' write that major type         // instead of as a bignum         var ui = (long)(EInteger)bigint;         WritePositiveInt64(datatype' ui' stream);       } else {         // Get a byte array of the big integer's value'         // since shifting and doing AND operations is         // slow with large BigIntegers         byte[] bytes = bigint.ToBytes(true);         int byteCount = bytes.Length;         while (byteCount > 0 && bytes[byteCount - 1] == 0) {           // Ignore trailing zero bytes           --byteCount;         }         if (byteCount != 0) {           int half = byteCount >> 1;           int right = byteCount - 1;           for (var i = 0; i < half; ++i' --right) {             byte value = bytes[i];             bytes[i] = bytes[right];             bytes[right] = value;           }         }         switch (byteCount) {           case 0:             stream.WriteByte((byte)(datatype << 5));             return;           case 1:             WritePositiveInt(datatype' ((int)bytes[0]) & 0xff' stream);             break;           case 2:             stream.WriteByte((byte)((datatype << 5) | 25));             stream.Write(bytes' 0' byteCount);             break;           case 3:             stream.WriteByte((byte)((datatype << 5) | 26));             stream.WriteByte((byte)0);             stream.Write(bytes' 0' byteCount);             break;           case 4:             stream.WriteByte((byte)((datatype << 5) | 26));             stream.Write(bytes' 0' byteCount);             break;           case 5:             stream.WriteByte((byte)((datatype << 5) | 27));             stream.WriteByte((byte)0);             stream.WriteByte((byte)0);             stream.WriteByte((byte)0);             stream.Write(bytes' 0' byteCount);             break;           case 6:             stream.WriteByte((byte)((datatype << 5) | 27));             stream.WriteByte((byte)0);             stream.WriteByte((byte)0);             stream.Write(bytes' 0' byteCount);             break;           case 7:             stream.WriteByte((byte)((datatype << 5) | 27));             stream.WriteByte((byte)0);             stream.Write(bytes' 0' byteCount);             break;           case 8:             stream.WriteByte((byte)((datatype << 5) | 27));             stream.Write(bytes' 0' byteCount);             break;           default: stream.WriteByte((datatype == 0) ? (byte)0xc2 : (byte)0xc3);             WritePositiveInt(2' byteCount' stream);             stream.Write(bytes' 0' byteCount);             break;         }       }
Magic Number,PeterO.Cbor,CBORObject,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORObject.cs,Write,The following statement contains a magic number: if (bigint.CompareTo(Int64MaxValue) <= 0) {         // If the big integer is representable as a long and in         // major type 0 or 1' write that major type         // instead of as a bignum         var ui = (long)(EInteger)bigint;         WritePositiveInt64(datatype' ui' stream);       } else {         // Get a byte array of the big integer's value'         // since shifting and doing AND operations is         // slow with large BigIntegers         byte[] bytes = bigint.ToBytes(true);         int byteCount = bytes.Length;         while (byteCount > 0 && bytes[byteCount - 1] == 0) {           // Ignore trailing zero bytes           --byteCount;         }         if (byteCount != 0) {           int half = byteCount >> 1;           int right = byteCount - 1;           for (var i = 0; i < half; ++i' --right) {             byte value = bytes[i];             bytes[i] = bytes[right];             bytes[right] = value;           }         }         switch (byteCount) {           case 0:             stream.WriteByte((byte)(datatype << 5));             return;           case 1:             WritePositiveInt(datatype' ((int)bytes[0]) & 0xff' stream);             break;           case 2:             stream.WriteByte((byte)((datatype << 5) | 25));             stream.Write(bytes' 0' byteCount);             break;           case 3:             stream.WriteByte((byte)((datatype << 5) | 26));             stream.WriteByte((byte)0);             stream.Write(bytes' 0' byteCount);             break;           case 4:             stream.WriteByte((byte)((datatype << 5) | 26));             stream.Write(bytes' 0' byteCount);             break;           case 5:             stream.WriteByte((byte)((datatype << 5) | 27));             stream.WriteByte((byte)0);             stream.WriteByte((byte)0);             stream.WriteByte((byte)0);             stream.Write(bytes' 0' byteCount);             break;           case 6:             stream.WriteByte((byte)((datatype << 5) | 27));             stream.WriteByte((byte)0);             stream.WriteByte((byte)0);             stream.Write(bytes' 0' byteCount);             break;           case 7:             stream.WriteByte((byte)((datatype << 5) | 27));             stream.WriteByte((byte)0);             stream.Write(bytes' 0' byteCount);             break;           case 8:             stream.WriteByte((byte)((datatype << 5) | 27));             stream.Write(bytes' 0' byteCount);             break;           default: stream.WriteByte((datatype == 0) ? (byte)0xc2 : (byte)0xc3);             WritePositiveInt(2' byteCount' stream);             stream.Write(bytes' 0' byteCount);             break;         }       }
Magic Number,PeterO.Cbor,CBORObject,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORObject.cs,Write,The following statement contains a magic number: if (bigint.CompareTo(Int64MaxValue) <= 0) {         // If the big integer is representable as a long and in         // major type 0 or 1' write that major type         // instead of as a bignum         var ui = (long)(EInteger)bigint;         WritePositiveInt64(datatype' ui' stream);       } else {         // Get a byte array of the big integer's value'         // since shifting and doing AND operations is         // slow with large BigIntegers         byte[] bytes = bigint.ToBytes(true);         int byteCount = bytes.Length;         while (byteCount > 0 && bytes[byteCount - 1] == 0) {           // Ignore trailing zero bytes           --byteCount;         }         if (byteCount != 0) {           int half = byteCount >> 1;           int right = byteCount - 1;           for (var i = 0; i < half; ++i' --right) {             byte value = bytes[i];             bytes[i] = bytes[right];             bytes[right] = value;           }         }         switch (byteCount) {           case 0:             stream.WriteByte((byte)(datatype << 5));             return;           case 1:             WritePositiveInt(datatype' ((int)bytes[0]) & 0xff' stream);             break;           case 2:             stream.WriteByte((byte)((datatype << 5) | 25));             stream.Write(bytes' 0' byteCount);             break;           case 3:             stream.WriteByte((byte)((datatype << 5) | 26));             stream.WriteByte((byte)0);             stream.Write(bytes' 0' byteCount);             break;           case 4:             stream.WriteByte((byte)((datatype << 5) | 26));             stream.Write(bytes' 0' byteCount);             break;           case 5:             stream.WriteByte((byte)((datatype << 5) | 27));             stream.WriteByte((byte)0);             stream.WriteByte((byte)0);             stream.WriteByte((byte)0);             stream.Write(bytes' 0' byteCount);             break;           case 6:             stream.WriteByte((byte)((datatype << 5) | 27));             stream.WriteByte((byte)0);             stream.WriteByte((byte)0);             stream.Write(bytes' 0' byteCount);             break;           case 7:             stream.WriteByte((byte)((datatype << 5) | 27));             stream.WriteByte((byte)0);             stream.Write(bytes' 0' byteCount);             break;           case 8:             stream.WriteByte((byte)((datatype << 5) | 27));             stream.Write(bytes' 0' byteCount);             break;           default: stream.WriteByte((datatype == 0) ? (byte)0xc2 : (byte)0xc3);             WritePositiveInt(2' byteCount' stream);             stream.Write(bytes' 0' byteCount);             break;         }       }
Magic Number,PeterO.Cbor,CBORObject,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORObject.cs,Write,The following statement contains a magic number: if (bigint.CompareTo(Int64MaxValue) <= 0) {         // If the big integer is representable as a long and in         // major type 0 or 1' write that major type         // instead of as a bignum         var ui = (long)(EInteger)bigint;         WritePositiveInt64(datatype' ui' stream);       } else {         // Get a byte array of the big integer's value'         // since shifting and doing AND operations is         // slow with large BigIntegers         byte[] bytes = bigint.ToBytes(true);         int byteCount = bytes.Length;         while (byteCount > 0 && bytes[byteCount - 1] == 0) {           // Ignore trailing zero bytes           --byteCount;         }         if (byteCount != 0) {           int half = byteCount >> 1;           int right = byteCount - 1;           for (var i = 0; i < half; ++i' --right) {             byte value = bytes[i];             bytes[i] = bytes[right];             bytes[right] = value;           }         }         switch (byteCount) {           case 0:             stream.WriteByte((byte)(datatype << 5));             return;           case 1:             WritePositiveInt(datatype' ((int)bytes[0]) & 0xff' stream);             break;           case 2:             stream.WriteByte((byte)((datatype << 5) | 25));             stream.Write(bytes' 0' byteCount);             break;           case 3:             stream.WriteByte((byte)((datatype << 5) | 26));             stream.WriteByte((byte)0);             stream.Write(bytes' 0' byteCount);             break;           case 4:             stream.WriteByte((byte)((datatype << 5) | 26));             stream.Write(bytes' 0' byteCount);             break;           case 5:             stream.WriteByte((byte)((datatype << 5) | 27));             stream.WriteByte((byte)0);             stream.WriteByte((byte)0);             stream.WriteByte((byte)0);             stream.Write(bytes' 0' byteCount);             break;           case 6:             stream.WriteByte((byte)((datatype << 5) | 27));             stream.WriteByte((byte)0);             stream.WriteByte((byte)0);             stream.Write(bytes' 0' byteCount);             break;           case 7:             stream.WriteByte((byte)((datatype << 5) | 27));             stream.WriteByte((byte)0);             stream.Write(bytes' 0' byteCount);             break;           case 8:             stream.WriteByte((byte)((datatype << 5) | 27));             stream.Write(bytes' 0' byteCount);             break;           default: stream.WriteByte((datatype == 0) ? (byte)0xc2 : (byte)0xc3);             WritePositiveInt(2' byteCount' stream);             stream.Write(bytes' 0' byteCount);             break;         }       }
Magic Number,PeterO.Cbor,CBORObject,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORObject.cs,Write,The following statement contains a magic number: if (bigint.CompareTo(Int64MaxValue) <= 0) {         // If the big integer is representable as a long and in         // major type 0 or 1' write that major type         // instead of as a bignum         var ui = (long)(EInteger)bigint;         WritePositiveInt64(datatype' ui' stream);       } else {         // Get a byte array of the big integer's value'         // since shifting and doing AND operations is         // slow with large BigIntegers         byte[] bytes = bigint.ToBytes(true);         int byteCount = bytes.Length;         while (byteCount > 0 && bytes[byteCount - 1] == 0) {           // Ignore trailing zero bytes           --byteCount;         }         if (byteCount != 0) {           int half = byteCount >> 1;           int right = byteCount - 1;           for (var i = 0; i < half; ++i' --right) {             byte value = bytes[i];             bytes[i] = bytes[right];             bytes[right] = value;           }         }         switch (byteCount) {           case 0:             stream.WriteByte((byte)(datatype << 5));             return;           case 1:             WritePositiveInt(datatype' ((int)bytes[0]) & 0xff' stream);             break;           case 2:             stream.WriteByte((byte)((datatype << 5) | 25));             stream.Write(bytes' 0' byteCount);             break;           case 3:             stream.WriteByte((byte)((datatype << 5) | 26));             stream.WriteByte((byte)0);             stream.Write(bytes' 0' byteCount);             break;           case 4:             stream.WriteByte((byte)((datatype << 5) | 26));             stream.Write(bytes' 0' byteCount);             break;           case 5:             stream.WriteByte((byte)((datatype << 5) | 27));             stream.WriteByte((byte)0);             stream.WriteByte((byte)0);             stream.WriteByte((byte)0);             stream.Write(bytes' 0' byteCount);             break;           case 6:             stream.WriteByte((byte)((datatype << 5) | 27));             stream.WriteByte((byte)0);             stream.WriteByte((byte)0);             stream.Write(bytes' 0' byteCount);             break;           case 7:             stream.WriteByte((byte)((datatype << 5) | 27));             stream.WriteByte((byte)0);             stream.Write(bytes' 0' byteCount);             break;           case 8:             stream.WriteByte((byte)((datatype << 5) | 27));             stream.Write(bytes' 0' byteCount);             break;           default: stream.WriteByte((datatype == 0) ? (byte)0xc2 : (byte)0xc3);             WritePositiveInt(2' byteCount' stream);             stream.Write(bytes' 0' byteCount);             break;         }       }
Magic Number,PeterO.Cbor,CBORObject,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORObject.cs,Write,The following statement contains a magic number: if (bigint.CompareTo(Int64MaxValue) <= 0) {         // If the big integer is representable as a long and in         // major type 0 or 1' write that major type         // instead of as a bignum         var ui = (long)(EInteger)bigint;         WritePositiveInt64(datatype' ui' stream);       } else {         // Get a byte array of the big integer's value'         // since shifting and doing AND operations is         // slow with large BigIntegers         byte[] bytes = bigint.ToBytes(true);         int byteCount = bytes.Length;         while (byteCount > 0 && bytes[byteCount - 1] == 0) {           // Ignore trailing zero bytes           --byteCount;         }         if (byteCount != 0) {           int half = byteCount >> 1;           int right = byteCount - 1;           for (var i = 0; i < half; ++i' --right) {             byte value = bytes[i];             bytes[i] = bytes[right];             bytes[right] = value;           }         }         switch (byteCount) {           case 0:             stream.WriteByte((byte)(datatype << 5));             return;           case 1:             WritePositiveInt(datatype' ((int)bytes[0]) & 0xff' stream);             break;           case 2:             stream.WriteByte((byte)((datatype << 5) | 25));             stream.Write(bytes' 0' byteCount);             break;           case 3:             stream.WriteByte((byte)((datatype << 5) | 26));             stream.WriteByte((byte)0);             stream.Write(bytes' 0' byteCount);             break;           case 4:             stream.WriteByte((byte)((datatype << 5) | 26));             stream.Write(bytes' 0' byteCount);             break;           case 5:             stream.WriteByte((byte)((datatype << 5) | 27));             stream.WriteByte((byte)0);             stream.WriteByte((byte)0);             stream.WriteByte((byte)0);             stream.Write(bytes' 0' byteCount);             break;           case 6:             stream.WriteByte((byte)((datatype << 5) | 27));             stream.WriteByte((byte)0);             stream.WriteByte((byte)0);             stream.Write(bytes' 0' byteCount);             break;           case 7:             stream.WriteByte((byte)((datatype << 5) | 27));             stream.WriteByte((byte)0);             stream.Write(bytes' 0' byteCount);             break;           case 8:             stream.WriteByte((byte)((datatype << 5) | 27));             stream.Write(bytes' 0' byteCount);             break;           default: stream.WriteByte((datatype == 0) ? (byte)0xc2 : (byte)0xc3);             WritePositiveInt(2' byteCount' stream);             stream.Write(bytes' 0' byteCount);             break;         }       }
Magic Number,PeterO.Cbor,CBORObject,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORObject.cs,Write,The following statement contains a magic number: if (bigint.CompareTo(Int64MaxValue) <= 0) {         // If the big integer is representable as a long and in         // major type 0 or 1' write that major type         // instead of as a bignum         var ui = (long)(EInteger)bigint;         WritePositiveInt64(datatype' ui' stream);       } else {         // Get a byte array of the big integer's value'         // since shifting and doing AND operations is         // slow with large BigIntegers         byte[] bytes = bigint.ToBytes(true);         int byteCount = bytes.Length;         while (byteCount > 0 && bytes[byteCount - 1] == 0) {           // Ignore trailing zero bytes           --byteCount;         }         if (byteCount != 0) {           int half = byteCount >> 1;           int right = byteCount - 1;           for (var i = 0; i < half; ++i' --right) {             byte value = bytes[i];             bytes[i] = bytes[right];             bytes[right] = value;           }         }         switch (byteCount) {           case 0:             stream.WriteByte((byte)(datatype << 5));             return;           case 1:             WritePositiveInt(datatype' ((int)bytes[0]) & 0xff' stream);             break;           case 2:             stream.WriteByte((byte)((datatype << 5) | 25));             stream.Write(bytes' 0' byteCount);             break;           case 3:             stream.WriteByte((byte)((datatype << 5) | 26));             stream.WriteByte((byte)0);             stream.Write(bytes' 0' byteCount);             break;           case 4:             stream.WriteByte((byte)((datatype << 5) | 26));             stream.Write(bytes' 0' byteCount);             break;           case 5:             stream.WriteByte((byte)((datatype << 5) | 27));             stream.WriteByte((byte)0);             stream.WriteByte((byte)0);             stream.WriteByte((byte)0);             stream.Write(bytes' 0' byteCount);             break;           case 6:             stream.WriteByte((byte)((datatype << 5) | 27));             stream.WriteByte((byte)0);             stream.WriteByte((byte)0);             stream.Write(bytes' 0' byteCount);             break;           case 7:             stream.WriteByte((byte)((datatype << 5) | 27));             stream.WriteByte((byte)0);             stream.Write(bytes' 0' byteCount);             break;           case 8:             stream.WriteByte((byte)((datatype << 5) | 27));             stream.Write(bytes' 0' byteCount);             break;           default: stream.WriteByte((datatype == 0) ? (byte)0xc2 : (byte)0xc3);             WritePositiveInt(2' byteCount' stream);             stream.Write(bytes' 0' byteCount);             break;         }       }
Magic Number,PeterO.Cbor,CBORObject,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORObject.cs,Write,The following statement contains a magic number: if (bigint.CompareTo(Int64MaxValue) <= 0) {         // If the big integer is representable as a long and in         // major type 0 or 1' write that major type         // instead of as a bignum         var ui = (long)(EInteger)bigint;         WritePositiveInt64(datatype' ui' stream);       } else {         // Get a byte array of the big integer's value'         // since shifting and doing AND operations is         // slow with large BigIntegers         byte[] bytes = bigint.ToBytes(true);         int byteCount = bytes.Length;         while (byteCount > 0 && bytes[byteCount - 1] == 0) {           // Ignore trailing zero bytes           --byteCount;         }         if (byteCount != 0) {           int half = byteCount >> 1;           int right = byteCount - 1;           for (var i = 0; i < half; ++i' --right) {             byte value = bytes[i];             bytes[i] = bytes[right];             bytes[right] = value;           }         }         switch (byteCount) {           case 0:             stream.WriteByte((byte)(datatype << 5));             return;           case 1:             WritePositiveInt(datatype' ((int)bytes[0]) & 0xff' stream);             break;           case 2:             stream.WriteByte((byte)((datatype << 5) | 25));             stream.Write(bytes' 0' byteCount);             break;           case 3:             stream.WriteByte((byte)((datatype << 5) | 26));             stream.WriteByte((byte)0);             stream.Write(bytes' 0' byteCount);             break;           case 4:             stream.WriteByte((byte)((datatype << 5) | 26));             stream.Write(bytes' 0' byteCount);             break;           case 5:             stream.WriteByte((byte)((datatype << 5) | 27));             stream.WriteByte((byte)0);             stream.WriteByte((byte)0);             stream.WriteByte((byte)0);             stream.Write(bytes' 0' byteCount);             break;           case 6:             stream.WriteByte((byte)((datatype << 5) | 27));             stream.WriteByte((byte)0);             stream.WriteByte((byte)0);             stream.Write(bytes' 0' byteCount);             break;           case 7:             stream.WriteByte((byte)((datatype << 5) | 27));             stream.WriteByte((byte)0);             stream.Write(bytes' 0' byteCount);             break;           case 8:             stream.WriteByte((byte)((datatype << 5) | 27));             stream.Write(bytes' 0' byteCount);             break;           default: stream.WriteByte((datatype == 0) ? (byte)0xc2 : (byte)0xc3);             WritePositiveInt(2' byteCount' stream);             stream.Write(bytes' 0' byteCount);             break;         }       }
Magic Number,PeterO.Cbor,CBORObject,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORObject.cs,Write,The following statement contains a magic number: if (bigint.CompareTo(Int64MaxValue) <= 0) {         // If the big integer is representable as a long and in         // major type 0 or 1' write that major type         // instead of as a bignum         var ui = (long)(EInteger)bigint;         WritePositiveInt64(datatype' ui' stream);       } else {         // Get a byte array of the big integer's value'         // since shifting and doing AND operations is         // slow with large BigIntegers         byte[] bytes = bigint.ToBytes(true);         int byteCount = bytes.Length;         while (byteCount > 0 && bytes[byteCount - 1] == 0) {           // Ignore trailing zero bytes           --byteCount;         }         if (byteCount != 0) {           int half = byteCount >> 1;           int right = byteCount - 1;           for (var i = 0; i < half; ++i' --right) {             byte value = bytes[i];             bytes[i] = bytes[right];             bytes[right] = value;           }         }         switch (byteCount) {           case 0:             stream.WriteByte((byte)(datatype << 5));             return;           case 1:             WritePositiveInt(datatype' ((int)bytes[0]) & 0xff' stream);             break;           case 2:             stream.WriteByte((byte)((datatype << 5) | 25));             stream.Write(bytes' 0' byteCount);             break;           case 3:             stream.WriteByte((byte)((datatype << 5) | 26));             stream.WriteByte((byte)0);             stream.Write(bytes' 0' byteCount);             break;           case 4:             stream.WriteByte((byte)((datatype << 5) | 26));             stream.Write(bytes' 0' byteCount);             break;           case 5:             stream.WriteByte((byte)((datatype << 5) | 27));             stream.WriteByte((byte)0);             stream.WriteByte((byte)0);             stream.WriteByte((byte)0);             stream.Write(bytes' 0' byteCount);             break;           case 6:             stream.WriteByte((byte)((datatype << 5) | 27));             stream.WriteByte((byte)0);             stream.WriteByte((byte)0);             stream.Write(bytes' 0' byteCount);             break;           case 7:             stream.WriteByte((byte)((datatype << 5) | 27));             stream.WriteByte((byte)0);             stream.Write(bytes' 0' byteCount);             break;           case 8:             stream.WriteByte((byte)((datatype << 5) | 27));             stream.Write(bytes' 0' byteCount);             break;           default: stream.WriteByte((datatype == 0) ? (byte)0xc2 : (byte)0xc3);             WritePositiveInt(2' byteCount' stream);             stream.Write(bytes' 0' byteCount);             break;         }       }
Magic Number,PeterO.Cbor,CBORObject,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORObject.cs,Write,The following statement contains a magic number: if (bigint.CompareTo(Int64MaxValue) <= 0) {         // If the big integer is representable as a long and in         // major type 0 or 1' write that major type         // instead of as a bignum         var ui = (long)(EInteger)bigint;         WritePositiveInt64(datatype' ui' stream);       } else {         // Get a byte array of the big integer's value'         // since shifting and doing AND operations is         // slow with large BigIntegers         byte[] bytes = bigint.ToBytes(true);         int byteCount = bytes.Length;         while (byteCount > 0 && bytes[byteCount - 1] == 0) {           // Ignore trailing zero bytes           --byteCount;         }         if (byteCount != 0) {           int half = byteCount >> 1;           int right = byteCount - 1;           for (var i = 0; i < half; ++i' --right) {             byte value = bytes[i];             bytes[i] = bytes[right];             bytes[right] = value;           }         }         switch (byteCount) {           case 0:             stream.WriteByte((byte)(datatype << 5));             return;           case 1:             WritePositiveInt(datatype' ((int)bytes[0]) & 0xff' stream);             break;           case 2:             stream.WriteByte((byte)((datatype << 5) | 25));             stream.Write(bytes' 0' byteCount);             break;           case 3:             stream.WriteByte((byte)((datatype << 5) | 26));             stream.WriteByte((byte)0);             stream.Write(bytes' 0' byteCount);             break;           case 4:             stream.WriteByte((byte)((datatype << 5) | 26));             stream.Write(bytes' 0' byteCount);             break;           case 5:             stream.WriteByte((byte)((datatype << 5) | 27));             stream.WriteByte((byte)0);             stream.WriteByte((byte)0);             stream.WriteByte((byte)0);             stream.Write(bytes' 0' byteCount);             break;           case 6:             stream.WriteByte((byte)((datatype << 5) | 27));             stream.WriteByte((byte)0);             stream.WriteByte((byte)0);             stream.Write(bytes' 0' byteCount);             break;           case 7:             stream.WriteByte((byte)((datatype << 5) | 27));             stream.WriteByte((byte)0);             stream.Write(bytes' 0' byteCount);             break;           case 8:             stream.WriteByte((byte)((datatype << 5) | 27));             stream.Write(bytes' 0' byteCount);             break;           default: stream.WriteByte((datatype == 0) ? (byte)0xc2 : (byte)0xc3);             WritePositiveInt(2' byteCount' stream);             stream.Write(bytes' 0' byteCount);             break;         }       }
Magic Number,PeterO.Cbor,CBORObject,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORObject.cs,Write,The following statement contains a magic number: if (bigint.CompareTo(Int64MaxValue) <= 0) {         // If the big integer is representable as a long and in         // major type 0 or 1' write that major type         // instead of as a bignum         var ui = (long)(EInteger)bigint;         WritePositiveInt64(datatype' ui' stream);       } else {         // Get a byte array of the big integer's value'         // since shifting and doing AND operations is         // slow with large BigIntegers         byte[] bytes = bigint.ToBytes(true);         int byteCount = bytes.Length;         while (byteCount > 0 && bytes[byteCount - 1] == 0) {           // Ignore trailing zero bytes           --byteCount;         }         if (byteCount != 0) {           int half = byteCount >> 1;           int right = byteCount - 1;           for (var i = 0; i < half; ++i' --right) {             byte value = bytes[i];             bytes[i] = bytes[right];             bytes[right] = value;           }         }         switch (byteCount) {           case 0:             stream.WriteByte((byte)(datatype << 5));             return;           case 1:             WritePositiveInt(datatype' ((int)bytes[0]) & 0xff' stream);             break;           case 2:             stream.WriteByte((byte)((datatype << 5) | 25));             stream.Write(bytes' 0' byteCount);             break;           case 3:             stream.WriteByte((byte)((datatype << 5) | 26));             stream.WriteByte((byte)0);             stream.Write(bytes' 0' byteCount);             break;           case 4:             stream.WriteByte((byte)((datatype << 5) | 26));             stream.Write(bytes' 0' byteCount);             break;           case 5:             stream.WriteByte((byte)((datatype << 5) | 27));             stream.WriteByte((byte)0);             stream.WriteByte((byte)0);             stream.WriteByte((byte)0);             stream.Write(bytes' 0' byteCount);             break;           case 6:             stream.WriteByte((byte)((datatype << 5) | 27));             stream.WriteByte((byte)0);             stream.WriteByte((byte)0);             stream.Write(bytes' 0' byteCount);             break;           case 7:             stream.WriteByte((byte)((datatype << 5) | 27));             stream.WriteByte((byte)0);             stream.Write(bytes' 0' byteCount);             break;           case 8:             stream.WriteByte((byte)((datatype << 5) | 27));             stream.Write(bytes' 0' byteCount);             break;           default: stream.WriteByte((datatype == 0) ? (byte)0xc2 : (byte)0xc3);             WritePositiveInt(2' byteCount' stream);             stream.Write(bytes' 0' byteCount);             break;         }       }
Magic Number,PeterO.Cbor,CBORObject,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORObject.cs,Write,The following statement contains a magic number: if (bigint.CompareTo(Int64MaxValue) <= 0) {         // If the big integer is representable as a long and in         // major type 0 or 1' write that major type         // instead of as a bignum         var ui = (long)(EInteger)bigint;         WritePositiveInt64(datatype' ui' stream);       } else {         // Get a byte array of the big integer's value'         // since shifting and doing AND operations is         // slow with large BigIntegers         byte[] bytes = bigint.ToBytes(true);         int byteCount = bytes.Length;         while (byteCount > 0 && bytes[byteCount - 1] == 0) {           // Ignore trailing zero bytes           --byteCount;         }         if (byteCount != 0) {           int half = byteCount >> 1;           int right = byteCount - 1;           for (var i = 0; i < half; ++i' --right) {             byte value = bytes[i];             bytes[i] = bytes[right];             bytes[right] = value;           }         }         switch (byteCount) {           case 0:             stream.WriteByte((byte)(datatype << 5));             return;           case 1:             WritePositiveInt(datatype' ((int)bytes[0]) & 0xff' stream);             break;           case 2:             stream.WriteByte((byte)((datatype << 5) | 25));             stream.Write(bytes' 0' byteCount);             break;           case 3:             stream.WriteByte((byte)((datatype << 5) | 26));             stream.WriteByte((byte)0);             stream.Write(bytes' 0' byteCount);             break;           case 4:             stream.WriteByte((byte)((datatype << 5) | 26));             stream.Write(bytes' 0' byteCount);             break;           case 5:             stream.WriteByte((byte)((datatype << 5) | 27));             stream.WriteByte((byte)0);             stream.WriteByte((byte)0);             stream.WriteByte((byte)0);             stream.Write(bytes' 0' byteCount);             break;           case 6:             stream.WriteByte((byte)((datatype << 5) | 27));             stream.WriteByte((byte)0);             stream.WriteByte((byte)0);             stream.Write(bytes' 0' byteCount);             break;           case 7:             stream.WriteByte((byte)((datatype << 5) | 27));             stream.WriteByte((byte)0);             stream.Write(bytes' 0' byteCount);             break;           case 8:             stream.WriteByte((byte)((datatype << 5) | 27));             stream.Write(bytes' 0' byteCount);             break;           default: stream.WriteByte((datatype == 0) ? (byte)0xc2 : (byte)0xc3);             WritePositiveInt(2' byteCount' stream);             stream.Write(bytes' 0' byteCount);             break;         }       }
Magic Number,PeterO.Cbor,CBORObject,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORObject.cs,Write,The following statement contains a magic number: if (bigint.CompareTo(Int64MaxValue) <= 0) {         // If the big integer is representable as a long and in         // major type 0 or 1' write that major type         // instead of as a bignum         var ui = (long)(EInteger)bigint;         WritePositiveInt64(datatype' ui' stream);       } else {         // Get a byte array of the big integer's value'         // since shifting and doing AND operations is         // slow with large BigIntegers         byte[] bytes = bigint.ToBytes(true);         int byteCount = bytes.Length;         while (byteCount > 0 && bytes[byteCount - 1] == 0) {           // Ignore trailing zero bytes           --byteCount;         }         if (byteCount != 0) {           int half = byteCount >> 1;           int right = byteCount - 1;           for (var i = 0; i < half; ++i' --right) {             byte value = bytes[i];             bytes[i] = bytes[right];             bytes[right] = value;           }         }         switch (byteCount) {           case 0:             stream.WriteByte((byte)(datatype << 5));             return;           case 1:             WritePositiveInt(datatype' ((int)bytes[0]) & 0xff' stream);             break;           case 2:             stream.WriteByte((byte)((datatype << 5) | 25));             stream.Write(bytes' 0' byteCount);             break;           case 3:             stream.WriteByte((byte)((datatype << 5) | 26));             stream.WriteByte((byte)0);             stream.Write(bytes' 0' byteCount);             break;           case 4:             stream.WriteByte((byte)((datatype << 5) | 26));             stream.Write(bytes' 0' byteCount);             break;           case 5:             stream.WriteByte((byte)((datatype << 5) | 27));             stream.WriteByte((byte)0);             stream.WriteByte((byte)0);             stream.WriteByte((byte)0);             stream.Write(bytes' 0' byteCount);             break;           case 6:             stream.WriteByte((byte)((datatype << 5) | 27));             stream.WriteByte((byte)0);             stream.WriteByte((byte)0);             stream.Write(bytes' 0' byteCount);             break;           case 7:             stream.WriteByte((byte)((datatype << 5) | 27));             stream.WriteByte((byte)0);             stream.Write(bytes' 0' byteCount);             break;           case 8:             stream.WriteByte((byte)((datatype << 5) | 27));             stream.Write(bytes' 0' byteCount);             break;           default: stream.WriteByte((datatype == 0) ? (byte)0xc2 : (byte)0xc3);             WritePositiveInt(2' byteCount' stream);             stream.Write(bytes' 0' byteCount);             break;         }       }
Magic Number,PeterO.Cbor,CBORObject,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORObject.cs,Write,The following statement contains a magic number: if (bigint.CompareTo(Int64MaxValue) <= 0) {         // If the big integer is representable as a long and in         // major type 0 or 1' write that major type         // instead of as a bignum         var ui = (long)(EInteger)bigint;         WritePositiveInt64(datatype' ui' stream);       } else {         // Get a byte array of the big integer's value'         // since shifting and doing AND operations is         // slow with large BigIntegers         byte[] bytes = bigint.ToBytes(true);         int byteCount = bytes.Length;         while (byteCount > 0 && bytes[byteCount - 1] == 0) {           // Ignore trailing zero bytes           --byteCount;         }         if (byteCount != 0) {           int half = byteCount >> 1;           int right = byteCount - 1;           for (var i = 0; i < half; ++i' --right) {             byte value = bytes[i];             bytes[i] = bytes[right];             bytes[right] = value;           }         }         switch (byteCount) {           case 0:             stream.WriteByte((byte)(datatype << 5));             return;           case 1:             WritePositiveInt(datatype' ((int)bytes[0]) & 0xff' stream);             break;           case 2:             stream.WriteByte((byte)((datatype << 5) | 25));             stream.Write(bytes' 0' byteCount);             break;           case 3:             stream.WriteByte((byte)((datatype << 5) | 26));             stream.WriteByte((byte)0);             stream.Write(bytes' 0' byteCount);             break;           case 4:             stream.WriteByte((byte)((datatype << 5) | 26));             stream.Write(bytes' 0' byteCount);             break;           case 5:             stream.WriteByte((byte)((datatype << 5) | 27));             stream.WriteByte((byte)0);             stream.WriteByte((byte)0);             stream.WriteByte((byte)0);             stream.Write(bytes' 0' byteCount);             break;           case 6:             stream.WriteByte((byte)((datatype << 5) | 27));             stream.WriteByte((byte)0);             stream.WriteByte((byte)0);             stream.Write(bytes' 0' byteCount);             break;           case 7:             stream.WriteByte((byte)((datatype << 5) | 27));             stream.WriteByte((byte)0);             stream.Write(bytes' 0' byteCount);             break;           case 8:             stream.WriteByte((byte)((datatype << 5) | 27));             stream.Write(bytes' 0' byteCount);             break;           default: stream.WriteByte((datatype == 0) ? (byte)0xc2 : (byte)0xc3);             WritePositiveInt(2' byteCount' stream);             stream.Write(bytes' 0' byteCount);             break;         }       }
Magic Number,PeterO.Cbor,CBORObject,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORObject.cs,Write,The following statement contains a magic number: if (bigint.CompareTo(Int64MaxValue) <= 0) {         // If the big integer is representable as a long and in         // major type 0 or 1' write that major type         // instead of as a bignum         var ui = (long)(EInteger)bigint;         WritePositiveInt64(datatype' ui' stream);       } else {         // Get a byte array of the big integer's value'         // since shifting and doing AND operations is         // slow with large BigIntegers         byte[] bytes = bigint.ToBytes(true);         int byteCount = bytes.Length;         while (byteCount > 0 && bytes[byteCount - 1] == 0) {           // Ignore trailing zero bytes           --byteCount;         }         if (byteCount != 0) {           int half = byteCount >> 1;           int right = byteCount - 1;           for (var i = 0; i < half; ++i' --right) {             byte value = bytes[i];             bytes[i] = bytes[right];             bytes[right] = value;           }         }         switch (byteCount) {           case 0:             stream.WriteByte((byte)(datatype << 5));             return;           case 1:             WritePositiveInt(datatype' ((int)bytes[0]) & 0xff' stream);             break;           case 2:             stream.WriteByte((byte)((datatype << 5) | 25));             stream.Write(bytes' 0' byteCount);             break;           case 3:             stream.WriteByte((byte)((datatype << 5) | 26));             stream.WriteByte((byte)0);             stream.Write(bytes' 0' byteCount);             break;           case 4:             stream.WriteByte((byte)((datatype << 5) | 26));             stream.Write(bytes' 0' byteCount);             break;           case 5:             stream.WriteByte((byte)((datatype << 5) | 27));             stream.WriteByte((byte)0);             stream.WriteByte((byte)0);             stream.WriteByte((byte)0);             stream.Write(bytes' 0' byteCount);             break;           case 6:             stream.WriteByte((byte)((datatype << 5) | 27));             stream.WriteByte((byte)0);             stream.WriteByte((byte)0);             stream.Write(bytes' 0' byteCount);             break;           case 7:             stream.WriteByte((byte)((datatype << 5) | 27));             stream.WriteByte((byte)0);             stream.Write(bytes' 0' byteCount);             break;           case 8:             stream.WriteByte((byte)((datatype << 5) | 27));             stream.Write(bytes' 0' byteCount);             break;           default: stream.WriteByte((datatype == 0) ? (byte)0xc2 : (byte)0xc3);             WritePositiveInt(2' byteCount' stream);             stream.Write(bytes' 0' byteCount);             break;         }       }
Magic Number,PeterO.Cbor,CBORObject,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORObject.cs,Write,The following statement contains a magic number: if (bigint.CompareTo(Int64MaxValue) <= 0) {         // If the big integer is representable as a long and in         // major type 0 or 1' write that major type         // instead of as a bignum         var ui = (long)(EInteger)bigint;         WritePositiveInt64(datatype' ui' stream);       } else {         // Get a byte array of the big integer's value'         // since shifting and doing AND operations is         // slow with large BigIntegers         byte[] bytes = bigint.ToBytes(true);         int byteCount = bytes.Length;         while (byteCount > 0 && bytes[byteCount - 1] == 0) {           // Ignore trailing zero bytes           --byteCount;         }         if (byteCount != 0) {           int half = byteCount >> 1;           int right = byteCount - 1;           for (var i = 0; i < half; ++i' --right) {             byte value = bytes[i];             bytes[i] = bytes[right];             bytes[right] = value;           }         }         switch (byteCount) {           case 0:             stream.WriteByte((byte)(datatype << 5));             return;           case 1:             WritePositiveInt(datatype' ((int)bytes[0]) & 0xff' stream);             break;           case 2:             stream.WriteByte((byte)((datatype << 5) | 25));             stream.Write(bytes' 0' byteCount);             break;           case 3:             stream.WriteByte((byte)((datatype << 5) | 26));             stream.WriteByte((byte)0);             stream.Write(bytes' 0' byteCount);             break;           case 4:             stream.WriteByte((byte)((datatype << 5) | 26));             stream.Write(bytes' 0' byteCount);             break;           case 5:             stream.WriteByte((byte)((datatype << 5) | 27));             stream.WriteByte((byte)0);             stream.WriteByte((byte)0);             stream.WriteByte((byte)0);             stream.Write(bytes' 0' byteCount);             break;           case 6:             stream.WriteByte((byte)((datatype << 5) | 27));             stream.WriteByte((byte)0);             stream.WriteByte((byte)0);             stream.Write(bytes' 0' byteCount);             break;           case 7:             stream.WriteByte((byte)((datatype << 5) | 27));             stream.WriteByte((byte)0);             stream.Write(bytes' 0' byteCount);             break;           case 8:             stream.WriteByte((byte)((datatype << 5) | 27));             stream.Write(bytes' 0' byteCount);             break;           default: stream.WriteByte((datatype == 0) ? (byte)0xc2 : (byte)0xc3);             WritePositiveInt(2' byteCount' stream);             stream.Write(bytes' 0' byteCount);             break;         }       }
Magic Number,PeterO.Cbor,CBORObject,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORObject.cs,Write,The following statement contains a magic number: if (bigint.CompareTo(Int64MaxValue) <= 0) {         // If the big integer is representable as a long and in         // major type 0 or 1' write that major type         // instead of as a bignum         var ui = (long)(EInteger)bigint;         WritePositiveInt64(datatype' ui' stream);       } else {         // Get a byte array of the big integer's value'         // since shifting and doing AND operations is         // slow with large BigIntegers         byte[] bytes = bigint.ToBytes(true);         int byteCount = bytes.Length;         while (byteCount > 0 && bytes[byteCount - 1] == 0) {           // Ignore trailing zero bytes           --byteCount;         }         if (byteCount != 0) {           int half = byteCount >> 1;           int right = byteCount - 1;           for (var i = 0; i < half; ++i' --right) {             byte value = bytes[i];             bytes[i] = bytes[right];             bytes[right] = value;           }         }         switch (byteCount) {           case 0:             stream.WriteByte((byte)(datatype << 5));             return;           case 1:             WritePositiveInt(datatype' ((int)bytes[0]) & 0xff' stream);             break;           case 2:             stream.WriteByte((byte)((datatype << 5) | 25));             stream.Write(bytes' 0' byteCount);             break;           case 3:             stream.WriteByte((byte)((datatype << 5) | 26));             stream.WriteByte((byte)0);             stream.Write(bytes' 0' byteCount);             break;           case 4:             stream.WriteByte((byte)((datatype << 5) | 26));             stream.Write(bytes' 0' byteCount);             break;           case 5:             stream.WriteByte((byte)((datatype << 5) | 27));             stream.WriteByte((byte)0);             stream.WriteByte((byte)0);             stream.WriteByte((byte)0);             stream.Write(bytes' 0' byteCount);             break;           case 6:             stream.WriteByte((byte)((datatype << 5) | 27));             stream.WriteByte((byte)0);             stream.WriteByte((byte)0);             stream.Write(bytes' 0' byteCount);             break;           case 7:             stream.WriteByte((byte)((datatype << 5) | 27));             stream.WriteByte((byte)0);             stream.Write(bytes' 0' byteCount);             break;           case 8:             stream.WriteByte((byte)((datatype << 5) | 27));             stream.Write(bytes' 0' byteCount);             break;           default: stream.WriteByte((datatype == 0) ? (byte)0xc2 : (byte)0xc3);             WritePositiveInt(2' byteCount' stream);             stream.Write(bytes' 0' byteCount);             break;         }       }
Magic Number,PeterO.Cbor,CBORObject,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORObject.cs,Write,The following statement contains a magic number: if (bigint.CompareTo(Int64MaxValue) <= 0) {         // If the big integer is representable as a long and in         // major type 0 or 1' write that major type         // instead of as a bignum         var ui = (long)(EInteger)bigint;         WritePositiveInt64(datatype' ui' stream);       } else {         // Get a byte array of the big integer's value'         // since shifting and doing AND operations is         // slow with large BigIntegers         byte[] bytes = bigint.ToBytes(true);         int byteCount = bytes.Length;         while (byteCount > 0 && bytes[byteCount - 1] == 0) {           // Ignore trailing zero bytes           --byteCount;         }         if (byteCount != 0) {           int half = byteCount >> 1;           int right = byteCount - 1;           for (var i = 0; i < half; ++i' --right) {             byte value = bytes[i];             bytes[i] = bytes[right];             bytes[right] = value;           }         }         switch (byteCount) {           case 0:             stream.WriteByte((byte)(datatype << 5));             return;           case 1:             WritePositiveInt(datatype' ((int)bytes[0]) & 0xff' stream);             break;           case 2:             stream.WriteByte((byte)((datatype << 5) | 25));             stream.Write(bytes' 0' byteCount);             break;           case 3:             stream.WriteByte((byte)((datatype << 5) | 26));             stream.WriteByte((byte)0);             stream.Write(bytes' 0' byteCount);             break;           case 4:             stream.WriteByte((byte)((datatype << 5) | 26));             stream.Write(bytes' 0' byteCount);             break;           case 5:             stream.WriteByte((byte)((datatype << 5) | 27));             stream.WriteByte((byte)0);             stream.WriteByte((byte)0);             stream.WriteByte((byte)0);             stream.Write(bytes' 0' byteCount);             break;           case 6:             stream.WriteByte((byte)((datatype << 5) | 27));             stream.WriteByte((byte)0);             stream.WriteByte((byte)0);             stream.Write(bytes' 0' byteCount);             break;           case 7:             stream.WriteByte((byte)((datatype << 5) | 27));             stream.WriteByte((byte)0);             stream.Write(bytes' 0' byteCount);             break;           case 8:             stream.WriteByte((byte)((datatype << 5) | 27));             stream.Write(bytes' 0' byteCount);             break;           default: stream.WriteByte((datatype == 0) ? (byte)0xc2 : (byte)0xc3);             WritePositiveInt(2' byteCount' stream);             stream.Write(bytes' 0' byteCount);             break;         }       }
Magic Number,PeterO.Cbor,CBORObject,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORObject.cs,Write,The following statement contains a magic number: if (bigint.CompareTo(Int64MaxValue) <= 0) {         // If the big integer is representable as a long and in         // major type 0 or 1' write that major type         // instead of as a bignum         var ui = (long)(EInteger)bigint;         WritePositiveInt64(datatype' ui' stream);       } else {         // Get a byte array of the big integer's value'         // since shifting and doing AND operations is         // slow with large BigIntegers         byte[] bytes = bigint.ToBytes(true);         int byteCount = bytes.Length;         while (byteCount > 0 && bytes[byteCount - 1] == 0) {           // Ignore trailing zero bytes           --byteCount;         }         if (byteCount != 0) {           int half = byteCount >> 1;           int right = byteCount - 1;           for (var i = 0; i < half; ++i' --right) {             byte value = bytes[i];             bytes[i] = bytes[right];             bytes[right] = value;           }         }         switch (byteCount) {           case 0:             stream.WriteByte((byte)(datatype << 5));             return;           case 1:             WritePositiveInt(datatype' ((int)bytes[0]) & 0xff' stream);             break;           case 2:             stream.WriteByte((byte)((datatype << 5) | 25));             stream.Write(bytes' 0' byteCount);             break;           case 3:             stream.WriteByte((byte)((datatype << 5) | 26));             stream.WriteByte((byte)0);             stream.Write(bytes' 0' byteCount);             break;           case 4:             stream.WriteByte((byte)((datatype << 5) | 26));             stream.Write(bytes' 0' byteCount);             break;           case 5:             stream.WriteByte((byte)((datatype << 5) | 27));             stream.WriteByte((byte)0);             stream.WriteByte((byte)0);             stream.WriteByte((byte)0);             stream.Write(bytes' 0' byteCount);             break;           case 6:             stream.WriteByte((byte)((datatype << 5) | 27));             stream.WriteByte((byte)0);             stream.WriteByte((byte)0);             stream.Write(bytes' 0' byteCount);             break;           case 7:             stream.WriteByte((byte)((datatype << 5) | 27));             stream.WriteByte((byte)0);             stream.Write(bytes' 0' byteCount);             break;           case 8:             stream.WriteByte((byte)((datatype << 5) | 27));             stream.Write(bytes' 0' byteCount);             break;           default: stream.WriteByte((datatype == 0) ? (byte)0xc2 : (byte)0xc3);             WritePositiveInt(2' byteCount' stream);             stream.Write(bytes' 0' byteCount);             break;         }       }
Magic Number,PeterO.Cbor,CBORObject,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORObject.cs,Write,The following statement contains a magic number: if (bigint.CompareTo(Int64MaxValue) <= 0) {         // If the big integer is representable as a long and in         // major type 0 or 1' write that major type         // instead of as a bignum         var ui = (long)(EInteger)bigint;         WritePositiveInt64(datatype' ui' stream);       } else {         // Get a byte array of the big integer's value'         // since shifting and doing AND operations is         // slow with large BigIntegers         byte[] bytes = bigint.ToBytes(true);         int byteCount = bytes.Length;         while (byteCount > 0 && bytes[byteCount - 1] == 0) {           // Ignore trailing zero bytes           --byteCount;         }         if (byteCount != 0) {           int half = byteCount >> 1;           int right = byteCount - 1;           for (var i = 0; i < half; ++i' --right) {             byte value = bytes[i];             bytes[i] = bytes[right];             bytes[right] = value;           }         }         switch (byteCount) {           case 0:             stream.WriteByte((byte)(datatype << 5));             return;           case 1:             WritePositiveInt(datatype' ((int)bytes[0]) & 0xff' stream);             break;           case 2:             stream.WriteByte((byte)((datatype << 5) | 25));             stream.Write(bytes' 0' byteCount);             break;           case 3:             stream.WriteByte((byte)((datatype << 5) | 26));             stream.WriteByte((byte)0);             stream.Write(bytes' 0' byteCount);             break;           case 4:             stream.WriteByte((byte)((datatype << 5) | 26));             stream.Write(bytes' 0' byteCount);             break;           case 5:             stream.WriteByte((byte)((datatype << 5) | 27));             stream.WriteByte((byte)0);             stream.WriteByte((byte)0);             stream.WriteByte((byte)0);             stream.Write(bytes' 0' byteCount);             break;           case 6:             stream.WriteByte((byte)((datatype << 5) | 27));             stream.WriteByte((byte)0);             stream.WriteByte((byte)0);             stream.Write(bytes' 0' byteCount);             break;           case 7:             stream.WriteByte((byte)((datatype << 5) | 27));             stream.WriteByte((byte)0);             stream.Write(bytes' 0' byteCount);             break;           case 8:             stream.WriteByte((byte)((datatype << 5) | 27));             stream.Write(bytes' 0' byteCount);             break;           default: stream.WriteByte((datatype == 0) ? (byte)0xc2 : (byte)0xc3);             WritePositiveInt(2' byteCount' stream);             stream.Write(bytes' 0' byteCount);             break;         }       }
Magic Number,PeterO.Cbor,CBORObject,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORObject.cs,Write,The following statement contains a magic number: if (bigint.CompareTo(Int64MaxValue) <= 0) {         // If the big integer is representable as a long and in         // major type 0 or 1' write that major type         // instead of as a bignum         var ui = (long)(EInteger)bigint;         WritePositiveInt64(datatype' ui' stream);       } else {         // Get a byte array of the big integer's value'         // since shifting and doing AND operations is         // slow with large BigIntegers         byte[] bytes = bigint.ToBytes(true);         int byteCount = bytes.Length;         while (byteCount > 0 && bytes[byteCount - 1] == 0) {           // Ignore trailing zero bytes           --byteCount;         }         if (byteCount != 0) {           int half = byteCount >> 1;           int right = byteCount - 1;           for (var i = 0; i < half; ++i' --right) {             byte value = bytes[i];             bytes[i] = bytes[right];             bytes[right] = value;           }         }         switch (byteCount) {           case 0:             stream.WriteByte((byte)(datatype << 5));             return;           case 1:             WritePositiveInt(datatype' ((int)bytes[0]) & 0xff' stream);             break;           case 2:             stream.WriteByte((byte)((datatype << 5) | 25));             stream.Write(bytes' 0' byteCount);             break;           case 3:             stream.WriteByte((byte)((datatype << 5) | 26));             stream.WriteByte((byte)0);             stream.Write(bytes' 0' byteCount);             break;           case 4:             stream.WriteByte((byte)((datatype << 5) | 26));             stream.Write(bytes' 0' byteCount);             break;           case 5:             stream.WriteByte((byte)((datatype << 5) | 27));             stream.WriteByte((byte)0);             stream.WriteByte((byte)0);             stream.WriteByte((byte)0);             stream.Write(bytes' 0' byteCount);             break;           case 6:             stream.WriteByte((byte)((datatype << 5) | 27));             stream.WriteByte((byte)0);             stream.WriteByte((byte)0);             stream.Write(bytes' 0' byteCount);             break;           case 7:             stream.WriteByte((byte)((datatype << 5) | 27));             stream.WriteByte((byte)0);             stream.Write(bytes' 0' byteCount);             break;           case 8:             stream.WriteByte((byte)((datatype << 5) | 27));             stream.Write(bytes' 0' byteCount);             break;           default: stream.WriteByte((datatype == 0) ? (byte)0xc2 : (byte)0xc3);             WritePositiveInt(2' byteCount' stream);             stream.Write(bytes' 0' byteCount);             break;         }       }
Magic Number,PeterO.Cbor,CBORObject,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORObject.cs,Write,The following statement contains a magic number: if (bigint.CompareTo(Int64MaxValue) <= 0) {         // If the big integer is representable as a long and in         // major type 0 or 1' write that major type         // instead of as a bignum         var ui = (long)(EInteger)bigint;         WritePositiveInt64(datatype' ui' stream);       } else {         // Get a byte array of the big integer's value'         // since shifting and doing AND operations is         // slow with large BigIntegers         byte[] bytes = bigint.ToBytes(true);         int byteCount = bytes.Length;         while (byteCount > 0 && bytes[byteCount - 1] == 0) {           // Ignore trailing zero bytes           --byteCount;         }         if (byteCount != 0) {           int half = byteCount >> 1;           int right = byteCount - 1;           for (var i = 0; i < half; ++i' --right) {             byte value = bytes[i];             bytes[i] = bytes[right];             bytes[right] = value;           }         }         switch (byteCount) {           case 0:             stream.WriteByte((byte)(datatype << 5));             return;           case 1:             WritePositiveInt(datatype' ((int)bytes[0]) & 0xff' stream);             break;           case 2:             stream.WriteByte((byte)((datatype << 5) | 25));             stream.Write(bytes' 0' byteCount);             break;           case 3:             stream.WriteByte((byte)((datatype << 5) | 26));             stream.WriteByte((byte)0);             stream.Write(bytes' 0' byteCount);             break;           case 4:             stream.WriteByte((byte)((datatype << 5) | 26));             stream.Write(bytes' 0' byteCount);             break;           case 5:             stream.WriteByte((byte)((datatype << 5) | 27));             stream.WriteByte((byte)0);             stream.WriteByte((byte)0);             stream.WriteByte((byte)0);             stream.Write(bytes' 0' byteCount);             break;           case 6:             stream.WriteByte((byte)((datatype << 5) | 27));             stream.WriteByte((byte)0);             stream.WriteByte((byte)0);             stream.Write(bytes' 0' byteCount);             break;           case 7:             stream.WriteByte((byte)((datatype << 5) | 27));             stream.WriteByte((byte)0);             stream.Write(bytes' 0' byteCount);             break;           case 8:             stream.WriteByte((byte)((datatype << 5) | 27));             stream.Write(bytes' 0' byteCount);             break;           default: stream.WriteByte((datatype == 0) ? (byte)0xc2 : (byte)0xc3);             WritePositiveInt(2' byteCount' stream);             stream.Write(bytes' 0' byteCount);             break;         }       }
Magic Number,PeterO.Cbor,CBORObject,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORObject.cs,Write,The following statement contains a magic number: if (bigint.CompareTo(Int64MaxValue) <= 0) {         // If the big integer is representable as a long and in         // major type 0 or 1' write that major type         // instead of as a bignum         var ui = (long)(EInteger)bigint;         WritePositiveInt64(datatype' ui' stream);       } else {         // Get a byte array of the big integer's value'         // since shifting and doing AND operations is         // slow with large BigIntegers         byte[] bytes = bigint.ToBytes(true);         int byteCount = bytes.Length;         while (byteCount > 0 && bytes[byteCount - 1] == 0) {           // Ignore trailing zero bytes           --byteCount;         }         if (byteCount != 0) {           int half = byteCount >> 1;           int right = byteCount - 1;           for (var i = 0; i < half; ++i' --right) {             byte value = bytes[i];             bytes[i] = bytes[right];             bytes[right] = value;           }         }         switch (byteCount) {           case 0:             stream.WriteByte((byte)(datatype << 5));             return;           case 1:             WritePositiveInt(datatype' ((int)bytes[0]) & 0xff' stream);             break;           case 2:             stream.WriteByte((byte)((datatype << 5) | 25));             stream.Write(bytes' 0' byteCount);             break;           case 3:             stream.WriteByte((byte)((datatype << 5) | 26));             stream.WriteByte((byte)0);             stream.Write(bytes' 0' byteCount);             break;           case 4:             stream.WriteByte((byte)((datatype << 5) | 26));             stream.Write(bytes' 0' byteCount);             break;           case 5:             stream.WriteByte((byte)((datatype << 5) | 27));             stream.WriteByte((byte)0);             stream.WriteByte((byte)0);             stream.WriteByte((byte)0);             stream.Write(bytes' 0' byteCount);             break;           case 6:             stream.WriteByte((byte)((datatype << 5) | 27));             stream.WriteByte((byte)0);             stream.WriteByte((byte)0);             stream.Write(bytes' 0' byteCount);             break;           case 7:             stream.WriteByte((byte)((datatype << 5) | 27));             stream.WriteByte((byte)0);             stream.Write(bytes' 0' byteCount);             break;           case 8:             stream.WriteByte((byte)((datatype << 5) | 27));             stream.Write(bytes' 0' byteCount);             break;           default: stream.WriteByte((datatype == 0) ? (byte)0xc2 : (byte)0xc3);             WritePositiveInt(2' byteCount' stream);             stream.Write(bytes' 0' byteCount);             break;         }       }
Magic Number,PeterO.Cbor,CBORObject,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORObject.cs,Write,The following statement contains a magic number: if (value < 24) {         stream.WriteByte((byte)(value | type));       } else if (value <= 0xff) {         byte[] bytes = { (byte)(24 | type)' (byte)(value & 0xff) };         stream.Write(bytes' 0' 2);       } else if (value <= 0xffff) {         byte[] bytes = { (byte)(25 | type)' (byte)((value >> 8) & 0xff)'           (byte)(value & 0xff) };         stream.Write(bytes' 0' 3);       } else {         byte[] bytes = { (byte)(26 | type)' (byte)((value >> 24) & 0xff)'           (byte)((value >> 16) & 0xff)' (byte)((value >> 8) & 0xff)'           (byte)(value & 0xff) };         stream.Write(bytes' 0' 5);       }
Magic Number,PeterO.Cbor,CBORObject,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORObject.cs,Write,The following statement contains a magic number: if (value < 24) {         stream.WriteByte((byte)(value | type));       } else if (value <= 0xff) {         byte[] bytes = { (byte)(24 | type)' (byte)(value & 0xff) };         stream.Write(bytes' 0' 2);       } else if (value <= 0xffff) {         byte[] bytes = { (byte)(25 | type)' (byte)((value >> 8) & 0xff)'           (byte)(value & 0xff) };         stream.Write(bytes' 0' 3);       } else {         byte[] bytes = { (byte)(26 | type)' (byte)((value >> 24) & 0xff)'           (byte)((value >> 16) & 0xff)' (byte)((value >> 8) & 0xff)'           (byte)(value & 0xff) };         stream.Write(bytes' 0' 5);       }
Magic Number,PeterO.Cbor,CBORObject,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORObject.cs,Write,The following statement contains a magic number: if (value < 24) {         stream.WriteByte((byte)(value | type));       } else if (value <= 0xff) {         byte[] bytes = { (byte)(24 | type)' (byte)(value & 0xff) };         stream.Write(bytes' 0' 2);       } else if (value <= 0xffff) {         byte[] bytes = { (byte)(25 | type)' (byte)((value >> 8) & 0xff)'           (byte)(value & 0xff) };         stream.Write(bytes' 0' 3);       } else {         byte[] bytes = { (byte)(26 | type)' (byte)((value >> 24) & 0xff)'           (byte)((value >> 16) & 0xff)' (byte)((value >> 8) & 0xff)'           (byte)(value & 0xff) };         stream.Write(bytes' 0' 5);       }
Magic Number,PeterO.Cbor,CBORObject,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORObject.cs,Write,The following statement contains a magic number: if (value < 24) {         stream.WriteByte((byte)(value | type));       } else if (value <= 0xff) {         byte[] bytes = { (byte)(24 | type)' (byte)(value & 0xff) };         stream.Write(bytes' 0' 2);       } else if (value <= 0xffff) {         byte[] bytes = { (byte)(25 | type)' (byte)((value >> 8) & 0xff)'           (byte)(value & 0xff) };         stream.Write(bytes' 0' 3);       } else {         byte[] bytes = { (byte)(26 | type)' (byte)((value >> 24) & 0xff)'           (byte)((value >> 16) & 0xff)' (byte)((value >> 8) & 0xff)'           (byte)(value & 0xff) };         stream.Write(bytes' 0' 5);       }
Magic Number,PeterO.Cbor,CBORObject,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORObject.cs,Write,The following statement contains a magic number: if (value < 24) {         stream.WriteByte((byte)(value | type));       } else if (value <= 0xff) {         byte[] bytes = { (byte)(24 | type)' (byte)(value & 0xff) };         stream.Write(bytes' 0' 2);       } else if (value <= 0xffff) {         byte[] bytes = { (byte)(25 | type)' (byte)((value >> 8) & 0xff)'           (byte)(value & 0xff) };         stream.Write(bytes' 0' 3);       } else {         byte[] bytes = { (byte)(26 | type)' (byte)((value >> 24) & 0xff)'           (byte)((value >> 16) & 0xff)' (byte)((value >> 8) & 0xff)'           (byte)(value & 0xff) };         stream.Write(bytes' 0' 5);       }
Magic Number,PeterO.Cbor,CBORObject,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORObject.cs,Write,The following statement contains a magic number: if (value < 24) {         stream.WriteByte((byte)(value | type));       } else if (value <= 0xff) {         byte[] bytes = { (byte)(24 | type)' (byte)(value & 0xff) };         stream.Write(bytes' 0' 2);       } else if (value <= 0xffff) {         byte[] bytes = { (byte)(25 | type)' (byte)((value >> 8) & 0xff)'           (byte)(value & 0xff) };         stream.Write(bytes' 0' 3);       } else {         byte[] bytes = { (byte)(26 | type)' (byte)((value >> 24) & 0xff)'           (byte)((value >> 16) & 0xff)' (byte)((value >> 8) & 0xff)'           (byte)(value & 0xff) };         stream.Write(bytes' 0' 5);       }
Magic Number,PeterO.Cbor,CBORObject,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORObject.cs,Write,The following statement contains a magic number: if (value < 24) {         stream.WriteByte((byte)(value | type));       } else if (value <= 0xff) {         byte[] bytes = { (byte)(24 | type)' (byte)(value & 0xff) };         stream.Write(bytes' 0' 2);       } else if (value <= 0xffff) {         byte[] bytes = { (byte)(25 | type)' (byte)((value >> 8) & 0xff)'           (byte)(value & 0xff) };         stream.Write(bytes' 0' 3);       } else {         byte[] bytes = { (byte)(26 | type)' (byte)((value >> 24) & 0xff)'           (byte)((value >> 16) & 0xff)' (byte)((value >> 8) & 0xff)'           (byte)(value & 0xff) };         stream.Write(bytes' 0' 5);       }
Magic Number,PeterO.Cbor,CBORObject,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORObject.cs,Write,The following statement contains a magic number: if (value < 24) {         stream.WriteByte((byte)(value | type));       } else if (value <= 0xff) {         byte[] bytes = { (byte)(24 | type)' (byte)(value & 0xff) };         stream.Write(bytes' 0' 2);       } else if (value <= 0xffff) {         byte[] bytes = { (byte)(25 | type)' (byte)((value >> 8) & 0xff)'           (byte)(value & 0xff) };         stream.Write(bytes' 0' 3);       } else {         byte[] bytes = { (byte)(26 | type)' (byte)((value >> 24) & 0xff)'           (byte)((value >> 16) & 0xff)' (byte)((value >> 8) & 0xff)'           (byte)(value & 0xff) };         stream.Write(bytes' 0' 5);       }
Magic Number,PeterO.Cbor,CBORObject,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORObject.cs,Write,The following statement contains a magic number: if (value < 24) {         stream.WriteByte((byte)(value | type));       } else if (value <= 0xff) {         byte[] bytes = { (byte)(24 | type)' (byte)(value & 0xff) };         stream.Write(bytes' 0' 2);       } else if (value <= 0xffff) {         byte[] bytes = { (byte)(25 | type)' (byte)((value >> 8) & 0xff)'           (byte)(value & 0xff) };         stream.Write(bytes' 0' 3);       } else {         byte[] bytes = { (byte)(26 | type)' (byte)((value >> 24) & 0xff)'           (byte)((value >> 16) & 0xff)' (byte)((value >> 8) & 0xff)'           (byte)(value & 0xff) };         stream.Write(bytes' 0' 5);       }
Magic Number,PeterO.Cbor,CBORObject,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORObject.cs,Write,The following statement contains a magic number: if (value < 24) {         stream.WriteByte((byte)(value | type));       } else if (value <= 0xff) {         byte[] bytes = { (byte)(24 | type)' (byte)(value & 0xff) };         stream.Write(bytes' 0' 2);       } else if (value <= 0xffff) {         byte[] bytes = { (byte)(25 | type)' (byte)((value >> 8) & 0xff)'           (byte)(value & 0xff) };         stream.Write(bytes' 0' 3);       } else {         byte[] bytes = { (byte)(26 | type)' (byte)((value >> 24) & 0xff)'           (byte)((value >> 16) & 0xff)' (byte)((value >> 8) & 0xff)'           (byte)(value & 0xff) };         stream.Write(bytes' 0' 5);       }
Magic Number,PeterO.Cbor,CBORObject,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORObject.cs,Write,The following statement contains a magic number: if (value < 24) {         stream.WriteByte((byte)(value | type));       } else if (value <= 0xff) {         byte[] bytes = { (byte)(24 | type)' (byte)(value & 0xff) };         stream.Write(bytes' 0' 2);       } else if (value <= 0xffff) {         byte[] bytes = { (byte)(25 | type)' (byte)((value >> 8) & 0xff)'           (byte)(value & 0xff) };         stream.Write(bytes' 0' 3);       } else {         byte[] bytes = { (byte)(26 | type)' (byte)((value >> 24) & 0xff)'           (byte)((value >> 16) & 0xff)' (byte)((value >> 8) & 0xff)'           (byte)(value & 0xff) };         stream.Write(bytes' 0' 5);       }
Magic Number,PeterO.Cbor,CBORObject,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORObject.cs,Write,The following statement contains a magic number: if ((((int)value) & 0xff) < 24) {         stream.WriteByte(value);       } else {         stream.WriteByte((byte)24);         stream.WriteByte(value);       }
Magic Number,PeterO.Cbor,CBORObject,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORObject.cs,Write,The following statement contains a magic number: if ((((int)value) & 0xff) < 24) {         stream.WriteByte(value);       } else {         stream.WriteByte((byte)24);         stream.WriteByte(value);       }
Magic Number,PeterO.Cbor,CBORObject,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORObject.cs,Write,The following statement contains a magic number: byte[] data = { (byte)0xfa' (byte)((bits >> 24) & 0xff)'         (byte)((bits >> 16) & 0xff)' (byte)((bits >> 8) & 0xff)'         (byte)(bits & 0xff) };
Magic Number,PeterO.Cbor,CBORObject,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORObject.cs,Write,The following statement contains a magic number: byte[] data = { (byte)0xfa' (byte)((bits >> 24) & 0xff)'         (byte)((bits >> 16) & 0xff)' (byte)((bits >> 8) & 0xff)'         (byte)(bits & 0xff) };
Magic Number,PeterO.Cbor,CBORObject,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORObject.cs,Write,The following statement contains a magic number: byte[] data = { (byte)0xfa' (byte)((bits >> 24) & 0xff)'         (byte)((bits >> 16) & 0xff)' (byte)((bits >> 8) & 0xff)'         (byte)(bits & 0xff) };
Magic Number,PeterO.Cbor,CBORObject,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORObject.cs,Write,The following statement contains a magic number: s.Write(data' 0' 5);
Magic Number,PeterO.Cbor,CBORObject,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORObject.cs,Write,The following statement contains a magic number: byte[] data = { (byte)0xfb'         (byte)((bits >> 56) & 0xff)' (byte)((bits >> 48) & 0xff)'         (byte)((bits >> 40) & 0xff)' (byte)((bits >> 32) & 0xff)'         (byte)((bits >> 24) & 0xff)' (byte)((bits >> 16) & 0xff)'         (byte)((bits >> 8) & 0xff)' (byte)(bits & 0xff) };
Magic Number,PeterO.Cbor,CBORObject,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORObject.cs,Write,The following statement contains a magic number: byte[] data = { (byte)0xfb'         (byte)((bits >> 56) & 0xff)' (byte)((bits >> 48) & 0xff)'         (byte)((bits >> 40) & 0xff)' (byte)((bits >> 32) & 0xff)'         (byte)((bits >> 24) & 0xff)' (byte)((bits >> 16) & 0xff)'         (byte)((bits >> 8) & 0xff)' (byte)(bits & 0xff) };
Magic Number,PeterO.Cbor,CBORObject,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORObject.cs,Write,The following statement contains a magic number: byte[] data = { (byte)0xfb'         (byte)((bits >> 56) & 0xff)' (byte)((bits >> 48) & 0xff)'         (byte)((bits >> 40) & 0xff)' (byte)((bits >> 32) & 0xff)'         (byte)((bits >> 24) & 0xff)' (byte)((bits >> 16) & 0xff)'         (byte)((bits >> 8) & 0xff)' (byte)(bits & 0xff) };
Magic Number,PeterO.Cbor,CBORObject,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORObject.cs,Write,The following statement contains a magic number: byte[] data = { (byte)0xfb'         (byte)((bits >> 56) & 0xff)' (byte)((bits >> 48) & 0xff)'         (byte)((bits >> 40) & 0xff)' (byte)((bits >> 32) & 0xff)'         (byte)((bits >> 24) & 0xff)' (byte)((bits >> 16) & 0xff)'         (byte)((bits >> 8) & 0xff)' (byte)(bits & 0xff) };
Magic Number,PeterO.Cbor,CBORObject,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORObject.cs,Write,The following statement contains a magic number: byte[] data = { (byte)0xfb'         (byte)((bits >> 56) & 0xff)' (byte)((bits >> 48) & 0xff)'         (byte)((bits >> 40) & 0xff)' (byte)((bits >> 32) & 0xff)'         (byte)((bits >> 24) & 0xff)' (byte)((bits >> 16) & 0xff)'         (byte)((bits >> 8) & 0xff)' (byte)(bits & 0xff) };
Magic Number,PeterO.Cbor,CBORObject,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORObject.cs,Write,The following statement contains a magic number: byte[] data = { (byte)0xfb'         (byte)((bits >> 56) & 0xff)' (byte)((bits >> 48) & 0xff)'         (byte)((bits >> 40) & 0xff)' (byte)((bits >> 32) & 0xff)'         (byte)((bits >> 24) & 0xff)' (byte)((bits >> 16) & 0xff)'         (byte)((bits >> 8) & 0xff)' (byte)(bits & 0xff) };
Magic Number,PeterO.Cbor,CBORObject,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORObject.cs,Write,The following statement contains a magic number: byte[] data = { (byte)0xfb'         (byte)((bits >> 56) & 0xff)' (byte)((bits >> 48) & 0xff)'         (byte)((bits >> 40) & 0xff)' (byte)((bits >> 32) & 0xff)'         (byte)((bits >> 24) & 0xff)' (byte)((bits >> 16) & 0xff)'         (byte)((bits >> 8) & 0xff)' (byte)(bits & 0xff) };
Magic Number,PeterO.Cbor,CBORObject,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORObject.cs,Write,The following statement contains a magic number: stream.Write(data' 0' 9);
Magic Number,PeterO.Cbor,CBORObject,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORObject.cs,Write,The following statement contains a magic number: if (data != null) {         WritePositiveInt(3' data.Length' output);         output.Write(data' 0' data.Length);         return;       }
Magic Number,PeterO.Cbor,CBORObject,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORObject.cs,AsByte,The following statement contains a magic number: return (byte)this.AsInt32(0' 255);
Magic Number,PeterO.Cbor,CBORObject,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORObject.cs,CompareTo,The following statement contains a magic number: if (typeA == CBORObjectTypeSimpleValue) {         if ((int)objA == 20) {  // false           simpleValueA = 2;         } else if ((int)objA == 21) {  // true           simpleValueA = 3;         } else if ((int)objA == 22) {  // null           simpleValueA = 1;         } else if ((int)objA == 23) {  // undefined           simpleValueA = 0;         }       }
Magic Number,PeterO.Cbor,CBORObject,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORObject.cs,CompareTo,The following statement contains a magic number: if (typeA == CBORObjectTypeSimpleValue) {         if ((int)objA == 20) {  // false           simpleValueA = 2;         } else if ((int)objA == 21) {  // true           simpleValueA = 3;         } else if ((int)objA == 22) {  // null           simpleValueA = 1;         } else if ((int)objA == 23) {  // undefined           simpleValueA = 0;         }       }
Magic Number,PeterO.Cbor,CBORObject,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORObject.cs,CompareTo,The following statement contains a magic number: if (typeA == CBORObjectTypeSimpleValue) {         if ((int)objA == 20) {  // false           simpleValueA = 2;         } else if ((int)objA == 21) {  // true           simpleValueA = 3;         } else if ((int)objA == 22) {  // null           simpleValueA = 1;         } else if ((int)objA == 23) {  // undefined           simpleValueA = 0;         }       }
Magic Number,PeterO.Cbor,CBORObject,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORObject.cs,CompareTo,The following statement contains a magic number: if (typeA == CBORObjectTypeSimpleValue) {         if ((int)objA == 20) {  // false           simpleValueA = 2;         } else if ((int)objA == 21) {  // true           simpleValueA = 3;         } else if ((int)objA == 22) {  // null           simpleValueA = 1;         } else if ((int)objA == 23) {  // undefined           simpleValueA = 0;         }       }
Magic Number,PeterO.Cbor,CBORObject,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORObject.cs,CompareTo,The following statement contains a magic number: if (typeA == CBORObjectTypeSimpleValue) {         if ((int)objA == 20) {  // false           simpleValueA = 2;         } else if ((int)objA == 21) {  // true           simpleValueA = 3;         } else if ((int)objA == 22) {  // null           simpleValueA = 1;         } else if ((int)objA == 23) {  // undefined           simpleValueA = 0;         }       }
Magic Number,PeterO.Cbor,CBORObject,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORObject.cs,CompareTo,The following statement contains a magic number: if (typeA == CBORObjectTypeSimpleValue) {         if ((int)objA == 20) {  // false           simpleValueA = 2;         } else if ((int)objA == 21) {  // true           simpleValueA = 3;         } else if ((int)objA == 22) {  // null           simpleValueA = 1;         } else if ((int)objA == 23) {  // undefined           simpleValueA = 0;         }       }
Magic Number,PeterO.Cbor,CBORObject,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORObject.cs,CompareTo,The following statement contains a magic number: if (typeB == CBORObjectTypeSimpleValue) {         if ((int)objB == 20) {  // false           simpleValueB = 2;         } else if ((int)objB == 21) {  // true           simpleValueB = 3;         } else if ((int)objB == 22) {  // null           simpleValueB = 1;         } else if ((int)objB == 23) {  // undefined           simpleValueB = 0;         }       }
Magic Number,PeterO.Cbor,CBORObject,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORObject.cs,CompareTo,The following statement contains a magic number: if (typeB == CBORObjectTypeSimpleValue) {         if ((int)objB == 20) {  // false           simpleValueB = 2;         } else if ((int)objB == 21) {  // true           simpleValueB = 3;         } else if ((int)objB == 22) {  // null           simpleValueB = 1;         } else if ((int)objB == 23) {  // undefined           simpleValueB = 0;         }       }
Magic Number,PeterO.Cbor,CBORObject,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORObject.cs,CompareTo,The following statement contains a magic number: if (typeB == CBORObjectTypeSimpleValue) {         if ((int)objB == 20) {  // false           simpleValueB = 2;         } else if ((int)objB == 21) {  // true           simpleValueB = 3;         } else if ((int)objB == 22) {  // null           simpleValueB = 1;         } else if ((int)objB == 23) {  // undefined           simpleValueB = 0;         }       }
Magic Number,PeterO.Cbor,CBORObject,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORObject.cs,CompareTo,The following statement contains a magic number: if (typeB == CBORObjectTypeSimpleValue) {         if ((int)objB == 20) {  // false           simpleValueB = 2;         } else if ((int)objB == 21) {  // true           simpleValueB = 3;         } else if ((int)objB == 22) {  // null           simpleValueB = 1;         } else if ((int)objB == 23) {  // undefined           simpleValueB = 0;         }       }
Magic Number,PeterO.Cbor,CBORObject,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORObject.cs,CompareTo,The following statement contains a magic number: if (typeB == CBORObjectTypeSimpleValue) {         if ((int)objB == 20) {  // false           simpleValueB = 2;         } else if ((int)objB == 21) {  // true           simpleValueB = 3;         } else if ((int)objB == 22) {  // null           simpleValueB = 1;         } else if ((int)objB == 23) {  // undefined           simpleValueB = 0;         }       }
Magic Number,PeterO.Cbor,CBORObject,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORObject.cs,CompareTo,The following statement contains a magic number: if (typeB == CBORObjectTypeSimpleValue) {         if ((int)objB == 20) {  // false           simpleValueB = 2;         } else if ((int)objB == 21) {  // true           simpleValueB = 3;         } else if ((int)objB == 22) {  // null           simpleValueB = 1;         } else if ((int)objB == 23) {  // undefined           simpleValueB = 0;         }       }
Magic Number,PeterO.Cbor,CBORObject,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORObject.cs,CompareTo,The following statement contains a magic number: if (simpleValueA >= 0 || simpleValueB >= 0) {         if (simpleValueB < 0) {           return -1;  // B is not true' false' null' or undefined' so A is less         }         if (simpleValueA < 0) {           return 1;         }         cmp = (simpleValueA == simpleValueB) ? 0 : ((simpleValueA <                     simpleValueB) ? -1 : 1);       } else if (typeA == typeB) {         switch (typeA) {           case CBORObjectTypeInteger: {               var a = (long)objA;               var b = (long)objB;               cmp = (a == b) ? 0 : ((a < b) ? -1 : 1);               break;             }           case CBORObjectTypeSingle: {               var a = (float)objA;               var b = (float)objB;               // Treat NaN as greater than all other numbers               cmp = Single.IsNaN(a) ? (Single.IsNaN(b) ? 0 : 1) :                 (Single.IsNaN(b) ? (-1) : ((a == b) ? 0 : ((a < b) ? -1 :                     1)));               break;             }           case CBORObjectTypeBigInteger: {               var bigintA = (EInteger)objA;               var bigintB = (EInteger)objB;               cmp = bigintA.CompareTo(bigintB);               break;             }           case CBORObjectTypeDouble: {               var a = (double)objA;               var b = (double)objB;               // Treat NaN as greater than all other numbers               cmp = Double.IsNaN(a) ? (Double.IsNaN(b) ? 0 : 1) :                 (Double.IsNaN(b) ? (-1) : ((a == b) ? 0 : ((a < b) ? -1 :                     1)));               break;             }           case CBORObjectTypeExtendedDecimal: {               cmp = ((EDecimal)objA).CompareTo((EDecimal)objB);               break;             }           case CBORObjectTypeExtendedFloat: {               cmp = ((EFloat)objA).CompareTo(                 (EFloat)objB);               break;             }           case CBORObjectTypeExtendedRational: {               cmp = ((ERational)objA).CompareTo(                 (ERational)objB);               break;             }           case CBORObjectTypeByteString: {               cmp = CBORUtilities.ByteArrayCompare((byte[])objA' (byte[])objB);               break;             }           case CBORObjectTypeTextString: {               cmp = DataUtilities.CodePointCompare(                 (string)objA'                 (string)objB);               break;             }           case CBORObjectTypeArray: {               cmp = ListCompare(                 (List<CBORObject>)objA'                 (List<CBORObject>)objB);               break;             }           case CBORObjectTypeMap: {               cmp = MapCompare(                 (IDictionary<CBORObject' CBORObject>)objA'                 (IDictionary<CBORObject' CBORObject>)objB);               break;             }           case CBORObjectTypeSimpleValue: {               var valueA = (int)objA;               var valueB = (int)objB;               cmp = (valueA == valueB) ? 0 : ((valueA < valueB) ? -1 : 1);               break;             }           default: throw new ArgumentException("Unexpected data type");         }       } else {         int typeOrderA = ValueNumberTypeOrder[typeA];         int typeOrderB = ValueNumberTypeOrder[typeB];         // Check whether general types are different         // (treating number types the same)         if (typeOrderA != typeOrderB) {           return (typeOrderA < typeOrderB) ? -1 : 1;         }         // At this point' both types should be number types. #if DEBUG         if (typeOrderA != 0) {           throw new ArgumentException("doesn't satisfy typeOrderA == 0");         }         if (typeOrderB != 0) {           throw new ArgumentException("doesn't satisfy typeOrderB == 0");         } #endif         int s1 = GetSignInternal(typeA' objA);         int s2 = GetSignInternal(typeB' objB);         if (s1 != s2 && s1 != 2 && s2 != 2) {           // if both types are numbers           // and their signs are different           return (s1 < s2) ? -1 : 1;         }         if (s1 == 2 && s2 == 2) {           // both are NaN           cmp = 0;         } else if (s1 == 2) {           // first object is NaN           return 1;         } else if (s2 == 2) {           // second object is NaN           return -1;         } else {           // DebugUtility.Log("a=" + this + " b=" + other);           if (typeA == CBORObjectTypeExtendedRational) {             ERational e1 = NumberInterfaces[typeA].AsExtendedRational(objA);             if (typeB == CBORObjectTypeExtendedDecimal) {               EDecimal e2 = NumberInterfaces[typeB].AsExtendedDecimal(objB);               cmp = e1.CompareToDecimal(e2);             } else {               EFloat e2 = NumberInterfaces[typeB].AsExtendedFloat(objB);               cmp = e1.CompareToBinary(e2);             }           } else if (typeB == CBORObjectTypeExtendedRational) {             ERational e2 = NumberInterfaces[typeB].AsExtendedRational(objB);             if (typeA == CBORObjectTypeExtendedDecimal) {               EDecimal e1 = NumberInterfaces[typeA].AsExtendedDecimal(objA);               cmp = e2.CompareToDecimal(e1);               cmp = -cmp;             } else {               EFloat e1 = NumberInterfaces[typeA].AsExtendedFloat(objA);               cmp = e2.CompareToBinary(e1);               cmp = -cmp;             }           } else if (typeA == CBORObjectTypeExtendedDecimal ||                     typeB == CBORObjectTypeExtendedDecimal) {             EDecimal e1 = null;             EDecimal e2 = null;             if (typeA == CBORObjectTypeExtendedFloat) {               var ef1 = (EFloat)objA;               e2 = (EDecimal)objB;               cmp = e2.CompareToBinary(ef1);               cmp = -cmp;             } else if (typeB == CBORObjectTypeExtendedFloat) {               var ef1 = (EFloat)objB;               e2 = (EDecimal)objA;               cmp = e2.CompareToBinary(ef1);             } else {               e1 = NumberInterfaces[typeA].AsExtendedDecimal(objA);               e2 = NumberInterfaces[typeB].AsExtendedDecimal(objB);               cmp = e1.CompareTo(e2);             }           } else if (typeA == CBORObjectTypeExtendedFloat || typeB ==                     CBORObjectTypeExtendedFloat ||                     typeA == CBORObjectTypeDouble || typeB ==                     CBORObjectTypeDouble ||                     typeA == CBORObjectTypeSingle || typeB ==                     CBORObjectTypeSingle) {             EFloat e1 = NumberInterfaces[typeA].AsExtendedFloat(objA);             EFloat e2 = NumberInterfaces[typeB].AsExtendedFloat(objB);             cmp = e1.CompareTo(e2);           } else {             EInteger b1 = NumberInterfaces[typeA].AsEInteger(objA);             EInteger b2 = NumberInterfaces[typeB].AsEInteger(objB);             cmp = b1.CompareTo(b2);           }         }       }
Magic Number,PeterO.Cbor,CBORObject,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORObject.cs,CompareTo,The following statement contains a magic number: if (simpleValueA >= 0 || simpleValueB >= 0) {         if (simpleValueB < 0) {           return -1;  // B is not true' false' null' or undefined' so A is less         }         if (simpleValueA < 0) {           return 1;         }         cmp = (simpleValueA == simpleValueB) ? 0 : ((simpleValueA <                     simpleValueB) ? -1 : 1);       } else if (typeA == typeB) {         switch (typeA) {           case CBORObjectTypeInteger: {               var a = (long)objA;               var b = (long)objB;               cmp = (a == b) ? 0 : ((a < b) ? -1 : 1);               break;             }           case CBORObjectTypeSingle: {               var a = (float)objA;               var b = (float)objB;               // Treat NaN as greater than all other numbers               cmp = Single.IsNaN(a) ? (Single.IsNaN(b) ? 0 : 1) :                 (Single.IsNaN(b) ? (-1) : ((a == b) ? 0 : ((a < b) ? -1 :                     1)));               break;             }           case CBORObjectTypeBigInteger: {               var bigintA = (EInteger)objA;               var bigintB = (EInteger)objB;               cmp = bigintA.CompareTo(bigintB);               break;             }           case CBORObjectTypeDouble: {               var a = (double)objA;               var b = (double)objB;               // Treat NaN as greater than all other numbers               cmp = Double.IsNaN(a) ? (Double.IsNaN(b) ? 0 : 1) :                 (Double.IsNaN(b) ? (-1) : ((a == b) ? 0 : ((a < b) ? -1 :                     1)));               break;             }           case CBORObjectTypeExtendedDecimal: {               cmp = ((EDecimal)objA).CompareTo((EDecimal)objB);               break;             }           case CBORObjectTypeExtendedFloat: {               cmp = ((EFloat)objA).CompareTo(                 (EFloat)objB);               break;             }           case CBORObjectTypeExtendedRational: {               cmp = ((ERational)objA).CompareTo(                 (ERational)objB);               break;             }           case CBORObjectTypeByteString: {               cmp = CBORUtilities.ByteArrayCompare((byte[])objA' (byte[])objB);               break;             }           case CBORObjectTypeTextString: {               cmp = DataUtilities.CodePointCompare(                 (string)objA'                 (string)objB);               break;             }           case CBORObjectTypeArray: {               cmp = ListCompare(                 (List<CBORObject>)objA'                 (List<CBORObject>)objB);               break;             }           case CBORObjectTypeMap: {               cmp = MapCompare(                 (IDictionary<CBORObject' CBORObject>)objA'                 (IDictionary<CBORObject' CBORObject>)objB);               break;             }           case CBORObjectTypeSimpleValue: {               var valueA = (int)objA;               var valueB = (int)objB;               cmp = (valueA == valueB) ? 0 : ((valueA < valueB) ? -1 : 1);               break;             }           default: throw new ArgumentException("Unexpected data type");         }       } else {         int typeOrderA = ValueNumberTypeOrder[typeA];         int typeOrderB = ValueNumberTypeOrder[typeB];         // Check whether general types are different         // (treating number types the same)         if (typeOrderA != typeOrderB) {           return (typeOrderA < typeOrderB) ? -1 : 1;         }         // At this point' both types should be number types. #if DEBUG         if (typeOrderA != 0) {           throw new ArgumentException("doesn't satisfy typeOrderA == 0");         }         if (typeOrderB != 0) {           throw new ArgumentException("doesn't satisfy typeOrderB == 0");         } #endif         int s1 = GetSignInternal(typeA' objA);         int s2 = GetSignInternal(typeB' objB);         if (s1 != s2 && s1 != 2 && s2 != 2) {           // if both types are numbers           // and their signs are different           return (s1 < s2) ? -1 : 1;         }         if (s1 == 2 && s2 == 2) {           // both are NaN           cmp = 0;         } else if (s1 == 2) {           // first object is NaN           return 1;         } else if (s2 == 2) {           // second object is NaN           return -1;         } else {           // DebugUtility.Log("a=" + this + " b=" + other);           if (typeA == CBORObjectTypeExtendedRational) {             ERational e1 = NumberInterfaces[typeA].AsExtendedRational(objA);             if (typeB == CBORObjectTypeExtendedDecimal) {               EDecimal e2 = NumberInterfaces[typeB].AsExtendedDecimal(objB);               cmp = e1.CompareToDecimal(e2);             } else {               EFloat e2 = NumberInterfaces[typeB].AsExtendedFloat(objB);               cmp = e1.CompareToBinary(e2);             }           } else if (typeB == CBORObjectTypeExtendedRational) {             ERational e2 = NumberInterfaces[typeB].AsExtendedRational(objB);             if (typeA == CBORObjectTypeExtendedDecimal) {               EDecimal e1 = NumberInterfaces[typeA].AsExtendedDecimal(objA);               cmp = e2.CompareToDecimal(e1);               cmp = -cmp;             } else {               EFloat e1 = NumberInterfaces[typeA].AsExtendedFloat(objA);               cmp = e2.CompareToBinary(e1);               cmp = -cmp;             }           } else if (typeA == CBORObjectTypeExtendedDecimal ||                     typeB == CBORObjectTypeExtendedDecimal) {             EDecimal e1 = null;             EDecimal e2 = null;             if (typeA == CBORObjectTypeExtendedFloat) {               var ef1 = (EFloat)objA;               e2 = (EDecimal)objB;               cmp = e2.CompareToBinary(ef1);               cmp = -cmp;             } else if (typeB == CBORObjectTypeExtendedFloat) {               var ef1 = (EFloat)objB;               e2 = (EDecimal)objA;               cmp = e2.CompareToBinary(ef1);             } else {               e1 = NumberInterfaces[typeA].AsExtendedDecimal(objA);               e2 = NumberInterfaces[typeB].AsExtendedDecimal(objB);               cmp = e1.CompareTo(e2);             }           } else if (typeA == CBORObjectTypeExtendedFloat || typeB ==                     CBORObjectTypeExtendedFloat ||                     typeA == CBORObjectTypeDouble || typeB ==                     CBORObjectTypeDouble ||                     typeA == CBORObjectTypeSingle || typeB ==                     CBORObjectTypeSingle) {             EFloat e1 = NumberInterfaces[typeA].AsExtendedFloat(objA);             EFloat e2 = NumberInterfaces[typeB].AsExtendedFloat(objB);             cmp = e1.CompareTo(e2);           } else {             EInteger b1 = NumberInterfaces[typeA].AsEInteger(objA);             EInteger b2 = NumberInterfaces[typeB].AsEInteger(objB);             cmp = b1.CompareTo(b2);           }         }       }
Magic Number,PeterO.Cbor,CBORObject,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORObject.cs,CompareTo,The following statement contains a magic number: if (simpleValueA >= 0 || simpleValueB >= 0) {         if (simpleValueB < 0) {           return -1;  // B is not true' false' null' or undefined' so A is less         }         if (simpleValueA < 0) {           return 1;         }         cmp = (simpleValueA == simpleValueB) ? 0 : ((simpleValueA <                     simpleValueB) ? -1 : 1);       } else if (typeA == typeB) {         switch (typeA) {           case CBORObjectTypeInteger: {               var a = (long)objA;               var b = (long)objB;               cmp = (a == b) ? 0 : ((a < b) ? -1 : 1);               break;             }           case CBORObjectTypeSingle: {               var a = (float)objA;               var b = (float)objB;               // Treat NaN as greater than all other numbers               cmp = Single.IsNaN(a) ? (Single.IsNaN(b) ? 0 : 1) :                 (Single.IsNaN(b) ? (-1) : ((a == b) ? 0 : ((a < b) ? -1 :                     1)));               break;             }           case CBORObjectTypeBigInteger: {               var bigintA = (EInteger)objA;               var bigintB = (EInteger)objB;               cmp = bigintA.CompareTo(bigintB);               break;             }           case CBORObjectTypeDouble: {               var a = (double)objA;               var b = (double)objB;               // Treat NaN as greater than all other numbers               cmp = Double.IsNaN(a) ? (Double.IsNaN(b) ? 0 : 1) :                 (Double.IsNaN(b) ? (-1) : ((a == b) ? 0 : ((a < b) ? -1 :                     1)));               break;             }           case CBORObjectTypeExtendedDecimal: {               cmp = ((EDecimal)objA).CompareTo((EDecimal)objB);               break;             }           case CBORObjectTypeExtendedFloat: {               cmp = ((EFloat)objA).CompareTo(                 (EFloat)objB);               break;             }           case CBORObjectTypeExtendedRational: {               cmp = ((ERational)objA).CompareTo(                 (ERational)objB);               break;             }           case CBORObjectTypeByteString: {               cmp = CBORUtilities.ByteArrayCompare((byte[])objA' (byte[])objB);               break;             }           case CBORObjectTypeTextString: {               cmp = DataUtilities.CodePointCompare(                 (string)objA'                 (string)objB);               break;             }           case CBORObjectTypeArray: {               cmp = ListCompare(                 (List<CBORObject>)objA'                 (List<CBORObject>)objB);               break;             }           case CBORObjectTypeMap: {               cmp = MapCompare(                 (IDictionary<CBORObject' CBORObject>)objA'                 (IDictionary<CBORObject' CBORObject>)objB);               break;             }           case CBORObjectTypeSimpleValue: {               var valueA = (int)objA;               var valueB = (int)objB;               cmp = (valueA == valueB) ? 0 : ((valueA < valueB) ? -1 : 1);               break;             }           default: throw new ArgumentException("Unexpected data type");         }       } else {         int typeOrderA = ValueNumberTypeOrder[typeA];         int typeOrderB = ValueNumberTypeOrder[typeB];         // Check whether general types are different         // (treating number types the same)         if (typeOrderA != typeOrderB) {           return (typeOrderA < typeOrderB) ? -1 : 1;         }         // At this point' both types should be number types. #if DEBUG         if (typeOrderA != 0) {           throw new ArgumentException("doesn't satisfy typeOrderA == 0");         }         if (typeOrderB != 0) {           throw new ArgumentException("doesn't satisfy typeOrderB == 0");         } #endif         int s1 = GetSignInternal(typeA' objA);         int s2 = GetSignInternal(typeB' objB);         if (s1 != s2 && s1 != 2 && s2 != 2) {           // if both types are numbers           // and their signs are different           return (s1 < s2) ? -1 : 1;         }         if (s1 == 2 && s2 == 2) {           // both are NaN           cmp = 0;         } else if (s1 == 2) {           // first object is NaN           return 1;         } else if (s2 == 2) {           // second object is NaN           return -1;         } else {           // DebugUtility.Log("a=" + this + " b=" + other);           if (typeA == CBORObjectTypeExtendedRational) {             ERational e1 = NumberInterfaces[typeA].AsExtendedRational(objA);             if (typeB == CBORObjectTypeExtendedDecimal) {               EDecimal e2 = NumberInterfaces[typeB].AsExtendedDecimal(objB);               cmp = e1.CompareToDecimal(e2);             } else {               EFloat e2 = NumberInterfaces[typeB].AsExtendedFloat(objB);               cmp = e1.CompareToBinary(e2);             }           } else if (typeB == CBORObjectTypeExtendedRational) {             ERational e2 = NumberInterfaces[typeB].AsExtendedRational(objB);             if (typeA == CBORObjectTypeExtendedDecimal) {               EDecimal e1 = NumberInterfaces[typeA].AsExtendedDecimal(objA);               cmp = e2.CompareToDecimal(e1);               cmp = -cmp;             } else {               EFloat e1 = NumberInterfaces[typeA].AsExtendedFloat(objA);               cmp = e2.CompareToBinary(e1);               cmp = -cmp;             }           } else if (typeA == CBORObjectTypeExtendedDecimal ||                     typeB == CBORObjectTypeExtendedDecimal) {             EDecimal e1 = null;             EDecimal e2 = null;             if (typeA == CBORObjectTypeExtendedFloat) {               var ef1 = (EFloat)objA;               e2 = (EDecimal)objB;               cmp = e2.CompareToBinary(ef1);               cmp = -cmp;             } else if (typeB == CBORObjectTypeExtendedFloat) {               var ef1 = (EFloat)objB;               e2 = (EDecimal)objA;               cmp = e2.CompareToBinary(ef1);             } else {               e1 = NumberInterfaces[typeA].AsExtendedDecimal(objA);               e2 = NumberInterfaces[typeB].AsExtendedDecimal(objB);               cmp = e1.CompareTo(e2);             }           } else if (typeA == CBORObjectTypeExtendedFloat || typeB ==                     CBORObjectTypeExtendedFloat ||                     typeA == CBORObjectTypeDouble || typeB ==                     CBORObjectTypeDouble ||                     typeA == CBORObjectTypeSingle || typeB ==                     CBORObjectTypeSingle) {             EFloat e1 = NumberInterfaces[typeA].AsExtendedFloat(objA);             EFloat e2 = NumberInterfaces[typeB].AsExtendedFloat(objB);             cmp = e1.CompareTo(e2);           } else {             EInteger b1 = NumberInterfaces[typeA].AsEInteger(objA);             EInteger b2 = NumberInterfaces[typeB].AsEInteger(objB);             cmp = b1.CompareTo(b2);           }         }       }
Magic Number,PeterO.Cbor,CBORObject,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORObject.cs,CompareTo,The following statement contains a magic number: if (simpleValueA >= 0 || simpleValueB >= 0) {         if (simpleValueB < 0) {           return -1;  // B is not true' false' null' or undefined' so A is less         }         if (simpleValueA < 0) {           return 1;         }         cmp = (simpleValueA == simpleValueB) ? 0 : ((simpleValueA <                     simpleValueB) ? -1 : 1);       } else if (typeA == typeB) {         switch (typeA) {           case CBORObjectTypeInteger: {               var a = (long)objA;               var b = (long)objB;               cmp = (a == b) ? 0 : ((a < b) ? -1 : 1);               break;             }           case CBORObjectTypeSingle: {               var a = (float)objA;               var b = (float)objB;               // Treat NaN as greater than all other numbers               cmp = Single.IsNaN(a) ? (Single.IsNaN(b) ? 0 : 1) :                 (Single.IsNaN(b) ? (-1) : ((a == b) ? 0 : ((a < b) ? -1 :                     1)));               break;             }           case CBORObjectTypeBigInteger: {               var bigintA = (EInteger)objA;               var bigintB = (EInteger)objB;               cmp = bigintA.CompareTo(bigintB);               break;             }           case CBORObjectTypeDouble: {               var a = (double)objA;               var b = (double)objB;               // Treat NaN as greater than all other numbers               cmp = Double.IsNaN(a) ? (Double.IsNaN(b) ? 0 : 1) :                 (Double.IsNaN(b) ? (-1) : ((a == b) ? 0 : ((a < b) ? -1 :                     1)));               break;             }           case CBORObjectTypeExtendedDecimal: {               cmp = ((EDecimal)objA).CompareTo((EDecimal)objB);               break;             }           case CBORObjectTypeExtendedFloat: {               cmp = ((EFloat)objA).CompareTo(                 (EFloat)objB);               break;             }           case CBORObjectTypeExtendedRational: {               cmp = ((ERational)objA).CompareTo(                 (ERational)objB);               break;             }           case CBORObjectTypeByteString: {               cmp = CBORUtilities.ByteArrayCompare((byte[])objA' (byte[])objB);               break;             }           case CBORObjectTypeTextString: {               cmp = DataUtilities.CodePointCompare(                 (string)objA'                 (string)objB);               break;             }           case CBORObjectTypeArray: {               cmp = ListCompare(                 (List<CBORObject>)objA'                 (List<CBORObject>)objB);               break;             }           case CBORObjectTypeMap: {               cmp = MapCompare(                 (IDictionary<CBORObject' CBORObject>)objA'                 (IDictionary<CBORObject' CBORObject>)objB);               break;             }           case CBORObjectTypeSimpleValue: {               var valueA = (int)objA;               var valueB = (int)objB;               cmp = (valueA == valueB) ? 0 : ((valueA < valueB) ? -1 : 1);               break;             }           default: throw new ArgumentException("Unexpected data type");         }       } else {         int typeOrderA = ValueNumberTypeOrder[typeA];         int typeOrderB = ValueNumberTypeOrder[typeB];         // Check whether general types are different         // (treating number types the same)         if (typeOrderA != typeOrderB) {           return (typeOrderA < typeOrderB) ? -1 : 1;         }         // At this point' both types should be number types. #if DEBUG         if (typeOrderA != 0) {           throw new ArgumentException("doesn't satisfy typeOrderA == 0");         }         if (typeOrderB != 0) {           throw new ArgumentException("doesn't satisfy typeOrderB == 0");         } #endif         int s1 = GetSignInternal(typeA' objA);         int s2 = GetSignInternal(typeB' objB);         if (s1 != s2 && s1 != 2 && s2 != 2) {           // if both types are numbers           // and their signs are different           return (s1 < s2) ? -1 : 1;         }         if (s1 == 2 && s2 == 2) {           // both are NaN           cmp = 0;         } else if (s1 == 2) {           // first object is NaN           return 1;         } else if (s2 == 2) {           // second object is NaN           return -1;         } else {           // DebugUtility.Log("a=" + this + " b=" + other);           if (typeA == CBORObjectTypeExtendedRational) {             ERational e1 = NumberInterfaces[typeA].AsExtendedRational(objA);             if (typeB == CBORObjectTypeExtendedDecimal) {               EDecimal e2 = NumberInterfaces[typeB].AsExtendedDecimal(objB);               cmp = e1.CompareToDecimal(e2);             } else {               EFloat e2 = NumberInterfaces[typeB].AsExtendedFloat(objB);               cmp = e1.CompareToBinary(e2);             }           } else if (typeB == CBORObjectTypeExtendedRational) {             ERational e2 = NumberInterfaces[typeB].AsExtendedRational(objB);             if (typeA == CBORObjectTypeExtendedDecimal) {               EDecimal e1 = NumberInterfaces[typeA].AsExtendedDecimal(objA);               cmp = e2.CompareToDecimal(e1);               cmp = -cmp;             } else {               EFloat e1 = NumberInterfaces[typeA].AsExtendedFloat(objA);               cmp = e2.CompareToBinary(e1);               cmp = -cmp;             }           } else if (typeA == CBORObjectTypeExtendedDecimal ||                     typeB == CBORObjectTypeExtendedDecimal) {             EDecimal e1 = null;             EDecimal e2 = null;             if (typeA == CBORObjectTypeExtendedFloat) {               var ef1 = (EFloat)objA;               e2 = (EDecimal)objB;               cmp = e2.CompareToBinary(ef1);               cmp = -cmp;             } else if (typeB == CBORObjectTypeExtendedFloat) {               var ef1 = (EFloat)objB;               e2 = (EDecimal)objA;               cmp = e2.CompareToBinary(ef1);             } else {               e1 = NumberInterfaces[typeA].AsExtendedDecimal(objA);               e2 = NumberInterfaces[typeB].AsExtendedDecimal(objB);               cmp = e1.CompareTo(e2);             }           } else if (typeA == CBORObjectTypeExtendedFloat || typeB ==                     CBORObjectTypeExtendedFloat ||                     typeA == CBORObjectTypeDouble || typeB ==                     CBORObjectTypeDouble ||                     typeA == CBORObjectTypeSingle || typeB ==                     CBORObjectTypeSingle) {             EFloat e1 = NumberInterfaces[typeA].AsExtendedFloat(objA);             EFloat e2 = NumberInterfaces[typeB].AsExtendedFloat(objB);             cmp = e1.CompareTo(e2);           } else {             EInteger b1 = NumberInterfaces[typeA].AsEInteger(objA);             EInteger b2 = NumberInterfaces[typeB].AsEInteger(objB);             cmp = b1.CompareTo(b2);           }         }       }
Magic Number,PeterO.Cbor,CBORObject,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORObject.cs,CompareTo,The following statement contains a magic number: if (simpleValueA >= 0 || simpleValueB >= 0) {         if (simpleValueB < 0) {           return -1;  // B is not true' false' null' or undefined' so A is less         }         if (simpleValueA < 0) {           return 1;         }         cmp = (simpleValueA == simpleValueB) ? 0 : ((simpleValueA <                     simpleValueB) ? -1 : 1);       } else if (typeA == typeB) {         switch (typeA) {           case CBORObjectTypeInteger: {               var a = (long)objA;               var b = (long)objB;               cmp = (a == b) ? 0 : ((a < b) ? -1 : 1);               break;             }           case CBORObjectTypeSingle: {               var a = (float)objA;               var b = (float)objB;               // Treat NaN as greater than all other numbers               cmp = Single.IsNaN(a) ? (Single.IsNaN(b) ? 0 : 1) :                 (Single.IsNaN(b) ? (-1) : ((a == b) ? 0 : ((a < b) ? -1 :                     1)));               break;             }           case CBORObjectTypeBigInteger: {               var bigintA = (EInteger)objA;               var bigintB = (EInteger)objB;               cmp = bigintA.CompareTo(bigintB);               break;             }           case CBORObjectTypeDouble: {               var a = (double)objA;               var b = (double)objB;               // Treat NaN as greater than all other numbers               cmp = Double.IsNaN(a) ? (Double.IsNaN(b) ? 0 : 1) :                 (Double.IsNaN(b) ? (-1) : ((a == b) ? 0 : ((a < b) ? -1 :                     1)));               break;             }           case CBORObjectTypeExtendedDecimal: {               cmp = ((EDecimal)objA).CompareTo((EDecimal)objB);               break;             }           case CBORObjectTypeExtendedFloat: {               cmp = ((EFloat)objA).CompareTo(                 (EFloat)objB);               break;             }           case CBORObjectTypeExtendedRational: {               cmp = ((ERational)objA).CompareTo(                 (ERational)objB);               break;             }           case CBORObjectTypeByteString: {               cmp = CBORUtilities.ByteArrayCompare((byte[])objA' (byte[])objB);               break;             }           case CBORObjectTypeTextString: {               cmp = DataUtilities.CodePointCompare(                 (string)objA'                 (string)objB);               break;             }           case CBORObjectTypeArray: {               cmp = ListCompare(                 (List<CBORObject>)objA'                 (List<CBORObject>)objB);               break;             }           case CBORObjectTypeMap: {               cmp = MapCompare(                 (IDictionary<CBORObject' CBORObject>)objA'                 (IDictionary<CBORObject' CBORObject>)objB);               break;             }           case CBORObjectTypeSimpleValue: {               var valueA = (int)objA;               var valueB = (int)objB;               cmp = (valueA == valueB) ? 0 : ((valueA < valueB) ? -1 : 1);               break;             }           default: throw new ArgumentException("Unexpected data type");         }       } else {         int typeOrderA = ValueNumberTypeOrder[typeA];         int typeOrderB = ValueNumberTypeOrder[typeB];         // Check whether general types are different         // (treating number types the same)         if (typeOrderA != typeOrderB) {           return (typeOrderA < typeOrderB) ? -1 : 1;         }         // At this point' both types should be number types. #if DEBUG         if (typeOrderA != 0) {           throw new ArgumentException("doesn't satisfy typeOrderA == 0");         }         if (typeOrderB != 0) {           throw new ArgumentException("doesn't satisfy typeOrderB == 0");         } #endif         int s1 = GetSignInternal(typeA' objA);         int s2 = GetSignInternal(typeB' objB);         if (s1 != s2 && s1 != 2 && s2 != 2) {           // if both types are numbers           // and their signs are different           return (s1 < s2) ? -1 : 1;         }         if (s1 == 2 && s2 == 2) {           // both are NaN           cmp = 0;         } else if (s1 == 2) {           // first object is NaN           return 1;         } else if (s2 == 2) {           // second object is NaN           return -1;         } else {           // DebugUtility.Log("a=" + this + " b=" + other);           if (typeA == CBORObjectTypeExtendedRational) {             ERational e1 = NumberInterfaces[typeA].AsExtendedRational(objA);             if (typeB == CBORObjectTypeExtendedDecimal) {               EDecimal e2 = NumberInterfaces[typeB].AsExtendedDecimal(objB);               cmp = e1.CompareToDecimal(e2);             } else {               EFloat e2 = NumberInterfaces[typeB].AsExtendedFloat(objB);               cmp = e1.CompareToBinary(e2);             }           } else if (typeB == CBORObjectTypeExtendedRational) {             ERational e2 = NumberInterfaces[typeB].AsExtendedRational(objB);             if (typeA == CBORObjectTypeExtendedDecimal) {               EDecimal e1 = NumberInterfaces[typeA].AsExtendedDecimal(objA);               cmp = e2.CompareToDecimal(e1);               cmp = -cmp;             } else {               EFloat e1 = NumberInterfaces[typeA].AsExtendedFloat(objA);               cmp = e2.CompareToBinary(e1);               cmp = -cmp;             }           } else if (typeA == CBORObjectTypeExtendedDecimal ||                     typeB == CBORObjectTypeExtendedDecimal) {             EDecimal e1 = null;             EDecimal e2 = null;             if (typeA == CBORObjectTypeExtendedFloat) {               var ef1 = (EFloat)objA;               e2 = (EDecimal)objB;               cmp = e2.CompareToBinary(ef1);               cmp = -cmp;             } else if (typeB == CBORObjectTypeExtendedFloat) {               var ef1 = (EFloat)objB;               e2 = (EDecimal)objA;               cmp = e2.CompareToBinary(ef1);             } else {               e1 = NumberInterfaces[typeA].AsExtendedDecimal(objA);               e2 = NumberInterfaces[typeB].AsExtendedDecimal(objB);               cmp = e1.CompareTo(e2);             }           } else if (typeA == CBORObjectTypeExtendedFloat || typeB ==                     CBORObjectTypeExtendedFloat ||                     typeA == CBORObjectTypeDouble || typeB ==                     CBORObjectTypeDouble ||                     typeA == CBORObjectTypeSingle || typeB ==                     CBORObjectTypeSingle) {             EFloat e1 = NumberInterfaces[typeA].AsExtendedFloat(objA);             EFloat e2 = NumberInterfaces[typeB].AsExtendedFloat(objB);             cmp = e1.CompareTo(e2);           } else {             EInteger b1 = NumberInterfaces[typeA].AsEInteger(objA);             EInteger b2 = NumberInterfaces[typeB].AsEInteger(objB);             cmp = b1.CompareTo(b2);           }         }       }
Magic Number,PeterO.Cbor,CBORObject,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORObject.cs,CompareTo,The following statement contains a magic number: if (simpleValueA >= 0 || simpleValueB >= 0) {         if (simpleValueB < 0) {           return -1;  // B is not true' false' null' or undefined' so A is less         }         if (simpleValueA < 0) {           return 1;         }         cmp = (simpleValueA == simpleValueB) ? 0 : ((simpleValueA <                     simpleValueB) ? -1 : 1);       } else if (typeA == typeB) {         switch (typeA) {           case CBORObjectTypeInteger: {               var a = (long)objA;               var b = (long)objB;               cmp = (a == b) ? 0 : ((a < b) ? -1 : 1);               break;             }           case CBORObjectTypeSingle: {               var a = (float)objA;               var b = (float)objB;               // Treat NaN as greater than all other numbers               cmp = Single.IsNaN(a) ? (Single.IsNaN(b) ? 0 : 1) :                 (Single.IsNaN(b) ? (-1) : ((a == b) ? 0 : ((a < b) ? -1 :                     1)));               break;             }           case CBORObjectTypeBigInteger: {               var bigintA = (EInteger)objA;               var bigintB = (EInteger)objB;               cmp = bigintA.CompareTo(bigintB);               break;             }           case CBORObjectTypeDouble: {               var a = (double)objA;               var b = (double)objB;               // Treat NaN as greater than all other numbers               cmp = Double.IsNaN(a) ? (Double.IsNaN(b) ? 0 : 1) :                 (Double.IsNaN(b) ? (-1) : ((a == b) ? 0 : ((a < b) ? -1 :                     1)));               break;             }           case CBORObjectTypeExtendedDecimal: {               cmp = ((EDecimal)objA).CompareTo((EDecimal)objB);               break;             }           case CBORObjectTypeExtendedFloat: {               cmp = ((EFloat)objA).CompareTo(                 (EFloat)objB);               break;             }           case CBORObjectTypeExtendedRational: {               cmp = ((ERational)objA).CompareTo(                 (ERational)objB);               break;             }           case CBORObjectTypeByteString: {               cmp = CBORUtilities.ByteArrayCompare((byte[])objA' (byte[])objB);               break;             }           case CBORObjectTypeTextString: {               cmp = DataUtilities.CodePointCompare(                 (string)objA'                 (string)objB);               break;             }           case CBORObjectTypeArray: {               cmp = ListCompare(                 (List<CBORObject>)objA'                 (List<CBORObject>)objB);               break;             }           case CBORObjectTypeMap: {               cmp = MapCompare(                 (IDictionary<CBORObject' CBORObject>)objA'                 (IDictionary<CBORObject' CBORObject>)objB);               break;             }           case CBORObjectTypeSimpleValue: {               var valueA = (int)objA;               var valueB = (int)objB;               cmp = (valueA == valueB) ? 0 : ((valueA < valueB) ? -1 : 1);               break;             }           default: throw new ArgumentException("Unexpected data type");         }       } else {         int typeOrderA = ValueNumberTypeOrder[typeA];         int typeOrderB = ValueNumberTypeOrder[typeB];         // Check whether general types are different         // (treating number types the same)         if (typeOrderA != typeOrderB) {           return (typeOrderA < typeOrderB) ? -1 : 1;         }         // At this point' both types should be number types. #if DEBUG         if (typeOrderA != 0) {           throw new ArgumentException("doesn't satisfy typeOrderA == 0");         }         if (typeOrderB != 0) {           throw new ArgumentException("doesn't satisfy typeOrderB == 0");         } #endif         int s1 = GetSignInternal(typeA' objA);         int s2 = GetSignInternal(typeB' objB);         if (s1 != s2 && s1 != 2 && s2 != 2) {           // if both types are numbers           // and their signs are different           return (s1 < s2) ? -1 : 1;         }         if (s1 == 2 && s2 == 2) {           // both are NaN           cmp = 0;         } else if (s1 == 2) {           // first object is NaN           return 1;         } else if (s2 == 2) {           // second object is NaN           return -1;         } else {           // DebugUtility.Log("a=" + this + " b=" + other);           if (typeA == CBORObjectTypeExtendedRational) {             ERational e1 = NumberInterfaces[typeA].AsExtendedRational(objA);             if (typeB == CBORObjectTypeExtendedDecimal) {               EDecimal e2 = NumberInterfaces[typeB].AsExtendedDecimal(objB);               cmp = e1.CompareToDecimal(e2);             } else {               EFloat e2 = NumberInterfaces[typeB].AsExtendedFloat(objB);               cmp = e1.CompareToBinary(e2);             }           } else if (typeB == CBORObjectTypeExtendedRational) {             ERational e2 = NumberInterfaces[typeB].AsExtendedRational(objB);             if (typeA == CBORObjectTypeExtendedDecimal) {               EDecimal e1 = NumberInterfaces[typeA].AsExtendedDecimal(objA);               cmp = e2.CompareToDecimal(e1);               cmp = -cmp;             } else {               EFloat e1 = NumberInterfaces[typeA].AsExtendedFloat(objA);               cmp = e2.CompareToBinary(e1);               cmp = -cmp;             }           } else if (typeA == CBORObjectTypeExtendedDecimal ||                     typeB == CBORObjectTypeExtendedDecimal) {             EDecimal e1 = null;             EDecimal e2 = null;             if (typeA == CBORObjectTypeExtendedFloat) {               var ef1 = (EFloat)objA;               e2 = (EDecimal)objB;               cmp = e2.CompareToBinary(ef1);               cmp = -cmp;             } else if (typeB == CBORObjectTypeExtendedFloat) {               var ef1 = (EFloat)objB;               e2 = (EDecimal)objA;               cmp = e2.CompareToBinary(ef1);             } else {               e1 = NumberInterfaces[typeA].AsExtendedDecimal(objA);               e2 = NumberInterfaces[typeB].AsExtendedDecimal(objB);               cmp = e1.CompareTo(e2);             }           } else if (typeA == CBORObjectTypeExtendedFloat || typeB ==                     CBORObjectTypeExtendedFloat ||                     typeA == CBORObjectTypeDouble || typeB ==                     CBORObjectTypeDouble ||                     typeA == CBORObjectTypeSingle || typeB ==                     CBORObjectTypeSingle) {             EFloat e1 = NumberInterfaces[typeA].AsExtendedFloat(objA);             EFloat e2 = NumberInterfaces[typeB].AsExtendedFloat(objB);             cmp = e1.CompareTo(e2);           } else {             EInteger b1 = NumberInterfaces[typeA].AsEInteger(objA);             EInteger b2 = NumberInterfaces[typeB].AsEInteger(objB);             cmp = b1.CompareTo(b2);           }         }       }
Magic Number,PeterO.Cbor,CBORObject,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORObject.cs,EncodeToBytes,The following statement contains a magic number: if (this.IsTagged) {         var taggedItem = (CBORObject)this.itemValue;         if (taggedItem.IsTagged || this.tagHigh != 0 ||             (this.tagLow >> 16) != 0 || this.tagLow >= 24) {           hasComplexTag = true;         } else {           tagbyte = (byte)(0xc0 + (int)this.tagLow);         }       }
Magic Number,PeterO.Cbor,CBORObject,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORObject.cs,EncodeToBytes,The following statement contains a magic number: if (this.IsTagged) {         var taggedItem = (CBORObject)this.itemValue;         if (taggedItem.IsTagged || this.tagHigh != 0 ||             (this.tagLow >> 16) != 0 || this.tagLow >= 24) {           hasComplexTag = true;         } else {           tagbyte = (byte)(0xc0 + (int)this.tagLow);         }       }
Magic Number,PeterO.Cbor,CBORObject,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORObject.cs,EncodeToBytes,The following statement contains a magic number: if (!hasComplexTag) {         switch (this.ItemType) {           case CBORObjectTypeTextString: {               byte[] ret = GetOptimizedBytesIfShortAscii(                 this.AsString()' tagged ? (((int)tagbyte) & 0xff) : -1);               if (ret != null) {                 return ret;               }               break;             }           case CBORObjectTypeSimpleValue: {               if (tagged) {                 if (this.IsFalse) {                   return new[] { tagbyte' (byte)0xf4 };                 }                 if (this.IsTrue) {                   return new[] { tagbyte' (byte)0xf5 };                 }                 if (this.IsNull) {                   return new[] { tagbyte' (byte)0xf6 };                 }                 if (this.IsUndefined) {                   return new[] { tagbyte' (byte)0xf7 };                 }               } else {                 if (this.IsFalse) {                   return new[] { (byte)0xf4 };                 }                 if (this.IsTrue) {                   return new[] { (byte)0xf5 };                 }                 if (this.IsNull) {                   return new[] { (byte)0xf6 };                 }                 if (this.IsUndefined) {                   return new[] { (byte)0xf7 };                 }               }               break;             }           case CBORObjectTypeInteger: {               var value = (long)this.ThisItem;               byte[] intBytes = null;               if (value >= 0) {                 intBytes = GetPositiveInt64Bytes(0' value);               } else {                 ++value;                 value = -value;  // Will never overflow                 intBytes = GetPositiveInt64Bytes(1' value);               }               if (!tagged) {                 return intBytes;               }               var ret2 = new byte[intBytes.Length + 1];               Array.Copy(intBytes' 0' ret2' 1' intBytes.Length);               ret2[0] = tagbyte;               return ret2;             }           case CBORObjectTypeSingle: {               var value = (float)this.ThisItem;               int bits = BitConverter.ToInt32(BitConverter.GetBytes(value)' 0);               return tagged ? new[] { tagbyte' (byte)0xfa'                 (byte)((bits >> 24) & 0xff)' (byte)((bits >> 16) & 0xff)'                 (byte)((bits >> 8) & 0xff)' (byte)(bits & 0xff) } :                 new[] { (byte)0xfa' (byte)((bits >> 24) & 0xff)'                 (byte)((bits >> 16) & 0xff)' (byte)((bits >> 8) & 0xff)'                 (byte)(bits & 0xff) };             }           case CBORObjectTypeDouble: {               var value = (double)this.ThisItem;               long bits = BitConverter.ToInt64(BitConverter.GetBytes(value)' 0);               return tagged ? new[] { tagbyte' (byte)0xfb'                 (byte)((bits >> 56) & 0xff)' (byte)((bits >> 48) & 0xff)'                 (byte)((bits >> 40) & 0xff)' (byte)((bits >> 32) & 0xff)'                 (byte)((bits >> 24) & 0xff)' (byte)((bits >> 16) & 0xff)'                 (byte)((bits >> 8) & 0xff)' (byte)(bits & 0xff) } :                 new[] { (byte)0xfb' (byte)((bits >> 56) & 0xff)'                 (byte)((bits >> 48) & 0xff)' (byte)((bits >> 40) & 0xff)'                 (byte)((bits >> 32) & 0xff)' (byte)((bits >> 24) & 0xff)'                 (byte)((bits >> 16) & 0xff)' (byte)((bits >> 8) & 0xff)'                 (byte)(bits & 0xff) };             }         }       }
Magic Number,PeterO.Cbor,CBORObject,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORObject.cs,EncodeToBytes,The following statement contains a magic number: if (!hasComplexTag) {         switch (this.ItemType) {           case CBORObjectTypeTextString: {               byte[] ret = GetOptimizedBytesIfShortAscii(                 this.AsString()' tagged ? (((int)tagbyte) & 0xff) : -1);               if (ret != null) {                 return ret;               }               break;             }           case CBORObjectTypeSimpleValue: {               if (tagged) {                 if (this.IsFalse) {                   return new[] { tagbyte' (byte)0xf4 };                 }                 if (this.IsTrue) {                   return new[] { tagbyte' (byte)0xf5 };                 }                 if (this.IsNull) {                   return new[] { tagbyte' (byte)0xf6 };                 }                 if (this.IsUndefined) {                   return new[] { tagbyte' (byte)0xf7 };                 }               } else {                 if (this.IsFalse) {                   return new[] { (byte)0xf4 };                 }                 if (this.IsTrue) {                   return new[] { (byte)0xf5 };                 }                 if (this.IsNull) {                   return new[] { (byte)0xf6 };                 }                 if (this.IsUndefined) {                   return new[] { (byte)0xf7 };                 }               }               break;             }           case CBORObjectTypeInteger: {               var value = (long)this.ThisItem;               byte[] intBytes = null;               if (value >= 0) {                 intBytes = GetPositiveInt64Bytes(0' value);               } else {                 ++value;                 value = -value;  // Will never overflow                 intBytes = GetPositiveInt64Bytes(1' value);               }               if (!tagged) {                 return intBytes;               }               var ret2 = new byte[intBytes.Length + 1];               Array.Copy(intBytes' 0' ret2' 1' intBytes.Length);               ret2[0] = tagbyte;               return ret2;             }           case CBORObjectTypeSingle: {               var value = (float)this.ThisItem;               int bits = BitConverter.ToInt32(BitConverter.GetBytes(value)' 0);               return tagged ? new[] { tagbyte' (byte)0xfa'                 (byte)((bits >> 24) & 0xff)' (byte)((bits >> 16) & 0xff)'                 (byte)((bits >> 8) & 0xff)' (byte)(bits & 0xff) } :                 new[] { (byte)0xfa' (byte)((bits >> 24) & 0xff)'                 (byte)((bits >> 16) & 0xff)' (byte)((bits >> 8) & 0xff)'                 (byte)(bits & 0xff) };             }           case CBORObjectTypeDouble: {               var value = (double)this.ThisItem;               long bits = BitConverter.ToInt64(BitConverter.GetBytes(value)' 0);               return tagged ? new[] { tagbyte' (byte)0xfb'                 (byte)((bits >> 56) & 0xff)' (byte)((bits >> 48) & 0xff)'                 (byte)((bits >> 40) & 0xff)' (byte)((bits >> 32) & 0xff)'                 (byte)((bits >> 24) & 0xff)' (byte)((bits >> 16) & 0xff)'                 (byte)((bits >> 8) & 0xff)' (byte)(bits & 0xff) } :                 new[] { (byte)0xfb' (byte)((bits >> 56) & 0xff)'                 (byte)((bits >> 48) & 0xff)' (byte)((bits >> 40) & 0xff)'                 (byte)((bits >> 32) & 0xff)' (byte)((bits >> 24) & 0xff)'                 (byte)((bits >> 16) & 0xff)' (byte)((bits >> 8) & 0xff)'                 (byte)(bits & 0xff) };             }         }       }
Magic Number,PeterO.Cbor,CBORObject,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORObject.cs,EncodeToBytes,The following statement contains a magic number: if (!hasComplexTag) {         switch (this.ItemType) {           case CBORObjectTypeTextString: {               byte[] ret = GetOptimizedBytesIfShortAscii(                 this.AsString()' tagged ? (((int)tagbyte) & 0xff) : -1);               if (ret != null) {                 return ret;               }               break;             }           case CBORObjectTypeSimpleValue: {               if (tagged) {                 if (this.IsFalse) {                   return new[] { tagbyte' (byte)0xf4 };                 }                 if (this.IsTrue) {                   return new[] { tagbyte' (byte)0xf5 };                 }                 if (this.IsNull) {                   return new[] { tagbyte' (byte)0xf6 };                 }                 if (this.IsUndefined) {                   return new[] { tagbyte' (byte)0xf7 };                 }               } else {                 if (this.IsFalse) {                   return new[] { (byte)0xf4 };                 }                 if (this.IsTrue) {                   return new[] { (byte)0xf5 };                 }                 if (this.IsNull) {                   return new[] { (byte)0xf6 };                 }                 if (this.IsUndefined) {                   return new[] { (byte)0xf7 };                 }               }               break;             }           case CBORObjectTypeInteger: {               var value = (long)this.ThisItem;               byte[] intBytes = null;               if (value >= 0) {                 intBytes = GetPositiveInt64Bytes(0' value);               } else {                 ++value;                 value = -value;  // Will never overflow                 intBytes = GetPositiveInt64Bytes(1' value);               }               if (!tagged) {                 return intBytes;               }               var ret2 = new byte[intBytes.Length + 1];               Array.Copy(intBytes' 0' ret2' 1' intBytes.Length);               ret2[0] = tagbyte;               return ret2;             }           case CBORObjectTypeSingle: {               var value = (float)this.ThisItem;               int bits = BitConverter.ToInt32(BitConverter.GetBytes(value)' 0);               return tagged ? new[] { tagbyte' (byte)0xfa'                 (byte)((bits >> 24) & 0xff)' (byte)((bits >> 16) & 0xff)'                 (byte)((bits >> 8) & 0xff)' (byte)(bits & 0xff) } :                 new[] { (byte)0xfa' (byte)((bits >> 24) & 0xff)'                 (byte)((bits >> 16) & 0xff)' (byte)((bits >> 8) & 0xff)'                 (byte)(bits & 0xff) };             }           case CBORObjectTypeDouble: {               var value = (double)this.ThisItem;               long bits = BitConverter.ToInt64(BitConverter.GetBytes(value)' 0);               return tagged ? new[] { tagbyte' (byte)0xfb'                 (byte)((bits >> 56) & 0xff)' (byte)((bits >> 48) & 0xff)'                 (byte)((bits >> 40) & 0xff)' (byte)((bits >> 32) & 0xff)'                 (byte)((bits >> 24) & 0xff)' (byte)((bits >> 16) & 0xff)'                 (byte)((bits >> 8) & 0xff)' (byte)(bits & 0xff) } :                 new[] { (byte)0xfb' (byte)((bits >> 56) & 0xff)'                 (byte)((bits >> 48) & 0xff)' (byte)((bits >> 40) & 0xff)'                 (byte)((bits >> 32) & 0xff)' (byte)((bits >> 24) & 0xff)'                 (byte)((bits >> 16) & 0xff)' (byte)((bits >> 8) & 0xff)'                 (byte)(bits & 0xff) };             }         }       }
Magic Number,PeterO.Cbor,CBORObject,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORObject.cs,EncodeToBytes,The following statement contains a magic number: if (!hasComplexTag) {         switch (this.ItemType) {           case CBORObjectTypeTextString: {               byte[] ret = GetOptimizedBytesIfShortAscii(                 this.AsString()' tagged ? (((int)tagbyte) & 0xff) : -1);               if (ret != null) {                 return ret;               }               break;             }           case CBORObjectTypeSimpleValue: {               if (tagged) {                 if (this.IsFalse) {                   return new[] { tagbyte' (byte)0xf4 };                 }                 if (this.IsTrue) {                   return new[] { tagbyte' (byte)0xf5 };                 }                 if (this.IsNull) {                   return new[] { tagbyte' (byte)0xf6 };                 }                 if (this.IsUndefined) {                   return new[] { tagbyte' (byte)0xf7 };                 }               } else {                 if (this.IsFalse) {                   return new[] { (byte)0xf4 };                 }                 if (this.IsTrue) {                   return new[] { (byte)0xf5 };                 }                 if (this.IsNull) {                   return new[] { (byte)0xf6 };                 }                 if (this.IsUndefined) {                   return new[] { (byte)0xf7 };                 }               }               break;             }           case CBORObjectTypeInteger: {               var value = (long)this.ThisItem;               byte[] intBytes = null;               if (value >= 0) {                 intBytes = GetPositiveInt64Bytes(0' value);               } else {                 ++value;                 value = -value;  // Will never overflow                 intBytes = GetPositiveInt64Bytes(1' value);               }               if (!tagged) {                 return intBytes;               }               var ret2 = new byte[intBytes.Length + 1];               Array.Copy(intBytes' 0' ret2' 1' intBytes.Length);               ret2[0] = tagbyte;               return ret2;             }           case CBORObjectTypeSingle: {               var value = (float)this.ThisItem;               int bits = BitConverter.ToInt32(BitConverter.GetBytes(value)' 0);               return tagged ? new[] { tagbyte' (byte)0xfa'                 (byte)((bits >> 24) & 0xff)' (byte)((bits >> 16) & 0xff)'                 (byte)((bits >> 8) & 0xff)' (byte)(bits & 0xff) } :                 new[] { (byte)0xfa' (byte)((bits >> 24) & 0xff)'                 (byte)((bits >> 16) & 0xff)' (byte)((bits >> 8) & 0xff)'                 (byte)(bits & 0xff) };             }           case CBORObjectTypeDouble: {               var value = (double)this.ThisItem;               long bits = BitConverter.ToInt64(BitConverter.GetBytes(value)' 0);               return tagged ? new[] { tagbyte' (byte)0xfb'                 (byte)((bits >> 56) & 0xff)' (byte)((bits >> 48) & 0xff)'                 (byte)((bits >> 40) & 0xff)' (byte)((bits >> 32) & 0xff)'                 (byte)((bits >> 24) & 0xff)' (byte)((bits >> 16) & 0xff)'                 (byte)((bits >> 8) & 0xff)' (byte)(bits & 0xff) } :                 new[] { (byte)0xfb' (byte)((bits >> 56) & 0xff)'                 (byte)((bits >> 48) & 0xff)' (byte)((bits >> 40) & 0xff)'                 (byte)((bits >> 32) & 0xff)' (byte)((bits >> 24) & 0xff)'                 (byte)((bits >> 16) & 0xff)' (byte)((bits >> 8) & 0xff)'                 (byte)(bits & 0xff) };             }         }       }
Magic Number,PeterO.Cbor,CBORObject,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORObject.cs,EncodeToBytes,The following statement contains a magic number: if (!hasComplexTag) {         switch (this.ItemType) {           case CBORObjectTypeTextString: {               byte[] ret = GetOptimizedBytesIfShortAscii(                 this.AsString()' tagged ? (((int)tagbyte) & 0xff) : -1);               if (ret != null) {                 return ret;               }               break;             }           case CBORObjectTypeSimpleValue: {               if (tagged) {                 if (this.IsFalse) {                   return new[] { tagbyte' (byte)0xf4 };                 }                 if (this.IsTrue) {                   return new[] { tagbyte' (byte)0xf5 };                 }                 if (this.IsNull) {                   return new[] { tagbyte' (byte)0xf6 };                 }                 if (this.IsUndefined) {                   return new[] { tagbyte' (byte)0xf7 };                 }               } else {                 if (this.IsFalse) {                   return new[] { (byte)0xf4 };                 }                 if (this.IsTrue) {                   return new[] { (byte)0xf5 };                 }                 if (this.IsNull) {                   return new[] { (byte)0xf6 };                 }                 if (this.IsUndefined) {                   return new[] { (byte)0xf7 };                 }               }               break;             }           case CBORObjectTypeInteger: {               var value = (long)this.ThisItem;               byte[] intBytes = null;               if (value >= 0) {                 intBytes = GetPositiveInt64Bytes(0' value);               } else {                 ++value;                 value = -value;  // Will never overflow                 intBytes = GetPositiveInt64Bytes(1' value);               }               if (!tagged) {                 return intBytes;               }               var ret2 = new byte[intBytes.Length + 1];               Array.Copy(intBytes' 0' ret2' 1' intBytes.Length);               ret2[0] = tagbyte;               return ret2;             }           case CBORObjectTypeSingle: {               var value = (float)this.ThisItem;               int bits = BitConverter.ToInt32(BitConverter.GetBytes(value)' 0);               return tagged ? new[] { tagbyte' (byte)0xfa'                 (byte)((bits >> 24) & 0xff)' (byte)((bits >> 16) & 0xff)'                 (byte)((bits >> 8) & 0xff)' (byte)(bits & 0xff) } :                 new[] { (byte)0xfa' (byte)((bits >> 24) & 0xff)'                 (byte)((bits >> 16) & 0xff)' (byte)((bits >> 8) & 0xff)'                 (byte)(bits & 0xff) };             }           case CBORObjectTypeDouble: {               var value = (double)this.ThisItem;               long bits = BitConverter.ToInt64(BitConverter.GetBytes(value)' 0);               return tagged ? new[] { tagbyte' (byte)0xfb'                 (byte)((bits >> 56) & 0xff)' (byte)((bits >> 48) & 0xff)'                 (byte)((bits >> 40) & 0xff)' (byte)((bits >> 32) & 0xff)'                 (byte)((bits >> 24) & 0xff)' (byte)((bits >> 16) & 0xff)'                 (byte)((bits >> 8) & 0xff)' (byte)(bits & 0xff) } :                 new[] { (byte)0xfb' (byte)((bits >> 56) & 0xff)'                 (byte)((bits >> 48) & 0xff)' (byte)((bits >> 40) & 0xff)'                 (byte)((bits >> 32) & 0xff)' (byte)((bits >> 24) & 0xff)'                 (byte)((bits >> 16) & 0xff)' (byte)((bits >> 8) & 0xff)'                 (byte)(bits & 0xff) };             }         }       }
Magic Number,PeterO.Cbor,CBORObject,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORObject.cs,EncodeToBytes,The following statement contains a magic number: if (!hasComplexTag) {         switch (this.ItemType) {           case CBORObjectTypeTextString: {               byte[] ret = GetOptimizedBytesIfShortAscii(                 this.AsString()' tagged ? (((int)tagbyte) & 0xff) : -1);               if (ret != null) {                 return ret;               }               break;             }           case CBORObjectTypeSimpleValue: {               if (tagged) {                 if (this.IsFalse) {                   return new[] { tagbyte' (byte)0xf4 };                 }                 if (this.IsTrue) {                   return new[] { tagbyte' (byte)0xf5 };                 }                 if (this.IsNull) {                   return new[] { tagbyte' (byte)0xf6 };                 }                 if (this.IsUndefined) {                   return new[] { tagbyte' (byte)0xf7 };                 }               } else {                 if (this.IsFalse) {                   return new[] { (byte)0xf4 };                 }                 if (this.IsTrue) {                   return new[] { (byte)0xf5 };                 }                 if (this.IsNull) {                   return new[] { (byte)0xf6 };                 }                 if (this.IsUndefined) {                   return new[] { (byte)0xf7 };                 }               }               break;             }           case CBORObjectTypeInteger: {               var value = (long)this.ThisItem;               byte[] intBytes = null;               if (value >= 0) {                 intBytes = GetPositiveInt64Bytes(0' value);               } else {                 ++value;                 value = -value;  // Will never overflow                 intBytes = GetPositiveInt64Bytes(1' value);               }               if (!tagged) {                 return intBytes;               }               var ret2 = new byte[intBytes.Length + 1];               Array.Copy(intBytes' 0' ret2' 1' intBytes.Length);               ret2[0] = tagbyte;               return ret2;             }           case CBORObjectTypeSingle: {               var value = (float)this.ThisItem;               int bits = BitConverter.ToInt32(BitConverter.GetBytes(value)' 0);               return tagged ? new[] { tagbyte' (byte)0xfa'                 (byte)((bits >> 24) & 0xff)' (byte)((bits >> 16) & 0xff)'                 (byte)((bits >> 8) & 0xff)' (byte)(bits & 0xff) } :                 new[] { (byte)0xfa' (byte)((bits >> 24) & 0xff)'                 (byte)((bits >> 16) & 0xff)' (byte)((bits >> 8) & 0xff)'                 (byte)(bits & 0xff) };             }           case CBORObjectTypeDouble: {               var value = (double)this.ThisItem;               long bits = BitConverter.ToInt64(BitConverter.GetBytes(value)' 0);               return tagged ? new[] { tagbyte' (byte)0xfb'                 (byte)((bits >> 56) & 0xff)' (byte)((bits >> 48) & 0xff)'                 (byte)((bits >> 40) & 0xff)' (byte)((bits >> 32) & 0xff)'                 (byte)((bits >> 24) & 0xff)' (byte)((bits >> 16) & 0xff)'                 (byte)((bits >> 8) & 0xff)' (byte)(bits & 0xff) } :                 new[] { (byte)0xfb' (byte)((bits >> 56) & 0xff)'                 (byte)((bits >> 48) & 0xff)' (byte)((bits >> 40) & 0xff)'                 (byte)((bits >> 32) & 0xff)' (byte)((bits >> 24) & 0xff)'                 (byte)((bits >> 16) & 0xff)' (byte)((bits >> 8) & 0xff)'                 (byte)(bits & 0xff) };             }         }       }
Magic Number,PeterO.Cbor,CBORObject,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORObject.cs,EncodeToBytes,The following statement contains a magic number: if (!hasComplexTag) {         switch (this.ItemType) {           case CBORObjectTypeTextString: {               byte[] ret = GetOptimizedBytesIfShortAscii(                 this.AsString()' tagged ? (((int)tagbyte) & 0xff) : -1);               if (ret != null) {                 return ret;               }               break;             }           case CBORObjectTypeSimpleValue: {               if (tagged) {                 if (this.IsFalse) {                   return new[] { tagbyte' (byte)0xf4 };                 }                 if (this.IsTrue) {                   return new[] { tagbyte' (byte)0xf5 };                 }                 if (this.IsNull) {                   return new[] { tagbyte' (byte)0xf6 };                 }                 if (this.IsUndefined) {                   return new[] { tagbyte' (byte)0xf7 };                 }               } else {                 if (this.IsFalse) {                   return new[] { (byte)0xf4 };                 }                 if (this.IsTrue) {                   return new[] { (byte)0xf5 };                 }                 if (this.IsNull) {                   return new[] { (byte)0xf6 };                 }                 if (this.IsUndefined) {                   return new[] { (byte)0xf7 };                 }               }               break;             }           case CBORObjectTypeInteger: {               var value = (long)this.ThisItem;               byte[] intBytes = null;               if (value >= 0) {                 intBytes = GetPositiveInt64Bytes(0' value);               } else {                 ++value;                 value = -value;  // Will never overflow                 intBytes = GetPositiveInt64Bytes(1' value);               }               if (!tagged) {                 return intBytes;               }               var ret2 = new byte[intBytes.Length + 1];               Array.Copy(intBytes' 0' ret2' 1' intBytes.Length);               ret2[0] = tagbyte;               return ret2;             }           case CBORObjectTypeSingle: {               var value = (float)this.ThisItem;               int bits = BitConverter.ToInt32(BitConverter.GetBytes(value)' 0);               return tagged ? new[] { tagbyte' (byte)0xfa'                 (byte)((bits >> 24) & 0xff)' (byte)((bits >> 16) & 0xff)'                 (byte)((bits >> 8) & 0xff)' (byte)(bits & 0xff) } :                 new[] { (byte)0xfa' (byte)((bits >> 24) & 0xff)'                 (byte)((bits >> 16) & 0xff)' (byte)((bits >> 8) & 0xff)'                 (byte)(bits & 0xff) };             }           case CBORObjectTypeDouble: {               var value = (double)this.ThisItem;               long bits = BitConverter.ToInt64(BitConverter.GetBytes(value)' 0);               return tagged ? new[] { tagbyte' (byte)0xfb'                 (byte)((bits >> 56) & 0xff)' (byte)((bits >> 48) & 0xff)'                 (byte)((bits >> 40) & 0xff)' (byte)((bits >> 32) & 0xff)'                 (byte)((bits >> 24) & 0xff)' (byte)((bits >> 16) & 0xff)'                 (byte)((bits >> 8) & 0xff)' (byte)(bits & 0xff) } :                 new[] { (byte)0xfb' (byte)((bits >> 56) & 0xff)'                 (byte)((bits >> 48) & 0xff)' (byte)((bits >> 40) & 0xff)'                 (byte)((bits >> 32) & 0xff)' (byte)((bits >> 24) & 0xff)'                 (byte)((bits >> 16) & 0xff)' (byte)((bits >> 8) & 0xff)'                 (byte)(bits & 0xff) };             }         }       }
Magic Number,PeterO.Cbor,CBORObject,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORObject.cs,EncodeToBytes,The following statement contains a magic number: if (!hasComplexTag) {         switch (this.ItemType) {           case CBORObjectTypeTextString: {               byte[] ret = GetOptimizedBytesIfShortAscii(                 this.AsString()' tagged ? (((int)tagbyte) & 0xff) : -1);               if (ret != null) {                 return ret;               }               break;             }           case CBORObjectTypeSimpleValue: {               if (tagged) {                 if (this.IsFalse) {                   return new[] { tagbyte' (byte)0xf4 };                 }                 if (this.IsTrue) {                   return new[] { tagbyte' (byte)0xf5 };                 }                 if (this.IsNull) {                   return new[] { tagbyte' (byte)0xf6 };                 }                 if (this.IsUndefined) {                   return new[] { tagbyte' (byte)0xf7 };                 }               } else {                 if (this.IsFalse) {                   return new[] { (byte)0xf4 };                 }                 if (this.IsTrue) {                   return new[] { (byte)0xf5 };                 }                 if (this.IsNull) {                   return new[] { (byte)0xf6 };                 }                 if (this.IsUndefined) {                   return new[] { (byte)0xf7 };                 }               }               break;             }           case CBORObjectTypeInteger: {               var value = (long)this.ThisItem;               byte[] intBytes = null;               if (value >= 0) {                 intBytes = GetPositiveInt64Bytes(0' value);               } else {                 ++value;                 value = -value;  // Will never overflow                 intBytes = GetPositiveInt64Bytes(1' value);               }               if (!tagged) {                 return intBytes;               }               var ret2 = new byte[intBytes.Length + 1];               Array.Copy(intBytes' 0' ret2' 1' intBytes.Length);               ret2[0] = tagbyte;               return ret2;             }           case CBORObjectTypeSingle: {               var value = (float)this.ThisItem;               int bits = BitConverter.ToInt32(BitConverter.GetBytes(value)' 0);               return tagged ? new[] { tagbyte' (byte)0xfa'                 (byte)((bits >> 24) & 0xff)' (byte)((bits >> 16) & 0xff)'                 (byte)((bits >> 8) & 0xff)' (byte)(bits & 0xff) } :                 new[] { (byte)0xfa' (byte)((bits >> 24) & 0xff)'                 (byte)((bits >> 16) & 0xff)' (byte)((bits >> 8) & 0xff)'                 (byte)(bits & 0xff) };             }           case CBORObjectTypeDouble: {               var value = (double)this.ThisItem;               long bits = BitConverter.ToInt64(BitConverter.GetBytes(value)' 0);               return tagged ? new[] { tagbyte' (byte)0xfb'                 (byte)((bits >> 56) & 0xff)' (byte)((bits >> 48) & 0xff)'                 (byte)((bits >> 40) & 0xff)' (byte)((bits >> 32) & 0xff)'                 (byte)((bits >> 24) & 0xff)' (byte)((bits >> 16) & 0xff)'                 (byte)((bits >> 8) & 0xff)' (byte)(bits & 0xff) } :                 new[] { (byte)0xfb' (byte)((bits >> 56) & 0xff)'                 (byte)((bits >> 48) & 0xff)' (byte)((bits >> 40) & 0xff)'                 (byte)((bits >> 32) & 0xff)' (byte)((bits >> 24) & 0xff)'                 (byte)((bits >> 16) & 0xff)' (byte)((bits >> 8) & 0xff)'                 (byte)(bits & 0xff) };             }         }       }
Magic Number,PeterO.Cbor,CBORObject,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORObject.cs,EncodeToBytes,The following statement contains a magic number: if (!hasComplexTag) {         switch (this.ItemType) {           case CBORObjectTypeTextString: {               byte[] ret = GetOptimizedBytesIfShortAscii(                 this.AsString()' tagged ? (((int)tagbyte) & 0xff) : -1);               if (ret != null) {                 return ret;               }               break;             }           case CBORObjectTypeSimpleValue: {               if (tagged) {                 if (this.IsFalse) {                   return new[] { tagbyte' (byte)0xf4 };                 }                 if (this.IsTrue) {                   return new[] { tagbyte' (byte)0xf5 };                 }                 if (this.IsNull) {                   return new[] { tagbyte' (byte)0xf6 };                 }                 if (this.IsUndefined) {                   return new[] { tagbyte' (byte)0xf7 };                 }               } else {                 if (this.IsFalse) {                   return new[] { (byte)0xf4 };                 }                 if (this.IsTrue) {                   return new[] { (byte)0xf5 };                 }                 if (this.IsNull) {                   return new[] { (byte)0xf6 };                 }                 if (this.IsUndefined) {                   return new[] { (byte)0xf7 };                 }               }               break;             }           case CBORObjectTypeInteger: {               var value = (long)this.ThisItem;               byte[] intBytes = null;               if (value >= 0) {                 intBytes = GetPositiveInt64Bytes(0' value);               } else {                 ++value;                 value = -value;  // Will never overflow                 intBytes = GetPositiveInt64Bytes(1' value);               }               if (!tagged) {                 return intBytes;               }               var ret2 = new byte[intBytes.Length + 1];               Array.Copy(intBytes' 0' ret2' 1' intBytes.Length);               ret2[0] = tagbyte;               return ret2;             }           case CBORObjectTypeSingle: {               var value = (float)this.ThisItem;               int bits = BitConverter.ToInt32(BitConverter.GetBytes(value)' 0);               return tagged ? new[] { tagbyte' (byte)0xfa'                 (byte)((bits >> 24) & 0xff)' (byte)((bits >> 16) & 0xff)'                 (byte)((bits >> 8) & 0xff)' (byte)(bits & 0xff) } :                 new[] { (byte)0xfa' (byte)((bits >> 24) & 0xff)'                 (byte)((bits >> 16) & 0xff)' (byte)((bits >> 8) & 0xff)'                 (byte)(bits & 0xff) };             }           case CBORObjectTypeDouble: {               var value = (double)this.ThisItem;               long bits = BitConverter.ToInt64(BitConverter.GetBytes(value)' 0);               return tagged ? new[] { tagbyte' (byte)0xfb'                 (byte)((bits >> 56) & 0xff)' (byte)((bits >> 48) & 0xff)'                 (byte)((bits >> 40) & 0xff)' (byte)((bits >> 32) & 0xff)'                 (byte)((bits >> 24) & 0xff)' (byte)((bits >> 16) & 0xff)'                 (byte)((bits >> 8) & 0xff)' (byte)(bits & 0xff) } :                 new[] { (byte)0xfb' (byte)((bits >> 56) & 0xff)'                 (byte)((bits >> 48) & 0xff)' (byte)((bits >> 40) & 0xff)'                 (byte)((bits >> 32) & 0xff)' (byte)((bits >> 24) & 0xff)'                 (byte)((bits >> 16) & 0xff)' (byte)((bits >> 8) & 0xff)'                 (byte)(bits & 0xff) };             }         }       }
Magic Number,PeterO.Cbor,CBORObject,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORObject.cs,EncodeToBytes,The following statement contains a magic number: if (!hasComplexTag) {         switch (this.ItemType) {           case CBORObjectTypeTextString: {               byte[] ret = GetOptimizedBytesIfShortAscii(                 this.AsString()' tagged ? (((int)tagbyte) & 0xff) : -1);               if (ret != null) {                 return ret;               }               break;             }           case CBORObjectTypeSimpleValue: {               if (tagged) {                 if (this.IsFalse) {                   return new[] { tagbyte' (byte)0xf4 };                 }                 if (this.IsTrue) {                   return new[] { tagbyte' (byte)0xf5 };                 }                 if (this.IsNull) {                   return new[] { tagbyte' (byte)0xf6 };                 }                 if (this.IsUndefined) {                   return new[] { tagbyte' (byte)0xf7 };                 }               } else {                 if (this.IsFalse) {                   return new[] { (byte)0xf4 };                 }                 if (this.IsTrue) {                   return new[] { (byte)0xf5 };                 }                 if (this.IsNull) {                   return new[] { (byte)0xf6 };                 }                 if (this.IsUndefined) {                   return new[] { (byte)0xf7 };                 }               }               break;             }           case CBORObjectTypeInteger: {               var value = (long)this.ThisItem;               byte[] intBytes = null;               if (value >= 0) {                 intBytes = GetPositiveInt64Bytes(0' value);               } else {                 ++value;                 value = -value;  // Will never overflow                 intBytes = GetPositiveInt64Bytes(1' value);               }               if (!tagged) {                 return intBytes;               }               var ret2 = new byte[intBytes.Length + 1];               Array.Copy(intBytes' 0' ret2' 1' intBytes.Length);               ret2[0] = tagbyte;               return ret2;             }           case CBORObjectTypeSingle: {               var value = (float)this.ThisItem;               int bits = BitConverter.ToInt32(BitConverter.GetBytes(value)' 0);               return tagged ? new[] { tagbyte' (byte)0xfa'                 (byte)((bits >> 24) & 0xff)' (byte)((bits >> 16) & 0xff)'                 (byte)((bits >> 8) & 0xff)' (byte)(bits & 0xff) } :                 new[] { (byte)0xfa' (byte)((bits >> 24) & 0xff)'                 (byte)((bits >> 16) & 0xff)' (byte)((bits >> 8) & 0xff)'                 (byte)(bits & 0xff) };             }           case CBORObjectTypeDouble: {               var value = (double)this.ThisItem;               long bits = BitConverter.ToInt64(BitConverter.GetBytes(value)' 0);               return tagged ? new[] { tagbyte' (byte)0xfb'                 (byte)((bits >> 56) & 0xff)' (byte)((bits >> 48) & 0xff)'                 (byte)((bits >> 40) & 0xff)' (byte)((bits >> 32) & 0xff)'                 (byte)((bits >> 24) & 0xff)' (byte)((bits >> 16) & 0xff)'                 (byte)((bits >> 8) & 0xff)' (byte)(bits & 0xff) } :                 new[] { (byte)0xfb' (byte)((bits >> 56) & 0xff)'                 (byte)((bits >> 48) & 0xff)' (byte)((bits >> 40) & 0xff)'                 (byte)((bits >> 32) & 0xff)' (byte)((bits >> 24) & 0xff)'                 (byte)((bits >> 16) & 0xff)' (byte)((bits >> 8) & 0xff)'                 (byte)(bits & 0xff) };             }         }       }
Magic Number,PeterO.Cbor,CBORObject,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORObject.cs,EncodeToBytes,The following statement contains a magic number: if (!hasComplexTag) {         switch (this.ItemType) {           case CBORObjectTypeTextString: {               byte[] ret = GetOptimizedBytesIfShortAscii(                 this.AsString()' tagged ? (((int)tagbyte) & 0xff) : -1);               if (ret != null) {                 return ret;               }               break;             }           case CBORObjectTypeSimpleValue: {               if (tagged) {                 if (this.IsFalse) {                   return new[] { tagbyte' (byte)0xf4 };                 }                 if (this.IsTrue) {                   return new[] { tagbyte' (byte)0xf5 };                 }                 if (this.IsNull) {                   return new[] { tagbyte' (byte)0xf6 };                 }                 if (this.IsUndefined) {                   return new[] { tagbyte' (byte)0xf7 };                 }               } else {                 if (this.IsFalse) {                   return new[] { (byte)0xf4 };                 }                 if (this.IsTrue) {                   return new[] { (byte)0xf5 };                 }                 if (this.IsNull) {                   return new[] { (byte)0xf6 };                 }                 if (this.IsUndefined) {                   return new[] { (byte)0xf7 };                 }               }               break;             }           case CBORObjectTypeInteger: {               var value = (long)this.ThisItem;               byte[] intBytes = null;               if (value >= 0) {                 intBytes = GetPositiveInt64Bytes(0' value);               } else {                 ++value;                 value = -value;  // Will never overflow                 intBytes = GetPositiveInt64Bytes(1' value);               }               if (!tagged) {                 return intBytes;               }               var ret2 = new byte[intBytes.Length + 1];               Array.Copy(intBytes' 0' ret2' 1' intBytes.Length);               ret2[0] = tagbyte;               return ret2;             }           case CBORObjectTypeSingle: {               var value = (float)this.ThisItem;               int bits = BitConverter.ToInt32(BitConverter.GetBytes(value)' 0);               return tagged ? new[] { tagbyte' (byte)0xfa'                 (byte)((bits >> 24) & 0xff)' (byte)((bits >> 16) & 0xff)'                 (byte)((bits >> 8) & 0xff)' (byte)(bits & 0xff) } :                 new[] { (byte)0xfa' (byte)((bits >> 24) & 0xff)'                 (byte)((bits >> 16) & 0xff)' (byte)((bits >> 8) & 0xff)'                 (byte)(bits & 0xff) };             }           case CBORObjectTypeDouble: {               var value = (double)this.ThisItem;               long bits = BitConverter.ToInt64(BitConverter.GetBytes(value)' 0);               return tagged ? new[] { tagbyte' (byte)0xfb'                 (byte)((bits >> 56) & 0xff)' (byte)((bits >> 48) & 0xff)'                 (byte)((bits >> 40) & 0xff)' (byte)((bits >> 32) & 0xff)'                 (byte)((bits >> 24) & 0xff)' (byte)((bits >> 16) & 0xff)'                 (byte)((bits >> 8) & 0xff)' (byte)(bits & 0xff) } :                 new[] { (byte)0xfb' (byte)((bits >> 56) & 0xff)'                 (byte)((bits >> 48) & 0xff)' (byte)((bits >> 40) & 0xff)'                 (byte)((bits >> 32) & 0xff)' (byte)((bits >> 24) & 0xff)'                 (byte)((bits >> 16) & 0xff)' (byte)((bits >> 8) & 0xff)'                 (byte)(bits & 0xff) };             }         }       }
Magic Number,PeterO.Cbor,CBORObject,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORObject.cs,EncodeToBytes,The following statement contains a magic number: if (!hasComplexTag) {         switch (this.ItemType) {           case CBORObjectTypeTextString: {               byte[] ret = GetOptimizedBytesIfShortAscii(                 this.AsString()' tagged ? (((int)tagbyte) & 0xff) : -1);               if (ret != null) {                 return ret;               }               break;             }           case CBORObjectTypeSimpleValue: {               if (tagged) {                 if (this.IsFalse) {                   return new[] { tagbyte' (byte)0xf4 };                 }                 if (this.IsTrue) {                   return new[] { tagbyte' (byte)0xf5 };                 }                 if (this.IsNull) {                   return new[] { tagbyte' (byte)0xf6 };                 }                 if (this.IsUndefined) {                   return new[] { tagbyte' (byte)0xf7 };                 }               } else {                 if (this.IsFalse) {                   return new[] { (byte)0xf4 };                 }                 if (this.IsTrue) {                   return new[] { (byte)0xf5 };                 }                 if (this.IsNull) {                   return new[] { (byte)0xf6 };                 }                 if (this.IsUndefined) {                   return new[] { (byte)0xf7 };                 }               }               break;             }           case CBORObjectTypeInteger: {               var value = (long)this.ThisItem;               byte[] intBytes = null;               if (value >= 0) {                 intBytes = GetPositiveInt64Bytes(0' value);               } else {                 ++value;                 value = -value;  // Will never overflow                 intBytes = GetPositiveInt64Bytes(1' value);               }               if (!tagged) {                 return intBytes;               }               var ret2 = new byte[intBytes.Length + 1];               Array.Copy(intBytes' 0' ret2' 1' intBytes.Length);               ret2[0] = tagbyte;               return ret2;             }           case CBORObjectTypeSingle: {               var value = (float)this.ThisItem;               int bits = BitConverter.ToInt32(BitConverter.GetBytes(value)' 0);               return tagged ? new[] { tagbyte' (byte)0xfa'                 (byte)((bits >> 24) & 0xff)' (byte)((bits >> 16) & 0xff)'                 (byte)((bits >> 8) & 0xff)' (byte)(bits & 0xff) } :                 new[] { (byte)0xfa' (byte)((bits >> 24) & 0xff)'                 (byte)((bits >> 16) & 0xff)' (byte)((bits >> 8) & 0xff)'                 (byte)(bits & 0xff) };             }           case CBORObjectTypeDouble: {               var value = (double)this.ThisItem;               long bits = BitConverter.ToInt64(BitConverter.GetBytes(value)' 0);               return tagged ? new[] { tagbyte' (byte)0xfb'                 (byte)((bits >> 56) & 0xff)' (byte)((bits >> 48) & 0xff)'                 (byte)((bits >> 40) & 0xff)' (byte)((bits >> 32) & 0xff)'                 (byte)((bits >> 24) & 0xff)' (byte)((bits >> 16) & 0xff)'                 (byte)((bits >> 8) & 0xff)' (byte)(bits & 0xff) } :                 new[] { (byte)0xfb' (byte)((bits >> 56) & 0xff)'                 (byte)((bits >> 48) & 0xff)' (byte)((bits >> 40) & 0xff)'                 (byte)((bits >> 32) & 0xff)' (byte)((bits >> 24) & 0xff)'                 (byte)((bits >> 16) & 0xff)' (byte)((bits >> 8) & 0xff)'                 (byte)(bits & 0xff) };             }         }       }
Magic Number,PeterO.Cbor,CBORObject,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORObject.cs,EncodeToBytes,The following statement contains a magic number: if (!hasComplexTag) {         switch (this.ItemType) {           case CBORObjectTypeTextString: {               byte[] ret = GetOptimizedBytesIfShortAscii(                 this.AsString()' tagged ? (((int)tagbyte) & 0xff) : -1);               if (ret != null) {                 return ret;               }               break;             }           case CBORObjectTypeSimpleValue: {               if (tagged) {                 if (this.IsFalse) {                   return new[] { tagbyte' (byte)0xf4 };                 }                 if (this.IsTrue) {                   return new[] { tagbyte' (byte)0xf5 };                 }                 if (this.IsNull) {                   return new[] { tagbyte' (byte)0xf6 };                 }                 if (this.IsUndefined) {                   return new[] { tagbyte' (byte)0xf7 };                 }               } else {                 if (this.IsFalse) {                   return new[] { (byte)0xf4 };                 }                 if (this.IsTrue) {                   return new[] { (byte)0xf5 };                 }                 if (this.IsNull) {                   return new[] { (byte)0xf6 };                 }                 if (this.IsUndefined) {                   return new[] { (byte)0xf7 };                 }               }               break;             }           case CBORObjectTypeInteger: {               var value = (long)this.ThisItem;               byte[] intBytes = null;               if (value >= 0) {                 intBytes = GetPositiveInt64Bytes(0' value);               } else {                 ++value;                 value = -value;  // Will never overflow                 intBytes = GetPositiveInt64Bytes(1' value);               }               if (!tagged) {                 return intBytes;               }               var ret2 = new byte[intBytes.Length + 1];               Array.Copy(intBytes' 0' ret2' 1' intBytes.Length);               ret2[0] = tagbyte;               return ret2;             }           case CBORObjectTypeSingle: {               var value = (float)this.ThisItem;               int bits = BitConverter.ToInt32(BitConverter.GetBytes(value)' 0);               return tagged ? new[] { tagbyte' (byte)0xfa'                 (byte)((bits >> 24) & 0xff)' (byte)((bits >> 16) & 0xff)'                 (byte)((bits >> 8) & 0xff)' (byte)(bits & 0xff) } :                 new[] { (byte)0xfa' (byte)((bits >> 24) & 0xff)'                 (byte)((bits >> 16) & 0xff)' (byte)((bits >> 8) & 0xff)'                 (byte)(bits & 0xff) };             }           case CBORObjectTypeDouble: {               var value = (double)this.ThisItem;               long bits = BitConverter.ToInt64(BitConverter.GetBytes(value)' 0);               return tagged ? new[] { tagbyte' (byte)0xfb'                 (byte)((bits >> 56) & 0xff)' (byte)((bits >> 48) & 0xff)'                 (byte)((bits >> 40) & 0xff)' (byte)((bits >> 32) & 0xff)'                 (byte)((bits >> 24) & 0xff)' (byte)((bits >> 16) & 0xff)'                 (byte)((bits >> 8) & 0xff)' (byte)(bits & 0xff) } :                 new[] { (byte)0xfb' (byte)((bits >> 56) & 0xff)'                 (byte)((bits >> 48) & 0xff)' (byte)((bits >> 40) & 0xff)'                 (byte)((bits >> 32) & 0xff)' (byte)((bits >> 24) & 0xff)'                 (byte)((bits >> 16) & 0xff)' (byte)((bits >> 8) & 0xff)'                 (byte)(bits & 0xff) };             }         }       }
Magic Number,PeterO.Cbor,CBORObject,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORObject.cs,EncodeToBytes,The following statement contains a magic number: if (!hasComplexTag) {         switch (this.ItemType) {           case CBORObjectTypeTextString: {               byte[] ret = GetOptimizedBytesIfShortAscii(                 this.AsString()' tagged ? (((int)tagbyte) & 0xff) : -1);               if (ret != null) {                 return ret;               }               break;             }           case CBORObjectTypeSimpleValue: {               if (tagged) {                 if (this.IsFalse) {                   return new[] { tagbyte' (byte)0xf4 };                 }                 if (this.IsTrue) {                   return new[] { tagbyte' (byte)0xf5 };                 }                 if (this.IsNull) {                   return new[] { tagbyte' (byte)0xf6 };                 }                 if (this.IsUndefined) {                   return new[] { tagbyte' (byte)0xf7 };                 }               } else {                 if (this.IsFalse) {                   return new[] { (byte)0xf4 };                 }                 if (this.IsTrue) {                   return new[] { (byte)0xf5 };                 }                 if (this.IsNull) {                   return new[] { (byte)0xf6 };                 }                 if (this.IsUndefined) {                   return new[] { (byte)0xf7 };                 }               }               break;             }           case CBORObjectTypeInteger: {               var value = (long)this.ThisItem;               byte[] intBytes = null;               if (value >= 0) {                 intBytes = GetPositiveInt64Bytes(0' value);               } else {                 ++value;                 value = -value;  // Will never overflow                 intBytes = GetPositiveInt64Bytes(1' value);               }               if (!tagged) {                 return intBytes;               }               var ret2 = new byte[intBytes.Length + 1];               Array.Copy(intBytes' 0' ret2' 1' intBytes.Length);               ret2[0] = tagbyte;               return ret2;             }           case CBORObjectTypeSingle: {               var value = (float)this.ThisItem;               int bits = BitConverter.ToInt32(BitConverter.GetBytes(value)' 0);               return tagged ? new[] { tagbyte' (byte)0xfa'                 (byte)((bits >> 24) & 0xff)' (byte)((bits >> 16) & 0xff)'                 (byte)((bits >> 8) & 0xff)' (byte)(bits & 0xff) } :                 new[] { (byte)0xfa' (byte)((bits >> 24) & 0xff)'                 (byte)((bits >> 16) & 0xff)' (byte)((bits >> 8) & 0xff)'                 (byte)(bits & 0xff) };             }           case CBORObjectTypeDouble: {               var value = (double)this.ThisItem;               long bits = BitConverter.ToInt64(BitConverter.GetBytes(value)' 0);               return tagged ? new[] { tagbyte' (byte)0xfb'                 (byte)((bits >> 56) & 0xff)' (byte)((bits >> 48) & 0xff)'                 (byte)((bits >> 40) & 0xff)' (byte)((bits >> 32) & 0xff)'                 (byte)((bits >> 24) & 0xff)' (byte)((bits >> 16) & 0xff)'                 (byte)((bits >> 8) & 0xff)' (byte)(bits & 0xff) } :                 new[] { (byte)0xfb' (byte)((bits >> 56) & 0xff)'                 (byte)((bits >> 48) & 0xff)' (byte)((bits >> 40) & 0xff)'                 (byte)((bits >> 32) & 0xff)' (byte)((bits >> 24) & 0xff)'                 (byte)((bits >> 16) & 0xff)' (byte)((bits >> 8) & 0xff)'                 (byte)(bits & 0xff) };             }         }       }
Magic Number,PeterO.Cbor,CBORObject,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORObject.cs,EncodeToBytes,The following statement contains a magic number: if (!hasComplexTag) {         switch (this.ItemType) {           case CBORObjectTypeTextString: {               byte[] ret = GetOptimizedBytesIfShortAscii(                 this.AsString()' tagged ? (((int)tagbyte) & 0xff) : -1);               if (ret != null) {                 return ret;               }               break;             }           case CBORObjectTypeSimpleValue: {               if (tagged) {                 if (this.IsFalse) {                   return new[] { tagbyte' (byte)0xf4 };                 }                 if (this.IsTrue) {                   return new[] { tagbyte' (byte)0xf5 };                 }                 if (this.IsNull) {                   return new[] { tagbyte' (byte)0xf6 };                 }                 if (this.IsUndefined) {                   return new[] { tagbyte' (byte)0xf7 };                 }               } else {                 if (this.IsFalse) {                   return new[] { (byte)0xf4 };                 }                 if (this.IsTrue) {                   return new[] { (byte)0xf5 };                 }                 if (this.IsNull) {                   return new[] { (byte)0xf6 };                 }                 if (this.IsUndefined) {                   return new[] { (byte)0xf7 };                 }               }               break;             }           case CBORObjectTypeInteger: {               var value = (long)this.ThisItem;               byte[] intBytes = null;               if (value >= 0) {                 intBytes = GetPositiveInt64Bytes(0' value);               } else {                 ++value;                 value = -value;  // Will never overflow                 intBytes = GetPositiveInt64Bytes(1' value);               }               if (!tagged) {                 return intBytes;               }               var ret2 = new byte[intBytes.Length + 1];               Array.Copy(intBytes' 0' ret2' 1' intBytes.Length);               ret2[0] = tagbyte;               return ret2;             }           case CBORObjectTypeSingle: {               var value = (float)this.ThisItem;               int bits = BitConverter.ToInt32(BitConverter.GetBytes(value)' 0);               return tagged ? new[] { tagbyte' (byte)0xfa'                 (byte)((bits >> 24) & 0xff)' (byte)((bits >> 16) & 0xff)'                 (byte)((bits >> 8) & 0xff)' (byte)(bits & 0xff) } :                 new[] { (byte)0xfa' (byte)((bits >> 24) & 0xff)'                 (byte)((bits >> 16) & 0xff)' (byte)((bits >> 8) & 0xff)'                 (byte)(bits & 0xff) };             }           case CBORObjectTypeDouble: {               var value = (double)this.ThisItem;               long bits = BitConverter.ToInt64(BitConverter.GetBytes(value)' 0);               return tagged ? new[] { tagbyte' (byte)0xfb'                 (byte)((bits >> 56) & 0xff)' (byte)((bits >> 48) & 0xff)'                 (byte)((bits >> 40) & 0xff)' (byte)((bits >> 32) & 0xff)'                 (byte)((bits >> 24) & 0xff)' (byte)((bits >> 16) & 0xff)'                 (byte)((bits >> 8) & 0xff)' (byte)(bits & 0xff) } :                 new[] { (byte)0xfb' (byte)((bits >> 56) & 0xff)'                 (byte)((bits >> 48) & 0xff)' (byte)((bits >> 40) & 0xff)'                 (byte)((bits >> 32) & 0xff)' (byte)((bits >> 24) & 0xff)'                 (byte)((bits >> 16) & 0xff)' (byte)((bits >> 8) & 0xff)'                 (byte)(bits & 0xff) };             }         }       }
Magic Number,PeterO.Cbor,CBORObject,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORObject.cs,EncodeToBytes,The following statement contains a magic number: if (!hasComplexTag) {         switch (this.ItemType) {           case CBORObjectTypeTextString: {               byte[] ret = GetOptimizedBytesIfShortAscii(                 this.AsString()' tagged ? (((int)tagbyte) & 0xff) : -1);               if (ret != null) {                 return ret;               }               break;             }           case CBORObjectTypeSimpleValue: {               if (tagged) {                 if (this.IsFalse) {                   return new[] { tagbyte' (byte)0xf4 };                 }                 if (this.IsTrue) {                   return new[] { tagbyte' (byte)0xf5 };                 }                 if (this.IsNull) {                   return new[] { tagbyte' (byte)0xf6 };                 }                 if (this.IsUndefined) {                   return new[] { tagbyte' (byte)0xf7 };                 }               } else {                 if (this.IsFalse) {                   return new[] { (byte)0xf4 };                 }                 if (this.IsTrue) {                   return new[] { (byte)0xf5 };                 }                 if (this.IsNull) {                   return new[] { (byte)0xf6 };                 }                 if (this.IsUndefined) {                   return new[] { (byte)0xf7 };                 }               }               break;             }           case CBORObjectTypeInteger: {               var value = (long)this.ThisItem;               byte[] intBytes = null;               if (value >= 0) {                 intBytes = GetPositiveInt64Bytes(0' value);               } else {                 ++value;                 value = -value;  // Will never overflow                 intBytes = GetPositiveInt64Bytes(1' value);               }               if (!tagged) {                 return intBytes;               }               var ret2 = new byte[intBytes.Length + 1];               Array.Copy(intBytes' 0' ret2' 1' intBytes.Length);               ret2[0] = tagbyte;               return ret2;             }           case CBORObjectTypeSingle: {               var value = (float)this.ThisItem;               int bits = BitConverter.ToInt32(BitConverter.GetBytes(value)' 0);               return tagged ? new[] { tagbyte' (byte)0xfa'                 (byte)((bits >> 24) & 0xff)' (byte)((bits >> 16) & 0xff)'                 (byte)((bits >> 8) & 0xff)' (byte)(bits & 0xff) } :                 new[] { (byte)0xfa' (byte)((bits >> 24) & 0xff)'                 (byte)((bits >> 16) & 0xff)' (byte)((bits >> 8) & 0xff)'                 (byte)(bits & 0xff) };             }           case CBORObjectTypeDouble: {               var value = (double)this.ThisItem;               long bits = BitConverter.ToInt64(BitConverter.GetBytes(value)' 0);               return tagged ? new[] { tagbyte' (byte)0xfb'                 (byte)((bits >> 56) & 0xff)' (byte)((bits >> 48) & 0xff)'                 (byte)((bits >> 40) & 0xff)' (byte)((bits >> 32) & 0xff)'                 (byte)((bits >> 24) & 0xff)' (byte)((bits >> 16) & 0xff)'                 (byte)((bits >> 8) & 0xff)' (byte)(bits & 0xff) } :                 new[] { (byte)0xfb' (byte)((bits >> 56) & 0xff)'                 (byte)((bits >> 48) & 0xff)' (byte)((bits >> 40) & 0xff)'                 (byte)((bits >> 32) & 0xff)' (byte)((bits >> 24) & 0xff)'                 (byte)((bits >> 16) & 0xff)' (byte)((bits >> 8) & 0xff)'                 (byte)(bits & 0xff) };             }         }       }
Magic Number,PeterO.Cbor,CBORObject,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORObject.cs,EncodeToBytes,The following statement contains a magic number: if (!hasComplexTag) {         switch (this.ItemType) {           case CBORObjectTypeTextString: {               byte[] ret = GetOptimizedBytesIfShortAscii(                 this.AsString()' tagged ? (((int)tagbyte) & 0xff) : -1);               if (ret != null) {                 return ret;               }               break;             }           case CBORObjectTypeSimpleValue: {               if (tagged) {                 if (this.IsFalse) {                   return new[] { tagbyte' (byte)0xf4 };                 }                 if (this.IsTrue) {                   return new[] { tagbyte' (byte)0xf5 };                 }                 if (this.IsNull) {                   return new[] { tagbyte' (byte)0xf6 };                 }                 if (this.IsUndefined) {                   return new[] { tagbyte' (byte)0xf7 };                 }               } else {                 if (this.IsFalse) {                   return new[] { (byte)0xf4 };                 }                 if (this.IsTrue) {                   return new[] { (byte)0xf5 };                 }                 if (this.IsNull) {                   return new[] { (byte)0xf6 };                 }                 if (this.IsUndefined) {                   return new[] { (byte)0xf7 };                 }               }               break;             }           case CBORObjectTypeInteger: {               var value = (long)this.ThisItem;               byte[] intBytes = null;               if (value >= 0) {                 intBytes = GetPositiveInt64Bytes(0' value);               } else {                 ++value;                 value = -value;  // Will never overflow                 intBytes = GetPositiveInt64Bytes(1' value);               }               if (!tagged) {                 return intBytes;               }               var ret2 = new byte[intBytes.Length + 1];               Array.Copy(intBytes' 0' ret2' 1' intBytes.Length);               ret2[0] = tagbyte;               return ret2;             }           case CBORObjectTypeSingle: {               var value = (float)this.ThisItem;               int bits = BitConverter.ToInt32(BitConverter.GetBytes(value)' 0);               return tagged ? new[] { tagbyte' (byte)0xfa'                 (byte)((bits >> 24) & 0xff)' (byte)((bits >> 16) & 0xff)'                 (byte)((bits >> 8) & 0xff)' (byte)(bits & 0xff) } :                 new[] { (byte)0xfa' (byte)((bits >> 24) & 0xff)'                 (byte)((bits >> 16) & 0xff)' (byte)((bits >> 8) & 0xff)'                 (byte)(bits & 0xff) };             }           case CBORObjectTypeDouble: {               var value = (double)this.ThisItem;               long bits = BitConverter.ToInt64(BitConverter.GetBytes(value)' 0);               return tagged ? new[] { tagbyte' (byte)0xfb'                 (byte)((bits >> 56) & 0xff)' (byte)((bits >> 48) & 0xff)'                 (byte)((bits >> 40) & 0xff)' (byte)((bits >> 32) & 0xff)'                 (byte)((bits >> 24) & 0xff)' (byte)((bits >> 16) & 0xff)'                 (byte)((bits >> 8) & 0xff)' (byte)(bits & 0xff) } :                 new[] { (byte)0xfb' (byte)((bits >> 56) & 0xff)'                 (byte)((bits >> 48) & 0xff)' (byte)((bits >> 40) & 0xff)'                 (byte)((bits >> 32) & 0xff)' (byte)((bits >> 24) & 0xff)'                 (byte)((bits >> 16) & 0xff)' (byte)((bits >> 8) & 0xff)'                 (byte)(bits & 0xff) };             }         }       }
Magic Number,PeterO.Cbor,CBORObject,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORObject.cs,EncodeToBytes,The following statement contains a magic number: if (!hasComplexTag) {         switch (this.ItemType) {           case CBORObjectTypeTextString: {               byte[] ret = GetOptimizedBytesIfShortAscii(                 this.AsString()' tagged ? (((int)tagbyte) & 0xff) : -1);               if (ret != null) {                 return ret;               }               break;             }           case CBORObjectTypeSimpleValue: {               if (tagged) {                 if (this.IsFalse) {                   return new[] { tagbyte' (byte)0xf4 };                 }                 if (this.IsTrue) {                   return new[] { tagbyte' (byte)0xf5 };                 }                 if (this.IsNull) {                   return new[] { tagbyte' (byte)0xf6 };                 }                 if (this.IsUndefined) {                   return new[] { tagbyte' (byte)0xf7 };                 }               } else {                 if (this.IsFalse) {                   return new[] { (byte)0xf4 };                 }                 if (this.IsTrue) {                   return new[] { (byte)0xf5 };                 }                 if (this.IsNull) {                   return new[] { (byte)0xf6 };                 }                 if (this.IsUndefined) {                   return new[] { (byte)0xf7 };                 }               }               break;             }           case CBORObjectTypeInteger: {               var value = (long)this.ThisItem;               byte[] intBytes = null;               if (value >= 0) {                 intBytes = GetPositiveInt64Bytes(0' value);               } else {                 ++value;                 value = -value;  // Will never overflow                 intBytes = GetPositiveInt64Bytes(1' value);               }               if (!tagged) {                 return intBytes;               }               var ret2 = new byte[intBytes.Length + 1];               Array.Copy(intBytes' 0' ret2' 1' intBytes.Length);               ret2[0] = tagbyte;               return ret2;             }           case CBORObjectTypeSingle: {               var value = (float)this.ThisItem;               int bits = BitConverter.ToInt32(BitConverter.GetBytes(value)' 0);               return tagged ? new[] { tagbyte' (byte)0xfa'                 (byte)((bits >> 24) & 0xff)' (byte)((bits >> 16) & 0xff)'                 (byte)((bits >> 8) & 0xff)' (byte)(bits & 0xff) } :                 new[] { (byte)0xfa' (byte)((bits >> 24) & 0xff)'                 (byte)((bits >> 16) & 0xff)' (byte)((bits >> 8) & 0xff)'                 (byte)(bits & 0xff) };             }           case CBORObjectTypeDouble: {               var value = (double)this.ThisItem;               long bits = BitConverter.ToInt64(BitConverter.GetBytes(value)' 0);               return tagged ? new[] { tagbyte' (byte)0xfb'                 (byte)((bits >> 56) & 0xff)' (byte)((bits >> 48) & 0xff)'                 (byte)((bits >> 40) & 0xff)' (byte)((bits >> 32) & 0xff)'                 (byte)((bits >> 24) & 0xff)' (byte)((bits >> 16) & 0xff)'                 (byte)((bits >> 8) & 0xff)' (byte)(bits & 0xff) } :                 new[] { (byte)0xfb' (byte)((bits >> 56) & 0xff)'                 (byte)((bits >> 48) & 0xff)' (byte)((bits >> 40) & 0xff)'                 (byte)((bits >> 32) & 0xff)' (byte)((bits >> 24) & 0xff)'                 (byte)((bits >> 16) & 0xff)' (byte)((bits >> 8) & 0xff)'                 (byte)(bits & 0xff) };             }         }       }
Magic Number,PeterO.Cbor,CBORObject,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORObject.cs,EncodeToBytes,The following statement contains a magic number: if (!hasComplexTag) {         switch (this.ItemType) {           case CBORObjectTypeTextString: {               byte[] ret = GetOptimizedBytesIfShortAscii(                 this.AsString()' tagged ? (((int)tagbyte) & 0xff) : -1);               if (ret != null) {                 return ret;               }               break;             }           case CBORObjectTypeSimpleValue: {               if (tagged) {                 if (this.IsFalse) {                   return new[] { tagbyte' (byte)0xf4 };                 }                 if (this.IsTrue) {                   return new[] { tagbyte' (byte)0xf5 };                 }                 if (this.IsNull) {                   return new[] { tagbyte' (byte)0xf6 };                 }                 if (this.IsUndefined) {                   return new[] { tagbyte' (byte)0xf7 };                 }               } else {                 if (this.IsFalse) {                   return new[] { (byte)0xf4 };                 }                 if (this.IsTrue) {                   return new[] { (byte)0xf5 };                 }                 if (this.IsNull) {                   return new[] { (byte)0xf6 };                 }                 if (this.IsUndefined) {                   return new[] { (byte)0xf7 };                 }               }               break;             }           case CBORObjectTypeInteger: {               var value = (long)this.ThisItem;               byte[] intBytes = null;               if (value >= 0) {                 intBytes = GetPositiveInt64Bytes(0' value);               } else {                 ++value;                 value = -value;  // Will never overflow                 intBytes = GetPositiveInt64Bytes(1' value);               }               if (!tagged) {                 return intBytes;               }               var ret2 = new byte[intBytes.Length + 1];               Array.Copy(intBytes' 0' ret2' 1' intBytes.Length);               ret2[0] = tagbyte;               return ret2;             }           case CBORObjectTypeSingle: {               var value = (float)this.ThisItem;               int bits = BitConverter.ToInt32(BitConverter.GetBytes(value)' 0);               return tagged ? new[] { tagbyte' (byte)0xfa'                 (byte)((bits >> 24) & 0xff)' (byte)((bits >> 16) & 0xff)'                 (byte)((bits >> 8) & 0xff)' (byte)(bits & 0xff) } :                 new[] { (byte)0xfa' (byte)((bits >> 24) & 0xff)'                 (byte)((bits >> 16) & 0xff)' (byte)((bits >> 8) & 0xff)'                 (byte)(bits & 0xff) };             }           case CBORObjectTypeDouble: {               var value = (double)this.ThisItem;               long bits = BitConverter.ToInt64(BitConverter.GetBytes(value)' 0);               return tagged ? new[] { tagbyte' (byte)0xfb'                 (byte)((bits >> 56) & 0xff)' (byte)((bits >> 48) & 0xff)'                 (byte)((bits >> 40) & 0xff)' (byte)((bits >> 32) & 0xff)'                 (byte)((bits >> 24) & 0xff)' (byte)((bits >> 16) & 0xff)'                 (byte)((bits >> 8) & 0xff)' (byte)(bits & 0xff) } :                 new[] { (byte)0xfb' (byte)((bits >> 56) & 0xff)'                 (byte)((bits >> 48) & 0xff)' (byte)((bits >> 40) & 0xff)'                 (byte)((bits >> 32) & 0xff)' (byte)((bits >> 24) & 0xff)'                 (byte)((bits >> 16) & 0xff)' (byte)((bits >> 8) & 0xff)'                 (byte)(bits & 0xff) };             }         }       }
Magic Number,PeterO.Cbor,CBORObject,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORObject.cs,EncodeToBytes,The following statement contains a magic number: if (!hasComplexTag) {         switch (this.ItemType) {           case CBORObjectTypeTextString: {               byte[] ret = GetOptimizedBytesIfShortAscii(                 this.AsString()' tagged ? (((int)tagbyte) & 0xff) : -1);               if (ret != null) {                 return ret;               }               break;             }           case CBORObjectTypeSimpleValue: {               if (tagged) {                 if (this.IsFalse) {                   return new[] { tagbyte' (byte)0xf4 };                 }                 if (this.IsTrue) {                   return new[] { tagbyte' (byte)0xf5 };                 }                 if (this.IsNull) {                   return new[] { tagbyte' (byte)0xf6 };                 }                 if (this.IsUndefined) {                   return new[] { tagbyte' (byte)0xf7 };                 }               } else {                 if (this.IsFalse) {                   return new[] { (byte)0xf4 };                 }                 if (this.IsTrue) {                   return new[] { (byte)0xf5 };                 }                 if (this.IsNull) {                   return new[] { (byte)0xf6 };                 }                 if (this.IsUndefined) {                   return new[] { (byte)0xf7 };                 }               }               break;             }           case CBORObjectTypeInteger: {               var value = (long)this.ThisItem;               byte[] intBytes = null;               if (value >= 0) {                 intBytes = GetPositiveInt64Bytes(0' value);               } else {                 ++value;                 value = -value;  // Will never overflow                 intBytes = GetPositiveInt64Bytes(1' value);               }               if (!tagged) {                 return intBytes;               }               var ret2 = new byte[intBytes.Length + 1];               Array.Copy(intBytes' 0' ret2' 1' intBytes.Length);               ret2[0] = tagbyte;               return ret2;             }           case CBORObjectTypeSingle: {               var value = (float)this.ThisItem;               int bits = BitConverter.ToInt32(BitConverter.GetBytes(value)' 0);               return tagged ? new[] { tagbyte' (byte)0xfa'                 (byte)((bits >> 24) & 0xff)' (byte)((bits >> 16) & 0xff)'                 (byte)((bits >> 8) & 0xff)' (byte)(bits & 0xff) } :                 new[] { (byte)0xfa' (byte)((bits >> 24) & 0xff)'                 (byte)((bits >> 16) & 0xff)' (byte)((bits >> 8) & 0xff)'                 (byte)(bits & 0xff) };             }           case CBORObjectTypeDouble: {               var value = (double)this.ThisItem;               long bits = BitConverter.ToInt64(BitConverter.GetBytes(value)' 0);               return tagged ? new[] { tagbyte' (byte)0xfb'                 (byte)((bits >> 56) & 0xff)' (byte)((bits >> 48) & 0xff)'                 (byte)((bits >> 40) & 0xff)' (byte)((bits >> 32) & 0xff)'                 (byte)((bits >> 24) & 0xff)' (byte)((bits >> 16) & 0xff)'                 (byte)((bits >> 8) & 0xff)' (byte)(bits & 0xff) } :                 new[] { (byte)0xfb' (byte)((bits >> 56) & 0xff)'                 (byte)((bits >> 48) & 0xff)' (byte)((bits >> 40) & 0xff)'                 (byte)((bits >> 32) & 0xff)' (byte)((bits >> 24) & 0xff)'                 (byte)((bits >> 16) & 0xff)' (byte)((bits >> 8) & 0xff)'                 (byte)(bits & 0xff) };             }         }       }
Magic Number,PeterO.Cbor,CBORObject,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORObject.cs,EncodeToBytes,The following statement contains a magic number: try {         using (var ms = new MemoryStream(16)) {           this.WriteTo(ms' options);           return ms.ToArray();         }       } catch (IOException ex) {         throw new CBORException("I/O Error occurred"' ex);       }
Magic Number,PeterO.Cbor,CBORObject,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORObject.cs,GetHashCode,The following statement contains a magic number: var hashCode = 651869431;
Magic Number,PeterO.Cbor,CBORObject,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORObject.cs,GetHashCode,The following statement contains a magic number: unchecked {         if (this.itemValue != null) {           var itemHashCode = 0;           long longValue = 0L;           switch (this.itemtypeValue) {             case CBORObjectTypeByteString:               itemHashCode =                 CBORUtilities.ByteArrayHashCode((byte[])this.ThisItem);               break;             case CBORObjectTypeMap:               itemHashCode = CBORMapHashCode(this.AsMap());               break;             case CBORObjectTypeArray:               itemHashCode = CBORArrayHashCode(this.AsList());               break;             case CBORObjectTypeTextString:               itemHashCode = StringHashCode((string)this.itemValue);               break;             case CBORObjectTypeSimpleValue:               itemHashCode = (int)this.itemValue;               break;             case CBORObjectTypeSingle:               itemHashCode =   BitConverter.ToInt32(BitConverter.GetBytes((float)this.itemValue)' 0);               break;             case CBORObjectTypeDouble:               longValue =   BitConverter.ToInt64(BitConverter.GetBytes((double)this.itemValue)' 0);               longValue |= longValue >> 32;               itemHashCode = unchecked((int)longValue);               break;             case CBORObjectTypeInteger:               longValue = (long)this.itemValue;               longValue |= longValue >> 32;               itemHashCode = unchecked((int)longValue);               break;             default:               // EInteger' EFloat' EDecimal' ERational' CBORObject               itemHashCode = this.itemValue.GetHashCode();               break;           }           hashCode += 651869479 * itemHashCode;         }         hashCode += 651869483 * (this.itemtypeValue +                     this.tagLow + this.tagHigh);       }
Magic Number,PeterO.Cbor,CBORObject,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORObject.cs,GetHashCode,The following statement contains a magic number: unchecked {         if (this.itemValue != null) {           var itemHashCode = 0;           long longValue = 0L;           switch (this.itemtypeValue) {             case CBORObjectTypeByteString:               itemHashCode =                 CBORUtilities.ByteArrayHashCode((byte[])this.ThisItem);               break;             case CBORObjectTypeMap:               itemHashCode = CBORMapHashCode(this.AsMap());               break;             case CBORObjectTypeArray:               itemHashCode = CBORArrayHashCode(this.AsList());               break;             case CBORObjectTypeTextString:               itemHashCode = StringHashCode((string)this.itemValue);               break;             case CBORObjectTypeSimpleValue:               itemHashCode = (int)this.itemValue;               break;             case CBORObjectTypeSingle:               itemHashCode =   BitConverter.ToInt32(BitConverter.GetBytes((float)this.itemValue)' 0);               break;             case CBORObjectTypeDouble:               longValue =   BitConverter.ToInt64(BitConverter.GetBytes((double)this.itemValue)' 0);               longValue |= longValue >> 32;               itemHashCode = unchecked((int)longValue);               break;             case CBORObjectTypeInteger:               longValue = (long)this.itemValue;               longValue |= longValue >> 32;               itemHashCode = unchecked((int)longValue);               break;             default:               // EInteger' EFloat' EDecimal' ERational' CBORObject               itemHashCode = this.itemValue.GetHashCode();               break;           }           hashCode += 651869479 * itemHashCode;         }         hashCode += 651869483 * (this.itemtypeValue +                     this.tagLow + this.tagHigh);       }
Magic Number,PeterO.Cbor,CBORObject,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORObject.cs,GetHashCode,The following statement contains a magic number: unchecked {         if (this.itemValue != null) {           var itemHashCode = 0;           long longValue = 0L;           switch (this.itemtypeValue) {             case CBORObjectTypeByteString:               itemHashCode =                 CBORUtilities.ByteArrayHashCode((byte[])this.ThisItem);               break;             case CBORObjectTypeMap:               itemHashCode = CBORMapHashCode(this.AsMap());               break;             case CBORObjectTypeArray:               itemHashCode = CBORArrayHashCode(this.AsList());               break;             case CBORObjectTypeTextString:               itemHashCode = StringHashCode((string)this.itemValue);               break;             case CBORObjectTypeSimpleValue:               itemHashCode = (int)this.itemValue;               break;             case CBORObjectTypeSingle:               itemHashCode =   BitConverter.ToInt32(BitConverter.GetBytes((float)this.itemValue)' 0);               break;             case CBORObjectTypeDouble:               longValue =   BitConverter.ToInt64(BitConverter.GetBytes((double)this.itemValue)' 0);               longValue |= longValue >> 32;               itemHashCode = unchecked((int)longValue);               break;             case CBORObjectTypeInteger:               longValue = (long)this.itemValue;               longValue |= longValue >> 32;               itemHashCode = unchecked((int)longValue);               break;             default:               // EInteger' EFloat' EDecimal' ERational' CBORObject               itemHashCode = this.itemValue.GetHashCode();               break;           }           hashCode += 651869479 * itemHashCode;         }         hashCode += 651869483 * (this.itemtypeValue +                     this.tagLow + this.tagHigh);       }
Magic Number,PeterO.Cbor,CBORObject,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORObject.cs,GetHashCode,The following statement contains a magic number: unchecked {         if (this.itemValue != null) {           var itemHashCode = 0;           long longValue = 0L;           switch (this.itemtypeValue) {             case CBORObjectTypeByteString:               itemHashCode =                 CBORUtilities.ByteArrayHashCode((byte[])this.ThisItem);               break;             case CBORObjectTypeMap:               itemHashCode = CBORMapHashCode(this.AsMap());               break;             case CBORObjectTypeArray:               itemHashCode = CBORArrayHashCode(this.AsList());               break;             case CBORObjectTypeTextString:               itemHashCode = StringHashCode((string)this.itemValue);               break;             case CBORObjectTypeSimpleValue:               itemHashCode = (int)this.itemValue;               break;             case CBORObjectTypeSingle:               itemHashCode =   BitConverter.ToInt32(BitConverter.GetBytes((float)this.itemValue)' 0);               break;             case CBORObjectTypeDouble:               longValue =   BitConverter.ToInt64(BitConverter.GetBytes((double)this.itemValue)' 0);               longValue |= longValue >> 32;               itemHashCode = unchecked((int)longValue);               break;             case CBORObjectTypeInteger:               longValue = (long)this.itemValue;               longValue |= longValue >> 32;               itemHashCode = unchecked((int)longValue);               break;             default:               // EInteger' EFloat' EDecimal' ERational' CBORObject               itemHashCode = this.itemValue.GetHashCode();               break;           }           hashCode += 651869479 * itemHashCode;         }         hashCode += 651869483 * (this.itemtypeValue +                     this.tagLow + this.tagHigh);       }
Magic Number,PeterO.Cbor,CBORObject,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORObject.cs,ToString,The following statement contains a magic number: if (this.IsTagged) {         if (sb == null) {           if (type == CBORObjectTypeTextString) {             // The default capacity of StringBuilder may be too small             // for many strings' so set a suggested capacity             // explicitly             string str = this.AsString();             sb = new StringBuilder(Math.Min(str.Length' 4096) + 16);           } else {             sb = new StringBuilder();           }         }         this.AppendOpeningTags(sb);       }
Magic Number,PeterO.Cbor,CBORObject,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORObject.cs,ToString,The following statement contains a magic number: if (this.IsTagged) {         if (sb == null) {           if (type == CBORObjectTypeTextString) {             // The default capacity of StringBuilder may be too small             // for many strings' so set a suggested capacity             // explicitly             string str = this.AsString();             sb = new StringBuilder(Math.Min(str.Length' 4096) + 16);           } else {             sb = new StringBuilder();           }         }         this.AppendOpeningTags(sb);       }
Magic Number,PeterO.Cbor,CBORObject,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORObject.cs,WriteTo,The following statement contains a magic number: switch (type) {         case CBORObjectTypeInteger: {             Write((long)this.ThisItem' stream);             break;           }         case CBORObjectTypeBigInteger: {             Write((EInteger)this.ThisItem' stream);             break;           }         case CBORObjectTypeByteString: {             var arr = (byte[])this.ThisItem;             WritePositiveInt(               (this.ItemType == CBORObjectTypeByteString) ? 2 : 3'               arr.Length'               stream);             stream.Write(arr' 0' arr.Length);             break;           }         case CBORObjectTypeTextString: {             Write((string)this.ThisItem' stream' options);             break;           }         case CBORObjectTypeArray: {             WriteObjectArray(this.AsList()' stream' options);             break;           }         case CBORObjectTypeExtendedDecimal: {             var dec = (EDecimal)this.ThisItem;             Write(dec' stream);             break;           }         case CBORObjectTypeExtendedFloat: {             var flo = (EFloat)this.ThisItem;             Write(flo' stream);             break;           }         case CBORObjectTypeExtendedRational: {             var flo = (ERational)this.ThisItem;             Write(flo' stream);             break;           }         case CBORObjectTypeMap: {             WriteObjectMap(this.AsMap()' stream' options);             break;           }         case CBORObjectTypeSimpleValue: {             var value = (int)this.ThisItem;             if (value < 24) {               stream.WriteByte((byte)(0xe0 + value));             } else { #if DEBUG               if (value < 32) {                 throw new ArgumentException("value (" + value +                     ") is less than " + "32");               } #endif                stream.WriteByte(0xf8);               stream.WriteByte((byte)value);             }              break;           }         case CBORObjectTypeSingle: {             Write((float)this.ThisItem' stream);             break;           }         case CBORObjectTypeDouble: {             Write((double)this.ThisItem' stream);             break;           }         default: {             throw new ArgumentException("Unexpected data type");           }       }
Magic Number,PeterO.Cbor,CBORObject,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORObject.cs,WriteTo,The following statement contains a magic number: switch (type) {         case CBORObjectTypeInteger: {             Write((long)this.ThisItem' stream);             break;           }         case CBORObjectTypeBigInteger: {             Write((EInteger)this.ThisItem' stream);             break;           }         case CBORObjectTypeByteString: {             var arr = (byte[])this.ThisItem;             WritePositiveInt(               (this.ItemType == CBORObjectTypeByteString) ? 2 : 3'               arr.Length'               stream);             stream.Write(arr' 0' arr.Length);             break;           }         case CBORObjectTypeTextString: {             Write((string)this.ThisItem' stream' options);             break;           }         case CBORObjectTypeArray: {             WriteObjectArray(this.AsList()' stream' options);             break;           }         case CBORObjectTypeExtendedDecimal: {             var dec = (EDecimal)this.ThisItem;             Write(dec' stream);             break;           }         case CBORObjectTypeExtendedFloat: {             var flo = (EFloat)this.ThisItem;             Write(flo' stream);             break;           }         case CBORObjectTypeExtendedRational: {             var flo = (ERational)this.ThisItem;             Write(flo' stream);             break;           }         case CBORObjectTypeMap: {             WriteObjectMap(this.AsMap()' stream' options);             break;           }         case CBORObjectTypeSimpleValue: {             var value = (int)this.ThisItem;             if (value < 24) {               stream.WriteByte((byte)(0xe0 + value));             } else { #if DEBUG               if (value < 32) {                 throw new ArgumentException("value (" + value +                     ") is less than " + "32");               } #endif                stream.WriteByte(0xf8);               stream.WriteByte((byte)value);             }              break;           }         case CBORObjectTypeSingle: {             Write((float)this.ThisItem' stream);             break;           }         case CBORObjectTypeDouble: {             Write((double)this.ThisItem' stream);             break;           }         default: {             throw new ArgumentException("Unexpected data type");           }       }
Magic Number,PeterO.Cbor,CBORObject,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORObject.cs,WriteTo,The following statement contains a magic number: switch (type) {         case CBORObjectTypeInteger: {             Write((long)this.ThisItem' stream);             break;           }         case CBORObjectTypeBigInteger: {             Write((EInteger)this.ThisItem' stream);             break;           }         case CBORObjectTypeByteString: {             var arr = (byte[])this.ThisItem;             WritePositiveInt(               (this.ItemType == CBORObjectTypeByteString) ? 2 : 3'               arr.Length'               stream);             stream.Write(arr' 0' arr.Length);             break;           }         case CBORObjectTypeTextString: {             Write((string)this.ThisItem' stream' options);             break;           }         case CBORObjectTypeArray: {             WriteObjectArray(this.AsList()' stream' options);             break;           }         case CBORObjectTypeExtendedDecimal: {             var dec = (EDecimal)this.ThisItem;             Write(dec' stream);             break;           }         case CBORObjectTypeExtendedFloat: {             var flo = (EFloat)this.ThisItem;             Write(flo' stream);             break;           }         case CBORObjectTypeExtendedRational: {             var flo = (ERational)this.ThisItem;             Write(flo' stream);             break;           }         case CBORObjectTypeMap: {             WriteObjectMap(this.AsMap()' stream' options);             break;           }         case CBORObjectTypeSimpleValue: {             var value = (int)this.ThisItem;             if (value < 24) {               stream.WriteByte((byte)(0xe0 + value));             } else { #if DEBUG               if (value < 32) {                 throw new ArgumentException("value (" + value +                     ") is less than " + "32");               } #endif                stream.WriteByte(0xf8);               stream.WriteByte((byte)value);             }              break;           }         case CBORObjectTypeSingle: {             Write((float)this.ThisItem' stream);             break;           }         case CBORObjectTypeDouble: {             Write((double)this.ThisItem' stream);             break;           }         default: {             throw new ArgumentException("Unexpected data type");           }       }
Magic Number,PeterO.Cbor,CBORObject,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORObject.cs,WriteTo,The following statement contains a magic number: switch (type) {         case CBORObjectTypeInteger: {             Write((long)this.ThisItem' stream);             break;           }         case CBORObjectTypeBigInteger: {             Write((EInteger)this.ThisItem' stream);             break;           }         case CBORObjectTypeByteString: {             var arr = (byte[])this.ThisItem;             WritePositiveInt(               (this.ItemType == CBORObjectTypeByteString) ? 2 : 3'               arr.Length'               stream);             stream.Write(arr' 0' arr.Length);             break;           }         case CBORObjectTypeTextString: {             Write((string)this.ThisItem' stream' options);             break;           }         case CBORObjectTypeArray: {             WriteObjectArray(this.AsList()' stream' options);             break;           }         case CBORObjectTypeExtendedDecimal: {             var dec = (EDecimal)this.ThisItem;             Write(dec' stream);             break;           }         case CBORObjectTypeExtendedFloat: {             var flo = (EFloat)this.ThisItem;             Write(flo' stream);             break;           }         case CBORObjectTypeExtendedRational: {             var flo = (ERational)this.ThisItem;             Write(flo' stream);             break;           }         case CBORObjectTypeMap: {             WriteObjectMap(this.AsMap()' stream' options);             break;           }         case CBORObjectTypeSimpleValue: {             var value = (int)this.ThisItem;             if (value < 24) {               stream.WriteByte((byte)(0xe0 + value));             } else { #if DEBUG               if (value < 32) {                 throw new ArgumentException("value (" + value +                     ") is less than " + "32");               } #endif                stream.WriteByte(0xf8);               stream.WriteByte((byte)value);             }              break;           }         case CBORObjectTypeSingle: {             Write((float)this.ThisItem' stream);             break;           }         case CBORObjectTypeDouble: {             Write((double)this.ThisItem' stream);             break;           }         default: {             throw new ArgumentException("Unexpected data type");           }       }
Magic Number,PeterO.Cbor,CBORObject,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORObject.cs,FindTagConverter,The following statement contains a magic number: if (TagHandlersEmpty()) {         AddTagHandler((EInteger)2' new CBORTag2());         AddTagHandler((EInteger)3' new CBORTag3());         AddTagHandler((EInteger)4' new CBORTag4());         AddTagHandler((EInteger)5' new CBORTag5());         AddTagHandler((EInteger)264' new CBORTag4(true));         AddTagHandler((EInteger)265' new CBORTag5(true));         AddTagHandler((EInteger)25' new CBORTagUnsigned());         AddTagHandler((EInteger)29' new CBORTagUnsigned());         AddTagHandler((EInteger)256' new CBORTagAny());         AddTagHandler(EInteger.Zero' new CBORTag0());         AddTagHandler((EInteger)32' new CBORTag32());         AddTagHandler((EInteger)33' new CBORTagGenericString());         AddTagHandler((EInteger)34' new CBORTagGenericString());         AddTagHandler((EInteger)35' new CBORTagGenericString());         AddTagHandler((EInteger)36' new CBORTagGenericString());         AddTagHandler((EInteger)37' new CBORTag37());         AddTagHandler((EInteger)30' new CBORTag30());       }
Magic Number,PeterO.Cbor,CBORObject,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORObject.cs,FindTagConverter,The following statement contains a magic number: if (TagHandlersEmpty()) {         AddTagHandler((EInteger)2' new CBORTag2());         AddTagHandler((EInteger)3' new CBORTag3());         AddTagHandler((EInteger)4' new CBORTag4());         AddTagHandler((EInteger)5' new CBORTag5());         AddTagHandler((EInteger)264' new CBORTag4(true));         AddTagHandler((EInteger)265' new CBORTag5(true));         AddTagHandler((EInteger)25' new CBORTagUnsigned());         AddTagHandler((EInteger)29' new CBORTagUnsigned());         AddTagHandler((EInteger)256' new CBORTagAny());         AddTagHandler(EInteger.Zero' new CBORTag0());         AddTagHandler((EInteger)32' new CBORTag32());         AddTagHandler((EInteger)33' new CBORTagGenericString());         AddTagHandler((EInteger)34' new CBORTagGenericString());         AddTagHandler((EInteger)35' new CBORTagGenericString());         AddTagHandler((EInteger)36' new CBORTagGenericString());         AddTagHandler((EInteger)37' new CBORTag37());         AddTagHandler((EInteger)30' new CBORTag30());       }
Magic Number,PeterO.Cbor,CBORObject,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORObject.cs,FindTagConverter,The following statement contains a magic number: if (TagHandlersEmpty()) {         AddTagHandler((EInteger)2' new CBORTag2());         AddTagHandler((EInteger)3' new CBORTag3());         AddTagHandler((EInteger)4' new CBORTag4());         AddTagHandler((EInteger)5' new CBORTag5());         AddTagHandler((EInteger)264' new CBORTag4(true));         AddTagHandler((EInteger)265' new CBORTag5(true));         AddTagHandler((EInteger)25' new CBORTagUnsigned());         AddTagHandler((EInteger)29' new CBORTagUnsigned());         AddTagHandler((EInteger)256' new CBORTagAny());         AddTagHandler(EInteger.Zero' new CBORTag0());         AddTagHandler((EInteger)32' new CBORTag32());         AddTagHandler((EInteger)33' new CBORTagGenericString());         AddTagHandler((EInteger)34' new CBORTagGenericString());         AddTagHandler((EInteger)35' new CBORTagGenericString());         AddTagHandler((EInteger)36' new CBORTagGenericString());         AddTagHandler((EInteger)37' new CBORTag37());         AddTagHandler((EInteger)30' new CBORTag30());       }
Magic Number,PeterO.Cbor,CBORObject,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORObject.cs,FindTagConverter,The following statement contains a magic number: if (TagHandlersEmpty()) {         AddTagHandler((EInteger)2' new CBORTag2());         AddTagHandler((EInteger)3' new CBORTag3());         AddTagHandler((EInteger)4' new CBORTag4());         AddTagHandler((EInteger)5' new CBORTag5());         AddTagHandler((EInteger)264' new CBORTag4(true));         AddTagHandler((EInteger)265' new CBORTag5(true));         AddTagHandler((EInteger)25' new CBORTagUnsigned());         AddTagHandler((EInteger)29' new CBORTagUnsigned());         AddTagHandler((EInteger)256' new CBORTagAny());         AddTagHandler(EInteger.Zero' new CBORTag0());         AddTagHandler((EInteger)32' new CBORTag32());         AddTagHandler((EInteger)33' new CBORTagGenericString());         AddTagHandler((EInteger)34' new CBORTagGenericString());         AddTagHandler((EInteger)35' new CBORTagGenericString());         AddTagHandler((EInteger)36' new CBORTagGenericString());         AddTagHandler((EInteger)37' new CBORTag37());         AddTagHandler((EInteger)30' new CBORTag30());       }
Magic Number,PeterO.Cbor,CBORObject,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORObject.cs,FindTagConverter,The following statement contains a magic number: if (TagHandlersEmpty()) {         AddTagHandler((EInteger)2' new CBORTag2());         AddTagHandler((EInteger)3' new CBORTag3());         AddTagHandler((EInteger)4' new CBORTag4());         AddTagHandler((EInteger)5' new CBORTag5());         AddTagHandler((EInteger)264' new CBORTag4(true));         AddTagHandler((EInteger)265' new CBORTag5(true));         AddTagHandler((EInteger)25' new CBORTagUnsigned());         AddTagHandler((EInteger)29' new CBORTagUnsigned());         AddTagHandler((EInteger)256' new CBORTagAny());         AddTagHandler(EInteger.Zero' new CBORTag0());         AddTagHandler((EInteger)32' new CBORTag32());         AddTagHandler((EInteger)33' new CBORTagGenericString());         AddTagHandler((EInteger)34' new CBORTagGenericString());         AddTagHandler((EInteger)35' new CBORTagGenericString());         AddTagHandler((EInteger)36' new CBORTagGenericString());         AddTagHandler((EInteger)37' new CBORTag37());         AddTagHandler((EInteger)30' new CBORTag30());       }
Magic Number,PeterO.Cbor,CBORObject,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORObject.cs,FindTagConverter,The following statement contains a magic number: if (TagHandlersEmpty()) {         AddTagHandler((EInteger)2' new CBORTag2());         AddTagHandler((EInteger)3' new CBORTag3());         AddTagHandler((EInteger)4' new CBORTag4());         AddTagHandler((EInteger)5' new CBORTag5());         AddTagHandler((EInteger)264' new CBORTag4(true));         AddTagHandler((EInteger)265' new CBORTag5(true));         AddTagHandler((EInteger)25' new CBORTagUnsigned());         AddTagHandler((EInteger)29' new CBORTagUnsigned());         AddTagHandler((EInteger)256' new CBORTagAny());         AddTagHandler(EInteger.Zero' new CBORTag0());         AddTagHandler((EInteger)32' new CBORTag32());         AddTagHandler((EInteger)33' new CBORTagGenericString());         AddTagHandler((EInteger)34' new CBORTagGenericString());         AddTagHandler((EInteger)35' new CBORTagGenericString());         AddTagHandler((EInteger)36' new CBORTagGenericString());         AddTagHandler((EInteger)37' new CBORTag37());         AddTagHandler((EInteger)30' new CBORTag30());       }
Magic Number,PeterO.Cbor,CBORObject,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORObject.cs,FindTagConverter,The following statement contains a magic number: if (TagHandlersEmpty()) {         AddTagHandler((EInteger)2' new CBORTag2());         AddTagHandler((EInteger)3' new CBORTag3());         AddTagHandler((EInteger)4' new CBORTag4());         AddTagHandler((EInteger)5' new CBORTag5());         AddTagHandler((EInteger)264' new CBORTag4(true));         AddTagHandler((EInteger)265' new CBORTag5(true));         AddTagHandler((EInteger)25' new CBORTagUnsigned());         AddTagHandler((EInteger)29' new CBORTagUnsigned());         AddTagHandler((EInteger)256' new CBORTagAny());         AddTagHandler(EInteger.Zero' new CBORTag0());         AddTagHandler((EInteger)32' new CBORTag32());         AddTagHandler((EInteger)33' new CBORTagGenericString());         AddTagHandler((EInteger)34' new CBORTagGenericString());         AddTagHandler((EInteger)35' new CBORTagGenericString());         AddTagHandler((EInteger)36' new CBORTagGenericString());         AddTagHandler((EInteger)37' new CBORTag37());         AddTagHandler((EInteger)30' new CBORTag30());       }
Magic Number,PeterO.Cbor,CBORObject,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORObject.cs,FindTagConverter,The following statement contains a magic number: if (TagHandlersEmpty()) {         AddTagHandler((EInteger)2' new CBORTag2());         AddTagHandler((EInteger)3' new CBORTag3());         AddTagHandler((EInteger)4' new CBORTag4());         AddTagHandler((EInteger)5' new CBORTag5());         AddTagHandler((EInteger)264' new CBORTag4(true));         AddTagHandler((EInteger)265' new CBORTag5(true));         AddTagHandler((EInteger)25' new CBORTagUnsigned());         AddTagHandler((EInteger)29' new CBORTagUnsigned());         AddTagHandler((EInteger)256' new CBORTagAny());         AddTagHandler(EInteger.Zero' new CBORTag0());         AddTagHandler((EInteger)32' new CBORTag32());         AddTagHandler((EInteger)33' new CBORTagGenericString());         AddTagHandler((EInteger)34' new CBORTagGenericString());         AddTagHandler((EInteger)35' new CBORTagGenericString());         AddTagHandler((EInteger)36' new CBORTagGenericString());         AddTagHandler((EInteger)37' new CBORTag37());         AddTagHandler((EInteger)30' new CBORTag30());       }
Magic Number,PeterO.Cbor,CBORObject,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORObject.cs,FindTagConverter,The following statement contains a magic number: if (TagHandlersEmpty()) {         AddTagHandler((EInteger)2' new CBORTag2());         AddTagHandler((EInteger)3' new CBORTag3());         AddTagHandler((EInteger)4' new CBORTag4());         AddTagHandler((EInteger)5' new CBORTag5());         AddTagHandler((EInteger)264' new CBORTag4(true));         AddTagHandler((EInteger)265' new CBORTag5(true));         AddTagHandler((EInteger)25' new CBORTagUnsigned());         AddTagHandler((EInteger)29' new CBORTagUnsigned());         AddTagHandler((EInteger)256' new CBORTagAny());         AddTagHandler(EInteger.Zero' new CBORTag0());         AddTagHandler((EInteger)32' new CBORTag32());         AddTagHandler((EInteger)33' new CBORTagGenericString());         AddTagHandler((EInteger)34' new CBORTagGenericString());         AddTagHandler((EInteger)35' new CBORTagGenericString());         AddTagHandler((EInteger)36' new CBORTagGenericString());         AddTagHandler((EInteger)37' new CBORTag37());         AddTagHandler((EInteger)30' new CBORTag30());       }
Magic Number,PeterO.Cbor,CBORObject,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORObject.cs,FindTagConverter,The following statement contains a magic number: if (TagHandlersEmpty()) {         AddTagHandler((EInteger)2' new CBORTag2());         AddTagHandler((EInteger)3' new CBORTag3());         AddTagHandler((EInteger)4' new CBORTag4());         AddTagHandler((EInteger)5' new CBORTag5());         AddTagHandler((EInteger)264' new CBORTag4(true));         AddTagHandler((EInteger)265' new CBORTag5(true));         AddTagHandler((EInteger)25' new CBORTagUnsigned());         AddTagHandler((EInteger)29' new CBORTagUnsigned());         AddTagHandler((EInteger)256' new CBORTagAny());         AddTagHandler(EInteger.Zero' new CBORTag0());         AddTagHandler((EInteger)32' new CBORTag32());         AddTagHandler((EInteger)33' new CBORTagGenericString());         AddTagHandler((EInteger)34' new CBORTagGenericString());         AddTagHandler((EInteger)35' new CBORTagGenericString());         AddTagHandler((EInteger)36' new CBORTagGenericString());         AddTagHandler((EInteger)37' new CBORTag37());         AddTagHandler((EInteger)30' new CBORTag30());       }
Magic Number,PeterO.Cbor,CBORObject,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORObject.cs,FindTagConverter,The following statement contains a magic number: if (TagHandlersEmpty()) {         AddTagHandler((EInteger)2' new CBORTag2());         AddTagHandler((EInteger)3' new CBORTag3());         AddTagHandler((EInteger)4' new CBORTag4());         AddTagHandler((EInteger)5' new CBORTag5());         AddTagHandler((EInteger)264' new CBORTag4(true));         AddTagHandler((EInteger)265' new CBORTag5(true));         AddTagHandler((EInteger)25' new CBORTagUnsigned());         AddTagHandler((EInteger)29' new CBORTagUnsigned());         AddTagHandler((EInteger)256' new CBORTagAny());         AddTagHandler(EInteger.Zero' new CBORTag0());         AddTagHandler((EInteger)32' new CBORTag32());         AddTagHandler((EInteger)33' new CBORTagGenericString());         AddTagHandler((EInteger)34' new CBORTagGenericString());         AddTagHandler((EInteger)35' new CBORTagGenericString());         AddTagHandler((EInteger)36' new CBORTagGenericString());         AddTagHandler((EInteger)37' new CBORTag37());         AddTagHandler((EInteger)30' new CBORTag30());       }
Magic Number,PeterO.Cbor,CBORObject,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORObject.cs,FindTagConverter,The following statement contains a magic number: if (TagHandlersEmpty()) {         AddTagHandler((EInteger)2' new CBORTag2());         AddTagHandler((EInteger)3' new CBORTag3());         AddTagHandler((EInteger)4' new CBORTag4());         AddTagHandler((EInteger)5' new CBORTag5());         AddTagHandler((EInteger)264' new CBORTag4(true));         AddTagHandler((EInteger)265' new CBORTag5(true));         AddTagHandler((EInteger)25' new CBORTagUnsigned());         AddTagHandler((EInteger)29' new CBORTagUnsigned());         AddTagHandler((EInteger)256' new CBORTagAny());         AddTagHandler(EInteger.Zero' new CBORTag0());         AddTagHandler((EInteger)32' new CBORTag32());         AddTagHandler((EInteger)33' new CBORTagGenericString());         AddTagHandler((EInteger)34' new CBORTagGenericString());         AddTagHandler((EInteger)35' new CBORTagGenericString());         AddTagHandler((EInteger)36' new CBORTagGenericString());         AddTagHandler((EInteger)37' new CBORTag37());         AddTagHandler((EInteger)30' new CBORTag30());       }
Magic Number,PeterO.Cbor,CBORObject,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORObject.cs,FindTagConverter,The following statement contains a magic number: if (TagHandlersEmpty()) {         AddTagHandler((EInteger)2' new CBORTag2());         AddTagHandler((EInteger)3' new CBORTag3());         AddTagHandler((EInteger)4' new CBORTag4());         AddTagHandler((EInteger)5' new CBORTag5());         AddTagHandler((EInteger)264' new CBORTag4(true));         AddTagHandler((EInteger)265' new CBORTag5(true));         AddTagHandler((EInteger)25' new CBORTagUnsigned());         AddTagHandler((EInteger)29' new CBORTagUnsigned());         AddTagHandler((EInteger)256' new CBORTagAny());         AddTagHandler(EInteger.Zero' new CBORTag0());         AddTagHandler((EInteger)32' new CBORTag32());         AddTagHandler((EInteger)33' new CBORTagGenericString());         AddTagHandler((EInteger)34' new CBORTagGenericString());         AddTagHandler((EInteger)35' new CBORTagGenericString());         AddTagHandler((EInteger)36' new CBORTagGenericString());         AddTagHandler((EInteger)37' new CBORTag37());         AddTagHandler((EInteger)30' new CBORTag30());       }
Magic Number,PeterO.Cbor,CBORObject,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORObject.cs,FindTagConverter,The following statement contains a magic number: if (TagHandlersEmpty()) {         AddTagHandler((EInteger)2' new CBORTag2());         AddTagHandler((EInteger)3' new CBORTag3());         AddTagHandler((EInteger)4' new CBORTag4());         AddTagHandler((EInteger)5' new CBORTag5());         AddTagHandler((EInteger)264' new CBORTag4(true));         AddTagHandler((EInteger)265' new CBORTag5(true));         AddTagHandler((EInteger)25' new CBORTagUnsigned());         AddTagHandler((EInteger)29' new CBORTagUnsigned());         AddTagHandler((EInteger)256' new CBORTagAny());         AddTagHandler(EInteger.Zero' new CBORTag0());         AddTagHandler((EInteger)32' new CBORTag32());         AddTagHandler((EInteger)33' new CBORTagGenericString());         AddTagHandler((EInteger)34' new CBORTagGenericString());         AddTagHandler((EInteger)35' new CBORTagGenericString());         AddTagHandler((EInteger)36' new CBORTagGenericString());         AddTagHandler((EInteger)37' new CBORTag37());         AddTagHandler((EInteger)30' new CBORTag30());       }
Magic Number,PeterO.Cbor,CBORObject,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORObject.cs,FindTagConverter,The following statement contains a magic number: if (TagHandlersEmpty()) {         AddTagHandler((EInteger)2' new CBORTag2());         AddTagHandler((EInteger)3' new CBORTag3());         AddTagHandler((EInteger)4' new CBORTag4());         AddTagHandler((EInteger)5' new CBORTag5());         AddTagHandler((EInteger)264' new CBORTag4(true));         AddTagHandler((EInteger)265' new CBORTag5(true));         AddTagHandler((EInteger)25' new CBORTagUnsigned());         AddTagHandler((EInteger)29' new CBORTagUnsigned());         AddTagHandler((EInteger)256' new CBORTagAny());         AddTagHandler(EInteger.Zero' new CBORTag0());         AddTagHandler((EInteger)32' new CBORTag32());         AddTagHandler((EInteger)33' new CBORTagGenericString());         AddTagHandler((EInteger)34' new CBORTagGenericString());         AddTagHandler((EInteger)35' new CBORTagGenericString());         AddTagHandler((EInteger)36' new CBORTagGenericString());         AddTagHandler((EInteger)37' new CBORTag37());         AddTagHandler((EInteger)30' new CBORTag30());       }
Magic Number,PeterO.Cbor,CBORObject,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORObject.cs,FindTagConverter,The following statement contains a magic number: if (TagHandlersEmpty()) {         AddTagHandler((EInteger)2' new CBORTag2());         AddTagHandler((EInteger)3' new CBORTag3());         AddTagHandler((EInteger)4' new CBORTag4());         AddTagHandler((EInteger)5' new CBORTag5());         AddTagHandler((EInteger)264' new CBORTag4(true));         AddTagHandler((EInteger)265' new CBORTag5(true));         AddTagHandler((EInteger)25' new CBORTagUnsigned());         AddTagHandler((EInteger)29' new CBORTagUnsigned());         AddTagHandler((EInteger)256' new CBORTagAny());         AddTagHandler(EInteger.Zero' new CBORTag0());         AddTagHandler((EInteger)32' new CBORTag32());         AddTagHandler((EInteger)33' new CBORTagGenericString());         AddTagHandler((EInteger)34' new CBORTagGenericString());         AddTagHandler((EInteger)35' new CBORTagGenericString());         AddTagHandler((EInteger)36' new CBORTagGenericString());         AddTagHandler((EInteger)37' new CBORTag37());         AddTagHandler((EInteger)30' new CBORTag30());       }
Magic Number,PeterO.Cbor,CBORObject,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORObject.cs,FindTagConverter,The following statement contains a magic number: lock (ValueTagHandlers) {         if (ValueTagHandlers.ContainsKey(bigintTag)) {           return ValueTagHandlers[bigintTag];         } #if DEBUG         if (bigintTag.Equals((EInteger)2)) {           throw new InvalidOperationException("Expected valid tag handler");         } #endif         return null;       }
Magic Number,PeterO.Cbor,CBORObject,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORObject.cs,GetFixedLengthObject,The following statement contains a magic number: int majortype = firstbyte >> 5;
Magic Number,PeterO.Cbor,CBORObject,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORObject.cs,GetFixedLengthObject,The following statement contains a magic number: if ((firstbyte & 0x1c) == 0x18) {         // contains 1 to 8 extra bytes of additional information         long uadditional = 0;         switch (firstbyte & 0x1f) {           case 24:             uadditional = (int)(data[1] & (int)0xff);             break;           case 25:             uadditional = ((long)(data[1] & (long)0xff)) << 8;             uadditional |= (long)(data[2] & (long)0xff);             break;           case 26:             uadditional = ((long)(data[1] & (long)0xff)) << 24;             uadditional |= ((long)(data[2] & (long)0xff)) << 16;             uadditional |= ((long)(data[3] & (long)0xff)) << 8;             uadditional |= (long)(data[4] & (long)0xff);             break;           case 27:             uadditional = ((long)(data[1] & (long)0xff)) << 56;             uadditional |= ((long)(data[2] & (long)0xff)) << 48;             uadditional |= ((long)(data[3] & (long)0xff)) << 40;             uadditional |= ((long)(data[4] & (long)0xff)) << 32;             uadditional |= ((long)(data[5] & (long)0xff)) << 24;             uadditional |= ((long)(data[6] & (long)0xff)) << 16;             uadditional |= ((long)(data[7] & (long)0xff)) << 8;             uadditional |= (long)(data[8] & (long)0xff);             break;           default:             throw new CBORException("Unexpected data encountered");         }         switch (majortype) {           case 0:             if ((uadditional >> 63) == 0) {               // use only if additional's top bit isn't set               // (additional is a signed long)               return new CBORObject(CBORObjectTypeInteger' uadditional);             } else {               int low = unchecked((int)((uadditional) & 0xffffffffL));               int high = unchecked((int)((uadditional >> 32) & 0xffffffffL));               return FromObject(LowHighToEInteger(low' high));             }           case 1:             if ((uadditional >> 63) == 0) {               // use only if additional's top bit isn't set               // (additional is a signed long)               return new CBORObject(CBORObjectTypeInteger' -1 - uadditional);             } else {               int low = unchecked((int)((uadditional) & 0xffffffffL));               int high = unchecked((int)((uadditional >> 32) & 0xffffffffL));               EInteger bigintAdditional = LowHighToEInteger(low' high);               EInteger minusOne = -EInteger.One;               bigintAdditional = minusOne - (EInteger)bigintAdditional;               return FromObject(bigintAdditional);             }           case 7:             if (firstbyte == 0xf9) {               return new CBORObject(                 CBORObjectTypeSingle'              CBORUtilities.HalfPrecisionToSingle(unchecked((int)uadditional)));             }             if (firstbyte == 0xfa) {               float flt = BitConverter.ToSingle(                 BitConverter.GetBytes((int)unchecked((int)uadditional))'                 0);               return new CBORObject(                 CBORObjectTypeSingle'                 flt);             }             if (firstbyte == 0xfb) {               double flt = BitConverter.ToDouble(                 BitConverter.GetBytes((long)uadditional)'                 0);               return new CBORObject(                 CBORObjectTypeDouble'                 flt);             }             if (firstbyte == 0xf8) {               if ((int)uadditional < 32) {                 throw new CBORException("Invalid overlong simple value");               }               return new CBORObject(                 CBORObjectTypeSimpleValue'                 (int)uadditional);             }             throw new CBORException("Unexpected data encountered");           default: throw new CBORException("Unexpected data encountered");         }       }
Magic Number,PeterO.Cbor,CBORObject,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORObject.cs,GetFixedLengthObject,The following statement contains a magic number: if ((firstbyte & 0x1c) == 0x18) {         // contains 1 to 8 extra bytes of additional information         long uadditional = 0;         switch (firstbyte & 0x1f) {           case 24:             uadditional = (int)(data[1] & (int)0xff);             break;           case 25:             uadditional = ((long)(data[1] & (long)0xff)) << 8;             uadditional |= (long)(data[2] & (long)0xff);             break;           case 26:             uadditional = ((long)(data[1] & (long)0xff)) << 24;             uadditional |= ((long)(data[2] & (long)0xff)) << 16;             uadditional |= ((long)(data[3] & (long)0xff)) << 8;             uadditional |= (long)(data[4] & (long)0xff);             break;           case 27:             uadditional = ((long)(data[1] & (long)0xff)) << 56;             uadditional |= ((long)(data[2] & (long)0xff)) << 48;             uadditional |= ((long)(data[3] & (long)0xff)) << 40;             uadditional |= ((long)(data[4] & (long)0xff)) << 32;             uadditional |= ((long)(data[5] & (long)0xff)) << 24;             uadditional |= ((long)(data[6] & (long)0xff)) << 16;             uadditional |= ((long)(data[7] & (long)0xff)) << 8;             uadditional |= (long)(data[8] & (long)0xff);             break;           default:             throw new CBORException("Unexpected data encountered");         }         switch (majortype) {           case 0:             if ((uadditional >> 63) == 0) {               // use only if additional's top bit isn't set               // (additional is a signed long)               return new CBORObject(CBORObjectTypeInteger' uadditional);             } else {               int low = unchecked((int)((uadditional) & 0xffffffffL));               int high = unchecked((int)((uadditional >> 32) & 0xffffffffL));               return FromObject(LowHighToEInteger(low' high));             }           case 1:             if ((uadditional >> 63) == 0) {               // use only if additional's top bit isn't set               // (additional is a signed long)               return new CBORObject(CBORObjectTypeInteger' -1 - uadditional);             } else {               int low = unchecked((int)((uadditional) & 0xffffffffL));               int high = unchecked((int)((uadditional >> 32) & 0xffffffffL));               EInteger bigintAdditional = LowHighToEInteger(low' high);               EInteger minusOne = -EInteger.One;               bigintAdditional = minusOne - (EInteger)bigintAdditional;               return FromObject(bigintAdditional);             }           case 7:             if (firstbyte == 0xf9) {               return new CBORObject(                 CBORObjectTypeSingle'              CBORUtilities.HalfPrecisionToSingle(unchecked((int)uadditional)));             }             if (firstbyte == 0xfa) {               float flt = BitConverter.ToSingle(                 BitConverter.GetBytes((int)unchecked((int)uadditional))'                 0);               return new CBORObject(                 CBORObjectTypeSingle'                 flt);             }             if (firstbyte == 0xfb) {               double flt = BitConverter.ToDouble(                 BitConverter.GetBytes((long)uadditional)'                 0);               return new CBORObject(                 CBORObjectTypeDouble'                 flt);             }             if (firstbyte == 0xf8) {               if ((int)uadditional < 32) {                 throw new CBORException("Invalid overlong simple value");               }               return new CBORObject(                 CBORObjectTypeSimpleValue'                 (int)uadditional);             }             throw new CBORException("Unexpected data encountered");           default: throw new CBORException("Unexpected data encountered");         }       }
Magic Number,PeterO.Cbor,CBORObject,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORObject.cs,GetFixedLengthObject,The following statement contains a magic number: if ((firstbyte & 0x1c) == 0x18) {         // contains 1 to 8 extra bytes of additional information         long uadditional = 0;         switch (firstbyte & 0x1f) {           case 24:             uadditional = (int)(data[1] & (int)0xff);             break;           case 25:             uadditional = ((long)(data[1] & (long)0xff)) << 8;             uadditional |= (long)(data[2] & (long)0xff);             break;           case 26:             uadditional = ((long)(data[1] & (long)0xff)) << 24;             uadditional |= ((long)(data[2] & (long)0xff)) << 16;             uadditional |= ((long)(data[3] & (long)0xff)) << 8;             uadditional |= (long)(data[4] & (long)0xff);             break;           case 27:             uadditional = ((long)(data[1] & (long)0xff)) << 56;             uadditional |= ((long)(data[2] & (long)0xff)) << 48;             uadditional |= ((long)(data[3] & (long)0xff)) << 40;             uadditional |= ((long)(data[4] & (long)0xff)) << 32;             uadditional |= ((long)(data[5] & (long)0xff)) << 24;             uadditional |= ((long)(data[6] & (long)0xff)) << 16;             uadditional |= ((long)(data[7] & (long)0xff)) << 8;             uadditional |= (long)(data[8] & (long)0xff);             break;           default:             throw new CBORException("Unexpected data encountered");         }         switch (majortype) {           case 0:             if ((uadditional >> 63) == 0) {               // use only if additional's top bit isn't set               // (additional is a signed long)               return new CBORObject(CBORObjectTypeInteger' uadditional);             } else {               int low = unchecked((int)((uadditional) & 0xffffffffL));               int high = unchecked((int)((uadditional >> 32) & 0xffffffffL));               return FromObject(LowHighToEInteger(low' high));             }           case 1:             if ((uadditional >> 63) == 0) {               // use only if additional's top bit isn't set               // (additional is a signed long)               return new CBORObject(CBORObjectTypeInteger' -1 - uadditional);             } else {               int low = unchecked((int)((uadditional) & 0xffffffffL));               int high = unchecked((int)((uadditional >> 32) & 0xffffffffL));               EInteger bigintAdditional = LowHighToEInteger(low' high);               EInteger minusOne = -EInteger.One;               bigintAdditional = minusOne - (EInteger)bigintAdditional;               return FromObject(bigintAdditional);             }           case 7:             if (firstbyte == 0xf9) {               return new CBORObject(                 CBORObjectTypeSingle'              CBORUtilities.HalfPrecisionToSingle(unchecked((int)uadditional)));             }             if (firstbyte == 0xfa) {               float flt = BitConverter.ToSingle(                 BitConverter.GetBytes((int)unchecked((int)uadditional))'                 0);               return new CBORObject(                 CBORObjectTypeSingle'                 flt);             }             if (firstbyte == 0xfb) {               double flt = BitConverter.ToDouble(                 BitConverter.GetBytes((long)uadditional)'                 0);               return new CBORObject(                 CBORObjectTypeDouble'                 flt);             }             if (firstbyte == 0xf8) {               if ((int)uadditional < 32) {                 throw new CBORException("Invalid overlong simple value");               }               return new CBORObject(                 CBORObjectTypeSimpleValue'                 (int)uadditional);             }             throw new CBORException("Unexpected data encountered");           default: throw new CBORException("Unexpected data encountered");         }       }
Magic Number,PeterO.Cbor,CBORObject,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORObject.cs,GetFixedLengthObject,The following statement contains a magic number: if ((firstbyte & 0x1c) == 0x18) {         // contains 1 to 8 extra bytes of additional information         long uadditional = 0;         switch (firstbyte & 0x1f) {           case 24:             uadditional = (int)(data[1] & (int)0xff);             break;           case 25:             uadditional = ((long)(data[1] & (long)0xff)) << 8;             uadditional |= (long)(data[2] & (long)0xff);             break;           case 26:             uadditional = ((long)(data[1] & (long)0xff)) << 24;             uadditional |= ((long)(data[2] & (long)0xff)) << 16;             uadditional |= ((long)(data[3] & (long)0xff)) << 8;             uadditional |= (long)(data[4] & (long)0xff);             break;           case 27:             uadditional = ((long)(data[1] & (long)0xff)) << 56;             uadditional |= ((long)(data[2] & (long)0xff)) << 48;             uadditional |= ((long)(data[3] & (long)0xff)) << 40;             uadditional |= ((long)(data[4] & (long)0xff)) << 32;             uadditional |= ((long)(data[5] & (long)0xff)) << 24;             uadditional |= ((long)(data[6] & (long)0xff)) << 16;             uadditional |= ((long)(data[7] & (long)0xff)) << 8;             uadditional |= (long)(data[8] & (long)0xff);             break;           default:             throw new CBORException("Unexpected data encountered");         }         switch (majortype) {           case 0:             if ((uadditional >> 63) == 0) {               // use only if additional's top bit isn't set               // (additional is a signed long)               return new CBORObject(CBORObjectTypeInteger' uadditional);             } else {               int low = unchecked((int)((uadditional) & 0xffffffffL));               int high = unchecked((int)((uadditional >> 32) & 0xffffffffL));               return FromObject(LowHighToEInteger(low' high));             }           case 1:             if ((uadditional >> 63) == 0) {               // use only if additional's top bit isn't set               // (additional is a signed long)               return new CBORObject(CBORObjectTypeInteger' -1 - uadditional);             } else {               int low = unchecked((int)((uadditional) & 0xffffffffL));               int high = unchecked((int)((uadditional >> 32) & 0xffffffffL));               EInteger bigintAdditional = LowHighToEInteger(low' high);               EInteger minusOne = -EInteger.One;               bigintAdditional = minusOne - (EInteger)bigintAdditional;               return FromObject(bigintAdditional);             }           case 7:             if (firstbyte == 0xf9) {               return new CBORObject(                 CBORObjectTypeSingle'              CBORUtilities.HalfPrecisionToSingle(unchecked((int)uadditional)));             }             if (firstbyte == 0xfa) {               float flt = BitConverter.ToSingle(                 BitConverter.GetBytes((int)unchecked((int)uadditional))'                 0);               return new CBORObject(                 CBORObjectTypeSingle'                 flt);             }             if (firstbyte == 0xfb) {               double flt = BitConverter.ToDouble(                 BitConverter.GetBytes((long)uadditional)'                 0);               return new CBORObject(                 CBORObjectTypeDouble'                 flt);             }             if (firstbyte == 0xf8) {               if ((int)uadditional < 32) {                 throw new CBORException("Invalid overlong simple value");               }               return new CBORObject(                 CBORObjectTypeSimpleValue'                 (int)uadditional);             }             throw new CBORException("Unexpected data encountered");           default: throw new CBORException("Unexpected data encountered");         }       }
Magic Number,PeterO.Cbor,CBORObject,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORObject.cs,GetFixedLengthObject,The following statement contains a magic number: if ((firstbyte & 0x1c) == 0x18) {         // contains 1 to 8 extra bytes of additional information         long uadditional = 0;         switch (firstbyte & 0x1f) {           case 24:             uadditional = (int)(data[1] & (int)0xff);             break;           case 25:             uadditional = ((long)(data[1] & (long)0xff)) << 8;             uadditional |= (long)(data[2] & (long)0xff);             break;           case 26:             uadditional = ((long)(data[1] & (long)0xff)) << 24;             uadditional |= ((long)(data[2] & (long)0xff)) << 16;             uadditional |= ((long)(data[3] & (long)0xff)) << 8;             uadditional |= (long)(data[4] & (long)0xff);             break;           case 27:             uadditional = ((long)(data[1] & (long)0xff)) << 56;             uadditional |= ((long)(data[2] & (long)0xff)) << 48;             uadditional |= ((long)(data[3] & (long)0xff)) << 40;             uadditional |= ((long)(data[4] & (long)0xff)) << 32;             uadditional |= ((long)(data[5] & (long)0xff)) << 24;             uadditional |= ((long)(data[6] & (long)0xff)) << 16;             uadditional |= ((long)(data[7] & (long)0xff)) << 8;             uadditional |= (long)(data[8] & (long)0xff);             break;           default:             throw new CBORException("Unexpected data encountered");         }         switch (majortype) {           case 0:             if ((uadditional >> 63) == 0) {               // use only if additional's top bit isn't set               // (additional is a signed long)               return new CBORObject(CBORObjectTypeInteger' uadditional);             } else {               int low = unchecked((int)((uadditional) & 0xffffffffL));               int high = unchecked((int)((uadditional >> 32) & 0xffffffffL));               return FromObject(LowHighToEInteger(low' high));             }           case 1:             if ((uadditional >> 63) == 0) {               // use only if additional's top bit isn't set               // (additional is a signed long)               return new CBORObject(CBORObjectTypeInteger' -1 - uadditional);             } else {               int low = unchecked((int)((uadditional) & 0xffffffffL));               int high = unchecked((int)((uadditional >> 32) & 0xffffffffL));               EInteger bigintAdditional = LowHighToEInteger(low' high);               EInteger minusOne = -EInteger.One;               bigintAdditional = minusOne - (EInteger)bigintAdditional;               return FromObject(bigintAdditional);             }           case 7:             if (firstbyte == 0xf9) {               return new CBORObject(                 CBORObjectTypeSingle'              CBORUtilities.HalfPrecisionToSingle(unchecked((int)uadditional)));             }             if (firstbyte == 0xfa) {               float flt = BitConverter.ToSingle(                 BitConverter.GetBytes((int)unchecked((int)uadditional))'                 0);               return new CBORObject(                 CBORObjectTypeSingle'                 flt);             }             if (firstbyte == 0xfb) {               double flt = BitConverter.ToDouble(                 BitConverter.GetBytes((long)uadditional)'                 0);               return new CBORObject(                 CBORObjectTypeDouble'                 flt);             }             if (firstbyte == 0xf8) {               if ((int)uadditional < 32) {                 throw new CBORException("Invalid overlong simple value");               }               return new CBORObject(                 CBORObjectTypeSimpleValue'                 (int)uadditional);             }             throw new CBORException("Unexpected data encountered");           default: throw new CBORException("Unexpected data encountered");         }       }
Magic Number,PeterO.Cbor,CBORObject,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORObject.cs,GetFixedLengthObject,The following statement contains a magic number: if ((firstbyte & 0x1c) == 0x18) {         // contains 1 to 8 extra bytes of additional information         long uadditional = 0;         switch (firstbyte & 0x1f) {           case 24:             uadditional = (int)(data[1] & (int)0xff);             break;           case 25:             uadditional = ((long)(data[1] & (long)0xff)) << 8;             uadditional |= (long)(data[2] & (long)0xff);             break;           case 26:             uadditional = ((long)(data[1] & (long)0xff)) << 24;             uadditional |= ((long)(data[2] & (long)0xff)) << 16;             uadditional |= ((long)(data[3] & (long)0xff)) << 8;             uadditional |= (long)(data[4] & (long)0xff);             break;           case 27:             uadditional = ((long)(data[1] & (long)0xff)) << 56;             uadditional |= ((long)(data[2] & (long)0xff)) << 48;             uadditional |= ((long)(data[3] & (long)0xff)) << 40;             uadditional |= ((long)(data[4] & (long)0xff)) << 32;             uadditional |= ((long)(data[5] & (long)0xff)) << 24;             uadditional |= ((long)(data[6] & (long)0xff)) << 16;             uadditional |= ((long)(data[7] & (long)0xff)) << 8;             uadditional |= (long)(data[8] & (long)0xff);             break;           default:             throw new CBORException("Unexpected data encountered");         }         switch (majortype) {           case 0:             if ((uadditional >> 63) == 0) {               // use only if additional's top bit isn't set               // (additional is a signed long)               return new CBORObject(CBORObjectTypeInteger' uadditional);             } else {               int low = unchecked((int)((uadditional) & 0xffffffffL));               int high = unchecked((int)((uadditional >> 32) & 0xffffffffL));               return FromObject(LowHighToEInteger(low' high));             }           case 1:             if ((uadditional >> 63) == 0) {               // use only if additional's top bit isn't set               // (additional is a signed long)               return new CBORObject(CBORObjectTypeInteger' -1 - uadditional);             } else {               int low = unchecked((int)((uadditional) & 0xffffffffL));               int high = unchecked((int)((uadditional >> 32) & 0xffffffffL));               EInteger bigintAdditional = LowHighToEInteger(low' high);               EInteger minusOne = -EInteger.One;               bigintAdditional = minusOne - (EInteger)bigintAdditional;               return FromObject(bigintAdditional);             }           case 7:             if (firstbyte == 0xf9) {               return new CBORObject(                 CBORObjectTypeSingle'              CBORUtilities.HalfPrecisionToSingle(unchecked((int)uadditional)));             }             if (firstbyte == 0xfa) {               float flt = BitConverter.ToSingle(                 BitConverter.GetBytes((int)unchecked((int)uadditional))'                 0);               return new CBORObject(                 CBORObjectTypeSingle'                 flt);             }             if (firstbyte == 0xfb) {               double flt = BitConverter.ToDouble(                 BitConverter.GetBytes((long)uadditional)'                 0);               return new CBORObject(                 CBORObjectTypeDouble'                 flt);             }             if (firstbyte == 0xf8) {               if ((int)uadditional < 32) {                 throw new CBORException("Invalid overlong simple value");               }               return new CBORObject(                 CBORObjectTypeSimpleValue'                 (int)uadditional);             }             throw new CBORException("Unexpected data encountered");           default: throw new CBORException("Unexpected data encountered");         }       }
Magic Number,PeterO.Cbor,CBORObject,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORObject.cs,GetFixedLengthObject,The following statement contains a magic number: if ((firstbyte & 0x1c) == 0x18) {         // contains 1 to 8 extra bytes of additional information         long uadditional = 0;         switch (firstbyte & 0x1f) {           case 24:             uadditional = (int)(data[1] & (int)0xff);             break;           case 25:             uadditional = ((long)(data[1] & (long)0xff)) << 8;             uadditional |= (long)(data[2] & (long)0xff);             break;           case 26:             uadditional = ((long)(data[1] & (long)0xff)) << 24;             uadditional |= ((long)(data[2] & (long)0xff)) << 16;             uadditional |= ((long)(data[3] & (long)0xff)) << 8;             uadditional |= (long)(data[4] & (long)0xff);             break;           case 27:             uadditional = ((long)(data[1] & (long)0xff)) << 56;             uadditional |= ((long)(data[2] & (long)0xff)) << 48;             uadditional |= ((long)(data[3] & (long)0xff)) << 40;             uadditional |= ((long)(data[4] & (long)0xff)) << 32;             uadditional |= ((long)(data[5] & (long)0xff)) << 24;             uadditional |= ((long)(data[6] & (long)0xff)) << 16;             uadditional |= ((long)(data[7] & (long)0xff)) << 8;             uadditional |= (long)(data[8] & (long)0xff);             break;           default:             throw new CBORException("Unexpected data encountered");         }         switch (majortype) {           case 0:             if ((uadditional >> 63) == 0) {               // use only if additional's top bit isn't set               // (additional is a signed long)               return new CBORObject(CBORObjectTypeInteger' uadditional);             } else {               int low = unchecked((int)((uadditional) & 0xffffffffL));               int high = unchecked((int)((uadditional >> 32) & 0xffffffffL));               return FromObject(LowHighToEInteger(low' high));             }           case 1:             if ((uadditional >> 63) == 0) {               // use only if additional's top bit isn't set               // (additional is a signed long)               return new CBORObject(CBORObjectTypeInteger' -1 - uadditional);             } else {               int low = unchecked((int)((uadditional) & 0xffffffffL));               int high = unchecked((int)((uadditional >> 32) & 0xffffffffL));               EInteger bigintAdditional = LowHighToEInteger(low' high);               EInteger minusOne = -EInteger.One;               bigintAdditional = minusOne - (EInteger)bigintAdditional;               return FromObject(bigintAdditional);             }           case 7:             if (firstbyte == 0xf9) {               return new CBORObject(                 CBORObjectTypeSingle'              CBORUtilities.HalfPrecisionToSingle(unchecked((int)uadditional)));             }             if (firstbyte == 0xfa) {               float flt = BitConverter.ToSingle(                 BitConverter.GetBytes((int)unchecked((int)uadditional))'                 0);               return new CBORObject(                 CBORObjectTypeSingle'                 flt);             }             if (firstbyte == 0xfb) {               double flt = BitConverter.ToDouble(                 BitConverter.GetBytes((long)uadditional)'                 0);               return new CBORObject(                 CBORObjectTypeDouble'                 flt);             }             if (firstbyte == 0xf8) {               if ((int)uadditional < 32) {                 throw new CBORException("Invalid overlong simple value");               }               return new CBORObject(                 CBORObjectTypeSimpleValue'                 (int)uadditional);             }             throw new CBORException("Unexpected data encountered");           default: throw new CBORException("Unexpected data encountered");         }       }
Magic Number,PeterO.Cbor,CBORObject,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORObject.cs,GetFixedLengthObject,The following statement contains a magic number: if ((firstbyte & 0x1c) == 0x18) {         // contains 1 to 8 extra bytes of additional information         long uadditional = 0;         switch (firstbyte & 0x1f) {           case 24:             uadditional = (int)(data[1] & (int)0xff);             break;           case 25:             uadditional = ((long)(data[1] & (long)0xff)) << 8;             uadditional |= (long)(data[2] & (long)0xff);             break;           case 26:             uadditional = ((long)(data[1] & (long)0xff)) << 24;             uadditional |= ((long)(data[2] & (long)0xff)) << 16;             uadditional |= ((long)(data[3] & (long)0xff)) << 8;             uadditional |= (long)(data[4] & (long)0xff);             break;           case 27:             uadditional = ((long)(data[1] & (long)0xff)) << 56;             uadditional |= ((long)(data[2] & (long)0xff)) << 48;             uadditional |= ((long)(data[3] & (long)0xff)) << 40;             uadditional |= ((long)(data[4] & (long)0xff)) << 32;             uadditional |= ((long)(data[5] & (long)0xff)) << 24;             uadditional |= ((long)(data[6] & (long)0xff)) << 16;             uadditional |= ((long)(data[7] & (long)0xff)) << 8;             uadditional |= (long)(data[8] & (long)0xff);             break;           default:             throw new CBORException("Unexpected data encountered");         }         switch (majortype) {           case 0:             if ((uadditional >> 63) == 0) {               // use only if additional's top bit isn't set               // (additional is a signed long)               return new CBORObject(CBORObjectTypeInteger' uadditional);             } else {               int low = unchecked((int)((uadditional) & 0xffffffffL));               int high = unchecked((int)((uadditional >> 32) & 0xffffffffL));               return FromObject(LowHighToEInteger(low' high));             }           case 1:             if ((uadditional >> 63) == 0) {               // use only if additional's top bit isn't set               // (additional is a signed long)               return new CBORObject(CBORObjectTypeInteger' -1 - uadditional);             } else {               int low = unchecked((int)((uadditional) & 0xffffffffL));               int high = unchecked((int)((uadditional >> 32) & 0xffffffffL));               EInteger bigintAdditional = LowHighToEInteger(low' high);               EInteger minusOne = -EInteger.One;               bigintAdditional = minusOne - (EInteger)bigintAdditional;               return FromObject(bigintAdditional);             }           case 7:             if (firstbyte == 0xf9) {               return new CBORObject(                 CBORObjectTypeSingle'              CBORUtilities.HalfPrecisionToSingle(unchecked((int)uadditional)));             }             if (firstbyte == 0xfa) {               float flt = BitConverter.ToSingle(                 BitConverter.GetBytes((int)unchecked((int)uadditional))'                 0);               return new CBORObject(                 CBORObjectTypeSingle'                 flt);             }             if (firstbyte == 0xfb) {               double flt = BitConverter.ToDouble(                 BitConverter.GetBytes((long)uadditional)'                 0);               return new CBORObject(                 CBORObjectTypeDouble'                 flt);             }             if (firstbyte == 0xf8) {               if ((int)uadditional < 32) {                 throw new CBORException("Invalid overlong simple value");               }               return new CBORObject(                 CBORObjectTypeSimpleValue'                 (int)uadditional);             }             throw new CBORException("Unexpected data encountered");           default: throw new CBORException("Unexpected data encountered");         }       }
Magic Number,PeterO.Cbor,CBORObject,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORObject.cs,GetFixedLengthObject,The following statement contains a magic number: if ((firstbyte & 0x1c) == 0x18) {         // contains 1 to 8 extra bytes of additional information         long uadditional = 0;         switch (firstbyte & 0x1f) {           case 24:             uadditional = (int)(data[1] & (int)0xff);             break;           case 25:             uadditional = ((long)(data[1] & (long)0xff)) << 8;             uadditional |= (long)(data[2] & (long)0xff);             break;           case 26:             uadditional = ((long)(data[1] & (long)0xff)) << 24;             uadditional |= ((long)(data[2] & (long)0xff)) << 16;             uadditional |= ((long)(data[3] & (long)0xff)) << 8;             uadditional |= (long)(data[4] & (long)0xff);             break;           case 27:             uadditional = ((long)(data[1] & (long)0xff)) << 56;             uadditional |= ((long)(data[2] & (long)0xff)) << 48;             uadditional |= ((long)(data[3] & (long)0xff)) << 40;             uadditional |= ((long)(data[4] & (long)0xff)) << 32;             uadditional |= ((long)(data[5] & (long)0xff)) << 24;             uadditional |= ((long)(data[6] & (long)0xff)) << 16;             uadditional |= ((long)(data[7] & (long)0xff)) << 8;             uadditional |= (long)(data[8] & (long)0xff);             break;           default:             throw new CBORException("Unexpected data encountered");         }         switch (majortype) {           case 0:             if ((uadditional >> 63) == 0) {               // use only if additional's top bit isn't set               // (additional is a signed long)               return new CBORObject(CBORObjectTypeInteger' uadditional);             } else {               int low = unchecked((int)((uadditional) & 0xffffffffL));               int high = unchecked((int)((uadditional >> 32) & 0xffffffffL));               return FromObject(LowHighToEInteger(low' high));             }           case 1:             if ((uadditional >> 63) == 0) {               // use only if additional's top bit isn't set               // (additional is a signed long)               return new CBORObject(CBORObjectTypeInteger' -1 - uadditional);             } else {               int low = unchecked((int)((uadditional) & 0xffffffffL));               int high = unchecked((int)((uadditional >> 32) & 0xffffffffL));               EInteger bigintAdditional = LowHighToEInteger(low' high);               EInteger minusOne = -EInteger.One;               bigintAdditional = minusOne - (EInteger)bigintAdditional;               return FromObject(bigintAdditional);             }           case 7:             if (firstbyte == 0xf9) {               return new CBORObject(                 CBORObjectTypeSingle'              CBORUtilities.HalfPrecisionToSingle(unchecked((int)uadditional)));             }             if (firstbyte == 0xfa) {               float flt = BitConverter.ToSingle(                 BitConverter.GetBytes((int)unchecked((int)uadditional))'                 0);               return new CBORObject(                 CBORObjectTypeSingle'                 flt);             }             if (firstbyte == 0xfb) {               double flt = BitConverter.ToDouble(                 BitConverter.GetBytes((long)uadditional)'                 0);               return new CBORObject(                 CBORObjectTypeDouble'                 flt);             }             if (firstbyte == 0xf8) {               if ((int)uadditional < 32) {                 throw new CBORException("Invalid overlong simple value");               }               return new CBORObject(                 CBORObjectTypeSimpleValue'                 (int)uadditional);             }             throw new CBORException("Unexpected data encountered");           default: throw new CBORException("Unexpected data encountered");         }       }
Magic Number,PeterO.Cbor,CBORObject,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORObject.cs,GetFixedLengthObject,The following statement contains a magic number: if ((firstbyte & 0x1c) == 0x18) {         // contains 1 to 8 extra bytes of additional information         long uadditional = 0;         switch (firstbyte & 0x1f) {           case 24:             uadditional = (int)(data[1] & (int)0xff);             break;           case 25:             uadditional = ((long)(data[1] & (long)0xff)) << 8;             uadditional |= (long)(data[2] & (long)0xff);             break;           case 26:             uadditional = ((long)(data[1] & (long)0xff)) << 24;             uadditional |= ((long)(data[2] & (long)0xff)) << 16;             uadditional |= ((long)(data[3] & (long)0xff)) << 8;             uadditional |= (long)(data[4] & (long)0xff);             break;           case 27:             uadditional = ((long)(data[1] & (long)0xff)) << 56;             uadditional |= ((long)(data[2] & (long)0xff)) << 48;             uadditional |= ((long)(data[3] & (long)0xff)) << 40;             uadditional |= ((long)(data[4] & (long)0xff)) << 32;             uadditional |= ((long)(data[5] & (long)0xff)) << 24;             uadditional |= ((long)(data[6] & (long)0xff)) << 16;             uadditional |= ((long)(data[7] & (long)0xff)) << 8;             uadditional |= (long)(data[8] & (long)0xff);             break;           default:             throw new CBORException("Unexpected data encountered");         }         switch (majortype) {           case 0:             if ((uadditional >> 63) == 0) {               // use only if additional's top bit isn't set               // (additional is a signed long)               return new CBORObject(CBORObjectTypeInteger' uadditional);             } else {               int low = unchecked((int)((uadditional) & 0xffffffffL));               int high = unchecked((int)((uadditional >> 32) & 0xffffffffL));               return FromObject(LowHighToEInteger(low' high));             }           case 1:             if ((uadditional >> 63) == 0) {               // use only if additional's top bit isn't set               // (additional is a signed long)               return new CBORObject(CBORObjectTypeInteger' -1 - uadditional);             } else {               int low = unchecked((int)((uadditional) & 0xffffffffL));               int high = unchecked((int)((uadditional >> 32) & 0xffffffffL));               EInteger bigintAdditional = LowHighToEInteger(low' high);               EInteger minusOne = -EInteger.One;               bigintAdditional = minusOne - (EInteger)bigintAdditional;               return FromObject(bigintAdditional);             }           case 7:             if (firstbyte == 0xf9) {               return new CBORObject(                 CBORObjectTypeSingle'              CBORUtilities.HalfPrecisionToSingle(unchecked((int)uadditional)));             }             if (firstbyte == 0xfa) {               float flt = BitConverter.ToSingle(                 BitConverter.GetBytes((int)unchecked((int)uadditional))'                 0);               return new CBORObject(                 CBORObjectTypeSingle'                 flt);             }             if (firstbyte == 0xfb) {               double flt = BitConverter.ToDouble(                 BitConverter.GetBytes((long)uadditional)'                 0);               return new CBORObject(                 CBORObjectTypeDouble'                 flt);             }             if (firstbyte == 0xf8) {               if ((int)uadditional < 32) {                 throw new CBORException("Invalid overlong simple value");               }               return new CBORObject(                 CBORObjectTypeSimpleValue'                 (int)uadditional);             }             throw new CBORException("Unexpected data encountered");           default: throw new CBORException("Unexpected data encountered");         }       }
Magic Number,PeterO.Cbor,CBORObject,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORObject.cs,GetFixedLengthObject,The following statement contains a magic number: if ((firstbyte & 0x1c) == 0x18) {         // contains 1 to 8 extra bytes of additional information         long uadditional = 0;         switch (firstbyte & 0x1f) {           case 24:             uadditional = (int)(data[1] & (int)0xff);             break;           case 25:             uadditional = ((long)(data[1] & (long)0xff)) << 8;             uadditional |= (long)(data[2] & (long)0xff);             break;           case 26:             uadditional = ((long)(data[1] & (long)0xff)) << 24;             uadditional |= ((long)(data[2] & (long)0xff)) << 16;             uadditional |= ((long)(data[3] & (long)0xff)) << 8;             uadditional |= (long)(data[4] & (long)0xff);             break;           case 27:             uadditional = ((long)(data[1] & (long)0xff)) << 56;             uadditional |= ((long)(data[2] & (long)0xff)) << 48;             uadditional |= ((long)(data[3] & (long)0xff)) << 40;             uadditional |= ((long)(data[4] & (long)0xff)) << 32;             uadditional |= ((long)(data[5] & (long)0xff)) << 24;             uadditional |= ((long)(data[6] & (long)0xff)) << 16;             uadditional |= ((long)(data[7] & (long)0xff)) << 8;             uadditional |= (long)(data[8] & (long)0xff);             break;           default:             throw new CBORException("Unexpected data encountered");         }         switch (majortype) {           case 0:             if ((uadditional >> 63) == 0) {               // use only if additional's top bit isn't set               // (additional is a signed long)               return new CBORObject(CBORObjectTypeInteger' uadditional);             } else {               int low = unchecked((int)((uadditional) & 0xffffffffL));               int high = unchecked((int)((uadditional >> 32) & 0xffffffffL));               return FromObject(LowHighToEInteger(low' high));             }           case 1:             if ((uadditional >> 63) == 0) {               // use only if additional's top bit isn't set               // (additional is a signed long)               return new CBORObject(CBORObjectTypeInteger' -1 - uadditional);             } else {               int low = unchecked((int)((uadditional) & 0xffffffffL));               int high = unchecked((int)((uadditional >> 32) & 0xffffffffL));               EInteger bigintAdditional = LowHighToEInteger(low' high);               EInteger minusOne = -EInteger.One;               bigintAdditional = minusOne - (EInteger)bigintAdditional;               return FromObject(bigintAdditional);             }           case 7:             if (firstbyte == 0xf9) {               return new CBORObject(                 CBORObjectTypeSingle'              CBORUtilities.HalfPrecisionToSingle(unchecked((int)uadditional)));             }             if (firstbyte == 0xfa) {               float flt = BitConverter.ToSingle(                 BitConverter.GetBytes((int)unchecked((int)uadditional))'                 0);               return new CBORObject(                 CBORObjectTypeSingle'                 flt);             }             if (firstbyte == 0xfb) {               double flt = BitConverter.ToDouble(                 BitConverter.GetBytes((long)uadditional)'                 0);               return new CBORObject(                 CBORObjectTypeDouble'                 flt);             }             if (firstbyte == 0xf8) {               if ((int)uadditional < 32) {                 throw new CBORException("Invalid overlong simple value");               }               return new CBORObject(                 CBORObjectTypeSimpleValue'                 (int)uadditional);             }             throw new CBORException("Unexpected data encountered");           default: throw new CBORException("Unexpected data encountered");         }       }
Magic Number,PeterO.Cbor,CBORObject,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORObject.cs,GetFixedLengthObject,The following statement contains a magic number: if ((firstbyte & 0x1c) == 0x18) {         // contains 1 to 8 extra bytes of additional information         long uadditional = 0;         switch (firstbyte & 0x1f) {           case 24:             uadditional = (int)(data[1] & (int)0xff);             break;           case 25:             uadditional = ((long)(data[1] & (long)0xff)) << 8;             uadditional |= (long)(data[2] & (long)0xff);             break;           case 26:             uadditional = ((long)(data[1] & (long)0xff)) << 24;             uadditional |= ((long)(data[2] & (long)0xff)) << 16;             uadditional |= ((long)(data[3] & (long)0xff)) << 8;             uadditional |= (long)(data[4] & (long)0xff);             break;           case 27:             uadditional = ((long)(data[1] & (long)0xff)) << 56;             uadditional |= ((long)(data[2] & (long)0xff)) << 48;             uadditional |= ((long)(data[3] & (long)0xff)) << 40;             uadditional |= ((long)(data[4] & (long)0xff)) << 32;             uadditional |= ((long)(data[5] & (long)0xff)) << 24;             uadditional |= ((long)(data[6] & (long)0xff)) << 16;             uadditional |= ((long)(data[7] & (long)0xff)) << 8;             uadditional |= (long)(data[8] & (long)0xff);             break;           default:             throw new CBORException("Unexpected data encountered");         }         switch (majortype) {           case 0:             if ((uadditional >> 63) == 0) {               // use only if additional's top bit isn't set               // (additional is a signed long)               return new CBORObject(CBORObjectTypeInteger' uadditional);             } else {               int low = unchecked((int)((uadditional) & 0xffffffffL));               int high = unchecked((int)((uadditional >> 32) & 0xffffffffL));               return FromObject(LowHighToEInteger(low' high));             }           case 1:             if ((uadditional >> 63) == 0) {               // use only if additional's top bit isn't set               // (additional is a signed long)               return new CBORObject(CBORObjectTypeInteger' -1 - uadditional);             } else {               int low = unchecked((int)((uadditional) & 0xffffffffL));               int high = unchecked((int)((uadditional >> 32) & 0xffffffffL));               EInteger bigintAdditional = LowHighToEInteger(low' high);               EInteger minusOne = -EInteger.One;               bigintAdditional = minusOne - (EInteger)bigintAdditional;               return FromObject(bigintAdditional);             }           case 7:             if (firstbyte == 0xf9) {               return new CBORObject(                 CBORObjectTypeSingle'              CBORUtilities.HalfPrecisionToSingle(unchecked((int)uadditional)));             }             if (firstbyte == 0xfa) {               float flt = BitConverter.ToSingle(                 BitConverter.GetBytes((int)unchecked((int)uadditional))'                 0);               return new CBORObject(                 CBORObjectTypeSingle'                 flt);             }             if (firstbyte == 0xfb) {               double flt = BitConverter.ToDouble(                 BitConverter.GetBytes((long)uadditional)'                 0);               return new CBORObject(                 CBORObjectTypeDouble'                 flt);             }             if (firstbyte == 0xf8) {               if ((int)uadditional < 32) {                 throw new CBORException("Invalid overlong simple value");               }               return new CBORObject(                 CBORObjectTypeSimpleValue'                 (int)uadditional);             }             throw new CBORException("Unexpected data encountered");           default: throw new CBORException("Unexpected data encountered");         }       }
Magic Number,PeterO.Cbor,CBORObject,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORObject.cs,GetFixedLengthObject,The following statement contains a magic number: if ((firstbyte & 0x1c) == 0x18) {         // contains 1 to 8 extra bytes of additional information         long uadditional = 0;         switch (firstbyte & 0x1f) {           case 24:             uadditional = (int)(data[1] & (int)0xff);             break;           case 25:             uadditional = ((long)(data[1] & (long)0xff)) << 8;             uadditional |= (long)(data[2] & (long)0xff);             break;           case 26:             uadditional = ((long)(data[1] & (long)0xff)) << 24;             uadditional |= ((long)(data[2] & (long)0xff)) << 16;             uadditional |= ((long)(data[3] & (long)0xff)) << 8;             uadditional |= (long)(data[4] & (long)0xff);             break;           case 27:             uadditional = ((long)(data[1] & (long)0xff)) << 56;             uadditional |= ((long)(data[2] & (long)0xff)) << 48;             uadditional |= ((long)(data[3] & (long)0xff)) << 40;             uadditional |= ((long)(data[4] & (long)0xff)) << 32;             uadditional |= ((long)(data[5] & (long)0xff)) << 24;             uadditional |= ((long)(data[6] & (long)0xff)) << 16;             uadditional |= ((long)(data[7] & (long)0xff)) << 8;             uadditional |= (long)(data[8] & (long)0xff);             break;           default:             throw new CBORException("Unexpected data encountered");         }         switch (majortype) {           case 0:             if ((uadditional >> 63) == 0) {               // use only if additional's top bit isn't set               // (additional is a signed long)               return new CBORObject(CBORObjectTypeInteger' uadditional);             } else {               int low = unchecked((int)((uadditional) & 0xffffffffL));               int high = unchecked((int)((uadditional >> 32) & 0xffffffffL));               return FromObject(LowHighToEInteger(low' high));             }           case 1:             if ((uadditional >> 63) == 0) {               // use only if additional's top bit isn't set               // (additional is a signed long)               return new CBORObject(CBORObjectTypeInteger' -1 - uadditional);             } else {               int low = unchecked((int)((uadditional) & 0xffffffffL));               int high = unchecked((int)((uadditional >> 32) & 0xffffffffL));               EInteger bigintAdditional = LowHighToEInteger(low' high);               EInteger minusOne = -EInteger.One;               bigintAdditional = minusOne - (EInteger)bigintAdditional;               return FromObject(bigintAdditional);             }           case 7:             if (firstbyte == 0xf9) {               return new CBORObject(                 CBORObjectTypeSingle'              CBORUtilities.HalfPrecisionToSingle(unchecked((int)uadditional)));             }             if (firstbyte == 0xfa) {               float flt = BitConverter.ToSingle(                 BitConverter.GetBytes((int)unchecked((int)uadditional))'                 0);               return new CBORObject(                 CBORObjectTypeSingle'                 flt);             }             if (firstbyte == 0xfb) {               double flt = BitConverter.ToDouble(                 BitConverter.GetBytes((long)uadditional)'                 0);               return new CBORObject(                 CBORObjectTypeDouble'                 flt);             }             if (firstbyte == 0xf8) {               if ((int)uadditional < 32) {                 throw new CBORException("Invalid overlong simple value");               }               return new CBORObject(                 CBORObjectTypeSimpleValue'                 (int)uadditional);             }             throw new CBORException("Unexpected data encountered");           default: throw new CBORException("Unexpected data encountered");         }       }
Magic Number,PeterO.Cbor,CBORObject,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORObject.cs,GetFixedLengthObject,The following statement contains a magic number: if ((firstbyte & 0x1c) == 0x18) {         // contains 1 to 8 extra bytes of additional information         long uadditional = 0;         switch (firstbyte & 0x1f) {           case 24:             uadditional = (int)(data[1] & (int)0xff);             break;           case 25:             uadditional = ((long)(data[1] & (long)0xff)) << 8;             uadditional |= (long)(data[2] & (long)0xff);             break;           case 26:             uadditional = ((long)(data[1] & (long)0xff)) << 24;             uadditional |= ((long)(data[2] & (long)0xff)) << 16;             uadditional |= ((long)(data[3] & (long)0xff)) << 8;             uadditional |= (long)(data[4] & (long)0xff);             break;           case 27:             uadditional = ((long)(data[1] & (long)0xff)) << 56;             uadditional |= ((long)(data[2] & (long)0xff)) << 48;             uadditional |= ((long)(data[3] & (long)0xff)) << 40;             uadditional |= ((long)(data[4] & (long)0xff)) << 32;             uadditional |= ((long)(data[5] & (long)0xff)) << 24;             uadditional |= ((long)(data[6] & (long)0xff)) << 16;             uadditional |= ((long)(data[7] & (long)0xff)) << 8;             uadditional |= (long)(data[8] & (long)0xff);             break;           default:             throw new CBORException("Unexpected data encountered");         }         switch (majortype) {           case 0:             if ((uadditional >> 63) == 0) {               // use only if additional's top bit isn't set               // (additional is a signed long)               return new CBORObject(CBORObjectTypeInteger' uadditional);             } else {               int low = unchecked((int)((uadditional) & 0xffffffffL));               int high = unchecked((int)((uadditional >> 32) & 0xffffffffL));               return FromObject(LowHighToEInteger(low' high));             }           case 1:             if ((uadditional >> 63) == 0) {               // use only if additional's top bit isn't set               // (additional is a signed long)               return new CBORObject(CBORObjectTypeInteger' -1 - uadditional);             } else {               int low = unchecked((int)((uadditional) & 0xffffffffL));               int high = unchecked((int)((uadditional >> 32) & 0xffffffffL));               EInteger bigintAdditional = LowHighToEInteger(low' high);               EInteger minusOne = -EInteger.One;               bigintAdditional = minusOne - (EInteger)bigintAdditional;               return FromObject(bigintAdditional);             }           case 7:             if (firstbyte == 0xf9) {               return new CBORObject(                 CBORObjectTypeSingle'              CBORUtilities.HalfPrecisionToSingle(unchecked((int)uadditional)));             }             if (firstbyte == 0xfa) {               float flt = BitConverter.ToSingle(                 BitConverter.GetBytes((int)unchecked((int)uadditional))'                 0);               return new CBORObject(                 CBORObjectTypeSingle'                 flt);             }             if (firstbyte == 0xfb) {               double flt = BitConverter.ToDouble(                 BitConverter.GetBytes((long)uadditional)'                 0);               return new CBORObject(                 CBORObjectTypeDouble'                 flt);             }             if (firstbyte == 0xf8) {               if ((int)uadditional < 32) {                 throw new CBORException("Invalid overlong simple value");               }               return new CBORObject(                 CBORObjectTypeSimpleValue'                 (int)uadditional);             }             throw new CBORException("Unexpected data encountered");           default: throw new CBORException("Unexpected data encountered");         }       }
Magic Number,PeterO.Cbor,CBORObject,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORObject.cs,GetFixedLengthObject,The following statement contains a magic number: if ((firstbyte & 0x1c) == 0x18) {         // contains 1 to 8 extra bytes of additional information         long uadditional = 0;         switch (firstbyte & 0x1f) {           case 24:             uadditional = (int)(data[1] & (int)0xff);             break;           case 25:             uadditional = ((long)(data[1] & (long)0xff)) << 8;             uadditional |= (long)(data[2] & (long)0xff);             break;           case 26:             uadditional = ((long)(data[1] & (long)0xff)) << 24;             uadditional |= ((long)(data[2] & (long)0xff)) << 16;             uadditional |= ((long)(data[3] & (long)0xff)) << 8;             uadditional |= (long)(data[4] & (long)0xff);             break;           case 27:             uadditional = ((long)(data[1] & (long)0xff)) << 56;             uadditional |= ((long)(data[2] & (long)0xff)) << 48;             uadditional |= ((long)(data[3] & (long)0xff)) << 40;             uadditional |= ((long)(data[4] & (long)0xff)) << 32;             uadditional |= ((long)(data[5] & (long)0xff)) << 24;             uadditional |= ((long)(data[6] & (long)0xff)) << 16;             uadditional |= ((long)(data[7] & (long)0xff)) << 8;             uadditional |= (long)(data[8] & (long)0xff);             break;           default:             throw new CBORException("Unexpected data encountered");         }         switch (majortype) {           case 0:             if ((uadditional >> 63) == 0) {               // use only if additional's top bit isn't set               // (additional is a signed long)               return new CBORObject(CBORObjectTypeInteger' uadditional);             } else {               int low = unchecked((int)((uadditional) & 0xffffffffL));               int high = unchecked((int)((uadditional >> 32) & 0xffffffffL));               return FromObject(LowHighToEInteger(low' high));             }           case 1:             if ((uadditional >> 63) == 0) {               // use only if additional's top bit isn't set               // (additional is a signed long)               return new CBORObject(CBORObjectTypeInteger' -1 - uadditional);             } else {               int low = unchecked((int)((uadditional) & 0xffffffffL));               int high = unchecked((int)((uadditional >> 32) & 0xffffffffL));               EInteger bigintAdditional = LowHighToEInteger(low' high);               EInteger minusOne = -EInteger.One;               bigintAdditional = minusOne - (EInteger)bigintAdditional;               return FromObject(bigintAdditional);             }           case 7:             if (firstbyte == 0xf9) {               return new CBORObject(                 CBORObjectTypeSingle'              CBORUtilities.HalfPrecisionToSingle(unchecked((int)uadditional)));             }             if (firstbyte == 0xfa) {               float flt = BitConverter.ToSingle(                 BitConverter.GetBytes((int)unchecked((int)uadditional))'                 0);               return new CBORObject(                 CBORObjectTypeSingle'                 flt);             }             if (firstbyte == 0xfb) {               double flt = BitConverter.ToDouble(                 BitConverter.GetBytes((long)uadditional)'                 0);               return new CBORObject(                 CBORObjectTypeDouble'                 flt);             }             if (firstbyte == 0xf8) {               if ((int)uadditional < 32) {                 throw new CBORException("Invalid overlong simple value");               }               return new CBORObject(                 CBORObjectTypeSimpleValue'                 (int)uadditional);             }             throw new CBORException("Unexpected data encountered");           default: throw new CBORException("Unexpected data encountered");         }       }
Magic Number,PeterO.Cbor,CBORObject,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORObject.cs,GetFixedLengthObject,The following statement contains a magic number: if ((firstbyte & 0x1c) == 0x18) {         // contains 1 to 8 extra bytes of additional information         long uadditional = 0;         switch (firstbyte & 0x1f) {           case 24:             uadditional = (int)(data[1] & (int)0xff);             break;           case 25:             uadditional = ((long)(data[1] & (long)0xff)) << 8;             uadditional |= (long)(data[2] & (long)0xff);             break;           case 26:             uadditional = ((long)(data[1] & (long)0xff)) << 24;             uadditional |= ((long)(data[2] & (long)0xff)) << 16;             uadditional |= ((long)(data[3] & (long)0xff)) << 8;             uadditional |= (long)(data[4] & (long)0xff);             break;           case 27:             uadditional = ((long)(data[1] & (long)0xff)) << 56;             uadditional |= ((long)(data[2] & (long)0xff)) << 48;             uadditional |= ((long)(data[3] & (long)0xff)) << 40;             uadditional |= ((long)(data[4] & (long)0xff)) << 32;             uadditional |= ((long)(data[5] & (long)0xff)) << 24;             uadditional |= ((long)(data[6] & (long)0xff)) << 16;             uadditional |= ((long)(data[7] & (long)0xff)) << 8;             uadditional |= (long)(data[8] & (long)0xff);             break;           default:             throw new CBORException("Unexpected data encountered");         }         switch (majortype) {           case 0:             if ((uadditional >> 63) == 0) {               // use only if additional's top bit isn't set               // (additional is a signed long)               return new CBORObject(CBORObjectTypeInteger' uadditional);             } else {               int low = unchecked((int)((uadditional) & 0xffffffffL));               int high = unchecked((int)((uadditional >> 32) & 0xffffffffL));               return FromObject(LowHighToEInteger(low' high));             }           case 1:             if ((uadditional >> 63) == 0) {               // use only if additional's top bit isn't set               // (additional is a signed long)               return new CBORObject(CBORObjectTypeInteger' -1 - uadditional);             } else {               int low = unchecked((int)((uadditional) & 0xffffffffL));               int high = unchecked((int)((uadditional >> 32) & 0xffffffffL));               EInteger bigintAdditional = LowHighToEInteger(low' high);               EInteger minusOne = -EInteger.One;               bigintAdditional = minusOne - (EInteger)bigintAdditional;               return FromObject(bigintAdditional);             }           case 7:             if (firstbyte == 0xf9) {               return new CBORObject(                 CBORObjectTypeSingle'              CBORUtilities.HalfPrecisionToSingle(unchecked((int)uadditional)));             }             if (firstbyte == 0xfa) {               float flt = BitConverter.ToSingle(                 BitConverter.GetBytes((int)unchecked((int)uadditional))'                 0);               return new CBORObject(                 CBORObjectTypeSingle'                 flt);             }             if (firstbyte == 0xfb) {               double flt = BitConverter.ToDouble(                 BitConverter.GetBytes((long)uadditional)'                 0);               return new CBORObject(                 CBORObjectTypeDouble'                 flt);             }             if (firstbyte == 0xf8) {               if ((int)uadditional < 32) {                 throw new CBORException("Invalid overlong simple value");               }               return new CBORObject(                 CBORObjectTypeSimpleValue'                 (int)uadditional);             }             throw new CBORException("Unexpected data encountered");           default: throw new CBORException("Unexpected data encountered");         }       }
Magic Number,PeterO.Cbor,CBORObject,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORObject.cs,GetFixedLengthObject,The following statement contains a magic number: if ((firstbyte & 0x1c) == 0x18) {         // contains 1 to 8 extra bytes of additional information         long uadditional = 0;         switch (firstbyte & 0x1f) {           case 24:             uadditional = (int)(data[1] & (int)0xff);             break;           case 25:             uadditional = ((long)(data[1] & (long)0xff)) << 8;             uadditional |= (long)(data[2] & (long)0xff);             break;           case 26:             uadditional = ((long)(data[1] & (long)0xff)) << 24;             uadditional |= ((long)(data[2] & (long)0xff)) << 16;             uadditional |= ((long)(data[3] & (long)0xff)) << 8;             uadditional |= (long)(data[4] & (long)0xff);             break;           case 27:             uadditional = ((long)(data[1] & (long)0xff)) << 56;             uadditional |= ((long)(data[2] & (long)0xff)) << 48;             uadditional |= ((long)(data[3] & (long)0xff)) << 40;             uadditional |= ((long)(data[4] & (long)0xff)) << 32;             uadditional |= ((long)(data[5] & (long)0xff)) << 24;             uadditional |= ((long)(data[6] & (long)0xff)) << 16;             uadditional |= ((long)(data[7] & (long)0xff)) << 8;             uadditional |= (long)(data[8] & (long)0xff);             break;           default:             throw new CBORException("Unexpected data encountered");         }         switch (majortype) {           case 0:             if ((uadditional >> 63) == 0) {               // use only if additional's top bit isn't set               // (additional is a signed long)               return new CBORObject(CBORObjectTypeInteger' uadditional);             } else {               int low = unchecked((int)((uadditional) & 0xffffffffL));               int high = unchecked((int)((uadditional >> 32) & 0xffffffffL));               return FromObject(LowHighToEInteger(low' high));             }           case 1:             if ((uadditional >> 63) == 0) {               // use only if additional's top bit isn't set               // (additional is a signed long)               return new CBORObject(CBORObjectTypeInteger' -1 - uadditional);             } else {               int low = unchecked((int)((uadditional) & 0xffffffffL));               int high = unchecked((int)((uadditional >> 32) & 0xffffffffL));               EInteger bigintAdditional = LowHighToEInteger(low' high);               EInteger minusOne = -EInteger.One;               bigintAdditional = minusOne - (EInteger)bigintAdditional;               return FromObject(bigintAdditional);             }           case 7:             if (firstbyte == 0xf9) {               return new CBORObject(                 CBORObjectTypeSingle'              CBORUtilities.HalfPrecisionToSingle(unchecked((int)uadditional)));             }             if (firstbyte == 0xfa) {               float flt = BitConverter.ToSingle(                 BitConverter.GetBytes((int)unchecked((int)uadditional))'                 0);               return new CBORObject(                 CBORObjectTypeSingle'                 flt);             }             if (firstbyte == 0xfb) {               double flt = BitConverter.ToDouble(                 BitConverter.GetBytes((long)uadditional)'                 0);               return new CBORObject(                 CBORObjectTypeDouble'                 flt);             }             if (firstbyte == 0xf8) {               if ((int)uadditional < 32) {                 throw new CBORException("Invalid overlong simple value");               }               return new CBORObject(                 CBORObjectTypeSimpleValue'                 (int)uadditional);             }             throw new CBORException("Unexpected data encountered");           default: throw new CBORException("Unexpected data encountered");         }       }
Magic Number,PeterO.Cbor,CBORObject,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORObject.cs,GetFixedLengthObject,The following statement contains a magic number: if ((firstbyte & 0x1c) == 0x18) {         // contains 1 to 8 extra bytes of additional information         long uadditional = 0;         switch (firstbyte & 0x1f) {           case 24:             uadditional = (int)(data[1] & (int)0xff);             break;           case 25:             uadditional = ((long)(data[1] & (long)0xff)) << 8;             uadditional |= (long)(data[2] & (long)0xff);             break;           case 26:             uadditional = ((long)(data[1] & (long)0xff)) << 24;             uadditional |= ((long)(data[2] & (long)0xff)) << 16;             uadditional |= ((long)(data[3] & (long)0xff)) << 8;             uadditional |= (long)(data[4] & (long)0xff);             break;           case 27:             uadditional = ((long)(data[1] & (long)0xff)) << 56;             uadditional |= ((long)(data[2] & (long)0xff)) << 48;             uadditional |= ((long)(data[3] & (long)0xff)) << 40;             uadditional |= ((long)(data[4] & (long)0xff)) << 32;             uadditional |= ((long)(data[5] & (long)0xff)) << 24;             uadditional |= ((long)(data[6] & (long)0xff)) << 16;             uadditional |= ((long)(data[7] & (long)0xff)) << 8;             uadditional |= (long)(data[8] & (long)0xff);             break;           default:             throw new CBORException("Unexpected data encountered");         }         switch (majortype) {           case 0:             if ((uadditional >> 63) == 0) {               // use only if additional's top bit isn't set               // (additional is a signed long)               return new CBORObject(CBORObjectTypeInteger' uadditional);             } else {               int low = unchecked((int)((uadditional) & 0xffffffffL));               int high = unchecked((int)((uadditional >> 32) & 0xffffffffL));               return FromObject(LowHighToEInteger(low' high));             }           case 1:             if ((uadditional >> 63) == 0) {               // use only if additional's top bit isn't set               // (additional is a signed long)               return new CBORObject(CBORObjectTypeInteger' -1 - uadditional);             } else {               int low = unchecked((int)((uadditional) & 0xffffffffL));               int high = unchecked((int)((uadditional >> 32) & 0xffffffffL));               EInteger bigintAdditional = LowHighToEInteger(low' high);               EInteger minusOne = -EInteger.One;               bigintAdditional = minusOne - (EInteger)bigintAdditional;               return FromObject(bigintAdditional);             }           case 7:             if (firstbyte == 0xf9) {               return new CBORObject(                 CBORObjectTypeSingle'              CBORUtilities.HalfPrecisionToSingle(unchecked((int)uadditional)));             }             if (firstbyte == 0xfa) {               float flt = BitConverter.ToSingle(                 BitConverter.GetBytes((int)unchecked((int)uadditional))'                 0);               return new CBORObject(                 CBORObjectTypeSingle'                 flt);             }             if (firstbyte == 0xfb) {               double flt = BitConverter.ToDouble(                 BitConverter.GetBytes((long)uadditional)'                 0);               return new CBORObject(                 CBORObjectTypeDouble'                 flt);             }             if (firstbyte == 0xf8) {               if ((int)uadditional < 32) {                 throw new CBORException("Invalid overlong simple value");               }               return new CBORObject(                 CBORObjectTypeSimpleValue'                 (int)uadditional);             }             throw new CBORException("Unexpected data encountered");           default: throw new CBORException("Unexpected data encountered");         }       }
Magic Number,PeterO.Cbor,CBORObject,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORObject.cs,GetFixedLengthObject,The following statement contains a magic number: if ((firstbyte & 0x1c) == 0x18) {         // contains 1 to 8 extra bytes of additional information         long uadditional = 0;         switch (firstbyte & 0x1f) {           case 24:             uadditional = (int)(data[1] & (int)0xff);             break;           case 25:             uadditional = ((long)(data[1] & (long)0xff)) << 8;             uadditional |= (long)(data[2] & (long)0xff);             break;           case 26:             uadditional = ((long)(data[1] & (long)0xff)) << 24;             uadditional |= ((long)(data[2] & (long)0xff)) << 16;             uadditional |= ((long)(data[3] & (long)0xff)) << 8;             uadditional |= (long)(data[4] & (long)0xff);             break;           case 27:             uadditional = ((long)(data[1] & (long)0xff)) << 56;             uadditional |= ((long)(data[2] & (long)0xff)) << 48;             uadditional |= ((long)(data[3] & (long)0xff)) << 40;             uadditional |= ((long)(data[4] & (long)0xff)) << 32;             uadditional |= ((long)(data[5] & (long)0xff)) << 24;             uadditional |= ((long)(data[6] & (long)0xff)) << 16;             uadditional |= ((long)(data[7] & (long)0xff)) << 8;             uadditional |= (long)(data[8] & (long)0xff);             break;           default:             throw new CBORException("Unexpected data encountered");         }         switch (majortype) {           case 0:             if ((uadditional >> 63) == 0) {               // use only if additional's top bit isn't set               // (additional is a signed long)               return new CBORObject(CBORObjectTypeInteger' uadditional);             } else {               int low = unchecked((int)((uadditional) & 0xffffffffL));               int high = unchecked((int)((uadditional >> 32) & 0xffffffffL));               return FromObject(LowHighToEInteger(low' high));             }           case 1:             if ((uadditional >> 63) == 0) {               // use only if additional's top bit isn't set               // (additional is a signed long)               return new CBORObject(CBORObjectTypeInteger' -1 - uadditional);             } else {               int low = unchecked((int)((uadditional) & 0xffffffffL));               int high = unchecked((int)((uadditional >> 32) & 0xffffffffL));               EInteger bigintAdditional = LowHighToEInteger(low' high);               EInteger minusOne = -EInteger.One;               bigintAdditional = minusOne - (EInteger)bigintAdditional;               return FromObject(bigintAdditional);             }           case 7:             if (firstbyte == 0xf9) {               return new CBORObject(                 CBORObjectTypeSingle'              CBORUtilities.HalfPrecisionToSingle(unchecked((int)uadditional)));             }             if (firstbyte == 0xfa) {               float flt = BitConverter.ToSingle(                 BitConverter.GetBytes((int)unchecked((int)uadditional))'                 0);               return new CBORObject(                 CBORObjectTypeSingle'                 flt);             }             if (firstbyte == 0xfb) {               double flt = BitConverter.ToDouble(                 BitConverter.GetBytes((long)uadditional)'                 0);               return new CBORObject(                 CBORObjectTypeDouble'                 flt);             }             if (firstbyte == 0xf8) {               if ((int)uadditional < 32) {                 throw new CBORException("Invalid overlong simple value");               }               return new CBORObject(                 CBORObjectTypeSimpleValue'                 (int)uadditional);             }             throw new CBORException("Unexpected data encountered");           default: throw new CBORException("Unexpected data encountered");         }       }
Magic Number,PeterO.Cbor,CBORObject,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORObject.cs,GetFixedLengthObject,The following statement contains a magic number: if ((firstbyte & 0x1c) == 0x18) {         // contains 1 to 8 extra bytes of additional information         long uadditional = 0;         switch (firstbyte & 0x1f) {           case 24:             uadditional = (int)(data[1] & (int)0xff);             break;           case 25:             uadditional = ((long)(data[1] & (long)0xff)) << 8;             uadditional |= (long)(data[2] & (long)0xff);             break;           case 26:             uadditional = ((long)(data[1] & (long)0xff)) << 24;             uadditional |= ((long)(data[2] & (long)0xff)) << 16;             uadditional |= ((long)(data[3] & (long)0xff)) << 8;             uadditional |= (long)(data[4] & (long)0xff);             break;           case 27:             uadditional = ((long)(data[1] & (long)0xff)) << 56;             uadditional |= ((long)(data[2] & (long)0xff)) << 48;             uadditional |= ((long)(data[3] & (long)0xff)) << 40;             uadditional |= ((long)(data[4] & (long)0xff)) << 32;             uadditional |= ((long)(data[5] & (long)0xff)) << 24;             uadditional |= ((long)(data[6] & (long)0xff)) << 16;             uadditional |= ((long)(data[7] & (long)0xff)) << 8;             uadditional |= (long)(data[8] & (long)0xff);             break;           default:             throw new CBORException("Unexpected data encountered");         }         switch (majortype) {           case 0:             if ((uadditional >> 63) == 0) {               // use only if additional's top bit isn't set               // (additional is a signed long)               return new CBORObject(CBORObjectTypeInteger' uadditional);             } else {               int low = unchecked((int)((uadditional) & 0xffffffffL));               int high = unchecked((int)((uadditional >> 32) & 0xffffffffL));               return FromObject(LowHighToEInteger(low' high));             }           case 1:             if ((uadditional >> 63) == 0) {               // use only if additional's top bit isn't set               // (additional is a signed long)               return new CBORObject(CBORObjectTypeInteger' -1 - uadditional);             } else {               int low = unchecked((int)((uadditional) & 0xffffffffL));               int high = unchecked((int)((uadditional >> 32) & 0xffffffffL));               EInteger bigintAdditional = LowHighToEInteger(low' high);               EInteger minusOne = -EInteger.One;               bigintAdditional = minusOne - (EInteger)bigintAdditional;               return FromObject(bigintAdditional);             }           case 7:             if (firstbyte == 0xf9) {               return new CBORObject(                 CBORObjectTypeSingle'              CBORUtilities.HalfPrecisionToSingle(unchecked((int)uadditional)));             }             if (firstbyte == 0xfa) {               float flt = BitConverter.ToSingle(                 BitConverter.GetBytes((int)unchecked((int)uadditional))'                 0);               return new CBORObject(                 CBORObjectTypeSingle'                 flt);             }             if (firstbyte == 0xfb) {               double flt = BitConverter.ToDouble(                 BitConverter.GetBytes((long)uadditional)'                 0);               return new CBORObject(                 CBORObjectTypeDouble'                 flt);             }             if (firstbyte == 0xf8) {               if ((int)uadditional < 32) {                 throw new CBORException("Invalid overlong simple value");               }               return new CBORObject(                 CBORObjectTypeSimpleValue'                 (int)uadditional);             }             throw new CBORException("Unexpected data encountered");           default: throw new CBORException("Unexpected data encountered");         }       }
Magic Number,PeterO.Cbor,CBORObject,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORObject.cs,GetFixedLengthObject,The following statement contains a magic number: if ((firstbyte & 0x1c) == 0x18) {         // contains 1 to 8 extra bytes of additional information         long uadditional = 0;         switch (firstbyte & 0x1f) {           case 24:             uadditional = (int)(data[1] & (int)0xff);             break;           case 25:             uadditional = ((long)(data[1] & (long)0xff)) << 8;             uadditional |= (long)(data[2] & (long)0xff);             break;           case 26:             uadditional = ((long)(data[1] & (long)0xff)) << 24;             uadditional |= ((long)(data[2] & (long)0xff)) << 16;             uadditional |= ((long)(data[3] & (long)0xff)) << 8;             uadditional |= (long)(data[4] & (long)0xff);             break;           case 27:             uadditional = ((long)(data[1] & (long)0xff)) << 56;             uadditional |= ((long)(data[2] & (long)0xff)) << 48;             uadditional |= ((long)(data[3] & (long)0xff)) << 40;             uadditional |= ((long)(data[4] & (long)0xff)) << 32;             uadditional |= ((long)(data[5] & (long)0xff)) << 24;             uadditional |= ((long)(data[6] & (long)0xff)) << 16;             uadditional |= ((long)(data[7] & (long)0xff)) << 8;             uadditional |= (long)(data[8] & (long)0xff);             break;           default:             throw new CBORException("Unexpected data encountered");         }         switch (majortype) {           case 0:             if ((uadditional >> 63) == 0) {               // use only if additional's top bit isn't set               // (additional is a signed long)               return new CBORObject(CBORObjectTypeInteger' uadditional);             } else {               int low = unchecked((int)((uadditional) & 0xffffffffL));               int high = unchecked((int)((uadditional >> 32) & 0xffffffffL));               return FromObject(LowHighToEInteger(low' high));             }           case 1:             if ((uadditional >> 63) == 0) {               // use only if additional's top bit isn't set               // (additional is a signed long)               return new CBORObject(CBORObjectTypeInteger' -1 - uadditional);             } else {               int low = unchecked((int)((uadditional) & 0xffffffffL));               int high = unchecked((int)((uadditional >> 32) & 0xffffffffL));               EInteger bigintAdditional = LowHighToEInteger(low' high);               EInteger minusOne = -EInteger.One;               bigintAdditional = minusOne - (EInteger)bigintAdditional;               return FromObject(bigintAdditional);             }           case 7:             if (firstbyte == 0xf9) {               return new CBORObject(                 CBORObjectTypeSingle'              CBORUtilities.HalfPrecisionToSingle(unchecked((int)uadditional)));             }             if (firstbyte == 0xfa) {               float flt = BitConverter.ToSingle(                 BitConverter.GetBytes((int)unchecked((int)uadditional))'                 0);               return new CBORObject(                 CBORObjectTypeSingle'                 flt);             }             if (firstbyte == 0xfb) {               double flt = BitConverter.ToDouble(                 BitConverter.GetBytes((long)uadditional)'                 0);               return new CBORObject(                 CBORObjectTypeDouble'                 flt);             }             if (firstbyte == 0xf8) {               if ((int)uadditional < 32) {                 throw new CBORException("Invalid overlong simple value");               }               return new CBORObject(                 CBORObjectTypeSimpleValue'                 (int)uadditional);             }             throw new CBORException("Unexpected data encountered");           default: throw new CBORException("Unexpected data encountered");         }       }
Magic Number,PeterO.Cbor,CBORObject,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORObject.cs,GetFixedLengthObject,The following statement contains a magic number: if ((firstbyte & 0x1c) == 0x18) {         // contains 1 to 8 extra bytes of additional information         long uadditional = 0;         switch (firstbyte & 0x1f) {           case 24:             uadditional = (int)(data[1] & (int)0xff);             break;           case 25:             uadditional = ((long)(data[1] & (long)0xff)) << 8;             uadditional |= (long)(data[2] & (long)0xff);             break;           case 26:             uadditional = ((long)(data[1] & (long)0xff)) << 24;             uadditional |= ((long)(data[2] & (long)0xff)) << 16;             uadditional |= ((long)(data[3] & (long)0xff)) << 8;             uadditional |= (long)(data[4] & (long)0xff);             break;           case 27:             uadditional = ((long)(data[1] & (long)0xff)) << 56;             uadditional |= ((long)(data[2] & (long)0xff)) << 48;             uadditional |= ((long)(data[3] & (long)0xff)) << 40;             uadditional |= ((long)(data[4] & (long)0xff)) << 32;             uadditional |= ((long)(data[5] & (long)0xff)) << 24;             uadditional |= ((long)(data[6] & (long)0xff)) << 16;             uadditional |= ((long)(data[7] & (long)0xff)) << 8;             uadditional |= (long)(data[8] & (long)0xff);             break;           default:             throw new CBORException("Unexpected data encountered");         }         switch (majortype) {           case 0:             if ((uadditional >> 63) == 0) {               // use only if additional's top bit isn't set               // (additional is a signed long)               return new CBORObject(CBORObjectTypeInteger' uadditional);             } else {               int low = unchecked((int)((uadditional) & 0xffffffffL));               int high = unchecked((int)((uadditional >> 32) & 0xffffffffL));               return FromObject(LowHighToEInteger(low' high));             }           case 1:             if ((uadditional >> 63) == 0) {               // use only if additional's top bit isn't set               // (additional is a signed long)               return new CBORObject(CBORObjectTypeInteger' -1 - uadditional);             } else {               int low = unchecked((int)((uadditional) & 0xffffffffL));               int high = unchecked((int)((uadditional >> 32) & 0xffffffffL));               EInteger bigintAdditional = LowHighToEInteger(low' high);               EInteger minusOne = -EInteger.One;               bigintAdditional = minusOne - (EInteger)bigintAdditional;               return FromObject(bigintAdditional);             }           case 7:             if (firstbyte == 0xf9) {               return new CBORObject(                 CBORObjectTypeSingle'              CBORUtilities.HalfPrecisionToSingle(unchecked((int)uadditional)));             }             if (firstbyte == 0xfa) {               float flt = BitConverter.ToSingle(                 BitConverter.GetBytes((int)unchecked((int)uadditional))'                 0);               return new CBORObject(                 CBORObjectTypeSingle'                 flt);             }             if (firstbyte == 0xfb) {               double flt = BitConverter.ToDouble(                 BitConverter.GetBytes((long)uadditional)'                 0);               return new CBORObject(                 CBORObjectTypeDouble'                 flt);             }             if (firstbyte == 0xf8) {               if ((int)uadditional < 32) {                 throw new CBORException("Invalid overlong simple value");               }               return new CBORObject(                 CBORObjectTypeSimpleValue'                 (int)uadditional);             }             throw new CBORException("Unexpected data encountered");           default: throw new CBORException("Unexpected data encountered");         }       }
Magic Number,PeterO.Cbor,CBORObject,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORObject.cs,GetFixedLengthObject,The following statement contains a magic number: if ((firstbyte & 0x1c) == 0x18) {         // contains 1 to 8 extra bytes of additional information         long uadditional = 0;         switch (firstbyte & 0x1f) {           case 24:             uadditional = (int)(data[1] & (int)0xff);             break;           case 25:             uadditional = ((long)(data[1] & (long)0xff)) << 8;             uadditional |= (long)(data[2] & (long)0xff);             break;           case 26:             uadditional = ((long)(data[1] & (long)0xff)) << 24;             uadditional |= ((long)(data[2] & (long)0xff)) << 16;             uadditional |= ((long)(data[3] & (long)0xff)) << 8;             uadditional |= (long)(data[4] & (long)0xff);             break;           case 27:             uadditional = ((long)(data[1] & (long)0xff)) << 56;             uadditional |= ((long)(data[2] & (long)0xff)) << 48;             uadditional |= ((long)(data[3] & (long)0xff)) << 40;             uadditional |= ((long)(data[4] & (long)0xff)) << 32;             uadditional |= ((long)(data[5] & (long)0xff)) << 24;             uadditional |= ((long)(data[6] & (long)0xff)) << 16;             uadditional |= ((long)(data[7] & (long)0xff)) << 8;             uadditional |= (long)(data[8] & (long)0xff);             break;           default:             throw new CBORException("Unexpected data encountered");         }         switch (majortype) {           case 0:             if ((uadditional >> 63) == 0) {               // use only if additional's top bit isn't set               // (additional is a signed long)               return new CBORObject(CBORObjectTypeInteger' uadditional);             } else {               int low = unchecked((int)((uadditional) & 0xffffffffL));               int high = unchecked((int)((uadditional >> 32) & 0xffffffffL));               return FromObject(LowHighToEInteger(low' high));             }           case 1:             if ((uadditional >> 63) == 0) {               // use only if additional's top bit isn't set               // (additional is a signed long)               return new CBORObject(CBORObjectTypeInteger' -1 - uadditional);             } else {               int low = unchecked((int)((uadditional) & 0xffffffffL));               int high = unchecked((int)((uadditional >> 32) & 0xffffffffL));               EInteger bigintAdditional = LowHighToEInteger(low' high);               EInteger minusOne = -EInteger.One;               bigintAdditional = minusOne - (EInteger)bigintAdditional;               return FromObject(bigintAdditional);             }           case 7:             if (firstbyte == 0xf9) {               return new CBORObject(                 CBORObjectTypeSingle'              CBORUtilities.HalfPrecisionToSingle(unchecked((int)uadditional)));             }             if (firstbyte == 0xfa) {               float flt = BitConverter.ToSingle(                 BitConverter.GetBytes((int)unchecked((int)uadditional))'                 0);               return new CBORObject(                 CBORObjectTypeSingle'                 flt);             }             if (firstbyte == 0xfb) {               double flt = BitConverter.ToDouble(                 BitConverter.GetBytes((long)uadditional)'                 0);               return new CBORObject(                 CBORObjectTypeDouble'                 flt);             }             if (firstbyte == 0xf8) {               if ((int)uadditional < 32) {                 throw new CBORException("Invalid overlong simple value");               }               return new CBORObject(                 CBORObjectTypeSimpleValue'                 (int)uadditional);             }             throw new CBORException("Unexpected data encountered");           default: throw new CBORException("Unexpected data encountered");         }       }
Magic Number,PeterO.Cbor,CBORObject,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORObject.cs,GetFixedLengthObject,The following statement contains a magic number: if ((firstbyte & 0x1c) == 0x18) {         // contains 1 to 8 extra bytes of additional information         long uadditional = 0;         switch (firstbyte & 0x1f) {           case 24:             uadditional = (int)(data[1] & (int)0xff);             break;           case 25:             uadditional = ((long)(data[1] & (long)0xff)) << 8;             uadditional |= (long)(data[2] & (long)0xff);             break;           case 26:             uadditional = ((long)(data[1] & (long)0xff)) << 24;             uadditional |= ((long)(data[2] & (long)0xff)) << 16;             uadditional |= ((long)(data[3] & (long)0xff)) << 8;             uadditional |= (long)(data[4] & (long)0xff);             break;           case 27:             uadditional = ((long)(data[1] & (long)0xff)) << 56;             uadditional |= ((long)(data[2] & (long)0xff)) << 48;             uadditional |= ((long)(data[3] & (long)0xff)) << 40;             uadditional |= ((long)(data[4] & (long)0xff)) << 32;             uadditional |= ((long)(data[5] & (long)0xff)) << 24;             uadditional |= ((long)(data[6] & (long)0xff)) << 16;             uadditional |= ((long)(data[7] & (long)0xff)) << 8;             uadditional |= (long)(data[8] & (long)0xff);             break;           default:             throw new CBORException("Unexpected data encountered");         }         switch (majortype) {           case 0:             if ((uadditional >> 63) == 0) {               // use only if additional's top bit isn't set               // (additional is a signed long)               return new CBORObject(CBORObjectTypeInteger' uadditional);             } else {               int low = unchecked((int)((uadditional) & 0xffffffffL));               int high = unchecked((int)((uadditional >> 32) & 0xffffffffL));               return FromObject(LowHighToEInteger(low' high));             }           case 1:             if ((uadditional >> 63) == 0) {               // use only if additional's top bit isn't set               // (additional is a signed long)               return new CBORObject(CBORObjectTypeInteger' -1 - uadditional);             } else {               int low = unchecked((int)((uadditional) & 0xffffffffL));               int high = unchecked((int)((uadditional >> 32) & 0xffffffffL));               EInteger bigintAdditional = LowHighToEInteger(low' high);               EInteger minusOne = -EInteger.One;               bigintAdditional = minusOne - (EInteger)bigintAdditional;               return FromObject(bigintAdditional);             }           case 7:             if (firstbyte == 0xf9) {               return new CBORObject(                 CBORObjectTypeSingle'              CBORUtilities.HalfPrecisionToSingle(unchecked((int)uadditional)));             }             if (firstbyte == 0xfa) {               float flt = BitConverter.ToSingle(                 BitConverter.GetBytes((int)unchecked((int)uadditional))'                 0);               return new CBORObject(                 CBORObjectTypeSingle'                 flt);             }             if (firstbyte == 0xfb) {               double flt = BitConverter.ToDouble(                 BitConverter.GetBytes((long)uadditional)'                 0);               return new CBORObject(                 CBORObjectTypeDouble'                 flt);             }             if (firstbyte == 0xf8) {               if ((int)uadditional < 32) {                 throw new CBORException("Invalid overlong simple value");               }               return new CBORObject(                 CBORObjectTypeSimpleValue'                 (int)uadditional);             }             throw new CBORException("Unexpected data encountered");           default: throw new CBORException("Unexpected data encountered");         }       }
Magic Number,PeterO.Cbor,CBORObject,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORObject.cs,GetFixedLengthObject,The following statement contains a magic number: if ((firstbyte & 0x1c) == 0x18) {         // contains 1 to 8 extra bytes of additional information         long uadditional = 0;         switch (firstbyte & 0x1f) {           case 24:             uadditional = (int)(data[1] & (int)0xff);             break;           case 25:             uadditional = ((long)(data[1] & (long)0xff)) << 8;             uadditional |= (long)(data[2] & (long)0xff);             break;           case 26:             uadditional = ((long)(data[1] & (long)0xff)) << 24;             uadditional |= ((long)(data[2] & (long)0xff)) << 16;             uadditional |= ((long)(data[3] & (long)0xff)) << 8;             uadditional |= (long)(data[4] & (long)0xff);             break;           case 27:             uadditional = ((long)(data[1] & (long)0xff)) << 56;             uadditional |= ((long)(data[2] & (long)0xff)) << 48;             uadditional |= ((long)(data[3] & (long)0xff)) << 40;             uadditional |= ((long)(data[4] & (long)0xff)) << 32;             uadditional |= ((long)(data[5] & (long)0xff)) << 24;             uadditional |= ((long)(data[6] & (long)0xff)) << 16;             uadditional |= ((long)(data[7] & (long)0xff)) << 8;             uadditional |= (long)(data[8] & (long)0xff);             break;           default:             throw new CBORException("Unexpected data encountered");         }         switch (majortype) {           case 0:             if ((uadditional >> 63) == 0) {               // use only if additional's top bit isn't set               // (additional is a signed long)               return new CBORObject(CBORObjectTypeInteger' uadditional);             } else {               int low = unchecked((int)((uadditional) & 0xffffffffL));               int high = unchecked((int)((uadditional >> 32) & 0xffffffffL));               return FromObject(LowHighToEInteger(low' high));             }           case 1:             if ((uadditional >> 63) == 0) {               // use only if additional's top bit isn't set               // (additional is a signed long)               return new CBORObject(CBORObjectTypeInteger' -1 - uadditional);             } else {               int low = unchecked((int)((uadditional) & 0xffffffffL));               int high = unchecked((int)((uadditional >> 32) & 0xffffffffL));               EInteger bigintAdditional = LowHighToEInteger(low' high);               EInteger minusOne = -EInteger.One;               bigintAdditional = minusOne - (EInteger)bigintAdditional;               return FromObject(bigintAdditional);             }           case 7:             if (firstbyte == 0xf9) {               return new CBORObject(                 CBORObjectTypeSingle'              CBORUtilities.HalfPrecisionToSingle(unchecked((int)uadditional)));             }             if (firstbyte == 0xfa) {               float flt = BitConverter.ToSingle(                 BitConverter.GetBytes((int)unchecked((int)uadditional))'                 0);               return new CBORObject(                 CBORObjectTypeSingle'                 flt);             }             if (firstbyte == 0xfb) {               double flt = BitConverter.ToDouble(                 BitConverter.GetBytes((long)uadditional)'                 0);               return new CBORObject(                 CBORObjectTypeDouble'                 flt);             }             if (firstbyte == 0xf8) {               if ((int)uadditional < 32) {                 throw new CBORException("Invalid overlong simple value");               }               return new CBORObject(                 CBORObjectTypeSimpleValue'                 (int)uadditional);             }             throw new CBORException("Unexpected data encountered");           default: throw new CBORException("Unexpected data encountered");         }       }
Magic Number,PeterO.Cbor,CBORObject,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORObject.cs,GetFixedLengthObject,The following statement contains a magic number: if ((firstbyte & 0x1c) == 0x18) {         // contains 1 to 8 extra bytes of additional information         long uadditional = 0;         switch (firstbyte & 0x1f) {           case 24:             uadditional = (int)(data[1] & (int)0xff);             break;           case 25:             uadditional = ((long)(data[1] & (long)0xff)) << 8;             uadditional |= (long)(data[2] & (long)0xff);             break;           case 26:             uadditional = ((long)(data[1] & (long)0xff)) << 24;             uadditional |= ((long)(data[2] & (long)0xff)) << 16;             uadditional |= ((long)(data[3] & (long)0xff)) << 8;             uadditional |= (long)(data[4] & (long)0xff);             break;           case 27:             uadditional = ((long)(data[1] & (long)0xff)) << 56;             uadditional |= ((long)(data[2] & (long)0xff)) << 48;             uadditional |= ((long)(data[3] & (long)0xff)) << 40;             uadditional |= ((long)(data[4] & (long)0xff)) << 32;             uadditional |= ((long)(data[5] & (long)0xff)) << 24;             uadditional |= ((long)(data[6] & (long)0xff)) << 16;             uadditional |= ((long)(data[7] & (long)0xff)) << 8;             uadditional |= (long)(data[8] & (long)0xff);             break;           default:             throw new CBORException("Unexpected data encountered");         }         switch (majortype) {           case 0:             if ((uadditional >> 63) == 0) {               // use only if additional's top bit isn't set               // (additional is a signed long)               return new CBORObject(CBORObjectTypeInteger' uadditional);             } else {               int low = unchecked((int)((uadditional) & 0xffffffffL));               int high = unchecked((int)((uadditional >> 32) & 0xffffffffL));               return FromObject(LowHighToEInteger(low' high));             }           case 1:             if ((uadditional >> 63) == 0) {               // use only if additional's top bit isn't set               // (additional is a signed long)               return new CBORObject(CBORObjectTypeInteger' -1 - uadditional);             } else {               int low = unchecked((int)((uadditional) & 0xffffffffL));               int high = unchecked((int)((uadditional >> 32) & 0xffffffffL));               EInteger bigintAdditional = LowHighToEInteger(low' high);               EInteger minusOne = -EInteger.One;               bigintAdditional = minusOne - (EInteger)bigintAdditional;               return FromObject(bigintAdditional);             }           case 7:             if (firstbyte == 0xf9) {               return new CBORObject(                 CBORObjectTypeSingle'              CBORUtilities.HalfPrecisionToSingle(unchecked((int)uadditional)));             }             if (firstbyte == 0xfa) {               float flt = BitConverter.ToSingle(                 BitConverter.GetBytes((int)unchecked((int)uadditional))'                 0);               return new CBORObject(                 CBORObjectTypeSingle'                 flt);             }             if (firstbyte == 0xfb) {               double flt = BitConverter.ToDouble(                 BitConverter.GetBytes((long)uadditional)'                 0);               return new CBORObject(                 CBORObjectTypeDouble'                 flt);             }             if (firstbyte == 0xf8) {               if ((int)uadditional < 32) {                 throw new CBORException("Invalid overlong simple value");               }               return new CBORObject(                 CBORObjectTypeSimpleValue'                 (int)uadditional);             }             throw new CBORException("Unexpected data encountered");           default: throw new CBORException("Unexpected data encountered");         }       }
Magic Number,PeterO.Cbor,CBORObject,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORObject.cs,GetFixedLengthObject,The following statement contains a magic number: if ((firstbyte & 0x1c) == 0x18) {         // contains 1 to 8 extra bytes of additional information         long uadditional = 0;         switch (firstbyte & 0x1f) {           case 24:             uadditional = (int)(data[1] & (int)0xff);             break;           case 25:             uadditional = ((long)(data[1] & (long)0xff)) << 8;             uadditional |= (long)(data[2] & (long)0xff);             break;           case 26:             uadditional = ((long)(data[1] & (long)0xff)) << 24;             uadditional |= ((long)(data[2] & (long)0xff)) << 16;             uadditional |= ((long)(data[3] & (long)0xff)) << 8;             uadditional |= (long)(data[4] & (long)0xff);             break;           case 27:             uadditional = ((long)(data[1] & (long)0xff)) << 56;             uadditional |= ((long)(data[2] & (long)0xff)) << 48;             uadditional |= ((long)(data[3] & (long)0xff)) << 40;             uadditional |= ((long)(data[4] & (long)0xff)) << 32;             uadditional |= ((long)(data[5] & (long)0xff)) << 24;             uadditional |= ((long)(data[6] & (long)0xff)) << 16;             uadditional |= ((long)(data[7] & (long)0xff)) << 8;             uadditional |= (long)(data[8] & (long)0xff);             break;           default:             throw new CBORException("Unexpected data encountered");         }         switch (majortype) {           case 0:             if ((uadditional >> 63) == 0) {               // use only if additional's top bit isn't set               // (additional is a signed long)               return new CBORObject(CBORObjectTypeInteger' uadditional);             } else {               int low = unchecked((int)((uadditional) & 0xffffffffL));               int high = unchecked((int)((uadditional >> 32) & 0xffffffffL));               return FromObject(LowHighToEInteger(low' high));             }           case 1:             if ((uadditional >> 63) == 0) {               // use only if additional's top bit isn't set               // (additional is a signed long)               return new CBORObject(CBORObjectTypeInteger' -1 - uadditional);             } else {               int low = unchecked((int)((uadditional) & 0xffffffffL));               int high = unchecked((int)((uadditional >> 32) & 0xffffffffL));               EInteger bigintAdditional = LowHighToEInteger(low' high);               EInteger minusOne = -EInteger.One;               bigintAdditional = minusOne - (EInteger)bigintAdditional;               return FromObject(bigintAdditional);             }           case 7:             if (firstbyte == 0xf9) {               return new CBORObject(                 CBORObjectTypeSingle'              CBORUtilities.HalfPrecisionToSingle(unchecked((int)uadditional)));             }             if (firstbyte == 0xfa) {               float flt = BitConverter.ToSingle(                 BitConverter.GetBytes((int)unchecked((int)uadditional))'                 0);               return new CBORObject(                 CBORObjectTypeSingle'                 flt);             }             if (firstbyte == 0xfb) {               double flt = BitConverter.ToDouble(                 BitConverter.GetBytes((long)uadditional)'                 0);               return new CBORObject(                 CBORObjectTypeDouble'                 flt);             }             if (firstbyte == 0xf8) {               if ((int)uadditional < 32) {                 throw new CBORException("Invalid overlong simple value");               }               return new CBORObject(                 CBORObjectTypeSimpleValue'                 (int)uadditional);             }             throw new CBORException("Unexpected data encountered");           default: throw new CBORException("Unexpected data encountered");         }       }
Magic Number,PeterO.Cbor,CBORObject,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORObject.cs,GetFixedLengthObject,The following statement contains a magic number: if ((firstbyte & 0x1c) == 0x18) {         // contains 1 to 8 extra bytes of additional information         long uadditional = 0;         switch (firstbyte & 0x1f) {           case 24:             uadditional = (int)(data[1] & (int)0xff);             break;           case 25:             uadditional = ((long)(data[1] & (long)0xff)) << 8;             uadditional |= (long)(data[2] & (long)0xff);             break;           case 26:             uadditional = ((long)(data[1] & (long)0xff)) << 24;             uadditional |= ((long)(data[2] & (long)0xff)) << 16;             uadditional |= ((long)(data[3] & (long)0xff)) << 8;             uadditional |= (long)(data[4] & (long)0xff);             break;           case 27:             uadditional = ((long)(data[1] & (long)0xff)) << 56;             uadditional |= ((long)(data[2] & (long)0xff)) << 48;             uadditional |= ((long)(data[3] & (long)0xff)) << 40;             uadditional |= ((long)(data[4] & (long)0xff)) << 32;             uadditional |= ((long)(data[5] & (long)0xff)) << 24;             uadditional |= ((long)(data[6] & (long)0xff)) << 16;             uadditional |= ((long)(data[7] & (long)0xff)) << 8;             uadditional |= (long)(data[8] & (long)0xff);             break;           default:             throw new CBORException("Unexpected data encountered");         }         switch (majortype) {           case 0:             if ((uadditional >> 63) == 0) {               // use only if additional's top bit isn't set               // (additional is a signed long)               return new CBORObject(CBORObjectTypeInteger' uadditional);             } else {               int low = unchecked((int)((uadditional) & 0xffffffffL));               int high = unchecked((int)((uadditional >> 32) & 0xffffffffL));               return FromObject(LowHighToEInteger(low' high));             }           case 1:             if ((uadditional >> 63) == 0) {               // use only if additional's top bit isn't set               // (additional is a signed long)               return new CBORObject(CBORObjectTypeInteger' -1 - uadditional);             } else {               int low = unchecked((int)((uadditional) & 0xffffffffL));               int high = unchecked((int)((uadditional >> 32) & 0xffffffffL));               EInteger bigintAdditional = LowHighToEInteger(low' high);               EInteger minusOne = -EInteger.One;               bigintAdditional = minusOne - (EInteger)bigintAdditional;               return FromObject(bigintAdditional);             }           case 7:             if (firstbyte == 0xf9) {               return new CBORObject(                 CBORObjectTypeSingle'              CBORUtilities.HalfPrecisionToSingle(unchecked((int)uadditional)));             }             if (firstbyte == 0xfa) {               float flt = BitConverter.ToSingle(                 BitConverter.GetBytes((int)unchecked((int)uadditional))'                 0);               return new CBORObject(                 CBORObjectTypeSingle'                 flt);             }             if (firstbyte == 0xfb) {               double flt = BitConverter.ToDouble(                 BitConverter.GetBytes((long)uadditional)'                 0);               return new CBORObject(                 CBORObjectTypeDouble'                 flt);             }             if (firstbyte == 0xf8) {               if ((int)uadditional < 32) {                 throw new CBORException("Invalid overlong simple value");               }               return new CBORObject(                 CBORObjectTypeSimpleValue'                 (int)uadditional);             }             throw new CBORException("Unexpected data encountered");           default: throw new CBORException("Unexpected data encountered");         }       }
Magic Number,PeterO.Cbor,CBORObject,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORObject.cs,GetFixedLengthObject,The following statement contains a magic number: if ((firstbyte & 0x1c) == 0x18) {         // contains 1 to 8 extra bytes of additional information         long uadditional = 0;         switch (firstbyte & 0x1f) {           case 24:             uadditional = (int)(data[1] & (int)0xff);             break;           case 25:             uadditional = ((long)(data[1] & (long)0xff)) << 8;             uadditional |= (long)(data[2] & (long)0xff);             break;           case 26:             uadditional = ((long)(data[1] & (long)0xff)) << 24;             uadditional |= ((long)(data[2] & (long)0xff)) << 16;             uadditional |= ((long)(data[3] & (long)0xff)) << 8;             uadditional |= (long)(data[4] & (long)0xff);             break;           case 27:             uadditional = ((long)(data[1] & (long)0xff)) << 56;             uadditional |= ((long)(data[2] & (long)0xff)) << 48;             uadditional |= ((long)(data[3] & (long)0xff)) << 40;             uadditional |= ((long)(data[4] & (long)0xff)) << 32;             uadditional |= ((long)(data[5] & (long)0xff)) << 24;             uadditional |= ((long)(data[6] & (long)0xff)) << 16;             uadditional |= ((long)(data[7] & (long)0xff)) << 8;             uadditional |= (long)(data[8] & (long)0xff);             break;           default:             throw new CBORException("Unexpected data encountered");         }         switch (majortype) {           case 0:             if ((uadditional >> 63) == 0) {               // use only if additional's top bit isn't set               // (additional is a signed long)               return new CBORObject(CBORObjectTypeInteger' uadditional);             } else {               int low = unchecked((int)((uadditional) & 0xffffffffL));               int high = unchecked((int)((uadditional >> 32) & 0xffffffffL));               return FromObject(LowHighToEInteger(low' high));             }           case 1:             if ((uadditional >> 63) == 0) {               // use only if additional's top bit isn't set               // (additional is a signed long)               return new CBORObject(CBORObjectTypeInteger' -1 - uadditional);             } else {               int low = unchecked((int)((uadditional) & 0xffffffffL));               int high = unchecked((int)((uadditional >> 32) & 0xffffffffL));               EInteger bigintAdditional = LowHighToEInteger(low' high);               EInteger minusOne = -EInteger.One;               bigintAdditional = minusOne - (EInteger)bigintAdditional;               return FromObject(bigintAdditional);             }           case 7:             if (firstbyte == 0xf9) {               return new CBORObject(                 CBORObjectTypeSingle'              CBORUtilities.HalfPrecisionToSingle(unchecked((int)uadditional)));             }             if (firstbyte == 0xfa) {               float flt = BitConverter.ToSingle(                 BitConverter.GetBytes((int)unchecked((int)uadditional))'                 0);               return new CBORObject(                 CBORObjectTypeSingle'                 flt);             }             if (firstbyte == 0xfb) {               double flt = BitConverter.ToDouble(                 BitConverter.GetBytes((long)uadditional)'                 0);               return new CBORObject(                 CBORObjectTypeDouble'                 flt);             }             if (firstbyte == 0xf8) {               if ((int)uadditional < 32) {                 throw new CBORException("Invalid overlong simple value");               }               return new CBORObject(                 CBORObjectTypeSimpleValue'                 (int)uadditional);             }             throw new CBORException("Unexpected data encountered");           default: throw new CBORException("Unexpected data encountered");         }       }
Magic Number,PeterO.Cbor,CBORObject,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORObject.cs,GetFixedLengthObject,The following statement contains a magic number: if ((firstbyte & 0x1c) == 0x18) {         // contains 1 to 8 extra bytes of additional information         long uadditional = 0;         switch (firstbyte & 0x1f) {           case 24:             uadditional = (int)(data[1] & (int)0xff);             break;           case 25:             uadditional = ((long)(data[1] & (long)0xff)) << 8;             uadditional |= (long)(data[2] & (long)0xff);             break;           case 26:             uadditional = ((long)(data[1] & (long)0xff)) << 24;             uadditional |= ((long)(data[2] & (long)0xff)) << 16;             uadditional |= ((long)(data[3] & (long)0xff)) << 8;             uadditional |= (long)(data[4] & (long)0xff);             break;           case 27:             uadditional = ((long)(data[1] & (long)0xff)) << 56;             uadditional |= ((long)(data[2] & (long)0xff)) << 48;             uadditional |= ((long)(data[3] & (long)0xff)) << 40;             uadditional |= ((long)(data[4] & (long)0xff)) << 32;             uadditional |= ((long)(data[5] & (long)0xff)) << 24;             uadditional |= ((long)(data[6] & (long)0xff)) << 16;             uadditional |= ((long)(data[7] & (long)0xff)) << 8;             uadditional |= (long)(data[8] & (long)0xff);             break;           default:             throw new CBORException("Unexpected data encountered");         }         switch (majortype) {           case 0:             if ((uadditional >> 63) == 0) {               // use only if additional's top bit isn't set               // (additional is a signed long)               return new CBORObject(CBORObjectTypeInteger' uadditional);             } else {               int low = unchecked((int)((uadditional) & 0xffffffffL));               int high = unchecked((int)((uadditional >> 32) & 0xffffffffL));               return FromObject(LowHighToEInteger(low' high));             }           case 1:             if ((uadditional >> 63) == 0) {               // use only if additional's top bit isn't set               // (additional is a signed long)               return new CBORObject(CBORObjectTypeInteger' -1 - uadditional);             } else {               int low = unchecked((int)((uadditional) & 0xffffffffL));               int high = unchecked((int)((uadditional >> 32) & 0xffffffffL));               EInteger bigintAdditional = LowHighToEInteger(low' high);               EInteger minusOne = -EInteger.One;               bigintAdditional = minusOne - (EInteger)bigintAdditional;               return FromObject(bigintAdditional);             }           case 7:             if (firstbyte == 0xf9) {               return new CBORObject(                 CBORObjectTypeSingle'              CBORUtilities.HalfPrecisionToSingle(unchecked((int)uadditional)));             }             if (firstbyte == 0xfa) {               float flt = BitConverter.ToSingle(                 BitConverter.GetBytes((int)unchecked((int)uadditional))'                 0);               return new CBORObject(                 CBORObjectTypeSingle'                 flt);             }             if (firstbyte == 0xfb) {               double flt = BitConverter.ToDouble(                 BitConverter.GetBytes((long)uadditional)'                 0);               return new CBORObject(                 CBORObjectTypeDouble'                 flt);             }             if (firstbyte == 0xf8) {               if ((int)uadditional < 32) {                 throw new CBORException("Invalid overlong simple value");               }               return new CBORObject(                 CBORObjectTypeSimpleValue'                 (int)uadditional);             }             throw new CBORException("Unexpected data encountered");           default: throw new CBORException("Unexpected data encountered");         }       }
Magic Number,PeterO.Cbor,CBORObject,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORObject.cs,GetFixedLengthObject,The following statement contains a magic number: if ((firstbyte & 0x1c) == 0x18) {         // contains 1 to 8 extra bytes of additional information         long uadditional = 0;         switch (firstbyte & 0x1f) {           case 24:             uadditional = (int)(data[1] & (int)0xff);             break;           case 25:             uadditional = ((long)(data[1] & (long)0xff)) << 8;             uadditional |= (long)(data[2] & (long)0xff);             break;           case 26:             uadditional = ((long)(data[1] & (long)0xff)) << 24;             uadditional |= ((long)(data[2] & (long)0xff)) << 16;             uadditional |= ((long)(data[3] & (long)0xff)) << 8;             uadditional |= (long)(data[4] & (long)0xff);             break;           case 27:             uadditional = ((long)(data[1] & (long)0xff)) << 56;             uadditional |= ((long)(data[2] & (long)0xff)) << 48;             uadditional |= ((long)(data[3] & (long)0xff)) << 40;             uadditional |= ((long)(data[4] & (long)0xff)) << 32;             uadditional |= ((long)(data[5] & (long)0xff)) << 24;             uadditional |= ((long)(data[6] & (long)0xff)) << 16;             uadditional |= ((long)(data[7] & (long)0xff)) << 8;             uadditional |= (long)(data[8] & (long)0xff);             break;           default:             throw new CBORException("Unexpected data encountered");         }         switch (majortype) {           case 0:             if ((uadditional >> 63) == 0) {               // use only if additional's top bit isn't set               // (additional is a signed long)               return new CBORObject(CBORObjectTypeInteger' uadditional);             } else {               int low = unchecked((int)((uadditional) & 0xffffffffL));               int high = unchecked((int)((uadditional >> 32) & 0xffffffffL));               return FromObject(LowHighToEInteger(low' high));             }           case 1:             if ((uadditional >> 63) == 0) {               // use only if additional's top bit isn't set               // (additional is a signed long)               return new CBORObject(CBORObjectTypeInteger' -1 - uadditional);             } else {               int low = unchecked((int)((uadditional) & 0xffffffffL));               int high = unchecked((int)((uadditional >> 32) & 0xffffffffL));               EInteger bigintAdditional = LowHighToEInteger(low' high);               EInteger minusOne = -EInteger.One;               bigintAdditional = minusOne - (EInteger)bigintAdditional;               return FromObject(bigintAdditional);             }           case 7:             if (firstbyte == 0xf9) {               return new CBORObject(                 CBORObjectTypeSingle'              CBORUtilities.HalfPrecisionToSingle(unchecked((int)uadditional)));             }             if (firstbyte == 0xfa) {               float flt = BitConverter.ToSingle(                 BitConverter.GetBytes((int)unchecked((int)uadditional))'                 0);               return new CBORObject(                 CBORObjectTypeSingle'                 flt);             }             if (firstbyte == 0xfb) {               double flt = BitConverter.ToDouble(                 BitConverter.GetBytes((long)uadditional)'                 0);               return new CBORObject(                 CBORObjectTypeDouble'                 flt);             }             if (firstbyte == 0xf8) {               if ((int)uadditional < 32) {                 throw new CBORException("Invalid overlong simple value");               }               return new CBORObject(                 CBORObjectTypeSimpleValue'                 (int)uadditional);             }             throw new CBORException("Unexpected data encountered");           default: throw new CBORException("Unexpected data encountered");         }       }
Magic Number,PeterO.Cbor,CBORObject,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORObject.cs,GetFixedLengthObject,The following statement contains a magic number: if ((firstbyte & 0x1c) == 0x18) {         // contains 1 to 8 extra bytes of additional information         long uadditional = 0;         switch (firstbyte & 0x1f) {           case 24:             uadditional = (int)(data[1] & (int)0xff);             break;           case 25:             uadditional = ((long)(data[1] & (long)0xff)) << 8;             uadditional |= (long)(data[2] & (long)0xff);             break;           case 26:             uadditional = ((long)(data[1] & (long)0xff)) << 24;             uadditional |= ((long)(data[2] & (long)0xff)) << 16;             uadditional |= ((long)(data[3] & (long)0xff)) << 8;             uadditional |= (long)(data[4] & (long)0xff);             break;           case 27:             uadditional = ((long)(data[1] & (long)0xff)) << 56;             uadditional |= ((long)(data[2] & (long)0xff)) << 48;             uadditional |= ((long)(data[3] & (long)0xff)) << 40;             uadditional |= ((long)(data[4] & (long)0xff)) << 32;             uadditional |= ((long)(data[5] & (long)0xff)) << 24;             uadditional |= ((long)(data[6] & (long)0xff)) << 16;             uadditional |= ((long)(data[7] & (long)0xff)) << 8;             uadditional |= (long)(data[8] & (long)0xff);             break;           default:             throw new CBORException("Unexpected data encountered");         }         switch (majortype) {           case 0:             if ((uadditional >> 63) == 0) {               // use only if additional's top bit isn't set               // (additional is a signed long)               return new CBORObject(CBORObjectTypeInteger' uadditional);             } else {               int low = unchecked((int)((uadditional) & 0xffffffffL));               int high = unchecked((int)((uadditional >> 32) & 0xffffffffL));               return FromObject(LowHighToEInteger(low' high));             }           case 1:             if ((uadditional >> 63) == 0) {               // use only if additional's top bit isn't set               // (additional is a signed long)               return new CBORObject(CBORObjectTypeInteger' -1 - uadditional);             } else {               int low = unchecked((int)((uadditional) & 0xffffffffL));               int high = unchecked((int)((uadditional >> 32) & 0xffffffffL));               EInteger bigintAdditional = LowHighToEInteger(low' high);               EInteger minusOne = -EInteger.One;               bigintAdditional = minusOne - (EInteger)bigintAdditional;               return FromObject(bigintAdditional);             }           case 7:             if (firstbyte == 0xf9) {               return new CBORObject(                 CBORObjectTypeSingle'              CBORUtilities.HalfPrecisionToSingle(unchecked((int)uadditional)));             }             if (firstbyte == 0xfa) {               float flt = BitConverter.ToSingle(                 BitConverter.GetBytes((int)unchecked((int)uadditional))'                 0);               return new CBORObject(                 CBORObjectTypeSingle'                 flt);             }             if (firstbyte == 0xfb) {               double flt = BitConverter.ToDouble(                 BitConverter.GetBytes((long)uadditional)'                 0);               return new CBORObject(                 CBORObjectTypeDouble'                 flt);             }             if (firstbyte == 0xf8) {               if ((int)uadditional < 32) {                 throw new CBORException("Invalid overlong simple value");               }               return new CBORObject(                 CBORObjectTypeSimpleValue'                 (int)uadditional);             }             throw new CBORException("Unexpected data encountered");           default: throw new CBORException("Unexpected data encountered");         }       }
Magic Number,PeterO.Cbor,CBORObject,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORObject.cs,GetFixedLengthObject,The following statement contains a magic number: if (majortype == 2) {  // short byte string         var ret = new byte[firstbyte - 0x40];         Array.Copy(data' 1' ret' 0' firstbyte - 0x40);         return new CBORObject(CBORObjectTypeByteString' ret);       }
Magic Number,PeterO.Cbor,CBORObject,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORObject.cs,GetFixedLengthObject,The following statement contains a magic number: if (majortype == 3) {  // short text string         var ret = new StringBuilder(firstbyte - 0x60);         DataUtilities.ReadUtf8FromBytes(data' 1' firstbyte - 0x60' ret' false);         return new CBORObject(CBORObjectTypeTextString' ret.ToString());       }
Magic Number,PeterO.Cbor,CBORObject,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORObject.cs,TrimDotZero,The following statement contains a magic number: return (str.Length > 2 && str[str.Length - 1] == '0' && str[str.Length                     - 2] == '.') ? str.Substring(0' str.Length - 2) :         str;
Magic Number,PeterO.Cbor,CBORObject,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORObject.cs,TrimDotZero,The following statement contains a magic number: return (str.Length > 2 && str[str.Length - 1] == '0' && str[str.Length                     - 2] == '.') ? str.Substring(0' str.Length - 2) :         str;
Magic Number,PeterO.Cbor,CBORObject,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORObject.cs,TrimDotZero,The following statement contains a magic number: return (str.Length > 2 && str[str.Length - 1] == '0' && str[str.Length                     - 2] == '.') ? str.Substring(0' str.Length - 2) :         str;
Magic Number,PeterO.Cbor,CBORObject,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORObject.cs,BigIntFits,The following statement contains a magic number: return bigint.GetSignedBitLength() <= 64;
Magic Number,PeterO.Cbor,CBORObject,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORObject.cs,CBORArrayHashCode,The following statement contains a magic number: var ret = 19;
Magic Number,PeterO.Cbor,CBORObject,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORObject.cs,CBORArrayHashCode,The following statement contains a magic number: unchecked {         ret = (ret * 31) + count;         for (var i = 0; i < count; ++i) {           ret = (ret * 31) + list[i].GetHashCode();         }       }
Magic Number,PeterO.Cbor,CBORObject,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORObject.cs,CBORArrayHashCode,The following statement contains a magic number: unchecked {         ret = (ret * 31) + count;         for (var i = 0; i < count; ++i) {           ret = (ret * 31) + list[i].GetHashCode();         }       }
Magic Number,PeterO.Cbor,CBORObject,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORObject.cs,StringHashCode,The following statement contains a magic number: var ret = 19;
Magic Number,PeterO.Cbor,CBORObject,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORObject.cs,StringHashCode,The following statement contains a magic number: unchecked {         ret = (ret * 31) + count;         for (var i = 0; i < count; ++i) {           ret = (ret * 31) + (int)str[i];         }       }
Magic Number,PeterO.Cbor,CBORObject,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORObject.cs,StringHashCode,The following statement contains a magic number: unchecked {         ret = (ret * 31) + count;         for (var i = 0; i < count; ++i) {           ret = (ret * 31) + (int)str[i];         }       }
Magic Number,PeterO.Cbor,CBORObject,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORObject.cs,CBORMapHashCode,The following statement contains a magic number: return unchecked(a.Count.GetHashCode() * 19);
Magic Number,PeterO.Cbor,CBORObject,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORObject.cs,ExtendedToString,The following statement contains a magic number: if (ef.IsFinite && (ef.Exponent.CompareTo((EInteger)2500) > 0 ||                     ef.Exponent.CompareTo((EInteger)(-2500)) < 0)) {         // It can take very long to convert a number with a very high         // or very low exponent to a decimal string' so do this instead         return ef.Mantissa + "p" + ef.Exponent;       }
Magic Number,PeterO.Cbor,CBORObject,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORObject.cs,ExtendedToString,The following statement contains a magic number: if (ef.IsFinite && (ef.Exponent.CompareTo((EInteger)2500) > 0 ||                     ef.Exponent.CompareTo((EInteger)(-2500)) < 0)) {         // It can take very long to convert a number with a very high         // or very low exponent to a decimal string' so do this instead         return ef.Mantissa + "p" + ef.Exponent;       }
Magic Number,PeterO.Cbor,CBORObject,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORObject.cs,GetOptimizedBytesIfShortAscii,The following statement contains a magic number: if (str.Length <= 255) {         // The strings will usually be short ASCII strings' so         // use this optimization         var offset = 0;         int length = str.Length;         int extra = (length < 24) ? 1 : 2;         if (tagbyteInt >= 0) {           ++extra;         }         bytes = new byte[length + extra];         if (tagbyteInt >= 0) {           bytes[offset] = (byte)tagbyteInt;           ++offset;         }         if (length < 24) {           bytes[offset] = (byte)(0x60 + str.Length);           ++offset;         } else {           bytes[offset] = (byte)0x78;           bytes[offset + 1] = (byte)str.Length;           offset += 2;         }         var issimple = true;         for (var i = 0; i < str.Length; ++i) {           char c = str[i];           if (c >= 0x80) {             issimple = false;             break;           }           bytes[i + offset] = unchecked((byte)c);         }         if (issimple) {           return bytes;         }       }
Magic Number,PeterO.Cbor,CBORObject,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORObject.cs,GetOptimizedBytesIfShortAscii,The following statement contains a magic number: if (str.Length <= 255) {         // The strings will usually be short ASCII strings' so         // use this optimization         var offset = 0;         int length = str.Length;         int extra = (length < 24) ? 1 : 2;         if (tagbyteInt >= 0) {           ++extra;         }         bytes = new byte[length + extra];         if (tagbyteInt >= 0) {           bytes[offset] = (byte)tagbyteInt;           ++offset;         }         if (length < 24) {           bytes[offset] = (byte)(0x60 + str.Length);           ++offset;         } else {           bytes[offset] = (byte)0x78;           bytes[offset + 1] = (byte)str.Length;           offset += 2;         }         var issimple = true;         for (var i = 0; i < str.Length; ++i) {           char c = str[i];           if (c >= 0x80) {             issimple = false;             break;           }           bytes[i + offset] = unchecked((byte)c);         }         if (issimple) {           return bytes;         }       }
Magic Number,PeterO.Cbor,CBORObject,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORObject.cs,GetOptimizedBytesIfShortAscii,The following statement contains a magic number: if (str.Length <= 255) {         // The strings will usually be short ASCII strings' so         // use this optimization         var offset = 0;         int length = str.Length;         int extra = (length < 24) ? 1 : 2;         if (tagbyteInt >= 0) {           ++extra;         }         bytes = new byte[length + extra];         if (tagbyteInt >= 0) {           bytes[offset] = (byte)tagbyteInt;           ++offset;         }         if (length < 24) {           bytes[offset] = (byte)(0x60 + str.Length);           ++offset;         } else {           bytes[offset] = (byte)0x78;           bytes[offset + 1] = (byte)str.Length;           offset += 2;         }         var issimple = true;         for (var i = 0; i < str.Length; ++i) {           char c = str[i];           if (c >= 0x80) {             issimple = false;             break;           }           bytes[i + offset] = unchecked((byte)c);         }         if (issimple) {           return bytes;         }       }
Magic Number,PeterO.Cbor,CBORObject,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORObject.cs,GetOptimizedBytesIfShortAscii,The following statement contains a magic number: if (str.Length <= 255) {         // The strings will usually be short ASCII strings' so         // use this optimization         var offset = 0;         int length = str.Length;         int extra = (length < 24) ? 1 : 2;         if (tagbyteInt >= 0) {           ++extra;         }         bytes = new byte[length + extra];         if (tagbyteInt >= 0) {           bytes[offset] = (byte)tagbyteInt;           ++offset;         }         if (length < 24) {           bytes[offset] = (byte)(0x60 + str.Length);           ++offset;         } else {           bytes[offset] = (byte)0x78;           bytes[offset + 1] = (byte)str.Length;           offset += 2;         }         var issimple = true;         for (var i = 0; i < str.Length; ++i) {           char c = str[i];           if (c >= 0x80) {             issimple = false;             break;           }           bytes[i + offset] = unchecked((byte)c);         }         if (issimple) {           return bytes;         }       }
Magic Number,PeterO.Cbor,CBORObject,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORObject.cs,GetOptimizedBytesIfShortAscii,The following statement contains a magic number: if (str.Length <= 255) {         // The strings will usually be short ASCII strings' so         // use this optimization         var offset = 0;         int length = str.Length;         int extra = (length < 24) ? 1 : 2;         if (tagbyteInt >= 0) {           ++extra;         }         bytes = new byte[length + extra];         if (tagbyteInt >= 0) {           bytes[offset] = (byte)tagbyteInt;           ++offset;         }         if (length < 24) {           bytes[offset] = (byte)(0x60 + str.Length);           ++offset;         } else {           bytes[offset] = (byte)0x78;           bytes[offset + 1] = (byte)str.Length;           offset += 2;         }         var issimple = true;         for (var i = 0; i < str.Length; ++i) {           char c = str[i];           if (c >= 0x80) {             issimple = false;             break;           }           bytes[i + offset] = unchecked((byte)c);         }         if (issimple) {           return bytes;         }       }
Magic Number,PeterO.Cbor,CBORObject,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORObject.cs,GetPositiveInt64Bytes,The following statement contains a magic number: if (value < 24) {         return new[] { (byte)((byte)value | (byte)(type << 5)) };       }
Magic Number,PeterO.Cbor,CBORObject,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORObject.cs,GetPositiveInt64Bytes,The following statement contains a magic number: if (value < 24) {         return new[] { (byte)((byte)value | (byte)(type << 5)) };       }
Magic Number,PeterO.Cbor,CBORObject,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORObject.cs,GetPositiveInt64Bytes,The following statement contains a magic number: if (value <= 0xffL) {         return new[] { (byte)(24 | (type << 5))' (byte)(value & 0xff)         };       }
Magic Number,PeterO.Cbor,CBORObject,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORObject.cs,GetPositiveInt64Bytes,The following statement contains a magic number: if (value <= 0xffL) {         return new[] { (byte)(24 | (type << 5))' (byte)(value & 0xff)         };       }
Magic Number,PeterO.Cbor,CBORObject,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORObject.cs,GetPositiveInt64Bytes,The following statement contains a magic number: if (value <= 0xffffL) {         return new[] { (byte)(25 | (type << 5))'           (byte)((value >> 8) & 0xff)' (byte)(value & 0xff)         };       }
Magic Number,PeterO.Cbor,CBORObject,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORObject.cs,GetPositiveInt64Bytes,The following statement contains a magic number: if (value <= 0xffffL) {         return new[] { (byte)(25 | (type << 5))'           (byte)((value >> 8) & 0xff)' (byte)(value & 0xff)         };       }
Magic Number,PeterO.Cbor,CBORObject,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORObject.cs,GetPositiveInt64Bytes,The following statement contains a magic number: if (value <= 0xffffL) {         return new[] { (byte)(25 | (type << 5))'           (byte)((value >> 8) & 0xff)' (byte)(value & 0xff)         };       }
Magic Number,PeterO.Cbor,CBORObject,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORObject.cs,GetPositiveInt64Bytes,The following statement contains a magic number: if (value <= 0xffffffffL) {         return new[] { (byte)(26 | (type << 5))'           (byte)((value >> 24) & 0xff)' (byte)((value >> 16) & 0xff)'           (byte)((value >> 8) & 0xff)' (byte)(value & 0xff)         };       }
Magic Number,PeterO.Cbor,CBORObject,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORObject.cs,GetPositiveInt64Bytes,The following statement contains a magic number: if (value <= 0xffffffffL) {         return new[] { (byte)(26 | (type << 5))'           (byte)((value >> 24) & 0xff)' (byte)((value >> 16) & 0xff)'           (byte)((value >> 8) & 0xff)' (byte)(value & 0xff)         };       }
Magic Number,PeterO.Cbor,CBORObject,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORObject.cs,GetPositiveInt64Bytes,The following statement contains a magic number: if (value <= 0xffffffffL) {         return new[] { (byte)(26 | (type << 5))'           (byte)((value >> 24) & 0xff)' (byte)((value >> 16) & 0xff)'           (byte)((value >> 8) & 0xff)' (byte)(value & 0xff)         };       }
Magic Number,PeterO.Cbor,CBORObject,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORObject.cs,GetPositiveInt64Bytes,The following statement contains a magic number: if (value <= 0xffffffffL) {         return new[] { (byte)(26 | (type << 5))'           (byte)((value >> 24) & 0xff)' (byte)((value >> 16) & 0xff)'           (byte)((value >> 8) & 0xff)' (byte)(value & 0xff)         };       }
Magic Number,PeterO.Cbor,CBORObject,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORObject.cs,GetPositiveInt64Bytes,The following statement contains a magic number: if (value <= 0xffffffffL) {         return new[] { (byte)(26 | (type << 5))'           (byte)((value >> 24) & 0xff)' (byte)((value >> 16) & 0xff)'           (byte)((value >> 8) & 0xff)' (byte)(value & 0xff)         };       }
Magic Number,PeterO.Cbor,CBORObject,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORObject.cs,GetPositiveInt64Bytes,The following statement contains a magic number: return new[] { (byte)(27 | (type << 5))' (byte)((value >> 56) & 0xff)'         (byte)((value >> 48) & 0xff)' (byte)((value >> 40) & 0xff)'         (byte)((value >> 32) & 0xff)' (byte)((value >> 24) & 0xff)'         (byte)((value >> 16) & 0xff)' (byte)((value >> 8) & 0xff)'         (byte)(value & 0xff) };
Magic Number,PeterO.Cbor,CBORObject,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORObject.cs,GetPositiveInt64Bytes,The following statement contains a magic number: return new[] { (byte)(27 | (type << 5))' (byte)((value >> 56) & 0xff)'         (byte)((value >> 48) & 0xff)' (byte)((value >> 40) & 0xff)'         (byte)((value >> 32) & 0xff)' (byte)((value >> 24) & 0xff)'         (byte)((value >> 16) & 0xff)' (byte)((value >> 8) & 0xff)'         (byte)(value & 0xff) };
Magic Number,PeterO.Cbor,CBORObject,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORObject.cs,GetPositiveInt64Bytes,The following statement contains a magic number: return new[] { (byte)(27 | (type << 5))' (byte)((value >> 56) & 0xff)'         (byte)((value >> 48) & 0xff)' (byte)((value >> 40) & 0xff)'         (byte)((value >> 32) & 0xff)' (byte)((value >> 24) & 0xff)'         (byte)((value >> 16) & 0xff)' (byte)((value >> 8) & 0xff)'         (byte)(value & 0xff) };
Magic Number,PeterO.Cbor,CBORObject,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORObject.cs,GetPositiveInt64Bytes,The following statement contains a magic number: return new[] { (byte)(27 | (type << 5))' (byte)((value >> 56) & 0xff)'         (byte)((value >> 48) & 0xff)' (byte)((value >> 40) & 0xff)'         (byte)((value >> 32) & 0xff)' (byte)((value >> 24) & 0xff)'         (byte)((value >> 16) & 0xff)' (byte)((value >> 8) & 0xff)'         (byte)(value & 0xff) };
Magic Number,PeterO.Cbor,CBORObject,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORObject.cs,GetPositiveInt64Bytes,The following statement contains a magic number: return new[] { (byte)(27 | (type << 5))' (byte)((value >> 56) & 0xff)'         (byte)((value >> 48) & 0xff)' (byte)((value >> 40) & 0xff)'         (byte)((value >> 32) & 0xff)' (byte)((value >> 24) & 0xff)'         (byte)((value >> 16) & 0xff)' (byte)((value >> 8) & 0xff)'         (byte)(value & 0xff) };
Magic Number,PeterO.Cbor,CBORObject,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORObject.cs,GetPositiveInt64Bytes,The following statement contains a magic number: return new[] { (byte)(27 | (type << 5))' (byte)((value >> 56) & 0xff)'         (byte)((value >> 48) & 0xff)' (byte)((value >> 40) & 0xff)'         (byte)((value >> 32) & 0xff)' (byte)((value >> 24) & 0xff)'         (byte)((value >> 16) & 0xff)' (byte)((value >> 8) & 0xff)'         (byte)(value & 0xff) };
Magic Number,PeterO.Cbor,CBORObject,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORObject.cs,GetPositiveInt64Bytes,The following statement contains a magic number: return new[] { (byte)(27 | (type << 5))' (byte)((value >> 56) & 0xff)'         (byte)((value >> 48) & 0xff)' (byte)((value >> 40) & 0xff)'         (byte)((value >> 32) & 0xff)' (byte)((value >> 24) & 0xff)'         (byte)((value >> 16) & 0xff)' (byte)((value >> 8) & 0xff)'         (byte)(value & 0xff) };
Magic Number,PeterO.Cbor,CBORObject,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORObject.cs,GetPositiveInt64Bytes,The following statement contains a magic number: return new[] { (byte)(27 | (type << 5))' (byte)((value >> 56) & 0xff)'         (byte)((value >> 48) & 0xff)' (byte)((value >> 40) & 0xff)'         (byte)((value >> 32) & 0xff)' (byte)((value >> 24) & 0xff)'         (byte)((value >> 16) & 0xff)' (byte)((value >> 8) & 0xff)'         (byte)(value & 0xff) };
Magic Number,PeterO.Cbor,CBORObject,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORObject.cs,GetPositiveInt64Bytes,The following statement contains a magic number: return new[] { (byte)(27 | (type << 5))' (byte)((value >> 56) & 0xff)'         (byte)((value >> 48) & 0xff)' (byte)((value >> 40) & 0xff)'         (byte)((value >> 32) & 0xff)' (byte)((value >> 24) & 0xff)'         (byte)((value >> 16) & 0xff)' (byte)((value >> 8) & 0xff)'         (byte)(value & 0xff) };
Magic Number,PeterO.Cbor,CBORObject,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORObject.cs,GetPositiveIntBytes,The following statement contains a magic number: if (value < 24) {         return new[] { (byte)((byte)value | (byte)(type << 5)) };       }
Magic Number,PeterO.Cbor,CBORObject,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORObject.cs,GetPositiveIntBytes,The following statement contains a magic number: if (value < 24) {         return new[] { (byte)((byte)value | (byte)(type << 5)) };       }
Magic Number,PeterO.Cbor,CBORObject,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORObject.cs,GetPositiveIntBytes,The following statement contains a magic number: if (value <= 0xff) {         return new[] { (byte)(24 | (type << 5))' (byte)(value & 0xff)         };       }
Magic Number,PeterO.Cbor,CBORObject,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORObject.cs,GetPositiveIntBytes,The following statement contains a magic number: if (value <= 0xff) {         return new[] { (byte)(24 | (type << 5))' (byte)(value & 0xff)         };       }
Magic Number,PeterO.Cbor,CBORObject,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORObject.cs,GetPositiveIntBytes,The following statement contains a magic number: if (value <= 0xffff) {         return new[] { (byte)(25 | (type << 5))'           (byte)((value >> 8) & 0xff)' (byte)(value & 0xff)         };       }
Magic Number,PeterO.Cbor,CBORObject,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORObject.cs,GetPositiveIntBytes,The following statement contains a magic number: if (value <= 0xffff) {         return new[] { (byte)(25 | (type << 5))'           (byte)((value >> 8) & 0xff)' (byte)(value & 0xff)         };       }
Magic Number,PeterO.Cbor,CBORObject,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORObject.cs,GetPositiveIntBytes,The following statement contains a magic number: if (value <= 0xffff) {         return new[] { (byte)(25 | (type << 5))'           (byte)((value >> 8) & 0xff)' (byte)(value & 0xff)         };       }
Magic Number,PeterO.Cbor,CBORObject,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORObject.cs,GetPositiveIntBytes,The following statement contains a magic number: return new[] { (byte)(26 | (type << 5))' (byte)((value >> 24) & 0xff)'         (byte)((value >> 16) & 0xff)' (byte)((value >> 8) & 0xff)'         (byte)(value & 0xff) };
Magic Number,PeterO.Cbor,CBORObject,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORObject.cs,GetPositiveIntBytes,The following statement contains a magic number: return new[] { (byte)(26 | (type << 5))' (byte)((value >> 24) & 0xff)'         (byte)((value >> 16) & 0xff)' (byte)((value >> 8) & 0xff)'         (byte)(value & 0xff) };
Magic Number,PeterO.Cbor,CBORObject,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORObject.cs,GetPositiveIntBytes,The following statement contains a magic number: return new[] { (byte)(26 | (type << 5))' (byte)((value >> 24) & 0xff)'         (byte)((value >> 16) & 0xff)' (byte)((value >> 8) & 0xff)'         (byte)(value & 0xff) };
Magic Number,PeterO.Cbor,CBORObject,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORObject.cs,GetPositiveIntBytes,The following statement contains a magic number: return new[] { (byte)(26 | (type << 5))' (byte)((value >> 24) & 0xff)'         (byte)((value >> 16) & 0xff)' (byte)((value >> 8) & 0xff)'         (byte)(value & 0xff) };
Magic Number,PeterO.Cbor,CBORObject,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORObject.cs,GetPositiveIntBytes,The following statement contains a magic number: return new[] { (byte)(26 | (type << 5))' (byte)((value >> 24) & 0xff)'         (byte)((value >> 16) & 0xff)' (byte)((value >> 8) & 0xff)'         (byte)(value & 0xff) };
Magic Number,PeterO.Cbor,CBORObject,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORObject.cs,GetSignInternal,The following statement contains a magic number: return cn == null ? 2 : cn.Sign(obj);
Magic Number,PeterO.Cbor,CBORObject,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORObject.cs,InitializeFixedObjects,The following statement contains a magic number: valueFixedObjects = new CBORObject[256];
Magic Number,PeterO.Cbor,CBORObject,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORObject.cs,LowHighToEInteger,The following statement contains a magic number: if (tagHigh != 0) {         uabytes = new byte[9];         uabytes[7] = (byte)((tagHigh >> 24) & 0xff);         uabytes[6] = (byte)((tagHigh >> 16) & 0xff);         uabytes[5] = (byte)((tagHigh >> 8) & 0xff);         uabytes[4] = (byte)(tagHigh & 0xff);         uabytes[3] = (byte)((tagLow >> 24) & 0xff);         uabytes[2] = (byte)((tagLow >> 16) & 0xff);         uabytes[1] = (byte)((tagLow >> 8) & 0xff);         uabytes[0] = (byte)(tagLow & 0xff);         uabytes[8] = 0;         return EInteger.FromBytes(uabytes' true);       }
Magic Number,PeterO.Cbor,CBORObject,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORObject.cs,LowHighToEInteger,The following statement contains a magic number: if (tagHigh != 0) {         uabytes = new byte[9];         uabytes[7] = (byte)((tagHigh >> 24) & 0xff);         uabytes[6] = (byte)((tagHigh >> 16) & 0xff);         uabytes[5] = (byte)((tagHigh >> 8) & 0xff);         uabytes[4] = (byte)(tagHigh & 0xff);         uabytes[3] = (byte)((tagLow >> 24) & 0xff);         uabytes[2] = (byte)((tagLow >> 16) & 0xff);         uabytes[1] = (byte)((tagLow >> 8) & 0xff);         uabytes[0] = (byte)(tagLow & 0xff);         uabytes[8] = 0;         return EInteger.FromBytes(uabytes' true);       }
Magic Number,PeterO.Cbor,CBORObject,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORObject.cs,LowHighToEInteger,The following statement contains a magic number: if (tagHigh != 0) {         uabytes = new byte[9];         uabytes[7] = (byte)((tagHigh >> 24) & 0xff);         uabytes[6] = (byte)((tagHigh >> 16) & 0xff);         uabytes[5] = (byte)((tagHigh >> 8) & 0xff);         uabytes[4] = (byte)(tagHigh & 0xff);         uabytes[3] = (byte)((tagLow >> 24) & 0xff);         uabytes[2] = (byte)((tagLow >> 16) & 0xff);         uabytes[1] = (byte)((tagLow >> 8) & 0xff);         uabytes[0] = (byte)(tagLow & 0xff);         uabytes[8] = 0;         return EInteger.FromBytes(uabytes' true);       }
Magic Number,PeterO.Cbor,CBORObject,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORObject.cs,LowHighToEInteger,The following statement contains a magic number: if (tagHigh != 0) {         uabytes = new byte[9];         uabytes[7] = (byte)((tagHigh >> 24) & 0xff);         uabytes[6] = (byte)((tagHigh >> 16) & 0xff);         uabytes[5] = (byte)((tagHigh >> 8) & 0xff);         uabytes[4] = (byte)(tagHigh & 0xff);         uabytes[3] = (byte)((tagLow >> 24) & 0xff);         uabytes[2] = (byte)((tagLow >> 16) & 0xff);         uabytes[1] = (byte)((tagLow >> 8) & 0xff);         uabytes[0] = (byte)(tagLow & 0xff);         uabytes[8] = 0;         return EInteger.FromBytes(uabytes' true);       }
Magic Number,PeterO.Cbor,CBORObject,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORObject.cs,LowHighToEInteger,The following statement contains a magic number: if (tagHigh != 0) {         uabytes = new byte[9];         uabytes[7] = (byte)((tagHigh >> 24) & 0xff);         uabytes[6] = (byte)((tagHigh >> 16) & 0xff);         uabytes[5] = (byte)((tagHigh >> 8) & 0xff);         uabytes[4] = (byte)(tagHigh & 0xff);         uabytes[3] = (byte)((tagLow >> 24) & 0xff);         uabytes[2] = (byte)((tagLow >> 16) & 0xff);         uabytes[1] = (byte)((tagLow >> 8) & 0xff);         uabytes[0] = (byte)(tagLow & 0xff);         uabytes[8] = 0;         return EInteger.FromBytes(uabytes' true);       }
Magic Number,PeterO.Cbor,CBORObject,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORObject.cs,LowHighToEInteger,The following statement contains a magic number: if (tagHigh != 0) {         uabytes = new byte[9];         uabytes[7] = (byte)((tagHigh >> 24) & 0xff);         uabytes[6] = (byte)((tagHigh >> 16) & 0xff);         uabytes[5] = (byte)((tagHigh >> 8) & 0xff);         uabytes[4] = (byte)(tagHigh & 0xff);         uabytes[3] = (byte)((tagLow >> 24) & 0xff);         uabytes[2] = (byte)((tagLow >> 16) & 0xff);         uabytes[1] = (byte)((tagLow >> 8) & 0xff);         uabytes[0] = (byte)(tagLow & 0xff);         uabytes[8] = 0;         return EInteger.FromBytes(uabytes' true);       }
Magic Number,PeterO.Cbor,CBORObject,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORObject.cs,LowHighToEInteger,The following statement contains a magic number: if (tagHigh != 0) {         uabytes = new byte[9];         uabytes[7] = (byte)((tagHigh >> 24) & 0xff);         uabytes[6] = (byte)((tagHigh >> 16) & 0xff);         uabytes[5] = (byte)((tagHigh >> 8) & 0xff);         uabytes[4] = (byte)(tagHigh & 0xff);         uabytes[3] = (byte)((tagLow >> 24) & 0xff);         uabytes[2] = (byte)((tagLow >> 16) & 0xff);         uabytes[1] = (byte)((tagLow >> 8) & 0xff);         uabytes[0] = (byte)(tagLow & 0xff);         uabytes[8] = 0;         return EInteger.FromBytes(uabytes' true);       }
Magic Number,PeterO.Cbor,CBORObject,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORObject.cs,LowHighToEInteger,The following statement contains a magic number: if (tagHigh != 0) {         uabytes = new byte[9];         uabytes[7] = (byte)((tagHigh >> 24) & 0xff);         uabytes[6] = (byte)((tagHigh >> 16) & 0xff);         uabytes[5] = (byte)((tagHigh >> 8) & 0xff);         uabytes[4] = (byte)(tagHigh & 0xff);         uabytes[3] = (byte)((tagLow >> 24) & 0xff);         uabytes[2] = (byte)((tagLow >> 16) & 0xff);         uabytes[1] = (byte)((tagLow >> 8) & 0xff);         uabytes[0] = (byte)(tagLow & 0xff);         uabytes[8] = 0;         return EInteger.FromBytes(uabytes' true);       }
Magic Number,PeterO.Cbor,CBORObject,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORObject.cs,LowHighToEInteger,The following statement contains a magic number: if (tagHigh != 0) {         uabytes = new byte[9];         uabytes[7] = (byte)((tagHigh >> 24) & 0xff);         uabytes[6] = (byte)((tagHigh >> 16) & 0xff);         uabytes[5] = (byte)((tagHigh >> 8) & 0xff);         uabytes[4] = (byte)(tagHigh & 0xff);         uabytes[3] = (byte)((tagLow >> 24) & 0xff);         uabytes[2] = (byte)((tagLow >> 16) & 0xff);         uabytes[1] = (byte)((tagLow >> 8) & 0xff);         uabytes[0] = (byte)(tagLow & 0xff);         uabytes[8] = 0;         return EInteger.FromBytes(uabytes' true);       }
Magic Number,PeterO.Cbor,CBORObject,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORObject.cs,LowHighToEInteger,The following statement contains a magic number: if (tagHigh != 0) {         uabytes = new byte[9];         uabytes[7] = (byte)((tagHigh >> 24) & 0xff);         uabytes[6] = (byte)((tagHigh >> 16) & 0xff);         uabytes[5] = (byte)((tagHigh >> 8) & 0xff);         uabytes[4] = (byte)(tagHigh & 0xff);         uabytes[3] = (byte)((tagLow >> 24) & 0xff);         uabytes[2] = (byte)((tagLow >> 16) & 0xff);         uabytes[1] = (byte)((tagLow >> 8) & 0xff);         uabytes[0] = (byte)(tagLow & 0xff);         uabytes[8] = 0;         return EInteger.FromBytes(uabytes' true);       }
Magic Number,PeterO.Cbor,CBORObject,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORObject.cs,LowHighToEInteger,The following statement contains a magic number: if (tagHigh != 0) {         uabytes = new byte[9];         uabytes[7] = (byte)((tagHigh >> 24) & 0xff);         uabytes[6] = (byte)((tagHigh >> 16) & 0xff);         uabytes[5] = (byte)((tagHigh >> 8) & 0xff);         uabytes[4] = (byte)(tagHigh & 0xff);         uabytes[3] = (byte)((tagLow >> 24) & 0xff);         uabytes[2] = (byte)((tagLow >> 16) & 0xff);         uabytes[1] = (byte)((tagLow >> 8) & 0xff);         uabytes[0] = (byte)(tagLow & 0xff);         uabytes[8] = 0;         return EInteger.FromBytes(uabytes' true);       }
Magic Number,PeterO.Cbor,CBORObject,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORObject.cs,LowHighToEInteger,The following statement contains a magic number: if (tagHigh != 0) {         uabytes = new byte[9];         uabytes[7] = (byte)((tagHigh >> 24) & 0xff);         uabytes[6] = (byte)((tagHigh >> 16) & 0xff);         uabytes[5] = (byte)((tagHigh >> 8) & 0xff);         uabytes[4] = (byte)(tagHigh & 0xff);         uabytes[3] = (byte)((tagLow >> 24) & 0xff);         uabytes[2] = (byte)((tagLow >> 16) & 0xff);         uabytes[1] = (byte)((tagLow >> 8) & 0xff);         uabytes[0] = (byte)(tagLow & 0xff);         uabytes[8] = 0;         return EInteger.FromBytes(uabytes' true);       }
Magic Number,PeterO.Cbor,CBORObject,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORObject.cs,LowHighToEInteger,The following statement contains a magic number: if (tagHigh != 0) {         uabytes = new byte[9];         uabytes[7] = (byte)((tagHigh >> 24) & 0xff);         uabytes[6] = (byte)((tagHigh >> 16) & 0xff);         uabytes[5] = (byte)((tagHigh >> 8) & 0xff);         uabytes[4] = (byte)(tagHigh & 0xff);         uabytes[3] = (byte)((tagLow >> 24) & 0xff);         uabytes[2] = (byte)((tagLow >> 16) & 0xff);         uabytes[1] = (byte)((tagLow >> 8) & 0xff);         uabytes[0] = (byte)(tagLow & 0xff);         uabytes[8] = 0;         return EInteger.FromBytes(uabytes' true);       }
Magic Number,PeterO.Cbor,CBORObject,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORObject.cs,LowHighToEInteger,The following statement contains a magic number: if (tagHigh != 0) {         uabytes = new byte[9];         uabytes[7] = (byte)((tagHigh >> 24) & 0xff);         uabytes[6] = (byte)((tagHigh >> 16) & 0xff);         uabytes[5] = (byte)((tagHigh >> 8) & 0xff);         uabytes[4] = (byte)(tagHigh & 0xff);         uabytes[3] = (byte)((tagLow >> 24) & 0xff);         uabytes[2] = (byte)((tagLow >> 16) & 0xff);         uabytes[1] = (byte)((tagLow >> 8) & 0xff);         uabytes[0] = (byte)(tagLow & 0xff);         uabytes[8] = 0;         return EInteger.FromBytes(uabytes' true);       }
Magic Number,PeterO.Cbor,CBORObject,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORObject.cs,LowHighToEInteger,The following statement contains a magic number: if (tagLow != 0) {         uabytes = new byte[5];         uabytes[3] = (byte)((tagLow >> 24) & 0xff);         uabytes[2] = (byte)((tagLow >> 16) & 0xff);         uabytes[1] = (byte)((tagLow >> 8) & 0xff);         uabytes[0] = (byte)(tagLow & 0xff);         uabytes[4] = 0;         return EInteger.FromBytes(uabytes' true);       }
Magic Number,PeterO.Cbor,CBORObject,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORObject.cs,LowHighToEInteger,The following statement contains a magic number: if (tagLow != 0) {         uabytes = new byte[5];         uabytes[3] = (byte)((tagLow >> 24) & 0xff);         uabytes[2] = (byte)((tagLow >> 16) & 0xff);         uabytes[1] = (byte)((tagLow >> 8) & 0xff);         uabytes[0] = (byte)(tagLow & 0xff);         uabytes[4] = 0;         return EInteger.FromBytes(uabytes' true);       }
Magic Number,PeterO.Cbor,CBORObject,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORObject.cs,LowHighToEInteger,The following statement contains a magic number: if (tagLow != 0) {         uabytes = new byte[5];         uabytes[3] = (byte)((tagLow >> 24) & 0xff);         uabytes[2] = (byte)((tagLow >> 16) & 0xff);         uabytes[1] = (byte)((tagLow >> 8) & 0xff);         uabytes[0] = (byte)(tagLow & 0xff);         uabytes[4] = 0;         return EInteger.FromBytes(uabytes' true);       }
Magic Number,PeterO.Cbor,CBORObject,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORObject.cs,LowHighToEInteger,The following statement contains a magic number: if (tagLow != 0) {         uabytes = new byte[5];         uabytes[3] = (byte)((tagLow >> 24) & 0xff);         uabytes[2] = (byte)((tagLow >> 16) & 0xff);         uabytes[1] = (byte)((tagLow >> 8) & 0xff);         uabytes[0] = (byte)(tagLow & 0xff);         uabytes[4] = 0;         return EInteger.FromBytes(uabytes' true);       }
Magic Number,PeterO.Cbor,CBORObject,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORObject.cs,LowHighToEInteger,The following statement contains a magic number: if (tagLow != 0) {         uabytes = new byte[5];         uabytes[3] = (byte)((tagLow >> 24) & 0xff);         uabytes[2] = (byte)((tagLow >> 16) & 0xff);         uabytes[1] = (byte)((tagLow >> 8) & 0xff);         uabytes[0] = (byte)(tagLow & 0xff);         uabytes[4] = 0;         return EInteger.FromBytes(uabytes' true);       }
Magic Number,PeterO.Cbor,CBORObject,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORObject.cs,LowHighToEInteger,The following statement contains a magic number: if (tagLow != 0) {         uabytes = new byte[5];         uabytes[3] = (byte)((tagLow >> 24) & 0xff);         uabytes[2] = (byte)((tagLow >> 16) & 0xff);         uabytes[1] = (byte)((tagLow >> 8) & 0xff);         uabytes[0] = (byte)(tagLow & 0xff);         uabytes[4] = 0;         return EInteger.FromBytes(uabytes' true);       }
Magic Number,PeterO.Cbor,CBORObject,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORObject.cs,LowHighToEInteger,The following statement contains a magic number: if (tagLow != 0) {         uabytes = new byte[5];         uabytes[3] = (byte)((tagLow >> 24) & 0xff);         uabytes[2] = (byte)((tagLow >> 16) & 0xff);         uabytes[1] = (byte)((tagLow >> 8) & 0xff);         uabytes[0] = (byte)(tagLow & 0xff);         uabytes[4] = 0;         return EInteger.FromBytes(uabytes' true);       }
Magic Number,PeterO.Cbor,CBORObject,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORObject.cs,WriteObjectArray,The following statement contains a magic number: WritePositiveInt(4' list.Count' outputStream);
Magic Number,PeterO.Cbor,CBORObject,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORObject.cs,WriteObjectMap,The following statement contains a magic number: WritePositiveInt(5' map.Count' outputStream);
Magic Number,PeterO.Cbor,CBORObject,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORObject.cs,WriteStreamedString,The following statement contains a magic number: for (int index = 0; index < str.Length; ++index) {         int c = str[index];         if (c <= 0x7f) {           if (byteIndex >= StreamedStringBufferLength) {             // Write bytes retrieved so far             if (!streaming) {               stream.WriteByte((byte)0x7f);             }             WritePositiveInt(3' byteIndex' stream);             stream.Write(bytes' 0' byteIndex);             byteIndex = 0;             streaming = true;           }           bytes[byteIndex++] = (byte)c;         } else if (c <= 0x7ff) {           if (byteIndex + 2 > StreamedStringBufferLength) {             // Write bytes retrieved so far - the next three bytes             // would exceed the length' and the CBOR spec forbids             // splitting characters when generating text strings             if (!streaming) {               stream.WriteByte((byte)0x7f);             }             WritePositiveInt(3' byteIndex' stream);             stream.Write(bytes' 0' byteIndex);             byteIndex = 0;             streaming = true;           }           bytes[byteIndex++] = (byte)(0xc0 | ((c >> 6) & 0x1f));           bytes[byteIndex++] = (byte)(0x80 | (c & 0x3f));         } else {           if ((c & 0xfc00) == 0xd800 && index + 1 < str.Length &&               str[index + 1] >= 0xdc00 && str[index + 1] <= 0xdfff) {             // Get the Unicode code point for the surrogate pair             c = 0x10000 + ((c - 0xd800) << 10) + (str[index + 1] - 0xdc00);             ++index;           } else if ((c & 0xf800) == 0xd800) {             // unpaired surrogate' write U + FFFD instead             c = 0xfffd;           }           if (c <= 0xffff) {             if (byteIndex + 3 > StreamedStringBufferLength) {               // Write bytes retrieved so far - the next three bytes               // would exceed the length' and the CBOR spec forbids               // splitting characters when generating text strings               if (!streaming) {                 stream.WriteByte((byte)0x7f);               }               WritePositiveInt(3' byteIndex' stream);               stream.Write(bytes' 0' byteIndex);               byteIndex = 0;               streaming = true;             }             bytes[byteIndex++] = (byte)(0xe0 | ((c >> 12) & 0x0f));             bytes[byteIndex++] = (byte)(0x80 | ((c >> 6) & 0x3f));             bytes[byteIndex++] = (byte)(0x80 | (c & 0x3f));           } else {             if (byteIndex + 4 > StreamedStringBufferLength) {               // Write bytes retrieved so far - the next four bytes               // would exceed the length' and the CBOR spec forbids               // splitting characters when generating text strings               if (!streaming) {                 stream.WriteByte((byte)0x7f);               }               WritePositiveInt(3' byteIndex' stream);               stream.Write(bytes' 0' byteIndex);               byteIndex = 0;               streaming = true;             }             bytes[byteIndex++] = (byte)(0xf0 | ((c >> 18) & 0x07));             bytes[byteIndex++] = (byte)(0x80 | ((c >> 12) & 0x3f));             bytes[byteIndex++] = (byte)(0x80 | ((c >> 6) & 0x3f));             bytes[byteIndex++] = (byte)(0x80 | (c & 0x3f));           }         }       }
Magic Number,PeterO.Cbor,CBORObject,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORObject.cs,WriteStreamedString,The following statement contains a magic number: for (int index = 0; index < str.Length; ++index) {         int c = str[index];         if (c <= 0x7f) {           if (byteIndex >= StreamedStringBufferLength) {             // Write bytes retrieved so far             if (!streaming) {               stream.WriteByte((byte)0x7f);             }             WritePositiveInt(3' byteIndex' stream);             stream.Write(bytes' 0' byteIndex);             byteIndex = 0;             streaming = true;           }           bytes[byteIndex++] = (byte)c;         } else if (c <= 0x7ff) {           if (byteIndex + 2 > StreamedStringBufferLength) {             // Write bytes retrieved so far - the next three bytes             // would exceed the length' and the CBOR spec forbids             // splitting characters when generating text strings             if (!streaming) {               stream.WriteByte((byte)0x7f);             }             WritePositiveInt(3' byteIndex' stream);             stream.Write(bytes' 0' byteIndex);             byteIndex = 0;             streaming = true;           }           bytes[byteIndex++] = (byte)(0xc0 | ((c >> 6) & 0x1f));           bytes[byteIndex++] = (byte)(0x80 | (c & 0x3f));         } else {           if ((c & 0xfc00) == 0xd800 && index + 1 < str.Length &&               str[index + 1] >= 0xdc00 && str[index + 1] <= 0xdfff) {             // Get the Unicode code point for the surrogate pair             c = 0x10000 + ((c - 0xd800) << 10) + (str[index + 1] - 0xdc00);             ++index;           } else if ((c & 0xf800) == 0xd800) {             // unpaired surrogate' write U + FFFD instead             c = 0xfffd;           }           if (c <= 0xffff) {             if (byteIndex + 3 > StreamedStringBufferLength) {               // Write bytes retrieved so far - the next three bytes               // would exceed the length' and the CBOR spec forbids               // splitting characters when generating text strings               if (!streaming) {                 stream.WriteByte((byte)0x7f);               }               WritePositiveInt(3' byteIndex' stream);               stream.Write(bytes' 0' byteIndex);               byteIndex = 0;               streaming = true;             }             bytes[byteIndex++] = (byte)(0xe0 | ((c >> 12) & 0x0f));             bytes[byteIndex++] = (byte)(0x80 | ((c >> 6) & 0x3f));             bytes[byteIndex++] = (byte)(0x80 | (c & 0x3f));           } else {             if (byteIndex + 4 > StreamedStringBufferLength) {               // Write bytes retrieved so far - the next four bytes               // would exceed the length' and the CBOR spec forbids               // splitting characters when generating text strings               if (!streaming) {                 stream.WriteByte((byte)0x7f);               }               WritePositiveInt(3' byteIndex' stream);               stream.Write(bytes' 0' byteIndex);               byteIndex = 0;               streaming = true;             }             bytes[byteIndex++] = (byte)(0xf0 | ((c >> 18) & 0x07));             bytes[byteIndex++] = (byte)(0x80 | ((c >> 12) & 0x3f));             bytes[byteIndex++] = (byte)(0x80 | ((c >> 6) & 0x3f));             bytes[byteIndex++] = (byte)(0x80 | (c & 0x3f));           }         }       }
Magic Number,PeterO.Cbor,CBORObject,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORObject.cs,WriteStreamedString,The following statement contains a magic number: for (int index = 0; index < str.Length; ++index) {         int c = str[index];         if (c <= 0x7f) {           if (byteIndex >= StreamedStringBufferLength) {             // Write bytes retrieved so far             if (!streaming) {               stream.WriteByte((byte)0x7f);             }             WritePositiveInt(3' byteIndex' stream);             stream.Write(bytes' 0' byteIndex);             byteIndex = 0;             streaming = true;           }           bytes[byteIndex++] = (byte)c;         } else if (c <= 0x7ff) {           if (byteIndex + 2 > StreamedStringBufferLength) {             // Write bytes retrieved so far - the next three bytes             // would exceed the length' and the CBOR spec forbids             // splitting characters when generating text strings             if (!streaming) {               stream.WriteByte((byte)0x7f);             }             WritePositiveInt(3' byteIndex' stream);             stream.Write(bytes' 0' byteIndex);             byteIndex = 0;             streaming = true;           }           bytes[byteIndex++] = (byte)(0xc0 | ((c >> 6) & 0x1f));           bytes[byteIndex++] = (byte)(0x80 | (c & 0x3f));         } else {           if ((c & 0xfc00) == 0xd800 && index + 1 < str.Length &&               str[index + 1] >= 0xdc00 && str[index + 1] <= 0xdfff) {             // Get the Unicode code point for the surrogate pair             c = 0x10000 + ((c - 0xd800) << 10) + (str[index + 1] - 0xdc00);             ++index;           } else if ((c & 0xf800) == 0xd800) {             // unpaired surrogate' write U + FFFD instead             c = 0xfffd;           }           if (c <= 0xffff) {             if (byteIndex + 3 > StreamedStringBufferLength) {               // Write bytes retrieved so far - the next three bytes               // would exceed the length' and the CBOR spec forbids               // splitting characters when generating text strings               if (!streaming) {                 stream.WriteByte((byte)0x7f);               }               WritePositiveInt(3' byteIndex' stream);               stream.Write(bytes' 0' byteIndex);               byteIndex = 0;               streaming = true;             }             bytes[byteIndex++] = (byte)(0xe0 | ((c >> 12) & 0x0f));             bytes[byteIndex++] = (byte)(0x80 | ((c >> 6) & 0x3f));             bytes[byteIndex++] = (byte)(0x80 | (c & 0x3f));           } else {             if (byteIndex + 4 > StreamedStringBufferLength) {               // Write bytes retrieved so far - the next four bytes               // would exceed the length' and the CBOR spec forbids               // splitting characters when generating text strings               if (!streaming) {                 stream.WriteByte((byte)0x7f);               }               WritePositiveInt(3' byteIndex' stream);               stream.Write(bytes' 0' byteIndex);               byteIndex = 0;               streaming = true;             }             bytes[byteIndex++] = (byte)(0xf0 | ((c >> 18) & 0x07));             bytes[byteIndex++] = (byte)(0x80 | ((c >> 12) & 0x3f));             bytes[byteIndex++] = (byte)(0x80 | ((c >> 6) & 0x3f));             bytes[byteIndex++] = (byte)(0x80 | (c & 0x3f));           }         }       }
Magic Number,PeterO.Cbor,CBORObject,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORObject.cs,WriteStreamedString,The following statement contains a magic number: for (int index = 0; index < str.Length; ++index) {         int c = str[index];         if (c <= 0x7f) {           if (byteIndex >= StreamedStringBufferLength) {             // Write bytes retrieved so far             if (!streaming) {               stream.WriteByte((byte)0x7f);             }             WritePositiveInt(3' byteIndex' stream);             stream.Write(bytes' 0' byteIndex);             byteIndex = 0;             streaming = true;           }           bytes[byteIndex++] = (byte)c;         } else if (c <= 0x7ff) {           if (byteIndex + 2 > StreamedStringBufferLength) {             // Write bytes retrieved so far - the next three bytes             // would exceed the length' and the CBOR spec forbids             // splitting characters when generating text strings             if (!streaming) {               stream.WriteByte((byte)0x7f);             }             WritePositiveInt(3' byteIndex' stream);             stream.Write(bytes' 0' byteIndex);             byteIndex = 0;             streaming = true;           }           bytes[byteIndex++] = (byte)(0xc0 | ((c >> 6) & 0x1f));           bytes[byteIndex++] = (byte)(0x80 | (c & 0x3f));         } else {           if ((c & 0xfc00) == 0xd800 && index + 1 < str.Length &&               str[index + 1] >= 0xdc00 && str[index + 1] <= 0xdfff) {             // Get the Unicode code point for the surrogate pair             c = 0x10000 + ((c - 0xd800) << 10) + (str[index + 1] - 0xdc00);             ++index;           } else if ((c & 0xf800) == 0xd800) {             // unpaired surrogate' write U + FFFD instead             c = 0xfffd;           }           if (c <= 0xffff) {             if (byteIndex + 3 > StreamedStringBufferLength) {               // Write bytes retrieved so far - the next three bytes               // would exceed the length' and the CBOR spec forbids               // splitting characters when generating text strings               if (!streaming) {                 stream.WriteByte((byte)0x7f);               }               WritePositiveInt(3' byteIndex' stream);               stream.Write(bytes' 0' byteIndex);               byteIndex = 0;               streaming = true;             }             bytes[byteIndex++] = (byte)(0xe0 | ((c >> 12) & 0x0f));             bytes[byteIndex++] = (byte)(0x80 | ((c >> 6) & 0x3f));             bytes[byteIndex++] = (byte)(0x80 | (c & 0x3f));           } else {             if (byteIndex + 4 > StreamedStringBufferLength) {               // Write bytes retrieved so far - the next four bytes               // would exceed the length' and the CBOR spec forbids               // splitting characters when generating text strings               if (!streaming) {                 stream.WriteByte((byte)0x7f);               }               WritePositiveInt(3' byteIndex' stream);               stream.Write(bytes' 0' byteIndex);               byteIndex = 0;               streaming = true;             }             bytes[byteIndex++] = (byte)(0xf0 | ((c >> 18) & 0x07));             bytes[byteIndex++] = (byte)(0x80 | ((c >> 12) & 0x3f));             bytes[byteIndex++] = (byte)(0x80 | ((c >> 6) & 0x3f));             bytes[byteIndex++] = (byte)(0x80 | (c & 0x3f));           }         }       }
Magic Number,PeterO.Cbor,CBORObject,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORObject.cs,WriteStreamedString,The following statement contains a magic number: for (int index = 0; index < str.Length; ++index) {         int c = str[index];         if (c <= 0x7f) {           if (byteIndex >= StreamedStringBufferLength) {             // Write bytes retrieved so far             if (!streaming) {               stream.WriteByte((byte)0x7f);             }             WritePositiveInt(3' byteIndex' stream);             stream.Write(bytes' 0' byteIndex);             byteIndex = 0;             streaming = true;           }           bytes[byteIndex++] = (byte)c;         } else if (c <= 0x7ff) {           if (byteIndex + 2 > StreamedStringBufferLength) {             // Write bytes retrieved so far - the next three bytes             // would exceed the length' and the CBOR spec forbids             // splitting characters when generating text strings             if (!streaming) {               stream.WriteByte((byte)0x7f);             }             WritePositiveInt(3' byteIndex' stream);             stream.Write(bytes' 0' byteIndex);             byteIndex = 0;             streaming = true;           }           bytes[byteIndex++] = (byte)(0xc0 | ((c >> 6) & 0x1f));           bytes[byteIndex++] = (byte)(0x80 | (c & 0x3f));         } else {           if ((c & 0xfc00) == 0xd800 && index + 1 < str.Length &&               str[index + 1] >= 0xdc00 && str[index + 1] <= 0xdfff) {             // Get the Unicode code point for the surrogate pair             c = 0x10000 + ((c - 0xd800) << 10) + (str[index + 1] - 0xdc00);             ++index;           } else if ((c & 0xf800) == 0xd800) {             // unpaired surrogate' write U + FFFD instead             c = 0xfffd;           }           if (c <= 0xffff) {             if (byteIndex + 3 > StreamedStringBufferLength) {               // Write bytes retrieved so far - the next three bytes               // would exceed the length' and the CBOR spec forbids               // splitting characters when generating text strings               if (!streaming) {                 stream.WriteByte((byte)0x7f);               }               WritePositiveInt(3' byteIndex' stream);               stream.Write(bytes' 0' byteIndex);               byteIndex = 0;               streaming = true;             }             bytes[byteIndex++] = (byte)(0xe0 | ((c >> 12) & 0x0f));             bytes[byteIndex++] = (byte)(0x80 | ((c >> 6) & 0x3f));             bytes[byteIndex++] = (byte)(0x80 | (c & 0x3f));           } else {             if (byteIndex + 4 > StreamedStringBufferLength) {               // Write bytes retrieved so far - the next four bytes               // would exceed the length' and the CBOR spec forbids               // splitting characters when generating text strings               if (!streaming) {                 stream.WriteByte((byte)0x7f);               }               WritePositiveInt(3' byteIndex' stream);               stream.Write(bytes' 0' byteIndex);               byteIndex = 0;               streaming = true;             }             bytes[byteIndex++] = (byte)(0xf0 | ((c >> 18) & 0x07));             bytes[byteIndex++] = (byte)(0x80 | ((c >> 12) & 0x3f));             bytes[byteIndex++] = (byte)(0x80 | ((c >> 6) & 0x3f));             bytes[byteIndex++] = (byte)(0x80 | (c & 0x3f));           }         }       }
Magic Number,PeterO.Cbor,CBORObject,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORObject.cs,WriteStreamedString,The following statement contains a magic number: for (int index = 0; index < str.Length; ++index) {         int c = str[index];         if (c <= 0x7f) {           if (byteIndex >= StreamedStringBufferLength) {             // Write bytes retrieved so far             if (!streaming) {               stream.WriteByte((byte)0x7f);             }             WritePositiveInt(3' byteIndex' stream);             stream.Write(bytes' 0' byteIndex);             byteIndex = 0;             streaming = true;           }           bytes[byteIndex++] = (byte)c;         } else if (c <= 0x7ff) {           if (byteIndex + 2 > StreamedStringBufferLength) {             // Write bytes retrieved so far - the next three bytes             // would exceed the length' and the CBOR spec forbids             // splitting characters when generating text strings             if (!streaming) {               stream.WriteByte((byte)0x7f);             }             WritePositiveInt(3' byteIndex' stream);             stream.Write(bytes' 0' byteIndex);             byteIndex = 0;             streaming = true;           }           bytes[byteIndex++] = (byte)(0xc0 | ((c >> 6) & 0x1f));           bytes[byteIndex++] = (byte)(0x80 | (c & 0x3f));         } else {           if ((c & 0xfc00) == 0xd800 && index + 1 < str.Length &&               str[index + 1] >= 0xdc00 && str[index + 1] <= 0xdfff) {             // Get the Unicode code point for the surrogate pair             c = 0x10000 + ((c - 0xd800) << 10) + (str[index + 1] - 0xdc00);             ++index;           } else if ((c & 0xf800) == 0xd800) {             // unpaired surrogate' write U + FFFD instead             c = 0xfffd;           }           if (c <= 0xffff) {             if (byteIndex + 3 > StreamedStringBufferLength) {               // Write bytes retrieved so far - the next three bytes               // would exceed the length' and the CBOR spec forbids               // splitting characters when generating text strings               if (!streaming) {                 stream.WriteByte((byte)0x7f);               }               WritePositiveInt(3' byteIndex' stream);               stream.Write(bytes' 0' byteIndex);               byteIndex = 0;               streaming = true;             }             bytes[byteIndex++] = (byte)(0xe0 | ((c >> 12) & 0x0f));             bytes[byteIndex++] = (byte)(0x80 | ((c >> 6) & 0x3f));             bytes[byteIndex++] = (byte)(0x80 | (c & 0x3f));           } else {             if (byteIndex + 4 > StreamedStringBufferLength) {               // Write bytes retrieved so far - the next four bytes               // would exceed the length' and the CBOR spec forbids               // splitting characters when generating text strings               if (!streaming) {                 stream.WriteByte((byte)0x7f);               }               WritePositiveInt(3' byteIndex' stream);               stream.Write(bytes' 0' byteIndex);               byteIndex = 0;               streaming = true;             }             bytes[byteIndex++] = (byte)(0xf0 | ((c >> 18) & 0x07));             bytes[byteIndex++] = (byte)(0x80 | ((c >> 12) & 0x3f));             bytes[byteIndex++] = (byte)(0x80 | ((c >> 6) & 0x3f));             bytes[byteIndex++] = (byte)(0x80 | (c & 0x3f));           }         }       }
Magic Number,PeterO.Cbor,CBORObject,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORObject.cs,WriteStreamedString,The following statement contains a magic number: for (int index = 0; index < str.Length; ++index) {         int c = str[index];         if (c <= 0x7f) {           if (byteIndex >= StreamedStringBufferLength) {             // Write bytes retrieved so far             if (!streaming) {               stream.WriteByte((byte)0x7f);             }             WritePositiveInt(3' byteIndex' stream);             stream.Write(bytes' 0' byteIndex);             byteIndex = 0;             streaming = true;           }           bytes[byteIndex++] = (byte)c;         } else if (c <= 0x7ff) {           if (byteIndex + 2 > StreamedStringBufferLength) {             // Write bytes retrieved so far - the next three bytes             // would exceed the length' and the CBOR spec forbids             // splitting characters when generating text strings             if (!streaming) {               stream.WriteByte((byte)0x7f);             }             WritePositiveInt(3' byteIndex' stream);             stream.Write(bytes' 0' byteIndex);             byteIndex = 0;             streaming = true;           }           bytes[byteIndex++] = (byte)(0xc0 | ((c >> 6) & 0x1f));           bytes[byteIndex++] = (byte)(0x80 | (c & 0x3f));         } else {           if ((c & 0xfc00) == 0xd800 && index + 1 < str.Length &&               str[index + 1] >= 0xdc00 && str[index + 1] <= 0xdfff) {             // Get the Unicode code point for the surrogate pair             c = 0x10000 + ((c - 0xd800) << 10) + (str[index + 1] - 0xdc00);             ++index;           } else if ((c & 0xf800) == 0xd800) {             // unpaired surrogate' write U + FFFD instead             c = 0xfffd;           }           if (c <= 0xffff) {             if (byteIndex + 3 > StreamedStringBufferLength) {               // Write bytes retrieved so far - the next three bytes               // would exceed the length' and the CBOR spec forbids               // splitting characters when generating text strings               if (!streaming) {                 stream.WriteByte((byte)0x7f);               }               WritePositiveInt(3' byteIndex' stream);               stream.Write(bytes' 0' byteIndex);               byteIndex = 0;               streaming = true;             }             bytes[byteIndex++] = (byte)(0xe0 | ((c >> 12) & 0x0f));             bytes[byteIndex++] = (byte)(0x80 | ((c >> 6) & 0x3f));             bytes[byteIndex++] = (byte)(0x80 | (c & 0x3f));           } else {             if (byteIndex + 4 > StreamedStringBufferLength) {               // Write bytes retrieved so far - the next four bytes               // would exceed the length' and the CBOR spec forbids               // splitting characters when generating text strings               if (!streaming) {                 stream.WriteByte((byte)0x7f);               }               WritePositiveInt(3' byteIndex' stream);               stream.Write(bytes' 0' byteIndex);               byteIndex = 0;               streaming = true;             }             bytes[byteIndex++] = (byte)(0xf0 | ((c >> 18) & 0x07));             bytes[byteIndex++] = (byte)(0x80 | ((c >> 12) & 0x3f));             bytes[byteIndex++] = (byte)(0x80 | ((c >> 6) & 0x3f));             bytes[byteIndex++] = (byte)(0x80 | (c & 0x3f));           }         }       }
Magic Number,PeterO.Cbor,CBORObject,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORObject.cs,WriteStreamedString,The following statement contains a magic number: for (int index = 0; index < str.Length; ++index) {         int c = str[index];         if (c <= 0x7f) {           if (byteIndex >= StreamedStringBufferLength) {             // Write bytes retrieved so far             if (!streaming) {               stream.WriteByte((byte)0x7f);             }             WritePositiveInt(3' byteIndex' stream);             stream.Write(bytes' 0' byteIndex);             byteIndex = 0;             streaming = true;           }           bytes[byteIndex++] = (byte)c;         } else if (c <= 0x7ff) {           if (byteIndex + 2 > StreamedStringBufferLength) {             // Write bytes retrieved so far - the next three bytes             // would exceed the length' and the CBOR spec forbids             // splitting characters when generating text strings             if (!streaming) {               stream.WriteByte((byte)0x7f);             }             WritePositiveInt(3' byteIndex' stream);             stream.Write(bytes' 0' byteIndex);             byteIndex = 0;             streaming = true;           }           bytes[byteIndex++] = (byte)(0xc0 | ((c >> 6) & 0x1f));           bytes[byteIndex++] = (byte)(0x80 | (c & 0x3f));         } else {           if ((c & 0xfc00) == 0xd800 && index + 1 < str.Length &&               str[index + 1] >= 0xdc00 && str[index + 1] <= 0xdfff) {             // Get the Unicode code point for the surrogate pair             c = 0x10000 + ((c - 0xd800) << 10) + (str[index + 1] - 0xdc00);             ++index;           } else if ((c & 0xf800) == 0xd800) {             // unpaired surrogate' write U + FFFD instead             c = 0xfffd;           }           if (c <= 0xffff) {             if (byteIndex + 3 > StreamedStringBufferLength) {               // Write bytes retrieved so far - the next three bytes               // would exceed the length' and the CBOR spec forbids               // splitting characters when generating text strings               if (!streaming) {                 stream.WriteByte((byte)0x7f);               }               WritePositiveInt(3' byteIndex' stream);               stream.Write(bytes' 0' byteIndex);               byteIndex = 0;               streaming = true;             }             bytes[byteIndex++] = (byte)(0xe0 | ((c >> 12) & 0x0f));             bytes[byteIndex++] = (byte)(0x80 | ((c >> 6) & 0x3f));             bytes[byteIndex++] = (byte)(0x80 | (c & 0x3f));           } else {             if (byteIndex + 4 > StreamedStringBufferLength) {               // Write bytes retrieved so far - the next four bytes               // would exceed the length' and the CBOR spec forbids               // splitting characters when generating text strings               if (!streaming) {                 stream.WriteByte((byte)0x7f);               }               WritePositiveInt(3' byteIndex' stream);               stream.Write(bytes' 0' byteIndex);               byteIndex = 0;               streaming = true;             }             bytes[byteIndex++] = (byte)(0xf0 | ((c >> 18) & 0x07));             bytes[byteIndex++] = (byte)(0x80 | ((c >> 12) & 0x3f));             bytes[byteIndex++] = (byte)(0x80 | ((c >> 6) & 0x3f));             bytes[byteIndex++] = (byte)(0x80 | (c & 0x3f));           }         }       }
Magic Number,PeterO.Cbor,CBORObject,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORObject.cs,WriteStreamedString,The following statement contains a magic number: for (int index = 0; index < str.Length; ++index) {         int c = str[index];         if (c <= 0x7f) {           if (byteIndex >= StreamedStringBufferLength) {             // Write bytes retrieved so far             if (!streaming) {               stream.WriteByte((byte)0x7f);             }             WritePositiveInt(3' byteIndex' stream);             stream.Write(bytes' 0' byteIndex);             byteIndex = 0;             streaming = true;           }           bytes[byteIndex++] = (byte)c;         } else if (c <= 0x7ff) {           if (byteIndex + 2 > StreamedStringBufferLength) {             // Write bytes retrieved so far - the next three bytes             // would exceed the length' and the CBOR spec forbids             // splitting characters when generating text strings             if (!streaming) {               stream.WriteByte((byte)0x7f);             }             WritePositiveInt(3' byteIndex' stream);             stream.Write(bytes' 0' byteIndex);             byteIndex = 0;             streaming = true;           }           bytes[byteIndex++] = (byte)(0xc0 | ((c >> 6) & 0x1f));           bytes[byteIndex++] = (byte)(0x80 | (c & 0x3f));         } else {           if ((c & 0xfc00) == 0xd800 && index + 1 < str.Length &&               str[index + 1] >= 0xdc00 && str[index + 1] <= 0xdfff) {             // Get the Unicode code point for the surrogate pair             c = 0x10000 + ((c - 0xd800) << 10) + (str[index + 1] - 0xdc00);             ++index;           } else if ((c & 0xf800) == 0xd800) {             // unpaired surrogate' write U + FFFD instead             c = 0xfffd;           }           if (c <= 0xffff) {             if (byteIndex + 3 > StreamedStringBufferLength) {               // Write bytes retrieved so far - the next three bytes               // would exceed the length' and the CBOR spec forbids               // splitting characters when generating text strings               if (!streaming) {                 stream.WriteByte((byte)0x7f);               }               WritePositiveInt(3' byteIndex' stream);               stream.Write(bytes' 0' byteIndex);               byteIndex = 0;               streaming = true;             }             bytes[byteIndex++] = (byte)(0xe0 | ((c >> 12) & 0x0f));             bytes[byteIndex++] = (byte)(0x80 | ((c >> 6) & 0x3f));             bytes[byteIndex++] = (byte)(0x80 | (c & 0x3f));           } else {             if (byteIndex + 4 > StreamedStringBufferLength) {               // Write bytes retrieved so far - the next four bytes               // would exceed the length' and the CBOR spec forbids               // splitting characters when generating text strings               if (!streaming) {                 stream.WriteByte((byte)0x7f);               }               WritePositiveInt(3' byteIndex' stream);               stream.Write(bytes' 0' byteIndex);               byteIndex = 0;               streaming = true;             }             bytes[byteIndex++] = (byte)(0xf0 | ((c >> 18) & 0x07));             bytes[byteIndex++] = (byte)(0x80 | ((c >> 12) & 0x3f));             bytes[byteIndex++] = (byte)(0x80 | ((c >> 6) & 0x3f));             bytes[byteIndex++] = (byte)(0x80 | (c & 0x3f));           }         }       }
Magic Number,PeterO.Cbor,CBORObject,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORObject.cs,WriteStreamedString,The following statement contains a magic number: for (int index = 0; index < str.Length; ++index) {         int c = str[index];         if (c <= 0x7f) {           if (byteIndex >= StreamedStringBufferLength) {             // Write bytes retrieved so far             if (!streaming) {               stream.WriteByte((byte)0x7f);             }             WritePositiveInt(3' byteIndex' stream);             stream.Write(bytes' 0' byteIndex);             byteIndex = 0;             streaming = true;           }           bytes[byteIndex++] = (byte)c;         } else if (c <= 0x7ff) {           if (byteIndex + 2 > StreamedStringBufferLength) {             // Write bytes retrieved so far - the next three bytes             // would exceed the length' and the CBOR spec forbids             // splitting characters when generating text strings             if (!streaming) {               stream.WriteByte((byte)0x7f);             }             WritePositiveInt(3' byteIndex' stream);             stream.Write(bytes' 0' byteIndex);             byteIndex = 0;             streaming = true;           }           bytes[byteIndex++] = (byte)(0xc0 | ((c >> 6) & 0x1f));           bytes[byteIndex++] = (byte)(0x80 | (c & 0x3f));         } else {           if ((c & 0xfc00) == 0xd800 && index + 1 < str.Length &&               str[index + 1] >= 0xdc00 && str[index + 1] <= 0xdfff) {             // Get the Unicode code point for the surrogate pair             c = 0x10000 + ((c - 0xd800) << 10) + (str[index + 1] - 0xdc00);             ++index;           } else if ((c & 0xf800) == 0xd800) {             // unpaired surrogate' write U + FFFD instead             c = 0xfffd;           }           if (c <= 0xffff) {             if (byteIndex + 3 > StreamedStringBufferLength) {               // Write bytes retrieved so far - the next three bytes               // would exceed the length' and the CBOR spec forbids               // splitting characters when generating text strings               if (!streaming) {                 stream.WriteByte((byte)0x7f);               }               WritePositiveInt(3' byteIndex' stream);               stream.Write(bytes' 0' byteIndex);               byteIndex = 0;               streaming = true;             }             bytes[byteIndex++] = (byte)(0xe0 | ((c >> 12) & 0x0f));             bytes[byteIndex++] = (byte)(0x80 | ((c >> 6) & 0x3f));             bytes[byteIndex++] = (byte)(0x80 | (c & 0x3f));           } else {             if (byteIndex + 4 > StreamedStringBufferLength) {               // Write bytes retrieved so far - the next four bytes               // would exceed the length' and the CBOR spec forbids               // splitting characters when generating text strings               if (!streaming) {                 stream.WriteByte((byte)0x7f);               }               WritePositiveInt(3' byteIndex' stream);               stream.Write(bytes' 0' byteIndex);               byteIndex = 0;               streaming = true;             }             bytes[byteIndex++] = (byte)(0xf0 | ((c >> 18) & 0x07));             bytes[byteIndex++] = (byte)(0x80 | ((c >> 12) & 0x3f));             bytes[byteIndex++] = (byte)(0x80 | ((c >> 6) & 0x3f));             bytes[byteIndex++] = (byte)(0x80 | (c & 0x3f));           }         }       }
Magic Number,PeterO.Cbor,CBORObject,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORObject.cs,WriteStreamedString,The following statement contains a magic number: for (int index = 0; index < str.Length; ++index) {         int c = str[index];         if (c <= 0x7f) {           if (byteIndex >= StreamedStringBufferLength) {             // Write bytes retrieved so far             if (!streaming) {               stream.WriteByte((byte)0x7f);             }             WritePositiveInt(3' byteIndex' stream);             stream.Write(bytes' 0' byteIndex);             byteIndex = 0;             streaming = true;           }           bytes[byteIndex++] = (byte)c;         } else if (c <= 0x7ff) {           if (byteIndex + 2 > StreamedStringBufferLength) {             // Write bytes retrieved so far - the next three bytes             // would exceed the length' and the CBOR spec forbids             // splitting characters when generating text strings             if (!streaming) {               stream.WriteByte((byte)0x7f);             }             WritePositiveInt(3' byteIndex' stream);             stream.Write(bytes' 0' byteIndex);             byteIndex = 0;             streaming = true;           }           bytes[byteIndex++] = (byte)(0xc0 | ((c >> 6) & 0x1f));           bytes[byteIndex++] = (byte)(0x80 | (c & 0x3f));         } else {           if ((c & 0xfc00) == 0xd800 && index + 1 < str.Length &&               str[index + 1] >= 0xdc00 && str[index + 1] <= 0xdfff) {             // Get the Unicode code point for the surrogate pair             c = 0x10000 + ((c - 0xd800) << 10) + (str[index + 1] - 0xdc00);             ++index;           } else if ((c & 0xf800) == 0xd800) {             // unpaired surrogate' write U + FFFD instead             c = 0xfffd;           }           if (c <= 0xffff) {             if (byteIndex + 3 > StreamedStringBufferLength) {               // Write bytes retrieved so far - the next three bytes               // would exceed the length' and the CBOR spec forbids               // splitting characters when generating text strings               if (!streaming) {                 stream.WriteByte((byte)0x7f);               }               WritePositiveInt(3' byteIndex' stream);               stream.Write(bytes' 0' byteIndex);               byteIndex = 0;               streaming = true;             }             bytes[byteIndex++] = (byte)(0xe0 | ((c >> 12) & 0x0f));             bytes[byteIndex++] = (byte)(0x80 | ((c >> 6) & 0x3f));             bytes[byteIndex++] = (byte)(0x80 | (c & 0x3f));           } else {             if (byteIndex + 4 > StreamedStringBufferLength) {               // Write bytes retrieved so far - the next four bytes               // would exceed the length' and the CBOR spec forbids               // splitting characters when generating text strings               if (!streaming) {                 stream.WriteByte((byte)0x7f);               }               WritePositiveInt(3' byteIndex' stream);               stream.Write(bytes' 0' byteIndex);               byteIndex = 0;               streaming = true;             }             bytes[byteIndex++] = (byte)(0xf0 | ((c >> 18) & 0x07));             bytes[byteIndex++] = (byte)(0x80 | ((c >> 12) & 0x3f));             bytes[byteIndex++] = (byte)(0x80 | ((c >> 6) & 0x3f));             bytes[byteIndex++] = (byte)(0x80 | (c & 0x3f));           }         }       }
Magic Number,PeterO.Cbor,CBORObject,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORObject.cs,WriteStreamedString,The following statement contains a magic number: for (int index = 0; index < str.Length; ++index) {         int c = str[index];         if (c <= 0x7f) {           if (byteIndex >= StreamedStringBufferLength) {             // Write bytes retrieved so far             if (!streaming) {               stream.WriteByte((byte)0x7f);             }             WritePositiveInt(3' byteIndex' stream);             stream.Write(bytes' 0' byteIndex);             byteIndex = 0;             streaming = true;           }           bytes[byteIndex++] = (byte)c;         } else if (c <= 0x7ff) {           if (byteIndex + 2 > StreamedStringBufferLength) {             // Write bytes retrieved so far - the next three bytes             // would exceed the length' and the CBOR spec forbids             // splitting characters when generating text strings             if (!streaming) {               stream.WriteByte((byte)0x7f);             }             WritePositiveInt(3' byteIndex' stream);             stream.Write(bytes' 0' byteIndex);             byteIndex = 0;             streaming = true;           }           bytes[byteIndex++] = (byte)(0xc0 | ((c >> 6) & 0x1f));           bytes[byteIndex++] = (byte)(0x80 | (c & 0x3f));         } else {           if ((c & 0xfc00) == 0xd800 && index + 1 < str.Length &&               str[index + 1] >= 0xdc00 && str[index + 1] <= 0xdfff) {             // Get the Unicode code point for the surrogate pair             c = 0x10000 + ((c - 0xd800) << 10) + (str[index + 1] - 0xdc00);             ++index;           } else if ((c & 0xf800) == 0xd800) {             // unpaired surrogate' write U + FFFD instead             c = 0xfffd;           }           if (c <= 0xffff) {             if (byteIndex + 3 > StreamedStringBufferLength) {               // Write bytes retrieved so far - the next three bytes               // would exceed the length' and the CBOR spec forbids               // splitting characters when generating text strings               if (!streaming) {                 stream.WriteByte((byte)0x7f);               }               WritePositiveInt(3' byteIndex' stream);               stream.Write(bytes' 0' byteIndex);               byteIndex = 0;               streaming = true;             }             bytes[byteIndex++] = (byte)(0xe0 | ((c >> 12) & 0x0f));             bytes[byteIndex++] = (byte)(0x80 | ((c >> 6) & 0x3f));             bytes[byteIndex++] = (byte)(0x80 | (c & 0x3f));           } else {             if (byteIndex + 4 > StreamedStringBufferLength) {               // Write bytes retrieved so far - the next four bytes               // would exceed the length' and the CBOR spec forbids               // splitting characters when generating text strings               if (!streaming) {                 stream.WriteByte((byte)0x7f);               }               WritePositiveInt(3' byteIndex' stream);               stream.Write(bytes' 0' byteIndex);               byteIndex = 0;               streaming = true;             }             bytes[byteIndex++] = (byte)(0xf0 | ((c >> 18) & 0x07));             bytes[byteIndex++] = (byte)(0x80 | ((c >> 12) & 0x3f));             bytes[byteIndex++] = (byte)(0x80 | ((c >> 6) & 0x3f));             bytes[byteIndex++] = (byte)(0x80 | (c & 0x3f));           }         }       }
Magic Number,PeterO.Cbor,CBORObject,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORObject.cs,WriteStreamedString,The following statement contains a magic number: for (int index = 0; index < str.Length; ++index) {         int c = str[index];         if (c <= 0x7f) {           if (byteIndex >= StreamedStringBufferLength) {             // Write bytes retrieved so far             if (!streaming) {               stream.WriteByte((byte)0x7f);             }             WritePositiveInt(3' byteIndex' stream);             stream.Write(bytes' 0' byteIndex);             byteIndex = 0;             streaming = true;           }           bytes[byteIndex++] = (byte)c;         } else if (c <= 0x7ff) {           if (byteIndex + 2 > StreamedStringBufferLength) {             // Write bytes retrieved so far - the next three bytes             // would exceed the length' and the CBOR spec forbids             // splitting characters when generating text strings             if (!streaming) {               stream.WriteByte((byte)0x7f);             }             WritePositiveInt(3' byteIndex' stream);             stream.Write(bytes' 0' byteIndex);             byteIndex = 0;             streaming = true;           }           bytes[byteIndex++] = (byte)(0xc0 | ((c >> 6) & 0x1f));           bytes[byteIndex++] = (byte)(0x80 | (c & 0x3f));         } else {           if ((c & 0xfc00) == 0xd800 && index + 1 < str.Length &&               str[index + 1] >= 0xdc00 && str[index + 1] <= 0xdfff) {             // Get the Unicode code point for the surrogate pair             c = 0x10000 + ((c - 0xd800) << 10) + (str[index + 1] - 0xdc00);             ++index;           } else if ((c & 0xf800) == 0xd800) {             // unpaired surrogate' write U + FFFD instead             c = 0xfffd;           }           if (c <= 0xffff) {             if (byteIndex + 3 > StreamedStringBufferLength) {               // Write bytes retrieved so far - the next three bytes               // would exceed the length' and the CBOR spec forbids               // splitting characters when generating text strings               if (!streaming) {                 stream.WriteByte((byte)0x7f);               }               WritePositiveInt(3' byteIndex' stream);               stream.Write(bytes' 0' byteIndex);               byteIndex = 0;               streaming = true;             }             bytes[byteIndex++] = (byte)(0xe0 | ((c >> 12) & 0x0f));             bytes[byteIndex++] = (byte)(0x80 | ((c >> 6) & 0x3f));             bytes[byteIndex++] = (byte)(0x80 | (c & 0x3f));           } else {             if (byteIndex + 4 > StreamedStringBufferLength) {               // Write bytes retrieved so far - the next four bytes               // would exceed the length' and the CBOR spec forbids               // splitting characters when generating text strings               if (!streaming) {                 stream.WriteByte((byte)0x7f);               }               WritePositiveInt(3' byteIndex' stream);               stream.Write(bytes' 0' byteIndex);               byteIndex = 0;               streaming = true;             }             bytes[byteIndex++] = (byte)(0xf0 | ((c >> 18) & 0x07));             bytes[byteIndex++] = (byte)(0x80 | ((c >> 12) & 0x3f));             bytes[byteIndex++] = (byte)(0x80 | ((c >> 6) & 0x3f));             bytes[byteIndex++] = (byte)(0x80 | (c & 0x3f));           }         }       }
Magic Number,PeterO.Cbor,CBORObject,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORObject.cs,WriteStreamedString,The following statement contains a magic number: for (int index = 0; index < str.Length; ++index) {         int c = str[index];         if (c <= 0x7f) {           if (byteIndex >= StreamedStringBufferLength) {             // Write bytes retrieved so far             if (!streaming) {               stream.WriteByte((byte)0x7f);             }             WritePositiveInt(3' byteIndex' stream);             stream.Write(bytes' 0' byteIndex);             byteIndex = 0;             streaming = true;           }           bytes[byteIndex++] = (byte)c;         } else if (c <= 0x7ff) {           if (byteIndex + 2 > StreamedStringBufferLength) {             // Write bytes retrieved so far - the next three bytes             // would exceed the length' and the CBOR spec forbids             // splitting characters when generating text strings             if (!streaming) {               stream.WriteByte((byte)0x7f);             }             WritePositiveInt(3' byteIndex' stream);             stream.Write(bytes' 0' byteIndex);             byteIndex = 0;             streaming = true;           }           bytes[byteIndex++] = (byte)(0xc0 | ((c >> 6) & 0x1f));           bytes[byteIndex++] = (byte)(0x80 | (c & 0x3f));         } else {           if ((c & 0xfc00) == 0xd800 && index + 1 < str.Length &&               str[index + 1] >= 0xdc00 && str[index + 1] <= 0xdfff) {             // Get the Unicode code point for the surrogate pair             c = 0x10000 + ((c - 0xd800) << 10) + (str[index + 1] - 0xdc00);             ++index;           } else if ((c & 0xf800) == 0xd800) {             // unpaired surrogate' write U + FFFD instead             c = 0xfffd;           }           if (c <= 0xffff) {             if (byteIndex + 3 > StreamedStringBufferLength) {               // Write bytes retrieved so far - the next three bytes               // would exceed the length' and the CBOR spec forbids               // splitting characters when generating text strings               if (!streaming) {                 stream.WriteByte((byte)0x7f);               }               WritePositiveInt(3' byteIndex' stream);               stream.Write(bytes' 0' byteIndex);               byteIndex = 0;               streaming = true;             }             bytes[byteIndex++] = (byte)(0xe0 | ((c >> 12) & 0x0f));             bytes[byteIndex++] = (byte)(0x80 | ((c >> 6) & 0x3f));             bytes[byteIndex++] = (byte)(0x80 | (c & 0x3f));           } else {             if (byteIndex + 4 > StreamedStringBufferLength) {               // Write bytes retrieved so far - the next four bytes               // would exceed the length' and the CBOR spec forbids               // splitting characters when generating text strings               if (!streaming) {                 stream.WriteByte((byte)0x7f);               }               WritePositiveInt(3' byteIndex' stream);               stream.Write(bytes' 0' byteIndex);               byteIndex = 0;               streaming = true;             }             bytes[byteIndex++] = (byte)(0xf0 | ((c >> 18) & 0x07));             bytes[byteIndex++] = (byte)(0x80 | ((c >> 12) & 0x3f));             bytes[byteIndex++] = (byte)(0x80 | ((c >> 6) & 0x3f));             bytes[byteIndex++] = (byte)(0x80 | (c & 0x3f));           }         }       }
Magic Number,PeterO.Cbor,CBORObject,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORObject.cs,WriteStreamedString,The following statement contains a magic number: WritePositiveInt(3' byteIndex' stream);
Magic Number,PeterO.Cbor,CBORObject,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORObject.cs,AppendOpeningTags,The following statement contains a magic number: while (curobject.IsTagged) {         int low = curobject.tagLow;         int high = curobject.tagHigh;         if (high == 0 && (low >> 16) == 0) {           sb.Append(CBORUtilities.LongToString(low));         } else {           EInteger bi = LowHighToEInteger(low' high);           sb.Append(CBORUtilities.BigIntToString(bi));         }         sb.Append('(');         curobject = (CBORObject)curobject.itemValue;       }
Magic Number,PeterO.Cbor,CBORObject,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORObject.cs,WriteTags,The following statement contains a magic number: while (curobject.IsTagged) {         int low = curobject.tagLow;         int high = curobject.tagHigh;         if (high == 0 && (low >> 16) == 0) {           WritePositiveInt(6' low' s);         } else if (high == 0) {           long value = ((long)low) & 0xffffffffL;           WritePositiveInt64(6' value' s);         } else if ((high >> 16) == 0) {           long value = ((long)low) & 0xffffffffL;           long highValue = ((long)high) & 0xffffffffL;           value |= highValue << 32;           WritePositiveInt64(6' value' s);         } else {           byte[] arrayToWrite = { (byte)0xdb'             (byte)((high >> 24) & 0xff)' (byte)((high >> 16) & 0xff)'             (byte)((high >> 8) & 0xff)' (byte)(high & 0xff)'             (byte)((low >> 24) & 0xff)' (byte)((low >> 16) & 0xff)'             (byte)((low >> 8) & 0xff)' (byte)(low & 0xff) };           s.Write(arrayToWrite' 0' 9);         }         curobject = (CBORObject)curobject.itemValue;       }
Magic Number,PeterO.Cbor,CBORObject,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORObject.cs,WriteTags,The following statement contains a magic number: while (curobject.IsTagged) {         int low = curobject.tagLow;         int high = curobject.tagHigh;         if (high == 0 && (low >> 16) == 0) {           WritePositiveInt(6' low' s);         } else if (high == 0) {           long value = ((long)low) & 0xffffffffL;           WritePositiveInt64(6' value' s);         } else if ((high >> 16) == 0) {           long value = ((long)low) & 0xffffffffL;           long highValue = ((long)high) & 0xffffffffL;           value |= highValue << 32;           WritePositiveInt64(6' value' s);         } else {           byte[] arrayToWrite = { (byte)0xdb'             (byte)((high >> 24) & 0xff)' (byte)((high >> 16) & 0xff)'             (byte)((high >> 8) & 0xff)' (byte)(high & 0xff)'             (byte)((low >> 24) & 0xff)' (byte)((low >> 16) & 0xff)'             (byte)((low >> 8) & 0xff)' (byte)(low & 0xff) };           s.Write(arrayToWrite' 0' 9);         }         curobject = (CBORObject)curobject.itemValue;       }
Magic Number,PeterO.Cbor,CBORObject,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORObject.cs,WriteTags,The following statement contains a magic number: while (curobject.IsTagged) {         int low = curobject.tagLow;         int high = curobject.tagHigh;         if (high == 0 && (low >> 16) == 0) {           WritePositiveInt(6' low' s);         } else if (high == 0) {           long value = ((long)low) & 0xffffffffL;           WritePositiveInt64(6' value' s);         } else if ((high >> 16) == 0) {           long value = ((long)low) & 0xffffffffL;           long highValue = ((long)high) & 0xffffffffL;           value |= highValue << 32;           WritePositiveInt64(6' value' s);         } else {           byte[] arrayToWrite = { (byte)0xdb'             (byte)((high >> 24) & 0xff)' (byte)((high >> 16) & 0xff)'             (byte)((high >> 8) & 0xff)' (byte)(high & 0xff)'             (byte)((low >> 24) & 0xff)' (byte)((low >> 16) & 0xff)'             (byte)((low >> 8) & 0xff)' (byte)(low & 0xff) };           s.Write(arrayToWrite' 0' 9);         }         curobject = (CBORObject)curobject.itemValue;       }
Magic Number,PeterO.Cbor,CBORObject,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORObject.cs,WriteTags,The following statement contains a magic number: while (curobject.IsTagged) {         int low = curobject.tagLow;         int high = curobject.tagHigh;         if (high == 0 && (low >> 16) == 0) {           WritePositiveInt(6' low' s);         } else if (high == 0) {           long value = ((long)low) & 0xffffffffL;           WritePositiveInt64(6' value' s);         } else if ((high >> 16) == 0) {           long value = ((long)low) & 0xffffffffL;           long highValue = ((long)high) & 0xffffffffL;           value |= highValue << 32;           WritePositiveInt64(6' value' s);         } else {           byte[] arrayToWrite = { (byte)0xdb'             (byte)((high >> 24) & 0xff)' (byte)((high >> 16) & 0xff)'             (byte)((high >> 8) & 0xff)' (byte)(high & 0xff)'             (byte)((low >> 24) & 0xff)' (byte)((low >> 16) & 0xff)'             (byte)((low >> 8) & 0xff)' (byte)(low & 0xff) };           s.Write(arrayToWrite' 0' 9);         }         curobject = (CBORObject)curobject.itemValue;       }
Magic Number,PeterO.Cbor,CBORObject,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORObject.cs,WriteTags,The following statement contains a magic number: while (curobject.IsTagged) {         int low = curobject.tagLow;         int high = curobject.tagHigh;         if (high == 0 && (low >> 16) == 0) {           WritePositiveInt(6' low' s);         } else if (high == 0) {           long value = ((long)low) & 0xffffffffL;           WritePositiveInt64(6' value' s);         } else if ((high >> 16) == 0) {           long value = ((long)low) & 0xffffffffL;           long highValue = ((long)high) & 0xffffffffL;           value |= highValue << 32;           WritePositiveInt64(6' value' s);         } else {           byte[] arrayToWrite = { (byte)0xdb'             (byte)((high >> 24) & 0xff)' (byte)((high >> 16) & 0xff)'             (byte)((high >> 8) & 0xff)' (byte)(high & 0xff)'             (byte)((low >> 24) & 0xff)' (byte)((low >> 16) & 0xff)'             (byte)((low >> 8) & 0xff)' (byte)(low & 0xff) };           s.Write(arrayToWrite' 0' 9);         }         curobject = (CBORObject)curobject.itemValue;       }
Magic Number,PeterO.Cbor,CBORObject,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORObject.cs,WriteTags,The following statement contains a magic number: while (curobject.IsTagged) {         int low = curobject.tagLow;         int high = curobject.tagHigh;         if (high == 0 && (low >> 16) == 0) {           WritePositiveInt(6' low' s);         } else if (high == 0) {           long value = ((long)low) & 0xffffffffL;           WritePositiveInt64(6' value' s);         } else if ((high >> 16) == 0) {           long value = ((long)low) & 0xffffffffL;           long highValue = ((long)high) & 0xffffffffL;           value |= highValue << 32;           WritePositiveInt64(6' value' s);         } else {           byte[] arrayToWrite = { (byte)0xdb'             (byte)((high >> 24) & 0xff)' (byte)((high >> 16) & 0xff)'             (byte)((high >> 8) & 0xff)' (byte)(high & 0xff)'             (byte)((low >> 24) & 0xff)' (byte)((low >> 16) & 0xff)'             (byte)((low >> 8) & 0xff)' (byte)(low & 0xff) };           s.Write(arrayToWrite' 0' 9);         }         curobject = (CBORObject)curobject.itemValue;       }
Magic Number,PeterO.Cbor,CBORObject,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORObject.cs,WriteTags,The following statement contains a magic number: while (curobject.IsTagged) {         int low = curobject.tagLow;         int high = curobject.tagHigh;         if (high == 0 && (low >> 16) == 0) {           WritePositiveInt(6' low' s);         } else if (high == 0) {           long value = ((long)low) & 0xffffffffL;           WritePositiveInt64(6' value' s);         } else if ((high >> 16) == 0) {           long value = ((long)low) & 0xffffffffL;           long highValue = ((long)high) & 0xffffffffL;           value |= highValue << 32;           WritePositiveInt64(6' value' s);         } else {           byte[] arrayToWrite = { (byte)0xdb'             (byte)((high >> 24) & 0xff)' (byte)((high >> 16) & 0xff)'             (byte)((high >> 8) & 0xff)' (byte)(high & 0xff)'             (byte)((low >> 24) & 0xff)' (byte)((low >> 16) & 0xff)'             (byte)((low >> 8) & 0xff)' (byte)(low & 0xff) };           s.Write(arrayToWrite' 0' 9);         }         curobject = (CBORObject)curobject.itemValue;       }
Magic Number,PeterO.Cbor,CBORObject,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORObject.cs,WriteTags,The following statement contains a magic number: while (curobject.IsTagged) {         int low = curobject.tagLow;         int high = curobject.tagHigh;         if (high == 0 && (low >> 16) == 0) {           WritePositiveInt(6' low' s);         } else if (high == 0) {           long value = ((long)low) & 0xffffffffL;           WritePositiveInt64(6' value' s);         } else if ((high >> 16) == 0) {           long value = ((long)low) & 0xffffffffL;           long highValue = ((long)high) & 0xffffffffL;           value |= highValue << 32;           WritePositiveInt64(6' value' s);         } else {           byte[] arrayToWrite = { (byte)0xdb'             (byte)((high >> 24) & 0xff)' (byte)((high >> 16) & 0xff)'             (byte)((high >> 8) & 0xff)' (byte)(high & 0xff)'             (byte)((low >> 24) & 0xff)' (byte)((low >> 16) & 0xff)'             (byte)((low >> 8) & 0xff)' (byte)(low & 0xff) };           s.Write(arrayToWrite' 0' 9);         }         curobject = (CBORObject)curobject.itemValue;       }
Magic Number,PeterO.Cbor,CBORObject,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORObject.cs,WriteTags,The following statement contains a magic number: while (curobject.IsTagged) {         int low = curobject.tagLow;         int high = curobject.tagHigh;         if (high == 0 && (low >> 16) == 0) {           WritePositiveInt(6' low' s);         } else if (high == 0) {           long value = ((long)low) & 0xffffffffL;           WritePositiveInt64(6' value' s);         } else if ((high >> 16) == 0) {           long value = ((long)low) & 0xffffffffL;           long highValue = ((long)high) & 0xffffffffL;           value |= highValue << 32;           WritePositiveInt64(6' value' s);         } else {           byte[] arrayToWrite = { (byte)0xdb'             (byte)((high >> 24) & 0xff)' (byte)((high >> 16) & 0xff)'             (byte)((high >> 8) & 0xff)' (byte)(high & 0xff)'             (byte)((low >> 24) & 0xff)' (byte)((low >> 16) & 0xff)'             (byte)((low >> 8) & 0xff)' (byte)(low & 0xff) };           s.Write(arrayToWrite' 0' 9);         }         curobject = (CBORObject)curobject.itemValue;       }
Magic Number,PeterO.Cbor,CBORObject,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORObject.cs,WriteTags,The following statement contains a magic number: while (curobject.IsTagged) {         int low = curobject.tagLow;         int high = curobject.tagHigh;         if (high == 0 && (low >> 16) == 0) {           WritePositiveInt(6' low' s);         } else if (high == 0) {           long value = ((long)low) & 0xffffffffL;           WritePositiveInt64(6' value' s);         } else if ((high >> 16) == 0) {           long value = ((long)low) & 0xffffffffL;           long highValue = ((long)high) & 0xffffffffL;           value |= highValue << 32;           WritePositiveInt64(6' value' s);         } else {           byte[] arrayToWrite = { (byte)0xdb'             (byte)((high >> 24) & 0xff)' (byte)((high >> 16) & 0xff)'             (byte)((high >> 8) & 0xff)' (byte)(high & 0xff)'             (byte)((low >> 24) & 0xff)' (byte)((low >> 16) & 0xff)'             (byte)((low >> 8) & 0xff)' (byte)(low & 0xff) };           s.Write(arrayToWrite' 0' 9);         }         curobject = (CBORObject)curobject.itemValue;       }
Magic Number,PeterO.Cbor,CBORObject,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORObject.cs,WriteTags,The following statement contains a magic number: while (curobject.IsTagged) {         int low = curobject.tagLow;         int high = curobject.tagHigh;         if (high == 0 && (low >> 16) == 0) {           WritePositiveInt(6' low' s);         } else if (high == 0) {           long value = ((long)low) & 0xffffffffL;           WritePositiveInt64(6' value' s);         } else if ((high >> 16) == 0) {           long value = ((long)low) & 0xffffffffL;           long highValue = ((long)high) & 0xffffffffL;           value |= highValue << 32;           WritePositiveInt64(6' value' s);         } else {           byte[] arrayToWrite = { (byte)0xdb'             (byte)((high >> 24) & 0xff)' (byte)((high >> 16) & 0xff)'             (byte)((high >> 8) & 0xff)' (byte)(high & 0xff)'             (byte)((low >> 24) & 0xff)' (byte)((low >> 16) & 0xff)'             (byte)((low >> 8) & 0xff)' (byte)(low & 0xff) };           s.Write(arrayToWrite' 0' 9);         }         curobject = (CBORObject)curobject.itemValue;       }
Magic Number,PeterO.Cbor,CBORObject,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORObject.cs,WriteTags,The following statement contains a magic number: while (curobject.IsTagged) {         int low = curobject.tagLow;         int high = curobject.tagHigh;         if (high == 0 && (low >> 16) == 0) {           WritePositiveInt(6' low' s);         } else if (high == 0) {           long value = ((long)low) & 0xffffffffL;           WritePositiveInt64(6' value' s);         } else if ((high >> 16) == 0) {           long value = ((long)low) & 0xffffffffL;           long highValue = ((long)high) & 0xffffffffL;           value |= highValue << 32;           WritePositiveInt64(6' value' s);         } else {           byte[] arrayToWrite = { (byte)0xdb'             (byte)((high >> 24) & 0xff)' (byte)((high >> 16) & 0xff)'             (byte)((high >> 8) & 0xff)' (byte)(high & 0xff)'             (byte)((low >> 24) & 0xff)' (byte)((low >> 16) & 0xff)'             (byte)((low >> 8) & 0xff)' (byte)(low & 0xff) };           s.Write(arrayToWrite' 0' 9);         }         curobject = (CBORObject)curobject.itemValue;       }
Magic Number,PeterO.Cbor,CBORObject,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORObject.cs,WriteTags,The following statement contains a magic number: while (curobject.IsTagged) {         int low = curobject.tagLow;         int high = curobject.tagHigh;         if (high == 0 && (low >> 16) == 0) {           WritePositiveInt(6' low' s);         } else if (high == 0) {           long value = ((long)low) & 0xffffffffL;           WritePositiveInt64(6' value' s);         } else if ((high >> 16) == 0) {           long value = ((long)low) & 0xffffffffL;           long highValue = ((long)high) & 0xffffffffL;           value |= highValue << 32;           WritePositiveInt64(6' value' s);         } else {           byte[] arrayToWrite = { (byte)0xdb'             (byte)((high >> 24) & 0xff)' (byte)((high >> 16) & 0xff)'             (byte)((high >> 8) & 0xff)' (byte)(high & 0xff)'             (byte)((low >> 24) & 0xff)' (byte)((low >> 16) & 0xff)'             (byte)((low >> 8) & 0xff)' (byte)(low & 0xff) };           s.Write(arrayToWrite' 0' 9);         }         curobject = (CBORObject)curobject.itemValue;       }
Magic Number,PeterO.Cbor,CBORObject,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORObject.cs,AsUInt64,The following statement contains a magic number: if (bigint.Sign < 0 || bigint.GetSignedBitLength() > 64) {         throw new OverflowException("This object's value is out of range");       }
Magic Number,PeterO.Cbor,CBORObject,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORObject.cs,Write,The following statement contains a magic number: if (value <= Int64.MaxValue) {         Write((long)value' stream);       } else {         stream.WriteByte((byte)27);         stream.WriteByte((byte)((value >> 56) & 0xff));         stream.WriteByte((byte)((value >> 48) & 0xff));         stream.WriteByte((byte)((value >> 40) & 0xff));         stream.WriteByte((byte)((value >> 32) & 0xff));         stream.WriteByte((byte)((value >> 24) & 0xff));         stream.WriteByte((byte)((value >> 16) & 0xff));         stream.WriteByte((byte)((value >> 8) & 0xff));         stream.WriteByte((byte)(value & 0xff));       }
Magic Number,PeterO.Cbor,CBORObject,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORObject.cs,Write,The following statement contains a magic number: if (value <= Int64.MaxValue) {         Write((long)value' stream);       } else {         stream.WriteByte((byte)27);         stream.WriteByte((byte)((value >> 56) & 0xff));         stream.WriteByte((byte)((value >> 48) & 0xff));         stream.WriteByte((byte)((value >> 40) & 0xff));         stream.WriteByte((byte)((value >> 32) & 0xff));         stream.WriteByte((byte)((value >> 24) & 0xff));         stream.WriteByte((byte)((value >> 16) & 0xff));         stream.WriteByte((byte)((value >> 8) & 0xff));         stream.WriteByte((byte)(value & 0xff));       }
Magic Number,PeterO.Cbor,CBORObject,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORObject.cs,Write,The following statement contains a magic number: if (value <= Int64.MaxValue) {         Write((long)value' stream);       } else {         stream.WriteByte((byte)27);         stream.WriteByte((byte)((value >> 56) & 0xff));         stream.WriteByte((byte)((value >> 48) & 0xff));         stream.WriteByte((byte)((value >> 40) & 0xff));         stream.WriteByte((byte)((value >> 32) & 0xff));         stream.WriteByte((byte)((value >> 24) & 0xff));         stream.WriteByte((byte)((value >> 16) & 0xff));         stream.WriteByte((byte)((value >> 8) & 0xff));         stream.WriteByte((byte)(value & 0xff));       }
Magic Number,PeterO.Cbor,CBORObject,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORObject.cs,Write,The following statement contains a magic number: if (value <= Int64.MaxValue) {         Write((long)value' stream);       } else {         stream.WriteByte((byte)27);         stream.WriteByte((byte)((value >> 56) & 0xff));         stream.WriteByte((byte)((value >> 48) & 0xff));         stream.WriteByte((byte)((value >> 40) & 0xff));         stream.WriteByte((byte)((value >> 32) & 0xff));         stream.WriteByte((byte)((value >> 24) & 0xff));         stream.WriteByte((byte)((value >> 16) & 0xff));         stream.WriteByte((byte)((value >> 8) & 0xff));         stream.WriteByte((byte)(value & 0xff));       }
Magic Number,PeterO.Cbor,CBORObject,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORObject.cs,Write,The following statement contains a magic number: if (value <= Int64.MaxValue) {         Write((long)value' stream);       } else {         stream.WriteByte((byte)27);         stream.WriteByte((byte)((value >> 56) & 0xff));         stream.WriteByte((byte)((value >> 48) & 0xff));         stream.WriteByte((byte)((value >> 40) & 0xff));         stream.WriteByte((byte)((value >> 32) & 0xff));         stream.WriteByte((byte)((value >> 24) & 0xff));         stream.WriteByte((byte)((value >> 16) & 0xff));         stream.WriteByte((byte)((value >> 8) & 0xff));         stream.WriteByte((byte)(value & 0xff));       }
Magic Number,PeterO.Cbor,CBORObject,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORObject.cs,Write,The following statement contains a magic number: if (value <= Int64.MaxValue) {         Write((long)value' stream);       } else {         stream.WriteByte((byte)27);         stream.WriteByte((byte)((value >> 56) & 0xff));         stream.WriteByte((byte)((value >> 48) & 0xff));         stream.WriteByte((byte)((value >> 40) & 0xff));         stream.WriteByte((byte)((value >> 32) & 0xff));         stream.WriteByte((byte)((value >> 24) & 0xff));         stream.WriteByte((byte)((value >> 16) & 0xff));         stream.WriteByte((byte)((value >> 8) & 0xff));         stream.WriteByte((byte)(value & 0xff));       }
Magic Number,PeterO.Cbor,CBORObject,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORObject.cs,Write,The following statement contains a magic number: if (value <= Int64.MaxValue) {         Write((long)value' stream);       } else {         stream.WriteByte((byte)27);         stream.WriteByte((byte)((value >> 56) & 0xff));         stream.WriteByte((byte)((value >> 48) & 0xff));         stream.WriteByte((byte)((value >> 40) & 0xff));         stream.WriteByte((byte)((value >> 32) & 0xff));         stream.WriteByte((byte)((value >> 24) & 0xff));         stream.WriteByte((byte)((value >> 16) & 0xff));         stream.WriteByte((byte)((value >> 8) & 0xff));         stream.WriteByte((byte)(value & 0xff));       }
Magic Number,PeterO.Cbor,CBORObject,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORObject.cs,Write,The following statement contains a magic number: if (value <= Int64.MaxValue) {         Write((long)value' stream);       } else {         stream.WriteByte((byte)27);         stream.WriteByte((byte)((value >> 56) & 0xff));         stream.WriteByte((byte)((value >> 48) & 0xff));         stream.WriteByte((byte)((value >> 40) & 0xff));         stream.WriteByte((byte)((value >> 32) & 0xff));         stream.WriteByte((byte)((value >> 24) & 0xff));         stream.WriteByte((byte)((value >> 16) & 0xff));         stream.WriteByte((byte)((value >> 8) & 0xff));         stream.WriteByte((byte)(value & 0xff));       }
Magic Number,PeterO.Cbor,CBORObject,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORObject.cs,UInt64ToEInteger,The following statement contains a magic number: var data = new byte[9];
Magic Number,PeterO.Cbor,CBORObject,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORObject.cs,UInt64ToEInteger,The following statement contains a magic number: data[1] = (byte)((uvalue >> 8) & 0xff);
Magic Number,PeterO.Cbor,CBORObject,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORObject.cs,UInt64ToEInteger,The following statement contains a magic number: data[2] = (byte)((uvalue >> 16) & 0xff);
Magic Number,PeterO.Cbor,CBORObject,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORObject.cs,UInt64ToEInteger,The following statement contains a magic number: data[2] = (byte)((uvalue >> 16) & 0xff);
Magic Number,PeterO.Cbor,CBORObject,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORObject.cs,UInt64ToEInteger,The following statement contains a magic number: data[3] = (byte)((uvalue >> 24) & 0xff);
Magic Number,PeterO.Cbor,CBORObject,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORObject.cs,UInt64ToEInteger,The following statement contains a magic number: data[3] = (byte)((uvalue >> 24) & 0xff);
Magic Number,PeterO.Cbor,CBORObject,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORObject.cs,UInt64ToEInteger,The following statement contains a magic number: data[4] = (byte)((uvalue >> 32) & 0xff);
Magic Number,PeterO.Cbor,CBORObject,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORObject.cs,UInt64ToEInteger,The following statement contains a magic number: data[4] = (byte)((uvalue >> 32) & 0xff);
Magic Number,PeterO.Cbor,CBORObject,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORObject.cs,UInt64ToEInteger,The following statement contains a magic number: data[5] = (byte)((uvalue >> 40) & 0xff);
Magic Number,PeterO.Cbor,CBORObject,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORObject.cs,UInt64ToEInteger,The following statement contains a magic number: data[5] = (byte)((uvalue >> 40) & 0xff);
Magic Number,PeterO.Cbor,CBORObject,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORObject.cs,UInt64ToEInteger,The following statement contains a magic number: data[6] = (byte)((uvalue >> 48) & 0xff);
Magic Number,PeterO.Cbor,CBORObject,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORObject.cs,UInt64ToEInteger,The following statement contains a magic number: data[6] = (byte)((uvalue >> 48) & 0xff);
Magic Number,PeterO.Cbor,CBORObject,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORObject.cs,UInt64ToEInteger,The following statement contains a magic number: data[7] = (byte)((uvalue >> 56) & 0xff);
Magic Number,PeterO.Cbor,CBORObject,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORObject.cs,UInt64ToEInteger,The following statement contains a magic number: data[7] = (byte)((uvalue >> 56) & 0xff);
Magic Number,PeterO.Cbor,CBORObject,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORObject.cs,UInt64ToEInteger,The following statement contains a magic number: data[8] = (byte)0;
Magic Number,PeterO.Cbor,CBORReader,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORReader.cs,ResolveSharedRefs,The following statement contains a magic number: bool hasTag = obj.MostOuterTag.Equals((EInteger)29);
Magic Number,PeterO.Cbor,CBORReader,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORReader.cs,ResolveSharedRefs,The following statement contains a magic number: hasTag = obj.MostOuterTag.Equals((EInteger)28);
Magic Number,PeterO.Cbor,CBORReader,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORReader.cs,Read,The following statement contains a magic number: if (this.depth > 500) {         throw new CBORException("Too deeply nested");       }
Magic Number,PeterO.Cbor,CBORReader,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORReader.cs,ReadForFirstByte,The following statement contains a magic number: if (this.depth > 500) {         throw new CBORException("Too deeply nested");       }
Magic Number,PeterO.Cbor,CBORReader,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORReader.cs,ReadForFirstByte,The following statement contains a magic number: int type = (firstbyte >> 5) & 0x07;
Magic Number,PeterO.Cbor,CBORReader,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORReader.cs,ReadForFirstByte,The following statement contains a magic number: if (expectedLength != 0) {         data = new byte[expectedLength];         // include the first byte because GetFixedLengthObject         // will assume it exists for some head bytes         data[0] = unchecked((byte)firstbyte);         if (expectedLength > 1 &&             this.stream.Read(data' 1' expectedLength - 1) != expectedLength             - 1) {           throw new CBORException("Premature end of data");         }         CBORObject cbor = CBORObject.GetFixedLengthObject(firstbyte' data);         if (this.stringRefs != null && (type == 2 || type == 3)) {           this.stringRefs.AddStringIfNeeded(cbor' expectedLength - 1);         }         return cbor;       }
Magic Number,PeterO.Cbor,CBORReader,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORReader.cs,ReadForFirstByte,The following statement contains a magic number: if (expectedLength != 0) {         data = new byte[expectedLength];         // include the first byte because GetFixedLengthObject         // will assume it exists for some head bytes         data[0] = unchecked((byte)firstbyte);         if (expectedLength > 1 &&             this.stream.Read(data' 1' expectedLength - 1) != expectedLength             - 1) {           throw new CBORException("Premature end of data");         }         CBORObject cbor = CBORObject.GetFixedLengthObject(firstbyte' data);         if (this.stringRefs != null && (type == 2 || type == 3)) {           this.stringRefs.AddStringIfNeeded(cbor' expectedLength - 1);         }         return cbor;       }
Magic Number,PeterO.Cbor,CBORReader,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORReader.cs,ReadForFirstByte,The following statement contains a magic number: data = new byte[8];
Magic Number,PeterO.Cbor,CBORReader,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORReader.cs,ReadForFirstByte,The following statement contains a magic number: switch (firstbyte & 0x1f) {         case 24: {             int tmp = this.stream.ReadByte();             if (tmp < 0) {               throw new CBORException("Premature end of data");             }             lowAdditional = tmp;             uadditional = lowAdditional;             break;           }         case 25: {             if (this.stream.Read(data' 0' 2) != 2) {               throw new CBORException("Premature end of data");             }             lowAdditional = ((int)(data[0] & (int)0xff)) << 8;             lowAdditional |= (int)(data[1] & (int)0xff);             uadditional = lowAdditional;             break;           }         case 26: {             if (this.stream.Read(data' 0' 4) != 4) {               throw new CBORException("Premature end of data");             }             uadditional = ((long)(data[0] & (long)0xff)) << 24;             uadditional |= ((long)(data[1] & (long)0xff)) << 16;             uadditional |= ((long)(data[2] & (long)0xff)) << 8;             uadditional |= (long)(data[3] & (long)0xff);             break;           }         case 27: {             if (this.stream.Read(data' 0' 8) != 8) {               throw new CBORException("Premature end of data");             }             if ((((int)data[0]) & 0x80) != 0) {               // Won't fit in a signed 64-bit number               var uabytes = new byte[9];               uabytes[0] = data[7];               uabytes[1] = data[6];               uabytes[2] = data[5];               uabytes[3] = data[4];               uabytes[4] = data[3];               uabytes[5] = data[2];               uabytes[6] = data[1];               uabytes[7] = data[0];               uabytes[8] = 0;               hasBigAdditional = true;               bigintAdditional = EInteger.FromBytes(uabytes' true);             } else {               uadditional = ((long)(data[0] & (long)0xff)) << 56;               uadditional |= ((long)(data[1] & (long)0xff)) << 48;               uadditional |= ((long)(data[2] & (long)0xff)) << 40;               uadditional |= ((long)(data[3] & (long)0xff)) << 32;               uadditional |= ((long)(data[4] & (long)0xff)) << 24;               uadditional |= ((long)(data[5] & (long)0xff)) << 16;               uadditional |= ((long)(data[6] & (long)0xff)) << 8;               uadditional |= (long)(data[7] & (long)0xff);             }             break;           }       }
Magic Number,PeterO.Cbor,CBORReader,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORReader.cs,ReadForFirstByte,The following statement contains a magic number: switch (firstbyte & 0x1f) {         case 24: {             int tmp = this.stream.ReadByte();             if (tmp < 0) {               throw new CBORException("Premature end of data");             }             lowAdditional = tmp;             uadditional = lowAdditional;             break;           }         case 25: {             if (this.stream.Read(data' 0' 2) != 2) {               throw new CBORException("Premature end of data");             }             lowAdditional = ((int)(data[0] & (int)0xff)) << 8;             lowAdditional |= (int)(data[1] & (int)0xff);             uadditional = lowAdditional;             break;           }         case 26: {             if (this.stream.Read(data' 0' 4) != 4) {               throw new CBORException("Premature end of data");             }             uadditional = ((long)(data[0] & (long)0xff)) << 24;             uadditional |= ((long)(data[1] & (long)0xff)) << 16;             uadditional |= ((long)(data[2] & (long)0xff)) << 8;             uadditional |= (long)(data[3] & (long)0xff);             break;           }         case 27: {             if (this.stream.Read(data' 0' 8) != 8) {               throw new CBORException("Premature end of data");             }             if ((((int)data[0]) & 0x80) != 0) {               // Won't fit in a signed 64-bit number               var uabytes = new byte[9];               uabytes[0] = data[7];               uabytes[1] = data[6];               uabytes[2] = data[5];               uabytes[3] = data[4];               uabytes[4] = data[3];               uabytes[5] = data[2];               uabytes[6] = data[1];               uabytes[7] = data[0];               uabytes[8] = 0;               hasBigAdditional = true;               bigintAdditional = EInteger.FromBytes(uabytes' true);             } else {               uadditional = ((long)(data[0] & (long)0xff)) << 56;               uadditional |= ((long)(data[1] & (long)0xff)) << 48;               uadditional |= ((long)(data[2] & (long)0xff)) << 40;               uadditional |= ((long)(data[3] & (long)0xff)) << 32;               uadditional |= ((long)(data[4] & (long)0xff)) << 24;               uadditional |= ((long)(data[5] & (long)0xff)) << 16;               uadditional |= ((long)(data[6] & (long)0xff)) << 8;               uadditional |= (long)(data[7] & (long)0xff);             }             break;           }       }
Magic Number,PeterO.Cbor,CBORReader,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORReader.cs,ReadForFirstByte,The following statement contains a magic number: switch (firstbyte & 0x1f) {         case 24: {             int tmp = this.stream.ReadByte();             if (tmp < 0) {               throw new CBORException("Premature end of data");             }             lowAdditional = tmp;             uadditional = lowAdditional;             break;           }         case 25: {             if (this.stream.Read(data' 0' 2) != 2) {               throw new CBORException("Premature end of data");             }             lowAdditional = ((int)(data[0] & (int)0xff)) << 8;             lowAdditional |= (int)(data[1] & (int)0xff);             uadditional = lowAdditional;             break;           }         case 26: {             if (this.stream.Read(data' 0' 4) != 4) {               throw new CBORException("Premature end of data");             }             uadditional = ((long)(data[0] & (long)0xff)) << 24;             uadditional |= ((long)(data[1] & (long)0xff)) << 16;             uadditional |= ((long)(data[2] & (long)0xff)) << 8;             uadditional |= (long)(data[3] & (long)0xff);             break;           }         case 27: {             if (this.stream.Read(data' 0' 8) != 8) {               throw new CBORException("Premature end of data");             }             if ((((int)data[0]) & 0x80) != 0) {               // Won't fit in a signed 64-bit number               var uabytes = new byte[9];               uabytes[0] = data[7];               uabytes[1] = data[6];               uabytes[2] = data[5];               uabytes[3] = data[4];               uabytes[4] = data[3];               uabytes[5] = data[2];               uabytes[6] = data[1];               uabytes[7] = data[0];               uabytes[8] = 0;               hasBigAdditional = true;               bigintAdditional = EInteger.FromBytes(uabytes' true);             } else {               uadditional = ((long)(data[0] & (long)0xff)) << 56;               uadditional |= ((long)(data[1] & (long)0xff)) << 48;               uadditional |= ((long)(data[2] & (long)0xff)) << 40;               uadditional |= ((long)(data[3] & (long)0xff)) << 32;               uadditional |= ((long)(data[4] & (long)0xff)) << 24;               uadditional |= ((long)(data[5] & (long)0xff)) << 16;               uadditional |= ((long)(data[6] & (long)0xff)) << 8;               uadditional |= (long)(data[7] & (long)0xff);             }             break;           }       }
Magic Number,PeterO.Cbor,CBORReader,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORReader.cs,ReadForFirstByte,The following statement contains a magic number: switch (firstbyte & 0x1f) {         case 24: {             int tmp = this.stream.ReadByte();             if (tmp < 0) {               throw new CBORException("Premature end of data");             }             lowAdditional = tmp;             uadditional = lowAdditional;             break;           }         case 25: {             if (this.stream.Read(data' 0' 2) != 2) {               throw new CBORException("Premature end of data");             }             lowAdditional = ((int)(data[0] & (int)0xff)) << 8;             lowAdditional |= (int)(data[1] & (int)0xff);             uadditional = lowAdditional;             break;           }         case 26: {             if (this.stream.Read(data' 0' 4) != 4) {               throw new CBORException("Premature end of data");             }             uadditional = ((long)(data[0] & (long)0xff)) << 24;             uadditional |= ((long)(data[1] & (long)0xff)) << 16;             uadditional |= ((long)(data[2] & (long)0xff)) << 8;             uadditional |= (long)(data[3] & (long)0xff);             break;           }         case 27: {             if (this.stream.Read(data' 0' 8) != 8) {               throw new CBORException("Premature end of data");             }             if ((((int)data[0]) & 0x80) != 0) {               // Won't fit in a signed 64-bit number               var uabytes = new byte[9];               uabytes[0] = data[7];               uabytes[1] = data[6];               uabytes[2] = data[5];               uabytes[3] = data[4];               uabytes[4] = data[3];               uabytes[5] = data[2];               uabytes[6] = data[1];               uabytes[7] = data[0];               uabytes[8] = 0;               hasBigAdditional = true;               bigintAdditional = EInteger.FromBytes(uabytes' true);             } else {               uadditional = ((long)(data[0] & (long)0xff)) << 56;               uadditional |= ((long)(data[1] & (long)0xff)) << 48;               uadditional |= ((long)(data[2] & (long)0xff)) << 40;               uadditional |= ((long)(data[3] & (long)0xff)) << 32;               uadditional |= ((long)(data[4] & (long)0xff)) << 24;               uadditional |= ((long)(data[5] & (long)0xff)) << 16;               uadditional |= ((long)(data[6] & (long)0xff)) << 8;               uadditional |= (long)(data[7] & (long)0xff);             }             break;           }       }
Magic Number,PeterO.Cbor,CBORReader,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORReader.cs,ReadForFirstByte,The following statement contains a magic number: switch (firstbyte & 0x1f) {         case 24: {             int tmp = this.stream.ReadByte();             if (tmp < 0) {               throw new CBORException("Premature end of data");             }             lowAdditional = tmp;             uadditional = lowAdditional;             break;           }         case 25: {             if (this.stream.Read(data' 0' 2) != 2) {               throw new CBORException("Premature end of data");             }             lowAdditional = ((int)(data[0] & (int)0xff)) << 8;             lowAdditional |= (int)(data[1] & (int)0xff);             uadditional = lowAdditional;             break;           }         case 26: {             if (this.stream.Read(data' 0' 4) != 4) {               throw new CBORException("Premature end of data");             }             uadditional = ((long)(data[0] & (long)0xff)) << 24;             uadditional |= ((long)(data[1] & (long)0xff)) << 16;             uadditional |= ((long)(data[2] & (long)0xff)) << 8;             uadditional |= (long)(data[3] & (long)0xff);             break;           }         case 27: {             if (this.stream.Read(data' 0' 8) != 8) {               throw new CBORException("Premature end of data");             }             if ((((int)data[0]) & 0x80) != 0) {               // Won't fit in a signed 64-bit number               var uabytes = new byte[9];               uabytes[0] = data[7];               uabytes[1] = data[6];               uabytes[2] = data[5];               uabytes[3] = data[4];               uabytes[4] = data[3];               uabytes[5] = data[2];               uabytes[6] = data[1];               uabytes[7] = data[0];               uabytes[8] = 0;               hasBigAdditional = true;               bigintAdditional = EInteger.FromBytes(uabytes' true);             } else {               uadditional = ((long)(data[0] & (long)0xff)) << 56;               uadditional |= ((long)(data[1] & (long)0xff)) << 48;               uadditional |= ((long)(data[2] & (long)0xff)) << 40;               uadditional |= ((long)(data[3] & (long)0xff)) << 32;               uadditional |= ((long)(data[4] & (long)0xff)) << 24;               uadditional |= ((long)(data[5] & (long)0xff)) << 16;               uadditional |= ((long)(data[6] & (long)0xff)) << 8;               uadditional |= (long)(data[7] & (long)0xff);             }             break;           }       }
Magic Number,PeterO.Cbor,CBORReader,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORReader.cs,ReadForFirstByte,The following statement contains a magic number: switch (firstbyte & 0x1f) {         case 24: {             int tmp = this.stream.ReadByte();             if (tmp < 0) {               throw new CBORException("Premature end of data");             }             lowAdditional = tmp;             uadditional = lowAdditional;             break;           }         case 25: {             if (this.stream.Read(data' 0' 2) != 2) {               throw new CBORException("Premature end of data");             }             lowAdditional = ((int)(data[0] & (int)0xff)) << 8;             lowAdditional |= (int)(data[1] & (int)0xff);             uadditional = lowAdditional;             break;           }         case 26: {             if (this.stream.Read(data' 0' 4) != 4) {               throw new CBORException("Premature end of data");             }             uadditional = ((long)(data[0] & (long)0xff)) << 24;             uadditional |= ((long)(data[1] & (long)0xff)) << 16;             uadditional |= ((long)(data[2] & (long)0xff)) << 8;             uadditional |= (long)(data[3] & (long)0xff);             break;           }         case 27: {             if (this.stream.Read(data' 0' 8) != 8) {               throw new CBORException("Premature end of data");             }             if ((((int)data[0]) & 0x80) != 0) {               // Won't fit in a signed 64-bit number               var uabytes = new byte[9];               uabytes[0] = data[7];               uabytes[1] = data[6];               uabytes[2] = data[5];               uabytes[3] = data[4];               uabytes[4] = data[3];               uabytes[5] = data[2];               uabytes[6] = data[1];               uabytes[7] = data[0];               uabytes[8] = 0;               hasBigAdditional = true;               bigintAdditional = EInteger.FromBytes(uabytes' true);             } else {               uadditional = ((long)(data[0] & (long)0xff)) << 56;               uadditional |= ((long)(data[1] & (long)0xff)) << 48;               uadditional |= ((long)(data[2] & (long)0xff)) << 40;               uadditional |= ((long)(data[3] & (long)0xff)) << 32;               uadditional |= ((long)(data[4] & (long)0xff)) << 24;               uadditional |= ((long)(data[5] & (long)0xff)) << 16;               uadditional |= ((long)(data[6] & (long)0xff)) << 8;               uadditional |= (long)(data[7] & (long)0xff);             }             break;           }       }
Magic Number,PeterO.Cbor,CBORReader,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORReader.cs,ReadForFirstByte,The following statement contains a magic number: switch (firstbyte & 0x1f) {         case 24: {             int tmp = this.stream.ReadByte();             if (tmp < 0) {               throw new CBORException("Premature end of data");             }             lowAdditional = tmp;             uadditional = lowAdditional;             break;           }         case 25: {             if (this.stream.Read(data' 0' 2) != 2) {               throw new CBORException("Premature end of data");             }             lowAdditional = ((int)(data[0] & (int)0xff)) << 8;             lowAdditional |= (int)(data[1] & (int)0xff);             uadditional = lowAdditional;             break;           }         case 26: {             if (this.stream.Read(data' 0' 4) != 4) {               throw new CBORException("Premature end of data");             }             uadditional = ((long)(data[0] & (long)0xff)) << 24;             uadditional |= ((long)(data[1] & (long)0xff)) << 16;             uadditional |= ((long)(data[2] & (long)0xff)) << 8;             uadditional |= (long)(data[3] & (long)0xff);             break;           }         case 27: {             if (this.stream.Read(data' 0' 8) != 8) {               throw new CBORException("Premature end of data");             }             if ((((int)data[0]) & 0x80) != 0) {               // Won't fit in a signed 64-bit number               var uabytes = new byte[9];               uabytes[0] = data[7];               uabytes[1] = data[6];               uabytes[2] = data[5];               uabytes[3] = data[4];               uabytes[4] = data[3];               uabytes[5] = data[2];               uabytes[6] = data[1];               uabytes[7] = data[0];               uabytes[8] = 0;               hasBigAdditional = true;               bigintAdditional = EInteger.FromBytes(uabytes' true);             } else {               uadditional = ((long)(data[0] & (long)0xff)) << 56;               uadditional |= ((long)(data[1] & (long)0xff)) << 48;               uadditional |= ((long)(data[2] & (long)0xff)) << 40;               uadditional |= ((long)(data[3] & (long)0xff)) << 32;               uadditional |= ((long)(data[4] & (long)0xff)) << 24;               uadditional |= ((long)(data[5] & (long)0xff)) << 16;               uadditional |= ((long)(data[6] & (long)0xff)) << 8;               uadditional |= (long)(data[7] & (long)0xff);             }             break;           }       }
Magic Number,PeterO.Cbor,CBORReader,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORReader.cs,ReadForFirstByte,The following statement contains a magic number: switch (firstbyte & 0x1f) {         case 24: {             int tmp = this.stream.ReadByte();             if (tmp < 0) {               throw new CBORException("Premature end of data");             }             lowAdditional = tmp;             uadditional = lowAdditional;             break;           }         case 25: {             if (this.stream.Read(data' 0' 2) != 2) {               throw new CBORException("Premature end of data");             }             lowAdditional = ((int)(data[0] & (int)0xff)) << 8;             lowAdditional |= (int)(data[1] & (int)0xff);             uadditional = lowAdditional;             break;           }         case 26: {             if (this.stream.Read(data' 0' 4) != 4) {               throw new CBORException("Premature end of data");             }             uadditional = ((long)(data[0] & (long)0xff)) << 24;             uadditional |= ((long)(data[1] & (long)0xff)) << 16;             uadditional |= ((long)(data[2] & (long)0xff)) << 8;             uadditional |= (long)(data[3] & (long)0xff);             break;           }         case 27: {             if (this.stream.Read(data' 0' 8) != 8) {               throw new CBORException("Premature end of data");             }             if ((((int)data[0]) & 0x80) != 0) {               // Won't fit in a signed 64-bit number               var uabytes = new byte[9];               uabytes[0] = data[7];               uabytes[1] = data[6];               uabytes[2] = data[5];               uabytes[3] = data[4];               uabytes[4] = data[3];               uabytes[5] = data[2];               uabytes[6] = data[1];               uabytes[7] = data[0];               uabytes[8] = 0;               hasBigAdditional = true;               bigintAdditional = EInteger.FromBytes(uabytes' true);             } else {               uadditional = ((long)(data[0] & (long)0xff)) << 56;               uadditional |= ((long)(data[1] & (long)0xff)) << 48;               uadditional |= ((long)(data[2] & (long)0xff)) << 40;               uadditional |= ((long)(data[3] & (long)0xff)) << 32;               uadditional |= ((long)(data[4] & (long)0xff)) << 24;               uadditional |= ((long)(data[5] & (long)0xff)) << 16;               uadditional |= ((long)(data[6] & (long)0xff)) << 8;               uadditional |= (long)(data[7] & (long)0xff);             }             break;           }       }
Magic Number,PeterO.Cbor,CBORReader,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORReader.cs,ReadForFirstByte,The following statement contains a magic number: switch (firstbyte & 0x1f) {         case 24: {             int tmp = this.stream.ReadByte();             if (tmp < 0) {               throw new CBORException("Premature end of data");             }             lowAdditional = tmp;             uadditional = lowAdditional;             break;           }         case 25: {             if (this.stream.Read(data' 0' 2) != 2) {               throw new CBORException("Premature end of data");             }             lowAdditional = ((int)(data[0] & (int)0xff)) << 8;             lowAdditional |= (int)(data[1] & (int)0xff);             uadditional = lowAdditional;             break;           }         case 26: {             if (this.stream.Read(data' 0' 4) != 4) {               throw new CBORException("Premature end of data");             }             uadditional = ((long)(data[0] & (long)0xff)) << 24;             uadditional |= ((long)(data[1] & (long)0xff)) << 16;             uadditional |= ((long)(data[2] & (long)0xff)) << 8;             uadditional |= (long)(data[3] & (long)0xff);             break;           }         case 27: {             if (this.stream.Read(data' 0' 8) != 8) {               throw new CBORException("Premature end of data");             }             if ((((int)data[0]) & 0x80) != 0) {               // Won't fit in a signed 64-bit number               var uabytes = new byte[9];               uabytes[0] = data[7];               uabytes[1] = data[6];               uabytes[2] = data[5];               uabytes[3] = data[4];               uabytes[4] = data[3];               uabytes[5] = data[2];               uabytes[6] = data[1];               uabytes[7] = data[0];               uabytes[8] = 0;               hasBigAdditional = true;               bigintAdditional = EInteger.FromBytes(uabytes' true);             } else {               uadditional = ((long)(data[0] & (long)0xff)) << 56;               uadditional |= ((long)(data[1] & (long)0xff)) << 48;               uadditional |= ((long)(data[2] & (long)0xff)) << 40;               uadditional |= ((long)(data[3] & (long)0xff)) << 32;               uadditional |= ((long)(data[4] & (long)0xff)) << 24;               uadditional |= ((long)(data[5] & (long)0xff)) << 16;               uadditional |= ((long)(data[6] & (long)0xff)) << 8;               uadditional |= (long)(data[7] & (long)0xff);             }             break;           }       }
Magic Number,PeterO.Cbor,CBORReader,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORReader.cs,ReadForFirstByte,The following statement contains a magic number: switch (firstbyte & 0x1f) {         case 24: {             int tmp = this.stream.ReadByte();             if (tmp < 0) {               throw new CBORException("Premature end of data");             }             lowAdditional = tmp;             uadditional = lowAdditional;             break;           }         case 25: {             if (this.stream.Read(data' 0' 2) != 2) {               throw new CBORException("Premature end of data");             }             lowAdditional = ((int)(data[0] & (int)0xff)) << 8;             lowAdditional |= (int)(data[1] & (int)0xff);             uadditional = lowAdditional;             break;           }         case 26: {             if (this.stream.Read(data' 0' 4) != 4) {               throw new CBORException("Premature end of data");             }             uadditional = ((long)(data[0] & (long)0xff)) << 24;             uadditional |= ((long)(data[1] & (long)0xff)) << 16;             uadditional |= ((long)(data[2] & (long)0xff)) << 8;             uadditional |= (long)(data[3] & (long)0xff);             break;           }         case 27: {             if (this.stream.Read(data' 0' 8) != 8) {               throw new CBORException("Premature end of data");             }             if ((((int)data[0]) & 0x80) != 0) {               // Won't fit in a signed 64-bit number               var uabytes = new byte[9];               uabytes[0] = data[7];               uabytes[1] = data[6];               uabytes[2] = data[5];               uabytes[3] = data[4];               uabytes[4] = data[3];               uabytes[5] = data[2];               uabytes[6] = data[1];               uabytes[7] = data[0];               uabytes[8] = 0;               hasBigAdditional = true;               bigintAdditional = EInteger.FromBytes(uabytes' true);             } else {               uadditional = ((long)(data[0] & (long)0xff)) << 56;               uadditional |= ((long)(data[1] & (long)0xff)) << 48;               uadditional |= ((long)(data[2] & (long)0xff)) << 40;               uadditional |= ((long)(data[3] & (long)0xff)) << 32;               uadditional |= ((long)(data[4] & (long)0xff)) << 24;               uadditional |= ((long)(data[5] & (long)0xff)) << 16;               uadditional |= ((long)(data[6] & (long)0xff)) << 8;               uadditional |= (long)(data[7] & (long)0xff);             }             break;           }       }
Magic Number,PeterO.Cbor,CBORReader,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORReader.cs,ReadForFirstByte,The following statement contains a magic number: switch (firstbyte & 0x1f) {         case 24: {             int tmp = this.stream.ReadByte();             if (tmp < 0) {               throw new CBORException("Premature end of data");             }             lowAdditional = tmp;             uadditional = lowAdditional;             break;           }         case 25: {             if (this.stream.Read(data' 0' 2) != 2) {               throw new CBORException("Premature end of data");             }             lowAdditional = ((int)(data[0] & (int)0xff)) << 8;             lowAdditional |= (int)(data[1] & (int)0xff);             uadditional = lowAdditional;             break;           }         case 26: {             if (this.stream.Read(data' 0' 4) != 4) {               throw new CBORException("Premature end of data");             }             uadditional = ((long)(data[0] & (long)0xff)) << 24;             uadditional |= ((long)(data[1] & (long)0xff)) << 16;             uadditional |= ((long)(data[2] & (long)0xff)) << 8;             uadditional |= (long)(data[3] & (long)0xff);             break;           }         case 27: {             if (this.stream.Read(data' 0' 8) != 8) {               throw new CBORException("Premature end of data");             }             if ((((int)data[0]) & 0x80) != 0) {               // Won't fit in a signed 64-bit number               var uabytes = new byte[9];               uabytes[0] = data[7];               uabytes[1] = data[6];               uabytes[2] = data[5];               uabytes[3] = data[4];               uabytes[4] = data[3];               uabytes[5] = data[2];               uabytes[6] = data[1];               uabytes[7] = data[0];               uabytes[8] = 0;               hasBigAdditional = true;               bigintAdditional = EInteger.FromBytes(uabytes' true);             } else {               uadditional = ((long)(data[0] & (long)0xff)) << 56;               uadditional |= ((long)(data[1] & (long)0xff)) << 48;               uadditional |= ((long)(data[2] & (long)0xff)) << 40;               uadditional |= ((long)(data[3] & (long)0xff)) << 32;               uadditional |= ((long)(data[4] & (long)0xff)) << 24;               uadditional |= ((long)(data[5] & (long)0xff)) << 16;               uadditional |= ((long)(data[6] & (long)0xff)) << 8;               uadditional |= (long)(data[7] & (long)0xff);             }             break;           }       }
Magic Number,PeterO.Cbor,CBORReader,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORReader.cs,ReadForFirstByte,The following statement contains a magic number: switch (firstbyte & 0x1f) {         case 24: {             int tmp = this.stream.ReadByte();             if (tmp < 0) {               throw new CBORException("Premature end of data");             }             lowAdditional = tmp;             uadditional = lowAdditional;             break;           }         case 25: {             if (this.stream.Read(data' 0' 2) != 2) {               throw new CBORException("Premature end of data");             }             lowAdditional = ((int)(data[0] & (int)0xff)) << 8;             lowAdditional |= (int)(data[1] & (int)0xff);             uadditional = lowAdditional;             break;           }         case 26: {             if (this.stream.Read(data' 0' 4) != 4) {               throw new CBORException("Premature end of data");             }             uadditional = ((long)(data[0] & (long)0xff)) << 24;             uadditional |= ((long)(data[1] & (long)0xff)) << 16;             uadditional |= ((long)(data[2] & (long)0xff)) << 8;             uadditional |= (long)(data[3] & (long)0xff);             break;           }         case 27: {             if (this.stream.Read(data' 0' 8) != 8) {               throw new CBORException("Premature end of data");             }             if ((((int)data[0]) & 0x80) != 0) {               // Won't fit in a signed 64-bit number               var uabytes = new byte[9];               uabytes[0] = data[7];               uabytes[1] = data[6];               uabytes[2] = data[5];               uabytes[3] = data[4];               uabytes[4] = data[3];               uabytes[5] = data[2];               uabytes[6] = data[1];               uabytes[7] = data[0];               uabytes[8] = 0;               hasBigAdditional = true;               bigintAdditional = EInteger.FromBytes(uabytes' true);             } else {               uadditional = ((long)(data[0] & (long)0xff)) << 56;               uadditional |= ((long)(data[1] & (long)0xff)) << 48;               uadditional |= ((long)(data[2] & (long)0xff)) << 40;               uadditional |= ((long)(data[3] & (long)0xff)) << 32;               uadditional |= ((long)(data[4] & (long)0xff)) << 24;               uadditional |= ((long)(data[5] & (long)0xff)) << 16;               uadditional |= ((long)(data[6] & (long)0xff)) << 8;               uadditional |= (long)(data[7] & (long)0xff);             }             break;           }       }
Magic Number,PeterO.Cbor,CBORReader,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORReader.cs,ReadForFirstByte,The following statement contains a magic number: switch (firstbyte & 0x1f) {         case 24: {             int tmp = this.stream.ReadByte();             if (tmp < 0) {               throw new CBORException("Premature end of data");             }             lowAdditional = tmp;             uadditional = lowAdditional;             break;           }         case 25: {             if (this.stream.Read(data' 0' 2) != 2) {               throw new CBORException("Premature end of data");             }             lowAdditional = ((int)(data[0] & (int)0xff)) << 8;             lowAdditional |= (int)(data[1] & (int)0xff);             uadditional = lowAdditional;             break;           }         case 26: {             if (this.stream.Read(data' 0' 4) != 4) {               throw new CBORException("Premature end of data");             }             uadditional = ((long)(data[0] & (long)0xff)) << 24;             uadditional |= ((long)(data[1] & (long)0xff)) << 16;             uadditional |= ((long)(data[2] & (long)0xff)) << 8;             uadditional |= (long)(data[3] & (long)0xff);             break;           }         case 27: {             if (this.stream.Read(data' 0' 8) != 8) {               throw new CBORException("Premature end of data");             }             if ((((int)data[0]) & 0x80) != 0) {               // Won't fit in a signed 64-bit number               var uabytes = new byte[9];               uabytes[0] = data[7];               uabytes[1] = data[6];               uabytes[2] = data[5];               uabytes[3] = data[4];               uabytes[4] = data[3];               uabytes[5] = data[2];               uabytes[6] = data[1];               uabytes[7] = data[0];               uabytes[8] = 0;               hasBigAdditional = true;               bigintAdditional = EInteger.FromBytes(uabytes' true);             } else {               uadditional = ((long)(data[0] & (long)0xff)) << 56;               uadditional |= ((long)(data[1] & (long)0xff)) << 48;               uadditional |= ((long)(data[2] & (long)0xff)) << 40;               uadditional |= ((long)(data[3] & (long)0xff)) << 32;               uadditional |= ((long)(data[4] & (long)0xff)) << 24;               uadditional |= ((long)(data[5] & (long)0xff)) << 16;               uadditional |= ((long)(data[6] & (long)0xff)) << 8;               uadditional |= (long)(data[7] & (long)0xff);             }             break;           }       }
Magic Number,PeterO.Cbor,CBORReader,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORReader.cs,ReadForFirstByte,The following statement contains a magic number: switch (firstbyte & 0x1f) {         case 24: {             int tmp = this.stream.ReadByte();             if (tmp < 0) {               throw new CBORException("Premature end of data");             }             lowAdditional = tmp;             uadditional = lowAdditional;             break;           }         case 25: {             if (this.stream.Read(data' 0' 2) != 2) {               throw new CBORException("Premature end of data");             }             lowAdditional = ((int)(data[0] & (int)0xff)) << 8;             lowAdditional |= (int)(data[1] & (int)0xff);             uadditional = lowAdditional;             break;           }         case 26: {             if (this.stream.Read(data' 0' 4) != 4) {               throw new CBORException("Premature end of data");             }             uadditional = ((long)(data[0] & (long)0xff)) << 24;             uadditional |= ((long)(data[1] & (long)0xff)) << 16;             uadditional |= ((long)(data[2] & (long)0xff)) << 8;             uadditional |= (long)(data[3] & (long)0xff);             break;           }         case 27: {             if (this.stream.Read(data' 0' 8) != 8) {               throw new CBORException("Premature end of data");             }             if ((((int)data[0]) & 0x80) != 0) {               // Won't fit in a signed 64-bit number               var uabytes = new byte[9];               uabytes[0] = data[7];               uabytes[1] = data[6];               uabytes[2] = data[5];               uabytes[3] = data[4];               uabytes[4] = data[3];               uabytes[5] = data[2];               uabytes[6] = data[1];               uabytes[7] = data[0];               uabytes[8] = 0;               hasBigAdditional = true;               bigintAdditional = EInteger.FromBytes(uabytes' true);             } else {               uadditional = ((long)(data[0] & (long)0xff)) << 56;               uadditional |= ((long)(data[1] & (long)0xff)) << 48;               uadditional |= ((long)(data[2] & (long)0xff)) << 40;               uadditional |= ((long)(data[3] & (long)0xff)) << 32;               uadditional |= ((long)(data[4] & (long)0xff)) << 24;               uadditional |= ((long)(data[5] & (long)0xff)) << 16;               uadditional |= ((long)(data[6] & (long)0xff)) << 8;               uadditional |= (long)(data[7] & (long)0xff);             }             break;           }       }
Magic Number,PeterO.Cbor,CBORReader,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORReader.cs,ReadForFirstByte,The following statement contains a magic number: switch (firstbyte & 0x1f) {         case 24: {             int tmp = this.stream.ReadByte();             if (tmp < 0) {               throw new CBORException("Premature end of data");             }             lowAdditional = tmp;             uadditional = lowAdditional;             break;           }         case 25: {             if (this.stream.Read(data' 0' 2) != 2) {               throw new CBORException("Premature end of data");             }             lowAdditional = ((int)(data[0] & (int)0xff)) << 8;             lowAdditional |= (int)(data[1] & (int)0xff);             uadditional = lowAdditional;             break;           }         case 26: {             if (this.stream.Read(data' 0' 4) != 4) {               throw new CBORException("Premature end of data");             }             uadditional = ((long)(data[0] & (long)0xff)) << 24;             uadditional |= ((long)(data[1] & (long)0xff)) << 16;             uadditional |= ((long)(data[2] & (long)0xff)) << 8;             uadditional |= (long)(data[3] & (long)0xff);             break;           }         case 27: {             if (this.stream.Read(data' 0' 8) != 8) {               throw new CBORException("Premature end of data");             }             if ((((int)data[0]) & 0x80) != 0) {               // Won't fit in a signed 64-bit number               var uabytes = new byte[9];               uabytes[0] = data[7];               uabytes[1] = data[6];               uabytes[2] = data[5];               uabytes[3] = data[4];               uabytes[4] = data[3];               uabytes[5] = data[2];               uabytes[6] = data[1];               uabytes[7] = data[0];               uabytes[8] = 0;               hasBigAdditional = true;               bigintAdditional = EInteger.FromBytes(uabytes' true);             } else {               uadditional = ((long)(data[0] & (long)0xff)) << 56;               uadditional |= ((long)(data[1] & (long)0xff)) << 48;               uadditional |= ((long)(data[2] & (long)0xff)) << 40;               uadditional |= ((long)(data[3] & (long)0xff)) << 32;               uadditional |= ((long)(data[4] & (long)0xff)) << 24;               uadditional |= ((long)(data[5] & (long)0xff)) << 16;               uadditional |= ((long)(data[6] & (long)0xff)) << 8;               uadditional |= (long)(data[7] & (long)0xff);             }             break;           }       }
Magic Number,PeterO.Cbor,CBORReader,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORReader.cs,ReadForFirstByte,The following statement contains a magic number: switch (firstbyte & 0x1f) {         case 24: {             int tmp = this.stream.ReadByte();             if (tmp < 0) {               throw new CBORException("Premature end of data");             }             lowAdditional = tmp;             uadditional = lowAdditional;             break;           }         case 25: {             if (this.stream.Read(data' 0' 2) != 2) {               throw new CBORException("Premature end of data");             }             lowAdditional = ((int)(data[0] & (int)0xff)) << 8;             lowAdditional |= (int)(data[1] & (int)0xff);             uadditional = lowAdditional;             break;           }         case 26: {             if (this.stream.Read(data' 0' 4) != 4) {               throw new CBORException("Premature end of data");             }             uadditional = ((long)(data[0] & (long)0xff)) << 24;             uadditional |= ((long)(data[1] & (long)0xff)) << 16;             uadditional |= ((long)(data[2] & (long)0xff)) << 8;             uadditional |= (long)(data[3] & (long)0xff);             break;           }         case 27: {             if (this.stream.Read(data' 0' 8) != 8) {               throw new CBORException("Premature end of data");             }             if ((((int)data[0]) & 0x80) != 0) {               // Won't fit in a signed 64-bit number               var uabytes = new byte[9];               uabytes[0] = data[7];               uabytes[1] = data[6];               uabytes[2] = data[5];               uabytes[3] = data[4];               uabytes[4] = data[3];               uabytes[5] = data[2];               uabytes[6] = data[1];               uabytes[7] = data[0];               uabytes[8] = 0;               hasBigAdditional = true;               bigintAdditional = EInteger.FromBytes(uabytes' true);             } else {               uadditional = ((long)(data[0] & (long)0xff)) << 56;               uadditional |= ((long)(data[1] & (long)0xff)) << 48;               uadditional |= ((long)(data[2] & (long)0xff)) << 40;               uadditional |= ((long)(data[3] & (long)0xff)) << 32;               uadditional |= ((long)(data[4] & (long)0xff)) << 24;               uadditional |= ((long)(data[5] & (long)0xff)) << 16;               uadditional |= ((long)(data[6] & (long)0xff)) << 8;               uadditional |= (long)(data[7] & (long)0xff);             }             break;           }       }
Magic Number,PeterO.Cbor,CBORReader,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORReader.cs,ReadForFirstByte,The following statement contains a magic number: switch (firstbyte & 0x1f) {         case 24: {             int tmp = this.stream.ReadByte();             if (tmp < 0) {               throw new CBORException("Premature end of data");             }             lowAdditional = tmp;             uadditional = lowAdditional;             break;           }         case 25: {             if (this.stream.Read(data' 0' 2) != 2) {               throw new CBORException("Premature end of data");             }             lowAdditional = ((int)(data[0] & (int)0xff)) << 8;             lowAdditional |= (int)(data[1] & (int)0xff);             uadditional = lowAdditional;             break;           }         case 26: {             if (this.stream.Read(data' 0' 4) != 4) {               throw new CBORException("Premature end of data");             }             uadditional = ((long)(data[0] & (long)0xff)) << 24;             uadditional |= ((long)(data[1] & (long)0xff)) << 16;             uadditional |= ((long)(data[2] & (long)0xff)) << 8;             uadditional |= (long)(data[3] & (long)0xff);             break;           }         case 27: {             if (this.stream.Read(data' 0' 8) != 8) {               throw new CBORException("Premature end of data");             }             if ((((int)data[0]) & 0x80) != 0) {               // Won't fit in a signed 64-bit number               var uabytes = new byte[9];               uabytes[0] = data[7];               uabytes[1] = data[6];               uabytes[2] = data[5];               uabytes[3] = data[4];               uabytes[4] = data[3];               uabytes[5] = data[2];               uabytes[6] = data[1];               uabytes[7] = data[0];               uabytes[8] = 0;               hasBigAdditional = true;               bigintAdditional = EInteger.FromBytes(uabytes' true);             } else {               uadditional = ((long)(data[0] & (long)0xff)) << 56;               uadditional |= ((long)(data[1] & (long)0xff)) << 48;               uadditional |= ((long)(data[2] & (long)0xff)) << 40;               uadditional |= ((long)(data[3] & (long)0xff)) << 32;               uadditional |= ((long)(data[4] & (long)0xff)) << 24;               uadditional |= ((long)(data[5] & (long)0xff)) << 16;               uadditional |= ((long)(data[6] & (long)0xff)) << 8;               uadditional |= (long)(data[7] & (long)0xff);             }             break;           }       }
Magic Number,PeterO.Cbor,CBORReader,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORReader.cs,ReadForFirstByte,The following statement contains a magic number: switch (firstbyte & 0x1f) {         case 24: {             int tmp = this.stream.ReadByte();             if (tmp < 0) {               throw new CBORException("Premature end of data");             }             lowAdditional = tmp;             uadditional = lowAdditional;             break;           }         case 25: {             if (this.stream.Read(data' 0' 2) != 2) {               throw new CBORException("Premature end of data");             }             lowAdditional = ((int)(data[0] & (int)0xff)) << 8;             lowAdditional |= (int)(data[1] & (int)0xff);             uadditional = lowAdditional;             break;           }         case 26: {             if (this.stream.Read(data' 0' 4) != 4) {               throw new CBORException("Premature end of data");             }             uadditional = ((long)(data[0] & (long)0xff)) << 24;             uadditional |= ((long)(data[1] & (long)0xff)) << 16;             uadditional |= ((long)(data[2] & (long)0xff)) << 8;             uadditional |= (long)(data[3] & (long)0xff);             break;           }         case 27: {             if (this.stream.Read(data' 0' 8) != 8) {               throw new CBORException("Premature end of data");             }             if ((((int)data[0]) & 0x80) != 0) {               // Won't fit in a signed 64-bit number               var uabytes = new byte[9];               uabytes[0] = data[7];               uabytes[1] = data[6];               uabytes[2] = data[5];               uabytes[3] = data[4];               uabytes[4] = data[3];               uabytes[5] = data[2];               uabytes[6] = data[1];               uabytes[7] = data[0];               uabytes[8] = 0;               hasBigAdditional = true;               bigintAdditional = EInteger.FromBytes(uabytes' true);             } else {               uadditional = ((long)(data[0] & (long)0xff)) << 56;               uadditional |= ((long)(data[1] & (long)0xff)) << 48;               uadditional |= ((long)(data[2] & (long)0xff)) << 40;               uadditional |= ((long)(data[3] & (long)0xff)) << 32;               uadditional |= ((long)(data[4] & (long)0xff)) << 24;               uadditional |= ((long)(data[5] & (long)0xff)) << 16;               uadditional |= ((long)(data[6] & (long)0xff)) << 8;               uadditional |= (long)(data[7] & (long)0xff);             }             break;           }       }
Magic Number,PeterO.Cbor,CBORReader,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORReader.cs,ReadForFirstByte,The following statement contains a magic number: switch (firstbyte & 0x1f) {         case 24: {             int tmp = this.stream.ReadByte();             if (tmp < 0) {               throw new CBORException("Premature end of data");             }             lowAdditional = tmp;             uadditional = lowAdditional;             break;           }         case 25: {             if (this.stream.Read(data' 0' 2) != 2) {               throw new CBORException("Premature end of data");             }             lowAdditional = ((int)(data[0] & (int)0xff)) << 8;             lowAdditional |= (int)(data[1] & (int)0xff);             uadditional = lowAdditional;             break;           }         case 26: {             if (this.stream.Read(data' 0' 4) != 4) {               throw new CBORException("Premature end of data");             }             uadditional = ((long)(data[0] & (long)0xff)) << 24;             uadditional |= ((long)(data[1] & (long)0xff)) << 16;             uadditional |= ((long)(data[2] & (long)0xff)) << 8;             uadditional |= (long)(data[3] & (long)0xff);             break;           }         case 27: {             if (this.stream.Read(data' 0' 8) != 8) {               throw new CBORException("Premature end of data");             }             if ((((int)data[0]) & 0x80) != 0) {               // Won't fit in a signed 64-bit number               var uabytes = new byte[9];               uabytes[0] = data[7];               uabytes[1] = data[6];               uabytes[2] = data[5];               uabytes[3] = data[4];               uabytes[4] = data[3];               uabytes[5] = data[2];               uabytes[6] = data[1];               uabytes[7] = data[0];               uabytes[8] = 0;               hasBigAdditional = true;               bigintAdditional = EInteger.FromBytes(uabytes' true);             } else {               uadditional = ((long)(data[0] & (long)0xff)) << 56;               uadditional |= ((long)(data[1] & (long)0xff)) << 48;               uadditional |= ((long)(data[2] & (long)0xff)) << 40;               uadditional |= ((long)(data[3] & (long)0xff)) << 32;               uadditional |= ((long)(data[4] & (long)0xff)) << 24;               uadditional |= ((long)(data[5] & (long)0xff)) << 16;               uadditional |= ((long)(data[6] & (long)0xff)) << 8;               uadditional |= (long)(data[7] & (long)0xff);             }             break;           }       }
Magic Number,PeterO.Cbor,CBORReader,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORReader.cs,ReadForFirstByte,The following statement contains a magic number: switch (firstbyte & 0x1f) {         case 24: {             int tmp = this.stream.ReadByte();             if (tmp < 0) {               throw new CBORException("Premature end of data");             }             lowAdditional = tmp;             uadditional = lowAdditional;             break;           }         case 25: {             if (this.stream.Read(data' 0' 2) != 2) {               throw new CBORException("Premature end of data");             }             lowAdditional = ((int)(data[0] & (int)0xff)) << 8;             lowAdditional |= (int)(data[1] & (int)0xff);             uadditional = lowAdditional;             break;           }         case 26: {             if (this.stream.Read(data' 0' 4) != 4) {               throw new CBORException("Premature end of data");             }             uadditional = ((long)(data[0] & (long)0xff)) << 24;             uadditional |= ((long)(data[1] & (long)0xff)) << 16;             uadditional |= ((long)(data[2] & (long)0xff)) << 8;             uadditional |= (long)(data[3] & (long)0xff);             break;           }         case 27: {             if (this.stream.Read(data' 0' 8) != 8) {               throw new CBORException("Premature end of data");             }             if ((((int)data[0]) & 0x80) != 0) {               // Won't fit in a signed 64-bit number               var uabytes = new byte[9];               uabytes[0] = data[7];               uabytes[1] = data[6];               uabytes[2] = data[5];               uabytes[3] = data[4];               uabytes[4] = data[3];               uabytes[5] = data[2];               uabytes[6] = data[1];               uabytes[7] = data[0];               uabytes[8] = 0;               hasBigAdditional = true;               bigintAdditional = EInteger.FromBytes(uabytes' true);             } else {               uadditional = ((long)(data[0] & (long)0xff)) << 56;               uadditional |= ((long)(data[1] & (long)0xff)) << 48;               uadditional |= ((long)(data[2] & (long)0xff)) << 40;               uadditional |= ((long)(data[3] & (long)0xff)) << 32;               uadditional |= ((long)(data[4] & (long)0xff)) << 24;               uadditional |= ((long)(data[5] & (long)0xff)) << 16;               uadditional |= ((long)(data[6] & (long)0xff)) << 8;               uadditional |= (long)(data[7] & (long)0xff);             }             break;           }       }
Magic Number,PeterO.Cbor,CBORReader,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORReader.cs,ReadForFirstByte,The following statement contains a magic number: switch (firstbyte & 0x1f) {         case 24: {             int tmp = this.stream.ReadByte();             if (tmp < 0) {               throw new CBORException("Premature end of data");             }             lowAdditional = tmp;             uadditional = lowAdditional;             break;           }         case 25: {             if (this.stream.Read(data' 0' 2) != 2) {               throw new CBORException("Premature end of data");             }             lowAdditional = ((int)(data[0] & (int)0xff)) << 8;             lowAdditional |= (int)(data[1] & (int)0xff);             uadditional = lowAdditional;             break;           }         case 26: {             if (this.stream.Read(data' 0' 4) != 4) {               throw new CBORException("Premature end of data");             }             uadditional = ((long)(data[0] & (long)0xff)) << 24;             uadditional |= ((long)(data[1] & (long)0xff)) << 16;             uadditional |= ((long)(data[2] & (long)0xff)) << 8;             uadditional |= (long)(data[3] & (long)0xff);             break;           }         case 27: {             if (this.stream.Read(data' 0' 8) != 8) {               throw new CBORException("Premature end of data");             }             if ((((int)data[0]) & 0x80) != 0) {               // Won't fit in a signed 64-bit number               var uabytes = new byte[9];               uabytes[0] = data[7];               uabytes[1] = data[6];               uabytes[2] = data[5];               uabytes[3] = data[4];               uabytes[4] = data[3];               uabytes[5] = data[2];               uabytes[6] = data[1];               uabytes[7] = data[0];               uabytes[8] = 0;               hasBigAdditional = true;               bigintAdditional = EInteger.FromBytes(uabytes' true);             } else {               uadditional = ((long)(data[0] & (long)0xff)) << 56;               uadditional |= ((long)(data[1] & (long)0xff)) << 48;               uadditional |= ((long)(data[2] & (long)0xff)) << 40;               uadditional |= ((long)(data[3] & (long)0xff)) << 32;               uadditional |= ((long)(data[4] & (long)0xff)) << 24;               uadditional |= ((long)(data[5] & (long)0xff)) << 16;               uadditional |= ((long)(data[6] & (long)0xff)) << 8;               uadditional |= (long)(data[7] & (long)0xff);             }             break;           }       }
Magic Number,PeterO.Cbor,CBORReader,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORReader.cs,ReadForFirstByte,The following statement contains a magic number: switch (firstbyte & 0x1f) {         case 24: {             int tmp = this.stream.ReadByte();             if (tmp < 0) {               throw new CBORException("Premature end of data");             }             lowAdditional = tmp;             uadditional = lowAdditional;             break;           }         case 25: {             if (this.stream.Read(data' 0' 2) != 2) {               throw new CBORException("Premature end of data");             }             lowAdditional = ((int)(data[0] & (int)0xff)) << 8;             lowAdditional |= (int)(data[1] & (int)0xff);             uadditional = lowAdditional;             break;           }         case 26: {             if (this.stream.Read(data' 0' 4) != 4) {               throw new CBORException("Premature end of data");             }             uadditional = ((long)(data[0] & (long)0xff)) << 24;             uadditional |= ((long)(data[1] & (long)0xff)) << 16;             uadditional |= ((long)(data[2] & (long)0xff)) << 8;             uadditional |= (long)(data[3] & (long)0xff);             break;           }         case 27: {             if (this.stream.Read(data' 0' 8) != 8) {               throw new CBORException("Premature end of data");             }             if ((((int)data[0]) & 0x80) != 0) {               // Won't fit in a signed 64-bit number               var uabytes = new byte[9];               uabytes[0] = data[7];               uabytes[1] = data[6];               uabytes[2] = data[5];               uabytes[3] = data[4];               uabytes[4] = data[3];               uabytes[5] = data[2];               uabytes[6] = data[1];               uabytes[7] = data[0];               uabytes[8] = 0;               hasBigAdditional = true;               bigintAdditional = EInteger.FromBytes(uabytes' true);             } else {               uadditional = ((long)(data[0] & (long)0xff)) << 56;               uadditional |= ((long)(data[1] & (long)0xff)) << 48;               uadditional |= ((long)(data[2] & (long)0xff)) << 40;               uadditional |= ((long)(data[3] & (long)0xff)) << 32;               uadditional |= ((long)(data[4] & (long)0xff)) << 24;               uadditional |= ((long)(data[5] & (long)0xff)) << 16;               uadditional |= ((long)(data[6] & (long)0xff)) << 8;               uadditional |= (long)(data[7] & (long)0xff);             }             break;           }       }
Magic Number,PeterO.Cbor,CBORReader,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORReader.cs,ReadForFirstByte,The following statement contains a magic number: switch (firstbyte & 0x1f) {         case 24: {             int tmp = this.stream.ReadByte();             if (tmp < 0) {               throw new CBORException("Premature end of data");             }             lowAdditional = tmp;             uadditional = lowAdditional;             break;           }         case 25: {             if (this.stream.Read(data' 0' 2) != 2) {               throw new CBORException("Premature end of data");             }             lowAdditional = ((int)(data[0] & (int)0xff)) << 8;             lowAdditional |= (int)(data[1] & (int)0xff);             uadditional = lowAdditional;             break;           }         case 26: {             if (this.stream.Read(data' 0' 4) != 4) {               throw new CBORException("Premature end of data");             }             uadditional = ((long)(data[0] & (long)0xff)) << 24;             uadditional |= ((long)(data[1] & (long)0xff)) << 16;             uadditional |= ((long)(data[2] & (long)0xff)) << 8;             uadditional |= (long)(data[3] & (long)0xff);             break;           }         case 27: {             if (this.stream.Read(data' 0' 8) != 8) {               throw new CBORException("Premature end of data");             }             if ((((int)data[0]) & 0x80) != 0) {               // Won't fit in a signed 64-bit number               var uabytes = new byte[9];               uabytes[0] = data[7];               uabytes[1] = data[6];               uabytes[2] = data[5];               uabytes[3] = data[4];               uabytes[4] = data[3];               uabytes[5] = data[2];               uabytes[6] = data[1];               uabytes[7] = data[0];               uabytes[8] = 0;               hasBigAdditional = true;               bigintAdditional = EInteger.FromBytes(uabytes' true);             } else {               uadditional = ((long)(data[0] & (long)0xff)) << 56;               uadditional |= ((long)(data[1] & (long)0xff)) << 48;               uadditional |= ((long)(data[2] & (long)0xff)) << 40;               uadditional |= ((long)(data[3] & (long)0xff)) << 32;               uadditional |= ((long)(data[4] & (long)0xff)) << 24;               uadditional |= ((long)(data[5] & (long)0xff)) << 16;               uadditional |= ((long)(data[6] & (long)0xff)) << 8;               uadditional |= (long)(data[7] & (long)0xff);             }             break;           }       }
Magic Number,PeterO.Cbor,CBORReader,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORReader.cs,ReadForFirstByte,The following statement contains a magic number: switch (firstbyte & 0x1f) {         case 24: {             int tmp = this.stream.ReadByte();             if (tmp < 0) {               throw new CBORException("Premature end of data");             }             lowAdditional = tmp;             uadditional = lowAdditional;             break;           }         case 25: {             if (this.stream.Read(data' 0' 2) != 2) {               throw new CBORException("Premature end of data");             }             lowAdditional = ((int)(data[0] & (int)0xff)) << 8;             lowAdditional |= (int)(data[1] & (int)0xff);             uadditional = lowAdditional;             break;           }         case 26: {             if (this.stream.Read(data' 0' 4) != 4) {               throw new CBORException("Premature end of data");             }             uadditional = ((long)(data[0] & (long)0xff)) << 24;             uadditional |= ((long)(data[1] & (long)0xff)) << 16;             uadditional |= ((long)(data[2] & (long)0xff)) << 8;             uadditional |= (long)(data[3] & (long)0xff);             break;           }         case 27: {             if (this.stream.Read(data' 0' 8) != 8) {               throw new CBORException("Premature end of data");             }             if ((((int)data[0]) & 0x80) != 0) {               // Won't fit in a signed 64-bit number               var uabytes = new byte[9];               uabytes[0] = data[7];               uabytes[1] = data[6];               uabytes[2] = data[5];               uabytes[3] = data[4];               uabytes[4] = data[3];               uabytes[5] = data[2];               uabytes[6] = data[1];               uabytes[7] = data[0];               uabytes[8] = 0;               hasBigAdditional = true;               bigintAdditional = EInteger.FromBytes(uabytes' true);             } else {               uadditional = ((long)(data[0] & (long)0xff)) << 56;               uadditional |= ((long)(data[1] & (long)0xff)) << 48;               uadditional |= ((long)(data[2] & (long)0xff)) << 40;               uadditional |= ((long)(data[3] & (long)0xff)) << 32;               uadditional |= ((long)(data[4] & (long)0xff)) << 24;               uadditional |= ((long)(data[5] & (long)0xff)) << 16;               uadditional |= ((long)(data[6] & (long)0xff)) << 8;               uadditional |= (long)(data[7] & (long)0xff);             }             break;           }       }
Magic Number,PeterO.Cbor,CBORReader,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORReader.cs,ReadForFirstByte,The following statement contains a magic number: switch (firstbyte & 0x1f) {         case 24: {             int tmp = this.stream.ReadByte();             if (tmp < 0) {               throw new CBORException("Premature end of data");             }             lowAdditional = tmp;             uadditional = lowAdditional;             break;           }         case 25: {             if (this.stream.Read(data' 0' 2) != 2) {               throw new CBORException("Premature end of data");             }             lowAdditional = ((int)(data[0] & (int)0xff)) << 8;             lowAdditional |= (int)(data[1] & (int)0xff);             uadditional = lowAdditional;             break;           }         case 26: {             if (this.stream.Read(data' 0' 4) != 4) {               throw new CBORException("Premature end of data");             }             uadditional = ((long)(data[0] & (long)0xff)) << 24;             uadditional |= ((long)(data[1] & (long)0xff)) << 16;             uadditional |= ((long)(data[2] & (long)0xff)) << 8;             uadditional |= (long)(data[3] & (long)0xff);             break;           }         case 27: {             if (this.stream.Read(data' 0' 8) != 8) {               throw new CBORException("Premature end of data");             }             if ((((int)data[0]) & 0x80) != 0) {               // Won't fit in a signed 64-bit number               var uabytes = new byte[9];               uabytes[0] = data[7];               uabytes[1] = data[6];               uabytes[2] = data[5];               uabytes[3] = data[4];               uabytes[4] = data[3];               uabytes[5] = data[2];               uabytes[6] = data[1];               uabytes[7] = data[0];               uabytes[8] = 0;               hasBigAdditional = true;               bigintAdditional = EInteger.FromBytes(uabytes' true);             } else {               uadditional = ((long)(data[0] & (long)0xff)) << 56;               uadditional |= ((long)(data[1] & (long)0xff)) << 48;               uadditional |= ((long)(data[2] & (long)0xff)) << 40;               uadditional |= ((long)(data[3] & (long)0xff)) << 32;               uadditional |= ((long)(data[4] & (long)0xff)) << 24;               uadditional |= ((long)(data[5] & (long)0xff)) << 16;               uadditional |= ((long)(data[6] & (long)0xff)) << 8;               uadditional |= (long)(data[7] & (long)0xff);             }             break;           }       }
Magic Number,PeterO.Cbor,CBORReader,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORReader.cs,ReadForFirstByte,The following statement contains a magic number: switch (firstbyte & 0x1f) {         case 24: {             int tmp = this.stream.ReadByte();             if (tmp < 0) {               throw new CBORException("Premature end of data");             }             lowAdditional = tmp;             uadditional = lowAdditional;             break;           }         case 25: {             if (this.stream.Read(data' 0' 2) != 2) {               throw new CBORException("Premature end of data");             }             lowAdditional = ((int)(data[0] & (int)0xff)) << 8;             lowAdditional |= (int)(data[1] & (int)0xff);             uadditional = lowAdditional;             break;           }         case 26: {             if (this.stream.Read(data' 0' 4) != 4) {               throw new CBORException("Premature end of data");             }             uadditional = ((long)(data[0] & (long)0xff)) << 24;             uadditional |= ((long)(data[1] & (long)0xff)) << 16;             uadditional |= ((long)(data[2] & (long)0xff)) << 8;             uadditional |= (long)(data[3] & (long)0xff);             break;           }         case 27: {             if (this.stream.Read(data' 0' 8) != 8) {               throw new CBORException("Premature end of data");             }             if ((((int)data[0]) & 0x80) != 0) {               // Won't fit in a signed 64-bit number               var uabytes = new byte[9];               uabytes[0] = data[7];               uabytes[1] = data[6];               uabytes[2] = data[5];               uabytes[3] = data[4];               uabytes[4] = data[3];               uabytes[5] = data[2];               uabytes[6] = data[1];               uabytes[7] = data[0];               uabytes[8] = 0;               hasBigAdditional = true;               bigintAdditional = EInteger.FromBytes(uabytes' true);             } else {               uadditional = ((long)(data[0] & (long)0xff)) << 56;               uadditional |= ((long)(data[1] & (long)0xff)) << 48;               uadditional |= ((long)(data[2] & (long)0xff)) << 40;               uadditional |= ((long)(data[3] & (long)0xff)) << 32;               uadditional |= ((long)(data[4] & (long)0xff)) << 24;               uadditional |= ((long)(data[5] & (long)0xff)) << 16;               uadditional |= ((long)(data[6] & (long)0xff)) << 8;               uadditional |= (long)(data[7] & (long)0xff);             }             break;           }       }
Magic Number,PeterO.Cbor,CBORReader,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORReader.cs,ReadForFirstByte,The following statement contains a magic number: switch (firstbyte & 0x1f) {         case 24: {             int tmp = this.stream.ReadByte();             if (tmp < 0) {               throw new CBORException("Premature end of data");             }             lowAdditional = tmp;             uadditional = lowAdditional;             break;           }         case 25: {             if (this.stream.Read(data' 0' 2) != 2) {               throw new CBORException("Premature end of data");             }             lowAdditional = ((int)(data[0] & (int)0xff)) << 8;             lowAdditional |= (int)(data[1] & (int)0xff);             uadditional = lowAdditional;             break;           }         case 26: {             if (this.stream.Read(data' 0' 4) != 4) {               throw new CBORException("Premature end of data");             }             uadditional = ((long)(data[0] & (long)0xff)) << 24;             uadditional |= ((long)(data[1] & (long)0xff)) << 16;             uadditional |= ((long)(data[2] & (long)0xff)) << 8;             uadditional |= (long)(data[3] & (long)0xff);             break;           }         case 27: {             if (this.stream.Read(data' 0' 8) != 8) {               throw new CBORException("Premature end of data");             }             if ((((int)data[0]) & 0x80) != 0) {               // Won't fit in a signed 64-bit number               var uabytes = new byte[9];               uabytes[0] = data[7];               uabytes[1] = data[6];               uabytes[2] = data[5];               uabytes[3] = data[4];               uabytes[4] = data[3];               uabytes[5] = data[2];               uabytes[6] = data[1];               uabytes[7] = data[0];               uabytes[8] = 0;               hasBigAdditional = true;               bigintAdditional = EInteger.FromBytes(uabytes' true);             } else {               uadditional = ((long)(data[0] & (long)0xff)) << 56;               uadditional |= ((long)(data[1] & (long)0xff)) << 48;               uadditional |= ((long)(data[2] & (long)0xff)) << 40;               uadditional |= ((long)(data[3] & (long)0xff)) << 32;               uadditional |= ((long)(data[4] & (long)0xff)) << 24;               uadditional |= ((long)(data[5] & (long)0xff)) << 16;               uadditional |= ((long)(data[6] & (long)0xff)) << 8;               uadditional |= (long)(data[7] & (long)0xff);             }             break;           }       }
Magic Number,PeterO.Cbor,CBORReader,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORReader.cs,ReadForFirstByte,The following statement contains a magic number: switch (firstbyte & 0x1f) {         case 24: {             int tmp = this.stream.ReadByte();             if (tmp < 0) {               throw new CBORException("Premature end of data");             }             lowAdditional = tmp;             uadditional = lowAdditional;             break;           }         case 25: {             if (this.stream.Read(data' 0' 2) != 2) {               throw new CBORException("Premature end of data");             }             lowAdditional = ((int)(data[0] & (int)0xff)) << 8;             lowAdditional |= (int)(data[1] & (int)0xff);             uadditional = lowAdditional;             break;           }         case 26: {             if (this.stream.Read(data' 0' 4) != 4) {               throw new CBORException("Premature end of data");             }             uadditional = ((long)(data[0] & (long)0xff)) << 24;             uadditional |= ((long)(data[1] & (long)0xff)) << 16;             uadditional |= ((long)(data[2] & (long)0xff)) << 8;             uadditional |= (long)(data[3] & (long)0xff);             break;           }         case 27: {             if (this.stream.Read(data' 0' 8) != 8) {               throw new CBORException("Premature end of data");             }             if ((((int)data[0]) & 0x80) != 0) {               // Won't fit in a signed 64-bit number               var uabytes = new byte[9];               uabytes[0] = data[7];               uabytes[1] = data[6];               uabytes[2] = data[5];               uabytes[3] = data[4];               uabytes[4] = data[3];               uabytes[5] = data[2];               uabytes[6] = data[1];               uabytes[7] = data[0];               uabytes[8] = 0;               hasBigAdditional = true;               bigintAdditional = EInteger.FromBytes(uabytes' true);             } else {               uadditional = ((long)(data[0] & (long)0xff)) << 56;               uadditional |= ((long)(data[1] & (long)0xff)) << 48;               uadditional |= ((long)(data[2] & (long)0xff)) << 40;               uadditional |= ((long)(data[3] & (long)0xff)) << 32;               uadditional |= ((long)(data[4] & (long)0xff)) << 24;               uadditional |= ((long)(data[5] & (long)0xff)) << 16;               uadditional |= ((long)(data[6] & (long)0xff)) << 8;               uadditional |= (long)(data[7] & (long)0xff);             }             break;           }       }
Magic Number,PeterO.Cbor,CBORReader,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORReader.cs,ReadForFirstByte,The following statement contains a magic number: switch (firstbyte & 0x1f) {         case 24: {             int tmp = this.stream.ReadByte();             if (tmp < 0) {               throw new CBORException("Premature end of data");             }             lowAdditional = tmp;             uadditional = lowAdditional;             break;           }         case 25: {             if (this.stream.Read(data' 0' 2) != 2) {               throw new CBORException("Premature end of data");             }             lowAdditional = ((int)(data[0] & (int)0xff)) << 8;             lowAdditional |= (int)(data[1] & (int)0xff);             uadditional = lowAdditional;             break;           }         case 26: {             if (this.stream.Read(data' 0' 4) != 4) {               throw new CBORException("Premature end of data");             }             uadditional = ((long)(data[0] & (long)0xff)) << 24;             uadditional |= ((long)(data[1] & (long)0xff)) << 16;             uadditional |= ((long)(data[2] & (long)0xff)) << 8;             uadditional |= (long)(data[3] & (long)0xff);             break;           }         case 27: {             if (this.stream.Read(data' 0' 8) != 8) {               throw new CBORException("Premature end of data");             }             if ((((int)data[0]) & 0x80) != 0) {               // Won't fit in a signed 64-bit number               var uabytes = new byte[9];               uabytes[0] = data[7];               uabytes[1] = data[6];               uabytes[2] = data[5];               uabytes[3] = data[4];               uabytes[4] = data[3];               uabytes[5] = data[2];               uabytes[6] = data[1];               uabytes[7] = data[0];               uabytes[8] = 0;               hasBigAdditional = true;               bigintAdditional = EInteger.FromBytes(uabytes' true);             } else {               uadditional = ((long)(data[0] & (long)0xff)) << 56;               uadditional |= ((long)(data[1] & (long)0xff)) << 48;               uadditional |= ((long)(data[2] & (long)0xff)) << 40;               uadditional |= ((long)(data[3] & (long)0xff)) << 32;               uadditional |= ((long)(data[4] & (long)0xff)) << 24;               uadditional |= ((long)(data[5] & (long)0xff)) << 16;               uadditional |= ((long)(data[6] & (long)0xff)) << 8;               uadditional |= (long)(data[7] & (long)0xff);             }             break;           }       }
Magic Number,PeterO.Cbor,CBORReader,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORReader.cs,ReadForFirstByte,The following statement contains a magic number: switch (firstbyte & 0x1f) {         case 24: {             int tmp = this.stream.ReadByte();             if (tmp < 0) {               throw new CBORException("Premature end of data");             }             lowAdditional = tmp;             uadditional = lowAdditional;             break;           }         case 25: {             if (this.stream.Read(data' 0' 2) != 2) {               throw new CBORException("Premature end of data");             }             lowAdditional = ((int)(data[0] & (int)0xff)) << 8;             lowAdditional |= (int)(data[1] & (int)0xff);             uadditional = lowAdditional;             break;           }         case 26: {             if (this.stream.Read(data' 0' 4) != 4) {               throw new CBORException("Premature end of data");             }             uadditional = ((long)(data[0] & (long)0xff)) << 24;             uadditional |= ((long)(data[1] & (long)0xff)) << 16;             uadditional |= ((long)(data[2] & (long)0xff)) << 8;             uadditional |= (long)(data[3] & (long)0xff);             break;           }         case 27: {             if (this.stream.Read(data' 0' 8) != 8) {               throw new CBORException("Premature end of data");             }             if ((((int)data[0]) & 0x80) != 0) {               // Won't fit in a signed 64-bit number               var uabytes = new byte[9];               uabytes[0] = data[7];               uabytes[1] = data[6];               uabytes[2] = data[5];               uabytes[3] = data[4];               uabytes[4] = data[3];               uabytes[5] = data[2];               uabytes[6] = data[1];               uabytes[7] = data[0];               uabytes[8] = 0;               hasBigAdditional = true;               bigintAdditional = EInteger.FromBytes(uabytes' true);             } else {               uadditional = ((long)(data[0] & (long)0xff)) << 56;               uadditional |= ((long)(data[1] & (long)0xff)) << 48;               uadditional |= ((long)(data[2] & (long)0xff)) << 40;               uadditional |= ((long)(data[3] & (long)0xff)) << 32;               uadditional |= ((long)(data[4] & (long)0xff)) << 24;               uadditional |= ((long)(data[5] & (long)0xff)) << 16;               uadditional |= ((long)(data[6] & (long)0xff)) << 8;               uadditional |= (long)(data[7] & (long)0xff);             }             break;           }       }
Magic Number,PeterO.Cbor,CBORReader,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORReader.cs,ReadForFirstByte,The following statement contains a magic number: switch (firstbyte & 0x1f) {         case 24: {             int tmp = this.stream.ReadByte();             if (tmp < 0) {               throw new CBORException("Premature end of data");             }             lowAdditional = tmp;             uadditional = lowAdditional;             break;           }         case 25: {             if (this.stream.Read(data' 0' 2) != 2) {               throw new CBORException("Premature end of data");             }             lowAdditional = ((int)(data[0] & (int)0xff)) << 8;             lowAdditional |= (int)(data[1] & (int)0xff);             uadditional = lowAdditional;             break;           }         case 26: {             if (this.stream.Read(data' 0' 4) != 4) {               throw new CBORException("Premature end of data");             }             uadditional = ((long)(data[0] & (long)0xff)) << 24;             uadditional |= ((long)(data[1] & (long)0xff)) << 16;             uadditional |= ((long)(data[2] & (long)0xff)) << 8;             uadditional |= (long)(data[3] & (long)0xff);             break;           }         case 27: {             if (this.stream.Read(data' 0' 8) != 8) {               throw new CBORException("Premature end of data");             }             if ((((int)data[0]) & 0x80) != 0) {               // Won't fit in a signed 64-bit number               var uabytes = new byte[9];               uabytes[0] = data[7];               uabytes[1] = data[6];               uabytes[2] = data[5];               uabytes[3] = data[4];               uabytes[4] = data[3];               uabytes[5] = data[2];               uabytes[6] = data[1];               uabytes[7] = data[0];               uabytes[8] = 0;               hasBigAdditional = true;               bigintAdditional = EInteger.FromBytes(uabytes' true);             } else {               uadditional = ((long)(data[0] & (long)0xff)) << 56;               uadditional |= ((long)(data[1] & (long)0xff)) << 48;               uadditional |= ((long)(data[2] & (long)0xff)) << 40;               uadditional |= ((long)(data[3] & (long)0xff)) << 32;               uadditional |= ((long)(data[4] & (long)0xff)) << 24;               uadditional |= ((long)(data[5] & (long)0xff)) << 16;               uadditional |= ((long)(data[6] & (long)0xff)) << 8;               uadditional |= (long)(data[7] & (long)0xff);             }             break;           }       }
Magic Number,PeterO.Cbor,CBORReader,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORReader.cs,ReadForFirstByte,The following statement contains a magic number: switch (firstbyte & 0x1f) {         case 24: {             int tmp = this.stream.ReadByte();             if (tmp < 0) {               throw new CBORException("Premature end of data");             }             lowAdditional = tmp;             uadditional = lowAdditional;             break;           }         case 25: {             if (this.stream.Read(data' 0' 2) != 2) {               throw new CBORException("Premature end of data");             }             lowAdditional = ((int)(data[0] & (int)0xff)) << 8;             lowAdditional |= (int)(data[1] & (int)0xff);             uadditional = lowAdditional;             break;           }         case 26: {             if (this.stream.Read(data' 0' 4) != 4) {               throw new CBORException("Premature end of data");             }             uadditional = ((long)(data[0] & (long)0xff)) << 24;             uadditional |= ((long)(data[1] & (long)0xff)) << 16;             uadditional |= ((long)(data[2] & (long)0xff)) << 8;             uadditional |= (long)(data[3] & (long)0xff);             break;           }         case 27: {             if (this.stream.Read(data' 0' 8) != 8) {               throw new CBORException("Premature end of data");             }             if ((((int)data[0]) & 0x80) != 0) {               // Won't fit in a signed 64-bit number               var uabytes = new byte[9];               uabytes[0] = data[7];               uabytes[1] = data[6];               uabytes[2] = data[5];               uabytes[3] = data[4];               uabytes[4] = data[3];               uabytes[5] = data[2];               uabytes[6] = data[1];               uabytes[7] = data[0];               uabytes[8] = 0;               hasBigAdditional = true;               bigintAdditional = EInteger.FromBytes(uabytes' true);             } else {               uadditional = ((long)(data[0] & (long)0xff)) << 56;               uadditional |= ((long)(data[1] & (long)0xff)) << 48;               uadditional |= ((long)(data[2] & (long)0xff)) << 40;               uadditional |= ((long)(data[3] & (long)0xff)) << 32;               uadditional |= ((long)(data[4] & (long)0xff)) << 24;               uadditional |= ((long)(data[5] & (long)0xff)) << 16;               uadditional |= ((long)(data[6] & (long)0xff)) << 8;               uadditional |= (long)(data[7] & (long)0xff);             }             break;           }       }
Magic Number,PeterO.Cbor,CBORReader,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORReader.cs,ReadForFirstByte,The following statement contains a magic number: switch (firstbyte & 0x1f) {         case 24: {             int tmp = this.stream.ReadByte();             if (tmp < 0) {               throw new CBORException("Premature end of data");             }             lowAdditional = tmp;             uadditional = lowAdditional;             break;           }         case 25: {             if (this.stream.Read(data' 0' 2) != 2) {               throw new CBORException("Premature end of data");             }             lowAdditional = ((int)(data[0] & (int)0xff)) << 8;             lowAdditional |= (int)(data[1] & (int)0xff);             uadditional = lowAdditional;             break;           }         case 26: {             if (this.stream.Read(data' 0' 4) != 4) {               throw new CBORException("Premature end of data");             }             uadditional = ((long)(data[0] & (long)0xff)) << 24;             uadditional |= ((long)(data[1] & (long)0xff)) << 16;             uadditional |= ((long)(data[2] & (long)0xff)) << 8;             uadditional |= (long)(data[3] & (long)0xff);             break;           }         case 27: {             if (this.stream.Read(data' 0' 8) != 8) {               throw new CBORException("Premature end of data");             }             if ((((int)data[0]) & 0x80) != 0) {               // Won't fit in a signed 64-bit number               var uabytes = new byte[9];               uabytes[0] = data[7];               uabytes[1] = data[6];               uabytes[2] = data[5];               uabytes[3] = data[4];               uabytes[4] = data[3];               uabytes[5] = data[2];               uabytes[6] = data[1];               uabytes[7] = data[0];               uabytes[8] = 0;               hasBigAdditional = true;               bigintAdditional = EInteger.FromBytes(uabytes' true);             } else {               uadditional = ((long)(data[0] & (long)0xff)) << 56;               uadditional |= ((long)(data[1] & (long)0xff)) << 48;               uadditional |= ((long)(data[2] & (long)0xff)) << 40;               uadditional |= ((long)(data[3] & (long)0xff)) << 32;               uadditional |= ((long)(data[4] & (long)0xff)) << 24;               uadditional |= ((long)(data[5] & (long)0xff)) << 16;               uadditional |= ((long)(data[6] & (long)0xff)) << 8;               uadditional |= (long)(data[7] & (long)0xff);             }             break;           }       }
Magic Number,PeterO.Cbor,CBORReader,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORReader.cs,ReadForFirstByte,The following statement contains a magic number: switch (firstbyte & 0x1f) {         case 24: {             int tmp = this.stream.ReadByte();             if (tmp < 0) {               throw new CBORException("Premature end of data");             }             lowAdditional = tmp;             uadditional = lowAdditional;             break;           }         case 25: {             if (this.stream.Read(data' 0' 2) != 2) {               throw new CBORException("Premature end of data");             }             lowAdditional = ((int)(data[0] & (int)0xff)) << 8;             lowAdditional |= (int)(data[1] & (int)0xff);             uadditional = lowAdditional;             break;           }         case 26: {             if (this.stream.Read(data' 0' 4) != 4) {               throw new CBORException("Premature end of data");             }             uadditional = ((long)(data[0] & (long)0xff)) << 24;             uadditional |= ((long)(data[1] & (long)0xff)) << 16;             uadditional |= ((long)(data[2] & (long)0xff)) << 8;             uadditional |= (long)(data[3] & (long)0xff);             break;           }         case 27: {             if (this.stream.Read(data' 0' 8) != 8) {               throw new CBORException("Premature end of data");             }             if ((((int)data[0]) & 0x80) != 0) {               // Won't fit in a signed 64-bit number               var uabytes = new byte[9];               uabytes[0] = data[7];               uabytes[1] = data[6];               uabytes[2] = data[5];               uabytes[3] = data[4];               uabytes[4] = data[3];               uabytes[5] = data[2];               uabytes[6] = data[1];               uabytes[7] = data[0];               uabytes[8] = 0;               hasBigAdditional = true;               bigintAdditional = EInteger.FromBytes(uabytes' true);             } else {               uadditional = ((long)(data[0] & (long)0xff)) << 56;               uadditional |= ((long)(data[1] & (long)0xff)) << 48;               uadditional |= ((long)(data[2] & (long)0xff)) << 40;               uadditional |= ((long)(data[3] & (long)0xff)) << 32;               uadditional |= ((long)(data[4] & (long)0xff)) << 24;               uadditional |= ((long)(data[5] & (long)0xff)) << 16;               uadditional |= ((long)(data[6] & (long)0xff)) << 8;               uadditional |= (long)(data[7] & (long)0xff);             }             break;           }       }
Magic Number,PeterO.Cbor,CBORReader,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORReader.cs,ReadForFirstByte,The following statement contains a magic number: switch (firstbyte & 0x1f) {         case 24: {             int tmp = this.stream.ReadByte();             if (tmp < 0) {               throw new CBORException("Premature end of data");             }             lowAdditional = tmp;             uadditional = lowAdditional;             break;           }         case 25: {             if (this.stream.Read(data' 0' 2) != 2) {               throw new CBORException("Premature end of data");             }             lowAdditional = ((int)(data[0] & (int)0xff)) << 8;             lowAdditional |= (int)(data[1] & (int)0xff);             uadditional = lowAdditional;             break;           }         case 26: {             if (this.stream.Read(data' 0' 4) != 4) {               throw new CBORException("Premature end of data");             }             uadditional = ((long)(data[0] & (long)0xff)) << 24;             uadditional |= ((long)(data[1] & (long)0xff)) << 16;             uadditional |= ((long)(data[2] & (long)0xff)) << 8;             uadditional |= (long)(data[3] & (long)0xff);             break;           }         case 27: {             if (this.stream.Read(data' 0' 8) != 8) {               throw new CBORException("Premature end of data");             }             if ((((int)data[0]) & 0x80) != 0) {               // Won't fit in a signed 64-bit number               var uabytes = new byte[9];               uabytes[0] = data[7];               uabytes[1] = data[6];               uabytes[2] = data[5];               uabytes[3] = data[4];               uabytes[4] = data[3];               uabytes[5] = data[2];               uabytes[6] = data[1];               uabytes[7] = data[0];               uabytes[8] = 0;               hasBigAdditional = true;               bigintAdditional = EInteger.FromBytes(uabytes' true);             } else {               uadditional = ((long)(data[0] & (long)0xff)) << 56;               uadditional |= ((long)(data[1] & (long)0xff)) << 48;               uadditional |= ((long)(data[2] & (long)0xff)) << 40;               uadditional |= ((long)(data[3] & (long)0xff)) << 32;               uadditional |= ((long)(data[4] & (long)0xff)) << 24;               uadditional |= ((long)(data[5] & (long)0xff)) << 16;               uadditional |= ((long)(data[6] & (long)0xff)) << 8;               uadditional |= (long)(data[7] & (long)0xff);             }             break;           }       }
Magic Number,PeterO.Cbor,CBORReader,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORReader.cs,ReadForFirstByte,The following statement contains a magic number: switch (firstbyte & 0x1f) {         case 24: {             int tmp = this.stream.ReadByte();             if (tmp < 0) {               throw new CBORException("Premature end of data");             }             lowAdditional = tmp;             uadditional = lowAdditional;             break;           }         case 25: {             if (this.stream.Read(data' 0' 2) != 2) {               throw new CBORException("Premature end of data");             }             lowAdditional = ((int)(data[0] & (int)0xff)) << 8;             lowAdditional |= (int)(data[1] & (int)0xff);             uadditional = lowAdditional;             break;           }         case 26: {             if (this.stream.Read(data' 0' 4) != 4) {               throw new CBORException("Premature end of data");             }             uadditional = ((long)(data[0] & (long)0xff)) << 24;             uadditional |= ((long)(data[1] & (long)0xff)) << 16;             uadditional |= ((long)(data[2] & (long)0xff)) << 8;             uadditional |= (long)(data[3] & (long)0xff);             break;           }         case 27: {             if (this.stream.Read(data' 0' 8) != 8) {               throw new CBORException("Premature end of data");             }             if ((((int)data[0]) & 0x80) != 0) {               // Won't fit in a signed 64-bit number               var uabytes = new byte[9];               uabytes[0] = data[7];               uabytes[1] = data[6];               uabytes[2] = data[5];               uabytes[3] = data[4];               uabytes[4] = data[3];               uabytes[5] = data[2];               uabytes[6] = data[1];               uabytes[7] = data[0];               uabytes[8] = 0;               hasBigAdditional = true;               bigintAdditional = EInteger.FromBytes(uabytes' true);             } else {               uadditional = ((long)(data[0] & (long)0xff)) << 56;               uadditional |= ((long)(data[1] & (long)0xff)) << 48;               uadditional |= ((long)(data[2] & (long)0xff)) << 40;               uadditional |= ((long)(data[3] & (long)0xff)) << 32;               uadditional |= ((long)(data[4] & (long)0xff)) << 24;               uadditional |= ((long)(data[5] & (long)0xff)) << 16;               uadditional |= ((long)(data[6] & (long)0xff)) << 8;               uadditional |= (long)(data[7] & (long)0xff);             }             break;           }       }
Magic Number,PeterO.Cbor,CBORReader,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORReader.cs,ReadForFirstByte,The following statement contains a magic number: switch (firstbyte & 0x1f) {         case 24: {             int tmp = this.stream.ReadByte();             if (tmp < 0) {               throw new CBORException("Premature end of data");             }             lowAdditional = tmp;             uadditional = lowAdditional;             break;           }         case 25: {             if (this.stream.Read(data' 0' 2) != 2) {               throw new CBORException("Premature end of data");             }             lowAdditional = ((int)(data[0] & (int)0xff)) << 8;             lowAdditional |= (int)(data[1] & (int)0xff);             uadditional = lowAdditional;             break;           }         case 26: {             if (this.stream.Read(data' 0' 4) != 4) {               throw new CBORException("Premature end of data");             }             uadditional = ((long)(data[0] & (long)0xff)) << 24;             uadditional |= ((long)(data[1] & (long)0xff)) << 16;             uadditional |= ((long)(data[2] & (long)0xff)) << 8;             uadditional |= (long)(data[3] & (long)0xff);             break;           }         case 27: {             if (this.stream.Read(data' 0' 8) != 8) {               throw new CBORException("Premature end of data");             }             if ((((int)data[0]) & 0x80) != 0) {               // Won't fit in a signed 64-bit number               var uabytes = new byte[9];               uabytes[0] = data[7];               uabytes[1] = data[6];               uabytes[2] = data[5];               uabytes[3] = data[4];               uabytes[4] = data[3];               uabytes[5] = data[2];               uabytes[6] = data[1];               uabytes[7] = data[0];               uabytes[8] = 0;               hasBigAdditional = true;               bigintAdditional = EInteger.FromBytes(uabytes' true);             } else {               uadditional = ((long)(data[0] & (long)0xff)) << 56;               uadditional |= ((long)(data[1] & (long)0xff)) << 48;               uadditional |= ((long)(data[2] & (long)0xff)) << 40;               uadditional |= ((long)(data[3] & (long)0xff)) << 32;               uadditional |= ((long)(data[4] & (long)0xff)) << 24;               uadditional |= ((long)(data[5] & (long)0xff)) << 16;               uadditional |= ((long)(data[6] & (long)0xff)) << 8;               uadditional |= (long)(data[7] & (long)0xff);             }             break;           }       }
Magic Number,PeterO.Cbor,CBORReader,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORReader.cs,ReadForFirstByte,The following statement contains a magic number: switch (firstbyte & 0x1f) {         case 24: {             int tmp = this.stream.ReadByte();             if (tmp < 0) {               throw new CBORException("Premature end of data");             }             lowAdditional = tmp;             uadditional = lowAdditional;             break;           }         case 25: {             if (this.stream.Read(data' 0' 2) != 2) {               throw new CBORException("Premature end of data");             }             lowAdditional = ((int)(data[0] & (int)0xff)) << 8;             lowAdditional |= (int)(data[1] & (int)0xff);             uadditional = lowAdditional;             break;           }         case 26: {             if (this.stream.Read(data' 0' 4) != 4) {               throw new CBORException("Premature end of data");             }             uadditional = ((long)(data[0] & (long)0xff)) << 24;             uadditional |= ((long)(data[1] & (long)0xff)) << 16;             uadditional |= ((long)(data[2] & (long)0xff)) << 8;             uadditional |= (long)(data[3] & (long)0xff);             break;           }         case 27: {             if (this.stream.Read(data' 0' 8) != 8) {               throw new CBORException("Premature end of data");             }             if ((((int)data[0]) & 0x80) != 0) {               // Won't fit in a signed 64-bit number               var uabytes = new byte[9];               uabytes[0] = data[7];               uabytes[1] = data[6];               uabytes[2] = data[5];               uabytes[3] = data[4];               uabytes[4] = data[3];               uabytes[5] = data[2];               uabytes[6] = data[1];               uabytes[7] = data[0];               uabytes[8] = 0;               hasBigAdditional = true;               bigintAdditional = EInteger.FromBytes(uabytes' true);             } else {               uadditional = ((long)(data[0] & (long)0xff)) << 56;               uadditional |= ((long)(data[1] & (long)0xff)) << 48;               uadditional |= ((long)(data[2] & (long)0xff)) << 40;               uadditional |= ((long)(data[3] & (long)0xff)) << 32;               uadditional |= ((long)(data[4] & (long)0xff)) << 24;               uadditional |= ((long)(data[5] & (long)0xff)) << 16;               uadditional |= ((long)(data[6] & (long)0xff)) << 8;               uadditional |= (long)(data[7] & (long)0xff);             }             break;           }       }
Magic Number,PeterO.Cbor,CBORReader,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORReader.cs,ReadForFirstByte,The following statement contains a magic number: switch (firstbyte & 0x1f) {         case 24: {             int tmp = this.stream.ReadByte();             if (tmp < 0) {               throw new CBORException("Premature end of data");             }             lowAdditional = tmp;             uadditional = lowAdditional;             break;           }         case 25: {             if (this.stream.Read(data' 0' 2) != 2) {               throw new CBORException("Premature end of data");             }             lowAdditional = ((int)(data[0] & (int)0xff)) << 8;             lowAdditional |= (int)(data[1] & (int)0xff);             uadditional = lowAdditional;             break;           }         case 26: {             if (this.stream.Read(data' 0' 4) != 4) {               throw new CBORException("Premature end of data");             }             uadditional = ((long)(data[0] & (long)0xff)) << 24;             uadditional |= ((long)(data[1] & (long)0xff)) << 16;             uadditional |= ((long)(data[2] & (long)0xff)) << 8;             uadditional |= (long)(data[3] & (long)0xff);             break;           }         case 27: {             if (this.stream.Read(data' 0' 8) != 8) {               throw new CBORException("Premature end of data");             }             if ((((int)data[0]) & 0x80) != 0) {               // Won't fit in a signed 64-bit number               var uabytes = new byte[9];               uabytes[0] = data[7];               uabytes[1] = data[6];               uabytes[2] = data[5];               uabytes[3] = data[4];               uabytes[4] = data[3];               uabytes[5] = data[2];               uabytes[6] = data[1];               uabytes[7] = data[0];               uabytes[8] = 0;               hasBigAdditional = true;               bigintAdditional = EInteger.FromBytes(uabytes' true);             } else {               uadditional = ((long)(data[0] & (long)0xff)) << 56;               uadditional |= ((long)(data[1] & (long)0xff)) << 48;               uadditional |= ((long)(data[2] & (long)0xff)) << 40;               uadditional |= ((long)(data[3] & (long)0xff)) << 32;               uadditional |= ((long)(data[4] & (long)0xff)) << 24;               uadditional |= ((long)(data[5] & (long)0xff)) << 16;               uadditional |= ((long)(data[6] & (long)0xff)) << 8;               uadditional |= (long)(data[7] & (long)0xff);             }             break;           }       }
Magic Number,PeterO.Cbor,CBORReader,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORReader.cs,ReadForFirstByte,The following statement contains a magic number: switch (firstbyte & 0x1f) {         case 24: {             int tmp = this.stream.ReadByte();             if (tmp < 0) {               throw new CBORException("Premature end of data");             }             lowAdditional = tmp;             uadditional = lowAdditional;             break;           }         case 25: {             if (this.stream.Read(data' 0' 2) != 2) {               throw new CBORException("Premature end of data");             }             lowAdditional = ((int)(data[0] & (int)0xff)) << 8;             lowAdditional |= (int)(data[1] & (int)0xff);             uadditional = lowAdditional;             break;           }         case 26: {             if (this.stream.Read(data' 0' 4) != 4) {               throw new CBORException("Premature end of data");             }             uadditional = ((long)(data[0] & (long)0xff)) << 24;             uadditional |= ((long)(data[1] & (long)0xff)) << 16;             uadditional |= ((long)(data[2] & (long)0xff)) << 8;             uadditional |= (long)(data[3] & (long)0xff);             break;           }         case 27: {             if (this.stream.Read(data' 0' 8) != 8) {               throw new CBORException("Premature end of data");             }             if ((((int)data[0]) & 0x80) != 0) {               // Won't fit in a signed 64-bit number               var uabytes = new byte[9];               uabytes[0] = data[7];               uabytes[1] = data[6];               uabytes[2] = data[5];               uabytes[3] = data[4];               uabytes[4] = data[3];               uabytes[5] = data[2];               uabytes[6] = data[1];               uabytes[7] = data[0];               uabytes[8] = 0;               hasBigAdditional = true;               bigintAdditional = EInteger.FromBytes(uabytes' true);             } else {               uadditional = ((long)(data[0] & (long)0xff)) << 56;               uadditional |= ((long)(data[1] & (long)0xff)) << 48;               uadditional |= ((long)(data[2] & (long)0xff)) << 40;               uadditional |= ((long)(data[3] & (long)0xff)) << 32;               uadditional |= ((long)(data[4] & (long)0xff)) << 24;               uadditional |= ((long)(data[5] & (long)0xff)) << 16;               uadditional |= ((long)(data[6] & (long)0xff)) << 8;               uadditional |= (long)(data[7] & (long)0xff);             }             break;           }       }
Magic Number,PeterO.Cbor,CBORReader,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORReader.cs,ReadForFirstByte,The following statement contains a magic number: switch (firstbyte & 0x1f) {         case 24: {             int tmp = this.stream.ReadByte();             if (tmp < 0) {               throw new CBORException("Premature end of data");             }             lowAdditional = tmp;             uadditional = lowAdditional;             break;           }         case 25: {             if (this.stream.Read(data' 0' 2) != 2) {               throw new CBORException("Premature end of data");             }             lowAdditional = ((int)(data[0] & (int)0xff)) << 8;             lowAdditional |= (int)(data[1] & (int)0xff);             uadditional = lowAdditional;             break;           }         case 26: {             if (this.stream.Read(data' 0' 4) != 4) {               throw new CBORException("Premature end of data");             }             uadditional = ((long)(data[0] & (long)0xff)) << 24;             uadditional |= ((long)(data[1] & (long)0xff)) << 16;             uadditional |= ((long)(data[2] & (long)0xff)) << 8;             uadditional |= (long)(data[3] & (long)0xff);             break;           }         case 27: {             if (this.stream.Read(data' 0' 8) != 8) {               throw new CBORException("Premature end of data");             }             if ((((int)data[0]) & 0x80) != 0) {               // Won't fit in a signed 64-bit number               var uabytes = new byte[9];               uabytes[0] = data[7];               uabytes[1] = data[6];               uabytes[2] = data[5];               uabytes[3] = data[4];               uabytes[4] = data[3];               uabytes[5] = data[2];               uabytes[6] = data[1];               uabytes[7] = data[0];               uabytes[8] = 0;               hasBigAdditional = true;               bigintAdditional = EInteger.FromBytes(uabytes' true);             } else {               uadditional = ((long)(data[0] & (long)0xff)) << 56;               uadditional |= ((long)(data[1] & (long)0xff)) << 48;               uadditional |= ((long)(data[2] & (long)0xff)) << 40;               uadditional |= ((long)(data[3] & (long)0xff)) << 32;               uadditional |= ((long)(data[4] & (long)0xff)) << 24;               uadditional |= ((long)(data[5] & (long)0xff)) << 16;               uadditional |= ((long)(data[6] & (long)0xff)) << 8;               uadditional |= (long)(data[7] & (long)0xff);             }             break;           }       }
Magic Number,PeterO.Cbor,CBORReader,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORReader.cs,ReadForFirstByte,The following statement contains a magic number: switch (firstbyte & 0x1f) {         case 24: {             int tmp = this.stream.ReadByte();             if (tmp < 0) {               throw new CBORException("Premature end of data");             }             lowAdditional = tmp;             uadditional = lowAdditional;             break;           }         case 25: {             if (this.stream.Read(data' 0' 2) != 2) {               throw new CBORException("Premature end of data");             }             lowAdditional = ((int)(data[0] & (int)0xff)) << 8;             lowAdditional |= (int)(data[1] & (int)0xff);             uadditional = lowAdditional;             break;           }         case 26: {             if (this.stream.Read(data' 0' 4) != 4) {               throw new CBORException("Premature end of data");             }             uadditional = ((long)(data[0] & (long)0xff)) << 24;             uadditional |= ((long)(data[1] & (long)0xff)) << 16;             uadditional |= ((long)(data[2] & (long)0xff)) << 8;             uadditional |= (long)(data[3] & (long)0xff);             break;           }         case 27: {             if (this.stream.Read(data' 0' 8) != 8) {               throw new CBORException("Premature end of data");             }             if ((((int)data[0]) & 0x80) != 0) {               // Won't fit in a signed 64-bit number               var uabytes = new byte[9];               uabytes[0] = data[7];               uabytes[1] = data[6];               uabytes[2] = data[5];               uabytes[3] = data[4];               uabytes[4] = data[3];               uabytes[5] = data[2];               uabytes[6] = data[1];               uabytes[7] = data[0];               uabytes[8] = 0;               hasBigAdditional = true;               bigintAdditional = EInteger.FromBytes(uabytes' true);             } else {               uadditional = ((long)(data[0] & (long)0xff)) << 56;               uadditional |= ((long)(data[1] & (long)0xff)) << 48;               uadditional |= ((long)(data[2] & (long)0xff)) << 40;               uadditional |= ((long)(data[3] & (long)0xff)) << 32;               uadditional |= ((long)(data[4] & (long)0xff)) << 24;               uadditional |= ((long)(data[5] & (long)0xff)) << 16;               uadditional |= ((long)(data[6] & (long)0xff)) << 8;               uadditional |= (long)(data[7] & (long)0xff);             }             break;           }       }
Magic Number,PeterO.Cbor,CBORReader,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORReader.cs,ReadForFirstByte,The following statement contains a magic number: switch (firstbyte & 0x1f) {         case 24: {             int tmp = this.stream.ReadByte();             if (tmp < 0) {               throw new CBORException("Premature end of data");             }             lowAdditional = tmp;             uadditional = lowAdditional;             break;           }         case 25: {             if (this.stream.Read(data' 0' 2) != 2) {               throw new CBORException("Premature end of data");             }             lowAdditional = ((int)(data[0] & (int)0xff)) << 8;             lowAdditional |= (int)(data[1] & (int)0xff);             uadditional = lowAdditional;             break;           }         case 26: {             if (this.stream.Read(data' 0' 4) != 4) {               throw new CBORException("Premature end of data");             }             uadditional = ((long)(data[0] & (long)0xff)) << 24;             uadditional |= ((long)(data[1] & (long)0xff)) << 16;             uadditional |= ((long)(data[2] & (long)0xff)) << 8;             uadditional |= (long)(data[3] & (long)0xff);             break;           }         case 27: {             if (this.stream.Read(data' 0' 8) != 8) {               throw new CBORException("Premature end of data");             }             if ((((int)data[0]) & 0x80) != 0) {               // Won't fit in a signed 64-bit number               var uabytes = new byte[9];               uabytes[0] = data[7];               uabytes[1] = data[6];               uabytes[2] = data[5];               uabytes[3] = data[4];               uabytes[4] = data[3];               uabytes[5] = data[2];               uabytes[6] = data[1];               uabytes[7] = data[0];               uabytes[8] = 0;               hasBigAdditional = true;               bigintAdditional = EInteger.FromBytes(uabytes' true);             } else {               uadditional = ((long)(data[0] & (long)0xff)) << 56;               uadditional |= ((long)(data[1] & (long)0xff)) << 48;               uadditional |= ((long)(data[2] & (long)0xff)) << 40;               uadditional |= ((long)(data[3] & (long)0xff)) << 32;               uadditional |= ((long)(data[4] & (long)0xff)) << 24;               uadditional |= ((long)(data[5] & (long)0xff)) << 16;               uadditional |= ((long)(data[6] & (long)0xff)) << 8;               uadditional |= (long)(data[7] & (long)0xff);             }             break;           }       }
Magic Number,PeterO.Cbor,CBORReader,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORReader.cs,ReadForFirstByte,The following statement contains a magic number: if (type == 2) {  // Byte string         if (additional == 31) {           // Streaming byte string           using (var ms = new MemoryStream()) {             // Requires same type as this one             while (true) {               int nextByte = this.stream.ReadByte();               if (nextByte == 0xff) {                 // break if the "break" code was read                 break;               }               long len = ReadDataLength(this.stream' nextByte' 2);               if ((len >> 63) != 0 || len > Int32.MaxValue) {                 throw new CBORException("Length" + ToUnsignedBigInteger(len) +                   " is bigger than supported ");               }               if (nextByte != 0x40) {   // NOTE: 0x40 means the empty byte string                 ReadByteData(this.stream' len' ms);               }             }             if (ms.Position > Int32.MaxValue) {               throw new   CBORException("Length of bytes to be streamed is bigger than supported ");             }             data = ms.ToArray();             return new CBORObject(   CBORObject.CBORObjectTypeByteString'   data);           }         } else {           if (hasBigAdditional) {             throw new CBORException("Length of " +   CBORUtilities.BigIntToString(bigintAdditional) + " is bigger than supported");           }           if (uadditional > Int32.MaxValue) {             throw new CBORException("Length of " +               CBORUtilities.LongToString(uadditional) +               " is bigger than supported");           }           data = ReadByteData(this.stream' uadditional' null);           var cbor = new CBORObject(CBORObject.CBORObjectTypeByteString' data);           if (this.stringRefs != null) {             int hint = (uadditional > Int32.MaxValue || hasBigAdditional) ?             Int32.MaxValue : (int)uadditional;             this.stringRefs.AddStringIfNeeded(cbor' hint);           }           return cbor;         }       }
Magic Number,PeterO.Cbor,CBORReader,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORReader.cs,ReadForFirstByte,The following statement contains a magic number: if (type == 2) {  // Byte string         if (additional == 31) {           // Streaming byte string           using (var ms = new MemoryStream()) {             // Requires same type as this one             while (true) {               int nextByte = this.stream.ReadByte();               if (nextByte == 0xff) {                 // break if the "break" code was read                 break;               }               long len = ReadDataLength(this.stream' nextByte' 2);               if ((len >> 63) != 0 || len > Int32.MaxValue) {                 throw new CBORException("Length" + ToUnsignedBigInteger(len) +                   " is bigger than supported ");               }               if (nextByte != 0x40) {   // NOTE: 0x40 means the empty byte string                 ReadByteData(this.stream' len' ms);               }             }             if (ms.Position > Int32.MaxValue) {               throw new   CBORException("Length of bytes to be streamed is bigger than supported ");             }             data = ms.ToArray();             return new CBORObject(   CBORObject.CBORObjectTypeByteString'   data);           }         } else {           if (hasBigAdditional) {             throw new CBORException("Length of " +   CBORUtilities.BigIntToString(bigintAdditional) + " is bigger than supported");           }           if (uadditional > Int32.MaxValue) {             throw new CBORException("Length of " +               CBORUtilities.LongToString(uadditional) +               " is bigger than supported");           }           data = ReadByteData(this.stream' uadditional' null);           var cbor = new CBORObject(CBORObject.CBORObjectTypeByteString' data);           if (this.stringRefs != null) {             int hint = (uadditional > Int32.MaxValue || hasBigAdditional) ?             Int32.MaxValue : (int)uadditional;             this.stringRefs.AddStringIfNeeded(cbor' hint);           }           return cbor;         }       }
Magic Number,PeterO.Cbor,CBORReader,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORReader.cs,ReadForFirstByte,The following statement contains a magic number: if (type == 2) {  // Byte string         if (additional == 31) {           // Streaming byte string           using (var ms = new MemoryStream()) {             // Requires same type as this one             while (true) {               int nextByte = this.stream.ReadByte();               if (nextByte == 0xff) {                 // break if the "break" code was read                 break;               }               long len = ReadDataLength(this.stream' nextByte' 2);               if ((len >> 63) != 0 || len > Int32.MaxValue) {                 throw new CBORException("Length" + ToUnsignedBigInteger(len) +                   " is bigger than supported ");               }               if (nextByte != 0x40) {   // NOTE: 0x40 means the empty byte string                 ReadByteData(this.stream' len' ms);               }             }             if (ms.Position > Int32.MaxValue) {               throw new   CBORException("Length of bytes to be streamed is bigger than supported ");             }             data = ms.ToArray();             return new CBORObject(   CBORObject.CBORObjectTypeByteString'   data);           }         } else {           if (hasBigAdditional) {             throw new CBORException("Length of " +   CBORUtilities.BigIntToString(bigintAdditional) + " is bigger than supported");           }           if (uadditional > Int32.MaxValue) {             throw new CBORException("Length of " +               CBORUtilities.LongToString(uadditional) +               " is bigger than supported");           }           data = ReadByteData(this.stream' uadditional' null);           var cbor = new CBORObject(CBORObject.CBORObjectTypeByteString' data);           if (this.stringRefs != null) {             int hint = (uadditional > Int32.MaxValue || hasBigAdditional) ?             Int32.MaxValue : (int)uadditional;             this.stringRefs.AddStringIfNeeded(cbor' hint);           }           return cbor;         }       }
Magic Number,PeterO.Cbor,CBORReader,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORReader.cs,ReadForFirstByte,The following statement contains a magic number: if (type == 2) {  // Byte string         if (additional == 31) {           // Streaming byte string           using (var ms = new MemoryStream()) {             // Requires same type as this one             while (true) {               int nextByte = this.stream.ReadByte();               if (nextByte == 0xff) {                 // break if the "break" code was read                 break;               }               long len = ReadDataLength(this.stream' nextByte' 2);               if ((len >> 63) != 0 || len > Int32.MaxValue) {                 throw new CBORException("Length" + ToUnsignedBigInteger(len) +                   " is bigger than supported ");               }               if (nextByte != 0x40) {   // NOTE: 0x40 means the empty byte string                 ReadByteData(this.stream' len' ms);               }             }             if (ms.Position > Int32.MaxValue) {               throw new   CBORException("Length of bytes to be streamed is bigger than supported ");             }             data = ms.ToArray();             return new CBORObject(   CBORObject.CBORObjectTypeByteString'   data);           }         } else {           if (hasBigAdditional) {             throw new CBORException("Length of " +   CBORUtilities.BigIntToString(bigintAdditional) + " is bigger than supported");           }           if (uadditional > Int32.MaxValue) {             throw new CBORException("Length of " +               CBORUtilities.LongToString(uadditional) +               " is bigger than supported");           }           data = ReadByteData(this.stream' uadditional' null);           var cbor = new CBORObject(CBORObject.CBORObjectTypeByteString' data);           if (this.stringRefs != null) {             int hint = (uadditional > Int32.MaxValue || hasBigAdditional) ?             Int32.MaxValue : (int)uadditional;             this.stringRefs.AddStringIfNeeded(cbor' hint);           }           return cbor;         }       }
Magic Number,PeterO.Cbor,CBORReader,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORReader.cs,ReadForFirstByte,The following statement contains a magic number: if (type == 3) {  // Text string         if (additional == 31) {           // Streaming text string           var builder = new StringBuilder();           while (true) {             int nextByte = this.stream.ReadByte();             if (nextByte == 0xff) {               // break if the "break" code was read               break;             }             long len = ReadDataLength(this.stream' nextByte' 3);             if ((len >> 63) != 0 || len > Int32.MaxValue) {               throw new CBORException("Length" + ToUnsignedBigInteger(len) +                 " is bigger than supported");             }             if (nextByte != 0x60) {   // NOTE: 0x60 means the empty string               if (PropertyMap.ExceedsKnownLength(this.stream' len)) {                 throw new CBORException("Premature end of data");               }               switch (   DataUtilities.ReadUtf8(   this.stream'   (int)len'   builder'   false)) {                 case -1:                   throw new CBORException("Invalid UTF-8");                 case -2:                   throw new CBORException("Premature end of data");               }             }           }           return new CBORObject(             CBORObject.CBORObjectTypeTextString'             builder.ToString());         } else {           if (hasBigAdditional) {             throw new CBORException("Length of " +   CBORUtilities.BigIntToString(bigintAdditional) + " is bigger than supported");           }           if (uadditional > Int32.MaxValue) {             throw new CBORException("Length of " +               CBORUtilities.LongToString(uadditional) +               " is bigger than supported");           }           if (PropertyMap.ExceedsKnownLength(this.stream' uadditional)) {             throw new CBORException("Premature end of data");           }           var builder = new StringBuilder();           switch (   DataUtilities.ReadUtf8(   this.stream'   (int)uadditional'   builder'   false)) {             case -1:               throw new CBORException("Invalid UTF-8");             case -2:               throw new CBORException("Premature end of data");           }           var cbor = new CBORObject(   CBORObject.CBORObjectTypeTextString'   builder.ToString());           if (this.stringRefs != null) {             int hint = (uadditional > Int32.MaxValue || hasBigAdditional) ?             Int32.MaxValue : (int)uadditional;             this.stringRefs.AddStringIfNeeded(cbor' hint);           }           return cbor;         }       }
Magic Number,PeterO.Cbor,CBORReader,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORReader.cs,ReadForFirstByte,The following statement contains a magic number: if (type == 3) {  // Text string         if (additional == 31) {           // Streaming text string           var builder = new StringBuilder();           while (true) {             int nextByte = this.stream.ReadByte();             if (nextByte == 0xff) {               // break if the "break" code was read               break;             }             long len = ReadDataLength(this.stream' nextByte' 3);             if ((len >> 63) != 0 || len > Int32.MaxValue) {               throw new CBORException("Length" + ToUnsignedBigInteger(len) +                 " is bigger than supported");             }             if (nextByte != 0x60) {   // NOTE: 0x60 means the empty string               if (PropertyMap.ExceedsKnownLength(this.stream' len)) {                 throw new CBORException("Premature end of data");               }               switch (   DataUtilities.ReadUtf8(   this.stream'   (int)len'   builder'   false)) {                 case -1:                   throw new CBORException("Invalid UTF-8");                 case -2:                   throw new CBORException("Premature end of data");               }             }           }           return new CBORObject(             CBORObject.CBORObjectTypeTextString'             builder.ToString());         } else {           if (hasBigAdditional) {             throw new CBORException("Length of " +   CBORUtilities.BigIntToString(bigintAdditional) + " is bigger than supported");           }           if (uadditional > Int32.MaxValue) {             throw new CBORException("Length of " +               CBORUtilities.LongToString(uadditional) +               " is bigger than supported");           }           if (PropertyMap.ExceedsKnownLength(this.stream' uadditional)) {             throw new CBORException("Premature end of data");           }           var builder = new StringBuilder();           switch (   DataUtilities.ReadUtf8(   this.stream'   (int)uadditional'   builder'   false)) {             case -1:               throw new CBORException("Invalid UTF-8");             case -2:               throw new CBORException("Premature end of data");           }           var cbor = new CBORObject(   CBORObject.CBORObjectTypeTextString'   builder.ToString());           if (this.stringRefs != null) {             int hint = (uadditional > Int32.MaxValue || hasBigAdditional) ?             Int32.MaxValue : (int)uadditional;             this.stringRefs.AddStringIfNeeded(cbor' hint);           }           return cbor;         }       }
Magic Number,PeterO.Cbor,CBORReader,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORReader.cs,ReadForFirstByte,The following statement contains a magic number: if (type == 3) {  // Text string         if (additional == 31) {           // Streaming text string           var builder = new StringBuilder();           while (true) {             int nextByte = this.stream.ReadByte();             if (nextByte == 0xff) {               // break if the "break" code was read               break;             }             long len = ReadDataLength(this.stream' nextByte' 3);             if ((len >> 63) != 0 || len > Int32.MaxValue) {               throw new CBORException("Length" + ToUnsignedBigInteger(len) +                 " is bigger than supported");             }             if (nextByte != 0x60) {   // NOTE: 0x60 means the empty string               if (PropertyMap.ExceedsKnownLength(this.stream' len)) {                 throw new CBORException("Premature end of data");               }               switch (   DataUtilities.ReadUtf8(   this.stream'   (int)len'   builder'   false)) {                 case -1:                   throw new CBORException("Invalid UTF-8");                 case -2:                   throw new CBORException("Premature end of data");               }             }           }           return new CBORObject(             CBORObject.CBORObjectTypeTextString'             builder.ToString());         } else {           if (hasBigAdditional) {             throw new CBORException("Length of " +   CBORUtilities.BigIntToString(bigintAdditional) + " is bigger than supported");           }           if (uadditional > Int32.MaxValue) {             throw new CBORException("Length of " +               CBORUtilities.LongToString(uadditional) +               " is bigger than supported");           }           if (PropertyMap.ExceedsKnownLength(this.stream' uadditional)) {             throw new CBORException("Premature end of data");           }           var builder = new StringBuilder();           switch (   DataUtilities.ReadUtf8(   this.stream'   (int)uadditional'   builder'   false)) {             case -1:               throw new CBORException("Invalid UTF-8");             case -2:               throw new CBORException("Premature end of data");           }           var cbor = new CBORObject(   CBORObject.CBORObjectTypeTextString'   builder.ToString());           if (this.stringRefs != null) {             int hint = (uadditional > Int32.MaxValue || hasBigAdditional) ?             Int32.MaxValue : (int)uadditional;             this.stringRefs.AddStringIfNeeded(cbor' hint);           }           return cbor;         }       }
Magic Number,PeterO.Cbor,CBORReader,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORReader.cs,ReadForFirstByte,The following statement contains a magic number: if (type == 3) {  // Text string         if (additional == 31) {           // Streaming text string           var builder = new StringBuilder();           while (true) {             int nextByte = this.stream.ReadByte();             if (nextByte == 0xff) {               // break if the "break" code was read               break;             }             long len = ReadDataLength(this.stream' nextByte' 3);             if ((len >> 63) != 0 || len > Int32.MaxValue) {               throw new CBORException("Length" + ToUnsignedBigInteger(len) +                 " is bigger than supported");             }             if (nextByte != 0x60) {   // NOTE: 0x60 means the empty string               if (PropertyMap.ExceedsKnownLength(this.stream' len)) {                 throw new CBORException("Premature end of data");               }               switch (   DataUtilities.ReadUtf8(   this.stream'   (int)len'   builder'   false)) {                 case -1:                   throw new CBORException("Invalid UTF-8");                 case -2:                   throw new CBORException("Premature end of data");               }             }           }           return new CBORObject(             CBORObject.CBORObjectTypeTextString'             builder.ToString());         } else {           if (hasBigAdditional) {             throw new CBORException("Length of " +   CBORUtilities.BigIntToString(bigintAdditional) + " is bigger than supported");           }           if (uadditional > Int32.MaxValue) {             throw new CBORException("Length of " +               CBORUtilities.LongToString(uadditional) +               " is bigger than supported");           }           if (PropertyMap.ExceedsKnownLength(this.stream' uadditional)) {             throw new CBORException("Premature end of data");           }           var builder = new StringBuilder();           switch (   DataUtilities.ReadUtf8(   this.stream'   (int)uadditional'   builder'   false)) {             case -1:               throw new CBORException("Invalid UTF-8");             case -2:               throw new CBORException("Premature end of data");           }           var cbor = new CBORObject(   CBORObject.CBORObjectTypeTextString'   builder.ToString());           if (this.stringRefs != null) {             int hint = (uadditional > Int32.MaxValue || hasBigAdditional) ?             Int32.MaxValue : (int)uadditional;             this.stringRefs.AddStringIfNeeded(cbor' hint);           }           return cbor;         }       }
Magic Number,PeterO.Cbor,CBORReader,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORReader.cs,ReadForFirstByte,The following statement contains a magic number: if (type == 3) {  // Text string         if (additional == 31) {           // Streaming text string           var builder = new StringBuilder();           while (true) {             int nextByte = this.stream.ReadByte();             if (nextByte == 0xff) {               // break if the "break" code was read               break;             }             long len = ReadDataLength(this.stream' nextByte' 3);             if ((len >> 63) != 0 || len > Int32.MaxValue) {               throw new CBORException("Length" + ToUnsignedBigInteger(len) +                 " is bigger than supported");             }             if (nextByte != 0x60) {   // NOTE: 0x60 means the empty string               if (PropertyMap.ExceedsKnownLength(this.stream' len)) {                 throw new CBORException("Premature end of data");               }               switch (   DataUtilities.ReadUtf8(   this.stream'   (int)len'   builder'   false)) {                 case -1:                   throw new CBORException("Invalid UTF-8");                 case -2:                   throw new CBORException("Premature end of data");               }             }           }           return new CBORObject(             CBORObject.CBORObjectTypeTextString'             builder.ToString());         } else {           if (hasBigAdditional) {             throw new CBORException("Length of " +   CBORUtilities.BigIntToString(bigintAdditional) + " is bigger than supported");           }           if (uadditional > Int32.MaxValue) {             throw new CBORException("Length of " +               CBORUtilities.LongToString(uadditional) +               " is bigger than supported");           }           if (PropertyMap.ExceedsKnownLength(this.stream' uadditional)) {             throw new CBORException("Premature end of data");           }           var builder = new StringBuilder();           switch (   DataUtilities.ReadUtf8(   this.stream'   (int)uadditional'   builder'   false)) {             case -1:               throw new CBORException("Invalid UTF-8");             case -2:               throw new CBORException("Premature end of data");           }           var cbor = new CBORObject(   CBORObject.CBORObjectTypeTextString'   builder.ToString());           if (this.stringRefs != null) {             int hint = (uadditional > Int32.MaxValue || hasBigAdditional) ?             Int32.MaxValue : (int)uadditional;             this.stringRefs.AddStringIfNeeded(cbor' hint);           }           return cbor;         }       }
Magic Number,PeterO.Cbor,CBORReader,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORReader.cs,ReadForFirstByte,The following statement contains a magic number: if (type == 3) {  // Text string         if (additional == 31) {           // Streaming text string           var builder = new StringBuilder();           while (true) {             int nextByte = this.stream.ReadByte();             if (nextByte == 0xff) {               // break if the "break" code was read               break;             }             long len = ReadDataLength(this.stream' nextByte' 3);             if ((len >> 63) != 0 || len > Int32.MaxValue) {               throw new CBORException("Length" + ToUnsignedBigInteger(len) +                 " is bigger than supported");             }             if (nextByte != 0x60) {   // NOTE: 0x60 means the empty string               if (PropertyMap.ExceedsKnownLength(this.stream' len)) {                 throw new CBORException("Premature end of data");               }               switch (   DataUtilities.ReadUtf8(   this.stream'   (int)len'   builder'   false)) {                 case -1:                   throw new CBORException("Invalid UTF-8");                 case -2:                   throw new CBORException("Premature end of data");               }             }           }           return new CBORObject(             CBORObject.CBORObjectTypeTextString'             builder.ToString());         } else {           if (hasBigAdditional) {             throw new CBORException("Length of " +   CBORUtilities.BigIntToString(bigintAdditional) + " is bigger than supported");           }           if (uadditional > Int32.MaxValue) {             throw new CBORException("Length of " +               CBORUtilities.LongToString(uadditional) +               " is bigger than supported");           }           if (PropertyMap.ExceedsKnownLength(this.stream' uadditional)) {             throw new CBORException("Premature end of data");           }           var builder = new StringBuilder();           switch (   DataUtilities.ReadUtf8(   this.stream'   (int)uadditional'   builder'   false)) {             case -1:               throw new CBORException("Invalid UTF-8");             case -2:               throw new CBORException("Premature end of data");           }           var cbor = new CBORObject(   CBORObject.CBORObjectTypeTextString'   builder.ToString());           if (this.stringRefs != null) {             int hint = (uadditional > Int32.MaxValue || hasBigAdditional) ?             Int32.MaxValue : (int)uadditional;             this.stringRefs.AddStringIfNeeded(cbor' hint);           }           return cbor;         }       }
Magic Number,PeterO.Cbor,CBORReader,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORReader.cs,ReadForFirstByte,The following statement contains a magic number: if (type == 4) {  // Array         CBORObject cbor = CBORObject.NewArray();         if (additional == 31) {           var vtindex = 0;           // Indefinite-length array           while (true) {             int headByte = this.stream.ReadByte();             if (headByte < 0) {               throw new CBORException("Premature end of data");             }             if (headByte == 0xff) {               // Break code was read               break;             }             if (filter != null && !filter.ArrayIndexAllowed(vtindex)) {               throw new CBORException("Array is too long");             }             ++this.depth;             CBORObject o = this.ReadForFirstByte(   headByte'   filter == null ? null : filter.GetSubFilter(vtindex));             --this.depth;             cbor.Add(o);             ++vtindex;           }           return cbor;         }         if (hasBigAdditional) {           throw new CBORException("Length of " +   CBORUtilities.BigIntToString(bigintAdditional) + " is bigger than supported");         }         if (uadditional > Int32.MaxValue) {           throw new CBORException("Length of " +             CBORUtilities.LongToString(uadditional) +             " is bigger than supported");         }         if (filter != null && !filter.ArrayLengthMatches(uadditional)) {           throw new CBORException("Array is too long");         }         if (PropertyMap.ExceedsKnownLength(this.stream' uadditional)) {           throw new CBORException("Remaining data too small for array length");         }         ++this.depth;         for (long i = 0; i < uadditional; ++i) {           cbor.Add(             this.Read(filter == null ? null : filter.GetSubFilter(i)));         }         --this.depth;         return cbor;       }
Magic Number,PeterO.Cbor,CBORReader,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORReader.cs,ReadForFirstByte,The following statement contains a magic number: if (type == 4) {  // Array         CBORObject cbor = CBORObject.NewArray();         if (additional == 31) {           var vtindex = 0;           // Indefinite-length array           while (true) {             int headByte = this.stream.ReadByte();             if (headByte < 0) {               throw new CBORException("Premature end of data");             }             if (headByte == 0xff) {               // Break code was read               break;             }             if (filter != null && !filter.ArrayIndexAllowed(vtindex)) {               throw new CBORException("Array is too long");             }             ++this.depth;             CBORObject o = this.ReadForFirstByte(   headByte'   filter == null ? null : filter.GetSubFilter(vtindex));             --this.depth;             cbor.Add(o);             ++vtindex;           }           return cbor;         }         if (hasBigAdditional) {           throw new CBORException("Length of " +   CBORUtilities.BigIntToString(bigintAdditional) + " is bigger than supported");         }         if (uadditional > Int32.MaxValue) {           throw new CBORException("Length of " +             CBORUtilities.LongToString(uadditional) +             " is bigger than supported");         }         if (filter != null && !filter.ArrayLengthMatches(uadditional)) {           throw new CBORException("Array is too long");         }         if (PropertyMap.ExceedsKnownLength(this.stream' uadditional)) {           throw new CBORException("Remaining data too small for array length");         }         ++this.depth;         for (long i = 0; i < uadditional; ++i) {           cbor.Add(             this.Read(filter == null ? null : filter.GetSubFilter(i)));         }         --this.depth;         return cbor;       }
Magic Number,PeterO.Cbor,CBORReader,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORReader.cs,ReadForFirstByte,The following statement contains a magic number: if (type == 5) {  // Map' type 5         CBORObject cbor = CBORObject.NewMap();         if (additional == 31) {           // Indefinite-length map           while (true) {             int headByte = this.stream.ReadByte();             if (headByte < 0) {               throw new CBORException("Premature end of data");             }             if (headByte == 0xff) {               // Break code was read               break;             }             ++this.depth;             CBORObject key = this.ReadForFirstByte(headByte' null);             CBORObject value = this.Read(null);             --this.depth;             if (this.policy == CBORDuplicatePolicy.Disallow) {               if (cbor.ContainsKey(key)) {                 throw new CBORException("Duplicate key already exists: " + key);               }             }             cbor[key] = value;           }           return cbor;         }         if (hasBigAdditional) {           throw new CBORException("Length of " +   CBORUtilities.BigIntToString(bigintAdditional) + " is bigger than supported");         }         if (uadditional > Int32.MaxValue) {           throw new CBORException("Length of " +             CBORUtilities.LongToString(uadditional) +             " is bigger than supported");         }         if (PropertyMap.ExceedsKnownLength(this.stream' uadditional)) {             throw new CBORException("Remaining data too small for map length");         }         for (long i = 0; i < uadditional; ++i) {           ++this.depth;           CBORObject key = this.Read(null);           CBORObject value = this.Read(null);           --this.depth;           if (this.policy == CBORDuplicatePolicy.Disallow) {             if (cbor.ContainsKey(key)) {               throw new CBORException("Duplicate key already exists: " + key);             }           }           cbor[key] = value;         }         return cbor;       }
Magic Number,PeterO.Cbor,CBORReader,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORReader.cs,ReadForFirstByte,The following statement contains a magic number: if (type == 5) {  // Map' type 5         CBORObject cbor = CBORObject.NewMap();         if (additional == 31) {           // Indefinite-length map           while (true) {             int headByte = this.stream.ReadByte();             if (headByte < 0) {               throw new CBORException("Premature end of data");             }             if (headByte == 0xff) {               // Break code was read               break;             }             ++this.depth;             CBORObject key = this.ReadForFirstByte(headByte' null);             CBORObject value = this.Read(null);             --this.depth;             if (this.policy == CBORDuplicatePolicy.Disallow) {               if (cbor.ContainsKey(key)) {                 throw new CBORException("Duplicate key already exists: " + key);               }             }             cbor[key] = value;           }           return cbor;         }         if (hasBigAdditional) {           throw new CBORException("Length of " +   CBORUtilities.BigIntToString(bigintAdditional) + " is bigger than supported");         }         if (uadditional > Int32.MaxValue) {           throw new CBORException("Length of " +             CBORUtilities.LongToString(uadditional) +             " is bigger than supported");         }         if (PropertyMap.ExceedsKnownLength(this.stream' uadditional)) {             throw new CBORException("Remaining data too small for map length");         }         for (long i = 0; i < uadditional; ++i) {           ++this.depth;           CBORObject key = this.Read(null);           CBORObject value = this.Read(null);           --this.depth;           if (this.policy == CBORDuplicatePolicy.Disallow) {             if (cbor.ContainsKey(key)) {               throw new CBORException("Duplicate key already exists: " + key);             }           }           cbor[key] = value;         }         return cbor;       }
Magic Number,PeterO.Cbor,CBORReader,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORReader.cs,ReadForFirstByte,The following statement contains a magic number: if (type == 6) {  // Tagged item         ICBORTag taginfo = null;         var haveFirstByte = false;         var newFirstByte = -1;         if (!hasBigAdditional) {           if (filter != null && !filter.TagAllowed(uadditional)) {             throw new CBORException("Unexpected tag encountered: " +                  uadditional);           }           int uad = uadditional >= 257 ? 257 : (uadditional < 0 ? 0 :             (int)uadditional);     switch (uad) {             case 256:               // Tag 256: String namespace               this.stringRefs = this.stringRefs ?? (new StringRefs());               this.stringRefs.Push();               break;             case 25:               // String reference               if (this.stringRefs == null) {                 throw new CBORException("No stringref namespace");               }               break;      case 28:      case 29:           this.hasSharableObjects = true;        break;           }            taginfo = CBORObject.FindTagConverterLong(uadditional);         } else {           if (filter != null && !filter.TagAllowed(bigintAdditional)) {             throw new CBORException("Unexpected tag encountered: " +                  uadditional);           }           taginfo = CBORObject.FindTagConverter(bigintAdditional);         }         ++this.depth;         CBORObject o = haveFirstByte ? this.ReadForFirstByte(   newFirstByte'   taginfo == null ? null : taginfo.GetTypeFilter()) :         this.Read(taginfo == null ? null : taginfo.GetTypeFilter());         --this.depth;         if (hasBigAdditional) {           return CBORObject.FromObjectAndTag(o' bigintAdditional);         }         if (uadditional < 65536) {           int uaddl = uadditional >= 257 ? 257 : (uadditional < 0 ? 0 :             (int)uadditional);           switch (uaddl) {             case 256:               // string tag               this.stringRefs.Pop();               break;             case 25:               // stringref tag               return this.stringRefs.GetString(o.AsEInteger());           }            return CBORObject.FromObjectAndTag(             o'             (int)uadditional);         }         return CBORObject.FromObjectAndTag(           o'           (EInteger)uadditional);       }
Magic Number,PeterO.Cbor,CBORReader,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORReader.cs,ReadForFirstByte,The following statement contains a magic number: if (type == 6) {  // Tagged item         ICBORTag taginfo = null;         var haveFirstByte = false;         var newFirstByte = -1;         if (!hasBigAdditional) {           if (filter != null && !filter.TagAllowed(uadditional)) {             throw new CBORException("Unexpected tag encountered: " +                  uadditional);           }           int uad = uadditional >= 257 ? 257 : (uadditional < 0 ? 0 :             (int)uadditional);     switch (uad) {             case 256:               // Tag 256: String namespace               this.stringRefs = this.stringRefs ?? (new StringRefs());               this.stringRefs.Push();               break;             case 25:               // String reference               if (this.stringRefs == null) {                 throw new CBORException("No stringref namespace");               }               break;      case 28:      case 29:           this.hasSharableObjects = true;        break;           }            taginfo = CBORObject.FindTagConverterLong(uadditional);         } else {           if (filter != null && !filter.TagAllowed(bigintAdditional)) {             throw new CBORException("Unexpected tag encountered: " +                  uadditional);           }           taginfo = CBORObject.FindTagConverter(bigintAdditional);         }         ++this.depth;         CBORObject o = haveFirstByte ? this.ReadForFirstByte(   newFirstByte'   taginfo == null ? null : taginfo.GetTypeFilter()) :         this.Read(taginfo == null ? null : taginfo.GetTypeFilter());         --this.depth;         if (hasBigAdditional) {           return CBORObject.FromObjectAndTag(o' bigintAdditional);         }         if (uadditional < 65536) {           int uaddl = uadditional >= 257 ? 257 : (uadditional < 0 ? 0 :             (int)uadditional);           switch (uaddl) {             case 256:               // string tag               this.stringRefs.Pop();               break;             case 25:               // stringref tag               return this.stringRefs.GetString(o.AsEInteger());           }            return CBORObject.FromObjectAndTag(             o'             (int)uadditional);         }         return CBORObject.FromObjectAndTag(           o'           (EInteger)uadditional);       }
Magic Number,PeterO.Cbor,CBORReader,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORReader.cs,ReadForFirstByte,The following statement contains a magic number: if (type == 6) {  // Tagged item         ICBORTag taginfo = null;         var haveFirstByte = false;         var newFirstByte = -1;         if (!hasBigAdditional) {           if (filter != null && !filter.TagAllowed(uadditional)) {             throw new CBORException("Unexpected tag encountered: " +                  uadditional);           }           int uad = uadditional >= 257 ? 257 : (uadditional < 0 ? 0 :             (int)uadditional);     switch (uad) {             case 256:               // Tag 256: String namespace               this.stringRefs = this.stringRefs ?? (new StringRefs());               this.stringRefs.Push();               break;             case 25:               // String reference               if (this.stringRefs == null) {                 throw new CBORException("No stringref namespace");               }               break;      case 28:      case 29:           this.hasSharableObjects = true;        break;           }            taginfo = CBORObject.FindTagConverterLong(uadditional);         } else {           if (filter != null && !filter.TagAllowed(bigintAdditional)) {             throw new CBORException("Unexpected tag encountered: " +                  uadditional);           }           taginfo = CBORObject.FindTagConverter(bigintAdditional);         }         ++this.depth;         CBORObject o = haveFirstByte ? this.ReadForFirstByte(   newFirstByte'   taginfo == null ? null : taginfo.GetTypeFilter()) :         this.Read(taginfo == null ? null : taginfo.GetTypeFilter());         --this.depth;         if (hasBigAdditional) {           return CBORObject.FromObjectAndTag(o' bigintAdditional);         }         if (uadditional < 65536) {           int uaddl = uadditional >= 257 ? 257 : (uadditional < 0 ? 0 :             (int)uadditional);           switch (uaddl) {             case 256:               // string tag               this.stringRefs.Pop();               break;             case 25:               // stringref tag               return this.stringRefs.GetString(o.AsEInteger());           }            return CBORObject.FromObjectAndTag(             o'             (int)uadditional);         }         return CBORObject.FromObjectAndTag(           o'           (EInteger)uadditional);       }
Magic Number,PeterO.Cbor,CBORReader,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORReader.cs,ReadForFirstByte,The following statement contains a magic number: if (type == 6) {  // Tagged item         ICBORTag taginfo = null;         var haveFirstByte = false;         var newFirstByte = -1;         if (!hasBigAdditional) {           if (filter != null && !filter.TagAllowed(uadditional)) {             throw new CBORException("Unexpected tag encountered: " +                  uadditional);           }           int uad = uadditional >= 257 ? 257 : (uadditional < 0 ? 0 :             (int)uadditional);     switch (uad) {             case 256:               // Tag 256: String namespace               this.stringRefs = this.stringRefs ?? (new StringRefs());               this.stringRefs.Push();               break;             case 25:               // String reference               if (this.stringRefs == null) {                 throw new CBORException("No stringref namespace");               }               break;      case 28:      case 29:           this.hasSharableObjects = true;        break;           }            taginfo = CBORObject.FindTagConverterLong(uadditional);         } else {           if (filter != null && !filter.TagAllowed(bigintAdditional)) {             throw new CBORException("Unexpected tag encountered: " +                  uadditional);           }           taginfo = CBORObject.FindTagConverter(bigintAdditional);         }         ++this.depth;         CBORObject o = haveFirstByte ? this.ReadForFirstByte(   newFirstByte'   taginfo == null ? null : taginfo.GetTypeFilter()) :         this.Read(taginfo == null ? null : taginfo.GetTypeFilter());         --this.depth;         if (hasBigAdditional) {           return CBORObject.FromObjectAndTag(o' bigintAdditional);         }         if (uadditional < 65536) {           int uaddl = uadditional >= 257 ? 257 : (uadditional < 0 ? 0 :             (int)uadditional);           switch (uaddl) {             case 256:               // string tag               this.stringRefs.Pop();               break;             case 25:               // stringref tag               return this.stringRefs.GetString(o.AsEInteger());           }            return CBORObject.FromObjectAndTag(             o'             (int)uadditional);         }         return CBORObject.FromObjectAndTag(           o'           (EInteger)uadditional);       }
Magic Number,PeterO.Cbor,CBORReader,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORReader.cs,ReadForFirstByte,The following statement contains a magic number: if (type == 6) {  // Tagged item         ICBORTag taginfo = null;         var haveFirstByte = false;         var newFirstByte = -1;         if (!hasBigAdditional) {           if (filter != null && !filter.TagAllowed(uadditional)) {             throw new CBORException("Unexpected tag encountered: " +                  uadditional);           }           int uad = uadditional >= 257 ? 257 : (uadditional < 0 ? 0 :             (int)uadditional);     switch (uad) {             case 256:               // Tag 256: String namespace               this.stringRefs = this.stringRefs ?? (new StringRefs());               this.stringRefs.Push();               break;             case 25:               // String reference               if (this.stringRefs == null) {                 throw new CBORException("No stringref namespace");               }               break;      case 28:      case 29:           this.hasSharableObjects = true;        break;           }            taginfo = CBORObject.FindTagConverterLong(uadditional);         } else {           if (filter != null && !filter.TagAllowed(bigintAdditional)) {             throw new CBORException("Unexpected tag encountered: " +                  uadditional);           }           taginfo = CBORObject.FindTagConverter(bigintAdditional);         }         ++this.depth;         CBORObject o = haveFirstByte ? this.ReadForFirstByte(   newFirstByte'   taginfo == null ? null : taginfo.GetTypeFilter()) :         this.Read(taginfo == null ? null : taginfo.GetTypeFilter());         --this.depth;         if (hasBigAdditional) {           return CBORObject.FromObjectAndTag(o' bigintAdditional);         }         if (uadditional < 65536) {           int uaddl = uadditional >= 257 ? 257 : (uadditional < 0 ? 0 :             (int)uadditional);           switch (uaddl) {             case 256:               // string tag               this.stringRefs.Pop();               break;             case 25:               // stringref tag               return this.stringRefs.GetString(o.AsEInteger());           }            return CBORObject.FromObjectAndTag(             o'             (int)uadditional);         }         return CBORObject.FromObjectAndTag(           o'           (EInteger)uadditional);       }
Magic Number,PeterO.Cbor,CBORReader,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORReader.cs,ReadForFirstByte,The following statement contains a magic number: if (type == 6) {  // Tagged item         ICBORTag taginfo = null;         var haveFirstByte = false;         var newFirstByte = -1;         if (!hasBigAdditional) {           if (filter != null && !filter.TagAllowed(uadditional)) {             throw new CBORException("Unexpected tag encountered: " +                  uadditional);           }           int uad = uadditional >= 257 ? 257 : (uadditional < 0 ? 0 :             (int)uadditional);     switch (uad) {             case 256:               // Tag 256: String namespace               this.stringRefs = this.stringRefs ?? (new StringRefs());               this.stringRefs.Push();               break;             case 25:               // String reference               if (this.stringRefs == null) {                 throw new CBORException("No stringref namespace");               }               break;      case 28:      case 29:           this.hasSharableObjects = true;        break;           }            taginfo = CBORObject.FindTagConverterLong(uadditional);         } else {           if (filter != null && !filter.TagAllowed(bigintAdditional)) {             throw new CBORException("Unexpected tag encountered: " +                  uadditional);           }           taginfo = CBORObject.FindTagConverter(bigintAdditional);         }         ++this.depth;         CBORObject o = haveFirstByte ? this.ReadForFirstByte(   newFirstByte'   taginfo == null ? null : taginfo.GetTypeFilter()) :         this.Read(taginfo == null ? null : taginfo.GetTypeFilter());         --this.depth;         if (hasBigAdditional) {           return CBORObject.FromObjectAndTag(o' bigintAdditional);         }         if (uadditional < 65536) {           int uaddl = uadditional >= 257 ? 257 : (uadditional < 0 ? 0 :             (int)uadditional);           switch (uaddl) {             case 256:               // string tag               this.stringRefs.Pop();               break;             case 25:               // stringref tag               return this.stringRefs.GetString(o.AsEInteger());           }            return CBORObject.FromObjectAndTag(             o'             (int)uadditional);         }         return CBORObject.FromObjectAndTag(           o'           (EInteger)uadditional);       }
Magic Number,PeterO.Cbor,CBORReader,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORReader.cs,ReadForFirstByte,The following statement contains a magic number: if (type == 6) {  // Tagged item         ICBORTag taginfo = null;         var haveFirstByte = false;         var newFirstByte = -1;         if (!hasBigAdditional) {           if (filter != null && !filter.TagAllowed(uadditional)) {             throw new CBORException("Unexpected tag encountered: " +                  uadditional);           }           int uad = uadditional >= 257 ? 257 : (uadditional < 0 ? 0 :             (int)uadditional);     switch (uad) {             case 256:               // Tag 256: String namespace               this.stringRefs = this.stringRefs ?? (new StringRefs());               this.stringRefs.Push();               break;             case 25:               // String reference               if (this.stringRefs == null) {                 throw new CBORException("No stringref namespace");               }               break;      case 28:      case 29:           this.hasSharableObjects = true;        break;           }            taginfo = CBORObject.FindTagConverterLong(uadditional);         } else {           if (filter != null && !filter.TagAllowed(bigintAdditional)) {             throw new CBORException("Unexpected tag encountered: " +                  uadditional);           }           taginfo = CBORObject.FindTagConverter(bigintAdditional);         }         ++this.depth;         CBORObject o = haveFirstByte ? this.ReadForFirstByte(   newFirstByte'   taginfo == null ? null : taginfo.GetTypeFilter()) :         this.Read(taginfo == null ? null : taginfo.GetTypeFilter());         --this.depth;         if (hasBigAdditional) {           return CBORObject.FromObjectAndTag(o' bigintAdditional);         }         if (uadditional < 65536) {           int uaddl = uadditional >= 257 ? 257 : (uadditional < 0 ? 0 :             (int)uadditional);           switch (uaddl) {             case 256:               // string tag               this.stringRefs.Pop();               break;             case 25:               // stringref tag               return this.stringRefs.GetString(o.AsEInteger());           }            return CBORObject.FromObjectAndTag(             o'             (int)uadditional);         }         return CBORObject.FromObjectAndTag(           o'           (EInteger)uadditional);       }
Magic Number,PeterO.Cbor,CBORReader,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORReader.cs,ReadForFirstByte,The following statement contains a magic number: if (type == 6) {  // Tagged item         ICBORTag taginfo = null;         var haveFirstByte = false;         var newFirstByte = -1;         if (!hasBigAdditional) {           if (filter != null && !filter.TagAllowed(uadditional)) {             throw new CBORException("Unexpected tag encountered: " +                  uadditional);           }           int uad = uadditional >= 257 ? 257 : (uadditional < 0 ? 0 :             (int)uadditional);     switch (uad) {             case 256:               // Tag 256: String namespace               this.stringRefs = this.stringRefs ?? (new StringRefs());               this.stringRefs.Push();               break;             case 25:               // String reference               if (this.stringRefs == null) {                 throw new CBORException("No stringref namespace");               }               break;      case 28:      case 29:           this.hasSharableObjects = true;        break;           }            taginfo = CBORObject.FindTagConverterLong(uadditional);         } else {           if (filter != null && !filter.TagAllowed(bigintAdditional)) {             throw new CBORException("Unexpected tag encountered: " +                  uadditional);           }           taginfo = CBORObject.FindTagConverter(bigintAdditional);         }         ++this.depth;         CBORObject o = haveFirstByte ? this.ReadForFirstByte(   newFirstByte'   taginfo == null ? null : taginfo.GetTypeFilter()) :         this.Read(taginfo == null ? null : taginfo.GetTypeFilter());         --this.depth;         if (hasBigAdditional) {           return CBORObject.FromObjectAndTag(o' bigintAdditional);         }         if (uadditional < 65536) {           int uaddl = uadditional >= 257 ? 257 : (uadditional < 0 ? 0 :             (int)uadditional);           switch (uaddl) {             case 256:               // string tag               this.stringRefs.Pop();               break;             case 25:               // stringref tag               return this.stringRefs.GetString(o.AsEInteger());           }            return CBORObject.FromObjectAndTag(             o'             (int)uadditional);         }         return CBORObject.FromObjectAndTag(           o'           (EInteger)uadditional);       }
Magic Number,PeterO.Cbor,CBORReader,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORReader.cs,ReadForFirstByte,The following statement contains a magic number: if (type == 6) {  // Tagged item         ICBORTag taginfo = null;         var haveFirstByte = false;         var newFirstByte = -1;         if (!hasBigAdditional) {           if (filter != null && !filter.TagAllowed(uadditional)) {             throw new CBORException("Unexpected tag encountered: " +                  uadditional);           }           int uad = uadditional >= 257 ? 257 : (uadditional < 0 ? 0 :             (int)uadditional);     switch (uad) {             case 256:               // Tag 256: String namespace               this.stringRefs = this.stringRefs ?? (new StringRefs());               this.stringRefs.Push();               break;             case 25:               // String reference               if (this.stringRefs == null) {                 throw new CBORException("No stringref namespace");               }               break;      case 28:      case 29:           this.hasSharableObjects = true;        break;           }            taginfo = CBORObject.FindTagConverterLong(uadditional);         } else {           if (filter != null && !filter.TagAllowed(bigintAdditional)) {             throw new CBORException("Unexpected tag encountered: " +                  uadditional);           }           taginfo = CBORObject.FindTagConverter(bigintAdditional);         }         ++this.depth;         CBORObject o = haveFirstByte ? this.ReadForFirstByte(   newFirstByte'   taginfo == null ? null : taginfo.GetTypeFilter()) :         this.Read(taginfo == null ? null : taginfo.GetTypeFilter());         --this.depth;         if (hasBigAdditional) {           return CBORObject.FromObjectAndTag(o' bigintAdditional);         }         if (uadditional < 65536) {           int uaddl = uadditional >= 257 ? 257 : (uadditional < 0 ? 0 :             (int)uadditional);           switch (uaddl) {             case 256:               // string tag               this.stringRefs.Pop();               break;             case 25:               // stringref tag               return this.stringRefs.GetString(o.AsEInteger());           }            return CBORObject.FromObjectAndTag(             o'             (int)uadditional);         }         return CBORObject.FromObjectAndTag(           o'           (EInteger)uadditional);       }
Magic Number,PeterO.Cbor,CBORReader,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORReader.cs,ReadForFirstByte,The following statement contains a magic number: if (type == 6) {  // Tagged item         ICBORTag taginfo = null;         var haveFirstByte = false;         var newFirstByte = -1;         if (!hasBigAdditional) {           if (filter != null && !filter.TagAllowed(uadditional)) {             throw new CBORException("Unexpected tag encountered: " +                  uadditional);           }           int uad = uadditional >= 257 ? 257 : (uadditional < 0 ? 0 :             (int)uadditional);     switch (uad) {             case 256:               // Tag 256: String namespace               this.stringRefs = this.stringRefs ?? (new StringRefs());               this.stringRefs.Push();               break;             case 25:               // String reference               if (this.stringRefs == null) {                 throw new CBORException("No stringref namespace");               }               break;      case 28:      case 29:           this.hasSharableObjects = true;        break;           }            taginfo = CBORObject.FindTagConverterLong(uadditional);         } else {           if (filter != null && !filter.TagAllowed(bigintAdditional)) {             throw new CBORException("Unexpected tag encountered: " +                  uadditional);           }           taginfo = CBORObject.FindTagConverter(bigintAdditional);         }         ++this.depth;         CBORObject o = haveFirstByte ? this.ReadForFirstByte(   newFirstByte'   taginfo == null ? null : taginfo.GetTypeFilter()) :         this.Read(taginfo == null ? null : taginfo.GetTypeFilter());         --this.depth;         if (hasBigAdditional) {           return CBORObject.FromObjectAndTag(o' bigintAdditional);         }         if (uadditional < 65536) {           int uaddl = uadditional >= 257 ? 257 : (uadditional < 0 ? 0 :             (int)uadditional);           switch (uaddl) {             case 256:               // string tag               this.stringRefs.Pop();               break;             case 25:               // stringref tag               return this.stringRefs.GetString(o.AsEInteger());           }            return CBORObject.FromObjectAndTag(             o'             (int)uadditional);         }         return CBORObject.FromObjectAndTag(           o'           (EInteger)uadditional);       }
Magic Number,PeterO.Cbor,CBORReader,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORReader.cs,ReadForFirstByte,The following statement contains a magic number: if (type == 6) {  // Tagged item         ICBORTag taginfo = null;         var haveFirstByte = false;         var newFirstByte = -1;         if (!hasBigAdditional) {           if (filter != null && !filter.TagAllowed(uadditional)) {             throw new CBORException("Unexpected tag encountered: " +                  uadditional);           }           int uad = uadditional >= 257 ? 257 : (uadditional < 0 ? 0 :             (int)uadditional);     switch (uad) {             case 256:               // Tag 256: String namespace               this.stringRefs = this.stringRefs ?? (new StringRefs());               this.stringRefs.Push();               break;             case 25:               // String reference               if (this.stringRefs == null) {                 throw new CBORException("No stringref namespace");               }               break;      case 28:      case 29:           this.hasSharableObjects = true;        break;           }            taginfo = CBORObject.FindTagConverterLong(uadditional);         } else {           if (filter != null && !filter.TagAllowed(bigintAdditional)) {             throw new CBORException("Unexpected tag encountered: " +                  uadditional);           }           taginfo = CBORObject.FindTagConverter(bigintAdditional);         }         ++this.depth;         CBORObject o = haveFirstByte ? this.ReadForFirstByte(   newFirstByte'   taginfo == null ? null : taginfo.GetTypeFilter()) :         this.Read(taginfo == null ? null : taginfo.GetTypeFilter());         --this.depth;         if (hasBigAdditional) {           return CBORObject.FromObjectAndTag(o' bigintAdditional);         }         if (uadditional < 65536) {           int uaddl = uadditional >= 257 ? 257 : (uadditional < 0 ? 0 :             (int)uadditional);           switch (uaddl) {             case 256:               // string tag               this.stringRefs.Pop();               break;             case 25:               // stringref tag               return this.stringRefs.GetString(o.AsEInteger());           }            return CBORObject.FromObjectAndTag(             o'             (int)uadditional);         }         return CBORObject.FromObjectAndTag(           o'           (EInteger)uadditional);       }
Magic Number,PeterO.Cbor,CBORReader,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORReader.cs,ReadForFirstByte,The following statement contains a magic number: if (type == 6) {  // Tagged item         ICBORTag taginfo = null;         var haveFirstByte = false;         var newFirstByte = -1;         if (!hasBigAdditional) {           if (filter != null && !filter.TagAllowed(uadditional)) {             throw new CBORException("Unexpected tag encountered: " +                  uadditional);           }           int uad = uadditional >= 257 ? 257 : (uadditional < 0 ? 0 :             (int)uadditional);     switch (uad) {             case 256:               // Tag 256: String namespace               this.stringRefs = this.stringRefs ?? (new StringRefs());               this.stringRefs.Push();               break;             case 25:               // String reference               if (this.stringRefs == null) {                 throw new CBORException("No stringref namespace");               }               break;      case 28:      case 29:           this.hasSharableObjects = true;        break;           }            taginfo = CBORObject.FindTagConverterLong(uadditional);         } else {           if (filter != null && !filter.TagAllowed(bigintAdditional)) {             throw new CBORException("Unexpected tag encountered: " +                  uadditional);           }           taginfo = CBORObject.FindTagConverter(bigintAdditional);         }         ++this.depth;         CBORObject o = haveFirstByte ? this.ReadForFirstByte(   newFirstByte'   taginfo == null ? null : taginfo.GetTypeFilter()) :         this.Read(taginfo == null ? null : taginfo.GetTypeFilter());         --this.depth;         if (hasBigAdditional) {           return CBORObject.FromObjectAndTag(o' bigintAdditional);         }         if (uadditional < 65536) {           int uaddl = uadditional >= 257 ? 257 : (uadditional < 0 ? 0 :             (int)uadditional);           switch (uaddl) {             case 256:               // string tag               this.stringRefs.Pop();               break;             case 25:               // stringref tag               return this.stringRefs.GetString(o.AsEInteger());           }            return CBORObject.FromObjectAndTag(             o'             (int)uadditional);         }         return CBORObject.FromObjectAndTag(           o'           (EInteger)uadditional);       }
Magic Number,PeterO.Cbor,CBORReader,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORReader.cs,ReadByteData,The following statement contains a magic number: if ((uadditional >> 63) != 0 || uadditional > Int32.MaxValue) {         throw new CBORException("Length" + ToUnsignedBigInteger(uadditional) +           " is bigger than supported ");       }
Magic Number,PeterO.Cbor,CBORReader,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORReader.cs,ReadDataLength,The following statement contains a magic number: if (((headByte >> 5) & 0x07) != expectedType) {         throw new CBORException("Unexpected data encountered");       }
Magic Number,PeterO.Cbor,CBORReader,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORReader.cs,ReadDataLength,The following statement contains a magic number: if (headByte < 24) {         return headByte;       }
Magic Number,PeterO.Cbor,CBORReader,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORReader.cs,ReadDataLength,The following statement contains a magic number: var data = new byte[8];
Magic Number,PeterO.Cbor,CBORReader,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORReader.cs,ReadDataLength,The following statement contains a magic number: switch (headByte & 0x1f) {         case 24: {             int tmp = stream.ReadByte();             if (tmp < 0) {               throw new CBORException("Premature end of data");             }             return tmp;           }         case 25: {             if (stream.Read(data' 0' 2) != 2) {               throw new CBORException("Premature end of data");             }             int lowAdditional = ((int)(data[0] & (int)0xff)) << 8;             lowAdditional |= (int)(data[1] & (int)0xff);             return lowAdditional;           }         case 26: {             if (stream.Read(data' 0' 4) != 4) {               throw new CBORException("Premature end of data");             }             long uadditional = ((long)(data[0] & (long)0xff)) << 24;             uadditional |= ((long)(data[1] & (long)0xff)) << 16;             uadditional |= ((long)(data[2] & (long)0xff)) << 8;             uadditional |= (long)(data[3] & (long)0xff);             return uadditional;           }         case 27: {             if (stream.Read(data' 0' 8) != 8) {               throw new CBORException("Premature end of data");             }             // Treat return value as an unsigned integer             long uadditional = ((long)(data[0] & (long)0xff)) << 56;             uadditional |= ((long)(data[1] & (long)0xff)) << 48;             uadditional |= ((long)(data[2] & (long)0xff)) << 40;             uadditional |= ((long)(data[3] & (long)0xff)) << 32;             uadditional |= ((long)(data[4] & (long)0xff)) << 24;             uadditional |= ((long)(data[5] & (long)0xff)) << 16;             uadditional |= ((long)(data[6] & (long)0xff)) << 8;             uadditional |= (long)(data[7] & (long)0xff);             return uadditional;           }         case 28:         case 29:         case 30:           throw new CBORException("Unexpected data encountered");         case 31:           throw new CBORException("Indefinite-length data not allowed here");         default: return headByte;       }
Magic Number,PeterO.Cbor,CBORReader,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORReader.cs,ReadDataLength,The following statement contains a magic number: switch (headByte & 0x1f) {         case 24: {             int tmp = stream.ReadByte();             if (tmp < 0) {               throw new CBORException("Premature end of data");             }             return tmp;           }         case 25: {             if (stream.Read(data' 0' 2) != 2) {               throw new CBORException("Premature end of data");             }             int lowAdditional = ((int)(data[0] & (int)0xff)) << 8;             lowAdditional |= (int)(data[1] & (int)0xff);             return lowAdditional;           }         case 26: {             if (stream.Read(data' 0' 4) != 4) {               throw new CBORException("Premature end of data");             }             long uadditional = ((long)(data[0] & (long)0xff)) << 24;             uadditional |= ((long)(data[1] & (long)0xff)) << 16;             uadditional |= ((long)(data[2] & (long)0xff)) << 8;             uadditional |= (long)(data[3] & (long)0xff);             return uadditional;           }         case 27: {             if (stream.Read(data' 0' 8) != 8) {               throw new CBORException("Premature end of data");             }             // Treat return value as an unsigned integer             long uadditional = ((long)(data[0] & (long)0xff)) << 56;             uadditional |= ((long)(data[1] & (long)0xff)) << 48;             uadditional |= ((long)(data[2] & (long)0xff)) << 40;             uadditional |= ((long)(data[3] & (long)0xff)) << 32;             uadditional |= ((long)(data[4] & (long)0xff)) << 24;             uadditional |= ((long)(data[5] & (long)0xff)) << 16;             uadditional |= ((long)(data[6] & (long)0xff)) << 8;             uadditional |= (long)(data[7] & (long)0xff);             return uadditional;           }         case 28:         case 29:         case 30:           throw new CBORException("Unexpected data encountered");         case 31:           throw new CBORException("Indefinite-length data not allowed here");         default: return headByte;       }
Magic Number,PeterO.Cbor,CBORReader,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORReader.cs,ReadDataLength,The following statement contains a magic number: switch (headByte & 0x1f) {         case 24: {             int tmp = stream.ReadByte();             if (tmp < 0) {               throw new CBORException("Premature end of data");             }             return tmp;           }         case 25: {             if (stream.Read(data' 0' 2) != 2) {               throw new CBORException("Premature end of data");             }             int lowAdditional = ((int)(data[0] & (int)0xff)) << 8;             lowAdditional |= (int)(data[1] & (int)0xff);             return lowAdditional;           }         case 26: {             if (stream.Read(data' 0' 4) != 4) {               throw new CBORException("Premature end of data");             }             long uadditional = ((long)(data[0] & (long)0xff)) << 24;             uadditional |= ((long)(data[1] & (long)0xff)) << 16;             uadditional |= ((long)(data[2] & (long)0xff)) << 8;             uadditional |= (long)(data[3] & (long)0xff);             return uadditional;           }         case 27: {             if (stream.Read(data' 0' 8) != 8) {               throw new CBORException("Premature end of data");             }             // Treat return value as an unsigned integer             long uadditional = ((long)(data[0] & (long)0xff)) << 56;             uadditional |= ((long)(data[1] & (long)0xff)) << 48;             uadditional |= ((long)(data[2] & (long)0xff)) << 40;             uadditional |= ((long)(data[3] & (long)0xff)) << 32;             uadditional |= ((long)(data[4] & (long)0xff)) << 24;             uadditional |= ((long)(data[5] & (long)0xff)) << 16;             uadditional |= ((long)(data[6] & (long)0xff)) << 8;             uadditional |= (long)(data[7] & (long)0xff);             return uadditional;           }         case 28:         case 29:         case 30:           throw new CBORException("Unexpected data encountered");         case 31:           throw new CBORException("Indefinite-length data not allowed here");         default: return headByte;       }
Magic Number,PeterO.Cbor,CBORReader,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORReader.cs,ReadDataLength,The following statement contains a magic number: switch (headByte & 0x1f) {         case 24: {             int tmp = stream.ReadByte();             if (tmp < 0) {               throw new CBORException("Premature end of data");             }             return tmp;           }         case 25: {             if (stream.Read(data' 0' 2) != 2) {               throw new CBORException("Premature end of data");             }             int lowAdditional = ((int)(data[0] & (int)0xff)) << 8;             lowAdditional |= (int)(data[1] & (int)0xff);             return lowAdditional;           }         case 26: {             if (stream.Read(data' 0' 4) != 4) {               throw new CBORException("Premature end of data");             }             long uadditional = ((long)(data[0] & (long)0xff)) << 24;             uadditional |= ((long)(data[1] & (long)0xff)) << 16;             uadditional |= ((long)(data[2] & (long)0xff)) << 8;             uadditional |= (long)(data[3] & (long)0xff);             return uadditional;           }         case 27: {             if (stream.Read(data' 0' 8) != 8) {               throw new CBORException("Premature end of data");             }             // Treat return value as an unsigned integer             long uadditional = ((long)(data[0] & (long)0xff)) << 56;             uadditional |= ((long)(data[1] & (long)0xff)) << 48;             uadditional |= ((long)(data[2] & (long)0xff)) << 40;             uadditional |= ((long)(data[3] & (long)0xff)) << 32;             uadditional |= ((long)(data[4] & (long)0xff)) << 24;             uadditional |= ((long)(data[5] & (long)0xff)) << 16;             uadditional |= ((long)(data[6] & (long)0xff)) << 8;             uadditional |= (long)(data[7] & (long)0xff);             return uadditional;           }         case 28:         case 29:         case 30:           throw new CBORException("Unexpected data encountered");         case 31:           throw new CBORException("Indefinite-length data not allowed here");         default: return headByte;       }
Magic Number,PeterO.Cbor,CBORReader,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORReader.cs,ReadDataLength,The following statement contains a magic number: switch (headByte & 0x1f) {         case 24: {             int tmp = stream.ReadByte();             if (tmp < 0) {               throw new CBORException("Premature end of data");             }             return tmp;           }         case 25: {             if (stream.Read(data' 0' 2) != 2) {               throw new CBORException("Premature end of data");             }             int lowAdditional = ((int)(data[0] & (int)0xff)) << 8;             lowAdditional |= (int)(data[1] & (int)0xff);             return lowAdditional;           }         case 26: {             if (stream.Read(data' 0' 4) != 4) {               throw new CBORException("Premature end of data");             }             long uadditional = ((long)(data[0] & (long)0xff)) << 24;             uadditional |= ((long)(data[1] & (long)0xff)) << 16;             uadditional |= ((long)(data[2] & (long)0xff)) << 8;             uadditional |= (long)(data[3] & (long)0xff);             return uadditional;           }         case 27: {             if (stream.Read(data' 0' 8) != 8) {               throw new CBORException("Premature end of data");             }             // Treat return value as an unsigned integer             long uadditional = ((long)(data[0] & (long)0xff)) << 56;             uadditional |= ((long)(data[1] & (long)0xff)) << 48;             uadditional |= ((long)(data[2] & (long)0xff)) << 40;             uadditional |= ((long)(data[3] & (long)0xff)) << 32;             uadditional |= ((long)(data[4] & (long)0xff)) << 24;             uadditional |= ((long)(data[5] & (long)0xff)) << 16;             uadditional |= ((long)(data[6] & (long)0xff)) << 8;             uadditional |= (long)(data[7] & (long)0xff);             return uadditional;           }         case 28:         case 29:         case 30:           throw new CBORException("Unexpected data encountered");         case 31:           throw new CBORException("Indefinite-length data not allowed here");         default: return headByte;       }
Magic Number,PeterO.Cbor,CBORReader,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORReader.cs,ReadDataLength,The following statement contains a magic number: switch (headByte & 0x1f) {         case 24: {             int tmp = stream.ReadByte();             if (tmp < 0) {               throw new CBORException("Premature end of data");             }             return tmp;           }         case 25: {             if (stream.Read(data' 0' 2) != 2) {               throw new CBORException("Premature end of data");             }             int lowAdditional = ((int)(data[0] & (int)0xff)) << 8;             lowAdditional |= (int)(data[1] & (int)0xff);             return lowAdditional;           }         case 26: {             if (stream.Read(data' 0' 4) != 4) {               throw new CBORException("Premature end of data");             }             long uadditional = ((long)(data[0] & (long)0xff)) << 24;             uadditional |= ((long)(data[1] & (long)0xff)) << 16;             uadditional |= ((long)(data[2] & (long)0xff)) << 8;             uadditional |= (long)(data[3] & (long)0xff);             return uadditional;           }         case 27: {             if (stream.Read(data' 0' 8) != 8) {               throw new CBORException("Premature end of data");             }             // Treat return value as an unsigned integer             long uadditional = ((long)(data[0] & (long)0xff)) << 56;             uadditional |= ((long)(data[1] & (long)0xff)) << 48;             uadditional |= ((long)(data[2] & (long)0xff)) << 40;             uadditional |= ((long)(data[3] & (long)0xff)) << 32;             uadditional |= ((long)(data[4] & (long)0xff)) << 24;             uadditional |= ((long)(data[5] & (long)0xff)) << 16;             uadditional |= ((long)(data[6] & (long)0xff)) << 8;             uadditional |= (long)(data[7] & (long)0xff);             return uadditional;           }         case 28:         case 29:         case 30:           throw new CBORException("Unexpected data encountered");         case 31:           throw new CBORException("Indefinite-length data not allowed here");         default: return headByte;       }
Magic Number,PeterO.Cbor,CBORReader,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORReader.cs,ReadDataLength,The following statement contains a magic number: switch (headByte & 0x1f) {         case 24: {             int tmp = stream.ReadByte();             if (tmp < 0) {               throw new CBORException("Premature end of data");             }             return tmp;           }         case 25: {             if (stream.Read(data' 0' 2) != 2) {               throw new CBORException("Premature end of data");             }             int lowAdditional = ((int)(data[0] & (int)0xff)) << 8;             lowAdditional |= (int)(data[1] & (int)0xff);             return lowAdditional;           }         case 26: {             if (stream.Read(data' 0' 4) != 4) {               throw new CBORException("Premature end of data");             }             long uadditional = ((long)(data[0] & (long)0xff)) << 24;             uadditional |= ((long)(data[1] & (long)0xff)) << 16;             uadditional |= ((long)(data[2] & (long)0xff)) << 8;             uadditional |= (long)(data[3] & (long)0xff);             return uadditional;           }         case 27: {             if (stream.Read(data' 0' 8) != 8) {               throw new CBORException("Premature end of data");             }             // Treat return value as an unsigned integer             long uadditional = ((long)(data[0] & (long)0xff)) << 56;             uadditional |= ((long)(data[1] & (long)0xff)) << 48;             uadditional |= ((long)(data[2] & (long)0xff)) << 40;             uadditional |= ((long)(data[3] & (long)0xff)) << 32;             uadditional |= ((long)(data[4] & (long)0xff)) << 24;             uadditional |= ((long)(data[5] & (long)0xff)) << 16;             uadditional |= ((long)(data[6] & (long)0xff)) << 8;             uadditional |= (long)(data[7] & (long)0xff);             return uadditional;           }         case 28:         case 29:         case 30:           throw new CBORException("Unexpected data encountered");         case 31:           throw new CBORException("Indefinite-length data not allowed here");         default: return headByte;       }
Magic Number,PeterO.Cbor,CBORReader,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORReader.cs,ReadDataLength,The following statement contains a magic number: switch (headByte & 0x1f) {         case 24: {             int tmp = stream.ReadByte();             if (tmp < 0) {               throw new CBORException("Premature end of data");             }             return tmp;           }         case 25: {             if (stream.Read(data' 0' 2) != 2) {               throw new CBORException("Premature end of data");             }             int lowAdditional = ((int)(data[0] & (int)0xff)) << 8;             lowAdditional |= (int)(data[1] & (int)0xff);             return lowAdditional;           }         case 26: {             if (stream.Read(data' 0' 4) != 4) {               throw new CBORException("Premature end of data");             }             long uadditional = ((long)(data[0] & (long)0xff)) << 24;             uadditional |= ((long)(data[1] & (long)0xff)) << 16;             uadditional |= ((long)(data[2] & (long)0xff)) << 8;             uadditional |= (long)(data[3] & (long)0xff);             return uadditional;           }         case 27: {             if (stream.Read(data' 0' 8) != 8) {               throw new CBORException("Premature end of data");             }             // Treat return value as an unsigned integer             long uadditional = ((long)(data[0] & (long)0xff)) << 56;             uadditional |= ((long)(data[1] & (long)0xff)) << 48;             uadditional |= ((long)(data[2] & (long)0xff)) << 40;             uadditional |= ((long)(data[3] & (long)0xff)) << 32;             uadditional |= ((long)(data[4] & (long)0xff)) << 24;             uadditional |= ((long)(data[5] & (long)0xff)) << 16;             uadditional |= ((long)(data[6] & (long)0xff)) << 8;             uadditional |= (long)(data[7] & (long)0xff);             return uadditional;           }         case 28:         case 29:         case 30:           throw new CBORException("Unexpected data encountered");         case 31:           throw new CBORException("Indefinite-length data not allowed here");         default: return headByte;       }
Magic Number,PeterO.Cbor,CBORReader,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORReader.cs,ReadDataLength,The following statement contains a magic number: switch (headByte & 0x1f) {         case 24: {             int tmp = stream.ReadByte();             if (tmp < 0) {               throw new CBORException("Premature end of data");             }             return tmp;           }         case 25: {             if (stream.Read(data' 0' 2) != 2) {               throw new CBORException("Premature end of data");             }             int lowAdditional = ((int)(data[0] & (int)0xff)) << 8;             lowAdditional |= (int)(data[1] & (int)0xff);             return lowAdditional;           }         case 26: {             if (stream.Read(data' 0' 4) != 4) {               throw new CBORException("Premature end of data");             }             long uadditional = ((long)(data[0] & (long)0xff)) << 24;             uadditional |= ((long)(data[1] & (long)0xff)) << 16;             uadditional |= ((long)(data[2] & (long)0xff)) << 8;             uadditional |= (long)(data[3] & (long)0xff);             return uadditional;           }         case 27: {             if (stream.Read(data' 0' 8) != 8) {               throw new CBORException("Premature end of data");             }             // Treat return value as an unsigned integer             long uadditional = ((long)(data[0] & (long)0xff)) << 56;             uadditional |= ((long)(data[1] & (long)0xff)) << 48;             uadditional |= ((long)(data[2] & (long)0xff)) << 40;             uadditional |= ((long)(data[3] & (long)0xff)) << 32;             uadditional |= ((long)(data[4] & (long)0xff)) << 24;             uadditional |= ((long)(data[5] & (long)0xff)) << 16;             uadditional |= ((long)(data[6] & (long)0xff)) << 8;             uadditional |= (long)(data[7] & (long)0xff);             return uadditional;           }         case 28:         case 29:         case 30:           throw new CBORException("Unexpected data encountered");         case 31:           throw new CBORException("Indefinite-length data not allowed here");         default: return headByte;       }
Magic Number,PeterO.Cbor,CBORReader,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORReader.cs,ReadDataLength,The following statement contains a magic number: switch (headByte & 0x1f) {         case 24: {             int tmp = stream.ReadByte();             if (tmp < 0) {               throw new CBORException("Premature end of data");             }             return tmp;           }         case 25: {             if (stream.Read(data' 0' 2) != 2) {               throw new CBORException("Premature end of data");             }             int lowAdditional = ((int)(data[0] & (int)0xff)) << 8;             lowAdditional |= (int)(data[1] & (int)0xff);             return lowAdditional;           }         case 26: {             if (stream.Read(data' 0' 4) != 4) {               throw new CBORException("Premature end of data");             }             long uadditional = ((long)(data[0] & (long)0xff)) << 24;             uadditional |= ((long)(data[1] & (long)0xff)) << 16;             uadditional |= ((long)(data[2] & (long)0xff)) << 8;             uadditional |= (long)(data[3] & (long)0xff);             return uadditional;           }         case 27: {             if (stream.Read(data' 0' 8) != 8) {               throw new CBORException("Premature end of data");             }             // Treat return value as an unsigned integer             long uadditional = ((long)(data[0] & (long)0xff)) << 56;             uadditional |= ((long)(data[1] & (long)0xff)) << 48;             uadditional |= ((long)(data[2] & (long)0xff)) << 40;             uadditional |= ((long)(data[3] & (long)0xff)) << 32;             uadditional |= ((long)(data[4] & (long)0xff)) << 24;             uadditional |= ((long)(data[5] & (long)0xff)) << 16;             uadditional |= ((long)(data[6] & (long)0xff)) << 8;             uadditional |= (long)(data[7] & (long)0xff);             return uadditional;           }         case 28:         case 29:         case 30:           throw new CBORException("Unexpected data encountered");         case 31:           throw new CBORException("Indefinite-length data not allowed here");         default: return headByte;       }
Magic Number,PeterO.Cbor,CBORReader,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORReader.cs,ReadDataLength,The following statement contains a magic number: switch (headByte & 0x1f) {         case 24: {             int tmp = stream.ReadByte();             if (tmp < 0) {               throw new CBORException("Premature end of data");             }             return tmp;           }         case 25: {             if (stream.Read(data' 0' 2) != 2) {               throw new CBORException("Premature end of data");             }             int lowAdditional = ((int)(data[0] & (int)0xff)) << 8;             lowAdditional |= (int)(data[1] & (int)0xff);             return lowAdditional;           }         case 26: {             if (stream.Read(data' 0' 4) != 4) {               throw new CBORException("Premature end of data");             }             long uadditional = ((long)(data[0] & (long)0xff)) << 24;             uadditional |= ((long)(data[1] & (long)0xff)) << 16;             uadditional |= ((long)(data[2] & (long)0xff)) << 8;             uadditional |= (long)(data[3] & (long)0xff);             return uadditional;           }         case 27: {             if (stream.Read(data' 0' 8) != 8) {               throw new CBORException("Premature end of data");             }             // Treat return value as an unsigned integer             long uadditional = ((long)(data[0] & (long)0xff)) << 56;             uadditional |= ((long)(data[1] & (long)0xff)) << 48;             uadditional |= ((long)(data[2] & (long)0xff)) << 40;             uadditional |= ((long)(data[3] & (long)0xff)) << 32;             uadditional |= ((long)(data[4] & (long)0xff)) << 24;             uadditional |= ((long)(data[5] & (long)0xff)) << 16;             uadditional |= ((long)(data[6] & (long)0xff)) << 8;             uadditional |= (long)(data[7] & (long)0xff);             return uadditional;           }         case 28:         case 29:         case 30:           throw new CBORException("Unexpected data encountered");         case 31:           throw new CBORException("Indefinite-length data not allowed here");         default: return headByte;       }
Magic Number,PeterO.Cbor,CBORReader,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORReader.cs,ReadDataLength,The following statement contains a magic number: switch (headByte & 0x1f) {         case 24: {             int tmp = stream.ReadByte();             if (tmp < 0) {               throw new CBORException("Premature end of data");             }             return tmp;           }         case 25: {             if (stream.Read(data' 0' 2) != 2) {               throw new CBORException("Premature end of data");             }             int lowAdditional = ((int)(data[0] & (int)0xff)) << 8;             lowAdditional |= (int)(data[1] & (int)0xff);             return lowAdditional;           }         case 26: {             if (stream.Read(data' 0' 4) != 4) {               throw new CBORException("Premature end of data");             }             long uadditional = ((long)(data[0] & (long)0xff)) << 24;             uadditional |= ((long)(data[1] & (long)0xff)) << 16;             uadditional |= ((long)(data[2] & (long)0xff)) << 8;             uadditional |= (long)(data[3] & (long)0xff);             return uadditional;           }         case 27: {             if (stream.Read(data' 0' 8) != 8) {               throw new CBORException("Premature end of data");             }             // Treat return value as an unsigned integer             long uadditional = ((long)(data[0] & (long)0xff)) << 56;             uadditional |= ((long)(data[1] & (long)0xff)) << 48;             uadditional |= ((long)(data[2] & (long)0xff)) << 40;             uadditional |= ((long)(data[3] & (long)0xff)) << 32;             uadditional |= ((long)(data[4] & (long)0xff)) << 24;             uadditional |= ((long)(data[5] & (long)0xff)) << 16;             uadditional |= ((long)(data[6] & (long)0xff)) << 8;             uadditional |= (long)(data[7] & (long)0xff);             return uadditional;           }         case 28:         case 29:         case 30:           throw new CBORException("Unexpected data encountered");         case 31:           throw new CBORException("Indefinite-length data not allowed here");         default: return headByte;       }
Magic Number,PeterO.Cbor,CBORReader,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORReader.cs,ReadDataLength,The following statement contains a magic number: switch (headByte & 0x1f) {         case 24: {             int tmp = stream.ReadByte();             if (tmp < 0) {               throw new CBORException("Premature end of data");             }             return tmp;           }         case 25: {             if (stream.Read(data' 0' 2) != 2) {               throw new CBORException("Premature end of data");             }             int lowAdditional = ((int)(data[0] & (int)0xff)) << 8;             lowAdditional |= (int)(data[1] & (int)0xff);             return lowAdditional;           }         case 26: {             if (stream.Read(data' 0' 4) != 4) {               throw new CBORException("Premature end of data");             }             long uadditional = ((long)(data[0] & (long)0xff)) << 24;             uadditional |= ((long)(data[1] & (long)0xff)) << 16;             uadditional |= ((long)(data[2] & (long)0xff)) << 8;             uadditional |= (long)(data[3] & (long)0xff);             return uadditional;           }         case 27: {             if (stream.Read(data' 0' 8) != 8) {               throw new CBORException("Premature end of data");             }             // Treat return value as an unsigned integer             long uadditional = ((long)(data[0] & (long)0xff)) << 56;             uadditional |= ((long)(data[1] & (long)0xff)) << 48;             uadditional |= ((long)(data[2] & (long)0xff)) << 40;             uadditional |= ((long)(data[3] & (long)0xff)) << 32;             uadditional |= ((long)(data[4] & (long)0xff)) << 24;             uadditional |= ((long)(data[5] & (long)0xff)) << 16;             uadditional |= ((long)(data[6] & (long)0xff)) << 8;             uadditional |= (long)(data[7] & (long)0xff);             return uadditional;           }         case 28:         case 29:         case 30:           throw new CBORException("Unexpected data encountered");         case 31:           throw new CBORException("Indefinite-length data not allowed here");         default: return headByte;       }
Magic Number,PeterO.Cbor,CBORReader,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORReader.cs,ReadDataLength,The following statement contains a magic number: switch (headByte & 0x1f) {         case 24: {             int tmp = stream.ReadByte();             if (tmp < 0) {               throw new CBORException("Premature end of data");             }             return tmp;           }         case 25: {             if (stream.Read(data' 0' 2) != 2) {               throw new CBORException("Premature end of data");             }             int lowAdditional = ((int)(data[0] & (int)0xff)) << 8;             lowAdditional |= (int)(data[1] & (int)0xff);             return lowAdditional;           }         case 26: {             if (stream.Read(data' 0' 4) != 4) {               throw new CBORException("Premature end of data");             }             long uadditional = ((long)(data[0] & (long)0xff)) << 24;             uadditional |= ((long)(data[1] & (long)0xff)) << 16;             uadditional |= ((long)(data[2] & (long)0xff)) << 8;             uadditional |= (long)(data[3] & (long)0xff);             return uadditional;           }         case 27: {             if (stream.Read(data' 0' 8) != 8) {               throw new CBORException("Premature end of data");             }             // Treat return value as an unsigned integer             long uadditional = ((long)(data[0] & (long)0xff)) << 56;             uadditional |= ((long)(data[1] & (long)0xff)) << 48;             uadditional |= ((long)(data[2] & (long)0xff)) << 40;             uadditional |= ((long)(data[3] & (long)0xff)) << 32;             uadditional |= ((long)(data[4] & (long)0xff)) << 24;             uadditional |= ((long)(data[5] & (long)0xff)) << 16;             uadditional |= ((long)(data[6] & (long)0xff)) << 8;             uadditional |= (long)(data[7] & (long)0xff);             return uadditional;           }         case 28:         case 29:         case 30:           throw new CBORException("Unexpected data encountered");         case 31:           throw new CBORException("Indefinite-length data not allowed here");         default: return headByte;       }
Magic Number,PeterO.Cbor,CBORReader,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORReader.cs,ReadDataLength,The following statement contains a magic number: switch (headByte & 0x1f) {         case 24: {             int tmp = stream.ReadByte();             if (tmp < 0) {               throw new CBORException("Premature end of data");             }             return tmp;           }         case 25: {             if (stream.Read(data' 0' 2) != 2) {               throw new CBORException("Premature end of data");             }             int lowAdditional = ((int)(data[0] & (int)0xff)) << 8;             lowAdditional |= (int)(data[1] & (int)0xff);             return lowAdditional;           }         case 26: {             if (stream.Read(data' 0' 4) != 4) {               throw new CBORException("Premature end of data");             }             long uadditional = ((long)(data[0] & (long)0xff)) << 24;             uadditional |= ((long)(data[1] & (long)0xff)) << 16;             uadditional |= ((long)(data[2] & (long)0xff)) << 8;             uadditional |= (long)(data[3] & (long)0xff);             return uadditional;           }         case 27: {             if (stream.Read(data' 0' 8) != 8) {               throw new CBORException("Premature end of data");             }             // Treat return value as an unsigned integer             long uadditional = ((long)(data[0] & (long)0xff)) << 56;             uadditional |= ((long)(data[1] & (long)0xff)) << 48;             uadditional |= ((long)(data[2] & (long)0xff)) << 40;             uadditional |= ((long)(data[3] & (long)0xff)) << 32;             uadditional |= ((long)(data[4] & (long)0xff)) << 24;             uadditional |= ((long)(data[5] & (long)0xff)) << 16;             uadditional |= ((long)(data[6] & (long)0xff)) << 8;             uadditional |= (long)(data[7] & (long)0xff);             return uadditional;           }         case 28:         case 29:         case 30:           throw new CBORException("Unexpected data encountered");         case 31:           throw new CBORException("Indefinite-length data not allowed here");         default: return headByte;       }
Magic Number,PeterO.Cbor,CBORReader,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORReader.cs,ReadDataLength,The following statement contains a magic number: switch (headByte & 0x1f) {         case 24: {             int tmp = stream.ReadByte();             if (tmp < 0) {               throw new CBORException("Premature end of data");             }             return tmp;           }         case 25: {             if (stream.Read(data' 0' 2) != 2) {               throw new CBORException("Premature end of data");             }             int lowAdditional = ((int)(data[0] & (int)0xff)) << 8;             lowAdditional |= (int)(data[1] & (int)0xff);             return lowAdditional;           }         case 26: {             if (stream.Read(data' 0' 4) != 4) {               throw new CBORException("Premature end of data");             }             long uadditional = ((long)(data[0] & (long)0xff)) << 24;             uadditional |= ((long)(data[1] & (long)0xff)) << 16;             uadditional |= ((long)(data[2] & (long)0xff)) << 8;             uadditional |= (long)(data[3] & (long)0xff);             return uadditional;           }         case 27: {             if (stream.Read(data' 0' 8) != 8) {               throw new CBORException("Premature end of data");             }             // Treat return value as an unsigned integer             long uadditional = ((long)(data[0] & (long)0xff)) << 56;             uadditional |= ((long)(data[1] & (long)0xff)) << 48;             uadditional |= ((long)(data[2] & (long)0xff)) << 40;             uadditional |= ((long)(data[3] & (long)0xff)) << 32;             uadditional |= ((long)(data[4] & (long)0xff)) << 24;             uadditional |= ((long)(data[5] & (long)0xff)) << 16;             uadditional |= ((long)(data[6] & (long)0xff)) << 8;             uadditional |= (long)(data[7] & (long)0xff);             return uadditional;           }         case 28:         case 29:         case 30:           throw new CBORException("Unexpected data encountered");         case 31:           throw new CBORException("Indefinite-length data not allowed here");         default: return headByte;       }
Magic Number,PeterO.Cbor,CBORReader,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORReader.cs,ReadDataLength,The following statement contains a magic number: switch (headByte & 0x1f) {         case 24: {             int tmp = stream.ReadByte();             if (tmp < 0) {               throw new CBORException("Premature end of data");             }             return tmp;           }         case 25: {             if (stream.Read(data' 0' 2) != 2) {               throw new CBORException("Premature end of data");             }             int lowAdditional = ((int)(data[0] & (int)0xff)) << 8;             lowAdditional |= (int)(data[1] & (int)0xff);             return lowAdditional;           }         case 26: {             if (stream.Read(data' 0' 4) != 4) {               throw new CBORException("Premature end of data");             }             long uadditional = ((long)(data[0] & (long)0xff)) << 24;             uadditional |= ((long)(data[1] & (long)0xff)) << 16;             uadditional |= ((long)(data[2] & (long)0xff)) << 8;             uadditional |= (long)(data[3] & (long)0xff);             return uadditional;           }         case 27: {             if (stream.Read(data' 0' 8) != 8) {               throw new CBORException("Premature end of data");             }             // Treat return value as an unsigned integer             long uadditional = ((long)(data[0] & (long)0xff)) << 56;             uadditional |= ((long)(data[1] & (long)0xff)) << 48;             uadditional |= ((long)(data[2] & (long)0xff)) << 40;             uadditional |= ((long)(data[3] & (long)0xff)) << 32;             uadditional |= ((long)(data[4] & (long)0xff)) << 24;             uadditional |= ((long)(data[5] & (long)0xff)) << 16;             uadditional |= ((long)(data[6] & (long)0xff)) << 8;             uadditional |= (long)(data[7] & (long)0xff);             return uadditional;           }         case 28:         case 29:         case 30:           throw new CBORException("Unexpected data encountered");         case 31:           throw new CBORException("Indefinite-length data not allowed here");         default: return headByte;       }
Magic Number,PeterO.Cbor,CBORReader,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORReader.cs,ReadDataLength,The following statement contains a magic number: switch (headByte & 0x1f) {         case 24: {             int tmp = stream.ReadByte();             if (tmp < 0) {               throw new CBORException("Premature end of data");             }             return tmp;           }         case 25: {             if (stream.Read(data' 0' 2) != 2) {               throw new CBORException("Premature end of data");             }             int lowAdditional = ((int)(data[0] & (int)0xff)) << 8;             lowAdditional |= (int)(data[1] & (int)0xff);             return lowAdditional;           }         case 26: {             if (stream.Read(data' 0' 4) != 4) {               throw new CBORException("Premature end of data");             }             long uadditional = ((long)(data[0] & (long)0xff)) << 24;             uadditional |= ((long)(data[1] & (long)0xff)) << 16;             uadditional |= ((long)(data[2] & (long)0xff)) << 8;             uadditional |= (long)(data[3] & (long)0xff);             return uadditional;           }         case 27: {             if (stream.Read(data' 0' 8) != 8) {               throw new CBORException("Premature end of data");             }             // Treat return value as an unsigned integer             long uadditional = ((long)(data[0] & (long)0xff)) << 56;             uadditional |= ((long)(data[1] & (long)0xff)) << 48;             uadditional |= ((long)(data[2] & (long)0xff)) << 40;             uadditional |= ((long)(data[3] & (long)0xff)) << 32;             uadditional |= ((long)(data[4] & (long)0xff)) << 24;             uadditional |= ((long)(data[5] & (long)0xff)) << 16;             uadditional |= ((long)(data[6] & (long)0xff)) << 8;             uadditional |= (long)(data[7] & (long)0xff);             return uadditional;           }         case 28:         case 29:         case 30:           throw new CBORException("Unexpected data encountered");         case 31:           throw new CBORException("Indefinite-length data not allowed here");         default: return headByte;       }
Magic Number,PeterO.Cbor,CBORReader,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORReader.cs,ReadDataLength,The following statement contains a magic number: switch (headByte & 0x1f) {         case 24: {             int tmp = stream.ReadByte();             if (tmp < 0) {               throw new CBORException("Premature end of data");             }             return tmp;           }         case 25: {             if (stream.Read(data' 0' 2) != 2) {               throw new CBORException("Premature end of data");             }             int lowAdditional = ((int)(data[0] & (int)0xff)) << 8;             lowAdditional |= (int)(data[1] & (int)0xff);             return lowAdditional;           }         case 26: {             if (stream.Read(data' 0' 4) != 4) {               throw new CBORException("Premature end of data");             }             long uadditional = ((long)(data[0] & (long)0xff)) << 24;             uadditional |= ((long)(data[1] & (long)0xff)) << 16;             uadditional |= ((long)(data[2] & (long)0xff)) << 8;             uadditional |= (long)(data[3] & (long)0xff);             return uadditional;           }         case 27: {             if (stream.Read(data' 0' 8) != 8) {               throw new CBORException("Premature end of data");             }             // Treat return value as an unsigned integer             long uadditional = ((long)(data[0] & (long)0xff)) << 56;             uadditional |= ((long)(data[1] & (long)0xff)) << 48;             uadditional |= ((long)(data[2] & (long)0xff)) << 40;             uadditional |= ((long)(data[3] & (long)0xff)) << 32;             uadditional |= ((long)(data[4] & (long)0xff)) << 24;             uadditional |= ((long)(data[5] & (long)0xff)) << 16;             uadditional |= ((long)(data[6] & (long)0xff)) << 8;             uadditional |= (long)(data[7] & (long)0xff);             return uadditional;           }         case 28:         case 29:         case 30:           throw new CBORException("Unexpected data encountered");         case 31:           throw new CBORException("Indefinite-length data not allowed here");         default: return headByte;       }
Magic Number,PeterO.Cbor,CBORReader,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORReader.cs,ReadDataLength,The following statement contains a magic number: switch (headByte & 0x1f) {         case 24: {             int tmp = stream.ReadByte();             if (tmp < 0) {               throw new CBORException("Premature end of data");             }             return tmp;           }         case 25: {             if (stream.Read(data' 0' 2) != 2) {               throw new CBORException("Premature end of data");             }             int lowAdditional = ((int)(data[0] & (int)0xff)) << 8;             lowAdditional |= (int)(data[1] & (int)0xff);             return lowAdditional;           }         case 26: {             if (stream.Read(data' 0' 4) != 4) {               throw new CBORException("Premature end of data");             }             long uadditional = ((long)(data[0] & (long)0xff)) << 24;             uadditional |= ((long)(data[1] & (long)0xff)) << 16;             uadditional |= ((long)(data[2] & (long)0xff)) << 8;             uadditional |= (long)(data[3] & (long)0xff);             return uadditional;           }         case 27: {             if (stream.Read(data' 0' 8) != 8) {               throw new CBORException("Premature end of data");             }             // Treat return value as an unsigned integer             long uadditional = ((long)(data[0] & (long)0xff)) << 56;             uadditional |= ((long)(data[1] & (long)0xff)) << 48;             uadditional |= ((long)(data[2] & (long)0xff)) << 40;             uadditional |= ((long)(data[3] & (long)0xff)) << 32;             uadditional |= ((long)(data[4] & (long)0xff)) << 24;             uadditional |= ((long)(data[5] & (long)0xff)) << 16;             uadditional |= ((long)(data[6] & (long)0xff)) << 8;             uadditional |= (long)(data[7] & (long)0xff);             return uadditional;           }         case 28:         case 29:         case 30:           throw new CBORException("Unexpected data encountered");         case 31:           throw new CBORException("Indefinite-length data not allowed here");         default: return headByte;       }
Magic Number,PeterO.Cbor,CBORReader,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORReader.cs,ReadDataLength,The following statement contains a magic number: switch (headByte & 0x1f) {         case 24: {             int tmp = stream.ReadByte();             if (tmp < 0) {               throw new CBORException("Premature end of data");             }             return tmp;           }         case 25: {             if (stream.Read(data' 0' 2) != 2) {               throw new CBORException("Premature end of data");             }             int lowAdditional = ((int)(data[0] & (int)0xff)) << 8;             lowAdditional |= (int)(data[1] & (int)0xff);             return lowAdditional;           }         case 26: {             if (stream.Read(data' 0' 4) != 4) {               throw new CBORException("Premature end of data");             }             long uadditional = ((long)(data[0] & (long)0xff)) << 24;             uadditional |= ((long)(data[1] & (long)0xff)) << 16;             uadditional |= ((long)(data[2] & (long)0xff)) << 8;             uadditional |= (long)(data[3] & (long)0xff);             return uadditional;           }         case 27: {             if (stream.Read(data' 0' 8) != 8) {               throw new CBORException("Premature end of data");             }             // Treat return value as an unsigned integer             long uadditional = ((long)(data[0] & (long)0xff)) << 56;             uadditional |= ((long)(data[1] & (long)0xff)) << 48;             uadditional |= ((long)(data[2] & (long)0xff)) << 40;             uadditional |= ((long)(data[3] & (long)0xff)) << 32;             uadditional |= ((long)(data[4] & (long)0xff)) << 24;             uadditional |= ((long)(data[5] & (long)0xff)) << 16;             uadditional |= ((long)(data[6] & (long)0xff)) << 8;             uadditional |= (long)(data[7] & (long)0xff);             return uadditional;           }         case 28:         case 29:         case 30:           throw new CBORException("Unexpected data encountered");         case 31:           throw new CBORException("Indefinite-length data not allowed here");         default: return headByte;       }
Magic Number,PeterO.Cbor,CBORReader,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORReader.cs,ReadDataLength,The following statement contains a magic number: switch (headByte & 0x1f) {         case 24: {             int tmp = stream.ReadByte();             if (tmp < 0) {               throw new CBORException("Premature end of data");             }             return tmp;           }         case 25: {             if (stream.Read(data' 0' 2) != 2) {               throw new CBORException("Premature end of data");             }             int lowAdditional = ((int)(data[0] & (int)0xff)) << 8;             lowAdditional |= (int)(data[1] & (int)0xff);             return lowAdditional;           }         case 26: {             if (stream.Read(data' 0' 4) != 4) {               throw new CBORException("Premature end of data");             }             long uadditional = ((long)(data[0] & (long)0xff)) << 24;             uadditional |= ((long)(data[1] & (long)0xff)) << 16;             uadditional |= ((long)(data[2] & (long)0xff)) << 8;             uadditional |= (long)(data[3] & (long)0xff);             return uadditional;           }         case 27: {             if (stream.Read(data' 0' 8) != 8) {               throw new CBORException("Premature end of data");             }             // Treat return value as an unsigned integer             long uadditional = ((long)(data[0] & (long)0xff)) << 56;             uadditional |= ((long)(data[1] & (long)0xff)) << 48;             uadditional |= ((long)(data[2] & (long)0xff)) << 40;             uadditional |= ((long)(data[3] & (long)0xff)) << 32;             uadditional |= ((long)(data[4] & (long)0xff)) << 24;             uadditional |= ((long)(data[5] & (long)0xff)) << 16;             uadditional |= ((long)(data[6] & (long)0xff)) << 8;             uadditional |= (long)(data[7] & (long)0xff);             return uadditional;           }         case 28:         case 29:         case 30:           throw new CBORException("Unexpected data encountered");         case 31:           throw new CBORException("Indefinite-length data not allowed here");         default: return headByte;       }
Magic Number,PeterO.Cbor,CBORReader,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORReader.cs,ReadDataLength,The following statement contains a magic number: switch (headByte & 0x1f) {         case 24: {             int tmp = stream.ReadByte();             if (tmp < 0) {               throw new CBORException("Premature end of data");             }             return tmp;           }         case 25: {             if (stream.Read(data' 0' 2) != 2) {               throw new CBORException("Premature end of data");             }             int lowAdditional = ((int)(data[0] & (int)0xff)) << 8;             lowAdditional |= (int)(data[1] & (int)0xff);             return lowAdditional;           }         case 26: {             if (stream.Read(data' 0' 4) != 4) {               throw new CBORException("Premature end of data");             }             long uadditional = ((long)(data[0] & (long)0xff)) << 24;             uadditional |= ((long)(data[1] & (long)0xff)) << 16;             uadditional |= ((long)(data[2] & (long)0xff)) << 8;             uadditional |= (long)(data[3] & (long)0xff);             return uadditional;           }         case 27: {             if (stream.Read(data' 0' 8) != 8) {               throw new CBORException("Premature end of data");             }             // Treat return value as an unsigned integer             long uadditional = ((long)(data[0] & (long)0xff)) << 56;             uadditional |= ((long)(data[1] & (long)0xff)) << 48;             uadditional |= ((long)(data[2] & (long)0xff)) << 40;             uadditional |= ((long)(data[3] & (long)0xff)) << 32;             uadditional |= ((long)(data[4] & (long)0xff)) << 24;             uadditional |= ((long)(data[5] & (long)0xff)) << 16;             uadditional |= ((long)(data[6] & (long)0xff)) << 8;             uadditional |= (long)(data[7] & (long)0xff);             return uadditional;           }         case 28:         case 29:         case 30:           throw new CBORException("Unexpected data encountered");         case 31:           throw new CBORException("Indefinite-length data not allowed here");         default: return headByte;       }
Magic Number,PeterO.Cbor,CBORReader,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORReader.cs,ReadDataLength,The following statement contains a magic number: switch (headByte & 0x1f) {         case 24: {             int tmp = stream.ReadByte();             if (tmp < 0) {               throw new CBORException("Premature end of data");             }             return tmp;           }         case 25: {             if (stream.Read(data' 0' 2) != 2) {               throw new CBORException("Premature end of data");             }             int lowAdditional = ((int)(data[0] & (int)0xff)) << 8;             lowAdditional |= (int)(data[1] & (int)0xff);             return lowAdditional;           }         case 26: {             if (stream.Read(data' 0' 4) != 4) {               throw new CBORException("Premature end of data");             }             long uadditional = ((long)(data[0] & (long)0xff)) << 24;             uadditional |= ((long)(data[1] & (long)0xff)) << 16;             uadditional |= ((long)(data[2] & (long)0xff)) << 8;             uadditional |= (long)(data[3] & (long)0xff);             return uadditional;           }         case 27: {             if (stream.Read(data' 0' 8) != 8) {               throw new CBORException("Premature end of data");             }             // Treat return value as an unsigned integer             long uadditional = ((long)(data[0] & (long)0xff)) << 56;             uadditional |= ((long)(data[1] & (long)0xff)) << 48;             uadditional |= ((long)(data[2] & (long)0xff)) << 40;             uadditional |= ((long)(data[3] & (long)0xff)) << 32;             uadditional |= ((long)(data[4] & (long)0xff)) << 24;             uadditional |= ((long)(data[5] & (long)0xff)) << 16;             uadditional |= ((long)(data[6] & (long)0xff)) << 8;             uadditional |= (long)(data[7] & (long)0xff);             return uadditional;           }         case 28:         case 29:         case 30:           throw new CBORException("Unexpected data encountered");         case 31:           throw new CBORException("Indefinite-length data not allowed here");         default: return headByte;       }
Magic Number,PeterO.Cbor,CBORReader,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORReader.cs,ReadDataLength,The following statement contains a magic number: switch (headByte & 0x1f) {         case 24: {             int tmp = stream.ReadByte();             if (tmp < 0) {               throw new CBORException("Premature end of data");             }             return tmp;           }         case 25: {             if (stream.Read(data' 0' 2) != 2) {               throw new CBORException("Premature end of data");             }             int lowAdditional = ((int)(data[0] & (int)0xff)) << 8;             lowAdditional |= (int)(data[1] & (int)0xff);             return lowAdditional;           }         case 26: {             if (stream.Read(data' 0' 4) != 4) {               throw new CBORException("Premature end of data");             }             long uadditional = ((long)(data[0] & (long)0xff)) << 24;             uadditional |= ((long)(data[1] & (long)0xff)) << 16;             uadditional |= ((long)(data[2] & (long)0xff)) << 8;             uadditional |= (long)(data[3] & (long)0xff);             return uadditional;           }         case 27: {             if (stream.Read(data' 0' 8) != 8) {               throw new CBORException("Premature end of data");             }             // Treat return value as an unsigned integer             long uadditional = ((long)(data[0] & (long)0xff)) << 56;             uadditional |= ((long)(data[1] & (long)0xff)) << 48;             uadditional |= ((long)(data[2] & (long)0xff)) << 40;             uadditional |= ((long)(data[3] & (long)0xff)) << 32;             uadditional |= ((long)(data[4] & (long)0xff)) << 24;             uadditional |= ((long)(data[5] & (long)0xff)) << 16;             uadditional |= ((long)(data[6] & (long)0xff)) << 8;             uadditional |= (long)(data[7] & (long)0xff);             return uadditional;           }         case 28:         case 29:         case 30:           throw new CBORException("Unexpected data encountered");         case 31:           throw new CBORException("Indefinite-length data not allowed here");         default: return headByte;       }
Magic Number,PeterO.Cbor,CBORReader,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORReader.cs,ReadDataLength,The following statement contains a magic number: switch (headByte & 0x1f) {         case 24: {             int tmp = stream.ReadByte();             if (tmp < 0) {               throw new CBORException("Premature end of data");             }             return tmp;           }         case 25: {             if (stream.Read(data' 0' 2) != 2) {               throw new CBORException("Premature end of data");             }             int lowAdditional = ((int)(data[0] & (int)0xff)) << 8;             lowAdditional |= (int)(data[1] & (int)0xff);             return lowAdditional;           }         case 26: {             if (stream.Read(data' 0' 4) != 4) {               throw new CBORException("Premature end of data");             }             long uadditional = ((long)(data[0] & (long)0xff)) << 24;             uadditional |= ((long)(data[1] & (long)0xff)) << 16;             uadditional |= ((long)(data[2] & (long)0xff)) << 8;             uadditional |= (long)(data[3] & (long)0xff);             return uadditional;           }         case 27: {             if (stream.Read(data' 0' 8) != 8) {               throw new CBORException("Premature end of data");             }             // Treat return value as an unsigned integer             long uadditional = ((long)(data[0] & (long)0xff)) << 56;             uadditional |= ((long)(data[1] & (long)0xff)) << 48;             uadditional |= ((long)(data[2] & (long)0xff)) << 40;             uadditional |= ((long)(data[3] & (long)0xff)) << 32;             uadditional |= ((long)(data[4] & (long)0xff)) << 24;             uadditional |= ((long)(data[5] & (long)0xff)) << 16;             uadditional |= ((long)(data[6] & (long)0xff)) << 8;             uadditional |= (long)(data[7] & (long)0xff);             return uadditional;           }         case 28:         case 29:         case 30:           throw new CBORException("Unexpected data encountered");         case 31:           throw new CBORException("Indefinite-length data not allowed here");         default: return headByte;       }
Magic Number,PeterO.Cbor,CBORReader,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORReader.cs,ReadDataLength,The following statement contains a magic number: switch (headByte & 0x1f) {         case 24: {             int tmp = stream.ReadByte();             if (tmp < 0) {               throw new CBORException("Premature end of data");             }             return tmp;           }         case 25: {             if (stream.Read(data' 0' 2) != 2) {               throw new CBORException("Premature end of data");             }             int lowAdditional = ((int)(data[0] & (int)0xff)) << 8;             lowAdditional |= (int)(data[1] & (int)0xff);             return lowAdditional;           }         case 26: {             if (stream.Read(data' 0' 4) != 4) {               throw new CBORException("Premature end of data");             }             long uadditional = ((long)(data[0] & (long)0xff)) << 24;             uadditional |= ((long)(data[1] & (long)0xff)) << 16;             uadditional |= ((long)(data[2] & (long)0xff)) << 8;             uadditional |= (long)(data[3] & (long)0xff);             return uadditional;           }         case 27: {             if (stream.Read(data' 0' 8) != 8) {               throw new CBORException("Premature end of data");             }             // Treat return value as an unsigned integer             long uadditional = ((long)(data[0] & (long)0xff)) << 56;             uadditional |= ((long)(data[1] & (long)0xff)) << 48;             uadditional |= ((long)(data[2] & (long)0xff)) << 40;             uadditional |= ((long)(data[3] & (long)0xff)) << 32;             uadditional |= ((long)(data[4] & (long)0xff)) << 24;             uadditional |= ((long)(data[5] & (long)0xff)) << 16;             uadditional |= ((long)(data[6] & (long)0xff)) << 8;             uadditional |= (long)(data[7] & (long)0xff);             return uadditional;           }         case 28:         case 29:         case 30:           throw new CBORException("Unexpected data encountered");         case 31:           throw new CBORException("Indefinite-length data not allowed here");         default: return headByte;       }
Magic Number,PeterO.Cbor,CBORReader,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORReader.cs,ReadDataLength,The following statement contains a magic number: switch (headByte & 0x1f) {         case 24: {             int tmp = stream.ReadByte();             if (tmp < 0) {               throw new CBORException("Premature end of data");             }             return tmp;           }         case 25: {             if (stream.Read(data' 0' 2) != 2) {               throw new CBORException("Premature end of data");             }             int lowAdditional = ((int)(data[0] & (int)0xff)) << 8;             lowAdditional |= (int)(data[1] & (int)0xff);             return lowAdditional;           }         case 26: {             if (stream.Read(data' 0' 4) != 4) {               throw new CBORException("Premature end of data");             }             long uadditional = ((long)(data[0] & (long)0xff)) << 24;             uadditional |= ((long)(data[1] & (long)0xff)) << 16;             uadditional |= ((long)(data[2] & (long)0xff)) << 8;             uadditional |= (long)(data[3] & (long)0xff);             return uadditional;           }         case 27: {             if (stream.Read(data' 0' 8) != 8) {               throw new CBORException("Premature end of data");             }             // Treat return value as an unsigned integer             long uadditional = ((long)(data[0] & (long)0xff)) << 56;             uadditional |= ((long)(data[1] & (long)0xff)) << 48;             uadditional |= ((long)(data[2] & (long)0xff)) << 40;             uadditional |= ((long)(data[3] & (long)0xff)) << 32;             uadditional |= ((long)(data[4] & (long)0xff)) << 24;             uadditional |= ((long)(data[5] & (long)0xff)) << 16;             uadditional |= ((long)(data[6] & (long)0xff)) << 8;             uadditional |= (long)(data[7] & (long)0xff);             return uadditional;           }         case 28:         case 29:         case 30:           throw new CBORException("Unexpected data encountered");         case 31:           throw new CBORException("Indefinite-length data not allowed here");         default: return headByte;       }
Magic Number,PeterO.Cbor,CBORReader,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORReader.cs,ReadDataLength,The following statement contains a magic number: switch (headByte & 0x1f) {         case 24: {             int tmp = stream.ReadByte();             if (tmp < 0) {               throw new CBORException("Premature end of data");             }             return tmp;           }         case 25: {             if (stream.Read(data' 0' 2) != 2) {               throw new CBORException("Premature end of data");             }             int lowAdditional = ((int)(data[0] & (int)0xff)) << 8;             lowAdditional |= (int)(data[1] & (int)0xff);             return lowAdditional;           }         case 26: {             if (stream.Read(data' 0' 4) != 4) {               throw new CBORException("Premature end of data");             }             long uadditional = ((long)(data[0] & (long)0xff)) << 24;             uadditional |= ((long)(data[1] & (long)0xff)) << 16;             uadditional |= ((long)(data[2] & (long)0xff)) << 8;             uadditional |= (long)(data[3] & (long)0xff);             return uadditional;           }         case 27: {             if (stream.Read(data' 0' 8) != 8) {               throw new CBORException("Premature end of data");             }             // Treat return value as an unsigned integer             long uadditional = ((long)(data[0] & (long)0xff)) << 56;             uadditional |= ((long)(data[1] & (long)0xff)) << 48;             uadditional |= ((long)(data[2] & (long)0xff)) << 40;             uadditional |= ((long)(data[3] & (long)0xff)) << 32;             uadditional |= ((long)(data[4] & (long)0xff)) << 24;             uadditional |= ((long)(data[5] & (long)0xff)) << 16;             uadditional |= ((long)(data[6] & (long)0xff)) << 8;             uadditional |= (long)(data[7] & (long)0xff);             return uadditional;           }         case 28:         case 29:         case 30:           throw new CBORException("Unexpected data encountered");         case 31:           throw new CBORException("Indefinite-length data not allowed here");         default: return headByte;       }
Magic Number,PeterO.Cbor,CBORReader,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORReader.cs,ReadDataLength,The following statement contains a magic number: switch (headByte & 0x1f) {         case 24: {             int tmp = stream.ReadByte();             if (tmp < 0) {               throw new CBORException("Premature end of data");             }             return tmp;           }         case 25: {             if (stream.Read(data' 0' 2) != 2) {               throw new CBORException("Premature end of data");             }             int lowAdditional = ((int)(data[0] & (int)0xff)) << 8;             lowAdditional |= (int)(data[1] & (int)0xff);             return lowAdditional;           }         case 26: {             if (stream.Read(data' 0' 4) != 4) {               throw new CBORException("Premature end of data");             }             long uadditional = ((long)(data[0] & (long)0xff)) << 24;             uadditional |= ((long)(data[1] & (long)0xff)) << 16;             uadditional |= ((long)(data[2] & (long)0xff)) << 8;             uadditional |= (long)(data[3] & (long)0xff);             return uadditional;           }         case 27: {             if (stream.Read(data' 0' 8) != 8) {               throw new CBORException("Premature end of data");             }             // Treat return value as an unsigned integer             long uadditional = ((long)(data[0] & (long)0xff)) << 56;             uadditional |= ((long)(data[1] & (long)0xff)) << 48;             uadditional |= ((long)(data[2] & (long)0xff)) << 40;             uadditional |= ((long)(data[3] & (long)0xff)) << 32;             uadditional |= ((long)(data[4] & (long)0xff)) << 24;             uadditional |= ((long)(data[5] & (long)0xff)) << 16;             uadditional |= ((long)(data[6] & (long)0xff)) << 8;             uadditional |= (long)(data[7] & (long)0xff);             return uadditional;           }         case 28:         case 29:         case 30:           throw new CBORException("Unexpected data encountered");         case 31:           throw new CBORException("Indefinite-length data not allowed here");         default: return headByte;       }
Magic Number,PeterO.Cbor,CBORReader,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORReader.cs,ReadDataLength,The following statement contains a magic number: switch (headByte & 0x1f) {         case 24: {             int tmp = stream.ReadByte();             if (tmp < 0) {               throw new CBORException("Premature end of data");             }             return tmp;           }         case 25: {             if (stream.Read(data' 0' 2) != 2) {               throw new CBORException("Premature end of data");             }             int lowAdditional = ((int)(data[0] & (int)0xff)) << 8;             lowAdditional |= (int)(data[1] & (int)0xff);             return lowAdditional;           }         case 26: {             if (stream.Read(data' 0' 4) != 4) {               throw new CBORException("Premature end of data");             }             long uadditional = ((long)(data[0] & (long)0xff)) << 24;             uadditional |= ((long)(data[1] & (long)0xff)) << 16;             uadditional |= ((long)(data[2] & (long)0xff)) << 8;             uadditional |= (long)(data[3] & (long)0xff);             return uadditional;           }         case 27: {             if (stream.Read(data' 0' 8) != 8) {               throw new CBORException("Premature end of data");             }             // Treat return value as an unsigned integer             long uadditional = ((long)(data[0] & (long)0xff)) << 56;             uadditional |= ((long)(data[1] & (long)0xff)) << 48;             uadditional |= ((long)(data[2] & (long)0xff)) << 40;             uadditional |= ((long)(data[3] & (long)0xff)) << 32;             uadditional |= ((long)(data[4] & (long)0xff)) << 24;             uadditional |= ((long)(data[5] & (long)0xff)) << 16;             uadditional |= ((long)(data[6] & (long)0xff)) << 8;             uadditional |= (long)(data[7] & (long)0xff);             return uadditional;           }         case 28:         case 29:         case 30:           throw new CBORException("Unexpected data encountered");         case 31:           throw new CBORException("Indefinite-length data not allowed here");         default: return headByte;       }
Magic Number,PeterO.Cbor,CBORReader,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORReader.cs,ReadDataLength,The following statement contains a magic number: switch (headByte & 0x1f) {         case 24: {             int tmp = stream.ReadByte();             if (tmp < 0) {               throw new CBORException("Premature end of data");             }             return tmp;           }         case 25: {             if (stream.Read(data' 0' 2) != 2) {               throw new CBORException("Premature end of data");             }             int lowAdditional = ((int)(data[0] & (int)0xff)) << 8;             lowAdditional |= (int)(data[1] & (int)0xff);             return lowAdditional;           }         case 26: {             if (stream.Read(data' 0' 4) != 4) {               throw new CBORException("Premature end of data");             }             long uadditional = ((long)(data[0] & (long)0xff)) << 24;             uadditional |= ((long)(data[1] & (long)0xff)) << 16;             uadditional |= ((long)(data[2] & (long)0xff)) << 8;             uadditional |= (long)(data[3] & (long)0xff);             return uadditional;           }         case 27: {             if (stream.Read(data' 0' 8) != 8) {               throw new CBORException("Premature end of data");             }             // Treat return value as an unsigned integer             long uadditional = ((long)(data[0] & (long)0xff)) << 56;             uadditional |= ((long)(data[1] & (long)0xff)) << 48;             uadditional |= ((long)(data[2] & (long)0xff)) << 40;             uadditional |= ((long)(data[3] & (long)0xff)) << 32;             uadditional |= ((long)(data[4] & (long)0xff)) << 24;             uadditional |= ((long)(data[5] & (long)0xff)) << 16;             uadditional |= ((long)(data[6] & (long)0xff)) << 8;             uadditional |= (long)(data[7] & (long)0xff);             return uadditional;           }         case 28:         case 29:         case 30:           throw new CBORException("Unexpected data encountered");         case 31:           throw new CBORException("Indefinite-length data not allowed here");         default: return headByte;       }
Magic Number,PeterO.Cbor,CBORReader,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORReader.cs,ReadDataLength,The following statement contains a magic number: switch (headByte & 0x1f) {         case 24: {             int tmp = stream.ReadByte();             if (tmp < 0) {               throw new CBORException("Premature end of data");             }             return tmp;           }         case 25: {             if (stream.Read(data' 0' 2) != 2) {               throw new CBORException("Premature end of data");             }             int lowAdditional = ((int)(data[0] & (int)0xff)) << 8;             lowAdditional |= (int)(data[1] & (int)0xff);             return lowAdditional;           }         case 26: {             if (stream.Read(data' 0' 4) != 4) {               throw new CBORException("Premature end of data");             }             long uadditional = ((long)(data[0] & (long)0xff)) << 24;             uadditional |= ((long)(data[1] & (long)0xff)) << 16;             uadditional |= ((long)(data[2] & (long)0xff)) << 8;             uadditional |= (long)(data[3] & (long)0xff);             return uadditional;           }         case 27: {             if (stream.Read(data' 0' 8) != 8) {               throw new CBORException("Premature end of data");             }             // Treat return value as an unsigned integer             long uadditional = ((long)(data[0] & (long)0xff)) << 56;             uadditional |= ((long)(data[1] & (long)0xff)) << 48;             uadditional |= ((long)(data[2] & (long)0xff)) << 40;             uadditional |= ((long)(data[3] & (long)0xff)) << 32;             uadditional |= ((long)(data[4] & (long)0xff)) << 24;             uadditional |= ((long)(data[5] & (long)0xff)) << 16;             uadditional |= ((long)(data[6] & (long)0xff)) << 8;             uadditional |= (long)(data[7] & (long)0xff);             return uadditional;           }         case 28:         case 29:         case 30:           throw new CBORException("Unexpected data encountered");         case 31:           throw new CBORException("Indefinite-length data not allowed here");         default: return headByte;       }
Magic Number,PeterO.Cbor,CBORReader,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORReader.cs,ToUnsignedBigInteger,The following statement contains a magic number: var lval = (EInteger)(val & ~(1L << 63));
Magic Number,PeterO.Cbor,CBORReader,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORReader.cs,ToUnsignedBigInteger,The following statement contains a magic number: if ((val >> 63) != 0) {         EInteger bigintAdd = EInteger.One << 63;         lval += (EInteger)bigintAdd;       }
Magic Number,PeterO.Cbor,CBORReader,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORReader.cs,ToUnsignedBigInteger,The following statement contains a magic number: if ((val >> 63) != 0) {         EInteger bigintAdd = EInteger.One << 63;         lval += (EInteger)bigintAdd;       }
Magic Number,PeterO.Cbor,CBORSingle,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORSingle.cs,Sign,The following statement contains a magic number: return Single.IsNaN(flt) ? 2 : (flt == 0.0f ? 0 : (flt < 0.0f ? -1 : 1));
Magic Number,PeterO.Cbor,CBORSingle,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORSingle.cs,IsNegative,The following statement contains a magic number: return (ivalue >> 31) != 0;
Magic Number,PeterO.Cbor,CBORTag0,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORTag0.cs,DateTimeToString,The following statement contains a magic number: var charbuf = new char[millisecond > 0 ? 24 : 20];
Magic Number,PeterO.Cbor,CBORTag0,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORTag0.cs,DateTimeToString,The following statement contains a magic number: var charbuf = new char[millisecond > 0 ? 24 : 20];
Magic Number,PeterO.Cbor,CBORTag0,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORTag0.cs,DateTimeToString,The following statement contains a magic number: charbuf[0] = (char)('0' + ((year / 1000) % 10));
Magic Number,PeterO.Cbor,CBORTag0,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORTag0.cs,DateTimeToString,The following statement contains a magic number: charbuf[0] = (char)('0' + ((year / 1000) % 10));
Magic Number,PeterO.Cbor,CBORTag0,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORTag0.cs,DateTimeToString,The following statement contains a magic number: charbuf[1] = (char)('0' + ((year / 100) % 10));
Magic Number,PeterO.Cbor,CBORTag0,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORTag0.cs,DateTimeToString,The following statement contains a magic number: charbuf[1] = (char)('0' + ((year / 100) % 10));
Magic Number,PeterO.Cbor,CBORTag0,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORTag0.cs,DateTimeToString,The following statement contains a magic number: charbuf[2] = (char)('0' + ((year / 10) % 10));
Magic Number,PeterO.Cbor,CBORTag0,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORTag0.cs,DateTimeToString,The following statement contains a magic number: charbuf[2] = (char)('0' + ((year / 10) % 10));
Magic Number,PeterO.Cbor,CBORTag0,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORTag0.cs,DateTimeToString,The following statement contains a magic number: charbuf[2] = (char)('0' + ((year / 10) % 10));
Magic Number,PeterO.Cbor,CBORTag0,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORTag0.cs,DateTimeToString,The following statement contains a magic number: charbuf[3] = (char)('0' + (year % 10));
Magic Number,PeterO.Cbor,CBORTag0,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORTag0.cs,DateTimeToString,The following statement contains a magic number: charbuf[3] = (char)('0' + (year % 10));
Magic Number,PeterO.Cbor,CBORTag0,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORTag0.cs,DateTimeToString,The following statement contains a magic number: charbuf[4] = '-';
Magic Number,PeterO.Cbor,CBORTag0,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORTag0.cs,DateTimeToString,The following statement contains a magic number: charbuf[5] = (char)('0' + ((month / 10) % 10));
Magic Number,PeterO.Cbor,CBORTag0,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORTag0.cs,DateTimeToString,The following statement contains a magic number: charbuf[5] = (char)('0' + ((month / 10) % 10));
Magic Number,PeterO.Cbor,CBORTag0,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORTag0.cs,DateTimeToString,The following statement contains a magic number: charbuf[5] = (char)('0' + ((month / 10) % 10));
Magic Number,PeterO.Cbor,CBORTag0,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORTag0.cs,DateTimeToString,The following statement contains a magic number: charbuf[6] = (char)('0' + (month % 10));
Magic Number,PeterO.Cbor,CBORTag0,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORTag0.cs,DateTimeToString,The following statement contains a magic number: charbuf[6] = (char)('0' + (month % 10));
Magic Number,PeterO.Cbor,CBORTag0,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORTag0.cs,DateTimeToString,The following statement contains a magic number: charbuf[7] = '-';
Magic Number,PeterO.Cbor,CBORTag0,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORTag0.cs,DateTimeToString,The following statement contains a magic number: charbuf[8] = (char)('0' + ((day / 10) % 10));
Magic Number,PeterO.Cbor,CBORTag0,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORTag0.cs,DateTimeToString,The following statement contains a magic number: charbuf[8] = (char)('0' + ((day / 10) % 10));
Magic Number,PeterO.Cbor,CBORTag0,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORTag0.cs,DateTimeToString,The following statement contains a magic number: charbuf[8] = (char)('0' + ((day / 10) % 10));
Magic Number,PeterO.Cbor,CBORTag0,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORTag0.cs,DateTimeToString,The following statement contains a magic number: charbuf[9] = (char)('0' + (day % 10));
Magic Number,PeterO.Cbor,CBORTag0,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORTag0.cs,DateTimeToString,The following statement contains a magic number: charbuf[9] = (char)('0' + (day % 10));
Magic Number,PeterO.Cbor,CBORTag0,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORTag0.cs,DateTimeToString,The following statement contains a magic number: charbuf[10] = 'T';
Magic Number,PeterO.Cbor,CBORTag0,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORTag0.cs,DateTimeToString,The following statement contains a magic number: charbuf[11] = (char)('0' + ((hour / 10) % 10));
Magic Number,PeterO.Cbor,CBORTag0,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORTag0.cs,DateTimeToString,The following statement contains a magic number: charbuf[11] = (char)('0' + ((hour / 10) % 10));
Magic Number,PeterO.Cbor,CBORTag0,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORTag0.cs,DateTimeToString,The following statement contains a magic number: charbuf[11] = (char)('0' + ((hour / 10) % 10));
Magic Number,PeterO.Cbor,CBORTag0,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORTag0.cs,DateTimeToString,The following statement contains a magic number: charbuf[12] = (char)('0' + (hour % 10));
Magic Number,PeterO.Cbor,CBORTag0,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORTag0.cs,DateTimeToString,The following statement contains a magic number: charbuf[12] = (char)('0' + (hour % 10));
Magic Number,PeterO.Cbor,CBORTag0,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORTag0.cs,DateTimeToString,The following statement contains a magic number: charbuf[13] = ':';
Magic Number,PeterO.Cbor,CBORTag0,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORTag0.cs,DateTimeToString,The following statement contains a magic number: charbuf[14] = (char)('0' + ((minute / 10) % 10));
Magic Number,PeterO.Cbor,CBORTag0,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORTag0.cs,DateTimeToString,The following statement contains a magic number: charbuf[14] = (char)('0' + ((minute / 10) % 10));
Magic Number,PeterO.Cbor,CBORTag0,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORTag0.cs,DateTimeToString,The following statement contains a magic number: charbuf[14] = (char)('0' + ((minute / 10) % 10));
Magic Number,PeterO.Cbor,CBORTag0,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORTag0.cs,DateTimeToString,The following statement contains a magic number: charbuf[15] = (char)('0' + (minute % 10));
Magic Number,PeterO.Cbor,CBORTag0,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORTag0.cs,DateTimeToString,The following statement contains a magic number: charbuf[15] = (char)('0' + (minute % 10));
Magic Number,PeterO.Cbor,CBORTag0,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORTag0.cs,DateTimeToString,The following statement contains a magic number: charbuf[16] = ':';
Magic Number,PeterO.Cbor,CBORTag0,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORTag0.cs,DateTimeToString,The following statement contains a magic number: charbuf[17] = (char)('0' + ((second / 10) % 10));
Magic Number,PeterO.Cbor,CBORTag0,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORTag0.cs,DateTimeToString,The following statement contains a magic number: charbuf[17] = (char)('0' + ((second / 10) % 10));
Magic Number,PeterO.Cbor,CBORTag0,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORTag0.cs,DateTimeToString,The following statement contains a magic number: charbuf[17] = (char)('0' + ((second / 10) % 10));
Magic Number,PeterO.Cbor,CBORTag0,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORTag0.cs,DateTimeToString,The following statement contains a magic number: charbuf[18] = (char)('0' + (second % 10));
Magic Number,PeterO.Cbor,CBORTag0,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORTag0.cs,DateTimeToString,The following statement contains a magic number: charbuf[18] = (char)('0' + (second % 10));
Magic Number,PeterO.Cbor,CBORTag0,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORTag0.cs,DateTimeToString,The following statement contains a magic number: if (millisecond > 0) {         charbuf[19] = '.';         charbuf[20] = (char)('0' + ((millisecond / 100) % 10));         charbuf[21] = (char)('0' + ((millisecond / 10) % 10));         charbuf[22] = (char)('0' + (millisecond % 10));         charbuf[23] = 'Z';       } else {         charbuf[19] = 'Z';       }
Magic Number,PeterO.Cbor,CBORTag0,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORTag0.cs,DateTimeToString,The following statement contains a magic number: if (millisecond > 0) {         charbuf[19] = '.';         charbuf[20] = (char)('0' + ((millisecond / 100) % 10));         charbuf[21] = (char)('0' + ((millisecond / 10) % 10));         charbuf[22] = (char)('0' + (millisecond % 10));         charbuf[23] = 'Z';       } else {         charbuf[19] = 'Z';       }
Magic Number,PeterO.Cbor,CBORTag0,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORTag0.cs,DateTimeToString,The following statement contains a magic number: if (millisecond > 0) {         charbuf[19] = '.';         charbuf[20] = (char)('0' + ((millisecond / 100) % 10));         charbuf[21] = (char)('0' + ((millisecond / 10) % 10));         charbuf[22] = (char)('0' + (millisecond % 10));         charbuf[23] = 'Z';       } else {         charbuf[19] = 'Z';       }
Magic Number,PeterO.Cbor,CBORTag0,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORTag0.cs,DateTimeToString,The following statement contains a magic number: if (millisecond > 0) {         charbuf[19] = '.';         charbuf[20] = (char)('0' + ((millisecond / 100) % 10));         charbuf[21] = (char)('0' + ((millisecond / 10) % 10));         charbuf[22] = (char)('0' + (millisecond % 10));         charbuf[23] = 'Z';       } else {         charbuf[19] = 'Z';       }
Magic Number,PeterO.Cbor,CBORTag0,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORTag0.cs,DateTimeToString,The following statement contains a magic number: if (millisecond > 0) {         charbuf[19] = '.';         charbuf[20] = (char)('0' + ((millisecond / 100) % 10));         charbuf[21] = (char)('0' + ((millisecond / 10) % 10));         charbuf[22] = (char)('0' + (millisecond % 10));         charbuf[23] = 'Z';       } else {         charbuf[19] = 'Z';       }
Magic Number,PeterO.Cbor,CBORTag0,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORTag0.cs,DateTimeToString,The following statement contains a magic number: if (millisecond > 0) {         charbuf[19] = '.';         charbuf[20] = (char)('0' + ((millisecond / 100) % 10));         charbuf[21] = (char)('0' + ((millisecond / 10) % 10));         charbuf[22] = (char)('0' + (millisecond % 10));         charbuf[23] = 'Z';       } else {         charbuf[19] = 'Z';       }
Magic Number,PeterO.Cbor,CBORTag0,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORTag0.cs,DateTimeToString,The following statement contains a magic number: if (millisecond > 0) {         charbuf[19] = '.';         charbuf[20] = (char)('0' + ((millisecond / 100) % 10));         charbuf[21] = (char)('0' + ((millisecond / 10) % 10));         charbuf[22] = (char)('0' + (millisecond % 10));         charbuf[23] = 'Z';       } else {         charbuf[19] = 'Z';       }
Magic Number,PeterO.Cbor,CBORTag0,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORTag0.cs,DateTimeToString,The following statement contains a magic number: if (millisecond > 0) {         charbuf[19] = '.';         charbuf[20] = (char)('0' + ((millisecond / 100) % 10));         charbuf[21] = (char)('0' + ((millisecond / 10) % 10));         charbuf[22] = (char)('0' + (millisecond % 10));         charbuf[23] = 'Z';       } else {         charbuf[19] = 'Z';       }
Magic Number,PeterO.Cbor,CBORTag0,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORTag0.cs,DateTimeToString,The following statement contains a magic number: if (millisecond > 0) {         charbuf[19] = '.';         charbuf[20] = (char)('0' + ((millisecond / 100) % 10));         charbuf[21] = (char)('0' + ((millisecond / 10) % 10));         charbuf[22] = (char)('0' + (millisecond % 10));         charbuf[23] = 'Z';       } else {         charbuf[19] = 'Z';       }
Magic Number,PeterO.Cbor,CBORTag0,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORTag0.cs,DateTimeToString,The following statement contains a magic number: if (millisecond > 0) {         charbuf[19] = '.';         charbuf[20] = (char)('0' + ((millisecond / 100) % 10));         charbuf[21] = (char)('0' + ((millisecond / 10) % 10));         charbuf[22] = (char)('0' + (millisecond % 10));         charbuf[23] = 'Z';       } else {         charbuf[19] = 'Z';       }
Magic Number,PeterO.Cbor,CBORTag0,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORTag0.cs,DateTimeToString,The following statement contains a magic number: if (millisecond > 0) {         charbuf[19] = '.';         charbuf[20] = (char)('0' + ((millisecond / 100) % 10));         charbuf[21] = (char)('0' + ((millisecond / 10) % 10));         charbuf[22] = (char)('0' + (millisecond % 10));         charbuf[23] = 'Z';       } else {         charbuf[19] = 'Z';       }
Magic Number,PeterO.Cbor,CBORTag2,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORTag2.cs,ConvertToBigNum,The following statement contains a magic number: if (data.Length <= 7) {         long x = 0;         for (var i = 0; i < data.Length; ++i) {           x <<= 8;           x |= ((long)data[i]) & 0xff;         }         if (negative) {           x = -x;           --x;         }         return FromObjectAndInnerTags(x' o);       }
Magic Number,PeterO.Cbor,CBORTag2,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORTag2.cs,ConvertToBigNum,The following statement contains a magic number: if (data.Length <= 7) {         long x = 0;         for (var i = 0; i < data.Length; ++i) {           x <<= 8;           x |= ((long)data[i]) & 0xff;         }         if (negative) {           x = -x;           --x;         }         return FromObjectAndInnerTags(x' o);       }
Magic Number,PeterO.Cbor,CBORTag2,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORTag2.cs,ConvertToBigNum,The following statement contains a magic number: if (((data[0] >> 7) & 1) != 0) {         // Increase the needed length         // if the highest bit is set' to         // distinguish negative and positive         // values         ++neededLength;         extended = true;       }
Magic Number,PeterO.Cbor,CBORTag30,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORTag30.cs,GetTypeFilter,The following statement contains a magic number: return new CBORTypeFilter().WithArrayExactLength(         2'         CBORTypeFilter.UnsignedInteger.WithNegativeInteger().WithTags(2' 3)'         CBORTypeFilter.UnsignedInteger.WithTags(2));
Magic Number,PeterO.Cbor,CBORTag30,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORTag30.cs,GetTypeFilter,The following statement contains a magic number: return new CBORTypeFilter().WithArrayExactLength(         2'         CBORTypeFilter.UnsignedInteger.WithNegativeInteger().WithTags(2' 3)'         CBORTypeFilter.UnsignedInteger.WithTags(2));
Magic Number,PeterO.Cbor,CBORTag30,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORTag30.cs,GetTypeFilter,The following statement contains a magic number: return new CBORTypeFilter().WithArrayExactLength(         2'         CBORTypeFilter.UnsignedInteger.WithNegativeInteger().WithTags(2' 3)'         CBORTypeFilter.UnsignedInteger.WithTags(2));
Magic Number,PeterO.Cbor,CBORTag30,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORTag30.cs,GetTypeFilter,The following statement contains a magic number: return new CBORTypeFilter().WithArrayExactLength(         2'         CBORTypeFilter.UnsignedInteger.WithNegativeInteger().WithTags(2' 3)'         CBORTypeFilter.UnsignedInteger.WithTags(2));
Magic Number,PeterO.Cbor,CBORTag30,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORTag30.cs,ValidateObject,The following statement contains a magic number: if (obj.Count != 2) {         throw new CBORException("Rational number requires exactly 2 items");       }
Magic Number,PeterO.Cbor,CBORTag32,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORTag32.cs,ToCBORObject,The following statement contains a magic number: return CBORObject.FromObjectAndTag(uriString' (int)32);
Magic Number,PeterO.Cbor,CBORTag37,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORTag37.cs,ValidateObject,The following statement contains a magic number: if (bytes.Length != 16) {         throw new CBORException("UUID must be 16 bytes long");       }
Magic Number,PeterO.Cbor,CBORTag37,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORTag37.cs,ToCBORObject,The following statement contains a magic number: var bytes2 = new byte[16];
Magic Number,PeterO.Cbor,CBORTag37,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORTag37.cs,ToCBORObject,The following statement contains a magic number: Array.Copy(bytes' bytes2' 16);
Magic Number,PeterO.Cbor,CBORTag37,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORTag37.cs,ToCBORObject,The following statement contains a magic number: bytes2[0] = bytes[3];
Magic Number,PeterO.Cbor,CBORTag37,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORTag37.cs,ToCBORObject,The following statement contains a magic number: bytes2[1] = bytes[2];
Magic Number,PeterO.Cbor,CBORTag37,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORTag37.cs,ToCBORObject,The following statement contains a magic number: bytes2[2] = bytes[1];
Magic Number,PeterO.Cbor,CBORTag37,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORTag37.cs,ToCBORObject,The following statement contains a magic number: bytes2[3] = bytes[0];
Magic Number,PeterO.Cbor,CBORTag37,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORTag37.cs,ToCBORObject,The following statement contains a magic number: bytes2[4] = bytes[5];
Magic Number,PeterO.Cbor,CBORTag37,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORTag37.cs,ToCBORObject,The following statement contains a magic number: bytes2[4] = bytes[5];
Magic Number,PeterO.Cbor,CBORTag37,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORTag37.cs,ToCBORObject,The following statement contains a magic number: bytes2[5] = bytes[4];
Magic Number,PeterO.Cbor,CBORTag37,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORTag37.cs,ToCBORObject,The following statement contains a magic number: bytes2[5] = bytes[4];
Magic Number,PeterO.Cbor,CBORTag37,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORTag37.cs,ToCBORObject,The following statement contains a magic number: bytes2[6] = bytes[7];
Magic Number,PeterO.Cbor,CBORTag37,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORTag37.cs,ToCBORObject,The following statement contains a magic number: bytes2[6] = bytes[7];
Magic Number,PeterO.Cbor,CBORTag37,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORTag37.cs,ToCBORObject,The following statement contains a magic number: bytes2[7] = bytes[6];
Magic Number,PeterO.Cbor,CBORTag37,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORTag37.cs,ToCBORObject,The following statement contains a magic number: bytes2[7] = bytes[6];
Magic Number,PeterO.Cbor,CBORTag37,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORTag37.cs,ToCBORObject,The following statement contains a magic number: return CBORObject.FromObjectAndTag(bytes2' (int)37);
Magic Number,PeterO.Cbor,CBORTag5,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORTag5.cs,ConvertToDecimalFrac,The following statement contains a magic number: if (o.Count != 2) {         throw new CBORException("Big fraction requires exactly 2 items");       }
Magic Number,PeterO.Cbor,CBORTag5,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORTag5.cs,ConvertToDecimalFrac,The following statement contains a magic number: if (exponent.GetSignedBitLength() > 64 && !extended) {         throw new CBORException("Exponent is too big");       }
Magic Number,PeterO.Cbor,CBORTypeFilter,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORTypeFilter.cs,ArrayIndexAllowed,The following statement contains a magic number: return (this.types & (1 << 4)) != 0 && index >= 0 &&         (this.anyArrayLength ||         ((this.arrayMinLength || index < this.arrayLength) && index >=                     0));
Magic Number,PeterO.Cbor,CBORTypeFilter,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORTypeFilter.cs,ArrayLengthMatches,The following statement contains a magic number: return (this.types & (1 << 4)) != 0 && (this.anyArrayLength ||                 (this.arrayMinLength ? this.arrayLength >= length :                 this.arrayLength == length));
Magic Number,PeterO.Cbor,CBORTypeFilter,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORTypeFilter.cs,ArrayLengthMatches,The following statement contains a magic number: return (this.types & (1 << 4)) != 0 && (this.anyArrayLength ||                 (this.arrayMinLength ? this.arrayLength >= length :                 this.arrayLength == length));
Magic Number,PeterO.Cbor,CBORTypeFilter,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORTypeFilter.cs,ArrayLengthMatches,The following statement contains a magic number: return ((this.types & (1 << 4)) == 0) && (this.anyArrayLength ||         ((!this.arrayMinLength &&         bigLength.CompareTo((EInteger)this.arrayLength) == 0) ||         (this.arrayMinLength &&         bigLength.CompareTo((EInteger)this.arrayLength) >= 0)));
Magic Number,PeterO.Cbor,CBORTypeFilter,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORTypeFilter.cs,MajorTypeMatches,The following statement contains a magic number: if (type > 7) {         throw new ArgumentException("type (" + type + ") is more than " + "7");       }
Magic Number,PeterO.Cbor,CBORTypeFilter,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORTypeFilter.cs,MajorTypeMatches,The following statement contains a magic number: return type >= 0 && type <= 7 && (this.types & (1 << type)) != 0;
Magic Number,PeterO.Cbor,CBORTypeFilter,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORTypeFilter.cs,NonFPSimpleValueAllowed,The following statement contains a magic number: return this.MajorTypeMatches(7) && !this.floatingpoint;
Magic Number,PeterO.Cbor,CBORTypeFilter,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORTypeFilter.cs,TagAllowed,The following statement contains a magic number: if ((this.types & (1 << 6)) == 0) {         return false;       }
Magic Number,PeterO.Cbor,CBORTypeFilter,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORTypeFilter.cs,WithArrayAnyLength,The following statement contains a magic number: filter.types |= 1 << 4;
Magic Number,PeterO.Cbor,CBORTypeFilter,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORTypeFilter.cs,WithArrayExactLength,The following statement contains a magic number: filter.types |= 1 << 4;
Magic Number,PeterO.Cbor,CBORTypeFilter,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORTypeFilter.cs,WithArrayMinLength,The following statement contains a magic number: filter.types |= 1 << 4;
Magic Number,PeterO.Cbor,CBORTypeFilter,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORTypeFilter.cs,WithByteString,The following statement contains a magic number: return this.WithType(2).WithTags(25);
Magic Number,PeterO.Cbor,CBORTypeFilter,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORTypeFilter.cs,WithByteString,The following statement contains a magic number: return this.WithType(2).WithTags(25);
Magic Number,PeterO.Cbor,CBORTypeFilter,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORTypeFilter.cs,WithFloatingPoint,The following statement contains a magic number: filter.types |= 1 << 4;
Magic Number,PeterO.Cbor,CBORTypeFilter,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORTypeFilter.cs,WithMap,The following statement contains a magic number: return this.WithType(5);
Magic Number,PeterO.Cbor,CBORTypeFilter,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORTypeFilter.cs,WithTags,The following statement contains a magic number: filter.types |= 1 << 6;
Magic Number,PeterO.Cbor,CBORTypeFilter,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORTypeFilter.cs,WithTags,The following statement contains a magic number: filter.types |= 1 << 6;
Magic Number,PeterO.Cbor,CBORTypeFilter,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORTypeFilter.cs,WithTextString,The following statement contains a magic number: return this.WithType(3).WithTags(25);
Magic Number,PeterO.Cbor,CBORTypeFilter,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORTypeFilter.cs,WithTextString,The following statement contains a magic number: return this.WithType(3).WithTags(25);
Magic Number,PeterO.Cbor,CBORUtilities,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORUtilities.cs,ToBase16,The following statement contains a magic number: for (var i = 0; i < length; ++i) {         str.Append(HexAlphabet[(data[i] >> 4) & 15]);         str.Append(HexAlphabet[data[i] & 15]);       }
Magic Number,PeterO.Cbor,CBORUtilities,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORUtilities.cs,ToBase16,The following statement contains a magic number: for (var i = 0; i < length; ++i) {         str.Append(HexAlphabet[(data[i] >> 4) & 15]);         str.Append(HexAlphabet[data[i] & 15]);       }
Magic Number,PeterO.Cbor,CBORUtilities,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORUtilities.cs,ToBase16,The following statement contains a magic number: for (var i = 0; i < length; ++i) {         str.Append(HexAlphabet[(data[i] >> 4) & 15]);         str.Append(HexAlphabet[data[i] & 15]);       }
Magic Number,PeterO.Cbor,CBORUtilities,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORUtilities.cs,ByteArrayHashCode,The following statement contains a magic number: var ret = 19;
Magic Number,PeterO.Cbor,CBORUtilities,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORUtilities.cs,ByteArrayHashCode,The following statement contains a magic number: unchecked {         ret = (ret * 31) + a.Length;         for (var i = 0; i < a.Length; ++i) {           ret = (ret * 31) + a[i];         }       }
Magic Number,PeterO.Cbor,CBORUtilities,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORUtilities.cs,ByteArrayHashCode,The following statement contains a magic number: unchecked {         ret = (ret * 31) + a.Length;         for (var i = 0; i < a.Length; ++i) {           ret = (ret * 31) + a[i];         }       }
Magic Number,PeterO.Cbor,CBORUtilities,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORUtilities.cs,BigIntegerFromSingle,The following statement contains a magic number: var fpexponent = (int)((value >> 23) & 0xff);
Magic Number,PeterO.Cbor,CBORUtilities,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORUtilities.cs,BigIntegerFromSingle,The following statement contains a magic number: if (fpexponent == 255) {         throw new OverflowException("Value is infinity or NaN");       }
Magic Number,PeterO.Cbor,CBORUtilities,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORUtilities.cs,BigIntegerFromSingle,The following statement contains a magic number: if (fpexponent == 0) {         ++fpexponent;       } else {         mantissa |= 1 << 23;       }
Magic Number,PeterO.Cbor,CBORUtilities,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORUtilities.cs,BigIntegerFromSingle,The following statement contains a magic number: fpexponent -= 150;
Magic Number,PeterO.Cbor,CBORUtilities,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORUtilities.cs,BigIntegerFromSingle,The following statement contains a magic number: bool neg = (value >> 31) != 0;
Magic Number,PeterO.Cbor,CBORUtilities,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORUtilities.cs,LongToString,The following statement contains a magic number: if ((long)intlongValue == longValue) {         chars = new char[12];         count = 11;         if (neg) {           intlongValue = -intlongValue;         }         while (intlongValue > 43698) {           int intdivValue = intlongValue / 10;         char digit = HexAlphabet[(int)(intlongValue - (intdivValue * 10))];         chars[count--] = digit;         intlongValue = intdivValue;       }       while (intlongValue > 9) {         int intdivValue = (intlongValue * 26215) >> 18;         char digit = HexAlphabet[(int)(intlongValue - (intdivValue * 10))];         chars[count--] = digit;         intlongValue = intdivValue;       }       if (intlongValue != 0) {         chars[count--] = HexAlphabet[(int)intlongValue];       }       if (neg) {         chars[count] = '-';       } else {         ++count;       }       return new String(chars' count' 12 - count);       } else {         chars = new char[24];         count = 23;         if (neg) {           longValue = -longValue;         }         while (longValue > 43698) {           long divValue = longValue / 10;         char digit = HexAlphabet[(int)(longValue - (divValue * 10))];         chars[count--] = digit;         longValue = divValue;       }       while (longValue > 9) {         long divValue = (longValue * 26215) >> 18;         char digit = HexAlphabet[(int)(longValue - (divValue * 10))];         chars[count--] = digit;         longValue = divValue;       }       if (longValue != 0) {         chars[count--] = HexAlphabet[(int)longValue];       }       if (neg) {         chars[count] = '-';       } else {         ++count;       }       return new String(chars' count' 24 - count);       }
Magic Number,PeterO.Cbor,CBORUtilities,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORUtilities.cs,LongToString,The following statement contains a magic number: if ((long)intlongValue == longValue) {         chars = new char[12];         count = 11;         if (neg) {           intlongValue = -intlongValue;         }         while (intlongValue > 43698) {           int intdivValue = intlongValue / 10;         char digit = HexAlphabet[(int)(intlongValue - (intdivValue * 10))];         chars[count--] = digit;         intlongValue = intdivValue;       }       while (intlongValue > 9) {         int intdivValue = (intlongValue * 26215) >> 18;         char digit = HexAlphabet[(int)(intlongValue - (intdivValue * 10))];         chars[count--] = digit;         intlongValue = intdivValue;       }       if (intlongValue != 0) {         chars[count--] = HexAlphabet[(int)intlongValue];       }       if (neg) {         chars[count] = '-';       } else {         ++count;       }       return new String(chars' count' 12 - count);       } else {         chars = new char[24];         count = 23;         if (neg) {           longValue = -longValue;         }         while (longValue > 43698) {           long divValue = longValue / 10;         char digit = HexAlphabet[(int)(longValue - (divValue * 10))];         chars[count--] = digit;         longValue = divValue;       }       while (longValue > 9) {         long divValue = (longValue * 26215) >> 18;         char digit = HexAlphabet[(int)(longValue - (divValue * 10))];         chars[count--] = digit;         longValue = divValue;       }       if (longValue != 0) {         chars[count--] = HexAlphabet[(int)longValue];       }       if (neg) {         chars[count] = '-';       } else {         ++count;       }       return new String(chars' count' 24 - count);       }
Magic Number,PeterO.Cbor,CBORUtilities,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORUtilities.cs,LongToString,The following statement contains a magic number: if ((long)intlongValue == longValue) {         chars = new char[12];         count = 11;         if (neg) {           intlongValue = -intlongValue;         }         while (intlongValue > 43698) {           int intdivValue = intlongValue / 10;         char digit = HexAlphabet[(int)(intlongValue - (intdivValue * 10))];         chars[count--] = digit;         intlongValue = intdivValue;       }       while (intlongValue > 9) {         int intdivValue = (intlongValue * 26215) >> 18;         char digit = HexAlphabet[(int)(intlongValue - (intdivValue * 10))];         chars[count--] = digit;         intlongValue = intdivValue;       }       if (intlongValue != 0) {         chars[count--] = HexAlphabet[(int)intlongValue];       }       if (neg) {         chars[count] = '-';       } else {         ++count;       }       return new String(chars' count' 12 - count);       } else {         chars = new char[24];         count = 23;         if (neg) {           longValue = -longValue;         }         while (longValue > 43698) {           long divValue = longValue / 10;         char digit = HexAlphabet[(int)(longValue - (divValue * 10))];         chars[count--] = digit;         longValue = divValue;       }       while (longValue > 9) {         long divValue = (longValue * 26215) >> 18;         char digit = HexAlphabet[(int)(longValue - (divValue * 10))];         chars[count--] = digit;         longValue = divValue;       }       if (longValue != 0) {         chars[count--] = HexAlphabet[(int)longValue];       }       if (neg) {         chars[count] = '-';       } else {         ++count;       }       return new String(chars' count' 24 - count);       }
Magic Number,PeterO.Cbor,CBORUtilities,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORUtilities.cs,LongToString,The following statement contains a magic number: if ((long)intlongValue == longValue) {         chars = new char[12];         count = 11;         if (neg) {           intlongValue = -intlongValue;         }         while (intlongValue > 43698) {           int intdivValue = intlongValue / 10;         char digit = HexAlphabet[(int)(intlongValue - (intdivValue * 10))];         chars[count--] = digit;         intlongValue = intdivValue;       }       while (intlongValue > 9) {         int intdivValue = (intlongValue * 26215) >> 18;         char digit = HexAlphabet[(int)(intlongValue - (intdivValue * 10))];         chars[count--] = digit;         intlongValue = intdivValue;       }       if (intlongValue != 0) {         chars[count--] = HexAlphabet[(int)intlongValue];       }       if (neg) {         chars[count] = '-';       } else {         ++count;       }       return new String(chars' count' 12 - count);       } else {         chars = new char[24];         count = 23;         if (neg) {           longValue = -longValue;         }         while (longValue > 43698) {           long divValue = longValue / 10;         char digit = HexAlphabet[(int)(longValue - (divValue * 10))];         chars[count--] = digit;         longValue = divValue;       }       while (longValue > 9) {         long divValue = (longValue * 26215) >> 18;         char digit = HexAlphabet[(int)(longValue - (divValue * 10))];         chars[count--] = digit;         longValue = divValue;       }       if (longValue != 0) {         chars[count--] = HexAlphabet[(int)longValue];       }       if (neg) {         chars[count] = '-';       } else {         ++count;       }       return new String(chars' count' 24 - count);       }
Magic Number,PeterO.Cbor,CBORUtilities,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORUtilities.cs,LongToString,The following statement contains a magic number: if ((long)intlongValue == longValue) {         chars = new char[12];         count = 11;         if (neg) {           intlongValue = -intlongValue;         }         while (intlongValue > 43698) {           int intdivValue = intlongValue / 10;         char digit = HexAlphabet[(int)(intlongValue - (intdivValue * 10))];         chars[count--] = digit;         intlongValue = intdivValue;       }       while (intlongValue > 9) {         int intdivValue = (intlongValue * 26215) >> 18;         char digit = HexAlphabet[(int)(intlongValue - (intdivValue * 10))];         chars[count--] = digit;         intlongValue = intdivValue;       }       if (intlongValue != 0) {         chars[count--] = HexAlphabet[(int)intlongValue];       }       if (neg) {         chars[count] = '-';       } else {         ++count;       }       return new String(chars' count' 12 - count);       } else {         chars = new char[24];         count = 23;         if (neg) {           longValue = -longValue;         }         while (longValue > 43698) {           long divValue = longValue / 10;         char digit = HexAlphabet[(int)(longValue - (divValue * 10))];         chars[count--] = digit;         longValue = divValue;       }       while (longValue > 9) {         long divValue = (longValue * 26215) >> 18;         char digit = HexAlphabet[(int)(longValue - (divValue * 10))];         chars[count--] = digit;         longValue = divValue;       }       if (longValue != 0) {         chars[count--] = HexAlphabet[(int)longValue];       }       if (neg) {         chars[count] = '-';       } else {         ++count;       }       return new String(chars' count' 24 - count);       }
Magic Number,PeterO.Cbor,CBORUtilities,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORUtilities.cs,LongToString,The following statement contains a magic number: if ((long)intlongValue == longValue) {         chars = new char[12];         count = 11;         if (neg) {           intlongValue = -intlongValue;         }         while (intlongValue > 43698) {           int intdivValue = intlongValue / 10;         char digit = HexAlphabet[(int)(intlongValue - (intdivValue * 10))];         chars[count--] = digit;         intlongValue = intdivValue;       }       while (intlongValue > 9) {         int intdivValue = (intlongValue * 26215) >> 18;         char digit = HexAlphabet[(int)(intlongValue - (intdivValue * 10))];         chars[count--] = digit;         intlongValue = intdivValue;       }       if (intlongValue != 0) {         chars[count--] = HexAlphabet[(int)intlongValue];       }       if (neg) {         chars[count] = '-';       } else {         ++count;       }       return new String(chars' count' 12 - count);       } else {         chars = new char[24];         count = 23;         if (neg) {           longValue = -longValue;         }         while (longValue > 43698) {           long divValue = longValue / 10;         char digit = HexAlphabet[(int)(longValue - (divValue * 10))];         chars[count--] = digit;         longValue = divValue;       }       while (longValue > 9) {         long divValue = (longValue * 26215) >> 18;         char digit = HexAlphabet[(int)(longValue - (divValue * 10))];         chars[count--] = digit;         longValue = divValue;       }       if (longValue != 0) {         chars[count--] = HexAlphabet[(int)longValue];       }       if (neg) {         chars[count] = '-';       } else {         ++count;       }       return new String(chars' count' 24 - count);       }
Magic Number,PeterO.Cbor,CBORUtilities,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORUtilities.cs,LongToString,The following statement contains a magic number: if ((long)intlongValue == longValue) {         chars = new char[12];         count = 11;         if (neg) {           intlongValue = -intlongValue;         }         while (intlongValue > 43698) {           int intdivValue = intlongValue / 10;         char digit = HexAlphabet[(int)(intlongValue - (intdivValue * 10))];         chars[count--] = digit;         intlongValue = intdivValue;       }       while (intlongValue > 9) {         int intdivValue = (intlongValue * 26215) >> 18;         char digit = HexAlphabet[(int)(intlongValue - (intdivValue * 10))];         chars[count--] = digit;         intlongValue = intdivValue;       }       if (intlongValue != 0) {         chars[count--] = HexAlphabet[(int)intlongValue];       }       if (neg) {         chars[count] = '-';       } else {         ++count;       }       return new String(chars' count' 12 - count);       } else {         chars = new char[24];         count = 23;         if (neg) {           longValue = -longValue;         }         while (longValue > 43698) {           long divValue = longValue / 10;         char digit = HexAlphabet[(int)(longValue - (divValue * 10))];         chars[count--] = digit;         longValue = divValue;       }       while (longValue > 9) {         long divValue = (longValue * 26215) >> 18;         char digit = HexAlphabet[(int)(longValue - (divValue * 10))];         chars[count--] = digit;         longValue = divValue;       }       if (longValue != 0) {         chars[count--] = HexAlphabet[(int)longValue];       }       if (neg) {         chars[count] = '-';       } else {         ++count;       }       return new String(chars' count' 24 - count);       }
Magic Number,PeterO.Cbor,CBORUtilities,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORUtilities.cs,LongToString,The following statement contains a magic number: if ((long)intlongValue == longValue) {         chars = new char[12];         count = 11;         if (neg) {           intlongValue = -intlongValue;         }         while (intlongValue > 43698) {           int intdivValue = intlongValue / 10;         char digit = HexAlphabet[(int)(intlongValue - (intdivValue * 10))];         chars[count--] = digit;         intlongValue = intdivValue;       }       while (intlongValue > 9) {         int intdivValue = (intlongValue * 26215) >> 18;         char digit = HexAlphabet[(int)(intlongValue - (intdivValue * 10))];         chars[count--] = digit;         intlongValue = intdivValue;       }       if (intlongValue != 0) {         chars[count--] = HexAlphabet[(int)intlongValue];       }       if (neg) {         chars[count] = '-';       } else {         ++count;       }       return new String(chars' count' 12 - count);       } else {         chars = new char[24];         count = 23;         if (neg) {           longValue = -longValue;         }         while (longValue > 43698) {           long divValue = longValue / 10;         char digit = HexAlphabet[(int)(longValue - (divValue * 10))];         chars[count--] = digit;         longValue = divValue;       }       while (longValue > 9) {         long divValue = (longValue * 26215) >> 18;         char digit = HexAlphabet[(int)(longValue - (divValue * 10))];         chars[count--] = digit;         longValue = divValue;       }       if (longValue != 0) {         chars[count--] = HexAlphabet[(int)longValue];       }       if (neg) {         chars[count] = '-';       } else {         ++count;       }       return new String(chars' count' 24 - count);       }
Magic Number,PeterO.Cbor,CBORUtilities,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORUtilities.cs,LongToString,The following statement contains a magic number: if ((long)intlongValue == longValue) {         chars = new char[12];         count = 11;         if (neg) {           intlongValue = -intlongValue;         }         while (intlongValue > 43698) {           int intdivValue = intlongValue / 10;         char digit = HexAlphabet[(int)(intlongValue - (intdivValue * 10))];         chars[count--] = digit;         intlongValue = intdivValue;       }       while (intlongValue > 9) {         int intdivValue = (intlongValue * 26215) >> 18;         char digit = HexAlphabet[(int)(intlongValue - (intdivValue * 10))];         chars[count--] = digit;         intlongValue = intdivValue;       }       if (intlongValue != 0) {         chars[count--] = HexAlphabet[(int)intlongValue];       }       if (neg) {         chars[count] = '-';       } else {         ++count;       }       return new String(chars' count' 12 - count);       } else {         chars = new char[24];         count = 23;         if (neg) {           longValue = -longValue;         }         while (longValue > 43698) {           long divValue = longValue / 10;         char digit = HexAlphabet[(int)(longValue - (divValue * 10))];         chars[count--] = digit;         longValue = divValue;       }       while (longValue > 9) {         long divValue = (longValue * 26215) >> 18;         char digit = HexAlphabet[(int)(longValue - (divValue * 10))];         chars[count--] = digit;         longValue = divValue;       }       if (longValue != 0) {         chars[count--] = HexAlphabet[(int)longValue];       }       if (neg) {         chars[count] = '-';       } else {         ++count;       }       return new String(chars' count' 24 - count);       }
Magic Number,PeterO.Cbor,CBORUtilities,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORUtilities.cs,LongToString,The following statement contains a magic number: if ((long)intlongValue == longValue) {         chars = new char[12];         count = 11;         if (neg) {           intlongValue = -intlongValue;         }         while (intlongValue > 43698) {           int intdivValue = intlongValue / 10;         char digit = HexAlphabet[(int)(intlongValue - (intdivValue * 10))];         chars[count--] = digit;         intlongValue = intdivValue;       }       while (intlongValue > 9) {         int intdivValue = (intlongValue * 26215) >> 18;         char digit = HexAlphabet[(int)(intlongValue - (intdivValue * 10))];         chars[count--] = digit;         intlongValue = intdivValue;       }       if (intlongValue != 0) {         chars[count--] = HexAlphabet[(int)intlongValue];       }       if (neg) {         chars[count] = '-';       } else {         ++count;       }       return new String(chars' count' 12 - count);       } else {         chars = new char[24];         count = 23;         if (neg) {           longValue = -longValue;         }         while (longValue > 43698) {           long divValue = longValue / 10;         char digit = HexAlphabet[(int)(longValue - (divValue * 10))];         chars[count--] = digit;         longValue = divValue;       }       while (longValue > 9) {         long divValue = (longValue * 26215) >> 18;         char digit = HexAlphabet[(int)(longValue - (divValue * 10))];         chars[count--] = digit;         longValue = divValue;       }       if (longValue != 0) {         chars[count--] = HexAlphabet[(int)longValue];       }       if (neg) {         chars[count] = '-';       } else {         ++count;       }       return new String(chars' count' 24 - count);       }
Magic Number,PeterO.Cbor,CBORUtilities,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORUtilities.cs,LongToString,The following statement contains a magic number: if ((long)intlongValue == longValue) {         chars = new char[12];         count = 11;         if (neg) {           intlongValue = -intlongValue;         }         while (intlongValue > 43698) {           int intdivValue = intlongValue / 10;         char digit = HexAlphabet[(int)(intlongValue - (intdivValue * 10))];         chars[count--] = digit;         intlongValue = intdivValue;       }       while (intlongValue > 9) {         int intdivValue = (intlongValue * 26215) >> 18;         char digit = HexAlphabet[(int)(intlongValue - (intdivValue * 10))];         chars[count--] = digit;         intlongValue = intdivValue;       }       if (intlongValue != 0) {         chars[count--] = HexAlphabet[(int)intlongValue];       }       if (neg) {         chars[count] = '-';       } else {         ++count;       }       return new String(chars' count' 12 - count);       } else {         chars = new char[24];         count = 23;         if (neg) {           longValue = -longValue;         }         while (longValue > 43698) {           long divValue = longValue / 10;         char digit = HexAlphabet[(int)(longValue - (divValue * 10))];         chars[count--] = digit;         longValue = divValue;       }       while (longValue > 9) {         long divValue = (longValue * 26215) >> 18;         char digit = HexAlphabet[(int)(longValue - (divValue * 10))];         chars[count--] = digit;         longValue = divValue;       }       if (longValue != 0) {         chars[count--] = HexAlphabet[(int)longValue];       }       if (neg) {         chars[count] = '-';       } else {         ++count;       }       return new String(chars' count' 24 - count);       }
Magic Number,PeterO.Cbor,CBORUtilities,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORUtilities.cs,LongToString,The following statement contains a magic number: if ((long)intlongValue == longValue) {         chars = new char[12];         count = 11;         if (neg) {           intlongValue = -intlongValue;         }         while (intlongValue > 43698) {           int intdivValue = intlongValue / 10;         char digit = HexAlphabet[(int)(intlongValue - (intdivValue * 10))];         chars[count--] = digit;         intlongValue = intdivValue;       }       while (intlongValue > 9) {         int intdivValue = (intlongValue * 26215) >> 18;         char digit = HexAlphabet[(int)(intlongValue - (intdivValue * 10))];         chars[count--] = digit;         intlongValue = intdivValue;       }       if (intlongValue != 0) {         chars[count--] = HexAlphabet[(int)intlongValue];       }       if (neg) {         chars[count] = '-';       } else {         ++count;       }       return new String(chars' count' 12 - count);       } else {         chars = new char[24];         count = 23;         if (neg) {           longValue = -longValue;         }         while (longValue > 43698) {           long divValue = longValue / 10;         char digit = HexAlphabet[(int)(longValue - (divValue * 10))];         chars[count--] = digit;         longValue = divValue;       }       while (longValue > 9) {         long divValue = (longValue * 26215) >> 18;         char digit = HexAlphabet[(int)(longValue - (divValue * 10))];         chars[count--] = digit;         longValue = divValue;       }       if (longValue != 0) {         chars[count--] = HexAlphabet[(int)longValue];       }       if (neg) {         chars[count] = '-';       } else {         ++count;       }       return new String(chars' count' 24 - count);       }
Magic Number,PeterO.Cbor,CBORUtilities,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORUtilities.cs,LongToString,The following statement contains a magic number: if ((long)intlongValue == longValue) {         chars = new char[12];         count = 11;         if (neg) {           intlongValue = -intlongValue;         }         while (intlongValue > 43698) {           int intdivValue = intlongValue / 10;         char digit = HexAlphabet[(int)(intlongValue - (intdivValue * 10))];         chars[count--] = digit;         intlongValue = intdivValue;       }       while (intlongValue > 9) {         int intdivValue = (intlongValue * 26215) >> 18;         char digit = HexAlphabet[(int)(intlongValue - (intdivValue * 10))];         chars[count--] = digit;         intlongValue = intdivValue;       }       if (intlongValue != 0) {         chars[count--] = HexAlphabet[(int)intlongValue];       }       if (neg) {         chars[count] = '-';       } else {         ++count;       }       return new String(chars' count' 12 - count);       } else {         chars = new char[24];         count = 23;         if (neg) {           longValue = -longValue;         }         while (longValue > 43698) {           long divValue = longValue / 10;         char digit = HexAlphabet[(int)(longValue - (divValue * 10))];         chars[count--] = digit;         longValue = divValue;       }       while (longValue > 9) {         long divValue = (longValue * 26215) >> 18;         char digit = HexAlphabet[(int)(longValue - (divValue * 10))];         chars[count--] = digit;         longValue = divValue;       }       if (longValue != 0) {         chars[count--] = HexAlphabet[(int)longValue];       }       if (neg) {         chars[count] = '-';       } else {         ++count;       }       return new String(chars' count' 24 - count);       }
Magic Number,PeterO.Cbor,CBORUtilities,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORUtilities.cs,LongToString,The following statement contains a magic number: if ((long)intlongValue == longValue) {         chars = new char[12];         count = 11;         if (neg) {           intlongValue = -intlongValue;         }         while (intlongValue > 43698) {           int intdivValue = intlongValue / 10;         char digit = HexAlphabet[(int)(intlongValue - (intdivValue * 10))];         chars[count--] = digit;         intlongValue = intdivValue;       }       while (intlongValue > 9) {         int intdivValue = (intlongValue * 26215) >> 18;         char digit = HexAlphabet[(int)(intlongValue - (intdivValue * 10))];         chars[count--] = digit;         intlongValue = intdivValue;       }       if (intlongValue != 0) {         chars[count--] = HexAlphabet[(int)intlongValue];       }       if (neg) {         chars[count] = '-';       } else {         ++count;       }       return new String(chars' count' 12 - count);       } else {         chars = new char[24];         count = 23;         if (neg) {           longValue = -longValue;         }         while (longValue > 43698) {           long divValue = longValue / 10;         char digit = HexAlphabet[(int)(longValue - (divValue * 10))];         chars[count--] = digit;         longValue = divValue;       }       while (longValue > 9) {         long divValue = (longValue * 26215) >> 18;         char digit = HexAlphabet[(int)(longValue - (divValue * 10))];         chars[count--] = digit;         longValue = divValue;       }       if (longValue != 0) {         chars[count--] = HexAlphabet[(int)longValue];       }       if (neg) {         chars[count] = '-';       } else {         ++count;       }       return new String(chars' count' 24 - count);       }
Magic Number,PeterO.Cbor,CBORUtilities,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORUtilities.cs,LongToString,The following statement contains a magic number: if ((long)intlongValue == longValue) {         chars = new char[12];         count = 11;         if (neg) {           intlongValue = -intlongValue;         }         while (intlongValue > 43698) {           int intdivValue = intlongValue / 10;         char digit = HexAlphabet[(int)(intlongValue - (intdivValue * 10))];         chars[count--] = digit;         intlongValue = intdivValue;       }       while (intlongValue > 9) {         int intdivValue = (intlongValue * 26215) >> 18;         char digit = HexAlphabet[(int)(intlongValue - (intdivValue * 10))];         chars[count--] = digit;         intlongValue = intdivValue;       }       if (intlongValue != 0) {         chars[count--] = HexAlphabet[(int)intlongValue];       }       if (neg) {         chars[count] = '-';       } else {         ++count;       }       return new String(chars' count' 12 - count);       } else {         chars = new char[24];         count = 23;         if (neg) {           longValue = -longValue;         }         while (longValue > 43698) {           long divValue = longValue / 10;         char digit = HexAlphabet[(int)(longValue - (divValue * 10))];         chars[count--] = digit;         longValue = divValue;       }       while (longValue > 9) {         long divValue = (longValue * 26215) >> 18;         char digit = HexAlphabet[(int)(longValue - (divValue * 10))];         chars[count--] = digit;         longValue = divValue;       }       if (longValue != 0) {         chars[count--] = HexAlphabet[(int)longValue];       }       if (neg) {         chars[count] = '-';       } else {         ++count;       }       return new String(chars' count' 24 - count);       }
Magic Number,PeterO.Cbor,CBORUtilities,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORUtilities.cs,LongToString,The following statement contains a magic number: if ((long)intlongValue == longValue) {         chars = new char[12];         count = 11;         if (neg) {           intlongValue = -intlongValue;         }         while (intlongValue > 43698) {           int intdivValue = intlongValue / 10;         char digit = HexAlphabet[(int)(intlongValue - (intdivValue * 10))];         chars[count--] = digit;         intlongValue = intdivValue;       }       while (intlongValue > 9) {         int intdivValue = (intlongValue * 26215) >> 18;         char digit = HexAlphabet[(int)(intlongValue - (intdivValue * 10))];         chars[count--] = digit;         intlongValue = intdivValue;       }       if (intlongValue != 0) {         chars[count--] = HexAlphabet[(int)intlongValue];       }       if (neg) {         chars[count] = '-';       } else {         ++count;       }       return new String(chars' count' 12 - count);       } else {         chars = new char[24];         count = 23;         if (neg) {           longValue = -longValue;         }         while (longValue > 43698) {           long divValue = longValue / 10;         char digit = HexAlphabet[(int)(longValue - (divValue * 10))];         chars[count--] = digit;         longValue = divValue;       }       while (longValue > 9) {         long divValue = (longValue * 26215) >> 18;         char digit = HexAlphabet[(int)(longValue - (divValue * 10))];         chars[count--] = digit;         longValue = divValue;       }       if (longValue != 0) {         chars[count--] = HexAlphabet[(int)longValue];       }       if (neg) {         chars[count] = '-';       } else {         ++count;       }       return new String(chars' count' 24 - count);       }
Magic Number,PeterO.Cbor,CBORUtilities,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORUtilities.cs,LongToString,The following statement contains a magic number: if ((long)intlongValue == longValue) {         chars = new char[12];         count = 11;         if (neg) {           intlongValue = -intlongValue;         }         while (intlongValue > 43698) {           int intdivValue = intlongValue / 10;         char digit = HexAlphabet[(int)(intlongValue - (intdivValue * 10))];         chars[count--] = digit;         intlongValue = intdivValue;       }       while (intlongValue > 9) {         int intdivValue = (intlongValue * 26215) >> 18;         char digit = HexAlphabet[(int)(intlongValue - (intdivValue * 10))];         chars[count--] = digit;         intlongValue = intdivValue;       }       if (intlongValue != 0) {         chars[count--] = HexAlphabet[(int)intlongValue];       }       if (neg) {         chars[count] = '-';       } else {         ++count;       }       return new String(chars' count' 12 - count);       } else {         chars = new char[24];         count = 23;         if (neg) {           longValue = -longValue;         }         while (longValue > 43698) {           long divValue = longValue / 10;         char digit = HexAlphabet[(int)(longValue - (divValue * 10))];         chars[count--] = digit;         longValue = divValue;       }       while (longValue > 9) {         long divValue = (longValue * 26215) >> 18;         char digit = HexAlphabet[(int)(longValue - (divValue * 10))];         chars[count--] = digit;         longValue = divValue;       }       if (longValue != 0) {         chars[count--] = HexAlphabet[(int)longValue];       }       if (neg) {         chars[count] = '-';       } else {         ++count;       }       return new String(chars' count' 24 - count);       }
Magic Number,PeterO.Cbor,CBORUtilities,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORUtilities.cs,LongToString,The following statement contains a magic number: if ((long)intlongValue == longValue) {         chars = new char[12];         count = 11;         if (neg) {           intlongValue = -intlongValue;         }         while (intlongValue > 43698) {           int intdivValue = intlongValue / 10;         char digit = HexAlphabet[(int)(intlongValue - (intdivValue * 10))];         chars[count--] = digit;         intlongValue = intdivValue;       }       while (intlongValue > 9) {         int intdivValue = (intlongValue * 26215) >> 18;         char digit = HexAlphabet[(int)(intlongValue - (intdivValue * 10))];         chars[count--] = digit;         intlongValue = intdivValue;       }       if (intlongValue != 0) {         chars[count--] = HexAlphabet[(int)intlongValue];       }       if (neg) {         chars[count] = '-';       } else {         ++count;       }       return new String(chars' count' 12 - count);       } else {         chars = new char[24];         count = 23;         if (neg) {           longValue = -longValue;         }         while (longValue > 43698) {           long divValue = longValue / 10;         char digit = HexAlphabet[(int)(longValue - (divValue * 10))];         chars[count--] = digit;         longValue = divValue;       }       while (longValue > 9) {         long divValue = (longValue * 26215) >> 18;         char digit = HexAlphabet[(int)(longValue - (divValue * 10))];         chars[count--] = digit;         longValue = divValue;       }       if (longValue != 0) {         chars[count--] = HexAlphabet[(int)longValue];       }       if (neg) {         chars[count] = '-';       } else {         ++count;       }       return new String(chars' count' 24 - count);       }
Magic Number,PeterO.Cbor,CBORUtilities,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORUtilities.cs,LongToString,The following statement contains a magic number: if ((long)intlongValue == longValue) {         chars = new char[12];         count = 11;         if (neg) {           intlongValue = -intlongValue;         }         while (intlongValue > 43698) {           int intdivValue = intlongValue / 10;         char digit = HexAlphabet[(int)(intlongValue - (intdivValue * 10))];         chars[count--] = digit;         intlongValue = intdivValue;       }       while (intlongValue > 9) {         int intdivValue = (intlongValue * 26215) >> 18;         char digit = HexAlphabet[(int)(intlongValue - (intdivValue * 10))];         chars[count--] = digit;         intlongValue = intdivValue;       }       if (intlongValue != 0) {         chars[count--] = HexAlphabet[(int)intlongValue];       }       if (neg) {         chars[count] = '-';       } else {         ++count;       }       return new String(chars' count' 12 - count);       } else {         chars = new char[24];         count = 23;         if (neg) {           longValue = -longValue;         }         while (longValue > 43698) {           long divValue = longValue / 10;         char digit = HexAlphabet[(int)(longValue - (divValue * 10))];         chars[count--] = digit;         longValue = divValue;       }       while (longValue > 9) {         long divValue = (longValue * 26215) >> 18;         char digit = HexAlphabet[(int)(longValue - (divValue * 10))];         chars[count--] = digit;         longValue = divValue;       }       if (longValue != 0) {         chars[count--] = HexAlphabet[(int)longValue];       }       if (neg) {         chars[count] = '-';       } else {         ++count;       }       return new String(chars' count' 24 - count);       }
Magic Number,PeterO.Cbor,CBORUtilities,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORUtilities.cs,LongToString,The following statement contains a magic number: if ((long)intlongValue == longValue) {         chars = new char[12];         count = 11;         if (neg) {           intlongValue = -intlongValue;         }         while (intlongValue > 43698) {           int intdivValue = intlongValue / 10;         char digit = HexAlphabet[(int)(intlongValue - (intdivValue * 10))];         chars[count--] = digit;         intlongValue = intdivValue;       }       while (intlongValue > 9) {         int intdivValue = (intlongValue * 26215) >> 18;         char digit = HexAlphabet[(int)(intlongValue - (intdivValue * 10))];         chars[count--] = digit;         intlongValue = intdivValue;       }       if (intlongValue != 0) {         chars[count--] = HexAlphabet[(int)intlongValue];       }       if (neg) {         chars[count] = '-';       } else {         ++count;       }       return new String(chars' count' 12 - count);       } else {         chars = new char[24];         count = 23;         if (neg) {           longValue = -longValue;         }         while (longValue > 43698) {           long divValue = longValue / 10;         char digit = HexAlphabet[(int)(longValue - (divValue * 10))];         chars[count--] = digit;         longValue = divValue;       }       while (longValue > 9) {         long divValue = (longValue * 26215) >> 18;         char digit = HexAlphabet[(int)(longValue - (divValue * 10))];         chars[count--] = digit;         longValue = divValue;       }       if (longValue != 0) {         chars[count--] = HexAlphabet[(int)longValue];       }       if (neg) {         chars[count] = '-';       } else {         ++count;       }       return new String(chars' count' 24 - count);       }
Magic Number,PeterO.Cbor,CBORUtilities,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORUtilities.cs,BigIntegerFromDouble,The following statement contains a magic number: int value1 = unchecked((int)((lvalue >> 32) & 0xffffffffL));
Magic Number,PeterO.Cbor,CBORUtilities,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORUtilities.cs,BigIntegerFromDouble,The following statement contains a magic number: var floatExponent = (int)((value1 >> 20) & 0x7ff);
Magic Number,PeterO.Cbor,CBORUtilities,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORUtilities.cs,BigIntegerFromDouble,The following statement contains a magic number: bool neg = (value1 >> 31) != 0;
Magic Number,PeterO.Cbor,CBORUtilities,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORUtilities.cs,BigIntegerFromDouble,The following statement contains a magic number: if (floatExponent == 2047) {         throw new OverflowException("Value is infinity or NaN");       }
Magic Number,PeterO.Cbor,CBORUtilities,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORUtilities.cs,BigIntegerFromDouble,The following statement contains a magic number: if ((value1 | value0) != 0) {         while ((value0 & 1) == 0) {           value0 >>= 1;           value0 &= 0x7fffffff;           value0 = unchecked(value0 | (value1 << 31));           value1 >>= 1;           ++floatExponent;         }       }
Magic Number,PeterO.Cbor,CBORUtilities,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORUtilities.cs,BigIntegerFromDouble,The following statement contains a magic number: floatExponent -= 1075;
Magic Number,PeterO.Cbor,CBORUtilities,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORUtilities.cs,BigIntegerFromDouble,The following statement contains a magic number: var bytes = new byte[9];
Magic Number,PeterO.Cbor,CBORUtilities,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORUtilities.cs,BigIntegerFromDouble,The following statement contains a magic number: bytes[1] = (byte)((value0 >> 8) & 0xff);
Magic Number,PeterO.Cbor,CBORUtilities,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORUtilities.cs,BigIntegerFromDouble,The following statement contains a magic number: bytes[2] = (byte)((value0 >> 16) & 0xff);
Magic Number,PeterO.Cbor,CBORUtilities,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORUtilities.cs,BigIntegerFromDouble,The following statement contains a magic number: bytes[2] = (byte)((value0 >> 16) & 0xff);
Magic Number,PeterO.Cbor,CBORUtilities,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORUtilities.cs,BigIntegerFromDouble,The following statement contains a magic number: bytes[3] = (byte)((value0 >> 24) & 0xff);
Magic Number,PeterO.Cbor,CBORUtilities,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORUtilities.cs,BigIntegerFromDouble,The following statement contains a magic number: bytes[3] = (byte)((value0 >> 24) & 0xff);
Magic Number,PeterO.Cbor,CBORUtilities,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORUtilities.cs,BigIntegerFromDouble,The following statement contains a magic number: bytes[4] = (byte)(value1 & 0xff);
Magic Number,PeterO.Cbor,CBORUtilities,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORUtilities.cs,BigIntegerFromDouble,The following statement contains a magic number: bytes[5] = (byte)((value1 >> 8) & 0xff);
Magic Number,PeterO.Cbor,CBORUtilities,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORUtilities.cs,BigIntegerFromDouble,The following statement contains a magic number: bytes[5] = (byte)((value1 >> 8) & 0xff);
Magic Number,PeterO.Cbor,CBORUtilities,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORUtilities.cs,BigIntegerFromDouble,The following statement contains a magic number: bytes[6] = (byte)((value1 >> 16) & 0xff);
Magic Number,PeterO.Cbor,CBORUtilities,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORUtilities.cs,BigIntegerFromDouble,The following statement contains a magic number: bytes[6] = (byte)((value1 >> 16) & 0xff);
Magic Number,PeterO.Cbor,CBORUtilities,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORUtilities.cs,BigIntegerFromDouble,The following statement contains a magic number: bytes[7] = (byte)((value1 >> 24) & 0xff);
Magic Number,PeterO.Cbor,CBORUtilities,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORUtilities.cs,BigIntegerFromDouble,The following statement contains a magic number: bytes[7] = (byte)((value1 >> 24) & 0xff);
Magic Number,PeterO.Cbor,CBORUtilities,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORUtilities.cs,BigIntegerFromDouble,The following statement contains a magic number: bytes[8] = (byte)0;
Magic Number,PeterO.Cbor,CBORUtilities,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORUtilities.cs,HalfPrecisionToSingle,The following statement contains a magic number: int negvalue = (value >= 0x8000) ? (1 << 31) : 0;
Magic Number,PeterO.Cbor,CBORUtilities,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORUtilities.cs,HalfPrecisionToSingle,The following statement contains a magic number: if (value >= 0x7c00) {         value = (int)(0x3fc00 | (value & 0x3ff)) << 13 | negvalue;         return BitConverter.ToSingle(   BitConverter.GetBytes(value)'   0);       }
Magic Number,PeterO.Cbor,CBORUtilities,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORUtilities.cs,HalfPrecisionToSingle,The following statement contains a magic number: if (value > 0x400) {         value = (int)((value + 0x1c000) << 13) | negvalue;         return BitConverter.ToSingle(   BitConverter.GetBytes(value)'   0);       }
Magic Number,PeterO.Cbor,CBORUtilities,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORUtilities.cs,HalfPrecisionToSingle,The following statement contains a magic number: if ((value & 0x400) == value) {         value = (int)((value == 0) ? 0 : 0x38800000) | negvalue;         return BitConverter.ToSingle(   BitConverter.GetBytes(value)'   0);       } else {         // denormalized         int m = value & 0x3ff;         value = 0x1c400;         while ((m >> 10) == 0) {           value -= 0x400;           m <<= 1;         }         value = ((value | (m & 0x3ff)) << 13) | negvalue;         return BitConverter.ToSingle(BitConverter.GetBytes((int)value)' 0);       }
Magic Number,PeterO.Cbor,CBORUtilities,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORUtilities.cs,HalfPrecisionToSingle,The following statement contains a magic number: if ((value & 0x400) == value) {         value = (int)((value == 0) ? 0 : 0x38800000) | negvalue;         return BitConverter.ToSingle(   BitConverter.GetBytes(value)'   0);       } else {         // denormalized         int m = value & 0x3ff;         value = 0x1c400;         while ((m >> 10) == 0) {           value -= 0x400;           m <<= 1;         }         value = ((value | (m & 0x3ff)) << 13) | negvalue;         return BitConverter.ToSingle(BitConverter.GetBytes((int)value)' 0);       }
Magic Number,PeterO.Cbor,CharacterReader,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CharacterReader.cs,ReadChar,The following statement contains a magic number: if (this.stream != null) {         return this.DetectUnicodeEncoding();       } else {         int c = (this.offset < this.strLength) ? this.str[this.offset] : -1;         if ((c & 0xfc00) == 0xd800 && this.offset + 1 < this.strLength &&                 this.str[this.offset + 1] >= 0xdc00 && this.str[this.offset + 1]                 <= 0xdfff) {           // Get the Unicode code point for the surrogate pair           c = 0x10000 + ((c - 0xd800) << 10) + (this.str[this.offset + 1] -           0xdc00);           ++this.offset;         } else if ((c & 0xf800) == 0xd800) {           // unpaired surrogate           if (this.errorThrow) {  throw new InvalidOperationException("Unpaired surrogate code point"); } else {  c = 0xfffd; }         }         ++this.offset;         return c;       }
Magic Number,PeterO.Cbor,CharacterReader,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CharacterReader.cs,DetectUtf8Or16Or32,The following statement contains a magic number: if (c1 == 0xff || c1 == 0xfe) {         // Start of a possible byte-order mark         // FF FE 0 0 --> UTF-32LE         // FF FE ... --> UTF-16LE         // FE FF --> UTF-16BE         c2 = this.stream.ReadByte();         bool bigEndian = c1 == 0xfe;         int otherbyte = bigEndian ? 0xff : 0xfe;         if (c2 == otherbyte) {           c3 = this.stream.ReadByte();           c4 = this.stream.ReadByte();           if (!bigEndian && c3 == 0 && c4 == 0) {             this.reader = new Utf32Reader(this.stream' false' this.errorThrow);             return this.reader.ReadChar();           } else {       var newReader = new Utf16Reader(   this.stream'   bigEndian'   this.errorThrow);             newReader.Unget(c3' c4);             this.reader = newReader;             return newReader.ReadChar();           }         }         // Assume UTF-8 here' so the 0xff or 0xfe is invalid         if (this.errorThrow) {           throw new InvalidOperationException("Invalid Unicode stream");         } else {           var utf8reader = new Utf8Reader(this.stream' this.errorThrow);           utf8reader.Unget(c2);           this.reader = utf8reader;           return 0xfffd;         }       } else if (c1 == 0 && this.mode == 4) {         // Here' the relevant cases are:         // 0 0 0 NZA --> UTF-32BE (if mode is 4)         // 0 0 FE FF --> UTF-32BE         // Anything else is treated as UTF-8         c2 = this.stream.ReadByte();         c3 = this.stream.ReadByte();         c4 = this.stream.ReadByte();         if (c2 == 0 &&            ((c3 == 0xfe && c4 == 0xff) ||             (c3 == 0 && c4 >= 0x01 && c4 <= 0x7f))) {           this.reader = new Utf32Reader(this.stream' true' this.errorThrow);           return c3 == 0 ? c4 : this.reader.ReadChar();         } else {           var utf8reader = new Utf8Reader(this.stream' this.errorThrow);           utf8reader.UngetThree(c2' c3' c4);           this.reader = utf8reader;           return c1;         }       } else if (this.mode == 2) {         if (c1 >= 0x01 && c1 <= 0x7f) {           // Nonzero ASCII character           c2 = this.stream.ReadByte();           if (c2 == 0) {             // NZA 0' so UTF-16LE or UTF-32LE             c3 = this.stream.ReadByte();             c4 = this.stream.ReadByte();             if (c3 == 0 && c4 == 0) {             this.reader = new Utf32Reader(   this.stream'   false'   this.errorThrow);               return c1;             } else {           var newReader = new Utf16Reader(   this.stream'   false'   this.errorThrow);               newReader.Unget(c3' c4);               this.reader = newReader;               return c1;             }           } else {             // NZA NZ' so UTF-8             var utf8reader = new Utf8Reader(this.stream' this.errorThrow);             utf8reader.Unget(c2);             this.reader = utf8reader;             return c1;           }         } else if (c1 == 0) {           // Zero           c2 = this.stream.ReadByte();           if (c2 >= 0x01 && c2 <= 0x7f) {             // 0 NZA' so UTF-16BE             var newReader = new Utf16Reader(this.stream' true' this.errorThrow);             this.reader = newReader;             return c2;           } else if (c2 == 0) {             // 0 0' so maybe UTF-32BE             c3 = this.stream.ReadByte();             c4 = this.stream.ReadByte();             if (c3 == 0 && c4 >= 0x01 && c4 <= 0x7f) {               // 0 0 0 NZA               this.reader = new Utf32Reader(this.stream' true' this.errorThrow);               return c4;             } else if (c3 == 0xfe && c4 == 0xff) {               // 0 0 FE FF               this.reader = new Utf32Reader(this.stream' true' this.errorThrow);               return this.reader.ReadChar();             } else {               // 0 0 ...               var newReader = new Utf8Reader(this.stream' this.errorThrow);               newReader.UngetThree(c2' c3' c4);               this.reader = newReader;               return c1;             }           } else {             // 0 NonAscii' so UTF-8             var utf8reader = new Utf8Reader(this.stream' this.errorThrow);             utf8reader.Unget(c2);             this.reader = utf8reader;             return c1;           }         }       }
Magic Number,PeterO.Cbor,CharacterReader,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CharacterReader.cs,DetectUtf8Or16Or32,The following statement contains a magic number: if (c1 == 0xff || c1 == 0xfe) {         // Start of a possible byte-order mark         // FF FE 0 0 --> UTF-32LE         // FF FE ... --> UTF-16LE         // FE FF --> UTF-16BE         c2 = this.stream.ReadByte();         bool bigEndian = c1 == 0xfe;         int otherbyte = bigEndian ? 0xff : 0xfe;         if (c2 == otherbyte) {           c3 = this.stream.ReadByte();           c4 = this.stream.ReadByte();           if (!bigEndian && c3 == 0 && c4 == 0) {             this.reader = new Utf32Reader(this.stream' false' this.errorThrow);             return this.reader.ReadChar();           } else {       var newReader = new Utf16Reader(   this.stream'   bigEndian'   this.errorThrow);             newReader.Unget(c3' c4);             this.reader = newReader;             return newReader.ReadChar();           }         }         // Assume UTF-8 here' so the 0xff or 0xfe is invalid         if (this.errorThrow) {           throw new InvalidOperationException("Invalid Unicode stream");         } else {           var utf8reader = new Utf8Reader(this.stream' this.errorThrow);           utf8reader.Unget(c2);           this.reader = utf8reader;           return 0xfffd;         }       } else if (c1 == 0 && this.mode == 4) {         // Here' the relevant cases are:         // 0 0 0 NZA --> UTF-32BE (if mode is 4)         // 0 0 FE FF --> UTF-32BE         // Anything else is treated as UTF-8         c2 = this.stream.ReadByte();         c3 = this.stream.ReadByte();         c4 = this.stream.ReadByte();         if (c2 == 0 &&            ((c3 == 0xfe && c4 == 0xff) ||             (c3 == 0 && c4 >= 0x01 && c4 <= 0x7f))) {           this.reader = new Utf32Reader(this.stream' true' this.errorThrow);           return c3 == 0 ? c4 : this.reader.ReadChar();         } else {           var utf8reader = new Utf8Reader(this.stream' this.errorThrow);           utf8reader.UngetThree(c2' c3' c4);           this.reader = utf8reader;           return c1;         }       } else if (this.mode == 2) {         if (c1 >= 0x01 && c1 <= 0x7f) {           // Nonzero ASCII character           c2 = this.stream.ReadByte();           if (c2 == 0) {             // NZA 0' so UTF-16LE or UTF-32LE             c3 = this.stream.ReadByte();             c4 = this.stream.ReadByte();             if (c3 == 0 && c4 == 0) {             this.reader = new Utf32Reader(   this.stream'   false'   this.errorThrow);               return c1;             } else {           var newReader = new Utf16Reader(   this.stream'   false'   this.errorThrow);               newReader.Unget(c3' c4);               this.reader = newReader;               return c1;             }           } else {             // NZA NZ' so UTF-8             var utf8reader = new Utf8Reader(this.stream' this.errorThrow);             utf8reader.Unget(c2);             this.reader = utf8reader;             return c1;           }         } else if (c1 == 0) {           // Zero           c2 = this.stream.ReadByte();           if (c2 >= 0x01 && c2 <= 0x7f) {             // 0 NZA' so UTF-16BE             var newReader = new Utf16Reader(this.stream' true' this.errorThrow);             this.reader = newReader;             return c2;           } else if (c2 == 0) {             // 0 0' so maybe UTF-32BE             c3 = this.stream.ReadByte();             c4 = this.stream.ReadByte();             if (c3 == 0 && c4 >= 0x01 && c4 <= 0x7f) {               // 0 0 0 NZA               this.reader = new Utf32Reader(this.stream' true' this.errorThrow);               return c4;             } else if (c3 == 0xfe && c4 == 0xff) {               // 0 0 FE FF               this.reader = new Utf32Reader(this.stream' true' this.errorThrow);               return this.reader.ReadChar();             } else {               // 0 0 ...               var newReader = new Utf8Reader(this.stream' this.errorThrow);               newReader.UngetThree(c2' c3' c4);               this.reader = newReader;               return c1;             }           } else {             // 0 NonAscii' so UTF-8             var utf8reader = new Utf8Reader(this.stream' this.errorThrow);             utf8reader.Unget(c2);             this.reader = utf8reader;             return c1;           }         }       }
Magic Number,PeterO.Cbor,CharacterReader,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CharacterReader.cs,DetectUtf8Or16Or32,The following statement contains a magic number: return -2;
Magic Number,PeterO.Cbor,CharacterReader,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CharacterReader.cs,DetectUtf8OrUtf16,The following statement contains a magic number: return -2;
Magic Number,PeterO.Cbor,CharacterReader,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CharacterReader.cs,DetectUnicodeEncoding,The following statement contains a magic number: if (mode == 0) {         // UTF-8 only         utf8reader = new Utf8Reader(this.stream' this.errorThrow);         this.reader = utf8reader;         c1 = utf8reader.ReadChar();         if (c1 == 0xfeff) {           // Skip BOM           c1 = utf8reader.ReadChar();         }         return c1;       } else if (mode == 1 || mode == 3) {         c2 = this.DetectUtf8OrUtf16(c1);         if (c2 >= -1) {  return c2; }       } else if (mode == 2 || mode == 4) {         // UTF-8' UTF-16' or UTF-32         c2 = this.DetectUtf8Or16Or32(c1);         if (c2 >= -1) {  return c2; }       }
Magic Number,PeterO.Cbor,CharacterReader,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CharacterReader.cs,DetectUnicodeEncoding,The following statement contains a magic number: if (mode == 0) {         // UTF-8 only         utf8reader = new Utf8Reader(this.stream' this.errorThrow);         this.reader = utf8reader;         c1 = utf8reader.ReadChar();         if (c1 == 0xfeff) {           // Skip BOM           c1 = utf8reader.ReadChar();         }         return c1;       } else if (mode == 1 || mode == 3) {         c2 = this.DetectUtf8OrUtf16(c1);         if (c2 >= -1) {  return c2; }       } else if (mode == 2 || mode == 4) {         // UTF-8' UTF-16' or UTF-32         c2 = this.DetectUtf8Or16Or32(c1);         if (c2 >= -1) {  return c2; }       }
Magic Number,PeterO.Cbor,CharacterReader,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CharacterReader.cs,DetectUnicodeEncoding,The following statement contains a magic number: if (mode == 0) {         // UTF-8 only         utf8reader = new Utf8Reader(this.stream' this.errorThrow);         this.reader = utf8reader;         c1 = utf8reader.ReadChar();         if (c1 == 0xfeff) {           // Skip BOM           c1 = utf8reader.ReadChar();         }         return c1;       } else if (mode == 1 || mode == 3) {         c2 = this.DetectUtf8OrUtf16(c1);         if (c2 >= -1) {  return c2; }       } else if (mode == 2 || mode == 4) {         // UTF-8' UTF-16' or UTF-32         c2 = this.DetectUtf8Or16Or32(c1);         if (c2 >= -1) {  return c2; }       }
Magic Number,PeterO.Cbor,SavedState,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CharacterReader.cs,Ensure,The following statement contains a magic number: if (this.savedLength + size < this.saved.Length) {           var newsaved = new int[this.savedLength + size + 4];           Array.Copy(this.saved' 0' newsaved' 0' this.savedLength);           this.saved = newsaved;         }
Magic Number,PeterO.Cbor,SavedState,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CharacterReader.cs,AddTwo,The following statement contains a magic number: this.Ensure(2);
Magic Number,PeterO.Cbor,SavedState,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CharacterReader.cs,AddTwo,The following statement contains a magic number: this.savedLength += 2;
Magic Number,PeterO.Cbor,SavedState,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CharacterReader.cs,AddThree,The following statement contains a magic number: this.Ensure(3);
Magic Number,PeterO.Cbor,SavedState,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CharacterReader.cs,AddThree,The following statement contains a magic number: this.saved[this.savedLength + 2] = a;
Magic Number,PeterO.Cbor,SavedState,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CharacterReader.cs,AddThree,The following statement contains a magic number: this.savedLength += 3;
Magic Number,PeterO.Cbor,Utf16Reader,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CharacterReader.cs,ReadChar,The following statement contains a magic number: c1 = this.bigEndian ? ((c1 << 8) | c2) : ((c2 << 8) | c1);
Magic Number,PeterO.Cbor,Utf16Reader,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CharacterReader.cs,ReadChar,The following statement contains a magic number: c1 = this.bigEndian ? ((c1 << 8) | c2) : ((c2 << 8) | c1);
Magic Number,PeterO.Cbor,Utf16Reader,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CharacterReader.cs,ReadChar,The following statement contains a magic number: if (surr == 0xd800) {           surr = c1;           c1 = this.state.Read(this.stream);           c2 = this.state.Read(this.stream);           if (c1 < 0 || c2 < 0) {             this.state.AddOne(-1);             if (this.errorThrow) {  throw new InvalidOperationException("Invalid UTF-16"); } else {  return 0xfffd; }           }           int unit2 = this.bigEndian ? ((c1 << 8) | c2) : ((c2 << 8) | c1);           if ((unit2 & 0xfc00) == 0xdc00) {             return 0x10000 + ((surr - 0xd800) << 10) + (unit2 - 0xdc00);           }           this.Unget(c1' c2);           if (this.errorThrow) {  throw new InvalidOperationException("Invalid UTF-16"); } else {  return 0xfffd; }         }
Magic Number,PeterO.Cbor,Utf16Reader,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CharacterReader.cs,ReadChar,The following statement contains a magic number: if (surr == 0xd800) {           surr = c1;           c1 = this.state.Read(this.stream);           c2 = this.state.Read(this.stream);           if (c1 < 0 || c2 < 0) {             this.state.AddOne(-1);             if (this.errorThrow) {  throw new InvalidOperationException("Invalid UTF-16"); } else {  return 0xfffd; }           }           int unit2 = this.bigEndian ? ((c1 << 8) | c2) : ((c2 << 8) | c1);           if ((unit2 & 0xfc00) == 0xdc00) {             return 0x10000 + ((surr - 0xd800) << 10) + (unit2 - 0xdc00);           }           this.Unget(c1' c2);           if (this.errorThrow) {  throw new InvalidOperationException("Invalid UTF-16"); } else {  return 0xfffd; }         }
Magic Number,PeterO.Cbor,Utf16Reader,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CharacterReader.cs,ReadChar,The following statement contains a magic number: if (surr == 0xd800) {           surr = c1;           c1 = this.state.Read(this.stream);           c2 = this.state.Read(this.stream);           if (c1 < 0 || c2 < 0) {             this.state.AddOne(-1);             if (this.errorThrow) {  throw new InvalidOperationException("Invalid UTF-16"); } else {  return 0xfffd; }           }           int unit2 = this.bigEndian ? ((c1 << 8) | c2) : ((c2 << 8) | c1);           if ((unit2 & 0xfc00) == 0xdc00) {             return 0x10000 + ((surr - 0xd800) << 10) + (unit2 - 0xdc00);           }           this.Unget(c1' c2);           if (this.errorThrow) {  throw new InvalidOperationException("Invalid UTF-16"); } else {  return 0xfffd; }         }
Magic Number,PeterO.Cbor,Utf32Reader,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CharacterReader.cs,ReadChar,The following statement contains a magic number: c1 = this.bigEndian ? ((c1 << 24) | (c2 << 16) | (c3 << 8) | c4) :           ((c4 << 24) | (c3 << 16) | (c2 << 8) | c1);
Magic Number,PeterO.Cbor,Utf32Reader,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CharacterReader.cs,ReadChar,The following statement contains a magic number: c1 = this.bigEndian ? ((c1 << 24) | (c2 << 16) | (c3 << 8) | c4) :           ((c4 << 24) | (c3 << 16) | (c2 << 8) | c1);
Magic Number,PeterO.Cbor,Utf32Reader,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CharacterReader.cs,ReadChar,The following statement contains a magic number: c1 = this.bigEndian ? ((c1 << 24) | (c2 << 16) | (c3 << 8) | c4) :           ((c4 << 24) | (c3 << 16) | (c2 << 8) | c1);
Magic Number,PeterO.Cbor,Utf32Reader,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CharacterReader.cs,ReadChar,The following statement contains a magic number: c1 = this.bigEndian ? ((c1 << 24) | (c2 << 16) | (c3 << 8) | c4) :           ((c4 << 24) | (c3 << 16) | (c2 << 8) | c1);
Magic Number,PeterO.Cbor,Utf32Reader,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CharacterReader.cs,ReadChar,The following statement contains a magic number: c1 = this.bigEndian ? ((c1 << 24) | (c2 << 16) | (c3 << 8) | c4) :           ((c4 << 24) | (c3 << 16) | (c2 << 8) | c1);
Magic Number,PeterO.Cbor,Utf32Reader,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CharacterReader.cs,ReadChar,The following statement contains a magic number: c1 = this.bigEndian ? ((c1 << 24) | (c2 << 16) | (c3 << 8) | c4) :           ((c4 << 24) | (c3 << 16) | (c2 << 8) | c1);
Magic Number,PeterO.Cbor,Utf8Reader,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CharacterReader.cs,ReadChar,The following statement contains a magic number: while (true) {           int b;           if (this.lastChar != -1) {             b = this.lastChar;             this.lastChar = -1;           } else {             b = this.state.Read(this.stream);           }           if (b < 0) {             if (bytesNeeded != 0) {               bytesNeeded = 0;               if (this.errorThrow) {  throw new InvalidOperationException("Invalid UTF-8"); } else {  return 0xfffd; }             }             return -1;           }           if (bytesNeeded == 0) {             if ((b & 0x7f) == b) {               return b;             }             if (b >= 0xc2 && b <= 0xdf) {               bytesNeeded = 1;               lower = 0x80;               upper = 0xbf;               cp = (b - 0xc0) << 6;             } else if (b >= 0xe0 && b <= 0xef) {               lower = (b == 0xe0) ? 0xa0 : 0x80;               upper = (b == 0xed) ? 0x9f : 0xbf;               bytesNeeded = 2;               cp = (b - 0xe0) << 12;             } else if (b >= 0xf0 && b <= 0xf4) {               lower = (b == 0xf0) ? 0x90 : 0x80;               upper = (b == 0xf4) ? 0x8f : 0xbf;               bytesNeeded = 3;               cp = (b - 0xf0) << 18;             } else {               if (this.errorThrow) {  throw new InvalidOperationException("Invalid UTF-8"); } else {  return 0xfffd; }             }             continue;           }           if (b < lower || b > upper) {             cp = bytesNeeded = bytesSeen = 0;             this.state.AddOne(b);             if (this.errorThrow) {  throw new InvalidOperationException("Invalid UTF-8"); } else {  return 0xfffd; }           }           lower = 0x80;           upper = 0xbf;           ++bytesSeen;           cp += (b - 0x80) << (6 * (bytesNeeded - bytesSeen));           if (bytesSeen != bytesNeeded) {             continue;           }           int ret = cp;           cp = 0;           bytesSeen = 0;           bytesNeeded = 0;           return ret;         }
Magic Number,PeterO.Cbor,Utf8Reader,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CharacterReader.cs,ReadChar,The following statement contains a magic number: while (true) {           int b;           if (this.lastChar != -1) {             b = this.lastChar;             this.lastChar = -1;           } else {             b = this.state.Read(this.stream);           }           if (b < 0) {             if (bytesNeeded != 0) {               bytesNeeded = 0;               if (this.errorThrow) {  throw new InvalidOperationException("Invalid UTF-8"); } else {  return 0xfffd; }             }             return -1;           }           if (bytesNeeded == 0) {             if ((b & 0x7f) == b) {               return b;             }             if (b >= 0xc2 && b <= 0xdf) {               bytesNeeded = 1;               lower = 0x80;               upper = 0xbf;               cp = (b - 0xc0) << 6;             } else if (b >= 0xe0 && b <= 0xef) {               lower = (b == 0xe0) ? 0xa0 : 0x80;               upper = (b == 0xed) ? 0x9f : 0xbf;               bytesNeeded = 2;               cp = (b - 0xe0) << 12;             } else if (b >= 0xf0 && b <= 0xf4) {               lower = (b == 0xf0) ? 0x90 : 0x80;               upper = (b == 0xf4) ? 0x8f : 0xbf;               bytesNeeded = 3;               cp = (b - 0xf0) << 18;             } else {               if (this.errorThrow) {  throw new InvalidOperationException("Invalid UTF-8"); } else {  return 0xfffd; }             }             continue;           }           if (b < lower || b > upper) {             cp = bytesNeeded = bytesSeen = 0;             this.state.AddOne(b);             if (this.errorThrow) {  throw new InvalidOperationException("Invalid UTF-8"); } else {  return 0xfffd; }           }           lower = 0x80;           upper = 0xbf;           ++bytesSeen;           cp += (b - 0x80) << (6 * (bytesNeeded - bytesSeen));           if (bytesSeen != bytesNeeded) {             continue;           }           int ret = cp;           cp = 0;           bytesSeen = 0;           bytesNeeded = 0;           return ret;         }
Magic Number,PeterO.Cbor,Utf8Reader,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CharacterReader.cs,ReadChar,The following statement contains a magic number: while (true) {           int b;           if (this.lastChar != -1) {             b = this.lastChar;             this.lastChar = -1;           } else {             b = this.state.Read(this.stream);           }           if (b < 0) {             if (bytesNeeded != 0) {               bytesNeeded = 0;               if (this.errorThrow) {  throw new InvalidOperationException("Invalid UTF-8"); } else {  return 0xfffd; }             }             return -1;           }           if (bytesNeeded == 0) {             if ((b & 0x7f) == b) {               return b;             }             if (b >= 0xc2 && b <= 0xdf) {               bytesNeeded = 1;               lower = 0x80;               upper = 0xbf;               cp = (b - 0xc0) << 6;             } else if (b >= 0xe0 && b <= 0xef) {               lower = (b == 0xe0) ? 0xa0 : 0x80;               upper = (b == 0xed) ? 0x9f : 0xbf;               bytesNeeded = 2;               cp = (b - 0xe0) << 12;             } else if (b >= 0xf0 && b <= 0xf4) {               lower = (b == 0xf0) ? 0x90 : 0x80;               upper = (b == 0xf4) ? 0x8f : 0xbf;               bytesNeeded = 3;               cp = (b - 0xf0) << 18;             } else {               if (this.errorThrow) {  throw new InvalidOperationException("Invalid UTF-8"); } else {  return 0xfffd; }             }             continue;           }           if (b < lower || b > upper) {             cp = bytesNeeded = bytesSeen = 0;             this.state.AddOne(b);             if (this.errorThrow) {  throw new InvalidOperationException("Invalid UTF-8"); } else {  return 0xfffd; }           }           lower = 0x80;           upper = 0xbf;           ++bytesSeen;           cp += (b - 0x80) << (6 * (bytesNeeded - bytesSeen));           if (bytesSeen != bytesNeeded) {             continue;           }           int ret = cp;           cp = 0;           bytesSeen = 0;           bytesNeeded = 0;           return ret;         }
Magic Number,PeterO.Cbor,Utf8Reader,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CharacterReader.cs,ReadChar,The following statement contains a magic number: while (true) {           int b;           if (this.lastChar != -1) {             b = this.lastChar;             this.lastChar = -1;           } else {             b = this.state.Read(this.stream);           }           if (b < 0) {             if (bytesNeeded != 0) {               bytesNeeded = 0;               if (this.errorThrow) {  throw new InvalidOperationException("Invalid UTF-8"); } else {  return 0xfffd; }             }             return -1;           }           if (bytesNeeded == 0) {             if ((b & 0x7f) == b) {               return b;             }             if (b >= 0xc2 && b <= 0xdf) {               bytesNeeded = 1;               lower = 0x80;               upper = 0xbf;               cp = (b - 0xc0) << 6;             } else if (b >= 0xe0 && b <= 0xef) {               lower = (b == 0xe0) ? 0xa0 : 0x80;               upper = (b == 0xed) ? 0x9f : 0xbf;               bytesNeeded = 2;               cp = (b - 0xe0) << 12;             } else if (b >= 0xf0 && b <= 0xf4) {               lower = (b == 0xf0) ? 0x90 : 0x80;               upper = (b == 0xf4) ? 0x8f : 0xbf;               bytesNeeded = 3;               cp = (b - 0xf0) << 18;             } else {               if (this.errorThrow) {  throw new InvalidOperationException("Invalid UTF-8"); } else {  return 0xfffd; }             }             continue;           }           if (b < lower || b > upper) {             cp = bytesNeeded = bytesSeen = 0;             this.state.AddOne(b);             if (this.errorThrow) {  throw new InvalidOperationException("Invalid UTF-8"); } else {  return 0xfffd; }           }           lower = 0x80;           upper = 0xbf;           ++bytesSeen;           cp += (b - 0x80) << (6 * (bytesNeeded - bytesSeen));           if (bytesSeen != bytesNeeded) {             continue;           }           int ret = cp;           cp = 0;           bytesSeen = 0;           bytesNeeded = 0;           return ret;         }
Magic Number,PeterO.Cbor,Utf8Reader,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CharacterReader.cs,ReadChar,The following statement contains a magic number: while (true) {           int b;           if (this.lastChar != -1) {             b = this.lastChar;             this.lastChar = -1;           } else {             b = this.state.Read(this.stream);           }           if (b < 0) {             if (bytesNeeded != 0) {               bytesNeeded = 0;               if (this.errorThrow) {  throw new InvalidOperationException("Invalid UTF-8"); } else {  return 0xfffd; }             }             return -1;           }           if (bytesNeeded == 0) {             if ((b & 0x7f) == b) {               return b;             }             if (b >= 0xc2 && b <= 0xdf) {               bytesNeeded = 1;               lower = 0x80;               upper = 0xbf;               cp = (b - 0xc0) << 6;             } else if (b >= 0xe0 && b <= 0xef) {               lower = (b == 0xe0) ? 0xa0 : 0x80;               upper = (b == 0xed) ? 0x9f : 0xbf;               bytesNeeded = 2;               cp = (b - 0xe0) << 12;             } else if (b >= 0xf0 && b <= 0xf4) {               lower = (b == 0xf0) ? 0x90 : 0x80;               upper = (b == 0xf4) ? 0x8f : 0xbf;               bytesNeeded = 3;               cp = (b - 0xf0) << 18;             } else {               if (this.errorThrow) {  throw new InvalidOperationException("Invalid UTF-8"); } else {  return 0xfffd; }             }             continue;           }           if (b < lower || b > upper) {             cp = bytesNeeded = bytesSeen = 0;             this.state.AddOne(b);             if (this.errorThrow) {  throw new InvalidOperationException("Invalid UTF-8"); } else {  return 0xfffd; }           }           lower = 0x80;           upper = 0xbf;           ++bytesSeen;           cp += (b - 0x80) << (6 * (bytesNeeded - bytesSeen));           if (bytesSeen != bytesNeeded) {             continue;           }           int ret = cp;           cp = 0;           bytesSeen = 0;           bytesNeeded = 0;           return ret;         }
Magic Number,PeterO.Cbor,Utf8Reader,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CharacterReader.cs,ReadChar,The following statement contains a magic number: while (true) {           int b;           if (this.lastChar != -1) {             b = this.lastChar;             this.lastChar = -1;           } else {             b = this.state.Read(this.stream);           }           if (b < 0) {             if (bytesNeeded != 0) {               bytesNeeded = 0;               if (this.errorThrow) {  throw new InvalidOperationException("Invalid UTF-8"); } else {  return 0xfffd; }             }             return -1;           }           if (bytesNeeded == 0) {             if ((b & 0x7f) == b) {               return b;             }             if (b >= 0xc2 && b <= 0xdf) {               bytesNeeded = 1;               lower = 0x80;               upper = 0xbf;               cp = (b - 0xc0) << 6;             } else if (b >= 0xe0 && b <= 0xef) {               lower = (b == 0xe0) ? 0xa0 : 0x80;               upper = (b == 0xed) ? 0x9f : 0xbf;               bytesNeeded = 2;               cp = (b - 0xe0) << 12;             } else if (b >= 0xf0 && b <= 0xf4) {               lower = (b == 0xf0) ? 0x90 : 0x80;               upper = (b == 0xf4) ? 0x8f : 0xbf;               bytesNeeded = 3;               cp = (b - 0xf0) << 18;             } else {               if (this.errorThrow) {  throw new InvalidOperationException("Invalid UTF-8"); } else {  return 0xfffd; }             }             continue;           }           if (b < lower || b > upper) {             cp = bytesNeeded = bytesSeen = 0;             this.state.AddOne(b);             if (this.errorThrow) {  throw new InvalidOperationException("Invalid UTF-8"); } else {  return 0xfffd; }           }           lower = 0x80;           upper = 0xbf;           ++bytesSeen;           cp += (b - 0x80) << (6 * (bytesNeeded - bytesSeen));           if (bytesSeen != bytesNeeded) {             continue;           }           int ret = cp;           cp = 0;           bytesSeen = 0;           bytesNeeded = 0;           return ret;         }
Magic Number,PeterO.Cbor,FastInteger2,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\FastInteger2.cs,AsInt32,The following statement contains a magic number: switch (this.integerMode) {         case 0:           return this.smallValue;         case 1:           return this.mnum.ToInt32();         case 2:           return (int)this.largeValue;         default: throw new InvalidOperationException();       }
Magic Number,PeterO.Cbor,FastInteger2,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\FastInteger2.cs,WordsToEInteger,The following statement contains a magic number: if (wordCount == 1 && (words[0] >> 31) == 0) {         return (EInteger)((int)words[0]);       }
Magic Number,PeterO.Cbor,FastInteger2,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\FastInteger2.cs,WordsToEInteger,The following statement contains a magic number: var bytes = new byte[(wordCount * 4) + 1];
Magic Number,PeterO.Cbor,FastInteger2,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\FastInteger2.cs,WordsToEInteger,The following statement contains a magic number: for (var i = 0; i < wordCount; ++i) {         bytes[(i * 4) + 0] = (byte)(words[i] & 0xff);         bytes[(i * 4) + 1] = (byte)((words[i] >> 8) & 0xff);         bytes[(i * 4) + 2] = (byte)((words[i] >> 16) & 0xff);         bytes[(i * 4) + 3] = (byte)((words[i] >> 24) & 0xff);       }
Magic Number,PeterO.Cbor,FastInteger2,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\FastInteger2.cs,WordsToEInteger,The following statement contains a magic number: for (var i = 0; i < wordCount; ++i) {         bytes[(i * 4) + 0] = (byte)(words[i] & 0xff);         bytes[(i * 4) + 1] = (byte)((words[i] >> 8) & 0xff);         bytes[(i * 4) + 2] = (byte)((words[i] >> 16) & 0xff);         bytes[(i * 4) + 3] = (byte)((words[i] >> 24) & 0xff);       }
Magic Number,PeterO.Cbor,FastInteger2,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\FastInteger2.cs,WordsToEInteger,The following statement contains a magic number: for (var i = 0; i < wordCount; ++i) {         bytes[(i * 4) + 0] = (byte)(words[i] & 0xff);         bytes[(i * 4) + 1] = (byte)((words[i] >> 8) & 0xff);         bytes[(i * 4) + 2] = (byte)((words[i] >> 16) & 0xff);         bytes[(i * 4) + 3] = (byte)((words[i] >> 24) & 0xff);       }
Magic Number,PeterO.Cbor,FastInteger2,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\FastInteger2.cs,WordsToEInteger,The following statement contains a magic number: for (var i = 0; i < wordCount; ++i) {         bytes[(i * 4) + 0] = (byte)(words[i] & 0xff);         bytes[(i * 4) + 1] = (byte)((words[i] >> 8) & 0xff);         bytes[(i * 4) + 2] = (byte)((words[i] >> 16) & 0xff);         bytes[(i * 4) + 3] = (byte)((words[i] >> 24) & 0xff);       }
Magic Number,PeterO.Cbor,FastInteger2,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\FastInteger2.cs,WordsToEInteger,The following statement contains a magic number: for (var i = 0; i < wordCount; ++i) {         bytes[(i * 4) + 0] = (byte)(words[i] & 0xff);         bytes[(i * 4) + 1] = (byte)((words[i] >> 8) & 0xff);         bytes[(i * 4) + 2] = (byte)((words[i] >> 16) & 0xff);         bytes[(i * 4) + 3] = (byte)((words[i] >> 24) & 0xff);       }
Magic Number,PeterO.Cbor,FastInteger2,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\FastInteger2.cs,WordsToEInteger,The following statement contains a magic number: for (var i = 0; i < wordCount; ++i) {         bytes[(i * 4) + 0] = (byte)(words[i] & 0xff);         bytes[(i * 4) + 1] = (byte)((words[i] >> 8) & 0xff);         bytes[(i * 4) + 2] = (byte)((words[i] >> 16) & 0xff);         bytes[(i * 4) + 3] = (byte)((words[i] >> 24) & 0xff);       }
Magic Number,PeterO.Cbor,FastInteger2,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\FastInteger2.cs,WordsToEInteger,The following statement contains a magic number: for (var i = 0; i < wordCount; ++i) {         bytes[(i * 4) + 0] = (byte)(words[i] & 0xff);         bytes[(i * 4) + 1] = (byte)((words[i] >> 8) & 0xff);         bytes[(i * 4) + 2] = (byte)((words[i] >> 16) & 0xff);         bytes[(i * 4) + 3] = (byte)((words[i] >> 24) & 0xff);       }
Magic Number,PeterO.Cbor,FastInteger2,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\FastInteger2.cs,WordsToEInteger,The following statement contains a magic number: for (var i = 0; i < wordCount; ++i) {         bytes[(i * 4) + 0] = (byte)(words[i] & 0xff);         bytes[(i * 4) + 1] = (byte)((words[i] >> 8) & 0xff);         bytes[(i * 4) + 2] = (byte)((words[i] >> 16) & 0xff);         bytes[(i * 4) + 3] = (byte)((words[i] >> 24) & 0xff);       }
Magic Number,PeterO.Cbor,FastInteger2,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\FastInteger2.cs,WordsToEInteger,The following statement contains a magic number: for (var i = 0; i < wordCount; ++i) {         bytes[(i * 4) + 0] = (byte)(words[i] & 0xff);         bytes[(i * 4) + 1] = (byte)((words[i] >> 8) & 0xff);         bytes[(i * 4) + 2] = (byte)((words[i] >> 16) & 0xff);         bytes[(i * 4) + 3] = (byte)((words[i] >> 24) & 0xff);       }
Magic Number,PeterO.Cbor,FastInteger2,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\FastInteger2.cs,Multiply,The following statement contains a magic number: if (val == 0) {         this.smallValue = 0;         this.integerMode = 0;       } else {         switch (this.integerMode) {           case 0:             bool apos = this.smallValue > 0L;             bool bpos = val > 0L;             if (               (apos && ((!bpos && (Int32.MinValue / this.smallValue) > val) ||                     (bpos && this.smallValue > (Int32.MaxValue / val)))) ||               (!apos && ((!bpos && this.smallValue != 0L &&                     (Int32.MaxValue / this.smallValue) > val) ||                     (bpos && this.smallValue < (Int32.MinValue / val))))) {               // would overflow' convert to large               if (apos && bpos) {                 // if both operands are nonnegative                 // convert to mutable big integer                 this.integerMode = 1;                 this.mnum = new MutableNumber(this.smallValue);                 this.mnum.Multiply(val);               } else {                 // if either operand is negative                 // convert to big integer                 this.integerMode = 2;                 this.largeValue = (EInteger)this.smallValue;                 this.largeValue *= (EInteger)val;               }             } else {               smallValue *= val;             }             break;           case 1:             if (val < 0) {               this.integerMode = 2;               this.largeValue = this.mnum.ToEInteger();               this.largeValue *= (EInteger)val;             } else {               mnum.Multiply(val);             }             break;           case 2:             this.largeValue *= (EInteger)val;             break;           default: throw new InvalidOperationException();         }       }
Magic Number,PeterO.Cbor,FastInteger2,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\FastInteger2.cs,Multiply,The following statement contains a magic number: if (val == 0) {         this.smallValue = 0;         this.integerMode = 0;       } else {         switch (this.integerMode) {           case 0:             bool apos = this.smallValue > 0L;             bool bpos = val > 0L;             if (               (apos && ((!bpos && (Int32.MinValue / this.smallValue) > val) ||                     (bpos && this.smallValue > (Int32.MaxValue / val)))) ||               (!apos && ((!bpos && this.smallValue != 0L &&                     (Int32.MaxValue / this.smallValue) > val) ||                     (bpos && this.smallValue < (Int32.MinValue / val))))) {               // would overflow' convert to large               if (apos && bpos) {                 // if both operands are nonnegative                 // convert to mutable big integer                 this.integerMode = 1;                 this.mnum = new MutableNumber(this.smallValue);                 this.mnum.Multiply(val);               } else {                 // if either operand is negative                 // convert to big integer                 this.integerMode = 2;                 this.largeValue = (EInteger)this.smallValue;                 this.largeValue *= (EInteger)val;               }             } else {               smallValue *= val;             }             break;           case 1:             if (val < 0) {               this.integerMode = 2;               this.largeValue = this.mnum.ToEInteger();               this.largeValue *= (EInteger)val;             } else {               mnum.Multiply(val);             }             break;           case 2:             this.largeValue *= (EInteger)val;             break;           default: throw new InvalidOperationException();         }       }
Magic Number,PeterO.Cbor,FastInteger2,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\FastInteger2.cs,Multiply,The following statement contains a magic number: if (val == 0) {         this.smallValue = 0;         this.integerMode = 0;       } else {         switch (this.integerMode) {           case 0:             bool apos = this.smallValue > 0L;             bool bpos = val > 0L;             if (               (apos && ((!bpos && (Int32.MinValue / this.smallValue) > val) ||                     (bpos && this.smallValue > (Int32.MaxValue / val)))) ||               (!apos && ((!bpos && this.smallValue != 0L &&                     (Int32.MaxValue / this.smallValue) > val) ||                     (bpos && this.smallValue < (Int32.MinValue / val))))) {               // would overflow' convert to large               if (apos && bpos) {                 // if both operands are nonnegative                 // convert to mutable big integer                 this.integerMode = 1;                 this.mnum = new MutableNumber(this.smallValue);                 this.mnum.Multiply(val);               } else {                 // if either operand is negative                 // convert to big integer                 this.integerMode = 2;                 this.largeValue = (EInteger)this.smallValue;                 this.largeValue *= (EInteger)val;               }             } else {               smallValue *= val;             }             break;           case 1:             if (val < 0) {               this.integerMode = 2;               this.largeValue = this.mnum.ToEInteger();               this.largeValue *= (EInteger)val;             } else {               mnum.Multiply(val);             }             break;           case 2:             this.largeValue *= (EInteger)val;             break;           default: throw new InvalidOperationException();         }       }
Magic Number,PeterO.Cbor,FastInteger2,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\FastInteger2.cs,Subtract,The following statement contains a magic number: switch (this.integerMode) {         case 0:           if (val.integerMode == 0) {             int vsv = val.smallValue;             if ((vsv < 0 && Int32.MaxValue + vsv < this.smallValue) ||                 (vsv > 0 && Int32.MinValue + vsv > this.smallValue)) {               // would overflow' convert to large               this.integerMode = 2;               this.largeValue = (EInteger)this.smallValue;               this.largeValue -= (EInteger)vsv;             } else {               this.smallValue -= vsv;             }           } else {             integerMode = 2;             largeValue = (EInteger)smallValue;             valValue = val.AsBigInteger();             largeValue -= (EInteger)valValue;           }           break;         case 1:           if (val.integerMode == 1) {             // NOTE: Mutable numbers are             // currently always zero or positive             this.mnum.Subtract(val.mnum);           } else if (val.integerMode == 0 && val.smallValue >= 0) {             mnum.SubtractInt(val.smallValue);           } else {             integerMode = 2;             largeValue = mnum.ToEInteger();             valValue = val.AsBigInteger();             largeValue -= (EInteger)valValue;           }           break;         case 2:           valValue = val.AsBigInteger();           this.largeValue -= (EInteger)valValue;           break;         default: throw new InvalidOperationException();       }
Magic Number,PeterO.Cbor,FastInteger2,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\FastInteger2.cs,Subtract,The following statement contains a magic number: switch (this.integerMode) {         case 0:           if (val.integerMode == 0) {             int vsv = val.smallValue;             if ((vsv < 0 && Int32.MaxValue + vsv < this.smallValue) ||                 (vsv > 0 && Int32.MinValue + vsv > this.smallValue)) {               // would overflow' convert to large               this.integerMode = 2;               this.largeValue = (EInteger)this.smallValue;               this.largeValue -= (EInteger)vsv;             } else {               this.smallValue -= vsv;             }           } else {             integerMode = 2;             largeValue = (EInteger)smallValue;             valValue = val.AsBigInteger();             largeValue -= (EInteger)valValue;           }           break;         case 1:           if (val.integerMode == 1) {             // NOTE: Mutable numbers are             // currently always zero or positive             this.mnum.Subtract(val.mnum);           } else if (val.integerMode == 0 && val.smallValue >= 0) {             mnum.SubtractInt(val.smallValue);           } else {             integerMode = 2;             largeValue = mnum.ToEInteger();             valValue = val.AsBigInteger();             largeValue -= (EInteger)valValue;           }           break;         case 2:           valValue = val.AsBigInteger();           this.largeValue -= (EInteger)valValue;           break;         default: throw new InvalidOperationException();       }
Magic Number,PeterO.Cbor,FastInteger2,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\FastInteger2.cs,Subtract,The following statement contains a magic number: switch (this.integerMode) {         case 0:           if (val.integerMode == 0) {             int vsv = val.smallValue;             if ((vsv < 0 && Int32.MaxValue + vsv < this.smallValue) ||                 (vsv > 0 && Int32.MinValue + vsv > this.smallValue)) {               // would overflow' convert to large               this.integerMode = 2;               this.largeValue = (EInteger)this.smallValue;               this.largeValue -= (EInteger)vsv;             } else {               this.smallValue -= vsv;             }           } else {             integerMode = 2;             largeValue = (EInteger)smallValue;             valValue = val.AsBigInteger();             largeValue -= (EInteger)valValue;           }           break;         case 1:           if (val.integerMode == 1) {             // NOTE: Mutable numbers are             // currently always zero or positive             this.mnum.Subtract(val.mnum);           } else if (val.integerMode == 0 && val.smallValue >= 0) {             mnum.SubtractInt(val.smallValue);           } else {             integerMode = 2;             largeValue = mnum.ToEInteger();             valValue = val.AsBigInteger();             largeValue -= (EInteger)valValue;           }           break;         case 2:           valValue = val.AsBigInteger();           this.largeValue -= (EInteger)valValue;           break;         default: throw new InvalidOperationException();       }
Magic Number,PeterO.Cbor,FastInteger2,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\FastInteger2.cs,Subtract,The following statement contains a magic number: switch (this.integerMode) {         case 0:           if (val.integerMode == 0) {             int vsv = val.smallValue;             if ((vsv < 0 && Int32.MaxValue + vsv < this.smallValue) ||                 (vsv > 0 && Int32.MinValue + vsv > this.smallValue)) {               // would overflow' convert to large               this.integerMode = 2;               this.largeValue = (EInteger)this.smallValue;               this.largeValue -= (EInteger)vsv;             } else {               this.smallValue -= vsv;             }           } else {             integerMode = 2;             largeValue = (EInteger)smallValue;             valValue = val.AsBigInteger();             largeValue -= (EInteger)valValue;           }           break;         case 1:           if (val.integerMode == 1) {             // NOTE: Mutable numbers are             // currently always zero or positive             this.mnum.Subtract(val.mnum);           } else if (val.integerMode == 0 && val.smallValue >= 0) {             mnum.SubtractInt(val.smallValue);           } else {             integerMode = 2;             largeValue = mnum.ToEInteger();             valValue = val.AsBigInteger();             largeValue -= (EInteger)valValue;           }           break;         case 2:           valValue = val.AsBigInteger();           this.largeValue -= (EInteger)valValue;           break;         default: throw new InvalidOperationException();       }
Magic Number,PeterO.Cbor,FastInteger2,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\FastInteger2.cs,SubtractInt,The following statement contains a magic number: if (this.integerMode == 0) {         if ((val < 0 && Int32.MaxValue + val < this.smallValue) ||                 (val > 0 && Int32.MinValue + val > this.smallValue)) {           // would overflow' convert to large           this.integerMode = 2;           this.largeValue = (EInteger)this.smallValue;           this.largeValue -= (EInteger)val;         } else {           this.smallValue -= val;         }         return this;       }
Magic Number,PeterO.Cbor,FastInteger2,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\FastInteger2.cs,Add,The following statement contains a magic number: switch (this.integerMode) {         case 0:           if (val.integerMode == 0) {             if ((this.smallValue < 0 && (int)val.smallValue < Int32.MinValue             - this.smallValue) ||                 (this.smallValue > 0 && (int)val.smallValue > Int32.MaxValue                 - this.smallValue)) {               // would overflow               if (val.smallValue >= 0) {                 this.integerMode = 1;                 this.mnum = new MutableNumber(this.smallValue);                 this.mnum.Add(val.smallValue);               } else {                 this.integerMode = 2;                 this.largeValue = (EInteger)this.smallValue;                 this.largeValue += (EInteger)val.smallValue;               }             } else {               this.smallValue += val.smallValue;             }           } else {             integerMode = 2;             largeValue = (EInteger)smallValue;             valValue = val.AsBigInteger();             largeValue += (EInteger)valValue;           }           break;         case 1:           if (val.integerMode == 0 && val.smallValue >= 0) {             this.mnum.Add(val.smallValue);           } else {             integerMode = 2;             largeValue = mnum.ToEInteger();             valValue = val.AsBigInteger();             largeValue += (EInteger)valValue;           }           break;         case 2:           valValue = val.AsBigInteger();           this.largeValue += (EInteger)valValue;           break;         default: throw new InvalidOperationException();       }
Magic Number,PeterO.Cbor,FastInteger2,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\FastInteger2.cs,Add,The following statement contains a magic number: switch (this.integerMode) {         case 0:           if (val.integerMode == 0) {             if ((this.smallValue < 0 && (int)val.smallValue < Int32.MinValue             - this.smallValue) ||                 (this.smallValue > 0 && (int)val.smallValue > Int32.MaxValue                 - this.smallValue)) {               // would overflow               if (val.smallValue >= 0) {                 this.integerMode = 1;                 this.mnum = new MutableNumber(this.smallValue);                 this.mnum.Add(val.smallValue);               } else {                 this.integerMode = 2;                 this.largeValue = (EInteger)this.smallValue;                 this.largeValue += (EInteger)val.smallValue;               }             } else {               this.smallValue += val.smallValue;             }           } else {             integerMode = 2;             largeValue = (EInteger)smallValue;             valValue = val.AsBigInteger();             largeValue += (EInteger)valValue;           }           break;         case 1:           if (val.integerMode == 0 && val.smallValue >= 0) {             this.mnum.Add(val.smallValue);           } else {             integerMode = 2;             largeValue = mnum.ToEInteger();             valValue = val.AsBigInteger();             largeValue += (EInteger)valValue;           }           break;         case 2:           valValue = val.AsBigInteger();           this.largeValue += (EInteger)valValue;           break;         default: throw new InvalidOperationException();       }
Magic Number,PeterO.Cbor,FastInteger2,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\FastInteger2.cs,Add,The following statement contains a magic number: switch (this.integerMode) {         case 0:           if (val.integerMode == 0) {             if ((this.smallValue < 0 && (int)val.smallValue < Int32.MinValue             - this.smallValue) ||                 (this.smallValue > 0 && (int)val.smallValue > Int32.MaxValue                 - this.smallValue)) {               // would overflow               if (val.smallValue >= 0) {                 this.integerMode = 1;                 this.mnum = new MutableNumber(this.smallValue);                 this.mnum.Add(val.smallValue);               } else {                 this.integerMode = 2;                 this.largeValue = (EInteger)this.smallValue;                 this.largeValue += (EInteger)val.smallValue;               }             } else {               this.smallValue += val.smallValue;             }           } else {             integerMode = 2;             largeValue = (EInteger)smallValue;             valValue = val.AsBigInteger();             largeValue += (EInteger)valValue;           }           break;         case 1:           if (val.integerMode == 0 && val.smallValue >= 0) {             this.mnum.Add(val.smallValue);           } else {             integerMode = 2;             largeValue = mnum.ToEInteger();             valValue = val.AsBigInteger();             largeValue += (EInteger)valValue;           }           break;         case 2:           valValue = val.AsBigInteger();           this.largeValue += (EInteger)valValue;           break;         default: throw new InvalidOperationException();       }
Magic Number,PeterO.Cbor,FastInteger2,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\FastInteger2.cs,Add,The following statement contains a magic number: switch (this.integerMode) {         case 0:           if (val.integerMode == 0) {             if ((this.smallValue < 0 && (int)val.smallValue < Int32.MinValue             - this.smallValue) ||                 (this.smallValue > 0 && (int)val.smallValue > Int32.MaxValue                 - this.smallValue)) {               // would overflow               if (val.smallValue >= 0) {                 this.integerMode = 1;                 this.mnum = new MutableNumber(this.smallValue);                 this.mnum.Add(val.smallValue);               } else {                 this.integerMode = 2;                 this.largeValue = (EInteger)this.smallValue;                 this.largeValue += (EInteger)val.smallValue;               }             } else {               this.smallValue += val.smallValue;             }           } else {             integerMode = 2;             largeValue = (EInteger)smallValue;             valValue = val.AsBigInteger();             largeValue += (EInteger)valValue;           }           break;         case 1:           if (val.integerMode == 0 && val.smallValue >= 0) {             this.mnum.Add(val.smallValue);           } else {             integerMode = 2;             largeValue = mnum.ToEInteger();             valValue = val.AsBigInteger();             largeValue += (EInteger)valValue;           }           break;         case 2:           valValue = val.AsBigInteger();           this.largeValue += (EInteger)valValue;           break;         default: throw new InvalidOperationException();       }
Magic Number,PeterO.Cbor,FastInteger2,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\FastInteger2.cs,AddInt,The following statement contains a magic number: switch (this.integerMode) {         case 0:           if ((this.smallValue < 0 && (int)val < Int32.MinValue -         this.smallValue) || (this.smallValue > 0 && (int)val >             Int32.MaxValue - this.smallValue)) {             // would overflow             if (val >= 0) {               this.integerMode = 1;               this.mnum = new MutableNumber(this.smallValue);               this.mnum.Add(val);             } else {               this.integerMode = 2;               this.largeValue = (EInteger)this.smallValue;               this.largeValue += (EInteger)val;             }           } else {             smallValue += val;           }           break;         case 1:           if (val >= 0) {             this.mnum.Add(val);           } else {             integerMode = 2;             largeValue = mnum.ToEInteger();             valValue = (EInteger)val;             largeValue += (EInteger)valValue;           }           break;         case 2:           valValue = (EInteger)val;           this.largeValue += (EInteger)valValue;           break;         default: throw new InvalidOperationException();       }
Magic Number,PeterO.Cbor,FastInteger2,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\FastInteger2.cs,AddInt,The following statement contains a magic number: switch (this.integerMode) {         case 0:           if ((this.smallValue < 0 && (int)val < Int32.MinValue -         this.smallValue) || (this.smallValue > 0 && (int)val >             Int32.MaxValue - this.smallValue)) {             // would overflow             if (val >= 0) {               this.integerMode = 1;               this.mnum = new MutableNumber(this.smallValue);               this.mnum.Add(val);             } else {               this.integerMode = 2;               this.largeValue = (EInteger)this.smallValue;               this.largeValue += (EInteger)val;             }           } else {             smallValue += val;           }           break;         case 1:           if (val >= 0) {             this.mnum.Add(val);           } else {             integerMode = 2;             largeValue = mnum.ToEInteger();             valValue = (EInteger)val;             largeValue += (EInteger)valValue;           }           break;         case 2:           valValue = (EInteger)val;           this.largeValue += (EInteger)valValue;           break;         default: throw new InvalidOperationException();       }
Magic Number,PeterO.Cbor,FastInteger2,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\FastInteger2.cs,AddInt,The following statement contains a magic number: switch (this.integerMode) {         case 0:           if ((this.smallValue < 0 && (int)val < Int32.MinValue -         this.smallValue) || (this.smallValue > 0 && (int)val >             Int32.MaxValue - this.smallValue)) {             // would overflow             if (val >= 0) {               this.integerMode = 1;               this.mnum = new MutableNumber(this.smallValue);               this.mnum.Add(val);             } else {               this.integerMode = 2;               this.largeValue = (EInteger)this.smallValue;               this.largeValue += (EInteger)val;             }           } else {             smallValue += val;           }           break;         case 1:           if (val >= 0) {             this.mnum.Add(val);           } else {             integerMode = 2;             largeValue = mnum.ToEInteger();             valValue = (EInteger)val;             largeValue += (EInteger)valValue;           }           break;         case 2:           valValue = (EInteger)val;           this.largeValue += (EInteger)valValue;           break;         default: throw new InvalidOperationException();       }
Magic Number,PeterO.Cbor,FastInteger2,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\FastInteger2.cs,CanFitInInt32,The following statement contains a magic number: switch (this.integerMode) {         case 0:           return true;         case 1:           return this.mnum.CanFitInInt32();           case 2: {             return this.largeValue.CanFitInInt32();           }         default:           throw new InvalidOperationException();       }
Magic Number,PeterO.Cbor,FastInteger2,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\FastInteger2.cs,AsBigInteger,The following statement contains a magic number: switch (this.integerMode) {         case 0:           return EInteger.FromInt32(this.smallValue);         case 1:           return this.mnum.ToEInteger();         case 2:           return this.largeValue;         default: throw new InvalidOperationException();       }
Magic Number,PeterO.Cbor,MutableNumber,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\FastInteger2.cs,MutableNumber,The following statement contains a magic number: this.data = new int[4];
Magic Number,PeterO.Cbor,MutableNumber,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\FastInteger2.cs,ToEInteger,The following statement contains a magic number: if (this.wordCount == 1 && (this.data[0] >> 31) == 0) {           return (EInteger)((int)this.data[0]);         }
Magic Number,PeterO.Cbor,MutableNumber,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\FastInteger2.cs,ToEInteger,The following statement contains a magic number: var bytes = new byte[(this.wordCount * 4) + 1];
Magic Number,PeterO.Cbor,MutableNumber,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\FastInteger2.cs,ToEInteger,The following statement contains a magic number: for (var i = 0; i < this.wordCount; ++i) {           bytes[i * 4] = (byte)(this.data[i] & 0xff);           bytes[(i * 4) + 1] = (byte)((this.data[i] >> 8) & 0xff);           bytes[(i * 4) + 2] = (byte)((this.data[i] >> 16) & 0xff);           bytes[(i * 4) + 3] = (byte)((this.data[i] >> 24) & 0xff);         }
Magic Number,PeterO.Cbor,MutableNumber,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\FastInteger2.cs,ToEInteger,The following statement contains a magic number: for (var i = 0; i < this.wordCount; ++i) {           bytes[i * 4] = (byte)(this.data[i] & 0xff);           bytes[(i * 4) + 1] = (byte)((this.data[i] >> 8) & 0xff);           bytes[(i * 4) + 2] = (byte)((this.data[i] >> 16) & 0xff);           bytes[(i * 4) + 3] = (byte)((this.data[i] >> 24) & 0xff);         }
Magic Number,PeterO.Cbor,MutableNumber,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\FastInteger2.cs,ToEInteger,The following statement contains a magic number: for (var i = 0; i < this.wordCount; ++i) {           bytes[i * 4] = (byte)(this.data[i] & 0xff);           bytes[(i * 4) + 1] = (byte)((this.data[i] >> 8) & 0xff);           bytes[(i * 4) + 2] = (byte)((this.data[i] >> 16) & 0xff);           bytes[(i * 4) + 3] = (byte)((this.data[i] >> 24) & 0xff);         }
Magic Number,PeterO.Cbor,MutableNumber,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\FastInteger2.cs,ToEInteger,The following statement contains a magic number: for (var i = 0; i < this.wordCount; ++i) {           bytes[i * 4] = (byte)(this.data[i] & 0xff);           bytes[(i * 4) + 1] = (byte)((this.data[i] >> 8) & 0xff);           bytes[(i * 4) + 2] = (byte)((this.data[i] >> 16) & 0xff);           bytes[(i * 4) + 3] = (byte)((this.data[i] >> 24) & 0xff);         }
Magic Number,PeterO.Cbor,MutableNumber,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\FastInteger2.cs,ToEInteger,The following statement contains a magic number: for (var i = 0; i < this.wordCount; ++i) {           bytes[i * 4] = (byte)(this.data[i] & 0xff);           bytes[(i * 4) + 1] = (byte)((this.data[i] >> 8) & 0xff);           bytes[(i * 4) + 2] = (byte)((this.data[i] >> 16) & 0xff);           bytes[(i * 4) + 3] = (byte)((this.data[i] >> 24) & 0xff);         }
Magic Number,PeterO.Cbor,MutableNumber,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\FastInteger2.cs,ToEInteger,The following statement contains a magic number: for (var i = 0; i < this.wordCount; ++i) {           bytes[i * 4] = (byte)(this.data[i] & 0xff);           bytes[(i * 4) + 1] = (byte)((this.data[i] >> 8) & 0xff);           bytes[(i * 4) + 2] = (byte)((this.data[i] >> 16) & 0xff);           bytes[(i * 4) + 3] = (byte)((this.data[i] >> 24) & 0xff);         }
Magic Number,PeterO.Cbor,MutableNumber,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\FastInteger2.cs,ToEInteger,The following statement contains a magic number: for (var i = 0; i < this.wordCount; ++i) {           bytes[i * 4] = (byte)(this.data[i] & 0xff);           bytes[(i * 4) + 1] = (byte)((this.data[i] >> 8) & 0xff);           bytes[(i * 4) + 2] = (byte)((this.data[i] >> 16) & 0xff);           bytes[(i * 4) + 3] = (byte)((this.data[i] >> 24) & 0xff);         }
Magic Number,PeterO.Cbor,MutableNumber,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\FastInteger2.cs,ToEInteger,The following statement contains a magic number: for (var i = 0; i < this.wordCount; ++i) {           bytes[i * 4] = (byte)(this.data[i] & 0xff);           bytes[(i * 4) + 1] = (byte)((this.data[i] >> 8) & 0xff);           bytes[(i * 4) + 2] = (byte)((this.data[i] >> 16) & 0xff);           bytes[(i * 4) + 3] = (byte)((this.data[i] >> 24) & 0xff);         }
Magic Number,PeterO.Cbor,MutableNumber,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\FastInteger2.cs,ToEInteger,The following statement contains a magic number: for (var i = 0; i < this.wordCount; ++i) {           bytes[i * 4] = (byte)(this.data[i] & 0xff);           bytes[(i * 4) + 1] = (byte)((this.data[i] >> 8) & 0xff);           bytes[(i * 4) + 2] = (byte)((this.data[i] >> 16) & 0xff);           bytes[(i * 4) + 3] = (byte)((this.data[i] >> 24) & 0xff);         }
Magic Number,PeterO.Cbor,MutableNumber,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\FastInteger2.cs,CanFitInInt32,The following statement contains a magic number: return this.wordCount == 0 || (this.wordCount == 1 && (this.data[0] >>         31) == 0);
Magic Number,PeterO.Cbor,MutableNumber,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\FastInteger2.cs,Multiply,The following statement contains a magic number: if (multiplicand != 0) {           var carry = 0;           if (this.wordCount == 0) {             if (this.data.Length == 0) {               this.data = new int[4];             }             this.data[0] = 0;             this.wordCount = 1;           }           int result0' result1' result2' result3;           if (multiplicand < 65536) {             for (var i = 0; i < this.wordCount; ++i) {               int x0 = this.data[i];               int x1 = x0;               int y0 = multiplicand;               x0 &= 65535;               x1 = (x1 >> 16) & 65535;               int temp = unchecked(x0 * y0);  // a * c               result1 = (temp >> 16) & 65535;               result0 = temp & 65535;               result2 = 0;               temp = unchecked(x1 * y0);  // b * c               result2 += (temp >> 16) & 65535;               result1 += temp & 65535;               result2 += (result1 >> 16) & 65535;               result1 &= 65535;               result3 = (result2 >> 16) & 65535;               result2 &= 65535;               // Add carry               x0 = unchecked((int)(result0 | (result1 << 16)));               x1 = unchecked((int)(result2 | (result3 << 16)));               int x2 = unchecked(x0 + carry);               if (((x2 >> 31) == (x0 >> 31)) ? ((x2 & Int32.MaxValue) < (x0 &               Int32.MaxValue)) : ((x2 >> 31) == 0)) {                 // Carry in addition                 x1 = unchecked(x1 + 1);               }               this.data[i] = x2;               carry = x1;             }           } else {             for (var i = 0; i < this.wordCount; ++i) {               int x0 = this.data[i];               int x1 = x0;               int y0 = multiplicand;               int y1 = y0;               x0 &= 65535;               y0 &= 65535;               x1 = (x1 >> 16) & 65535;               y1 = (y1 >> 16) & 65535;               int temp = unchecked(x0 * y0);  // a * c               result1 = (temp >> 16) & 65535;               result0 = temp & 65535;               temp = unchecked(x0 * y1);  // a * d               result2 = (temp >> 16) & 65535;               result1 += temp & 65535;               result2 += (result1 >> 16) & 65535;               result1 &= 65535;               temp = unchecked(x1 * y0);  // b * c               result2 += (temp >> 16) & 65535;               result1 += temp & 65535;               result2 += (result1 >> 16) & 65535;               result1 &= 65535;               result3 = (result2 >> 16) & 65535;               result2 &= 65535;               temp = unchecked(x1 * y1);  // b * d               result3 += (temp >> 16) & 65535;               result2 += temp & 65535;               result3 += (result2 >> 16) & 65535;               result2 &= 65535;               // Add carry               x0 = unchecked((int)(result0 | (result1 << 16)));               x1 = unchecked((int)(result2 | (result3 << 16)));               int x2 = unchecked(x0 + carry);               if (((x2 >> 31) == (x0 >> 31)) ? ((x2 & Int32.MaxValue) < (x0 &               Int32.MaxValue)) : ((x2 >> 31) == 0)) {                 // Carry in addition                 x1 = unchecked(x1 + 1);               }               this.data[i] = x2;               carry = x1;             }           }           if (carry != 0) {             if (this.wordCount >= this.data.Length) {               var newdata = new int[this.wordCount + 20];               Array.Copy(this.data' 0' newdata' 0' this.data.Length);               this.data = newdata;             }             this.data[this.wordCount] = carry;             ++this.wordCount;           }           // Calculate the correct data length           while (this.wordCount != 0 && this.data[this.wordCount - 1] == 0) {             --this.wordCount;           }         } else {           if (this.data.Length > 0) {             this.data[0] = 0;           }           this.wordCount = 0;         }
Magic Number,PeterO.Cbor,MutableNumber,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\FastInteger2.cs,Multiply,The following statement contains a magic number: if (multiplicand != 0) {           var carry = 0;           if (this.wordCount == 0) {             if (this.data.Length == 0) {               this.data = new int[4];             }             this.data[0] = 0;             this.wordCount = 1;           }           int result0' result1' result2' result3;           if (multiplicand < 65536) {             for (var i = 0; i < this.wordCount; ++i) {               int x0 = this.data[i];               int x1 = x0;               int y0 = multiplicand;               x0 &= 65535;               x1 = (x1 >> 16) & 65535;               int temp = unchecked(x0 * y0);  // a * c               result1 = (temp >> 16) & 65535;               result0 = temp & 65535;               result2 = 0;               temp = unchecked(x1 * y0);  // b * c               result2 += (temp >> 16) & 65535;               result1 += temp & 65535;               result2 += (result1 >> 16) & 65535;               result1 &= 65535;               result3 = (result2 >> 16) & 65535;               result2 &= 65535;               // Add carry               x0 = unchecked((int)(result0 | (result1 << 16)));               x1 = unchecked((int)(result2 | (result3 << 16)));               int x2 = unchecked(x0 + carry);               if (((x2 >> 31) == (x0 >> 31)) ? ((x2 & Int32.MaxValue) < (x0 &               Int32.MaxValue)) : ((x2 >> 31) == 0)) {                 // Carry in addition                 x1 = unchecked(x1 + 1);               }               this.data[i] = x2;               carry = x1;             }           } else {             for (var i = 0; i < this.wordCount; ++i) {               int x0 = this.data[i];               int x1 = x0;               int y0 = multiplicand;               int y1 = y0;               x0 &= 65535;               y0 &= 65535;               x1 = (x1 >> 16) & 65535;               y1 = (y1 >> 16) & 65535;               int temp = unchecked(x0 * y0);  // a * c               result1 = (temp >> 16) & 65535;               result0 = temp & 65535;               temp = unchecked(x0 * y1);  // a * d               result2 = (temp >> 16) & 65535;               result1 += temp & 65535;               result2 += (result1 >> 16) & 65535;               result1 &= 65535;               temp = unchecked(x1 * y0);  // b * c               result2 += (temp >> 16) & 65535;               result1 += temp & 65535;               result2 += (result1 >> 16) & 65535;               result1 &= 65535;               result3 = (result2 >> 16) & 65535;               result2 &= 65535;               temp = unchecked(x1 * y1);  // b * d               result3 += (temp >> 16) & 65535;               result2 += temp & 65535;               result3 += (result2 >> 16) & 65535;               result2 &= 65535;               // Add carry               x0 = unchecked((int)(result0 | (result1 << 16)));               x1 = unchecked((int)(result2 | (result3 << 16)));               int x2 = unchecked(x0 + carry);               if (((x2 >> 31) == (x0 >> 31)) ? ((x2 & Int32.MaxValue) < (x0 &               Int32.MaxValue)) : ((x2 >> 31) == 0)) {                 // Carry in addition                 x1 = unchecked(x1 + 1);               }               this.data[i] = x2;               carry = x1;             }           }           if (carry != 0) {             if (this.wordCount >= this.data.Length) {               var newdata = new int[this.wordCount + 20];               Array.Copy(this.data' 0' newdata' 0' this.data.Length);               this.data = newdata;             }             this.data[this.wordCount] = carry;             ++this.wordCount;           }           // Calculate the correct data length           while (this.wordCount != 0 && this.data[this.wordCount - 1] == 0) {             --this.wordCount;           }         } else {           if (this.data.Length > 0) {             this.data[0] = 0;           }           this.wordCount = 0;         }
Magic Number,PeterO.Cbor,MutableNumber,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\FastInteger2.cs,Multiply,The following statement contains a magic number: if (multiplicand != 0) {           var carry = 0;           if (this.wordCount == 0) {             if (this.data.Length == 0) {               this.data = new int[4];             }             this.data[0] = 0;             this.wordCount = 1;           }           int result0' result1' result2' result3;           if (multiplicand < 65536) {             for (var i = 0; i < this.wordCount; ++i) {               int x0 = this.data[i];               int x1 = x0;               int y0 = multiplicand;               x0 &= 65535;               x1 = (x1 >> 16) & 65535;               int temp = unchecked(x0 * y0);  // a * c               result1 = (temp >> 16) & 65535;               result0 = temp & 65535;               result2 = 0;               temp = unchecked(x1 * y0);  // b * c               result2 += (temp >> 16) & 65535;               result1 += temp & 65535;               result2 += (result1 >> 16) & 65535;               result1 &= 65535;               result3 = (result2 >> 16) & 65535;               result2 &= 65535;               // Add carry               x0 = unchecked((int)(result0 | (result1 << 16)));               x1 = unchecked((int)(result2 | (result3 << 16)));               int x2 = unchecked(x0 + carry);               if (((x2 >> 31) == (x0 >> 31)) ? ((x2 & Int32.MaxValue) < (x0 &               Int32.MaxValue)) : ((x2 >> 31) == 0)) {                 // Carry in addition                 x1 = unchecked(x1 + 1);               }               this.data[i] = x2;               carry = x1;             }           } else {             for (var i = 0; i < this.wordCount; ++i) {               int x0 = this.data[i];               int x1 = x0;               int y0 = multiplicand;               int y1 = y0;               x0 &= 65535;               y0 &= 65535;               x1 = (x1 >> 16) & 65535;               y1 = (y1 >> 16) & 65535;               int temp = unchecked(x0 * y0);  // a * c               result1 = (temp >> 16) & 65535;               result0 = temp & 65535;               temp = unchecked(x0 * y1);  // a * d               result2 = (temp >> 16) & 65535;               result1 += temp & 65535;               result2 += (result1 >> 16) & 65535;               result1 &= 65535;               temp = unchecked(x1 * y0);  // b * c               result2 += (temp >> 16) & 65535;               result1 += temp & 65535;               result2 += (result1 >> 16) & 65535;               result1 &= 65535;               result3 = (result2 >> 16) & 65535;               result2 &= 65535;               temp = unchecked(x1 * y1);  // b * d               result3 += (temp >> 16) & 65535;               result2 += temp & 65535;               result3 += (result2 >> 16) & 65535;               result2 &= 65535;               // Add carry               x0 = unchecked((int)(result0 | (result1 << 16)));               x1 = unchecked((int)(result2 | (result3 << 16)));               int x2 = unchecked(x0 + carry);               if (((x2 >> 31) == (x0 >> 31)) ? ((x2 & Int32.MaxValue) < (x0 &               Int32.MaxValue)) : ((x2 >> 31) == 0)) {                 // Carry in addition                 x1 = unchecked(x1 + 1);               }               this.data[i] = x2;               carry = x1;             }           }           if (carry != 0) {             if (this.wordCount >= this.data.Length) {               var newdata = new int[this.wordCount + 20];               Array.Copy(this.data' 0' newdata' 0' this.data.Length);               this.data = newdata;             }             this.data[this.wordCount] = carry;             ++this.wordCount;           }           // Calculate the correct data length           while (this.wordCount != 0 && this.data[this.wordCount - 1] == 0) {             --this.wordCount;           }         } else {           if (this.data.Length > 0) {             this.data[0] = 0;           }           this.wordCount = 0;         }
Magic Number,PeterO.Cbor,MutableNumber,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\FastInteger2.cs,Multiply,The following statement contains a magic number: if (multiplicand != 0) {           var carry = 0;           if (this.wordCount == 0) {             if (this.data.Length == 0) {               this.data = new int[4];             }             this.data[0] = 0;             this.wordCount = 1;           }           int result0' result1' result2' result3;           if (multiplicand < 65536) {             for (var i = 0; i < this.wordCount; ++i) {               int x0 = this.data[i];               int x1 = x0;               int y0 = multiplicand;               x0 &= 65535;               x1 = (x1 >> 16) & 65535;               int temp = unchecked(x0 * y0);  // a * c               result1 = (temp >> 16) & 65535;               result0 = temp & 65535;               result2 = 0;               temp = unchecked(x1 * y0);  // b * c               result2 += (temp >> 16) & 65535;               result1 += temp & 65535;               result2 += (result1 >> 16) & 65535;               result1 &= 65535;               result3 = (result2 >> 16) & 65535;               result2 &= 65535;               // Add carry               x0 = unchecked((int)(result0 | (result1 << 16)));               x1 = unchecked((int)(result2 | (result3 << 16)));               int x2 = unchecked(x0 + carry);               if (((x2 >> 31) == (x0 >> 31)) ? ((x2 & Int32.MaxValue) < (x0 &               Int32.MaxValue)) : ((x2 >> 31) == 0)) {                 // Carry in addition                 x1 = unchecked(x1 + 1);               }               this.data[i] = x2;               carry = x1;             }           } else {             for (var i = 0; i < this.wordCount; ++i) {               int x0 = this.data[i];               int x1 = x0;               int y0 = multiplicand;               int y1 = y0;               x0 &= 65535;               y0 &= 65535;               x1 = (x1 >> 16) & 65535;               y1 = (y1 >> 16) & 65535;               int temp = unchecked(x0 * y0);  // a * c               result1 = (temp >> 16) & 65535;               result0 = temp & 65535;               temp = unchecked(x0 * y1);  // a * d               result2 = (temp >> 16) & 65535;               result1 += temp & 65535;               result2 += (result1 >> 16) & 65535;               result1 &= 65535;               temp = unchecked(x1 * y0);  // b * c               result2 += (temp >> 16) & 65535;               result1 += temp & 65535;               result2 += (result1 >> 16) & 65535;               result1 &= 65535;               result3 = (result2 >> 16) & 65535;               result2 &= 65535;               temp = unchecked(x1 * y1);  // b * d               result3 += (temp >> 16) & 65535;               result2 += temp & 65535;               result3 += (result2 >> 16) & 65535;               result2 &= 65535;               // Add carry               x0 = unchecked((int)(result0 | (result1 << 16)));               x1 = unchecked((int)(result2 | (result3 << 16)));               int x2 = unchecked(x0 + carry);               if (((x2 >> 31) == (x0 >> 31)) ? ((x2 & Int32.MaxValue) < (x0 &               Int32.MaxValue)) : ((x2 >> 31) == 0)) {                 // Carry in addition                 x1 = unchecked(x1 + 1);               }               this.data[i] = x2;               carry = x1;             }           }           if (carry != 0) {             if (this.wordCount >= this.data.Length) {               var newdata = new int[this.wordCount + 20];               Array.Copy(this.data' 0' newdata' 0' this.data.Length);               this.data = newdata;             }             this.data[this.wordCount] = carry;             ++this.wordCount;           }           // Calculate the correct data length           while (this.wordCount != 0 && this.data[this.wordCount - 1] == 0) {             --this.wordCount;           }         } else {           if (this.data.Length > 0) {             this.data[0] = 0;           }           this.wordCount = 0;         }
Magic Number,PeterO.Cbor,MutableNumber,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\FastInteger2.cs,Multiply,The following statement contains a magic number: if (multiplicand != 0) {           var carry = 0;           if (this.wordCount == 0) {             if (this.data.Length == 0) {               this.data = new int[4];             }             this.data[0] = 0;             this.wordCount = 1;           }           int result0' result1' result2' result3;           if (multiplicand < 65536) {             for (var i = 0; i < this.wordCount; ++i) {               int x0 = this.data[i];               int x1 = x0;               int y0 = multiplicand;               x0 &= 65535;               x1 = (x1 >> 16) & 65535;               int temp = unchecked(x0 * y0);  // a * c               result1 = (temp >> 16) & 65535;               result0 = temp & 65535;               result2 = 0;               temp = unchecked(x1 * y0);  // b * c               result2 += (temp >> 16) & 65535;               result1 += temp & 65535;               result2 += (result1 >> 16) & 65535;               result1 &= 65535;               result3 = (result2 >> 16) & 65535;               result2 &= 65535;               // Add carry               x0 = unchecked((int)(result0 | (result1 << 16)));               x1 = unchecked((int)(result2 | (result3 << 16)));               int x2 = unchecked(x0 + carry);               if (((x2 >> 31) == (x0 >> 31)) ? ((x2 & Int32.MaxValue) < (x0 &               Int32.MaxValue)) : ((x2 >> 31) == 0)) {                 // Carry in addition                 x1 = unchecked(x1 + 1);               }               this.data[i] = x2;               carry = x1;             }           } else {             for (var i = 0; i < this.wordCount; ++i) {               int x0 = this.data[i];               int x1 = x0;               int y0 = multiplicand;               int y1 = y0;               x0 &= 65535;               y0 &= 65535;               x1 = (x1 >> 16) & 65535;               y1 = (y1 >> 16) & 65535;               int temp = unchecked(x0 * y0);  // a * c               result1 = (temp >> 16) & 65535;               result0 = temp & 65535;               temp = unchecked(x0 * y1);  // a * d               result2 = (temp >> 16) & 65535;               result1 += temp & 65535;               result2 += (result1 >> 16) & 65535;               result1 &= 65535;               temp = unchecked(x1 * y0);  // b * c               result2 += (temp >> 16) & 65535;               result1 += temp & 65535;               result2 += (result1 >> 16) & 65535;               result1 &= 65535;               result3 = (result2 >> 16) & 65535;               result2 &= 65535;               temp = unchecked(x1 * y1);  // b * d               result3 += (temp >> 16) & 65535;               result2 += temp & 65535;               result3 += (result2 >> 16) & 65535;               result2 &= 65535;               // Add carry               x0 = unchecked((int)(result0 | (result1 << 16)));               x1 = unchecked((int)(result2 | (result3 << 16)));               int x2 = unchecked(x0 + carry);               if (((x2 >> 31) == (x0 >> 31)) ? ((x2 & Int32.MaxValue) < (x0 &               Int32.MaxValue)) : ((x2 >> 31) == 0)) {                 // Carry in addition                 x1 = unchecked(x1 + 1);               }               this.data[i] = x2;               carry = x1;             }           }           if (carry != 0) {             if (this.wordCount >= this.data.Length) {               var newdata = new int[this.wordCount + 20];               Array.Copy(this.data' 0' newdata' 0' this.data.Length);               this.data = newdata;             }             this.data[this.wordCount] = carry;             ++this.wordCount;           }           // Calculate the correct data length           while (this.wordCount != 0 && this.data[this.wordCount - 1] == 0) {             --this.wordCount;           }         } else {           if (this.data.Length > 0) {             this.data[0] = 0;           }           this.wordCount = 0;         }
Magic Number,PeterO.Cbor,MutableNumber,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\FastInteger2.cs,Multiply,The following statement contains a magic number: if (multiplicand != 0) {           var carry = 0;           if (this.wordCount == 0) {             if (this.data.Length == 0) {               this.data = new int[4];             }             this.data[0] = 0;             this.wordCount = 1;           }           int result0' result1' result2' result3;           if (multiplicand < 65536) {             for (var i = 0; i < this.wordCount; ++i) {               int x0 = this.data[i];               int x1 = x0;               int y0 = multiplicand;               x0 &= 65535;               x1 = (x1 >> 16) & 65535;               int temp = unchecked(x0 * y0);  // a * c               result1 = (temp >> 16) & 65535;               result0 = temp & 65535;               result2 = 0;               temp = unchecked(x1 * y0);  // b * c               result2 += (temp >> 16) & 65535;               result1 += temp & 65535;               result2 += (result1 >> 16) & 65535;               result1 &= 65535;               result3 = (result2 >> 16) & 65535;               result2 &= 65535;               // Add carry               x0 = unchecked((int)(result0 | (result1 << 16)));               x1 = unchecked((int)(result2 | (result3 << 16)));               int x2 = unchecked(x0 + carry);               if (((x2 >> 31) == (x0 >> 31)) ? ((x2 & Int32.MaxValue) < (x0 &               Int32.MaxValue)) : ((x2 >> 31) == 0)) {                 // Carry in addition                 x1 = unchecked(x1 + 1);               }               this.data[i] = x2;               carry = x1;             }           } else {             for (var i = 0; i < this.wordCount; ++i) {               int x0 = this.data[i];               int x1 = x0;               int y0 = multiplicand;               int y1 = y0;               x0 &= 65535;               y0 &= 65535;               x1 = (x1 >> 16) & 65535;               y1 = (y1 >> 16) & 65535;               int temp = unchecked(x0 * y0);  // a * c               result1 = (temp >> 16) & 65535;               result0 = temp & 65535;               temp = unchecked(x0 * y1);  // a * d               result2 = (temp >> 16) & 65535;               result1 += temp & 65535;               result2 += (result1 >> 16) & 65535;               result1 &= 65535;               temp = unchecked(x1 * y0);  // b * c               result2 += (temp >> 16) & 65535;               result1 += temp & 65535;               result2 += (result1 >> 16) & 65535;               result1 &= 65535;               result3 = (result2 >> 16) & 65535;               result2 &= 65535;               temp = unchecked(x1 * y1);  // b * d               result3 += (temp >> 16) & 65535;               result2 += temp & 65535;               result3 += (result2 >> 16) & 65535;               result2 &= 65535;               // Add carry               x0 = unchecked((int)(result0 | (result1 << 16)));               x1 = unchecked((int)(result2 | (result3 << 16)));               int x2 = unchecked(x0 + carry);               if (((x2 >> 31) == (x0 >> 31)) ? ((x2 & Int32.MaxValue) < (x0 &               Int32.MaxValue)) : ((x2 >> 31) == 0)) {                 // Carry in addition                 x1 = unchecked(x1 + 1);               }               this.data[i] = x2;               carry = x1;             }           }           if (carry != 0) {             if (this.wordCount >= this.data.Length) {               var newdata = new int[this.wordCount + 20];               Array.Copy(this.data' 0' newdata' 0' this.data.Length);               this.data = newdata;             }             this.data[this.wordCount] = carry;             ++this.wordCount;           }           // Calculate the correct data length           while (this.wordCount != 0 && this.data[this.wordCount - 1] == 0) {             --this.wordCount;           }         } else {           if (this.data.Length > 0) {             this.data[0] = 0;           }           this.wordCount = 0;         }
Magic Number,PeterO.Cbor,MutableNumber,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\FastInteger2.cs,Multiply,The following statement contains a magic number: if (multiplicand != 0) {           var carry = 0;           if (this.wordCount == 0) {             if (this.data.Length == 0) {               this.data = new int[4];             }             this.data[0] = 0;             this.wordCount = 1;           }           int result0' result1' result2' result3;           if (multiplicand < 65536) {             for (var i = 0; i < this.wordCount; ++i) {               int x0 = this.data[i];               int x1 = x0;               int y0 = multiplicand;               x0 &= 65535;               x1 = (x1 >> 16) & 65535;               int temp = unchecked(x0 * y0);  // a * c               result1 = (temp >> 16) & 65535;               result0 = temp & 65535;               result2 = 0;               temp = unchecked(x1 * y0);  // b * c               result2 += (temp >> 16) & 65535;               result1 += temp & 65535;               result2 += (result1 >> 16) & 65535;               result1 &= 65535;               result3 = (result2 >> 16) & 65535;               result2 &= 65535;               // Add carry               x0 = unchecked((int)(result0 | (result1 << 16)));               x1 = unchecked((int)(result2 | (result3 << 16)));               int x2 = unchecked(x0 + carry);               if (((x2 >> 31) == (x0 >> 31)) ? ((x2 & Int32.MaxValue) < (x0 &               Int32.MaxValue)) : ((x2 >> 31) == 0)) {                 // Carry in addition                 x1 = unchecked(x1 + 1);               }               this.data[i] = x2;               carry = x1;             }           } else {             for (var i = 0; i < this.wordCount; ++i) {               int x0 = this.data[i];               int x1 = x0;               int y0 = multiplicand;               int y1 = y0;               x0 &= 65535;               y0 &= 65535;               x1 = (x1 >> 16) & 65535;               y1 = (y1 >> 16) & 65535;               int temp = unchecked(x0 * y0);  // a * c               result1 = (temp >> 16) & 65535;               result0 = temp & 65535;               temp = unchecked(x0 * y1);  // a * d               result2 = (temp >> 16) & 65535;               result1 += temp & 65535;               result2 += (result1 >> 16) & 65535;               result1 &= 65535;               temp = unchecked(x1 * y0);  // b * c               result2 += (temp >> 16) & 65535;               result1 += temp & 65535;               result2 += (result1 >> 16) & 65535;               result1 &= 65535;               result3 = (result2 >> 16) & 65535;               result2 &= 65535;               temp = unchecked(x1 * y1);  // b * d               result3 += (temp >> 16) & 65535;               result2 += temp & 65535;               result3 += (result2 >> 16) & 65535;               result2 &= 65535;               // Add carry               x0 = unchecked((int)(result0 | (result1 << 16)));               x1 = unchecked((int)(result2 | (result3 << 16)));               int x2 = unchecked(x0 + carry);               if (((x2 >> 31) == (x0 >> 31)) ? ((x2 & Int32.MaxValue) < (x0 &               Int32.MaxValue)) : ((x2 >> 31) == 0)) {                 // Carry in addition                 x1 = unchecked(x1 + 1);               }               this.data[i] = x2;               carry = x1;             }           }           if (carry != 0) {             if (this.wordCount >= this.data.Length) {               var newdata = new int[this.wordCount + 20];               Array.Copy(this.data' 0' newdata' 0' this.data.Length);               this.data = newdata;             }             this.data[this.wordCount] = carry;             ++this.wordCount;           }           // Calculate the correct data length           while (this.wordCount != 0 && this.data[this.wordCount - 1] == 0) {             --this.wordCount;           }         } else {           if (this.data.Length > 0) {             this.data[0] = 0;           }           this.wordCount = 0;         }
Magic Number,PeterO.Cbor,MutableNumber,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\FastInteger2.cs,Multiply,The following statement contains a magic number: if (multiplicand != 0) {           var carry = 0;           if (this.wordCount == 0) {             if (this.data.Length == 0) {               this.data = new int[4];             }             this.data[0] = 0;             this.wordCount = 1;           }           int result0' result1' result2' result3;           if (multiplicand < 65536) {             for (var i = 0; i < this.wordCount; ++i) {               int x0 = this.data[i];               int x1 = x0;               int y0 = multiplicand;               x0 &= 65535;               x1 = (x1 >> 16) & 65535;               int temp = unchecked(x0 * y0);  // a * c               result1 = (temp >> 16) & 65535;               result0 = temp & 65535;               result2 = 0;               temp = unchecked(x1 * y0);  // b * c               result2 += (temp >> 16) & 65535;               result1 += temp & 65535;               result2 += (result1 >> 16) & 65535;               result1 &= 65535;               result3 = (result2 >> 16) & 65535;               result2 &= 65535;               // Add carry               x0 = unchecked((int)(result0 | (result1 << 16)));               x1 = unchecked((int)(result2 | (result3 << 16)));               int x2 = unchecked(x0 + carry);               if (((x2 >> 31) == (x0 >> 31)) ? ((x2 & Int32.MaxValue) < (x0 &               Int32.MaxValue)) : ((x2 >> 31) == 0)) {                 // Carry in addition                 x1 = unchecked(x1 + 1);               }               this.data[i] = x2;               carry = x1;             }           } else {             for (var i = 0; i < this.wordCount; ++i) {               int x0 = this.data[i];               int x1 = x0;               int y0 = multiplicand;               int y1 = y0;               x0 &= 65535;               y0 &= 65535;               x1 = (x1 >> 16) & 65535;               y1 = (y1 >> 16) & 65535;               int temp = unchecked(x0 * y0);  // a * c               result1 = (temp >> 16) & 65535;               result0 = temp & 65535;               temp = unchecked(x0 * y1);  // a * d               result2 = (temp >> 16) & 65535;               result1 += temp & 65535;               result2 += (result1 >> 16) & 65535;               result1 &= 65535;               temp = unchecked(x1 * y0);  // b * c               result2 += (temp >> 16) & 65535;               result1 += temp & 65535;               result2 += (result1 >> 16) & 65535;               result1 &= 65535;               result3 = (result2 >> 16) & 65535;               result2 &= 65535;               temp = unchecked(x1 * y1);  // b * d               result3 += (temp >> 16) & 65535;               result2 += temp & 65535;               result3 += (result2 >> 16) & 65535;               result2 &= 65535;               // Add carry               x0 = unchecked((int)(result0 | (result1 << 16)));               x1 = unchecked((int)(result2 | (result3 << 16)));               int x2 = unchecked(x0 + carry);               if (((x2 >> 31) == (x0 >> 31)) ? ((x2 & Int32.MaxValue) < (x0 &               Int32.MaxValue)) : ((x2 >> 31) == 0)) {                 // Carry in addition                 x1 = unchecked(x1 + 1);               }               this.data[i] = x2;               carry = x1;             }           }           if (carry != 0) {             if (this.wordCount >= this.data.Length) {               var newdata = new int[this.wordCount + 20];               Array.Copy(this.data' 0' newdata' 0' this.data.Length);               this.data = newdata;             }             this.data[this.wordCount] = carry;             ++this.wordCount;           }           // Calculate the correct data length           while (this.wordCount != 0 && this.data[this.wordCount - 1] == 0) {             --this.wordCount;           }         } else {           if (this.data.Length > 0) {             this.data[0] = 0;           }           this.wordCount = 0;         }
Magic Number,PeterO.Cbor,MutableNumber,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\FastInteger2.cs,Multiply,The following statement contains a magic number: if (multiplicand != 0) {           var carry = 0;           if (this.wordCount == 0) {             if (this.data.Length == 0) {               this.data = new int[4];             }             this.data[0] = 0;             this.wordCount = 1;           }           int result0' result1' result2' result3;           if (multiplicand < 65536) {             for (var i = 0; i < this.wordCount; ++i) {               int x0 = this.data[i];               int x1 = x0;               int y0 = multiplicand;               x0 &= 65535;               x1 = (x1 >> 16) & 65535;               int temp = unchecked(x0 * y0);  // a * c               result1 = (temp >> 16) & 65535;               result0 = temp & 65535;               result2 = 0;               temp = unchecked(x1 * y0);  // b * c               result2 += (temp >> 16) & 65535;               result1 += temp & 65535;               result2 += (result1 >> 16) & 65535;               result1 &= 65535;               result3 = (result2 >> 16) & 65535;               result2 &= 65535;               // Add carry               x0 = unchecked((int)(result0 | (result1 << 16)));               x1 = unchecked((int)(result2 | (result3 << 16)));               int x2 = unchecked(x0 + carry);               if (((x2 >> 31) == (x0 >> 31)) ? ((x2 & Int32.MaxValue) < (x0 &               Int32.MaxValue)) : ((x2 >> 31) == 0)) {                 // Carry in addition                 x1 = unchecked(x1 + 1);               }               this.data[i] = x2;               carry = x1;             }           } else {             for (var i = 0; i < this.wordCount; ++i) {               int x0 = this.data[i];               int x1 = x0;               int y0 = multiplicand;               int y1 = y0;               x0 &= 65535;               y0 &= 65535;               x1 = (x1 >> 16) & 65535;               y1 = (y1 >> 16) & 65535;               int temp = unchecked(x0 * y0);  // a * c               result1 = (temp >> 16) & 65535;               result0 = temp & 65535;               temp = unchecked(x0 * y1);  // a * d               result2 = (temp >> 16) & 65535;               result1 += temp & 65535;               result2 += (result1 >> 16) & 65535;               result1 &= 65535;               temp = unchecked(x1 * y0);  // b * c               result2 += (temp >> 16) & 65535;               result1 += temp & 65535;               result2 += (result1 >> 16) & 65535;               result1 &= 65535;               result3 = (result2 >> 16) & 65535;               result2 &= 65535;               temp = unchecked(x1 * y1);  // b * d               result3 += (temp >> 16) & 65535;               result2 += temp & 65535;               result3 += (result2 >> 16) & 65535;               result2 &= 65535;               // Add carry               x0 = unchecked((int)(result0 | (result1 << 16)));               x1 = unchecked((int)(result2 | (result3 << 16)));               int x2 = unchecked(x0 + carry);               if (((x2 >> 31) == (x0 >> 31)) ? ((x2 & Int32.MaxValue) < (x0 &               Int32.MaxValue)) : ((x2 >> 31) == 0)) {                 // Carry in addition                 x1 = unchecked(x1 + 1);               }               this.data[i] = x2;               carry = x1;             }           }           if (carry != 0) {             if (this.wordCount >= this.data.Length) {               var newdata = new int[this.wordCount + 20];               Array.Copy(this.data' 0' newdata' 0' this.data.Length);               this.data = newdata;             }             this.data[this.wordCount] = carry;             ++this.wordCount;           }           // Calculate the correct data length           while (this.wordCount != 0 && this.data[this.wordCount - 1] == 0) {             --this.wordCount;           }         } else {           if (this.data.Length > 0) {             this.data[0] = 0;           }           this.wordCount = 0;         }
Magic Number,PeterO.Cbor,MutableNumber,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\FastInteger2.cs,Multiply,The following statement contains a magic number: if (multiplicand != 0) {           var carry = 0;           if (this.wordCount == 0) {             if (this.data.Length == 0) {               this.data = new int[4];             }             this.data[0] = 0;             this.wordCount = 1;           }           int result0' result1' result2' result3;           if (multiplicand < 65536) {             for (var i = 0; i < this.wordCount; ++i) {               int x0 = this.data[i];               int x1 = x0;               int y0 = multiplicand;               x0 &= 65535;               x1 = (x1 >> 16) & 65535;               int temp = unchecked(x0 * y0);  // a * c               result1 = (temp >> 16) & 65535;               result0 = temp & 65535;               result2 = 0;               temp = unchecked(x1 * y0);  // b * c               result2 += (temp >> 16) & 65535;               result1 += temp & 65535;               result2 += (result1 >> 16) & 65535;               result1 &= 65535;               result3 = (result2 >> 16) & 65535;               result2 &= 65535;               // Add carry               x0 = unchecked((int)(result0 | (result1 << 16)));               x1 = unchecked((int)(result2 | (result3 << 16)));               int x2 = unchecked(x0 + carry);               if (((x2 >> 31) == (x0 >> 31)) ? ((x2 & Int32.MaxValue) < (x0 &               Int32.MaxValue)) : ((x2 >> 31) == 0)) {                 // Carry in addition                 x1 = unchecked(x1 + 1);               }               this.data[i] = x2;               carry = x1;             }           } else {             for (var i = 0; i < this.wordCount; ++i) {               int x0 = this.data[i];               int x1 = x0;               int y0 = multiplicand;               int y1 = y0;               x0 &= 65535;               y0 &= 65535;               x1 = (x1 >> 16) & 65535;               y1 = (y1 >> 16) & 65535;               int temp = unchecked(x0 * y0);  // a * c               result1 = (temp >> 16) & 65535;               result0 = temp & 65535;               temp = unchecked(x0 * y1);  // a * d               result2 = (temp >> 16) & 65535;               result1 += temp & 65535;               result2 += (result1 >> 16) & 65535;               result1 &= 65535;               temp = unchecked(x1 * y0);  // b * c               result2 += (temp >> 16) & 65535;               result1 += temp & 65535;               result2 += (result1 >> 16) & 65535;               result1 &= 65535;               result3 = (result2 >> 16) & 65535;               result2 &= 65535;               temp = unchecked(x1 * y1);  // b * d               result3 += (temp >> 16) & 65535;               result2 += temp & 65535;               result3 += (result2 >> 16) & 65535;               result2 &= 65535;               // Add carry               x0 = unchecked((int)(result0 | (result1 << 16)));               x1 = unchecked((int)(result2 | (result3 << 16)));               int x2 = unchecked(x0 + carry);               if (((x2 >> 31) == (x0 >> 31)) ? ((x2 & Int32.MaxValue) < (x0 &               Int32.MaxValue)) : ((x2 >> 31) == 0)) {                 // Carry in addition                 x1 = unchecked(x1 + 1);               }               this.data[i] = x2;               carry = x1;             }           }           if (carry != 0) {             if (this.wordCount >= this.data.Length) {               var newdata = new int[this.wordCount + 20];               Array.Copy(this.data' 0' newdata' 0' this.data.Length);               this.data = newdata;             }             this.data[this.wordCount] = carry;             ++this.wordCount;           }           // Calculate the correct data length           while (this.wordCount != 0 && this.data[this.wordCount - 1] == 0) {             --this.wordCount;           }         } else {           if (this.data.Length > 0) {             this.data[0] = 0;           }           this.wordCount = 0;         }
Magic Number,PeterO.Cbor,MutableNumber,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\FastInteger2.cs,Multiply,The following statement contains a magic number: if (multiplicand != 0) {           var carry = 0;           if (this.wordCount == 0) {             if (this.data.Length == 0) {               this.data = new int[4];             }             this.data[0] = 0;             this.wordCount = 1;           }           int result0' result1' result2' result3;           if (multiplicand < 65536) {             for (var i = 0; i < this.wordCount; ++i) {               int x0 = this.data[i];               int x1 = x0;               int y0 = multiplicand;               x0 &= 65535;               x1 = (x1 >> 16) & 65535;               int temp = unchecked(x0 * y0);  // a * c               result1 = (temp >> 16) & 65535;               result0 = temp & 65535;               result2 = 0;               temp = unchecked(x1 * y0);  // b * c               result2 += (temp >> 16) & 65535;               result1 += temp & 65535;               result2 += (result1 >> 16) & 65535;               result1 &= 65535;               result3 = (result2 >> 16) & 65535;               result2 &= 65535;               // Add carry               x0 = unchecked((int)(result0 | (result1 << 16)));               x1 = unchecked((int)(result2 | (result3 << 16)));               int x2 = unchecked(x0 + carry);               if (((x2 >> 31) == (x0 >> 31)) ? ((x2 & Int32.MaxValue) < (x0 &               Int32.MaxValue)) : ((x2 >> 31) == 0)) {                 // Carry in addition                 x1 = unchecked(x1 + 1);               }               this.data[i] = x2;               carry = x1;             }           } else {             for (var i = 0; i < this.wordCount; ++i) {               int x0 = this.data[i];               int x1 = x0;               int y0 = multiplicand;               int y1 = y0;               x0 &= 65535;               y0 &= 65535;               x1 = (x1 >> 16) & 65535;               y1 = (y1 >> 16) & 65535;               int temp = unchecked(x0 * y0);  // a * c               result1 = (temp >> 16) & 65535;               result0 = temp & 65535;               temp = unchecked(x0 * y1);  // a * d               result2 = (temp >> 16) & 65535;               result1 += temp & 65535;               result2 += (result1 >> 16) & 65535;               result1 &= 65535;               temp = unchecked(x1 * y0);  // b * c               result2 += (temp >> 16) & 65535;               result1 += temp & 65535;               result2 += (result1 >> 16) & 65535;               result1 &= 65535;               result3 = (result2 >> 16) & 65535;               result2 &= 65535;               temp = unchecked(x1 * y1);  // b * d               result3 += (temp >> 16) & 65535;               result2 += temp & 65535;               result3 += (result2 >> 16) & 65535;               result2 &= 65535;               // Add carry               x0 = unchecked((int)(result0 | (result1 << 16)));               x1 = unchecked((int)(result2 | (result3 << 16)));               int x2 = unchecked(x0 + carry);               if (((x2 >> 31) == (x0 >> 31)) ? ((x2 & Int32.MaxValue) < (x0 &               Int32.MaxValue)) : ((x2 >> 31) == 0)) {                 // Carry in addition                 x1 = unchecked(x1 + 1);               }               this.data[i] = x2;               carry = x1;             }           }           if (carry != 0) {             if (this.wordCount >= this.data.Length) {               var newdata = new int[this.wordCount + 20];               Array.Copy(this.data' 0' newdata' 0' this.data.Length);               this.data = newdata;             }             this.data[this.wordCount] = carry;             ++this.wordCount;           }           // Calculate the correct data length           while (this.wordCount != 0 && this.data[this.wordCount - 1] == 0) {             --this.wordCount;           }         } else {           if (this.data.Length > 0) {             this.data[0] = 0;           }           this.wordCount = 0;         }
Magic Number,PeterO.Cbor,MutableNumber,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\FastInteger2.cs,Multiply,The following statement contains a magic number: if (multiplicand != 0) {           var carry = 0;           if (this.wordCount == 0) {             if (this.data.Length == 0) {               this.data = new int[4];             }             this.data[0] = 0;             this.wordCount = 1;           }           int result0' result1' result2' result3;           if (multiplicand < 65536) {             for (var i = 0; i < this.wordCount; ++i) {               int x0 = this.data[i];               int x1 = x0;               int y0 = multiplicand;               x0 &= 65535;               x1 = (x1 >> 16) & 65535;               int temp = unchecked(x0 * y0);  // a * c               result1 = (temp >> 16) & 65535;               result0 = temp & 65535;               result2 = 0;               temp = unchecked(x1 * y0);  // b * c               result2 += (temp >> 16) & 65535;               result1 += temp & 65535;               result2 += (result1 >> 16) & 65535;               result1 &= 65535;               result3 = (result2 >> 16) & 65535;               result2 &= 65535;               // Add carry               x0 = unchecked((int)(result0 | (result1 << 16)));               x1 = unchecked((int)(result2 | (result3 << 16)));               int x2 = unchecked(x0 + carry);               if (((x2 >> 31) == (x0 >> 31)) ? ((x2 & Int32.MaxValue) < (x0 &               Int32.MaxValue)) : ((x2 >> 31) == 0)) {                 // Carry in addition                 x1 = unchecked(x1 + 1);               }               this.data[i] = x2;               carry = x1;             }           } else {             for (var i = 0; i < this.wordCount; ++i) {               int x0 = this.data[i];               int x1 = x0;               int y0 = multiplicand;               int y1 = y0;               x0 &= 65535;               y0 &= 65535;               x1 = (x1 >> 16) & 65535;               y1 = (y1 >> 16) & 65535;               int temp = unchecked(x0 * y0);  // a * c               result1 = (temp >> 16) & 65535;               result0 = temp & 65535;               temp = unchecked(x0 * y1);  // a * d               result2 = (temp >> 16) & 65535;               result1 += temp & 65535;               result2 += (result1 >> 16) & 65535;               result1 &= 65535;               temp = unchecked(x1 * y0);  // b * c               result2 += (temp >> 16) & 65535;               result1 += temp & 65535;               result2 += (result1 >> 16) & 65535;               result1 &= 65535;               result3 = (result2 >> 16) & 65535;               result2 &= 65535;               temp = unchecked(x1 * y1);  // b * d               result3 += (temp >> 16) & 65535;               result2 += temp & 65535;               result3 += (result2 >> 16) & 65535;               result2 &= 65535;               // Add carry               x0 = unchecked((int)(result0 | (result1 << 16)));               x1 = unchecked((int)(result2 | (result3 << 16)));               int x2 = unchecked(x0 + carry);               if (((x2 >> 31) == (x0 >> 31)) ? ((x2 & Int32.MaxValue) < (x0 &               Int32.MaxValue)) : ((x2 >> 31) == 0)) {                 // Carry in addition                 x1 = unchecked(x1 + 1);               }               this.data[i] = x2;               carry = x1;             }           }           if (carry != 0) {             if (this.wordCount >= this.data.Length) {               var newdata = new int[this.wordCount + 20];               Array.Copy(this.data' 0' newdata' 0' this.data.Length);               this.data = newdata;             }             this.data[this.wordCount] = carry;             ++this.wordCount;           }           // Calculate the correct data length           while (this.wordCount != 0 && this.data[this.wordCount - 1] == 0) {             --this.wordCount;           }         } else {           if (this.data.Length > 0) {             this.data[0] = 0;           }           this.wordCount = 0;         }
Magic Number,PeterO.Cbor,MutableNumber,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\FastInteger2.cs,Multiply,The following statement contains a magic number: if (multiplicand != 0) {           var carry = 0;           if (this.wordCount == 0) {             if (this.data.Length == 0) {               this.data = new int[4];             }             this.data[0] = 0;             this.wordCount = 1;           }           int result0' result1' result2' result3;           if (multiplicand < 65536) {             for (var i = 0; i < this.wordCount; ++i) {               int x0 = this.data[i];               int x1 = x0;               int y0 = multiplicand;               x0 &= 65535;               x1 = (x1 >> 16) & 65535;               int temp = unchecked(x0 * y0);  // a * c               result1 = (temp >> 16) & 65535;               result0 = temp & 65535;               result2 = 0;               temp = unchecked(x1 * y0);  // b * c               result2 += (temp >> 16) & 65535;               result1 += temp & 65535;               result2 += (result1 >> 16) & 65535;               result1 &= 65535;               result3 = (result2 >> 16) & 65535;               result2 &= 65535;               // Add carry               x0 = unchecked((int)(result0 | (result1 << 16)));               x1 = unchecked((int)(result2 | (result3 << 16)));               int x2 = unchecked(x0 + carry);               if (((x2 >> 31) == (x0 >> 31)) ? ((x2 & Int32.MaxValue) < (x0 &               Int32.MaxValue)) : ((x2 >> 31) == 0)) {                 // Carry in addition                 x1 = unchecked(x1 + 1);               }               this.data[i] = x2;               carry = x1;             }           } else {             for (var i = 0; i < this.wordCount; ++i) {               int x0 = this.data[i];               int x1 = x0;               int y0 = multiplicand;               int y1 = y0;               x0 &= 65535;               y0 &= 65535;               x1 = (x1 >> 16) & 65535;               y1 = (y1 >> 16) & 65535;               int temp = unchecked(x0 * y0);  // a * c               result1 = (temp >> 16) & 65535;               result0 = temp & 65535;               temp = unchecked(x0 * y1);  // a * d               result2 = (temp >> 16) & 65535;               result1 += temp & 65535;               result2 += (result1 >> 16) & 65535;               result1 &= 65535;               temp = unchecked(x1 * y0);  // b * c               result2 += (temp >> 16) & 65535;               result1 += temp & 65535;               result2 += (result1 >> 16) & 65535;               result1 &= 65535;               result3 = (result2 >> 16) & 65535;               result2 &= 65535;               temp = unchecked(x1 * y1);  // b * d               result3 += (temp >> 16) & 65535;               result2 += temp & 65535;               result3 += (result2 >> 16) & 65535;               result2 &= 65535;               // Add carry               x0 = unchecked((int)(result0 | (result1 << 16)));               x1 = unchecked((int)(result2 | (result3 << 16)));               int x2 = unchecked(x0 + carry);               if (((x2 >> 31) == (x0 >> 31)) ? ((x2 & Int32.MaxValue) < (x0 &               Int32.MaxValue)) : ((x2 >> 31) == 0)) {                 // Carry in addition                 x1 = unchecked(x1 + 1);               }               this.data[i] = x2;               carry = x1;             }           }           if (carry != 0) {             if (this.wordCount >= this.data.Length) {               var newdata = new int[this.wordCount + 20];               Array.Copy(this.data' 0' newdata' 0' this.data.Length);               this.data = newdata;             }             this.data[this.wordCount] = carry;             ++this.wordCount;           }           // Calculate the correct data length           while (this.wordCount != 0 && this.data[this.wordCount - 1] == 0) {             --this.wordCount;           }         } else {           if (this.data.Length > 0) {             this.data[0] = 0;           }           this.wordCount = 0;         }
Magic Number,PeterO.Cbor,MutableNumber,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\FastInteger2.cs,Multiply,The following statement contains a magic number: if (multiplicand != 0) {           var carry = 0;           if (this.wordCount == 0) {             if (this.data.Length == 0) {               this.data = new int[4];             }             this.data[0] = 0;             this.wordCount = 1;           }           int result0' result1' result2' result3;           if (multiplicand < 65536) {             for (var i = 0; i < this.wordCount; ++i) {               int x0 = this.data[i];               int x1 = x0;               int y0 = multiplicand;               x0 &= 65535;               x1 = (x1 >> 16) & 65535;               int temp = unchecked(x0 * y0);  // a * c               result1 = (temp >> 16) & 65535;               result0 = temp & 65535;               result2 = 0;               temp = unchecked(x1 * y0);  // b * c               result2 += (temp >> 16) & 65535;               result1 += temp & 65535;               result2 += (result1 >> 16) & 65535;               result1 &= 65535;               result3 = (result2 >> 16) & 65535;               result2 &= 65535;               // Add carry               x0 = unchecked((int)(result0 | (result1 << 16)));               x1 = unchecked((int)(result2 | (result3 << 16)));               int x2 = unchecked(x0 + carry);               if (((x2 >> 31) == (x0 >> 31)) ? ((x2 & Int32.MaxValue) < (x0 &               Int32.MaxValue)) : ((x2 >> 31) == 0)) {                 // Carry in addition                 x1 = unchecked(x1 + 1);               }               this.data[i] = x2;               carry = x1;             }           } else {             for (var i = 0; i < this.wordCount; ++i) {               int x0 = this.data[i];               int x1 = x0;               int y0 = multiplicand;               int y1 = y0;               x0 &= 65535;               y0 &= 65535;               x1 = (x1 >> 16) & 65535;               y1 = (y1 >> 16) & 65535;               int temp = unchecked(x0 * y0);  // a * c               result1 = (temp >> 16) & 65535;               result0 = temp & 65535;               temp = unchecked(x0 * y1);  // a * d               result2 = (temp >> 16) & 65535;               result1 += temp & 65535;               result2 += (result1 >> 16) & 65535;               result1 &= 65535;               temp = unchecked(x1 * y0);  // b * c               result2 += (temp >> 16) & 65535;               result1 += temp & 65535;               result2 += (result1 >> 16) & 65535;               result1 &= 65535;               result3 = (result2 >> 16) & 65535;               result2 &= 65535;               temp = unchecked(x1 * y1);  // b * d               result3 += (temp >> 16) & 65535;               result2 += temp & 65535;               result3 += (result2 >> 16) & 65535;               result2 &= 65535;               // Add carry               x0 = unchecked((int)(result0 | (result1 << 16)));               x1 = unchecked((int)(result2 | (result3 << 16)));               int x2 = unchecked(x0 + carry);               if (((x2 >> 31) == (x0 >> 31)) ? ((x2 & Int32.MaxValue) < (x0 &               Int32.MaxValue)) : ((x2 >> 31) == 0)) {                 // Carry in addition                 x1 = unchecked(x1 + 1);               }               this.data[i] = x2;               carry = x1;             }           }           if (carry != 0) {             if (this.wordCount >= this.data.Length) {               var newdata = new int[this.wordCount + 20];               Array.Copy(this.data' 0' newdata' 0' this.data.Length);               this.data = newdata;             }             this.data[this.wordCount] = carry;             ++this.wordCount;           }           // Calculate the correct data length           while (this.wordCount != 0 && this.data[this.wordCount - 1] == 0) {             --this.wordCount;           }         } else {           if (this.data.Length > 0) {             this.data[0] = 0;           }           this.wordCount = 0;         }
Magic Number,PeterO.Cbor,MutableNumber,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\FastInteger2.cs,Multiply,The following statement contains a magic number: if (multiplicand != 0) {           var carry = 0;           if (this.wordCount == 0) {             if (this.data.Length == 0) {               this.data = new int[4];             }             this.data[0] = 0;             this.wordCount = 1;           }           int result0' result1' result2' result3;           if (multiplicand < 65536) {             for (var i = 0; i < this.wordCount; ++i) {               int x0 = this.data[i];               int x1 = x0;               int y0 = multiplicand;               x0 &= 65535;               x1 = (x1 >> 16) & 65535;               int temp = unchecked(x0 * y0);  // a * c               result1 = (temp >> 16) & 65535;               result0 = temp & 65535;               result2 = 0;               temp = unchecked(x1 * y0);  // b * c               result2 += (temp >> 16) & 65535;               result1 += temp & 65535;               result2 += (result1 >> 16) & 65535;               result1 &= 65535;               result3 = (result2 >> 16) & 65535;               result2 &= 65535;               // Add carry               x0 = unchecked((int)(result0 | (result1 << 16)));               x1 = unchecked((int)(result2 | (result3 << 16)));               int x2 = unchecked(x0 + carry);               if (((x2 >> 31) == (x0 >> 31)) ? ((x2 & Int32.MaxValue) < (x0 &               Int32.MaxValue)) : ((x2 >> 31) == 0)) {                 // Carry in addition                 x1 = unchecked(x1 + 1);               }               this.data[i] = x2;               carry = x1;             }           } else {             for (var i = 0; i < this.wordCount; ++i) {               int x0 = this.data[i];               int x1 = x0;               int y0 = multiplicand;               int y1 = y0;               x0 &= 65535;               y0 &= 65535;               x1 = (x1 >> 16) & 65535;               y1 = (y1 >> 16) & 65535;               int temp = unchecked(x0 * y0);  // a * c               result1 = (temp >> 16) & 65535;               result0 = temp & 65535;               temp = unchecked(x0 * y1);  // a * d               result2 = (temp >> 16) & 65535;               result1 += temp & 65535;               result2 += (result1 >> 16) & 65535;               result1 &= 65535;               temp = unchecked(x1 * y0);  // b * c               result2 += (temp >> 16) & 65535;               result1 += temp & 65535;               result2 += (result1 >> 16) & 65535;               result1 &= 65535;               result3 = (result2 >> 16) & 65535;               result2 &= 65535;               temp = unchecked(x1 * y1);  // b * d               result3 += (temp >> 16) & 65535;               result2 += temp & 65535;               result3 += (result2 >> 16) & 65535;               result2 &= 65535;               // Add carry               x0 = unchecked((int)(result0 | (result1 << 16)));               x1 = unchecked((int)(result2 | (result3 << 16)));               int x2 = unchecked(x0 + carry);               if (((x2 >> 31) == (x0 >> 31)) ? ((x2 & Int32.MaxValue) < (x0 &               Int32.MaxValue)) : ((x2 >> 31) == 0)) {                 // Carry in addition                 x1 = unchecked(x1 + 1);               }               this.data[i] = x2;               carry = x1;             }           }           if (carry != 0) {             if (this.wordCount >= this.data.Length) {               var newdata = new int[this.wordCount + 20];               Array.Copy(this.data' 0' newdata' 0' this.data.Length);               this.data = newdata;             }             this.data[this.wordCount] = carry;             ++this.wordCount;           }           // Calculate the correct data length           while (this.wordCount != 0 && this.data[this.wordCount - 1] == 0) {             --this.wordCount;           }         } else {           if (this.data.Length > 0) {             this.data[0] = 0;           }           this.wordCount = 0;         }
Magic Number,PeterO.Cbor,MutableNumber,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\FastInteger2.cs,Multiply,The following statement contains a magic number: if (multiplicand != 0) {           var carry = 0;           if (this.wordCount == 0) {             if (this.data.Length == 0) {               this.data = new int[4];             }             this.data[0] = 0;             this.wordCount = 1;           }           int result0' result1' result2' result3;           if (multiplicand < 65536) {             for (var i = 0; i < this.wordCount; ++i) {               int x0 = this.data[i];               int x1 = x0;               int y0 = multiplicand;               x0 &= 65535;               x1 = (x1 >> 16) & 65535;               int temp = unchecked(x0 * y0);  // a * c               result1 = (temp >> 16) & 65535;               result0 = temp & 65535;               result2 = 0;               temp = unchecked(x1 * y0);  // b * c               result2 += (temp >> 16) & 65535;               result1 += temp & 65535;               result2 += (result1 >> 16) & 65535;               result1 &= 65535;               result3 = (result2 >> 16) & 65535;               result2 &= 65535;               // Add carry               x0 = unchecked((int)(result0 | (result1 << 16)));               x1 = unchecked((int)(result2 | (result3 << 16)));               int x2 = unchecked(x0 + carry);               if (((x2 >> 31) == (x0 >> 31)) ? ((x2 & Int32.MaxValue) < (x0 &               Int32.MaxValue)) : ((x2 >> 31) == 0)) {                 // Carry in addition                 x1 = unchecked(x1 + 1);               }               this.data[i] = x2;               carry = x1;             }           } else {             for (var i = 0; i < this.wordCount; ++i) {               int x0 = this.data[i];               int x1 = x0;               int y0 = multiplicand;               int y1 = y0;               x0 &= 65535;               y0 &= 65535;               x1 = (x1 >> 16) & 65535;               y1 = (y1 >> 16) & 65535;               int temp = unchecked(x0 * y0);  // a * c               result1 = (temp >> 16) & 65535;               result0 = temp & 65535;               temp = unchecked(x0 * y1);  // a * d               result2 = (temp >> 16) & 65535;               result1 += temp & 65535;               result2 += (result1 >> 16) & 65535;               result1 &= 65535;               temp = unchecked(x1 * y0);  // b * c               result2 += (temp >> 16) & 65535;               result1 += temp & 65535;               result2 += (result1 >> 16) & 65535;               result1 &= 65535;               result3 = (result2 >> 16) & 65535;               result2 &= 65535;               temp = unchecked(x1 * y1);  // b * d               result3 += (temp >> 16) & 65535;               result2 += temp & 65535;               result3 += (result2 >> 16) & 65535;               result2 &= 65535;               // Add carry               x0 = unchecked((int)(result0 | (result1 << 16)));               x1 = unchecked((int)(result2 | (result3 << 16)));               int x2 = unchecked(x0 + carry);               if (((x2 >> 31) == (x0 >> 31)) ? ((x2 & Int32.MaxValue) < (x0 &               Int32.MaxValue)) : ((x2 >> 31) == 0)) {                 // Carry in addition                 x1 = unchecked(x1 + 1);               }               this.data[i] = x2;               carry = x1;             }           }           if (carry != 0) {             if (this.wordCount >= this.data.Length) {               var newdata = new int[this.wordCount + 20];               Array.Copy(this.data' 0' newdata' 0' this.data.Length);               this.data = newdata;             }             this.data[this.wordCount] = carry;             ++this.wordCount;           }           // Calculate the correct data length           while (this.wordCount != 0 && this.data[this.wordCount - 1] == 0) {             --this.wordCount;           }         } else {           if (this.data.Length > 0) {             this.data[0] = 0;           }           this.wordCount = 0;         }
Magic Number,PeterO.Cbor,MutableNumber,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\FastInteger2.cs,Multiply,The following statement contains a magic number: if (multiplicand != 0) {           var carry = 0;           if (this.wordCount == 0) {             if (this.data.Length == 0) {               this.data = new int[4];             }             this.data[0] = 0;             this.wordCount = 1;           }           int result0' result1' result2' result3;           if (multiplicand < 65536) {             for (var i = 0; i < this.wordCount; ++i) {               int x0 = this.data[i];               int x1 = x0;               int y0 = multiplicand;               x0 &= 65535;               x1 = (x1 >> 16) & 65535;               int temp = unchecked(x0 * y0);  // a * c               result1 = (temp >> 16) & 65535;               result0 = temp & 65535;               result2 = 0;               temp = unchecked(x1 * y0);  // b * c               result2 += (temp >> 16) & 65535;               result1 += temp & 65535;               result2 += (result1 >> 16) & 65535;               result1 &= 65535;               result3 = (result2 >> 16) & 65535;               result2 &= 65535;               // Add carry               x0 = unchecked((int)(result0 | (result1 << 16)));               x1 = unchecked((int)(result2 | (result3 << 16)));               int x2 = unchecked(x0 + carry);               if (((x2 >> 31) == (x0 >> 31)) ? ((x2 & Int32.MaxValue) < (x0 &               Int32.MaxValue)) : ((x2 >> 31) == 0)) {                 // Carry in addition                 x1 = unchecked(x1 + 1);               }               this.data[i] = x2;               carry = x1;             }           } else {             for (var i = 0; i < this.wordCount; ++i) {               int x0 = this.data[i];               int x1 = x0;               int y0 = multiplicand;               int y1 = y0;               x0 &= 65535;               y0 &= 65535;               x1 = (x1 >> 16) & 65535;               y1 = (y1 >> 16) & 65535;               int temp = unchecked(x0 * y0);  // a * c               result1 = (temp >> 16) & 65535;               result0 = temp & 65535;               temp = unchecked(x0 * y1);  // a * d               result2 = (temp >> 16) & 65535;               result1 += temp & 65535;               result2 += (result1 >> 16) & 65535;               result1 &= 65535;               temp = unchecked(x1 * y0);  // b * c               result2 += (temp >> 16) & 65535;               result1 += temp & 65535;               result2 += (result1 >> 16) & 65535;               result1 &= 65535;               result3 = (result2 >> 16) & 65535;               result2 &= 65535;               temp = unchecked(x1 * y1);  // b * d               result3 += (temp >> 16) & 65535;               result2 += temp & 65535;               result3 += (result2 >> 16) & 65535;               result2 &= 65535;               // Add carry               x0 = unchecked((int)(result0 | (result1 << 16)));               x1 = unchecked((int)(result2 | (result3 << 16)));               int x2 = unchecked(x0 + carry);               if (((x2 >> 31) == (x0 >> 31)) ? ((x2 & Int32.MaxValue) < (x0 &               Int32.MaxValue)) : ((x2 >> 31) == 0)) {                 // Carry in addition                 x1 = unchecked(x1 + 1);               }               this.data[i] = x2;               carry = x1;             }           }           if (carry != 0) {             if (this.wordCount >= this.data.Length) {               var newdata = new int[this.wordCount + 20];               Array.Copy(this.data' 0' newdata' 0' this.data.Length);               this.data = newdata;             }             this.data[this.wordCount] = carry;             ++this.wordCount;           }           // Calculate the correct data length           while (this.wordCount != 0 && this.data[this.wordCount - 1] == 0) {             --this.wordCount;           }         } else {           if (this.data.Length > 0) {             this.data[0] = 0;           }           this.wordCount = 0;         }
Magic Number,PeterO.Cbor,MutableNumber,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\FastInteger2.cs,Multiply,The following statement contains a magic number: if (multiplicand != 0) {           var carry = 0;           if (this.wordCount == 0) {             if (this.data.Length == 0) {               this.data = new int[4];             }             this.data[0] = 0;             this.wordCount = 1;           }           int result0' result1' result2' result3;           if (multiplicand < 65536) {             for (var i = 0; i < this.wordCount; ++i) {               int x0 = this.data[i];               int x1 = x0;               int y0 = multiplicand;               x0 &= 65535;               x1 = (x1 >> 16) & 65535;               int temp = unchecked(x0 * y0);  // a * c               result1 = (temp >> 16) & 65535;               result0 = temp & 65535;               result2 = 0;               temp = unchecked(x1 * y0);  // b * c               result2 += (temp >> 16) & 65535;               result1 += temp & 65535;               result2 += (result1 >> 16) & 65535;               result1 &= 65535;               result3 = (result2 >> 16) & 65535;               result2 &= 65535;               // Add carry               x0 = unchecked((int)(result0 | (result1 << 16)));               x1 = unchecked((int)(result2 | (result3 << 16)));               int x2 = unchecked(x0 + carry);               if (((x2 >> 31) == (x0 >> 31)) ? ((x2 & Int32.MaxValue) < (x0 &               Int32.MaxValue)) : ((x2 >> 31) == 0)) {                 // Carry in addition                 x1 = unchecked(x1 + 1);               }               this.data[i] = x2;               carry = x1;             }           } else {             for (var i = 0; i < this.wordCount; ++i) {               int x0 = this.data[i];               int x1 = x0;               int y0 = multiplicand;               int y1 = y0;               x0 &= 65535;               y0 &= 65535;               x1 = (x1 >> 16) & 65535;               y1 = (y1 >> 16) & 65535;               int temp = unchecked(x0 * y0);  // a * c               result1 = (temp >> 16) & 65535;               result0 = temp & 65535;               temp = unchecked(x0 * y1);  // a * d               result2 = (temp >> 16) & 65535;               result1 += temp & 65535;               result2 += (result1 >> 16) & 65535;               result1 &= 65535;               temp = unchecked(x1 * y0);  // b * c               result2 += (temp >> 16) & 65535;               result1 += temp & 65535;               result2 += (result1 >> 16) & 65535;               result1 &= 65535;               result3 = (result2 >> 16) & 65535;               result2 &= 65535;               temp = unchecked(x1 * y1);  // b * d               result3 += (temp >> 16) & 65535;               result2 += temp & 65535;               result3 += (result2 >> 16) & 65535;               result2 &= 65535;               // Add carry               x0 = unchecked((int)(result0 | (result1 << 16)));               x1 = unchecked((int)(result2 | (result3 << 16)));               int x2 = unchecked(x0 + carry);               if (((x2 >> 31) == (x0 >> 31)) ? ((x2 & Int32.MaxValue) < (x0 &               Int32.MaxValue)) : ((x2 >> 31) == 0)) {                 // Carry in addition                 x1 = unchecked(x1 + 1);               }               this.data[i] = x2;               carry = x1;             }           }           if (carry != 0) {             if (this.wordCount >= this.data.Length) {               var newdata = new int[this.wordCount + 20];               Array.Copy(this.data' 0' newdata' 0' this.data.Length);               this.data = newdata;             }             this.data[this.wordCount] = carry;             ++this.wordCount;           }           // Calculate the correct data length           while (this.wordCount != 0 && this.data[this.wordCount - 1] == 0) {             --this.wordCount;           }         } else {           if (this.data.Length > 0) {             this.data[0] = 0;           }           this.wordCount = 0;         }
Magic Number,PeterO.Cbor,MutableNumber,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\FastInteger2.cs,Multiply,The following statement contains a magic number: if (multiplicand != 0) {           var carry = 0;           if (this.wordCount == 0) {             if (this.data.Length == 0) {               this.data = new int[4];             }             this.data[0] = 0;             this.wordCount = 1;           }           int result0' result1' result2' result3;           if (multiplicand < 65536) {             for (var i = 0; i < this.wordCount; ++i) {               int x0 = this.data[i];               int x1 = x0;               int y0 = multiplicand;               x0 &= 65535;               x1 = (x1 >> 16) & 65535;               int temp = unchecked(x0 * y0);  // a * c               result1 = (temp >> 16) & 65535;               result0 = temp & 65535;               result2 = 0;               temp = unchecked(x1 * y0);  // b * c               result2 += (temp >> 16) & 65535;               result1 += temp & 65535;               result2 += (result1 >> 16) & 65535;               result1 &= 65535;               result3 = (result2 >> 16) & 65535;               result2 &= 65535;               // Add carry               x0 = unchecked((int)(result0 | (result1 << 16)));               x1 = unchecked((int)(result2 | (result3 << 16)));               int x2 = unchecked(x0 + carry);               if (((x2 >> 31) == (x0 >> 31)) ? ((x2 & Int32.MaxValue) < (x0 &               Int32.MaxValue)) : ((x2 >> 31) == 0)) {                 // Carry in addition                 x1 = unchecked(x1 + 1);               }               this.data[i] = x2;               carry = x1;             }           } else {             for (var i = 0; i < this.wordCount; ++i) {               int x0 = this.data[i];               int x1 = x0;               int y0 = multiplicand;               int y1 = y0;               x0 &= 65535;               y0 &= 65535;               x1 = (x1 >> 16) & 65535;               y1 = (y1 >> 16) & 65535;               int temp = unchecked(x0 * y0);  // a * c               result1 = (temp >> 16) & 65535;               result0 = temp & 65535;               temp = unchecked(x0 * y1);  // a * d               result2 = (temp >> 16) & 65535;               result1 += temp & 65535;               result2 += (result1 >> 16) & 65535;               result1 &= 65535;               temp = unchecked(x1 * y0);  // b * c               result2 += (temp >> 16) & 65535;               result1 += temp & 65535;               result2 += (result1 >> 16) & 65535;               result1 &= 65535;               result3 = (result2 >> 16) & 65535;               result2 &= 65535;               temp = unchecked(x1 * y1);  // b * d               result3 += (temp >> 16) & 65535;               result2 += temp & 65535;               result3 += (result2 >> 16) & 65535;               result2 &= 65535;               // Add carry               x0 = unchecked((int)(result0 | (result1 << 16)));               x1 = unchecked((int)(result2 | (result3 << 16)));               int x2 = unchecked(x0 + carry);               if (((x2 >> 31) == (x0 >> 31)) ? ((x2 & Int32.MaxValue) < (x0 &               Int32.MaxValue)) : ((x2 >> 31) == 0)) {                 // Carry in addition                 x1 = unchecked(x1 + 1);               }               this.data[i] = x2;               carry = x1;             }           }           if (carry != 0) {             if (this.wordCount >= this.data.Length) {               var newdata = new int[this.wordCount + 20];               Array.Copy(this.data' 0' newdata' 0' this.data.Length);               this.data = newdata;             }             this.data[this.wordCount] = carry;             ++this.wordCount;           }           // Calculate the correct data length           while (this.wordCount != 0 && this.data[this.wordCount - 1] == 0) {             --this.wordCount;           }         } else {           if (this.data.Length > 0) {             this.data[0] = 0;           }           this.wordCount = 0;         }
Magic Number,PeterO.Cbor,MutableNumber,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\FastInteger2.cs,Multiply,The following statement contains a magic number: if (multiplicand != 0) {           var carry = 0;           if (this.wordCount == 0) {             if (this.data.Length == 0) {               this.data = new int[4];             }             this.data[0] = 0;             this.wordCount = 1;           }           int result0' result1' result2' result3;           if (multiplicand < 65536) {             for (var i = 0; i < this.wordCount; ++i) {               int x0 = this.data[i];               int x1 = x0;               int y0 = multiplicand;               x0 &= 65535;               x1 = (x1 >> 16) & 65535;               int temp = unchecked(x0 * y0);  // a * c               result1 = (temp >> 16) & 65535;               result0 = temp & 65535;               result2 = 0;               temp = unchecked(x1 * y0);  // b * c               result2 += (temp >> 16) & 65535;               result1 += temp & 65535;               result2 += (result1 >> 16) & 65535;               result1 &= 65535;               result3 = (result2 >> 16) & 65535;               result2 &= 65535;               // Add carry               x0 = unchecked((int)(result0 | (result1 << 16)));               x1 = unchecked((int)(result2 | (result3 << 16)));               int x2 = unchecked(x0 + carry);               if (((x2 >> 31) == (x0 >> 31)) ? ((x2 & Int32.MaxValue) < (x0 &               Int32.MaxValue)) : ((x2 >> 31) == 0)) {                 // Carry in addition                 x1 = unchecked(x1 + 1);               }               this.data[i] = x2;               carry = x1;             }           } else {             for (var i = 0; i < this.wordCount; ++i) {               int x0 = this.data[i];               int x1 = x0;               int y0 = multiplicand;               int y1 = y0;               x0 &= 65535;               y0 &= 65535;               x1 = (x1 >> 16) & 65535;               y1 = (y1 >> 16) & 65535;               int temp = unchecked(x0 * y0);  // a * c               result1 = (temp >> 16) & 65535;               result0 = temp & 65535;               temp = unchecked(x0 * y1);  // a * d               result2 = (temp >> 16) & 65535;               result1 += temp & 65535;               result2 += (result1 >> 16) & 65535;               result1 &= 65535;               temp = unchecked(x1 * y0);  // b * c               result2 += (temp >> 16) & 65535;               result1 += temp & 65535;               result2 += (result1 >> 16) & 65535;               result1 &= 65535;               result3 = (result2 >> 16) & 65535;               result2 &= 65535;               temp = unchecked(x1 * y1);  // b * d               result3 += (temp >> 16) & 65535;               result2 += temp & 65535;               result3 += (result2 >> 16) & 65535;               result2 &= 65535;               // Add carry               x0 = unchecked((int)(result0 | (result1 << 16)));               x1 = unchecked((int)(result2 | (result3 << 16)));               int x2 = unchecked(x0 + carry);               if (((x2 >> 31) == (x0 >> 31)) ? ((x2 & Int32.MaxValue) < (x0 &               Int32.MaxValue)) : ((x2 >> 31) == 0)) {                 // Carry in addition                 x1 = unchecked(x1 + 1);               }               this.data[i] = x2;               carry = x1;             }           }           if (carry != 0) {             if (this.wordCount >= this.data.Length) {               var newdata = new int[this.wordCount + 20];               Array.Copy(this.data' 0' newdata' 0' this.data.Length);               this.data = newdata;             }             this.data[this.wordCount] = carry;             ++this.wordCount;           }           // Calculate the correct data length           while (this.wordCount != 0 && this.data[this.wordCount - 1] == 0) {             --this.wordCount;           }         } else {           if (this.data.Length > 0) {             this.data[0] = 0;           }           this.wordCount = 0;         }
Magic Number,PeterO.Cbor,MutableNumber,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\FastInteger2.cs,Multiply,The following statement contains a magic number: if (multiplicand != 0) {           var carry = 0;           if (this.wordCount == 0) {             if (this.data.Length == 0) {               this.data = new int[4];             }             this.data[0] = 0;             this.wordCount = 1;           }           int result0' result1' result2' result3;           if (multiplicand < 65536) {             for (var i = 0; i < this.wordCount; ++i) {               int x0 = this.data[i];               int x1 = x0;               int y0 = multiplicand;               x0 &= 65535;               x1 = (x1 >> 16) & 65535;               int temp = unchecked(x0 * y0);  // a * c               result1 = (temp >> 16) & 65535;               result0 = temp & 65535;               result2 = 0;               temp = unchecked(x1 * y0);  // b * c               result2 += (temp >> 16) & 65535;               result1 += temp & 65535;               result2 += (result1 >> 16) & 65535;               result1 &= 65535;               result3 = (result2 >> 16) & 65535;               result2 &= 65535;               // Add carry               x0 = unchecked((int)(result0 | (result1 << 16)));               x1 = unchecked((int)(result2 | (result3 << 16)));               int x2 = unchecked(x0 + carry);               if (((x2 >> 31) == (x0 >> 31)) ? ((x2 & Int32.MaxValue) < (x0 &               Int32.MaxValue)) : ((x2 >> 31) == 0)) {                 // Carry in addition                 x1 = unchecked(x1 + 1);               }               this.data[i] = x2;               carry = x1;             }           } else {             for (var i = 0; i < this.wordCount; ++i) {               int x0 = this.data[i];               int x1 = x0;               int y0 = multiplicand;               int y1 = y0;               x0 &= 65535;               y0 &= 65535;               x1 = (x1 >> 16) & 65535;               y1 = (y1 >> 16) & 65535;               int temp = unchecked(x0 * y0);  // a * c               result1 = (temp >> 16) & 65535;               result0 = temp & 65535;               temp = unchecked(x0 * y1);  // a * d               result2 = (temp >> 16) & 65535;               result1 += temp & 65535;               result2 += (result1 >> 16) & 65535;               result1 &= 65535;               temp = unchecked(x1 * y0);  // b * c               result2 += (temp >> 16) & 65535;               result1 += temp & 65535;               result2 += (result1 >> 16) & 65535;               result1 &= 65535;               result3 = (result2 >> 16) & 65535;               result2 &= 65535;               temp = unchecked(x1 * y1);  // b * d               result3 += (temp >> 16) & 65535;               result2 += temp & 65535;               result3 += (result2 >> 16) & 65535;               result2 &= 65535;               // Add carry               x0 = unchecked((int)(result0 | (result1 << 16)));               x1 = unchecked((int)(result2 | (result3 << 16)));               int x2 = unchecked(x0 + carry);               if (((x2 >> 31) == (x0 >> 31)) ? ((x2 & Int32.MaxValue) < (x0 &               Int32.MaxValue)) : ((x2 >> 31) == 0)) {                 // Carry in addition                 x1 = unchecked(x1 + 1);               }               this.data[i] = x2;               carry = x1;             }           }           if (carry != 0) {             if (this.wordCount >= this.data.Length) {               var newdata = new int[this.wordCount + 20];               Array.Copy(this.data' 0' newdata' 0' this.data.Length);               this.data = newdata;             }             this.data[this.wordCount] = carry;             ++this.wordCount;           }           // Calculate the correct data length           while (this.wordCount != 0 && this.data[this.wordCount - 1] == 0) {             --this.wordCount;           }         } else {           if (this.data.Length > 0) {             this.data[0] = 0;           }           this.wordCount = 0;         }
Magic Number,PeterO.Cbor,MutableNumber,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\FastInteger2.cs,Multiply,The following statement contains a magic number: if (multiplicand != 0) {           var carry = 0;           if (this.wordCount == 0) {             if (this.data.Length == 0) {               this.data = new int[4];             }             this.data[0] = 0;             this.wordCount = 1;           }           int result0' result1' result2' result3;           if (multiplicand < 65536) {             for (var i = 0; i < this.wordCount; ++i) {               int x0 = this.data[i];               int x1 = x0;               int y0 = multiplicand;               x0 &= 65535;               x1 = (x1 >> 16) & 65535;               int temp = unchecked(x0 * y0);  // a * c               result1 = (temp >> 16) & 65535;               result0 = temp & 65535;               result2 = 0;               temp = unchecked(x1 * y0);  // b * c               result2 += (temp >> 16) & 65535;               result1 += temp & 65535;               result2 += (result1 >> 16) & 65535;               result1 &= 65535;               result3 = (result2 >> 16) & 65535;               result2 &= 65535;               // Add carry               x0 = unchecked((int)(result0 | (result1 << 16)));               x1 = unchecked((int)(result2 | (result3 << 16)));               int x2 = unchecked(x0 + carry);               if (((x2 >> 31) == (x0 >> 31)) ? ((x2 & Int32.MaxValue) < (x0 &               Int32.MaxValue)) : ((x2 >> 31) == 0)) {                 // Carry in addition                 x1 = unchecked(x1 + 1);               }               this.data[i] = x2;               carry = x1;             }           } else {             for (var i = 0; i < this.wordCount; ++i) {               int x0 = this.data[i];               int x1 = x0;               int y0 = multiplicand;               int y1 = y0;               x0 &= 65535;               y0 &= 65535;               x1 = (x1 >> 16) & 65535;               y1 = (y1 >> 16) & 65535;               int temp = unchecked(x0 * y0);  // a * c               result1 = (temp >> 16) & 65535;               result0 = temp & 65535;               temp = unchecked(x0 * y1);  // a * d               result2 = (temp >> 16) & 65535;               result1 += temp & 65535;               result2 += (result1 >> 16) & 65535;               result1 &= 65535;               temp = unchecked(x1 * y0);  // b * c               result2 += (temp >> 16) & 65535;               result1 += temp & 65535;               result2 += (result1 >> 16) & 65535;               result1 &= 65535;               result3 = (result2 >> 16) & 65535;               result2 &= 65535;               temp = unchecked(x1 * y1);  // b * d               result3 += (temp >> 16) & 65535;               result2 += temp & 65535;               result3 += (result2 >> 16) & 65535;               result2 &= 65535;               // Add carry               x0 = unchecked((int)(result0 | (result1 << 16)));               x1 = unchecked((int)(result2 | (result3 << 16)));               int x2 = unchecked(x0 + carry);               if (((x2 >> 31) == (x0 >> 31)) ? ((x2 & Int32.MaxValue) < (x0 &               Int32.MaxValue)) : ((x2 >> 31) == 0)) {                 // Carry in addition                 x1 = unchecked(x1 + 1);               }               this.data[i] = x2;               carry = x1;             }           }           if (carry != 0) {             if (this.wordCount >= this.data.Length) {               var newdata = new int[this.wordCount + 20];               Array.Copy(this.data' 0' newdata' 0' this.data.Length);               this.data = newdata;             }             this.data[this.wordCount] = carry;             ++this.wordCount;           }           // Calculate the correct data length           while (this.wordCount != 0 && this.data[this.wordCount - 1] == 0) {             --this.wordCount;           }         } else {           if (this.data.Length > 0) {             this.data[0] = 0;           }           this.wordCount = 0;         }
Magic Number,PeterO.Cbor,MutableNumber,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\FastInteger2.cs,Multiply,The following statement contains a magic number: if (multiplicand != 0) {           var carry = 0;           if (this.wordCount == 0) {             if (this.data.Length == 0) {               this.data = new int[4];             }             this.data[0] = 0;             this.wordCount = 1;           }           int result0' result1' result2' result3;           if (multiplicand < 65536) {             for (var i = 0; i < this.wordCount; ++i) {               int x0 = this.data[i];               int x1 = x0;               int y0 = multiplicand;               x0 &= 65535;               x1 = (x1 >> 16) & 65535;               int temp = unchecked(x0 * y0);  // a * c               result1 = (temp >> 16) & 65535;               result0 = temp & 65535;               result2 = 0;               temp = unchecked(x1 * y0);  // b * c               result2 += (temp >> 16) & 65535;               result1 += temp & 65535;               result2 += (result1 >> 16) & 65535;               result1 &= 65535;               result3 = (result2 >> 16) & 65535;               result2 &= 65535;               // Add carry               x0 = unchecked((int)(result0 | (result1 << 16)));               x1 = unchecked((int)(result2 | (result3 << 16)));               int x2 = unchecked(x0 + carry);               if (((x2 >> 31) == (x0 >> 31)) ? ((x2 & Int32.MaxValue) < (x0 &               Int32.MaxValue)) : ((x2 >> 31) == 0)) {                 // Carry in addition                 x1 = unchecked(x1 + 1);               }               this.data[i] = x2;               carry = x1;             }           } else {             for (var i = 0; i < this.wordCount; ++i) {               int x0 = this.data[i];               int x1 = x0;               int y0 = multiplicand;               int y1 = y0;               x0 &= 65535;               y0 &= 65535;               x1 = (x1 >> 16) & 65535;               y1 = (y1 >> 16) & 65535;               int temp = unchecked(x0 * y0);  // a * c               result1 = (temp >> 16) & 65535;               result0 = temp & 65535;               temp = unchecked(x0 * y1);  // a * d               result2 = (temp >> 16) & 65535;               result1 += temp & 65535;               result2 += (result1 >> 16) & 65535;               result1 &= 65535;               temp = unchecked(x1 * y0);  // b * c               result2 += (temp >> 16) & 65535;               result1 += temp & 65535;               result2 += (result1 >> 16) & 65535;               result1 &= 65535;               result3 = (result2 >> 16) & 65535;               result2 &= 65535;               temp = unchecked(x1 * y1);  // b * d               result3 += (temp >> 16) & 65535;               result2 += temp & 65535;               result3 += (result2 >> 16) & 65535;               result2 &= 65535;               // Add carry               x0 = unchecked((int)(result0 | (result1 << 16)));               x1 = unchecked((int)(result2 | (result3 << 16)));               int x2 = unchecked(x0 + carry);               if (((x2 >> 31) == (x0 >> 31)) ? ((x2 & Int32.MaxValue) < (x0 &               Int32.MaxValue)) : ((x2 >> 31) == 0)) {                 // Carry in addition                 x1 = unchecked(x1 + 1);               }               this.data[i] = x2;               carry = x1;             }           }           if (carry != 0) {             if (this.wordCount >= this.data.Length) {               var newdata = new int[this.wordCount + 20];               Array.Copy(this.data' 0' newdata' 0' this.data.Length);               this.data = newdata;             }             this.data[this.wordCount] = carry;             ++this.wordCount;           }           // Calculate the correct data length           while (this.wordCount != 0 && this.data[this.wordCount - 1] == 0) {             --this.wordCount;           }         } else {           if (this.data.Length > 0) {             this.data[0] = 0;           }           this.wordCount = 0;         }
Magic Number,PeterO.Cbor,MutableNumber,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\FastInteger2.cs,Multiply,The following statement contains a magic number: if (multiplicand != 0) {           var carry = 0;           if (this.wordCount == 0) {             if (this.data.Length == 0) {               this.data = new int[4];             }             this.data[0] = 0;             this.wordCount = 1;           }           int result0' result1' result2' result3;           if (multiplicand < 65536) {             for (var i = 0; i < this.wordCount; ++i) {               int x0 = this.data[i];               int x1 = x0;               int y0 = multiplicand;               x0 &= 65535;               x1 = (x1 >> 16) & 65535;               int temp = unchecked(x0 * y0);  // a * c               result1 = (temp >> 16) & 65535;               result0 = temp & 65535;               result2 = 0;               temp = unchecked(x1 * y0);  // b * c               result2 += (temp >> 16) & 65535;               result1 += temp & 65535;               result2 += (result1 >> 16) & 65535;               result1 &= 65535;               result3 = (result2 >> 16) & 65535;               result2 &= 65535;               // Add carry               x0 = unchecked((int)(result0 | (result1 << 16)));               x1 = unchecked((int)(result2 | (result3 << 16)));               int x2 = unchecked(x0 + carry);               if (((x2 >> 31) == (x0 >> 31)) ? ((x2 & Int32.MaxValue) < (x0 &               Int32.MaxValue)) : ((x2 >> 31) == 0)) {                 // Carry in addition                 x1 = unchecked(x1 + 1);               }               this.data[i] = x2;               carry = x1;             }           } else {             for (var i = 0; i < this.wordCount; ++i) {               int x0 = this.data[i];               int x1 = x0;               int y0 = multiplicand;               int y1 = y0;               x0 &= 65535;               y0 &= 65535;               x1 = (x1 >> 16) & 65535;               y1 = (y1 >> 16) & 65535;               int temp = unchecked(x0 * y0);  // a * c               result1 = (temp >> 16) & 65535;               result0 = temp & 65535;               temp = unchecked(x0 * y1);  // a * d               result2 = (temp >> 16) & 65535;               result1 += temp & 65535;               result2 += (result1 >> 16) & 65535;               result1 &= 65535;               temp = unchecked(x1 * y0);  // b * c               result2 += (temp >> 16) & 65535;               result1 += temp & 65535;               result2 += (result1 >> 16) & 65535;               result1 &= 65535;               result3 = (result2 >> 16) & 65535;               result2 &= 65535;               temp = unchecked(x1 * y1);  // b * d               result3 += (temp >> 16) & 65535;               result2 += temp & 65535;               result3 += (result2 >> 16) & 65535;               result2 &= 65535;               // Add carry               x0 = unchecked((int)(result0 | (result1 << 16)));               x1 = unchecked((int)(result2 | (result3 << 16)));               int x2 = unchecked(x0 + carry);               if (((x2 >> 31) == (x0 >> 31)) ? ((x2 & Int32.MaxValue) < (x0 &               Int32.MaxValue)) : ((x2 >> 31) == 0)) {                 // Carry in addition                 x1 = unchecked(x1 + 1);               }               this.data[i] = x2;               carry = x1;             }           }           if (carry != 0) {             if (this.wordCount >= this.data.Length) {               var newdata = new int[this.wordCount + 20];               Array.Copy(this.data' 0' newdata' 0' this.data.Length);               this.data = newdata;             }             this.data[this.wordCount] = carry;             ++this.wordCount;           }           // Calculate the correct data length           while (this.wordCount != 0 && this.data[this.wordCount - 1] == 0) {             --this.wordCount;           }         } else {           if (this.data.Length > 0) {             this.data[0] = 0;           }           this.wordCount = 0;         }
Magic Number,PeterO.Cbor,MutableNumber,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\FastInteger2.cs,Multiply,The following statement contains a magic number: if (multiplicand != 0) {           var carry = 0;           if (this.wordCount == 0) {             if (this.data.Length == 0) {               this.data = new int[4];             }             this.data[0] = 0;             this.wordCount = 1;           }           int result0' result1' result2' result3;           if (multiplicand < 65536) {             for (var i = 0; i < this.wordCount; ++i) {               int x0 = this.data[i];               int x1 = x0;               int y0 = multiplicand;               x0 &= 65535;               x1 = (x1 >> 16) & 65535;               int temp = unchecked(x0 * y0);  // a * c               result1 = (temp >> 16) & 65535;               result0 = temp & 65535;               result2 = 0;               temp = unchecked(x1 * y0);  // b * c               result2 += (temp >> 16) & 65535;               result1 += temp & 65535;               result2 += (result1 >> 16) & 65535;               result1 &= 65535;               result3 = (result2 >> 16) & 65535;               result2 &= 65535;               // Add carry               x0 = unchecked((int)(result0 | (result1 << 16)));               x1 = unchecked((int)(result2 | (result3 << 16)));               int x2 = unchecked(x0 + carry);               if (((x2 >> 31) == (x0 >> 31)) ? ((x2 & Int32.MaxValue) < (x0 &               Int32.MaxValue)) : ((x2 >> 31) == 0)) {                 // Carry in addition                 x1 = unchecked(x1 + 1);               }               this.data[i] = x2;               carry = x1;             }           } else {             for (var i = 0; i < this.wordCount; ++i) {               int x0 = this.data[i];               int x1 = x0;               int y0 = multiplicand;               int y1 = y0;               x0 &= 65535;               y0 &= 65535;               x1 = (x1 >> 16) & 65535;               y1 = (y1 >> 16) & 65535;               int temp = unchecked(x0 * y0);  // a * c               result1 = (temp >> 16) & 65535;               result0 = temp & 65535;               temp = unchecked(x0 * y1);  // a * d               result2 = (temp >> 16) & 65535;               result1 += temp & 65535;               result2 += (result1 >> 16) & 65535;               result1 &= 65535;               temp = unchecked(x1 * y0);  // b * c               result2 += (temp >> 16) & 65535;               result1 += temp & 65535;               result2 += (result1 >> 16) & 65535;               result1 &= 65535;               result3 = (result2 >> 16) & 65535;               result2 &= 65535;               temp = unchecked(x1 * y1);  // b * d               result3 += (temp >> 16) & 65535;               result2 += temp & 65535;               result3 += (result2 >> 16) & 65535;               result2 &= 65535;               // Add carry               x0 = unchecked((int)(result0 | (result1 << 16)));               x1 = unchecked((int)(result2 | (result3 << 16)));               int x2 = unchecked(x0 + carry);               if (((x2 >> 31) == (x0 >> 31)) ? ((x2 & Int32.MaxValue) < (x0 &               Int32.MaxValue)) : ((x2 >> 31) == 0)) {                 // Carry in addition                 x1 = unchecked(x1 + 1);               }               this.data[i] = x2;               carry = x1;             }           }           if (carry != 0) {             if (this.wordCount >= this.data.Length) {               var newdata = new int[this.wordCount + 20];               Array.Copy(this.data' 0' newdata' 0' this.data.Length);               this.data = newdata;             }             this.data[this.wordCount] = carry;             ++this.wordCount;           }           // Calculate the correct data length           while (this.wordCount != 0 && this.data[this.wordCount - 1] == 0) {             --this.wordCount;           }         } else {           if (this.data.Length > 0) {             this.data[0] = 0;           }           this.wordCount = 0;         }
Magic Number,PeterO.Cbor,MutableNumber,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\FastInteger2.cs,Multiply,The following statement contains a magic number: if (multiplicand != 0) {           var carry = 0;           if (this.wordCount == 0) {             if (this.data.Length == 0) {               this.data = new int[4];             }             this.data[0] = 0;             this.wordCount = 1;           }           int result0' result1' result2' result3;           if (multiplicand < 65536) {             for (var i = 0; i < this.wordCount; ++i) {               int x0 = this.data[i];               int x1 = x0;               int y0 = multiplicand;               x0 &= 65535;               x1 = (x1 >> 16) & 65535;               int temp = unchecked(x0 * y0);  // a * c               result1 = (temp >> 16) & 65535;               result0 = temp & 65535;               result2 = 0;               temp = unchecked(x1 * y0);  // b * c               result2 += (temp >> 16) & 65535;               result1 += temp & 65535;               result2 += (result1 >> 16) & 65535;               result1 &= 65535;               result3 = (result2 >> 16) & 65535;               result2 &= 65535;               // Add carry               x0 = unchecked((int)(result0 | (result1 << 16)));               x1 = unchecked((int)(result2 | (result3 << 16)));               int x2 = unchecked(x0 + carry);               if (((x2 >> 31) == (x0 >> 31)) ? ((x2 & Int32.MaxValue) < (x0 &               Int32.MaxValue)) : ((x2 >> 31) == 0)) {                 // Carry in addition                 x1 = unchecked(x1 + 1);               }               this.data[i] = x2;               carry = x1;             }           } else {             for (var i = 0; i < this.wordCount; ++i) {               int x0 = this.data[i];               int x1 = x0;               int y0 = multiplicand;               int y1 = y0;               x0 &= 65535;               y0 &= 65535;               x1 = (x1 >> 16) & 65535;               y1 = (y1 >> 16) & 65535;               int temp = unchecked(x0 * y0);  // a * c               result1 = (temp >> 16) & 65535;               result0 = temp & 65535;               temp = unchecked(x0 * y1);  // a * d               result2 = (temp >> 16) & 65535;               result1 += temp & 65535;               result2 += (result1 >> 16) & 65535;               result1 &= 65535;               temp = unchecked(x1 * y0);  // b * c               result2 += (temp >> 16) & 65535;               result1 += temp & 65535;               result2 += (result1 >> 16) & 65535;               result1 &= 65535;               result3 = (result2 >> 16) & 65535;               result2 &= 65535;               temp = unchecked(x1 * y1);  // b * d               result3 += (temp >> 16) & 65535;               result2 += temp & 65535;               result3 += (result2 >> 16) & 65535;               result2 &= 65535;               // Add carry               x0 = unchecked((int)(result0 | (result1 << 16)));               x1 = unchecked((int)(result2 | (result3 << 16)));               int x2 = unchecked(x0 + carry);               if (((x2 >> 31) == (x0 >> 31)) ? ((x2 & Int32.MaxValue) < (x0 &               Int32.MaxValue)) : ((x2 >> 31) == 0)) {                 // Carry in addition                 x1 = unchecked(x1 + 1);               }               this.data[i] = x2;               carry = x1;             }           }           if (carry != 0) {             if (this.wordCount >= this.data.Length) {               var newdata = new int[this.wordCount + 20];               Array.Copy(this.data' 0' newdata' 0' this.data.Length);               this.data = newdata;             }             this.data[this.wordCount] = carry;             ++this.wordCount;           }           // Calculate the correct data length           while (this.wordCount != 0 && this.data[this.wordCount - 1] == 0) {             --this.wordCount;           }         } else {           if (this.data.Length > 0) {             this.data[0] = 0;           }           this.wordCount = 0;         }
Magic Number,PeterO.Cbor,MutableNumber,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\FastInteger2.cs,Multiply,The following statement contains a magic number: if (multiplicand != 0) {           var carry = 0;           if (this.wordCount == 0) {             if (this.data.Length == 0) {               this.data = new int[4];             }             this.data[0] = 0;             this.wordCount = 1;           }           int result0' result1' result2' result3;           if (multiplicand < 65536) {             for (var i = 0; i < this.wordCount; ++i) {               int x0 = this.data[i];               int x1 = x0;               int y0 = multiplicand;               x0 &= 65535;               x1 = (x1 >> 16) & 65535;               int temp = unchecked(x0 * y0);  // a * c               result1 = (temp >> 16) & 65535;               result0 = temp & 65535;               result2 = 0;               temp = unchecked(x1 * y0);  // b * c               result2 += (temp >> 16) & 65535;               result1 += temp & 65535;               result2 += (result1 >> 16) & 65535;               result1 &= 65535;               result3 = (result2 >> 16) & 65535;               result2 &= 65535;               // Add carry               x0 = unchecked((int)(result0 | (result1 << 16)));               x1 = unchecked((int)(result2 | (result3 << 16)));               int x2 = unchecked(x0 + carry);               if (((x2 >> 31) == (x0 >> 31)) ? ((x2 & Int32.MaxValue) < (x0 &               Int32.MaxValue)) : ((x2 >> 31) == 0)) {                 // Carry in addition                 x1 = unchecked(x1 + 1);               }               this.data[i] = x2;               carry = x1;             }           } else {             for (var i = 0; i < this.wordCount; ++i) {               int x0 = this.data[i];               int x1 = x0;               int y0 = multiplicand;               int y1 = y0;               x0 &= 65535;               y0 &= 65535;               x1 = (x1 >> 16) & 65535;               y1 = (y1 >> 16) & 65535;               int temp = unchecked(x0 * y0);  // a * c               result1 = (temp >> 16) & 65535;               result0 = temp & 65535;               temp = unchecked(x0 * y1);  // a * d               result2 = (temp >> 16) & 65535;               result1 += temp & 65535;               result2 += (result1 >> 16) & 65535;               result1 &= 65535;               temp = unchecked(x1 * y0);  // b * c               result2 += (temp >> 16) & 65535;               result1 += temp & 65535;               result2 += (result1 >> 16) & 65535;               result1 &= 65535;               result3 = (result2 >> 16) & 65535;               result2 &= 65535;               temp = unchecked(x1 * y1);  // b * d               result3 += (temp >> 16) & 65535;               result2 += temp & 65535;               result3 += (result2 >> 16) & 65535;               result2 &= 65535;               // Add carry               x0 = unchecked((int)(result0 | (result1 << 16)));               x1 = unchecked((int)(result2 | (result3 << 16)));               int x2 = unchecked(x0 + carry);               if (((x2 >> 31) == (x0 >> 31)) ? ((x2 & Int32.MaxValue) < (x0 &               Int32.MaxValue)) : ((x2 >> 31) == 0)) {                 // Carry in addition                 x1 = unchecked(x1 + 1);               }               this.data[i] = x2;               carry = x1;             }           }           if (carry != 0) {             if (this.wordCount >= this.data.Length) {               var newdata = new int[this.wordCount + 20];               Array.Copy(this.data' 0' newdata' 0' this.data.Length);               this.data = newdata;             }             this.data[this.wordCount] = carry;             ++this.wordCount;           }           // Calculate the correct data length           while (this.wordCount != 0 && this.data[this.wordCount - 1] == 0) {             --this.wordCount;           }         } else {           if (this.data.Length > 0) {             this.data[0] = 0;           }           this.wordCount = 0;         }
Magic Number,PeterO.Cbor,MutableNumber,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\FastInteger2.cs,Multiply,The following statement contains a magic number: if (multiplicand != 0) {           var carry = 0;           if (this.wordCount == 0) {             if (this.data.Length == 0) {               this.data = new int[4];             }             this.data[0] = 0;             this.wordCount = 1;           }           int result0' result1' result2' result3;           if (multiplicand < 65536) {             for (var i = 0; i < this.wordCount; ++i) {               int x0 = this.data[i];               int x1 = x0;               int y0 = multiplicand;               x0 &= 65535;               x1 = (x1 >> 16) & 65535;               int temp = unchecked(x0 * y0);  // a * c               result1 = (temp >> 16) & 65535;               result0 = temp & 65535;               result2 = 0;               temp = unchecked(x1 * y0);  // b * c               result2 += (temp >> 16) & 65535;               result1 += temp & 65535;               result2 += (result1 >> 16) & 65535;               result1 &= 65535;               result3 = (result2 >> 16) & 65535;               result2 &= 65535;               // Add carry               x0 = unchecked((int)(result0 | (result1 << 16)));               x1 = unchecked((int)(result2 | (result3 << 16)));               int x2 = unchecked(x0 + carry);               if (((x2 >> 31) == (x0 >> 31)) ? ((x2 & Int32.MaxValue) < (x0 &               Int32.MaxValue)) : ((x2 >> 31) == 0)) {                 // Carry in addition                 x1 = unchecked(x1 + 1);               }               this.data[i] = x2;               carry = x1;             }           } else {             for (var i = 0; i < this.wordCount; ++i) {               int x0 = this.data[i];               int x1 = x0;               int y0 = multiplicand;               int y1 = y0;               x0 &= 65535;               y0 &= 65535;               x1 = (x1 >> 16) & 65535;               y1 = (y1 >> 16) & 65535;               int temp = unchecked(x0 * y0);  // a * c               result1 = (temp >> 16) & 65535;               result0 = temp & 65535;               temp = unchecked(x0 * y1);  // a * d               result2 = (temp >> 16) & 65535;               result1 += temp & 65535;               result2 += (result1 >> 16) & 65535;               result1 &= 65535;               temp = unchecked(x1 * y0);  // b * c               result2 += (temp >> 16) & 65535;               result1 += temp & 65535;               result2 += (result1 >> 16) & 65535;               result1 &= 65535;               result3 = (result2 >> 16) & 65535;               result2 &= 65535;               temp = unchecked(x1 * y1);  // b * d               result3 += (temp >> 16) & 65535;               result2 += temp & 65535;               result3 += (result2 >> 16) & 65535;               result2 &= 65535;               // Add carry               x0 = unchecked((int)(result0 | (result1 << 16)));               x1 = unchecked((int)(result2 | (result3 << 16)));               int x2 = unchecked(x0 + carry);               if (((x2 >> 31) == (x0 >> 31)) ? ((x2 & Int32.MaxValue) < (x0 &               Int32.MaxValue)) : ((x2 >> 31) == 0)) {                 // Carry in addition                 x1 = unchecked(x1 + 1);               }               this.data[i] = x2;               carry = x1;             }           }           if (carry != 0) {             if (this.wordCount >= this.data.Length) {               var newdata = new int[this.wordCount + 20];               Array.Copy(this.data' 0' newdata' 0' this.data.Length);               this.data = newdata;             }             this.data[this.wordCount] = carry;             ++this.wordCount;           }           // Calculate the correct data length           while (this.wordCount != 0 && this.data[this.wordCount - 1] == 0) {             --this.wordCount;           }         } else {           if (this.data.Length > 0) {             this.data[0] = 0;           }           this.wordCount = 0;         }
Magic Number,PeterO.Cbor,MutableNumber,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\FastInteger2.cs,Multiply,The following statement contains a magic number: if (multiplicand != 0) {           var carry = 0;           if (this.wordCount == 0) {             if (this.data.Length == 0) {               this.data = new int[4];             }             this.data[0] = 0;             this.wordCount = 1;           }           int result0' result1' result2' result3;           if (multiplicand < 65536) {             for (var i = 0; i < this.wordCount; ++i) {               int x0 = this.data[i];               int x1 = x0;               int y0 = multiplicand;               x0 &= 65535;               x1 = (x1 >> 16) & 65535;               int temp = unchecked(x0 * y0);  // a * c               result1 = (temp >> 16) & 65535;               result0 = temp & 65535;               result2 = 0;               temp = unchecked(x1 * y0);  // b * c               result2 += (temp >> 16) & 65535;               result1 += temp & 65535;               result2 += (result1 >> 16) & 65535;               result1 &= 65535;               result3 = (result2 >> 16) & 65535;               result2 &= 65535;               // Add carry               x0 = unchecked((int)(result0 | (result1 << 16)));               x1 = unchecked((int)(result2 | (result3 << 16)));               int x2 = unchecked(x0 + carry);               if (((x2 >> 31) == (x0 >> 31)) ? ((x2 & Int32.MaxValue) < (x0 &               Int32.MaxValue)) : ((x2 >> 31) == 0)) {                 // Carry in addition                 x1 = unchecked(x1 + 1);               }               this.data[i] = x2;               carry = x1;             }           } else {             for (var i = 0; i < this.wordCount; ++i) {               int x0 = this.data[i];               int x1 = x0;               int y0 = multiplicand;               int y1 = y0;               x0 &= 65535;               y0 &= 65535;               x1 = (x1 >> 16) & 65535;               y1 = (y1 >> 16) & 65535;               int temp = unchecked(x0 * y0);  // a * c               result1 = (temp >> 16) & 65535;               result0 = temp & 65535;               temp = unchecked(x0 * y1);  // a * d               result2 = (temp >> 16) & 65535;               result1 += temp & 65535;               result2 += (result1 >> 16) & 65535;               result1 &= 65535;               temp = unchecked(x1 * y0);  // b * c               result2 += (temp >> 16) & 65535;               result1 += temp & 65535;               result2 += (result1 >> 16) & 65535;               result1 &= 65535;               result3 = (result2 >> 16) & 65535;               result2 &= 65535;               temp = unchecked(x1 * y1);  // b * d               result3 += (temp >> 16) & 65535;               result2 += temp & 65535;               result3 += (result2 >> 16) & 65535;               result2 &= 65535;               // Add carry               x0 = unchecked((int)(result0 | (result1 << 16)));               x1 = unchecked((int)(result2 | (result3 << 16)));               int x2 = unchecked(x0 + carry);               if (((x2 >> 31) == (x0 >> 31)) ? ((x2 & Int32.MaxValue) < (x0 &               Int32.MaxValue)) : ((x2 >> 31) == 0)) {                 // Carry in addition                 x1 = unchecked(x1 + 1);               }               this.data[i] = x2;               carry = x1;             }           }           if (carry != 0) {             if (this.wordCount >= this.data.Length) {               var newdata = new int[this.wordCount + 20];               Array.Copy(this.data' 0' newdata' 0' this.data.Length);               this.data = newdata;             }             this.data[this.wordCount] = carry;             ++this.wordCount;           }           // Calculate the correct data length           while (this.wordCount != 0 && this.data[this.wordCount - 1] == 0) {             --this.wordCount;           }         } else {           if (this.data.Length > 0) {             this.data[0] = 0;           }           this.wordCount = 0;         }
Magic Number,PeterO.Cbor,MutableNumber,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\FastInteger2.cs,Multiply,The following statement contains a magic number: if (multiplicand != 0) {           var carry = 0;           if (this.wordCount == 0) {             if (this.data.Length == 0) {               this.data = new int[4];             }             this.data[0] = 0;             this.wordCount = 1;           }           int result0' result1' result2' result3;           if (multiplicand < 65536) {             for (var i = 0; i < this.wordCount; ++i) {               int x0 = this.data[i];               int x1 = x0;               int y0 = multiplicand;               x0 &= 65535;               x1 = (x1 >> 16) & 65535;               int temp = unchecked(x0 * y0);  // a * c               result1 = (temp >> 16) & 65535;               result0 = temp & 65535;               result2 = 0;               temp = unchecked(x1 * y0);  // b * c               result2 += (temp >> 16) & 65535;               result1 += temp & 65535;               result2 += (result1 >> 16) & 65535;               result1 &= 65535;               result3 = (result2 >> 16) & 65535;               result2 &= 65535;               // Add carry               x0 = unchecked((int)(result0 | (result1 << 16)));               x1 = unchecked((int)(result2 | (result3 << 16)));               int x2 = unchecked(x0 + carry);               if (((x2 >> 31) == (x0 >> 31)) ? ((x2 & Int32.MaxValue) < (x0 &               Int32.MaxValue)) : ((x2 >> 31) == 0)) {                 // Carry in addition                 x1 = unchecked(x1 + 1);               }               this.data[i] = x2;               carry = x1;             }           } else {             for (var i = 0; i < this.wordCount; ++i) {               int x0 = this.data[i];               int x1 = x0;               int y0 = multiplicand;               int y1 = y0;               x0 &= 65535;               y0 &= 65535;               x1 = (x1 >> 16) & 65535;               y1 = (y1 >> 16) & 65535;               int temp = unchecked(x0 * y0);  // a * c               result1 = (temp >> 16) & 65535;               result0 = temp & 65535;               temp = unchecked(x0 * y1);  // a * d               result2 = (temp >> 16) & 65535;               result1 += temp & 65535;               result2 += (result1 >> 16) & 65535;               result1 &= 65535;               temp = unchecked(x1 * y0);  // b * c               result2 += (temp >> 16) & 65535;               result1 += temp & 65535;               result2 += (result1 >> 16) & 65535;               result1 &= 65535;               result3 = (result2 >> 16) & 65535;               result2 &= 65535;               temp = unchecked(x1 * y1);  // b * d               result3 += (temp >> 16) & 65535;               result2 += temp & 65535;               result3 += (result2 >> 16) & 65535;               result2 &= 65535;               // Add carry               x0 = unchecked((int)(result0 | (result1 << 16)));               x1 = unchecked((int)(result2 | (result3 << 16)));               int x2 = unchecked(x0 + carry);               if (((x2 >> 31) == (x0 >> 31)) ? ((x2 & Int32.MaxValue) < (x0 &               Int32.MaxValue)) : ((x2 >> 31) == 0)) {                 // Carry in addition                 x1 = unchecked(x1 + 1);               }               this.data[i] = x2;               carry = x1;             }           }           if (carry != 0) {             if (this.wordCount >= this.data.Length) {               var newdata = new int[this.wordCount + 20];               Array.Copy(this.data' 0' newdata' 0' this.data.Length);               this.data = newdata;             }             this.data[this.wordCount] = carry;             ++this.wordCount;           }           // Calculate the correct data length           while (this.wordCount != 0 && this.data[this.wordCount - 1] == 0) {             --this.wordCount;           }         } else {           if (this.data.Length > 0) {             this.data[0] = 0;           }           this.wordCount = 0;         }
Magic Number,PeterO.Cbor,MutableNumber,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\FastInteger2.cs,Multiply,The following statement contains a magic number: if (multiplicand != 0) {           var carry = 0;           if (this.wordCount == 0) {             if (this.data.Length == 0) {               this.data = new int[4];             }             this.data[0] = 0;             this.wordCount = 1;           }           int result0' result1' result2' result3;           if (multiplicand < 65536) {             for (var i = 0; i < this.wordCount; ++i) {               int x0 = this.data[i];               int x1 = x0;               int y0 = multiplicand;               x0 &= 65535;               x1 = (x1 >> 16) & 65535;               int temp = unchecked(x0 * y0);  // a * c               result1 = (temp >> 16) & 65535;               result0 = temp & 65535;               result2 = 0;               temp = unchecked(x1 * y0);  // b * c               result2 += (temp >> 16) & 65535;               result1 += temp & 65535;               result2 += (result1 >> 16) & 65535;               result1 &= 65535;               result3 = (result2 >> 16) & 65535;               result2 &= 65535;               // Add carry               x0 = unchecked((int)(result0 | (result1 << 16)));               x1 = unchecked((int)(result2 | (result3 << 16)));               int x2 = unchecked(x0 + carry);               if (((x2 >> 31) == (x0 >> 31)) ? ((x2 & Int32.MaxValue) < (x0 &               Int32.MaxValue)) : ((x2 >> 31) == 0)) {                 // Carry in addition                 x1 = unchecked(x1 + 1);               }               this.data[i] = x2;               carry = x1;             }           } else {             for (var i = 0; i < this.wordCount; ++i) {               int x0 = this.data[i];               int x1 = x0;               int y0 = multiplicand;               int y1 = y0;               x0 &= 65535;               y0 &= 65535;               x1 = (x1 >> 16) & 65535;               y1 = (y1 >> 16) & 65535;               int temp = unchecked(x0 * y0);  // a * c               result1 = (temp >> 16) & 65535;               result0 = temp & 65535;               temp = unchecked(x0 * y1);  // a * d               result2 = (temp >> 16) & 65535;               result1 += temp & 65535;               result2 += (result1 >> 16) & 65535;               result1 &= 65535;               temp = unchecked(x1 * y0);  // b * c               result2 += (temp >> 16) & 65535;               result1 += temp & 65535;               result2 += (result1 >> 16) & 65535;               result1 &= 65535;               result3 = (result2 >> 16) & 65535;               result2 &= 65535;               temp = unchecked(x1 * y1);  // b * d               result3 += (temp >> 16) & 65535;               result2 += temp & 65535;               result3 += (result2 >> 16) & 65535;               result2 &= 65535;               // Add carry               x0 = unchecked((int)(result0 | (result1 << 16)));               x1 = unchecked((int)(result2 | (result3 << 16)));               int x2 = unchecked(x0 + carry);               if (((x2 >> 31) == (x0 >> 31)) ? ((x2 & Int32.MaxValue) < (x0 &               Int32.MaxValue)) : ((x2 >> 31) == 0)) {                 // Carry in addition                 x1 = unchecked(x1 + 1);               }               this.data[i] = x2;               carry = x1;             }           }           if (carry != 0) {             if (this.wordCount >= this.data.Length) {               var newdata = new int[this.wordCount + 20];               Array.Copy(this.data' 0' newdata' 0' this.data.Length);               this.data = newdata;             }             this.data[this.wordCount] = carry;             ++this.wordCount;           }           // Calculate the correct data length           while (this.wordCount != 0 && this.data[this.wordCount - 1] == 0) {             --this.wordCount;           }         } else {           if (this.data.Length > 0) {             this.data[0] = 0;           }           this.wordCount = 0;         }
Magic Number,PeterO.Cbor,MutableNumber,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\FastInteger2.cs,Multiply,The following statement contains a magic number: if (multiplicand != 0) {           var carry = 0;           if (this.wordCount == 0) {             if (this.data.Length == 0) {               this.data = new int[4];             }             this.data[0] = 0;             this.wordCount = 1;           }           int result0' result1' result2' result3;           if (multiplicand < 65536) {             for (var i = 0; i < this.wordCount; ++i) {               int x0 = this.data[i];               int x1 = x0;               int y0 = multiplicand;               x0 &= 65535;               x1 = (x1 >> 16) & 65535;               int temp = unchecked(x0 * y0);  // a * c               result1 = (temp >> 16) & 65535;               result0 = temp & 65535;               result2 = 0;               temp = unchecked(x1 * y0);  // b * c               result2 += (temp >> 16) & 65535;               result1 += temp & 65535;               result2 += (result1 >> 16) & 65535;               result1 &= 65535;               result3 = (result2 >> 16) & 65535;               result2 &= 65535;               // Add carry               x0 = unchecked((int)(result0 | (result1 << 16)));               x1 = unchecked((int)(result2 | (result3 << 16)));               int x2 = unchecked(x0 + carry);               if (((x2 >> 31) == (x0 >> 31)) ? ((x2 & Int32.MaxValue) < (x0 &               Int32.MaxValue)) : ((x2 >> 31) == 0)) {                 // Carry in addition                 x1 = unchecked(x1 + 1);               }               this.data[i] = x2;               carry = x1;             }           } else {             for (var i = 0; i < this.wordCount; ++i) {               int x0 = this.data[i];               int x1 = x0;               int y0 = multiplicand;               int y1 = y0;               x0 &= 65535;               y0 &= 65535;               x1 = (x1 >> 16) & 65535;               y1 = (y1 >> 16) & 65535;               int temp = unchecked(x0 * y0);  // a * c               result1 = (temp >> 16) & 65535;               result0 = temp & 65535;               temp = unchecked(x0 * y1);  // a * d               result2 = (temp >> 16) & 65535;               result1 += temp & 65535;               result2 += (result1 >> 16) & 65535;               result1 &= 65535;               temp = unchecked(x1 * y0);  // b * c               result2 += (temp >> 16) & 65535;               result1 += temp & 65535;               result2 += (result1 >> 16) & 65535;               result1 &= 65535;               result3 = (result2 >> 16) & 65535;               result2 &= 65535;               temp = unchecked(x1 * y1);  // b * d               result3 += (temp >> 16) & 65535;               result2 += temp & 65535;               result3 += (result2 >> 16) & 65535;               result2 &= 65535;               // Add carry               x0 = unchecked((int)(result0 | (result1 << 16)));               x1 = unchecked((int)(result2 | (result3 << 16)));               int x2 = unchecked(x0 + carry);               if (((x2 >> 31) == (x0 >> 31)) ? ((x2 & Int32.MaxValue) < (x0 &               Int32.MaxValue)) : ((x2 >> 31) == 0)) {                 // Carry in addition                 x1 = unchecked(x1 + 1);               }               this.data[i] = x2;               carry = x1;             }           }           if (carry != 0) {             if (this.wordCount >= this.data.Length) {               var newdata = new int[this.wordCount + 20];               Array.Copy(this.data' 0' newdata' 0' this.data.Length);               this.data = newdata;             }             this.data[this.wordCount] = carry;             ++this.wordCount;           }           // Calculate the correct data length           while (this.wordCount != 0 && this.data[this.wordCount - 1] == 0) {             --this.wordCount;           }         } else {           if (this.data.Length > 0) {             this.data[0] = 0;           }           this.wordCount = 0;         }
Magic Number,PeterO.Cbor,MutableNumber,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\FastInteger2.cs,Multiply,The following statement contains a magic number: if (multiplicand != 0) {           var carry = 0;           if (this.wordCount == 0) {             if (this.data.Length == 0) {               this.data = new int[4];             }             this.data[0] = 0;             this.wordCount = 1;           }           int result0' result1' result2' result3;           if (multiplicand < 65536) {             for (var i = 0; i < this.wordCount; ++i) {               int x0 = this.data[i];               int x1 = x0;               int y0 = multiplicand;               x0 &= 65535;               x1 = (x1 >> 16) & 65535;               int temp = unchecked(x0 * y0);  // a * c               result1 = (temp >> 16) & 65535;               result0 = temp & 65535;               result2 = 0;               temp = unchecked(x1 * y0);  // b * c               result2 += (temp >> 16) & 65535;               result1 += temp & 65535;               result2 += (result1 >> 16) & 65535;               result1 &= 65535;               result3 = (result2 >> 16) & 65535;               result2 &= 65535;               // Add carry               x0 = unchecked((int)(result0 | (result1 << 16)));               x1 = unchecked((int)(result2 | (result3 << 16)));               int x2 = unchecked(x0 + carry);               if (((x2 >> 31) == (x0 >> 31)) ? ((x2 & Int32.MaxValue) < (x0 &               Int32.MaxValue)) : ((x2 >> 31) == 0)) {                 // Carry in addition                 x1 = unchecked(x1 + 1);               }               this.data[i] = x2;               carry = x1;             }           } else {             for (var i = 0; i < this.wordCount; ++i) {               int x0 = this.data[i];               int x1 = x0;               int y0 = multiplicand;               int y1 = y0;               x0 &= 65535;               y0 &= 65535;               x1 = (x1 >> 16) & 65535;               y1 = (y1 >> 16) & 65535;               int temp = unchecked(x0 * y0);  // a * c               result1 = (temp >> 16) & 65535;               result0 = temp & 65535;               temp = unchecked(x0 * y1);  // a * d               result2 = (temp >> 16) & 65535;               result1 += temp & 65535;               result2 += (result1 >> 16) & 65535;               result1 &= 65535;               temp = unchecked(x1 * y0);  // b * c               result2 += (temp >> 16) & 65535;               result1 += temp & 65535;               result2 += (result1 >> 16) & 65535;               result1 &= 65535;               result3 = (result2 >> 16) & 65535;               result2 &= 65535;               temp = unchecked(x1 * y1);  // b * d               result3 += (temp >> 16) & 65535;               result2 += temp & 65535;               result3 += (result2 >> 16) & 65535;               result2 &= 65535;               // Add carry               x0 = unchecked((int)(result0 | (result1 << 16)));               x1 = unchecked((int)(result2 | (result3 << 16)));               int x2 = unchecked(x0 + carry);               if (((x2 >> 31) == (x0 >> 31)) ? ((x2 & Int32.MaxValue) < (x0 &               Int32.MaxValue)) : ((x2 >> 31) == 0)) {                 // Carry in addition                 x1 = unchecked(x1 + 1);               }               this.data[i] = x2;               carry = x1;             }           }           if (carry != 0) {             if (this.wordCount >= this.data.Length) {               var newdata = new int[this.wordCount + 20];               Array.Copy(this.data' 0' newdata' 0' this.data.Length);               this.data = newdata;             }             this.data[this.wordCount] = carry;             ++this.wordCount;           }           // Calculate the correct data length           while (this.wordCount != 0 && this.data[this.wordCount - 1] == 0) {             --this.wordCount;           }         } else {           if (this.data.Length > 0) {             this.data[0] = 0;           }           this.wordCount = 0;         }
Magic Number,PeterO.Cbor,MutableNumber,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\FastInteger2.cs,Multiply,The following statement contains a magic number: if (multiplicand != 0) {           var carry = 0;           if (this.wordCount == 0) {             if (this.data.Length == 0) {               this.data = new int[4];             }             this.data[0] = 0;             this.wordCount = 1;           }           int result0' result1' result2' result3;           if (multiplicand < 65536) {             for (var i = 0; i < this.wordCount; ++i) {               int x0 = this.data[i];               int x1 = x0;               int y0 = multiplicand;               x0 &= 65535;               x1 = (x1 >> 16) & 65535;               int temp = unchecked(x0 * y0);  // a * c               result1 = (temp >> 16) & 65535;               result0 = temp & 65535;               result2 = 0;               temp = unchecked(x1 * y0);  // b * c               result2 += (temp >> 16) & 65535;               result1 += temp & 65535;               result2 += (result1 >> 16) & 65535;               result1 &= 65535;               result3 = (result2 >> 16) & 65535;               result2 &= 65535;               // Add carry               x0 = unchecked((int)(result0 | (result1 << 16)));               x1 = unchecked((int)(result2 | (result3 << 16)));               int x2 = unchecked(x0 + carry);               if (((x2 >> 31) == (x0 >> 31)) ? ((x2 & Int32.MaxValue) < (x0 &               Int32.MaxValue)) : ((x2 >> 31) == 0)) {                 // Carry in addition                 x1 = unchecked(x1 + 1);               }               this.data[i] = x2;               carry = x1;             }           } else {             for (var i = 0; i < this.wordCount; ++i) {               int x0 = this.data[i];               int x1 = x0;               int y0 = multiplicand;               int y1 = y0;               x0 &= 65535;               y0 &= 65535;               x1 = (x1 >> 16) & 65535;               y1 = (y1 >> 16) & 65535;               int temp = unchecked(x0 * y0);  // a * c               result1 = (temp >> 16) & 65535;               result0 = temp & 65535;               temp = unchecked(x0 * y1);  // a * d               result2 = (temp >> 16) & 65535;               result1 += temp & 65535;               result2 += (result1 >> 16) & 65535;               result1 &= 65535;               temp = unchecked(x1 * y0);  // b * c               result2 += (temp >> 16) & 65535;               result1 += temp & 65535;               result2 += (result1 >> 16) & 65535;               result1 &= 65535;               result3 = (result2 >> 16) & 65535;               result2 &= 65535;               temp = unchecked(x1 * y1);  // b * d               result3 += (temp >> 16) & 65535;               result2 += temp & 65535;               result3 += (result2 >> 16) & 65535;               result2 &= 65535;               // Add carry               x0 = unchecked((int)(result0 | (result1 << 16)));               x1 = unchecked((int)(result2 | (result3 << 16)));               int x2 = unchecked(x0 + carry);               if (((x2 >> 31) == (x0 >> 31)) ? ((x2 & Int32.MaxValue) < (x0 &               Int32.MaxValue)) : ((x2 >> 31) == 0)) {                 // Carry in addition                 x1 = unchecked(x1 + 1);               }               this.data[i] = x2;               carry = x1;             }           }           if (carry != 0) {             if (this.wordCount >= this.data.Length) {               var newdata = new int[this.wordCount + 20];               Array.Copy(this.data' 0' newdata' 0' this.data.Length);               this.data = newdata;             }             this.data[this.wordCount] = carry;             ++this.wordCount;           }           // Calculate the correct data length           while (this.wordCount != 0 && this.data[this.wordCount - 1] == 0) {             --this.wordCount;           }         } else {           if (this.data.Length > 0) {             this.data[0] = 0;           }           this.wordCount = 0;         }
Magic Number,PeterO.Cbor,MutableNumber,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\FastInteger2.cs,Multiply,The following statement contains a magic number: if (multiplicand != 0) {           var carry = 0;           if (this.wordCount == 0) {             if (this.data.Length == 0) {               this.data = new int[4];             }             this.data[0] = 0;             this.wordCount = 1;           }           int result0' result1' result2' result3;           if (multiplicand < 65536) {             for (var i = 0; i < this.wordCount; ++i) {               int x0 = this.data[i];               int x1 = x0;               int y0 = multiplicand;               x0 &= 65535;               x1 = (x1 >> 16) & 65535;               int temp = unchecked(x0 * y0);  // a * c               result1 = (temp >> 16) & 65535;               result0 = temp & 65535;               result2 = 0;               temp = unchecked(x1 * y0);  // b * c               result2 += (temp >> 16) & 65535;               result1 += temp & 65535;               result2 += (result1 >> 16) & 65535;               result1 &= 65535;               result3 = (result2 >> 16) & 65535;               result2 &= 65535;               // Add carry               x0 = unchecked((int)(result0 | (result1 << 16)));               x1 = unchecked((int)(result2 | (result3 << 16)));               int x2 = unchecked(x0 + carry);               if (((x2 >> 31) == (x0 >> 31)) ? ((x2 & Int32.MaxValue) < (x0 &               Int32.MaxValue)) : ((x2 >> 31) == 0)) {                 // Carry in addition                 x1 = unchecked(x1 + 1);               }               this.data[i] = x2;               carry = x1;             }           } else {             for (var i = 0; i < this.wordCount; ++i) {               int x0 = this.data[i];               int x1 = x0;               int y0 = multiplicand;               int y1 = y0;               x0 &= 65535;               y0 &= 65535;               x1 = (x1 >> 16) & 65535;               y1 = (y1 >> 16) & 65535;               int temp = unchecked(x0 * y0);  // a * c               result1 = (temp >> 16) & 65535;               result0 = temp & 65535;               temp = unchecked(x0 * y1);  // a * d               result2 = (temp >> 16) & 65535;               result1 += temp & 65535;               result2 += (result1 >> 16) & 65535;               result1 &= 65535;               temp = unchecked(x1 * y0);  // b * c               result2 += (temp >> 16) & 65535;               result1 += temp & 65535;               result2 += (result1 >> 16) & 65535;               result1 &= 65535;               result3 = (result2 >> 16) & 65535;               result2 &= 65535;               temp = unchecked(x1 * y1);  // b * d               result3 += (temp >> 16) & 65535;               result2 += temp & 65535;               result3 += (result2 >> 16) & 65535;               result2 &= 65535;               // Add carry               x0 = unchecked((int)(result0 | (result1 << 16)));               x1 = unchecked((int)(result2 | (result3 << 16)));               int x2 = unchecked(x0 + carry);               if (((x2 >> 31) == (x0 >> 31)) ? ((x2 & Int32.MaxValue) < (x0 &               Int32.MaxValue)) : ((x2 >> 31) == 0)) {                 // Carry in addition                 x1 = unchecked(x1 + 1);               }               this.data[i] = x2;               carry = x1;             }           }           if (carry != 0) {             if (this.wordCount >= this.data.Length) {               var newdata = new int[this.wordCount + 20];               Array.Copy(this.data' 0' newdata' 0' this.data.Length);               this.data = newdata;             }             this.data[this.wordCount] = carry;             ++this.wordCount;           }           // Calculate the correct data length           while (this.wordCount != 0 && this.data[this.wordCount - 1] == 0) {             --this.wordCount;           }         } else {           if (this.data.Length > 0) {             this.data[0] = 0;           }           this.wordCount = 0;         }
Magic Number,PeterO.Cbor,MutableNumber,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\FastInteger2.cs,Multiply,The following statement contains a magic number: if (multiplicand != 0) {           var carry = 0;           if (this.wordCount == 0) {             if (this.data.Length == 0) {               this.data = new int[4];             }             this.data[0] = 0;             this.wordCount = 1;           }           int result0' result1' result2' result3;           if (multiplicand < 65536) {             for (var i = 0; i < this.wordCount; ++i) {               int x0 = this.data[i];               int x1 = x0;               int y0 = multiplicand;               x0 &= 65535;               x1 = (x1 >> 16) & 65535;               int temp = unchecked(x0 * y0);  // a * c               result1 = (temp >> 16) & 65535;               result0 = temp & 65535;               result2 = 0;               temp = unchecked(x1 * y0);  // b * c               result2 += (temp >> 16) & 65535;               result1 += temp & 65535;               result2 += (result1 >> 16) & 65535;               result1 &= 65535;               result3 = (result2 >> 16) & 65535;               result2 &= 65535;               // Add carry               x0 = unchecked((int)(result0 | (result1 << 16)));               x1 = unchecked((int)(result2 | (result3 << 16)));               int x2 = unchecked(x0 + carry);               if (((x2 >> 31) == (x0 >> 31)) ? ((x2 & Int32.MaxValue) < (x0 &               Int32.MaxValue)) : ((x2 >> 31) == 0)) {                 // Carry in addition                 x1 = unchecked(x1 + 1);               }               this.data[i] = x2;               carry = x1;             }           } else {             for (var i = 0; i < this.wordCount; ++i) {               int x0 = this.data[i];               int x1 = x0;               int y0 = multiplicand;               int y1 = y0;               x0 &= 65535;               y0 &= 65535;               x1 = (x1 >> 16) & 65535;               y1 = (y1 >> 16) & 65535;               int temp = unchecked(x0 * y0);  // a * c               result1 = (temp >> 16) & 65535;               result0 = temp & 65535;               temp = unchecked(x0 * y1);  // a * d               result2 = (temp >> 16) & 65535;               result1 += temp & 65535;               result2 += (result1 >> 16) & 65535;               result1 &= 65535;               temp = unchecked(x1 * y0);  // b * c               result2 += (temp >> 16) & 65535;               result1 += temp & 65535;               result2 += (result1 >> 16) & 65535;               result1 &= 65535;               result3 = (result2 >> 16) & 65535;               result2 &= 65535;               temp = unchecked(x1 * y1);  // b * d               result3 += (temp >> 16) & 65535;               result2 += temp & 65535;               result3 += (result2 >> 16) & 65535;               result2 &= 65535;               // Add carry               x0 = unchecked((int)(result0 | (result1 << 16)));               x1 = unchecked((int)(result2 | (result3 << 16)));               int x2 = unchecked(x0 + carry);               if (((x2 >> 31) == (x0 >> 31)) ? ((x2 & Int32.MaxValue) < (x0 &               Int32.MaxValue)) : ((x2 >> 31) == 0)) {                 // Carry in addition                 x1 = unchecked(x1 + 1);               }               this.data[i] = x2;               carry = x1;             }           }           if (carry != 0) {             if (this.wordCount >= this.data.Length) {               var newdata = new int[this.wordCount + 20];               Array.Copy(this.data' 0' newdata' 0' this.data.Length);               this.data = newdata;             }             this.data[this.wordCount] = carry;             ++this.wordCount;           }           // Calculate the correct data length           while (this.wordCount != 0 && this.data[this.wordCount - 1] == 0) {             --this.wordCount;           }         } else {           if (this.data.Length > 0) {             this.data[0] = 0;           }           this.wordCount = 0;         }
Magic Number,PeterO.Cbor,MutableNumber,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\FastInteger2.cs,Multiply,The following statement contains a magic number: if (multiplicand != 0) {           var carry = 0;           if (this.wordCount == 0) {             if (this.data.Length == 0) {               this.data = new int[4];             }             this.data[0] = 0;             this.wordCount = 1;           }           int result0' result1' result2' result3;           if (multiplicand < 65536) {             for (var i = 0; i < this.wordCount; ++i) {               int x0 = this.data[i];               int x1 = x0;               int y0 = multiplicand;               x0 &= 65535;               x1 = (x1 >> 16) & 65535;               int temp = unchecked(x0 * y0);  // a * c               result1 = (temp >> 16) & 65535;               result0 = temp & 65535;               result2 = 0;               temp = unchecked(x1 * y0);  // b * c               result2 += (temp >> 16) & 65535;               result1 += temp & 65535;               result2 += (result1 >> 16) & 65535;               result1 &= 65535;               result3 = (result2 >> 16) & 65535;               result2 &= 65535;               // Add carry               x0 = unchecked((int)(result0 | (result1 << 16)));               x1 = unchecked((int)(result2 | (result3 << 16)));               int x2 = unchecked(x0 + carry);               if (((x2 >> 31) == (x0 >> 31)) ? ((x2 & Int32.MaxValue) < (x0 &               Int32.MaxValue)) : ((x2 >> 31) == 0)) {                 // Carry in addition                 x1 = unchecked(x1 + 1);               }               this.data[i] = x2;               carry = x1;             }           } else {             for (var i = 0; i < this.wordCount; ++i) {               int x0 = this.data[i];               int x1 = x0;               int y0 = multiplicand;               int y1 = y0;               x0 &= 65535;               y0 &= 65535;               x1 = (x1 >> 16) & 65535;               y1 = (y1 >> 16) & 65535;               int temp = unchecked(x0 * y0);  // a * c               result1 = (temp >> 16) & 65535;               result0 = temp & 65535;               temp = unchecked(x0 * y1);  // a * d               result2 = (temp >> 16) & 65535;               result1 += temp & 65535;               result2 += (result1 >> 16) & 65535;               result1 &= 65535;               temp = unchecked(x1 * y0);  // b * c               result2 += (temp >> 16) & 65535;               result1 += temp & 65535;               result2 += (result1 >> 16) & 65535;               result1 &= 65535;               result3 = (result2 >> 16) & 65535;               result2 &= 65535;               temp = unchecked(x1 * y1);  // b * d               result3 += (temp >> 16) & 65535;               result2 += temp & 65535;               result3 += (result2 >> 16) & 65535;               result2 &= 65535;               // Add carry               x0 = unchecked((int)(result0 | (result1 << 16)));               x1 = unchecked((int)(result2 | (result3 << 16)));               int x2 = unchecked(x0 + carry);               if (((x2 >> 31) == (x0 >> 31)) ? ((x2 & Int32.MaxValue) < (x0 &               Int32.MaxValue)) : ((x2 >> 31) == 0)) {                 // Carry in addition                 x1 = unchecked(x1 + 1);               }               this.data[i] = x2;               carry = x1;             }           }           if (carry != 0) {             if (this.wordCount >= this.data.Length) {               var newdata = new int[this.wordCount + 20];               Array.Copy(this.data' 0' newdata' 0' this.data.Length);               this.data = newdata;             }             this.data[this.wordCount] = carry;             ++this.wordCount;           }           // Calculate the correct data length           while (this.wordCount != 0 && this.data[this.wordCount - 1] == 0) {             --this.wordCount;           }         } else {           if (this.data.Length > 0) {             this.data[0] = 0;           }           this.wordCount = 0;         }
Magic Number,PeterO.Cbor,MutableNumber,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\FastInteger2.cs,Multiply,The following statement contains a magic number: if (multiplicand != 0) {           var carry = 0;           if (this.wordCount == 0) {             if (this.data.Length == 0) {               this.data = new int[4];             }             this.data[0] = 0;             this.wordCount = 1;           }           int result0' result1' result2' result3;           if (multiplicand < 65536) {             for (var i = 0; i < this.wordCount; ++i) {               int x0 = this.data[i];               int x1 = x0;               int y0 = multiplicand;               x0 &= 65535;               x1 = (x1 >> 16) & 65535;               int temp = unchecked(x0 * y0);  // a * c               result1 = (temp >> 16) & 65535;               result0 = temp & 65535;               result2 = 0;               temp = unchecked(x1 * y0);  // b * c               result2 += (temp >> 16) & 65535;               result1 += temp & 65535;               result2 += (result1 >> 16) & 65535;               result1 &= 65535;               result3 = (result2 >> 16) & 65535;               result2 &= 65535;               // Add carry               x0 = unchecked((int)(result0 | (result1 << 16)));               x1 = unchecked((int)(result2 | (result3 << 16)));               int x2 = unchecked(x0 + carry);               if (((x2 >> 31) == (x0 >> 31)) ? ((x2 & Int32.MaxValue) < (x0 &               Int32.MaxValue)) : ((x2 >> 31) == 0)) {                 // Carry in addition                 x1 = unchecked(x1 + 1);               }               this.data[i] = x2;               carry = x1;             }           } else {             for (var i = 0; i < this.wordCount; ++i) {               int x0 = this.data[i];               int x1 = x0;               int y0 = multiplicand;               int y1 = y0;               x0 &= 65535;               y0 &= 65535;               x1 = (x1 >> 16) & 65535;               y1 = (y1 >> 16) & 65535;               int temp = unchecked(x0 * y0);  // a * c               result1 = (temp >> 16) & 65535;               result0 = temp & 65535;               temp = unchecked(x0 * y1);  // a * d               result2 = (temp >> 16) & 65535;               result1 += temp & 65535;               result2 += (result1 >> 16) & 65535;               result1 &= 65535;               temp = unchecked(x1 * y0);  // b * c               result2 += (temp >> 16) & 65535;               result1 += temp & 65535;               result2 += (result1 >> 16) & 65535;               result1 &= 65535;               result3 = (result2 >> 16) & 65535;               result2 &= 65535;               temp = unchecked(x1 * y1);  // b * d               result3 += (temp >> 16) & 65535;               result2 += temp & 65535;               result3 += (result2 >> 16) & 65535;               result2 &= 65535;               // Add carry               x0 = unchecked((int)(result0 | (result1 << 16)));               x1 = unchecked((int)(result2 | (result3 << 16)));               int x2 = unchecked(x0 + carry);               if (((x2 >> 31) == (x0 >> 31)) ? ((x2 & Int32.MaxValue) < (x0 &               Int32.MaxValue)) : ((x2 >> 31) == 0)) {                 // Carry in addition                 x1 = unchecked(x1 + 1);               }               this.data[i] = x2;               carry = x1;             }           }           if (carry != 0) {             if (this.wordCount >= this.data.Length) {               var newdata = new int[this.wordCount + 20];               Array.Copy(this.data' 0' newdata' 0' this.data.Length);               this.data = newdata;             }             this.data[this.wordCount] = carry;             ++this.wordCount;           }           // Calculate the correct data length           while (this.wordCount != 0 && this.data[this.wordCount - 1] == 0) {             --this.wordCount;           }         } else {           if (this.data.Length > 0) {             this.data[0] = 0;           }           this.wordCount = 0;         }
Magic Number,PeterO.Cbor,MutableNumber,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\FastInteger2.cs,Multiply,The following statement contains a magic number: if (multiplicand != 0) {           var carry = 0;           if (this.wordCount == 0) {             if (this.data.Length == 0) {               this.data = new int[4];             }             this.data[0] = 0;             this.wordCount = 1;           }           int result0' result1' result2' result3;           if (multiplicand < 65536) {             for (var i = 0; i < this.wordCount; ++i) {               int x0 = this.data[i];               int x1 = x0;               int y0 = multiplicand;               x0 &= 65535;               x1 = (x1 >> 16) & 65535;               int temp = unchecked(x0 * y0);  // a * c               result1 = (temp >> 16) & 65535;               result0 = temp & 65535;               result2 = 0;               temp = unchecked(x1 * y0);  // b * c               result2 += (temp >> 16) & 65535;               result1 += temp & 65535;               result2 += (result1 >> 16) & 65535;               result1 &= 65535;               result3 = (result2 >> 16) & 65535;               result2 &= 65535;               // Add carry               x0 = unchecked((int)(result0 | (result1 << 16)));               x1 = unchecked((int)(result2 | (result3 << 16)));               int x2 = unchecked(x0 + carry);               if (((x2 >> 31) == (x0 >> 31)) ? ((x2 & Int32.MaxValue) < (x0 &               Int32.MaxValue)) : ((x2 >> 31) == 0)) {                 // Carry in addition                 x1 = unchecked(x1 + 1);               }               this.data[i] = x2;               carry = x1;             }           } else {             for (var i = 0; i < this.wordCount; ++i) {               int x0 = this.data[i];               int x1 = x0;               int y0 = multiplicand;               int y1 = y0;               x0 &= 65535;               y0 &= 65535;               x1 = (x1 >> 16) & 65535;               y1 = (y1 >> 16) & 65535;               int temp = unchecked(x0 * y0);  // a * c               result1 = (temp >> 16) & 65535;               result0 = temp & 65535;               temp = unchecked(x0 * y1);  // a * d               result2 = (temp >> 16) & 65535;               result1 += temp & 65535;               result2 += (result1 >> 16) & 65535;               result1 &= 65535;               temp = unchecked(x1 * y0);  // b * c               result2 += (temp >> 16) & 65535;               result1 += temp & 65535;               result2 += (result1 >> 16) & 65535;               result1 &= 65535;               result3 = (result2 >> 16) & 65535;               result2 &= 65535;               temp = unchecked(x1 * y1);  // b * d               result3 += (temp >> 16) & 65535;               result2 += temp & 65535;               result3 += (result2 >> 16) & 65535;               result2 &= 65535;               // Add carry               x0 = unchecked((int)(result0 | (result1 << 16)));               x1 = unchecked((int)(result2 | (result3 << 16)));               int x2 = unchecked(x0 + carry);               if (((x2 >> 31) == (x0 >> 31)) ? ((x2 & Int32.MaxValue) < (x0 &               Int32.MaxValue)) : ((x2 >> 31) == 0)) {                 // Carry in addition                 x1 = unchecked(x1 + 1);               }               this.data[i] = x2;               carry = x1;             }           }           if (carry != 0) {             if (this.wordCount >= this.data.Length) {               var newdata = new int[this.wordCount + 20];               Array.Copy(this.data' 0' newdata' 0' this.data.Length);               this.data = newdata;             }             this.data[this.wordCount] = carry;             ++this.wordCount;           }           // Calculate the correct data length           while (this.wordCount != 0 && this.data[this.wordCount - 1] == 0) {             --this.wordCount;           }         } else {           if (this.data.Length > 0) {             this.data[0] = 0;           }           this.wordCount = 0;         }
Magic Number,PeterO.Cbor,MutableNumber,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\FastInteger2.cs,Multiply,The following statement contains a magic number: if (multiplicand != 0) {           var carry = 0;           if (this.wordCount == 0) {             if (this.data.Length == 0) {               this.data = new int[4];             }             this.data[0] = 0;             this.wordCount = 1;           }           int result0' result1' result2' result3;           if (multiplicand < 65536) {             for (var i = 0; i < this.wordCount; ++i) {               int x0 = this.data[i];               int x1 = x0;               int y0 = multiplicand;               x0 &= 65535;               x1 = (x1 >> 16) & 65535;               int temp = unchecked(x0 * y0);  // a * c               result1 = (temp >> 16) & 65535;               result0 = temp & 65535;               result2 = 0;               temp = unchecked(x1 * y0);  // b * c               result2 += (temp >> 16) & 65535;               result1 += temp & 65535;               result2 += (result1 >> 16) & 65535;               result1 &= 65535;               result3 = (result2 >> 16) & 65535;               result2 &= 65535;               // Add carry               x0 = unchecked((int)(result0 | (result1 << 16)));               x1 = unchecked((int)(result2 | (result3 << 16)));               int x2 = unchecked(x0 + carry);               if (((x2 >> 31) == (x0 >> 31)) ? ((x2 & Int32.MaxValue) < (x0 &               Int32.MaxValue)) : ((x2 >> 31) == 0)) {                 // Carry in addition                 x1 = unchecked(x1 + 1);               }               this.data[i] = x2;               carry = x1;             }           } else {             for (var i = 0; i < this.wordCount; ++i) {               int x0 = this.data[i];               int x1 = x0;               int y0 = multiplicand;               int y1 = y0;               x0 &= 65535;               y0 &= 65535;               x1 = (x1 >> 16) & 65535;               y1 = (y1 >> 16) & 65535;               int temp = unchecked(x0 * y0);  // a * c               result1 = (temp >> 16) & 65535;               result0 = temp & 65535;               temp = unchecked(x0 * y1);  // a * d               result2 = (temp >> 16) & 65535;               result1 += temp & 65535;               result2 += (result1 >> 16) & 65535;               result1 &= 65535;               temp = unchecked(x1 * y0);  // b * c               result2 += (temp >> 16) & 65535;               result1 += temp & 65535;               result2 += (result1 >> 16) & 65535;               result1 &= 65535;               result3 = (result2 >> 16) & 65535;               result2 &= 65535;               temp = unchecked(x1 * y1);  // b * d               result3 += (temp >> 16) & 65535;               result2 += temp & 65535;               result3 += (result2 >> 16) & 65535;               result2 &= 65535;               // Add carry               x0 = unchecked((int)(result0 | (result1 << 16)));               x1 = unchecked((int)(result2 | (result3 << 16)));               int x2 = unchecked(x0 + carry);               if (((x2 >> 31) == (x0 >> 31)) ? ((x2 & Int32.MaxValue) < (x0 &               Int32.MaxValue)) : ((x2 >> 31) == 0)) {                 // Carry in addition                 x1 = unchecked(x1 + 1);               }               this.data[i] = x2;               carry = x1;             }           }           if (carry != 0) {             if (this.wordCount >= this.data.Length) {               var newdata = new int[this.wordCount + 20];               Array.Copy(this.data' 0' newdata' 0' this.data.Length);               this.data = newdata;             }             this.data[this.wordCount] = carry;             ++this.wordCount;           }           // Calculate the correct data length           while (this.wordCount != 0 && this.data[this.wordCount - 1] == 0) {             --this.wordCount;           }         } else {           if (this.data.Length > 0) {             this.data[0] = 0;           }           this.wordCount = 0;         }
Magic Number,PeterO.Cbor,MutableNumber,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\FastInteger2.cs,Multiply,The following statement contains a magic number: if (multiplicand != 0) {           var carry = 0;           if (this.wordCount == 0) {             if (this.data.Length == 0) {               this.data = new int[4];             }             this.data[0] = 0;             this.wordCount = 1;           }           int result0' result1' result2' result3;           if (multiplicand < 65536) {             for (var i = 0; i < this.wordCount; ++i) {               int x0 = this.data[i];               int x1 = x0;               int y0 = multiplicand;               x0 &= 65535;               x1 = (x1 >> 16) & 65535;               int temp = unchecked(x0 * y0);  // a * c               result1 = (temp >> 16) & 65535;               result0 = temp & 65535;               result2 = 0;               temp = unchecked(x1 * y0);  // b * c               result2 += (temp >> 16) & 65535;               result1 += temp & 65535;               result2 += (result1 >> 16) & 65535;               result1 &= 65535;               result3 = (result2 >> 16) & 65535;               result2 &= 65535;               // Add carry               x0 = unchecked((int)(result0 | (result1 << 16)));               x1 = unchecked((int)(result2 | (result3 << 16)));               int x2 = unchecked(x0 + carry);               if (((x2 >> 31) == (x0 >> 31)) ? ((x2 & Int32.MaxValue) < (x0 &               Int32.MaxValue)) : ((x2 >> 31) == 0)) {                 // Carry in addition                 x1 = unchecked(x1 + 1);               }               this.data[i] = x2;               carry = x1;             }           } else {             for (var i = 0; i < this.wordCount; ++i) {               int x0 = this.data[i];               int x1 = x0;               int y0 = multiplicand;               int y1 = y0;               x0 &= 65535;               y0 &= 65535;               x1 = (x1 >> 16) & 65535;               y1 = (y1 >> 16) & 65535;               int temp = unchecked(x0 * y0);  // a * c               result1 = (temp >> 16) & 65535;               result0 = temp & 65535;               temp = unchecked(x0 * y1);  // a * d               result2 = (temp >> 16) & 65535;               result1 += temp & 65535;               result2 += (result1 >> 16) & 65535;               result1 &= 65535;               temp = unchecked(x1 * y0);  // b * c               result2 += (temp >> 16) & 65535;               result1 += temp & 65535;               result2 += (result1 >> 16) & 65535;               result1 &= 65535;               result3 = (result2 >> 16) & 65535;               result2 &= 65535;               temp = unchecked(x1 * y1);  // b * d               result3 += (temp >> 16) & 65535;               result2 += temp & 65535;               result3 += (result2 >> 16) & 65535;               result2 &= 65535;               // Add carry               x0 = unchecked((int)(result0 | (result1 << 16)));               x1 = unchecked((int)(result2 | (result3 << 16)));               int x2 = unchecked(x0 + carry);               if (((x2 >> 31) == (x0 >> 31)) ? ((x2 & Int32.MaxValue) < (x0 &               Int32.MaxValue)) : ((x2 >> 31) == 0)) {                 // Carry in addition                 x1 = unchecked(x1 + 1);               }               this.data[i] = x2;               carry = x1;             }           }           if (carry != 0) {             if (this.wordCount >= this.data.Length) {               var newdata = new int[this.wordCount + 20];               Array.Copy(this.data' 0' newdata' 0' this.data.Length);               this.data = newdata;             }             this.data[this.wordCount] = carry;             ++this.wordCount;           }           // Calculate the correct data length           while (this.wordCount != 0 && this.data[this.wordCount - 1] == 0) {             --this.wordCount;           }         } else {           if (this.data.Length > 0) {             this.data[0] = 0;           }           this.wordCount = 0;         }
Magic Number,PeterO.Cbor,MutableNumber,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\FastInteger2.cs,Multiply,The following statement contains a magic number: if (multiplicand != 0) {           var carry = 0;           if (this.wordCount == 0) {             if (this.data.Length == 0) {               this.data = new int[4];             }             this.data[0] = 0;             this.wordCount = 1;           }           int result0' result1' result2' result3;           if (multiplicand < 65536) {             for (var i = 0; i < this.wordCount; ++i) {               int x0 = this.data[i];               int x1 = x0;               int y0 = multiplicand;               x0 &= 65535;               x1 = (x1 >> 16) & 65535;               int temp = unchecked(x0 * y0);  // a * c               result1 = (temp >> 16) & 65535;               result0 = temp & 65535;               result2 = 0;               temp = unchecked(x1 * y0);  // b * c               result2 += (temp >> 16) & 65535;               result1 += temp & 65535;               result2 += (result1 >> 16) & 65535;               result1 &= 65535;               result3 = (result2 >> 16) & 65535;               result2 &= 65535;               // Add carry               x0 = unchecked((int)(result0 | (result1 << 16)));               x1 = unchecked((int)(result2 | (result3 << 16)));               int x2 = unchecked(x0 + carry);               if (((x2 >> 31) == (x0 >> 31)) ? ((x2 & Int32.MaxValue) < (x0 &               Int32.MaxValue)) : ((x2 >> 31) == 0)) {                 // Carry in addition                 x1 = unchecked(x1 + 1);               }               this.data[i] = x2;               carry = x1;             }           } else {             for (var i = 0; i < this.wordCount; ++i) {               int x0 = this.data[i];               int x1 = x0;               int y0 = multiplicand;               int y1 = y0;               x0 &= 65535;               y0 &= 65535;               x1 = (x1 >> 16) & 65535;               y1 = (y1 >> 16) & 65535;               int temp = unchecked(x0 * y0);  // a * c               result1 = (temp >> 16) & 65535;               result0 = temp & 65535;               temp = unchecked(x0 * y1);  // a * d               result2 = (temp >> 16) & 65535;               result1 += temp & 65535;               result2 += (result1 >> 16) & 65535;               result1 &= 65535;               temp = unchecked(x1 * y0);  // b * c               result2 += (temp >> 16) & 65535;               result1 += temp & 65535;               result2 += (result1 >> 16) & 65535;               result1 &= 65535;               result3 = (result2 >> 16) & 65535;               result2 &= 65535;               temp = unchecked(x1 * y1);  // b * d               result3 += (temp >> 16) & 65535;               result2 += temp & 65535;               result3 += (result2 >> 16) & 65535;               result2 &= 65535;               // Add carry               x0 = unchecked((int)(result0 | (result1 << 16)));               x1 = unchecked((int)(result2 | (result3 << 16)));               int x2 = unchecked(x0 + carry);               if (((x2 >> 31) == (x0 >> 31)) ? ((x2 & Int32.MaxValue) < (x0 &               Int32.MaxValue)) : ((x2 >> 31) == 0)) {                 // Carry in addition                 x1 = unchecked(x1 + 1);               }               this.data[i] = x2;               carry = x1;             }           }           if (carry != 0) {             if (this.wordCount >= this.data.Length) {               var newdata = new int[this.wordCount + 20];               Array.Copy(this.data' 0' newdata' 0' this.data.Length);               this.data = newdata;             }             this.data[this.wordCount] = carry;             ++this.wordCount;           }           // Calculate the correct data length           while (this.wordCount != 0 && this.data[this.wordCount - 1] == 0) {             --this.wordCount;           }         } else {           if (this.data.Length > 0) {             this.data[0] = 0;           }           this.wordCount = 0;         }
Magic Number,PeterO.Cbor,MutableNumber,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\FastInteger2.cs,Multiply,The following statement contains a magic number: if (multiplicand != 0) {           var carry = 0;           if (this.wordCount == 0) {             if (this.data.Length == 0) {               this.data = new int[4];             }             this.data[0] = 0;             this.wordCount = 1;           }           int result0' result1' result2' result3;           if (multiplicand < 65536) {             for (var i = 0; i < this.wordCount; ++i) {               int x0 = this.data[i];               int x1 = x0;               int y0 = multiplicand;               x0 &= 65535;               x1 = (x1 >> 16) & 65535;               int temp = unchecked(x0 * y0);  // a * c               result1 = (temp >> 16) & 65535;               result0 = temp & 65535;               result2 = 0;               temp = unchecked(x1 * y0);  // b * c               result2 += (temp >> 16) & 65535;               result1 += temp & 65535;               result2 += (result1 >> 16) & 65535;               result1 &= 65535;               result3 = (result2 >> 16) & 65535;               result2 &= 65535;               // Add carry               x0 = unchecked((int)(result0 | (result1 << 16)));               x1 = unchecked((int)(result2 | (result3 << 16)));               int x2 = unchecked(x0 + carry);               if (((x2 >> 31) == (x0 >> 31)) ? ((x2 & Int32.MaxValue) < (x0 &               Int32.MaxValue)) : ((x2 >> 31) == 0)) {                 // Carry in addition                 x1 = unchecked(x1 + 1);               }               this.data[i] = x2;               carry = x1;             }           } else {             for (var i = 0; i < this.wordCount; ++i) {               int x0 = this.data[i];               int x1 = x0;               int y0 = multiplicand;               int y1 = y0;               x0 &= 65535;               y0 &= 65535;               x1 = (x1 >> 16) & 65535;               y1 = (y1 >> 16) & 65535;               int temp = unchecked(x0 * y0);  // a * c               result1 = (temp >> 16) & 65535;               result0 = temp & 65535;               temp = unchecked(x0 * y1);  // a * d               result2 = (temp >> 16) & 65535;               result1 += temp & 65535;               result2 += (result1 >> 16) & 65535;               result1 &= 65535;               temp = unchecked(x1 * y0);  // b * c               result2 += (temp >> 16) & 65535;               result1 += temp & 65535;               result2 += (result1 >> 16) & 65535;               result1 &= 65535;               result3 = (result2 >> 16) & 65535;               result2 &= 65535;               temp = unchecked(x1 * y1);  // b * d               result3 += (temp >> 16) & 65535;               result2 += temp & 65535;               result3 += (result2 >> 16) & 65535;               result2 &= 65535;               // Add carry               x0 = unchecked((int)(result0 | (result1 << 16)));               x1 = unchecked((int)(result2 | (result3 << 16)));               int x2 = unchecked(x0 + carry);               if (((x2 >> 31) == (x0 >> 31)) ? ((x2 & Int32.MaxValue) < (x0 &               Int32.MaxValue)) : ((x2 >> 31) == 0)) {                 // Carry in addition                 x1 = unchecked(x1 + 1);               }               this.data[i] = x2;               carry = x1;             }           }           if (carry != 0) {             if (this.wordCount >= this.data.Length) {               var newdata = new int[this.wordCount + 20];               Array.Copy(this.data' 0' newdata' 0' this.data.Length);               this.data = newdata;             }             this.data[this.wordCount] = carry;             ++this.wordCount;           }           // Calculate the correct data length           while (this.wordCount != 0 && this.data[this.wordCount - 1] == 0) {             --this.wordCount;           }         } else {           if (this.data.Length > 0) {             this.data[0] = 0;           }           this.wordCount = 0;         }
Magic Number,PeterO.Cbor,MutableNumber,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\FastInteger2.cs,Multiply,The following statement contains a magic number: if (multiplicand != 0) {           var carry = 0;           if (this.wordCount == 0) {             if (this.data.Length == 0) {               this.data = new int[4];             }             this.data[0] = 0;             this.wordCount = 1;           }           int result0' result1' result2' result3;           if (multiplicand < 65536) {             for (var i = 0; i < this.wordCount; ++i) {               int x0 = this.data[i];               int x1 = x0;               int y0 = multiplicand;               x0 &= 65535;               x1 = (x1 >> 16) & 65535;               int temp = unchecked(x0 * y0);  // a * c               result1 = (temp >> 16) & 65535;               result0 = temp & 65535;               result2 = 0;               temp = unchecked(x1 * y0);  // b * c               result2 += (temp >> 16) & 65535;               result1 += temp & 65535;               result2 += (result1 >> 16) & 65535;               result1 &= 65535;               result3 = (result2 >> 16) & 65535;               result2 &= 65535;               // Add carry               x0 = unchecked((int)(result0 | (result1 << 16)));               x1 = unchecked((int)(result2 | (result3 << 16)));               int x2 = unchecked(x0 + carry);               if (((x2 >> 31) == (x0 >> 31)) ? ((x2 & Int32.MaxValue) < (x0 &               Int32.MaxValue)) : ((x2 >> 31) == 0)) {                 // Carry in addition                 x1 = unchecked(x1 + 1);               }               this.data[i] = x2;               carry = x1;             }           } else {             for (var i = 0; i < this.wordCount; ++i) {               int x0 = this.data[i];               int x1 = x0;               int y0 = multiplicand;               int y1 = y0;               x0 &= 65535;               y0 &= 65535;               x1 = (x1 >> 16) & 65535;               y1 = (y1 >> 16) & 65535;               int temp = unchecked(x0 * y0);  // a * c               result1 = (temp >> 16) & 65535;               result0 = temp & 65535;               temp = unchecked(x0 * y1);  // a * d               result2 = (temp >> 16) & 65535;               result1 += temp & 65535;               result2 += (result1 >> 16) & 65535;               result1 &= 65535;               temp = unchecked(x1 * y0);  // b * c               result2 += (temp >> 16) & 65535;               result1 += temp & 65535;               result2 += (result1 >> 16) & 65535;               result1 &= 65535;               result3 = (result2 >> 16) & 65535;               result2 &= 65535;               temp = unchecked(x1 * y1);  // b * d               result3 += (temp >> 16) & 65535;               result2 += temp & 65535;               result3 += (result2 >> 16) & 65535;               result2 &= 65535;               // Add carry               x0 = unchecked((int)(result0 | (result1 << 16)));               x1 = unchecked((int)(result2 | (result3 << 16)));               int x2 = unchecked(x0 + carry);               if (((x2 >> 31) == (x0 >> 31)) ? ((x2 & Int32.MaxValue) < (x0 &               Int32.MaxValue)) : ((x2 >> 31) == 0)) {                 // Carry in addition                 x1 = unchecked(x1 + 1);               }               this.data[i] = x2;               carry = x1;             }           }           if (carry != 0) {             if (this.wordCount >= this.data.Length) {               var newdata = new int[this.wordCount + 20];               Array.Copy(this.data' 0' newdata' 0' this.data.Length);               this.data = newdata;             }             this.data[this.wordCount] = carry;             ++this.wordCount;           }           // Calculate the correct data length           while (this.wordCount != 0 && this.data[this.wordCount - 1] == 0) {             --this.wordCount;           }         } else {           if (this.data.Length > 0) {             this.data[0] = 0;           }           this.wordCount = 0;         }
Magic Number,PeterO.Cbor,MutableNumber,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\FastInteger2.cs,Multiply,The following statement contains a magic number: if (multiplicand != 0) {           var carry = 0;           if (this.wordCount == 0) {             if (this.data.Length == 0) {               this.data = new int[4];             }             this.data[0] = 0;             this.wordCount = 1;           }           int result0' result1' result2' result3;           if (multiplicand < 65536) {             for (var i = 0; i < this.wordCount; ++i) {               int x0 = this.data[i];               int x1 = x0;               int y0 = multiplicand;               x0 &= 65535;               x1 = (x1 >> 16) & 65535;               int temp = unchecked(x0 * y0);  // a * c               result1 = (temp >> 16) & 65535;               result0 = temp & 65535;               result2 = 0;               temp = unchecked(x1 * y0);  // b * c               result2 += (temp >> 16) & 65535;               result1 += temp & 65535;               result2 += (result1 >> 16) & 65535;               result1 &= 65535;               result3 = (result2 >> 16) & 65535;               result2 &= 65535;               // Add carry               x0 = unchecked((int)(result0 | (result1 << 16)));               x1 = unchecked((int)(result2 | (result3 << 16)));               int x2 = unchecked(x0 + carry);               if (((x2 >> 31) == (x0 >> 31)) ? ((x2 & Int32.MaxValue) < (x0 &               Int32.MaxValue)) : ((x2 >> 31) == 0)) {                 // Carry in addition                 x1 = unchecked(x1 + 1);               }               this.data[i] = x2;               carry = x1;             }           } else {             for (var i = 0; i < this.wordCount; ++i) {               int x0 = this.data[i];               int x1 = x0;               int y0 = multiplicand;               int y1 = y0;               x0 &= 65535;               y0 &= 65535;               x1 = (x1 >> 16) & 65535;               y1 = (y1 >> 16) & 65535;               int temp = unchecked(x0 * y0);  // a * c               result1 = (temp >> 16) & 65535;               result0 = temp & 65535;               temp = unchecked(x0 * y1);  // a * d               result2 = (temp >> 16) & 65535;               result1 += temp & 65535;               result2 += (result1 >> 16) & 65535;               result1 &= 65535;               temp = unchecked(x1 * y0);  // b * c               result2 += (temp >> 16) & 65535;               result1 += temp & 65535;               result2 += (result1 >> 16) & 65535;               result1 &= 65535;               result3 = (result2 >> 16) & 65535;               result2 &= 65535;               temp = unchecked(x1 * y1);  // b * d               result3 += (temp >> 16) & 65535;               result2 += temp & 65535;               result3 += (result2 >> 16) & 65535;               result2 &= 65535;               // Add carry               x0 = unchecked((int)(result0 | (result1 << 16)));               x1 = unchecked((int)(result2 | (result3 << 16)));               int x2 = unchecked(x0 + carry);               if (((x2 >> 31) == (x0 >> 31)) ? ((x2 & Int32.MaxValue) < (x0 &               Int32.MaxValue)) : ((x2 >> 31) == 0)) {                 // Carry in addition                 x1 = unchecked(x1 + 1);               }               this.data[i] = x2;               carry = x1;             }           }           if (carry != 0) {             if (this.wordCount >= this.data.Length) {               var newdata = new int[this.wordCount + 20];               Array.Copy(this.data' 0' newdata' 0' this.data.Length);               this.data = newdata;             }             this.data[this.wordCount] = carry;             ++this.wordCount;           }           // Calculate the correct data length           while (this.wordCount != 0 && this.data[this.wordCount - 1] == 0) {             --this.wordCount;           }         } else {           if (this.data.Length > 0) {             this.data[0] = 0;           }           this.wordCount = 0;         }
Magic Number,PeterO.Cbor,MutableNumber,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\FastInteger2.cs,Multiply,The following statement contains a magic number: if (multiplicand != 0) {           var carry = 0;           if (this.wordCount == 0) {             if (this.data.Length == 0) {               this.data = new int[4];             }             this.data[0] = 0;             this.wordCount = 1;           }           int result0' result1' result2' result3;           if (multiplicand < 65536) {             for (var i = 0; i < this.wordCount; ++i) {               int x0 = this.data[i];               int x1 = x0;               int y0 = multiplicand;               x0 &= 65535;               x1 = (x1 >> 16) & 65535;               int temp = unchecked(x0 * y0);  // a * c               result1 = (temp >> 16) & 65535;               result0 = temp & 65535;               result2 = 0;               temp = unchecked(x1 * y0);  // b * c               result2 += (temp >> 16) & 65535;               result1 += temp & 65535;               result2 += (result1 >> 16) & 65535;               result1 &= 65535;               result3 = (result2 >> 16) & 65535;               result2 &= 65535;               // Add carry               x0 = unchecked((int)(result0 | (result1 << 16)));               x1 = unchecked((int)(result2 | (result3 << 16)));               int x2 = unchecked(x0 + carry);               if (((x2 >> 31) == (x0 >> 31)) ? ((x2 & Int32.MaxValue) < (x0 &               Int32.MaxValue)) : ((x2 >> 31) == 0)) {                 // Carry in addition                 x1 = unchecked(x1 + 1);               }               this.data[i] = x2;               carry = x1;             }           } else {             for (var i = 0; i < this.wordCount; ++i) {               int x0 = this.data[i];               int x1 = x0;               int y0 = multiplicand;               int y1 = y0;               x0 &= 65535;               y0 &= 65535;               x1 = (x1 >> 16) & 65535;               y1 = (y1 >> 16) & 65535;               int temp = unchecked(x0 * y0);  // a * c               result1 = (temp >> 16) & 65535;               result0 = temp & 65535;               temp = unchecked(x0 * y1);  // a * d               result2 = (temp >> 16) & 65535;               result1 += temp & 65535;               result2 += (result1 >> 16) & 65535;               result1 &= 65535;               temp = unchecked(x1 * y0);  // b * c               result2 += (temp >> 16) & 65535;               result1 += temp & 65535;               result2 += (result1 >> 16) & 65535;               result1 &= 65535;               result3 = (result2 >> 16) & 65535;               result2 &= 65535;               temp = unchecked(x1 * y1);  // b * d               result3 += (temp >> 16) & 65535;               result2 += temp & 65535;               result3 += (result2 >> 16) & 65535;               result2 &= 65535;               // Add carry               x0 = unchecked((int)(result0 | (result1 << 16)));               x1 = unchecked((int)(result2 | (result3 << 16)));               int x2 = unchecked(x0 + carry);               if (((x2 >> 31) == (x0 >> 31)) ? ((x2 & Int32.MaxValue) < (x0 &               Int32.MaxValue)) : ((x2 >> 31) == 0)) {                 // Carry in addition                 x1 = unchecked(x1 + 1);               }               this.data[i] = x2;               carry = x1;             }           }           if (carry != 0) {             if (this.wordCount >= this.data.Length) {               var newdata = new int[this.wordCount + 20];               Array.Copy(this.data' 0' newdata' 0' this.data.Length);               this.data = newdata;             }             this.data[this.wordCount] = carry;             ++this.wordCount;           }           // Calculate the correct data length           while (this.wordCount != 0 && this.data[this.wordCount - 1] == 0) {             --this.wordCount;           }         } else {           if (this.data.Length > 0) {             this.data[0] = 0;           }           this.wordCount = 0;         }
Magic Number,PeterO.Cbor,MutableNumber,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\FastInteger2.cs,Multiply,The following statement contains a magic number: if (multiplicand != 0) {           var carry = 0;           if (this.wordCount == 0) {             if (this.data.Length == 0) {               this.data = new int[4];             }             this.data[0] = 0;             this.wordCount = 1;           }           int result0' result1' result2' result3;           if (multiplicand < 65536) {             for (var i = 0; i < this.wordCount; ++i) {               int x0 = this.data[i];               int x1 = x0;               int y0 = multiplicand;               x0 &= 65535;               x1 = (x1 >> 16) & 65535;               int temp = unchecked(x0 * y0);  // a * c               result1 = (temp >> 16) & 65535;               result0 = temp & 65535;               result2 = 0;               temp = unchecked(x1 * y0);  // b * c               result2 += (temp >> 16) & 65535;               result1 += temp & 65535;               result2 += (result1 >> 16) & 65535;               result1 &= 65535;               result3 = (result2 >> 16) & 65535;               result2 &= 65535;               // Add carry               x0 = unchecked((int)(result0 | (result1 << 16)));               x1 = unchecked((int)(result2 | (result3 << 16)));               int x2 = unchecked(x0 + carry);               if (((x2 >> 31) == (x0 >> 31)) ? ((x2 & Int32.MaxValue) < (x0 &               Int32.MaxValue)) : ((x2 >> 31) == 0)) {                 // Carry in addition                 x1 = unchecked(x1 + 1);               }               this.data[i] = x2;               carry = x1;             }           } else {             for (var i = 0; i < this.wordCount; ++i) {               int x0 = this.data[i];               int x1 = x0;               int y0 = multiplicand;               int y1 = y0;               x0 &= 65535;               y0 &= 65535;               x1 = (x1 >> 16) & 65535;               y1 = (y1 >> 16) & 65535;               int temp = unchecked(x0 * y0);  // a * c               result1 = (temp >> 16) & 65535;               result0 = temp & 65535;               temp = unchecked(x0 * y1);  // a * d               result2 = (temp >> 16) & 65535;               result1 += temp & 65535;               result2 += (result1 >> 16) & 65535;               result1 &= 65535;               temp = unchecked(x1 * y0);  // b * c               result2 += (temp >> 16) & 65535;               result1 += temp & 65535;               result2 += (result1 >> 16) & 65535;               result1 &= 65535;               result3 = (result2 >> 16) & 65535;               result2 &= 65535;               temp = unchecked(x1 * y1);  // b * d               result3 += (temp >> 16) & 65535;               result2 += temp & 65535;               result3 += (result2 >> 16) & 65535;               result2 &= 65535;               // Add carry               x0 = unchecked((int)(result0 | (result1 << 16)));               x1 = unchecked((int)(result2 | (result3 << 16)));               int x2 = unchecked(x0 + carry);               if (((x2 >> 31) == (x0 >> 31)) ? ((x2 & Int32.MaxValue) < (x0 &               Int32.MaxValue)) : ((x2 >> 31) == 0)) {                 // Carry in addition                 x1 = unchecked(x1 + 1);               }               this.data[i] = x2;               carry = x1;             }           }           if (carry != 0) {             if (this.wordCount >= this.data.Length) {               var newdata = new int[this.wordCount + 20];               Array.Copy(this.data' 0' newdata' 0' this.data.Length);               this.data = newdata;             }             this.data[this.wordCount] = carry;             ++this.wordCount;           }           // Calculate the correct data length           while (this.wordCount != 0 && this.data[this.wordCount - 1] == 0) {             --this.wordCount;           }         } else {           if (this.data.Length > 0) {             this.data[0] = 0;           }           this.wordCount = 0;         }
Magic Number,PeterO.Cbor,MutableNumber,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\FastInteger2.cs,Multiply,The following statement contains a magic number: if (multiplicand != 0) {           var carry = 0;           if (this.wordCount == 0) {             if (this.data.Length == 0) {               this.data = new int[4];             }             this.data[0] = 0;             this.wordCount = 1;           }           int result0' result1' result2' result3;           if (multiplicand < 65536) {             for (var i = 0; i < this.wordCount; ++i) {               int x0 = this.data[i];               int x1 = x0;               int y0 = multiplicand;               x0 &= 65535;               x1 = (x1 >> 16) & 65535;               int temp = unchecked(x0 * y0);  // a * c               result1 = (temp >> 16) & 65535;               result0 = temp & 65535;               result2 = 0;               temp = unchecked(x1 * y0);  // b * c               result2 += (temp >> 16) & 65535;               result1 += temp & 65535;               result2 += (result1 >> 16) & 65535;               result1 &= 65535;               result3 = (result2 >> 16) & 65535;               result2 &= 65535;               // Add carry               x0 = unchecked((int)(result0 | (result1 << 16)));               x1 = unchecked((int)(result2 | (result3 << 16)));               int x2 = unchecked(x0 + carry);               if (((x2 >> 31) == (x0 >> 31)) ? ((x2 & Int32.MaxValue) < (x0 &               Int32.MaxValue)) : ((x2 >> 31) == 0)) {                 // Carry in addition                 x1 = unchecked(x1 + 1);               }               this.data[i] = x2;               carry = x1;             }           } else {             for (var i = 0; i < this.wordCount; ++i) {               int x0 = this.data[i];               int x1 = x0;               int y0 = multiplicand;               int y1 = y0;               x0 &= 65535;               y0 &= 65535;               x1 = (x1 >> 16) & 65535;               y1 = (y1 >> 16) & 65535;               int temp = unchecked(x0 * y0);  // a * c               result1 = (temp >> 16) & 65535;               result0 = temp & 65535;               temp = unchecked(x0 * y1);  // a * d               result2 = (temp >> 16) & 65535;               result1 += temp & 65535;               result2 += (result1 >> 16) & 65535;               result1 &= 65535;               temp = unchecked(x1 * y0);  // b * c               result2 += (temp >> 16) & 65535;               result1 += temp & 65535;               result2 += (result1 >> 16) & 65535;               result1 &= 65535;               result3 = (result2 >> 16) & 65535;               result2 &= 65535;               temp = unchecked(x1 * y1);  // b * d               result3 += (temp >> 16) & 65535;               result2 += temp & 65535;               result3 += (result2 >> 16) & 65535;               result2 &= 65535;               // Add carry               x0 = unchecked((int)(result0 | (result1 << 16)));               x1 = unchecked((int)(result2 | (result3 << 16)));               int x2 = unchecked(x0 + carry);               if (((x2 >> 31) == (x0 >> 31)) ? ((x2 & Int32.MaxValue) < (x0 &               Int32.MaxValue)) : ((x2 >> 31) == 0)) {                 // Carry in addition                 x1 = unchecked(x1 + 1);               }               this.data[i] = x2;               carry = x1;             }           }           if (carry != 0) {             if (this.wordCount >= this.data.Length) {               var newdata = new int[this.wordCount + 20];               Array.Copy(this.data' 0' newdata' 0' this.data.Length);               this.data = newdata;             }             this.data[this.wordCount] = carry;             ++this.wordCount;           }           // Calculate the correct data length           while (this.wordCount != 0 && this.data[this.wordCount - 1] == 0) {             --this.wordCount;           }         } else {           if (this.data.Length > 0) {             this.data[0] = 0;           }           this.wordCount = 0;         }
Magic Number,PeterO.Cbor,MutableNumber,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\FastInteger2.cs,Multiply,The following statement contains a magic number: if (multiplicand != 0) {           var carry = 0;           if (this.wordCount == 0) {             if (this.data.Length == 0) {               this.data = new int[4];             }             this.data[0] = 0;             this.wordCount = 1;           }           int result0' result1' result2' result3;           if (multiplicand < 65536) {             for (var i = 0; i < this.wordCount; ++i) {               int x0 = this.data[i];               int x1 = x0;               int y0 = multiplicand;               x0 &= 65535;               x1 = (x1 >> 16) & 65535;               int temp = unchecked(x0 * y0);  // a * c               result1 = (temp >> 16) & 65535;               result0 = temp & 65535;               result2 = 0;               temp = unchecked(x1 * y0);  // b * c               result2 += (temp >> 16) & 65535;               result1 += temp & 65535;               result2 += (result1 >> 16) & 65535;               result1 &= 65535;               result3 = (result2 >> 16) & 65535;               result2 &= 65535;               // Add carry               x0 = unchecked((int)(result0 | (result1 << 16)));               x1 = unchecked((int)(result2 | (result3 << 16)));               int x2 = unchecked(x0 + carry);               if (((x2 >> 31) == (x0 >> 31)) ? ((x2 & Int32.MaxValue) < (x0 &               Int32.MaxValue)) : ((x2 >> 31) == 0)) {                 // Carry in addition                 x1 = unchecked(x1 + 1);               }               this.data[i] = x2;               carry = x1;             }           } else {             for (var i = 0; i < this.wordCount; ++i) {               int x0 = this.data[i];               int x1 = x0;               int y0 = multiplicand;               int y1 = y0;               x0 &= 65535;               y0 &= 65535;               x1 = (x1 >> 16) & 65535;               y1 = (y1 >> 16) & 65535;               int temp = unchecked(x0 * y0);  // a * c               result1 = (temp >> 16) & 65535;               result0 = temp & 65535;               temp = unchecked(x0 * y1);  // a * d               result2 = (temp >> 16) & 65535;               result1 += temp & 65535;               result2 += (result1 >> 16) & 65535;               result1 &= 65535;               temp = unchecked(x1 * y0);  // b * c               result2 += (temp >> 16) & 65535;               result1 += temp & 65535;               result2 += (result1 >> 16) & 65535;               result1 &= 65535;               result3 = (result2 >> 16) & 65535;               result2 &= 65535;               temp = unchecked(x1 * y1);  // b * d               result3 += (temp >> 16) & 65535;               result2 += temp & 65535;               result3 += (result2 >> 16) & 65535;               result2 &= 65535;               // Add carry               x0 = unchecked((int)(result0 | (result1 << 16)));               x1 = unchecked((int)(result2 | (result3 << 16)));               int x2 = unchecked(x0 + carry);               if (((x2 >> 31) == (x0 >> 31)) ? ((x2 & Int32.MaxValue) < (x0 &               Int32.MaxValue)) : ((x2 >> 31) == 0)) {                 // Carry in addition                 x1 = unchecked(x1 + 1);               }               this.data[i] = x2;               carry = x1;             }           }           if (carry != 0) {             if (this.wordCount >= this.data.Length) {               var newdata = new int[this.wordCount + 20];               Array.Copy(this.data' 0' newdata' 0' this.data.Length);               this.data = newdata;             }             this.data[this.wordCount] = carry;             ++this.wordCount;           }           // Calculate the correct data length           while (this.wordCount != 0 && this.data[this.wordCount - 1] == 0) {             --this.wordCount;           }         } else {           if (this.data.Length > 0) {             this.data[0] = 0;           }           this.wordCount = 0;         }
Magic Number,PeterO.Cbor,MutableNumber,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\FastInteger2.cs,Multiply,The following statement contains a magic number: if (multiplicand != 0) {           var carry = 0;           if (this.wordCount == 0) {             if (this.data.Length == 0) {               this.data = new int[4];             }             this.data[0] = 0;             this.wordCount = 1;           }           int result0' result1' result2' result3;           if (multiplicand < 65536) {             for (var i = 0; i < this.wordCount; ++i) {               int x0 = this.data[i];               int x1 = x0;               int y0 = multiplicand;               x0 &= 65535;               x1 = (x1 >> 16) & 65535;               int temp = unchecked(x0 * y0);  // a * c               result1 = (temp >> 16) & 65535;               result0 = temp & 65535;               result2 = 0;               temp = unchecked(x1 * y0);  // b * c               result2 += (temp >> 16) & 65535;               result1 += temp & 65535;               result2 += (result1 >> 16) & 65535;               result1 &= 65535;               result3 = (result2 >> 16) & 65535;               result2 &= 65535;               // Add carry               x0 = unchecked((int)(result0 | (result1 << 16)));               x1 = unchecked((int)(result2 | (result3 << 16)));               int x2 = unchecked(x0 + carry);               if (((x2 >> 31) == (x0 >> 31)) ? ((x2 & Int32.MaxValue) < (x0 &               Int32.MaxValue)) : ((x2 >> 31) == 0)) {                 // Carry in addition                 x1 = unchecked(x1 + 1);               }               this.data[i] = x2;               carry = x1;             }           } else {             for (var i = 0; i < this.wordCount; ++i) {               int x0 = this.data[i];               int x1 = x0;               int y0 = multiplicand;               int y1 = y0;               x0 &= 65535;               y0 &= 65535;               x1 = (x1 >> 16) & 65535;               y1 = (y1 >> 16) & 65535;               int temp = unchecked(x0 * y0);  // a * c               result1 = (temp >> 16) & 65535;               result0 = temp & 65535;               temp = unchecked(x0 * y1);  // a * d               result2 = (temp >> 16) & 65535;               result1 += temp & 65535;               result2 += (result1 >> 16) & 65535;               result1 &= 65535;               temp = unchecked(x1 * y0);  // b * c               result2 += (temp >> 16) & 65535;               result1 += temp & 65535;               result2 += (result1 >> 16) & 65535;               result1 &= 65535;               result3 = (result2 >> 16) & 65535;               result2 &= 65535;               temp = unchecked(x1 * y1);  // b * d               result3 += (temp >> 16) & 65535;               result2 += temp & 65535;               result3 += (result2 >> 16) & 65535;               result2 &= 65535;               // Add carry               x0 = unchecked((int)(result0 | (result1 << 16)));               x1 = unchecked((int)(result2 | (result3 << 16)));               int x2 = unchecked(x0 + carry);               if (((x2 >> 31) == (x0 >> 31)) ? ((x2 & Int32.MaxValue) < (x0 &               Int32.MaxValue)) : ((x2 >> 31) == 0)) {                 // Carry in addition                 x1 = unchecked(x1 + 1);               }               this.data[i] = x2;               carry = x1;             }           }           if (carry != 0) {             if (this.wordCount >= this.data.Length) {               var newdata = new int[this.wordCount + 20];               Array.Copy(this.data' 0' newdata' 0' this.data.Length);               this.data = newdata;             }             this.data[this.wordCount] = carry;             ++this.wordCount;           }           // Calculate the correct data length           while (this.wordCount != 0 && this.data[this.wordCount - 1] == 0) {             --this.wordCount;           }         } else {           if (this.data.Length > 0) {             this.data[0] = 0;           }           this.wordCount = 0;         }
Magic Number,PeterO.Cbor,MutableNumber,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\FastInteger2.cs,Multiply,The following statement contains a magic number: if (multiplicand != 0) {           var carry = 0;           if (this.wordCount == 0) {             if (this.data.Length == 0) {               this.data = new int[4];             }             this.data[0] = 0;             this.wordCount = 1;           }           int result0' result1' result2' result3;           if (multiplicand < 65536) {             for (var i = 0; i < this.wordCount; ++i) {               int x0 = this.data[i];               int x1 = x0;               int y0 = multiplicand;               x0 &= 65535;               x1 = (x1 >> 16) & 65535;               int temp = unchecked(x0 * y0);  // a * c               result1 = (temp >> 16) & 65535;               result0 = temp & 65535;               result2 = 0;               temp = unchecked(x1 * y0);  // b * c               result2 += (temp >> 16) & 65535;               result1 += temp & 65535;               result2 += (result1 >> 16) & 65535;               result1 &= 65535;               result3 = (result2 >> 16) & 65535;               result2 &= 65535;               // Add carry               x0 = unchecked((int)(result0 | (result1 << 16)));               x1 = unchecked((int)(result2 | (result3 << 16)));               int x2 = unchecked(x0 + carry);               if (((x2 >> 31) == (x0 >> 31)) ? ((x2 & Int32.MaxValue) < (x0 &               Int32.MaxValue)) : ((x2 >> 31) == 0)) {                 // Carry in addition                 x1 = unchecked(x1 + 1);               }               this.data[i] = x2;               carry = x1;             }           } else {             for (var i = 0; i < this.wordCount; ++i) {               int x0 = this.data[i];               int x1 = x0;               int y0 = multiplicand;               int y1 = y0;               x0 &= 65535;               y0 &= 65535;               x1 = (x1 >> 16) & 65535;               y1 = (y1 >> 16) & 65535;               int temp = unchecked(x0 * y0);  // a * c               result1 = (temp >> 16) & 65535;               result0 = temp & 65535;               temp = unchecked(x0 * y1);  // a * d               result2 = (temp >> 16) & 65535;               result1 += temp & 65535;               result2 += (result1 >> 16) & 65535;               result1 &= 65535;               temp = unchecked(x1 * y0);  // b * c               result2 += (temp >> 16) & 65535;               result1 += temp & 65535;               result2 += (result1 >> 16) & 65535;               result1 &= 65535;               result3 = (result2 >> 16) & 65535;               result2 &= 65535;               temp = unchecked(x1 * y1);  // b * d               result3 += (temp >> 16) & 65535;               result2 += temp & 65535;               result3 += (result2 >> 16) & 65535;               result2 &= 65535;               // Add carry               x0 = unchecked((int)(result0 | (result1 << 16)));               x1 = unchecked((int)(result2 | (result3 << 16)));               int x2 = unchecked(x0 + carry);               if (((x2 >> 31) == (x0 >> 31)) ? ((x2 & Int32.MaxValue) < (x0 &               Int32.MaxValue)) : ((x2 >> 31) == 0)) {                 // Carry in addition                 x1 = unchecked(x1 + 1);               }               this.data[i] = x2;               carry = x1;             }           }           if (carry != 0) {             if (this.wordCount >= this.data.Length) {               var newdata = new int[this.wordCount + 20];               Array.Copy(this.data' 0' newdata' 0' this.data.Length);               this.data = newdata;             }             this.data[this.wordCount] = carry;             ++this.wordCount;           }           // Calculate the correct data length           while (this.wordCount != 0 && this.data[this.wordCount - 1] == 0) {             --this.wordCount;           }         } else {           if (this.data.Length > 0) {             this.data[0] = 0;           }           this.wordCount = 0;         }
Magic Number,PeterO.Cbor,MutableNumber,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\FastInteger2.cs,Multiply,The following statement contains a magic number: if (multiplicand != 0) {           var carry = 0;           if (this.wordCount == 0) {             if (this.data.Length == 0) {               this.data = new int[4];             }             this.data[0] = 0;             this.wordCount = 1;           }           int result0' result1' result2' result3;           if (multiplicand < 65536) {             for (var i = 0; i < this.wordCount; ++i) {               int x0 = this.data[i];               int x1 = x0;               int y0 = multiplicand;               x0 &= 65535;               x1 = (x1 >> 16) & 65535;               int temp = unchecked(x0 * y0);  // a * c               result1 = (temp >> 16) & 65535;               result0 = temp & 65535;               result2 = 0;               temp = unchecked(x1 * y0);  // b * c               result2 += (temp >> 16) & 65535;               result1 += temp & 65535;               result2 += (result1 >> 16) & 65535;               result1 &= 65535;               result3 = (result2 >> 16) & 65535;               result2 &= 65535;               // Add carry               x0 = unchecked((int)(result0 | (result1 << 16)));               x1 = unchecked((int)(result2 | (result3 << 16)));               int x2 = unchecked(x0 + carry);               if (((x2 >> 31) == (x0 >> 31)) ? ((x2 & Int32.MaxValue) < (x0 &               Int32.MaxValue)) : ((x2 >> 31) == 0)) {                 // Carry in addition                 x1 = unchecked(x1 + 1);               }               this.data[i] = x2;               carry = x1;             }           } else {             for (var i = 0; i < this.wordCount; ++i) {               int x0 = this.data[i];               int x1 = x0;               int y0 = multiplicand;               int y1 = y0;               x0 &= 65535;               y0 &= 65535;               x1 = (x1 >> 16) & 65535;               y1 = (y1 >> 16) & 65535;               int temp = unchecked(x0 * y0);  // a * c               result1 = (temp >> 16) & 65535;               result0 = temp & 65535;               temp = unchecked(x0 * y1);  // a * d               result2 = (temp >> 16) & 65535;               result1 += temp & 65535;               result2 += (result1 >> 16) & 65535;               result1 &= 65535;               temp = unchecked(x1 * y0);  // b * c               result2 += (temp >> 16) & 65535;               result1 += temp & 65535;               result2 += (result1 >> 16) & 65535;               result1 &= 65535;               result3 = (result2 >> 16) & 65535;               result2 &= 65535;               temp = unchecked(x1 * y1);  // b * d               result3 += (temp >> 16) & 65535;               result2 += temp & 65535;               result3 += (result2 >> 16) & 65535;               result2 &= 65535;               // Add carry               x0 = unchecked((int)(result0 | (result1 << 16)));               x1 = unchecked((int)(result2 | (result3 << 16)));               int x2 = unchecked(x0 + carry);               if (((x2 >> 31) == (x0 >> 31)) ? ((x2 & Int32.MaxValue) < (x0 &               Int32.MaxValue)) : ((x2 >> 31) == 0)) {                 // Carry in addition                 x1 = unchecked(x1 + 1);               }               this.data[i] = x2;               carry = x1;             }           }           if (carry != 0) {             if (this.wordCount >= this.data.Length) {               var newdata = new int[this.wordCount + 20];               Array.Copy(this.data' 0' newdata' 0' this.data.Length);               this.data = newdata;             }             this.data[this.wordCount] = carry;             ++this.wordCount;           }           // Calculate the correct data length           while (this.wordCount != 0 && this.data[this.wordCount - 1] == 0) {             --this.wordCount;           }         } else {           if (this.data.Length > 0) {             this.data[0] = 0;           }           this.wordCount = 0;         }
Magic Number,PeterO.Cbor,MutableNumber,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\FastInteger2.cs,Multiply,The following statement contains a magic number: if (multiplicand != 0) {           var carry = 0;           if (this.wordCount == 0) {             if (this.data.Length == 0) {               this.data = new int[4];             }             this.data[0] = 0;             this.wordCount = 1;           }           int result0' result1' result2' result3;           if (multiplicand < 65536) {             for (var i = 0; i < this.wordCount; ++i) {               int x0 = this.data[i];               int x1 = x0;               int y0 = multiplicand;               x0 &= 65535;               x1 = (x1 >> 16) & 65535;               int temp = unchecked(x0 * y0);  // a * c               result1 = (temp >> 16) & 65535;               result0 = temp & 65535;               result2 = 0;               temp = unchecked(x1 * y0);  // b * c               result2 += (temp >> 16) & 65535;               result1 += temp & 65535;               result2 += (result1 >> 16) & 65535;               result1 &= 65535;               result3 = (result2 >> 16) & 65535;               result2 &= 65535;               // Add carry               x0 = unchecked((int)(result0 | (result1 << 16)));               x1 = unchecked((int)(result2 | (result3 << 16)));               int x2 = unchecked(x0 + carry);               if (((x2 >> 31) == (x0 >> 31)) ? ((x2 & Int32.MaxValue) < (x0 &               Int32.MaxValue)) : ((x2 >> 31) == 0)) {                 // Carry in addition                 x1 = unchecked(x1 + 1);               }               this.data[i] = x2;               carry = x1;             }           } else {             for (var i = 0; i < this.wordCount; ++i) {               int x0 = this.data[i];               int x1 = x0;               int y0 = multiplicand;               int y1 = y0;               x0 &= 65535;               y0 &= 65535;               x1 = (x1 >> 16) & 65535;               y1 = (y1 >> 16) & 65535;               int temp = unchecked(x0 * y0);  // a * c               result1 = (temp >> 16) & 65535;               result0 = temp & 65535;               temp = unchecked(x0 * y1);  // a * d               result2 = (temp >> 16) & 65535;               result1 += temp & 65535;               result2 += (result1 >> 16) & 65535;               result1 &= 65535;               temp = unchecked(x1 * y0);  // b * c               result2 += (temp >> 16) & 65535;               result1 += temp & 65535;               result2 += (result1 >> 16) & 65535;               result1 &= 65535;               result3 = (result2 >> 16) & 65535;               result2 &= 65535;               temp = unchecked(x1 * y1);  // b * d               result3 += (temp >> 16) & 65535;               result2 += temp & 65535;               result3 += (result2 >> 16) & 65535;               result2 &= 65535;               // Add carry               x0 = unchecked((int)(result0 | (result1 << 16)));               x1 = unchecked((int)(result2 | (result3 << 16)));               int x2 = unchecked(x0 + carry);               if (((x2 >> 31) == (x0 >> 31)) ? ((x2 & Int32.MaxValue) < (x0 &               Int32.MaxValue)) : ((x2 >> 31) == 0)) {                 // Carry in addition                 x1 = unchecked(x1 + 1);               }               this.data[i] = x2;               carry = x1;             }           }           if (carry != 0) {             if (this.wordCount >= this.data.Length) {               var newdata = new int[this.wordCount + 20];               Array.Copy(this.data' 0' newdata' 0' this.data.Length);               this.data = newdata;             }             this.data[this.wordCount] = carry;             ++this.wordCount;           }           // Calculate the correct data length           while (this.wordCount != 0 && this.data[this.wordCount - 1] == 0) {             --this.wordCount;           }         } else {           if (this.data.Length > 0) {             this.data[0] = 0;           }           this.wordCount = 0;         }
Magic Number,PeterO.Cbor,MutableNumber,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\FastInteger2.cs,Multiply,The following statement contains a magic number: if (multiplicand != 0) {           var carry = 0;           if (this.wordCount == 0) {             if (this.data.Length == 0) {               this.data = new int[4];             }             this.data[0] = 0;             this.wordCount = 1;           }           int result0' result1' result2' result3;           if (multiplicand < 65536) {             for (var i = 0; i < this.wordCount; ++i) {               int x0 = this.data[i];               int x1 = x0;               int y0 = multiplicand;               x0 &= 65535;               x1 = (x1 >> 16) & 65535;               int temp = unchecked(x0 * y0);  // a * c               result1 = (temp >> 16) & 65535;               result0 = temp & 65535;               result2 = 0;               temp = unchecked(x1 * y0);  // b * c               result2 += (temp >> 16) & 65535;               result1 += temp & 65535;               result2 += (result1 >> 16) & 65535;               result1 &= 65535;               result3 = (result2 >> 16) & 65535;               result2 &= 65535;               // Add carry               x0 = unchecked((int)(result0 | (result1 << 16)));               x1 = unchecked((int)(result2 | (result3 << 16)));               int x2 = unchecked(x0 + carry);               if (((x2 >> 31) == (x0 >> 31)) ? ((x2 & Int32.MaxValue) < (x0 &               Int32.MaxValue)) : ((x2 >> 31) == 0)) {                 // Carry in addition                 x1 = unchecked(x1 + 1);               }               this.data[i] = x2;               carry = x1;             }           } else {             for (var i = 0; i < this.wordCount; ++i) {               int x0 = this.data[i];               int x1 = x0;               int y0 = multiplicand;               int y1 = y0;               x0 &= 65535;               y0 &= 65535;               x1 = (x1 >> 16) & 65535;               y1 = (y1 >> 16) & 65535;               int temp = unchecked(x0 * y0);  // a * c               result1 = (temp >> 16) & 65535;               result0 = temp & 65535;               temp = unchecked(x0 * y1);  // a * d               result2 = (temp >> 16) & 65535;               result1 += temp & 65535;               result2 += (result1 >> 16) & 65535;               result1 &= 65535;               temp = unchecked(x1 * y0);  // b * c               result2 += (temp >> 16) & 65535;               result1 += temp & 65535;               result2 += (result1 >> 16) & 65535;               result1 &= 65535;               result3 = (result2 >> 16) & 65535;               result2 &= 65535;               temp = unchecked(x1 * y1);  // b * d               result3 += (temp >> 16) & 65535;               result2 += temp & 65535;               result3 += (result2 >> 16) & 65535;               result2 &= 65535;               // Add carry               x0 = unchecked((int)(result0 | (result1 << 16)));               x1 = unchecked((int)(result2 | (result3 << 16)));               int x2 = unchecked(x0 + carry);               if (((x2 >> 31) == (x0 >> 31)) ? ((x2 & Int32.MaxValue) < (x0 &               Int32.MaxValue)) : ((x2 >> 31) == 0)) {                 // Carry in addition                 x1 = unchecked(x1 + 1);               }               this.data[i] = x2;               carry = x1;             }           }           if (carry != 0) {             if (this.wordCount >= this.data.Length) {               var newdata = new int[this.wordCount + 20];               Array.Copy(this.data' 0' newdata' 0' this.data.Length);               this.data = newdata;             }             this.data[this.wordCount] = carry;             ++this.wordCount;           }           // Calculate the correct data length           while (this.wordCount != 0 && this.data[this.wordCount - 1] == 0) {             --this.wordCount;           }         } else {           if (this.data.Length > 0) {             this.data[0] = 0;           }           this.wordCount = 0;         }
Magic Number,PeterO.Cbor,MutableNumber,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\FastInteger2.cs,Multiply,The following statement contains a magic number: if (multiplicand != 0) {           var carry = 0;           if (this.wordCount == 0) {             if (this.data.Length == 0) {               this.data = new int[4];             }             this.data[0] = 0;             this.wordCount = 1;           }           int result0' result1' result2' result3;           if (multiplicand < 65536) {             for (var i = 0; i < this.wordCount; ++i) {               int x0 = this.data[i];               int x1 = x0;               int y0 = multiplicand;               x0 &= 65535;               x1 = (x1 >> 16) & 65535;               int temp = unchecked(x0 * y0);  // a * c               result1 = (temp >> 16) & 65535;               result0 = temp & 65535;               result2 = 0;               temp = unchecked(x1 * y0);  // b * c               result2 += (temp >> 16) & 65535;               result1 += temp & 65535;               result2 += (result1 >> 16) & 65535;               result1 &= 65535;               result3 = (result2 >> 16) & 65535;               result2 &= 65535;               // Add carry               x0 = unchecked((int)(result0 | (result1 << 16)));               x1 = unchecked((int)(result2 | (result3 << 16)));               int x2 = unchecked(x0 + carry);               if (((x2 >> 31) == (x0 >> 31)) ? ((x2 & Int32.MaxValue) < (x0 &               Int32.MaxValue)) : ((x2 >> 31) == 0)) {                 // Carry in addition                 x1 = unchecked(x1 + 1);               }               this.data[i] = x2;               carry = x1;             }           } else {             for (var i = 0; i < this.wordCount; ++i) {               int x0 = this.data[i];               int x1 = x0;               int y0 = multiplicand;               int y1 = y0;               x0 &= 65535;               y0 &= 65535;               x1 = (x1 >> 16) & 65535;               y1 = (y1 >> 16) & 65535;               int temp = unchecked(x0 * y0);  // a * c               result1 = (temp >> 16) & 65535;               result0 = temp & 65535;               temp = unchecked(x0 * y1);  // a * d               result2 = (temp >> 16) & 65535;               result1 += temp & 65535;               result2 += (result1 >> 16) & 65535;               result1 &= 65535;               temp = unchecked(x1 * y0);  // b * c               result2 += (temp >> 16) & 65535;               result1 += temp & 65535;               result2 += (result1 >> 16) & 65535;               result1 &= 65535;               result3 = (result2 >> 16) & 65535;               result2 &= 65535;               temp = unchecked(x1 * y1);  // b * d               result3 += (temp >> 16) & 65535;               result2 += temp & 65535;               result3 += (result2 >> 16) & 65535;               result2 &= 65535;               // Add carry               x0 = unchecked((int)(result0 | (result1 << 16)));               x1 = unchecked((int)(result2 | (result3 << 16)));               int x2 = unchecked(x0 + carry);               if (((x2 >> 31) == (x0 >> 31)) ? ((x2 & Int32.MaxValue) < (x0 &               Int32.MaxValue)) : ((x2 >> 31) == 0)) {                 // Carry in addition                 x1 = unchecked(x1 + 1);               }               this.data[i] = x2;               carry = x1;             }           }           if (carry != 0) {             if (this.wordCount >= this.data.Length) {               var newdata = new int[this.wordCount + 20];               Array.Copy(this.data' 0' newdata' 0' this.data.Length);               this.data = newdata;             }             this.data[this.wordCount] = carry;             ++this.wordCount;           }           // Calculate the correct data length           while (this.wordCount != 0 && this.data[this.wordCount - 1] == 0) {             --this.wordCount;           }         } else {           if (this.data.Length > 0) {             this.data[0] = 0;           }           this.wordCount = 0;         }
Magic Number,PeterO.Cbor,MutableNumber,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\FastInteger2.cs,Multiply,The following statement contains a magic number: if (multiplicand != 0) {           var carry = 0;           if (this.wordCount == 0) {             if (this.data.Length == 0) {               this.data = new int[4];             }             this.data[0] = 0;             this.wordCount = 1;           }           int result0' result1' result2' result3;           if (multiplicand < 65536) {             for (var i = 0; i < this.wordCount; ++i) {               int x0 = this.data[i];               int x1 = x0;               int y0 = multiplicand;               x0 &= 65535;               x1 = (x1 >> 16) & 65535;               int temp = unchecked(x0 * y0);  // a * c               result1 = (temp >> 16) & 65535;               result0 = temp & 65535;               result2 = 0;               temp = unchecked(x1 * y0);  // b * c               result2 += (temp >> 16) & 65535;               result1 += temp & 65535;               result2 += (result1 >> 16) & 65535;               result1 &= 65535;               result3 = (result2 >> 16) & 65535;               result2 &= 65535;               // Add carry               x0 = unchecked((int)(result0 | (result1 << 16)));               x1 = unchecked((int)(result2 | (result3 << 16)));               int x2 = unchecked(x0 + carry);               if (((x2 >> 31) == (x0 >> 31)) ? ((x2 & Int32.MaxValue) < (x0 &               Int32.MaxValue)) : ((x2 >> 31) == 0)) {                 // Carry in addition                 x1 = unchecked(x1 + 1);               }               this.data[i] = x2;               carry = x1;             }           } else {             for (var i = 0; i < this.wordCount; ++i) {               int x0 = this.data[i];               int x1 = x0;               int y0 = multiplicand;               int y1 = y0;               x0 &= 65535;               y0 &= 65535;               x1 = (x1 >> 16) & 65535;               y1 = (y1 >> 16) & 65535;               int temp = unchecked(x0 * y0);  // a * c               result1 = (temp >> 16) & 65535;               result0 = temp & 65535;               temp = unchecked(x0 * y1);  // a * d               result2 = (temp >> 16) & 65535;               result1 += temp & 65535;               result2 += (result1 >> 16) & 65535;               result1 &= 65535;               temp = unchecked(x1 * y0);  // b * c               result2 += (temp >> 16) & 65535;               result1 += temp & 65535;               result2 += (result1 >> 16) & 65535;               result1 &= 65535;               result3 = (result2 >> 16) & 65535;               result2 &= 65535;               temp = unchecked(x1 * y1);  // b * d               result3 += (temp >> 16) & 65535;               result2 += temp & 65535;               result3 += (result2 >> 16) & 65535;               result2 &= 65535;               // Add carry               x0 = unchecked((int)(result0 | (result1 << 16)));               x1 = unchecked((int)(result2 | (result3 << 16)));               int x2 = unchecked(x0 + carry);               if (((x2 >> 31) == (x0 >> 31)) ? ((x2 & Int32.MaxValue) < (x0 &               Int32.MaxValue)) : ((x2 >> 31) == 0)) {                 // Carry in addition                 x1 = unchecked(x1 + 1);               }               this.data[i] = x2;               carry = x1;             }           }           if (carry != 0) {             if (this.wordCount >= this.data.Length) {               var newdata = new int[this.wordCount + 20];               Array.Copy(this.data' 0' newdata' 0' this.data.Length);               this.data = newdata;             }             this.data[this.wordCount] = carry;             ++this.wordCount;           }           // Calculate the correct data length           while (this.wordCount != 0 && this.data[this.wordCount - 1] == 0) {             --this.wordCount;           }         } else {           if (this.data.Length > 0) {             this.data[0] = 0;           }           this.wordCount = 0;         }
Magic Number,PeterO.Cbor,MutableNumber,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\FastInteger2.cs,Multiply,The following statement contains a magic number: if (multiplicand != 0) {           var carry = 0;           if (this.wordCount == 0) {             if (this.data.Length == 0) {               this.data = new int[4];             }             this.data[0] = 0;             this.wordCount = 1;           }           int result0' result1' result2' result3;           if (multiplicand < 65536) {             for (var i = 0; i < this.wordCount; ++i) {               int x0 = this.data[i];               int x1 = x0;               int y0 = multiplicand;               x0 &= 65535;               x1 = (x1 >> 16) & 65535;               int temp = unchecked(x0 * y0);  // a * c               result1 = (temp >> 16) & 65535;               result0 = temp & 65535;               result2 = 0;               temp = unchecked(x1 * y0);  // b * c               result2 += (temp >> 16) & 65535;               result1 += temp & 65535;               result2 += (result1 >> 16) & 65535;               result1 &= 65535;               result3 = (result2 >> 16) & 65535;               result2 &= 65535;               // Add carry               x0 = unchecked((int)(result0 | (result1 << 16)));               x1 = unchecked((int)(result2 | (result3 << 16)));               int x2 = unchecked(x0 + carry);               if (((x2 >> 31) == (x0 >> 31)) ? ((x2 & Int32.MaxValue) < (x0 &               Int32.MaxValue)) : ((x2 >> 31) == 0)) {                 // Carry in addition                 x1 = unchecked(x1 + 1);               }               this.data[i] = x2;               carry = x1;             }           } else {             for (var i = 0; i < this.wordCount; ++i) {               int x0 = this.data[i];               int x1 = x0;               int y0 = multiplicand;               int y1 = y0;               x0 &= 65535;               y0 &= 65535;               x1 = (x1 >> 16) & 65535;               y1 = (y1 >> 16) & 65535;               int temp = unchecked(x0 * y0);  // a * c               result1 = (temp >> 16) & 65535;               result0 = temp & 65535;               temp = unchecked(x0 * y1);  // a * d               result2 = (temp >> 16) & 65535;               result1 += temp & 65535;               result2 += (result1 >> 16) & 65535;               result1 &= 65535;               temp = unchecked(x1 * y0);  // b * c               result2 += (temp >> 16) & 65535;               result1 += temp & 65535;               result2 += (result1 >> 16) & 65535;               result1 &= 65535;               result3 = (result2 >> 16) & 65535;               result2 &= 65535;               temp = unchecked(x1 * y1);  // b * d               result3 += (temp >> 16) & 65535;               result2 += temp & 65535;               result3 += (result2 >> 16) & 65535;               result2 &= 65535;               // Add carry               x0 = unchecked((int)(result0 | (result1 << 16)));               x1 = unchecked((int)(result2 | (result3 << 16)));               int x2 = unchecked(x0 + carry);               if (((x2 >> 31) == (x0 >> 31)) ? ((x2 & Int32.MaxValue) < (x0 &               Int32.MaxValue)) : ((x2 >> 31) == 0)) {                 // Carry in addition                 x1 = unchecked(x1 + 1);               }               this.data[i] = x2;               carry = x1;             }           }           if (carry != 0) {             if (this.wordCount >= this.data.Length) {               var newdata = new int[this.wordCount + 20];               Array.Copy(this.data' 0' newdata' 0' this.data.Length);               this.data = newdata;             }             this.data[this.wordCount] = carry;             ++this.wordCount;           }           // Calculate the correct data length           while (this.wordCount != 0 && this.data[this.wordCount - 1] == 0) {             --this.wordCount;           }         } else {           if (this.data.Length > 0) {             this.data[0] = 0;           }           this.wordCount = 0;         }
Magic Number,PeterO.Cbor,MutableNumber,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\FastInteger2.cs,Multiply,The following statement contains a magic number: if (multiplicand != 0) {           var carry = 0;           if (this.wordCount == 0) {             if (this.data.Length == 0) {               this.data = new int[4];             }             this.data[0] = 0;             this.wordCount = 1;           }           int result0' result1' result2' result3;           if (multiplicand < 65536) {             for (var i = 0; i < this.wordCount; ++i) {               int x0 = this.data[i];               int x1 = x0;               int y0 = multiplicand;               x0 &= 65535;               x1 = (x1 >> 16) & 65535;               int temp = unchecked(x0 * y0);  // a * c               result1 = (temp >> 16) & 65535;               result0 = temp & 65535;               result2 = 0;               temp = unchecked(x1 * y0);  // b * c               result2 += (temp >> 16) & 65535;               result1 += temp & 65535;               result2 += (result1 >> 16) & 65535;               result1 &= 65535;               result3 = (result2 >> 16) & 65535;               result2 &= 65535;               // Add carry               x0 = unchecked((int)(result0 | (result1 << 16)));               x1 = unchecked((int)(result2 | (result3 << 16)));               int x2 = unchecked(x0 + carry);               if (((x2 >> 31) == (x0 >> 31)) ? ((x2 & Int32.MaxValue) < (x0 &               Int32.MaxValue)) : ((x2 >> 31) == 0)) {                 // Carry in addition                 x1 = unchecked(x1 + 1);               }               this.data[i] = x2;               carry = x1;             }           } else {             for (var i = 0; i < this.wordCount; ++i) {               int x0 = this.data[i];               int x1 = x0;               int y0 = multiplicand;               int y1 = y0;               x0 &= 65535;               y0 &= 65535;               x1 = (x1 >> 16) & 65535;               y1 = (y1 >> 16) & 65535;               int temp = unchecked(x0 * y0);  // a * c               result1 = (temp >> 16) & 65535;               result0 = temp & 65535;               temp = unchecked(x0 * y1);  // a * d               result2 = (temp >> 16) & 65535;               result1 += temp & 65535;               result2 += (result1 >> 16) & 65535;               result1 &= 65535;               temp = unchecked(x1 * y0);  // b * c               result2 += (temp >> 16) & 65535;               result1 += temp & 65535;               result2 += (result1 >> 16) & 65535;               result1 &= 65535;               result3 = (result2 >> 16) & 65535;               result2 &= 65535;               temp = unchecked(x1 * y1);  // b * d               result3 += (temp >> 16) & 65535;               result2 += temp & 65535;               result3 += (result2 >> 16) & 65535;               result2 &= 65535;               // Add carry               x0 = unchecked((int)(result0 | (result1 << 16)));               x1 = unchecked((int)(result2 | (result3 << 16)));               int x2 = unchecked(x0 + carry);               if (((x2 >> 31) == (x0 >> 31)) ? ((x2 & Int32.MaxValue) < (x0 &               Int32.MaxValue)) : ((x2 >> 31) == 0)) {                 // Carry in addition                 x1 = unchecked(x1 + 1);               }               this.data[i] = x2;               carry = x1;             }           }           if (carry != 0) {             if (this.wordCount >= this.data.Length) {               var newdata = new int[this.wordCount + 20];               Array.Copy(this.data' 0' newdata' 0' this.data.Length);               this.data = newdata;             }             this.data[this.wordCount] = carry;             ++this.wordCount;           }           // Calculate the correct data length           while (this.wordCount != 0 && this.data[this.wordCount - 1] == 0) {             --this.wordCount;           }         } else {           if (this.data.Length > 0) {             this.data[0] = 0;           }           this.wordCount = 0;         }
Magic Number,PeterO.Cbor,MutableNumber,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\FastInteger2.cs,SubtractInt,The following statement contains a magic number: if (other != 0) {           unchecked {             // Ensure a length of at least 1             if (this.wordCount == 0) {               if (this.data.Length == 0) {                 this.data = new int[4];               }               this.data[0] = 0;               this.wordCount = 1;             }             int borrow;             int u;             int a = this.data[0];             u = a - other;             borrow = ((((a >> 31) == (u >> 31)) ?                     ((a & Int32.MaxValue) < (u & Int32.MaxValue)) :                     ((a >> 31) == 0)) || (a == u && other != 0)) ? 1 : 0;             this.data[0] = (int)u;             if (borrow != 0) {               for (int i = 1; i < this.wordCount; ++i) {                 u = this.data[i] - borrow;                 borrow = (((this.data[i] >> 31) == (u >> 31)) ?                 ((this.data[i] & Int32.MaxValue) < (u & Int32.MaxValue)) :                     ((this.data[i] >> 31) == 0)) ? 1 : 0;                 this.data[i] = (int)u;               }             }             // Calculate the correct data length             while (this.wordCount != 0 && this.data[this.wordCount - 1] == 0) {               --this.wordCount;             }           }         }
Magic Number,PeterO.Cbor,MutableNumber,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\FastInteger2.cs,SubtractInt,The following statement contains a magic number: if (other != 0) {           unchecked {             // Ensure a length of at least 1             if (this.wordCount == 0) {               if (this.data.Length == 0) {                 this.data = new int[4];               }               this.data[0] = 0;               this.wordCount = 1;             }             int borrow;             int u;             int a = this.data[0];             u = a - other;             borrow = ((((a >> 31) == (u >> 31)) ?                     ((a & Int32.MaxValue) < (u & Int32.MaxValue)) :                     ((a >> 31) == 0)) || (a == u && other != 0)) ? 1 : 0;             this.data[0] = (int)u;             if (borrow != 0) {               for (int i = 1; i < this.wordCount; ++i) {                 u = this.data[i] - borrow;                 borrow = (((this.data[i] >> 31) == (u >> 31)) ?                 ((this.data[i] & Int32.MaxValue) < (u & Int32.MaxValue)) :                     ((this.data[i] >> 31) == 0)) ? 1 : 0;                 this.data[i] = (int)u;               }             }             // Calculate the correct data length             while (this.wordCount != 0 && this.data[this.wordCount - 1] == 0) {               --this.wordCount;             }           }         }
Magic Number,PeterO.Cbor,MutableNumber,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\FastInteger2.cs,SubtractInt,The following statement contains a magic number: if (other != 0) {           unchecked {             // Ensure a length of at least 1             if (this.wordCount == 0) {               if (this.data.Length == 0) {                 this.data = new int[4];               }               this.data[0] = 0;               this.wordCount = 1;             }             int borrow;             int u;             int a = this.data[0];             u = a - other;             borrow = ((((a >> 31) == (u >> 31)) ?                     ((a & Int32.MaxValue) < (u & Int32.MaxValue)) :                     ((a >> 31) == 0)) || (a == u && other != 0)) ? 1 : 0;             this.data[0] = (int)u;             if (borrow != 0) {               for (int i = 1; i < this.wordCount; ++i) {                 u = this.data[i] - borrow;                 borrow = (((this.data[i] >> 31) == (u >> 31)) ?                 ((this.data[i] & Int32.MaxValue) < (u & Int32.MaxValue)) :                     ((this.data[i] >> 31) == 0)) ? 1 : 0;                 this.data[i] = (int)u;               }             }             // Calculate the correct data length             while (this.wordCount != 0 && this.data[this.wordCount - 1] == 0) {               --this.wordCount;             }           }         }
Magic Number,PeterO.Cbor,MutableNumber,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\FastInteger2.cs,SubtractInt,The following statement contains a magic number: if (other != 0) {           unchecked {             // Ensure a length of at least 1             if (this.wordCount == 0) {               if (this.data.Length == 0) {                 this.data = new int[4];               }               this.data[0] = 0;               this.wordCount = 1;             }             int borrow;             int u;             int a = this.data[0];             u = a - other;             borrow = ((((a >> 31) == (u >> 31)) ?                     ((a & Int32.MaxValue) < (u & Int32.MaxValue)) :                     ((a >> 31) == 0)) || (a == u && other != 0)) ? 1 : 0;             this.data[0] = (int)u;             if (borrow != 0) {               for (int i = 1; i < this.wordCount; ++i) {                 u = this.data[i] - borrow;                 borrow = (((this.data[i] >> 31) == (u >> 31)) ?                 ((this.data[i] & Int32.MaxValue) < (u & Int32.MaxValue)) :                     ((this.data[i] >> 31) == 0)) ? 1 : 0;                 this.data[i] = (int)u;               }             }             // Calculate the correct data length             while (this.wordCount != 0 && this.data[this.wordCount - 1] == 0) {               --this.wordCount;             }           }         }
Magic Number,PeterO.Cbor,MutableNumber,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\FastInteger2.cs,SubtractInt,The following statement contains a magic number: if (other != 0) {           unchecked {             // Ensure a length of at least 1             if (this.wordCount == 0) {               if (this.data.Length == 0) {                 this.data = new int[4];               }               this.data[0] = 0;               this.wordCount = 1;             }             int borrow;             int u;             int a = this.data[0];             u = a - other;             borrow = ((((a >> 31) == (u >> 31)) ?                     ((a & Int32.MaxValue) < (u & Int32.MaxValue)) :                     ((a >> 31) == 0)) || (a == u && other != 0)) ? 1 : 0;             this.data[0] = (int)u;             if (borrow != 0) {               for (int i = 1; i < this.wordCount; ++i) {                 u = this.data[i] - borrow;                 borrow = (((this.data[i] >> 31) == (u >> 31)) ?                 ((this.data[i] & Int32.MaxValue) < (u & Int32.MaxValue)) :                     ((this.data[i] >> 31) == 0)) ? 1 : 0;                 this.data[i] = (int)u;               }             }             // Calculate the correct data length             while (this.wordCount != 0 && this.data[this.wordCount - 1] == 0) {               --this.wordCount;             }           }         }
Magic Number,PeterO.Cbor,MutableNumber,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\FastInteger2.cs,SubtractInt,The following statement contains a magic number: if (other != 0) {           unchecked {             // Ensure a length of at least 1             if (this.wordCount == 0) {               if (this.data.Length == 0) {                 this.data = new int[4];               }               this.data[0] = 0;               this.wordCount = 1;             }             int borrow;             int u;             int a = this.data[0];             u = a - other;             borrow = ((((a >> 31) == (u >> 31)) ?                     ((a & Int32.MaxValue) < (u & Int32.MaxValue)) :                     ((a >> 31) == 0)) || (a == u && other != 0)) ? 1 : 0;             this.data[0] = (int)u;             if (borrow != 0) {               for (int i = 1; i < this.wordCount; ++i) {                 u = this.data[i] - borrow;                 borrow = (((this.data[i] >> 31) == (u >> 31)) ?                 ((this.data[i] & Int32.MaxValue) < (u & Int32.MaxValue)) :                     ((this.data[i] >> 31) == 0)) ? 1 : 0;                 this.data[i] = (int)u;               }             }             // Calculate the correct data length             while (this.wordCount != 0 && this.data[this.wordCount - 1] == 0) {               --this.wordCount;             }           }         }
Magic Number,PeterO.Cbor,MutableNumber,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\FastInteger2.cs,SubtractInt,The following statement contains a magic number: if (other != 0) {           unchecked {             // Ensure a length of at least 1             if (this.wordCount == 0) {               if (this.data.Length == 0) {                 this.data = new int[4];               }               this.data[0] = 0;               this.wordCount = 1;             }             int borrow;             int u;             int a = this.data[0];             u = a - other;             borrow = ((((a >> 31) == (u >> 31)) ?                     ((a & Int32.MaxValue) < (u & Int32.MaxValue)) :                     ((a >> 31) == 0)) || (a == u && other != 0)) ? 1 : 0;             this.data[0] = (int)u;             if (borrow != 0) {               for (int i = 1; i < this.wordCount; ++i) {                 u = this.data[i] - borrow;                 borrow = (((this.data[i] >> 31) == (u >> 31)) ?                 ((this.data[i] & Int32.MaxValue) < (u & Int32.MaxValue)) :                     ((this.data[i] >> 31) == 0)) ? 1 : 0;                 this.data[i] = (int)u;               }             }             // Calculate the correct data length             while (this.wordCount != 0 && this.data[this.wordCount - 1] == 0) {               --this.wordCount;             }           }         }
Magic Number,PeterO.Cbor,MutableNumber,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\FastInteger2.cs,Subtract,The following statement contains a magic number: unchecked {           {        // Console.WriteLine("" + this.data.Length + " " +              // (other.data.Length));             int neededSize = (this.wordCount > other.wordCount) ?             this.wordCount : other.wordCount;             if (this.data.Length < neededSize) {               var newdata = new int[neededSize + 20];               Array.Copy(this.data' 0' newdata' 0' this.data.Length);               this.data = newdata;             }             neededSize = (this.wordCount < other.wordCount) ? this.wordCount :             other.wordCount;             var u = 0;             var borrow = 0;             for (var i = 0; i < neededSize; ++i) {               int a = this.data[i];               u = (a - other.data[i]) - borrow;               borrow = ((((a >> 31) == (u >> 31)) ? ((a & Int32.MaxValue) <               (u & Int32.MaxValue)) :                     ((a >> 31) == 0)) || (a == u && other.data[i] !=                     0)) ? 1 : 0;               this.data[i] = (int)u;             }             if (borrow != 0) {               for (int i = neededSize; i < this.wordCount; ++i) {                 int a = this.data[i];                 u = (a - other.data[i]) - borrow;                 borrow = ((((a >> 31) == (u >> 31)) ? ((a & Int32.MaxValue) <                 (u & Int32.MaxValue)) :                     ((a >> 31) == 0)) || (a == u && other.data[i] !=                     0)) ? 1 : 0;                 this.data[i] = (int)u;               }             }             // Calculate the correct data length             while (this.wordCount != 0 && this.data[this.wordCount - 1] == 0) {               --this.wordCount;             }             return this;           }         }
Magic Number,PeterO.Cbor,MutableNumber,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\FastInteger2.cs,Subtract,The following statement contains a magic number: unchecked {           {        // Console.WriteLine("" + this.data.Length + " " +              // (other.data.Length));             int neededSize = (this.wordCount > other.wordCount) ?             this.wordCount : other.wordCount;             if (this.data.Length < neededSize) {               var newdata = new int[neededSize + 20];               Array.Copy(this.data' 0' newdata' 0' this.data.Length);               this.data = newdata;             }             neededSize = (this.wordCount < other.wordCount) ? this.wordCount :             other.wordCount;             var u = 0;             var borrow = 0;             for (var i = 0; i < neededSize; ++i) {               int a = this.data[i];               u = (a - other.data[i]) - borrow;               borrow = ((((a >> 31) == (u >> 31)) ? ((a & Int32.MaxValue) <               (u & Int32.MaxValue)) :                     ((a >> 31) == 0)) || (a == u && other.data[i] !=                     0)) ? 1 : 0;               this.data[i] = (int)u;             }             if (borrow != 0) {               for (int i = neededSize; i < this.wordCount; ++i) {                 int a = this.data[i];                 u = (a - other.data[i]) - borrow;                 borrow = ((((a >> 31) == (u >> 31)) ? ((a & Int32.MaxValue) <                 (u & Int32.MaxValue)) :                     ((a >> 31) == 0)) || (a == u && other.data[i] !=                     0)) ? 1 : 0;                 this.data[i] = (int)u;               }             }             // Calculate the correct data length             while (this.wordCount != 0 && this.data[this.wordCount - 1] == 0) {               --this.wordCount;             }             return this;           }         }
Magic Number,PeterO.Cbor,MutableNumber,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\FastInteger2.cs,Subtract,The following statement contains a magic number: unchecked {           {        // Console.WriteLine("" + this.data.Length + " " +              // (other.data.Length));             int neededSize = (this.wordCount > other.wordCount) ?             this.wordCount : other.wordCount;             if (this.data.Length < neededSize) {               var newdata = new int[neededSize + 20];               Array.Copy(this.data' 0' newdata' 0' this.data.Length);               this.data = newdata;             }             neededSize = (this.wordCount < other.wordCount) ? this.wordCount :             other.wordCount;             var u = 0;             var borrow = 0;             for (var i = 0; i < neededSize; ++i) {               int a = this.data[i];               u = (a - other.data[i]) - borrow;               borrow = ((((a >> 31) == (u >> 31)) ? ((a & Int32.MaxValue) <               (u & Int32.MaxValue)) :                     ((a >> 31) == 0)) || (a == u && other.data[i] !=                     0)) ? 1 : 0;               this.data[i] = (int)u;             }             if (borrow != 0) {               for (int i = neededSize; i < this.wordCount; ++i) {                 int a = this.data[i];                 u = (a - other.data[i]) - borrow;                 borrow = ((((a >> 31) == (u >> 31)) ? ((a & Int32.MaxValue) <                 (u & Int32.MaxValue)) :                     ((a >> 31) == 0)) || (a == u && other.data[i] !=                     0)) ? 1 : 0;                 this.data[i] = (int)u;               }             }             // Calculate the correct data length             while (this.wordCount != 0 && this.data[this.wordCount - 1] == 0) {               --this.wordCount;             }             return this;           }         }
Magic Number,PeterO.Cbor,MutableNumber,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\FastInteger2.cs,Subtract,The following statement contains a magic number: unchecked {           {        // Console.WriteLine("" + this.data.Length + " " +              // (other.data.Length));             int neededSize = (this.wordCount > other.wordCount) ?             this.wordCount : other.wordCount;             if (this.data.Length < neededSize) {               var newdata = new int[neededSize + 20];               Array.Copy(this.data' 0' newdata' 0' this.data.Length);               this.data = newdata;             }             neededSize = (this.wordCount < other.wordCount) ? this.wordCount :             other.wordCount;             var u = 0;             var borrow = 0;             for (var i = 0; i < neededSize; ++i) {               int a = this.data[i];               u = (a - other.data[i]) - borrow;               borrow = ((((a >> 31) == (u >> 31)) ? ((a & Int32.MaxValue) <               (u & Int32.MaxValue)) :                     ((a >> 31) == 0)) || (a == u && other.data[i] !=                     0)) ? 1 : 0;               this.data[i] = (int)u;             }             if (borrow != 0) {               for (int i = neededSize; i < this.wordCount; ++i) {                 int a = this.data[i];                 u = (a - other.data[i]) - borrow;                 borrow = ((((a >> 31) == (u >> 31)) ? ((a & Int32.MaxValue) <                 (u & Int32.MaxValue)) :                     ((a >> 31) == 0)) || (a == u && other.data[i] !=                     0)) ? 1 : 0;                 this.data[i] = (int)u;               }             }             // Calculate the correct data length             while (this.wordCount != 0 && this.data[this.wordCount - 1] == 0) {               --this.wordCount;             }             return this;           }         }
Magic Number,PeterO.Cbor,MutableNumber,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\FastInteger2.cs,Subtract,The following statement contains a magic number: unchecked {           {        // Console.WriteLine("" + this.data.Length + " " +              // (other.data.Length));             int neededSize = (this.wordCount > other.wordCount) ?             this.wordCount : other.wordCount;             if (this.data.Length < neededSize) {               var newdata = new int[neededSize + 20];               Array.Copy(this.data' 0' newdata' 0' this.data.Length);               this.data = newdata;             }             neededSize = (this.wordCount < other.wordCount) ? this.wordCount :             other.wordCount;             var u = 0;             var borrow = 0;             for (var i = 0; i < neededSize; ++i) {               int a = this.data[i];               u = (a - other.data[i]) - borrow;               borrow = ((((a >> 31) == (u >> 31)) ? ((a & Int32.MaxValue) <               (u & Int32.MaxValue)) :                     ((a >> 31) == 0)) || (a == u && other.data[i] !=                     0)) ? 1 : 0;               this.data[i] = (int)u;             }             if (borrow != 0) {               for (int i = neededSize; i < this.wordCount; ++i) {                 int a = this.data[i];                 u = (a - other.data[i]) - borrow;                 borrow = ((((a >> 31) == (u >> 31)) ? ((a & Int32.MaxValue) <                 (u & Int32.MaxValue)) :                     ((a >> 31) == 0)) || (a == u && other.data[i] !=                     0)) ? 1 : 0;                 this.data[i] = (int)u;               }             }             // Calculate the correct data length             while (this.wordCount != 0 && this.data[this.wordCount - 1] == 0) {               --this.wordCount;             }             return this;           }         }
Magic Number,PeterO.Cbor,MutableNumber,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\FastInteger2.cs,Subtract,The following statement contains a magic number: unchecked {           {        // Console.WriteLine("" + this.data.Length + " " +              // (other.data.Length));             int neededSize = (this.wordCount > other.wordCount) ?             this.wordCount : other.wordCount;             if (this.data.Length < neededSize) {               var newdata = new int[neededSize + 20];               Array.Copy(this.data' 0' newdata' 0' this.data.Length);               this.data = newdata;             }             neededSize = (this.wordCount < other.wordCount) ? this.wordCount :             other.wordCount;             var u = 0;             var borrow = 0;             for (var i = 0; i < neededSize; ++i) {               int a = this.data[i];               u = (a - other.data[i]) - borrow;               borrow = ((((a >> 31) == (u >> 31)) ? ((a & Int32.MaxValue) <               (u & Int32.MaxValue)) :                     ((a >> 31) == 0)) || (a == u && other.data[i] !=                     0)) ? 1 : 0;               this.data[i] = (int)u;             }             if (borrow != 0) {               for (int i = neededSize; i < this.wordCount; ++i) {                 int a = this.data[i];                 u = (a - other.data[i]) - borrow;                 borrow = ((((a >> 31) == (u >> 31)) ? ((a & Int32.MaxValue) <                 (u & Int32.MaxValue)) :                     ((a >> 31) == 0)) || (a == u && other.data[i] !=                     0)) ? 1 : 0;                 this.data[i] = (int)u;               }             }             // Calculate the correct data length             while (this.wordCount != 0 && this.data[this.wordCount - 1] == 0) {               --this.wordCount;             }             return this;           }         }
Magic Number,PeterO.Cbor,MutableNumber,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\FastInteger2.cs,Subtract,The following statement contains a magic number: unchecked {           {        // Console.WriteLine("" + this.data.Length + " " +              // (other.data.Length));             int neededSize = (this.wordCount > other.wordCount) ?             this.wordCount : other.wordCount;             if (this.data.Length < neededSize) {               var newdata = new int[neededSize + 20];               Array.Copy(this.data' 0' newdata' 0' this.data.Length);               this.data = newdata;             }             neededSize = (this.wordCount < other.wordCount) ? this.wordCount :             other.wordCount;             var u = 0;             var borrow = 0;             for (var i = 0; i < neededSize; ++i) {               int a = this.data[i];               u = (a - other.data[i]) - borrow;               borrow = ((((a >> 31) == (u >> 31)) ? ((a & Int32.MaxValue) <               (u & Int32.MaxValue)) :                     ((a >> 31) == 0)) || (a == u && other.data[i] !=                     0)) ? 1 : 0;               this.data[i] = (int)u;             }             if (borrow != 0) {               for (int i = neededSize; i < this.wordCount; ++i) {                 int a = this.data[i];                 u = (a - other.data[i]) - borrow;                 borrow = ((((a >> 31) == (u >> 31)) ? ((a & Int32.MaxValue) <                 (u & Int32.MaxValue)) :                     ((a >> 31) == 0)) || (a == u && other.data[i] !=                     0)) ? 1 : 0;                 this.data[i] = (int)u;               }             }             // Calculate the correct data length             while (this.wordCount != 0 && this.data[this.wordCount - 1] == 0) {               --this.wordCount;             }             return this;           }         }
Magic Number,PeterO.Cbor,MutableNumber,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\FastInteger2.cs,Add,The following statement contains a magic number: unchecked {         if (augend != 0) {           var carry = 0;           // Ensure a length of at least 1           if (this.wordCount == 0) {             if (this.data.Length == 0) {               this.data = new int[4];             }             this.data[0] = 0;             this.wordCount = 1;           }           for (var i = 0; i < this.wordCount; ++i) {             int u;             int a = this.data[i];             u = (a + augend) + carry;             carry = ((((u >> 31) == (a >> 31)) ? ((u & Int32.MaxValue) < (a &             Int32.MaxValue)) :                     ((u >> 31) == 0)) || (u == a && augend != 0)) ? 1 : 0;             this.data[i] = u;             if (carry == 0) {               return this;             }             augend = 0;           }           if (carry != 0) {             if (this.wordCount >= this.data.Length) {               var newdata = new int[this.wordCount + 20];               Array.Copy(this.data' 0' newdata' 0' this.data.Length);               this.data = newdata;             }             this.data[this.wordCount] = carry;             ++this.wordCount;           }         }         // Calculate the correct data length         while (this.wordCount != 0 && this.data[this.wordCount - 1] == 0) {           --this.wordCount;         }         return this;       }
Magic Number,PeterO.Cbor,MutableNumber,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\FastInteger2.cs,Add,The following statement contains a magic number: unchecked {         if (augend != 0) {           var carry = 0;           // Ensure a length of at least 1           if (this.wordCount == 0) {             if (this.data.Length == 0) {               this.data = new int[4];             }             this.data[0] = 0;             this.wordCount = 1;           }           for (var i = 0; i < this.wordCount; ++i) {             int u;             int a = this.data[i];             u = (a + augend) + carry;             carry = ((((u >> 31) == (a >> 31)) ? ((u & Int32.MaxValue) < (a &             Int32.MaxValue)) :                     ((u >> 31) == 0)) || (u == a && augend != 0)) ? 1 : 0;             this.data[i] = u;             if (carry == 0) {               return this;             }             augend = 0;           }           if (carry != 0) {             if (this.wordCount >= this.data.Length) {               var newdata = new int[this.wordCount + 20];               Array.Copy(this.data' 0' newdata' 0' this.data.Length);               this.data = newdata;             }             this.data[this.wordCount] = carry;             ++this.wordCount;           }         }         // Calculate the correct data length         while (this.wordCount != 0 && this.data[this.wordCount - 1] == 0) {           --this.wordCount;         }         return this;       }
Magic Number,PeterO.Cbor,MutableNumber,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\FastInteger2.cs,Add,The following statement contains a magic number: unchecked {         if (augend != 0) {           var carry = 0;           // Ensure a length of at least 1           if (this.wordCount == 0) {             if (this.data.Length == 0) {               this.data = new int[4];             }             this.data[0] = 0;             this.wordCount = 1;           }           for (var i = 0; i < this.wordCount; ++i) {             int u;             int a = this.data[i];             u = (a + augend) + carry;             carry = ((((u >> 31) == (a >> 31)) ? ((u & Int32.MaxValue) < (a &             Int32.MaxValue)) :                     ((u >> 31) == 0)) || (u == a && augend != 0)) ? 1 : 0;             this.data[i] = u;             if (carry == 0) {               return this;             }             augend = 0;           }           if (carry != 0) {             if (this.wordCount >= this.data.Length) {               var newdata = new int[this.wordCount + 20];               Array.Copy(this.data' 0' newdata' 0' this.data.Length);               this.data = newdata;             }             this.data[this.wordCount] = carry;             ++this.wordCount;           }         }         // Calculate the correct data length         while (this.wordCount != 0 && this.data[this.wordCount - 1] == 0) {           --this.wordCount;         }         return this;       }
Magic Number,PeterO.Cbor,MutableNumber,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\FastInteger2.cs,Add,The following statement contains a magic number: unchecked {         if (augend != 0) {           var carry = 0;           // Ensure a length of at least 1           if (this.wordCount == 0) {             if (this.data.Length == 0) {               this.data = new int[4];             }             this.data[0] = 0;             this.wordCount = 1;           }           for (var i = 0; i < this.wordCount; ++i) {             int u;             int a = this.data[i];             u = (a + augend) + carry;             carry = ((((u >> 31) == (a >> 31)) ? ((u & Int32.MaxValue) < (a &             Int32.MaxValue)) :                     ((u >> 31) == 0)) || (u == a && augend != 0)) ? 1 : 0;             this.data[i] = u;             if (carry == 0) {               return this;             }             augend = 0;           }           if (carry != 0) {             if (this.wordCount >= this.data.Length) {               var newdata = new int[this.wordCount + 20];               Array.Copy(this.data' 0' newdata' 0' this.data.Length);               this.data = newdata;             }             this.data[this.wordCount] = carry;             ++this.wordCount;           }         }         // Calculate the correct data length         while (this.wordCount != 0 && this.data[this.wordCount - 1] == 0) {           --this.wordCount;         }         return this;       }
Magic Number,PeterO.Cbor,MutableNumber,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\FastInteger2.cs,Add,The following statement contains a magic number: unchecked {         if (augend != 0) {           var carry = 0;           // Ensure a length of at least 1           if (this.wordCount == 0) {             if (this.data.Length == 0) {               this.data = new int[4];             }             this.data[0] = 0;             this.wordCount = 1;           }           for (var i = 0; i < this.wordCount; ++i) {             int u;             int a = this.data[i];             u = (a + augend) + carry;             carry = ((((u >> 31) == (a >> 31)) ? ((u & Int32.MaxValue) < (a &             Int32.MaxValue)) :                     ((u >> 31) == 0)) || (u == a && augend != 0)) ? 1 : 0;             this.data[i] = u;             if (carry == 0) {               return this;             }             augend = 0;           }           if (carry != 0) {             if (this.wordCount >= this.data.Length) {               var newdata = new int[this.wordCount + 20];               Array.Copy(this.data' 0' newdata' 0' this.data.Length);               this.data = newdata;             }             this.data[this.wordCount] = carry;             ++this.wordCount;           }         }         // Calculate the correct data length         while (this.wordCount != 0 && this.data[this.wordCount - 1] == 0) {           --this.wordCount;         }         return this;       }
Magic Number,PeterO.Cbor,PropertyMap,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\PropertyMap.cs,GetPropertyList,The following statement contains a magic number: lock (ValuePropertyLists) {         IList<PropertyData> ret;         if (ValuePropertyLists.TryGetValue(t' out ret)) {           return ret;         }         ret = new List<PropertyData>();         bool anonymous = HasCustomAttribute(           t'           "System.Runtime.CompilerServices.CompilerGeneratedAttribute");         foreach (PropertyInfo pi in GetTypeProperties(t)) {           if (pi.CanRead && (pi.CanWrite || anonymous) &&           pi.GetIndexParameters().Length == 0) {             PropertyData pd = new PropertyMap.PropertyData();             pd.Name = pi.Name;             // Convert 'IsXYZ' to 'XYZ'             if (pd.Name.Length >= 3 && pd.Name[0] == 'I' && pd.Name[1] == 's' &&                 pd.Name[2] >= 'A' && pd.Name[2] == 'Z') {               pd.Name = pd.Name.Substring(2);             }             // Convert to camel case             if (pd.Name[0] >= 'A' && pd.Name[0] <= 'Z') {               var sb = new System.Text.StringBuilder();               sb.Append((char)(pd.Name[0] + 0x20));               sb.Append(pd.Name.Substring(1));               pd.Name = sb.ToString();             }             pd.Prop = pi;             ret.Add(pd);           }         }         ValuePropertyLists.Add(t' ret);         return ret;       }
Magic Number,PeterO.Cbor,PropertyMap,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\PropertyMap.cs,GetPropertyList,The following statement contains a magic number: lock (ValuePropertyLists) {         IList<PropertyData> ret;         if (ValuePropertyLists.TryGetValue(t' out ret)) {           return ret;         }         ret = new List<PropertyData>();         bool anonymous = HasCustomAttribute(           t'           "System.Runtime.CompilerServices.CompilerGeneratedAttribute");         foreach (PropertyInfo pi in GetTypeProperties(t)) {           if (pi.CanRead && (pi.CanWrite || anonymous) &&           pi.GetIndexParameters().Length == 0) {             PropertyData pd = new PropertyMap.PropertyData();             pd.Name = pi.Name;             // Convert 'IsXYZ' to 'XYZ'             if (pd.Name.Length >= 3 && pd.Name[0] == 'I' && pd.Name[1] == 's' &&                 pd.Name[2] >= 'A' && pd.Name[2] == 'Z') {               pd.Name = pd.Name.Substring(2);             }             // Convert to camel case             if (pd.Name[0] >= 'A' && pd.Name[0] <= 'Z') {               var sb = new System.Text.StringBuilder();               sb.Append((char)(pd.Name[0] + 0x20));               sb.Append(pd.Name.Substring(1));               pd.Name = sb.ToString();             }             pd.Prop = pi;             ret.Add(pd);           }         }         ValuePropertyLists.Add(t' ret);         return ret;       }
Magic Number,PeterO.Cbor,PropertyMap,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\PropertyMap.cs,GetPropertyList,The following statement contains a magic number: lock (ValuePropertyLists) {         IList<PropertyData> ret;         if (ValuePropertyLists.TryGetValue(t' out ret)) {           return ret;         }         ret = new List<PropertyData>();         bool anonymous = HasCustomAttribute(           t'           "System.Runtime.CompilerServices.CompilerGeneratedAttribute");         foreach (PropertyInfo pi in GetTypeProperties(t)) {           if (pi.CanRead && (pi.CanWrite || anonymous) &&           pi.GetIndexParameters().Length == 0) {             PropertyData pd = new PropertyMap.PropertyData();             pd.Name = pi.Name;             // Convert 'IsXYZ' to 'XYZ'             if (pd.Name.Length >= 3 && pd.Name[0] == 'I' && pd.Name[1] == 's' &&                 pd.Name[2] >= 'A' && pd.Name[2] == 'Z') {               pd.Name = pd.Name.Substring(2);             }             // Convert to camel case             if (pd.Name[0] >= 'A' && pd.Name[0] <= 'Z') {               var sb = new System.Text.StringBuilder();               sb.Append((char)(pd.Name[0] + 0x20));               sb.Append(pd.Name.Substring(1));               pd.Name = sb.ToString();             }             pd.Prop = pi;             ret.Add(pd);           }         }         ValuePropertyLists.Add(t' ret);         return ret;       }
Magic Number,PeterO.Cbor,PropertyMap,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\PropertyMap.cs,GetPropertyList,The following statement contains a magic number: lock (ValuePropertyLists) {         IList<PropertyData> ret;         if (ValuePropertyLists.TryGetValue(t' out ret)) {           return ret;         }         ret = new List<PropertyData>();         bool anonymous = HasCustomAttribute(           t'           "System.Runtime.CompilerServices.CompilerGeneratedAttribute");         foreach (PropertyInfo pi in GetTypeProperties(t)) {           if (pi.CanRead && (pi.CanWrite || anonymous) &&           pi.GetIndexParameters().Length == 0) {             PropertyData pd = new PropertyMap.PropertyData();             pd.Name = pi.Name;             // Convert 'IsXYZ' to 'XYZ'             if (pd.Name.Length >= 3 && pd.Name[0] == 'I' && pd.Name[1] == 's' &&                 pd.Name[2] >= 'A' && pd.Name[2] == 'Z') {               pd.Name = pd.Name.Substring(2);             }             // Convert to camel case             if (pd.Name[0] >= 'A' && pd.Name[0] <= 'Z') {               var sb = new System.Text.StringBuilder();               sb.Append((char)(pd.Name[0] + 0x20));               sb.Append(pd.Name.Substring(1));               pd.Name = sb.ToString();             }             pd.Prop = pi;             ret.Add(pd);           }         }         ValuePropertyLists.Add(t' ret);         return ret;       }
Magic Number,PeterO.Cbor,PropertyMap,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\PropertyMap.cs,EnumToObject,The following statement contains a magic number: if (t.Equals(typeof(ulong))) {         var data = new byte[13];         ulong uvalue = Convert.ToUInt64(value);         data[0] = (byte)(uvalue & 0xff);         data[1] = (byte)((uvalue >> 8) & 0xff);         data[2] = (byte)((uvalue >> 16) & 0xff);         data[3] = (byte)((uvalue >> 24) & 0xff);         data[4] = (byte)((uvalue >> 32) & 0xff);         data[5] = (byte)((uvalue >> 40) & 0xff);         data[6] = (byte)((uvalue >> 48) & 0xff);         data[7] = (byte)((uvalue >> 56) & 0xff);         data[8] = (byte)0;         return EInteger.FromBytes(data' true);       }
Magic Number,PeterO.Cbor,PropertyMap,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\PropertyMap.cs,EnumToObject,The following statement contains a magic number: if (t.Equals(typeof(ulong))) {         var data = new byte[13];         ulong uvalue = Convert.ToUInt64(value);         data[0] = (byte)(uvalue & 0xff);         data[1] = (byte)((uvalue >> 8) & 0xff);         data[2] = (byte)((uvalue >> 16) & 0xff);         data[3] = (byte)((uvalue >> 24) & 0xff);         data[4] = (byte)((uvalue >> 32) & 0xff);         data[5] = (byte)((uvalue >> 40) & 0xff);         data[6] = (byte)((uvalue >> 48) & 0xff);         data[7] = (byte)((uvalue >> 56) & 0xff);         data[8] = (byte)0;         return EInteger.FromBytes(data' true);       }
Magic Number,PeterO.Cbor,PropertyMap,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\PropertyMap.cs,EnumToObject,The following statement contains a magic number: if (t.Equals(typeof(ulong))) {         var data = new byte[13];         ulong uvalue = Convert.ToUInt64(value);         data[0] = (byte)(uvalue & 0xff);         data[1] = (byte)((uvalue >> 8) & 0xff);         data[2] = (byte)((uvalue >> 16) & 0xff);         data[3] = (byte)((uvalue >> 24) & 0xff);         data[4] = (byte)((uvalue >> 32) & 0xff);         data[5] = (byte)((uvalue >> 40) & 0xff);         data[6] = (byte)((uvalue >> 48) & 0xff);         data[7] = (byte)((uvalue >> 56) & 0xff);         data[8] = (byte)0;         return EInteger.FromBytes(data' true);       }
Magic Number,PeterO.Cbor,PropertyMap,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\PropertyMap.cs,EnumToObject,The following statement contains a magic number: if (t.Equals(typeof(ulong))) {         var data = new byte[13];         ulong uvalue = Convert.ToUInt64(value);         data[0] = (byte)(uvalue & 0xff);         data[1] = (byte)((uvalue >> 8) & 0xff);         data[2] = (byte)((uvalue >> 16) & 0xff);         data[3] = (byte)((uvalue >> 24) & 0xff);         data[4] = (byte)((uvalue >> 32) & 0xff);         data[5] = (byte)((uvalue >> 40) & 0xff);         data[6] = (byte)((uvalue >> 48) & 0xff);         data[7] = (byte)((uvalue >> 56) & 0xff);         data[8] = (byte)0;         return EInteger.FromBytes(data' true);       }
Magic Number,PeterO.Cbor,PropertyMap,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\PropertyMap.cs,EnumToObject,The following statement contains a magic number: if (t.Equals(typeof(ulong))) {         var data = new byte[13];         ulong uvalue = Convert.ToUInt64(value);         data[0] = (byte)(uvalue & 0xff);         data[1] = (byte)((uvalue >> 8) & 0xff);         data[2] = (byte)((uvalue >> 16) & 0xff);         data[3] = (byte)((uvalue >> 24) & 0xff);         data[4] = (byte)((uvalue >> 32) & 0xff);         data[5] = (byte)((uvalue >> 40) & 0xff);         data[6] = (byte)((uvalue >> 48) & 0xff);         data[7] = (byte)((uvalue >> 56) & 0xff);         data[8] = (byte)0;         return EInteger.FromBytes(data' true);       }
Magic Number,PeterO.Cbor,PropertyMap,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\PropertyMap.cs,EnumToObject,The following statement contains a magic number: if (t.Equals(typeof(ulong))) {         var data = new byte[13];         ulong uvalue = Convert.ToUInt64(value);         data[0] = (byte)(uvalue & 0xff);         data[1] = (byte)((uvalue >> 8) & 0xff);         data[2] = (byte)((uvalue >> 16) & 0xff);         data[3] = (byte)((uvalue >> 24) & 0xff);         data[4] = (byte)((uvalue >> 32) & 0xff);         data[5] = (byte)((uvalue >> 40) & 0xff);         data[6] = (byte)((uvalue >> 48) & 0xff);         data[7] = (byte)((uvalue >> 56) & 0xff);         data[8] = (byte)0;         return EInteger.FromBytes(data' true);       }
Magic Number,PeterO.Cbor,PropertyMap,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\PropertyMap.cs,EnumToObject,The following statement contains a magic number: if (t.Equals(typeof(ulong))) {         var data = new byte[13];         ulong uvalue = Convert.ToUInt64(value);         data[0] = (byte)(uvalue & 0xff);         data[1] = (byte)((uvalue >> 8) & 0xff);         data[2] = (byte)((uvalue >> 16) & 0xff);         data[3] = (byte)((uvalue >> 24) & 0xff);         data[4] = (byte)((uvalue >> 32) & 0xff);         data[5] = (byte)((uvalue >> 40) & 0xff);         data[6] = (byte)((uvalue >> 48) & 0xff);         data[7] = (byte)((uvalue >> 56) & 0xff);         data[8] = (byte)0;         return EInteger.FromBytes(data' true);       }
Magic Number,PeterO.Cbor,PropertyMap,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\PropertyMap.cs,EnumToObject,The following statement contains a magic number: if (t.Equals(typeof(ulong))) {         var data = new byte[13];         ulong uvalue = Convert.ToUInt64(value);         data[0] = (byte)(uvalue & 0xff);         data[1] = (byte)((uvalue >> 8) & 0xff);         data[2] = (byte)((uvalue >> 16) & 0xff);         data[3] = (byte)((uvalue >> 24) & 0xff);         data[4] = (byte)((uvalue >> 32) & 0xff);         data[5] = (byte)((uvalue >> 40) & 0xff);         data[6] = (byte)((uvalue >> 48) & 0xff);         data[7] = (byte)((uvalue >> 56) & 0xff);         data[8] = (byte)0;         return EInteger.FromBytes(data' true);       }
Magic Number,PeterO.Cbor,PropertyMap,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\PropertyMap.cs,EnumToObject,The following statement contains a magic number: if (t.Equals(typeof(ulong))) {         var data = new byte[13];         ulong uvalue = Convert.ToUInt64(value);         data[0] = (byte)(uvalue & 0xff);         data[1] = (byte)((uvalue >> 8) & 0xff);         data[2] = (byte)((uvalue >> 16) & 0xff);         data[3] = (byte)((uvalue >> 24) & 0xff);         data[4] = (byte)((uvalue >> 32) & 0xff);         data[5] = (byte)((uvalue >> 40) & 0xff);         data[6] = (byte)((uvalue >> 48) & 0xff);         data[7] = (byte)((uvalue >> 56) & 0xff);         data[8] = (byte)0;         return EInteger.FromBytes(data' true);       }
Magic Number,PeterO.Cbor,PropertyMap,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\PropertyMap.cs,EnumToObject,The following statement contains a magic number: if (t.Equals(typeof(ulong))) {         var data = new byte[13];         ulong uvalue = Convert.ToUInt64(value);         data[0] = (byte)(uvalue & 0xff);         data[1] = (byte)((uvalue >> 8) & 0xff);         data[2] = (byte)((uvalue >> 16) & 0xff);         data[3] = (byte)((uvalue >> 24) & 0xff);         data[4] = (byte)((uvalue >> 32) & 0xff);         data[5] = (byte)((uvalue >> 40) & 0xff);         data[6] = (byte)((uvalue >> 48) & 0xff);         data[7] = (byte)((uvalue >> 56) & 0xff);         data[8] = (byte)0;         return EInteger.FromBytes(data' true);       }
Magic Number,PeterO.Cbor,PropertyMap,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\PropertyMap.cs,EnumToObject,The following statement contains a magic number: if (t.Equals(typeof(ulong))) {         var data = new byte[13];         ulong uvalue = Convert.ToUInt64(value);         data[0] = (byte)(uvalue & 0xff);         data[1] = (byte)((uvalue >> 8) & 0xff);         data[2] = (byte)((uvalue >> 16) & 0xff);         data[3] = (byte)((uvalue >> 24) & 0xff);         data[4] = (byte)((uvalue >> 32) & 0xff);         data[5] = (byte)((uvalue >> 40) & 0xff);         data[6] = (byte)((uvalue >> 48) & 0xff);         data[7] = (byte)((uvalue >> 56) & 0xff);         data[8] = (byte)0;         return EInteger.FromBytes(data' true);       }
Magic Number,PeterO.Cbor,PropertyMap,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\PropertyMap.cs,EnumToObject,The following statement contains a magic number: if (t.Equals(typeof(ulong))) {         var data = new byte[13];         ulong uvalue = Convert.ToUInt64(value);         data[0] = (byte)(uvalue & 0xff);         data[1] = (byte)((uvalue >> 8) & 0xff);         data[2] = (byte)((uvalue >> 16) & 0xff);         data[3] = (byte)((uvalue >> 24) & 0xff);         data[4] = (byte)((uvalue >> 32) & 0xff);         data[5] = (byte)((uvalue >> 40) & 0xff);         data[6] = (byte)((uvalue >> 48) & 0xff);         data[7] = (byte)((uvalue >> 56) & 0xff);         data[8] = (byte)0;         return EInteger.FromBytes(data' true);       }
Magic Number,PeterO.Cbor,PropertyMap,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\PropertyMap.cs,EnumToObject,The following statement contains a magic number: if (t.Equals(typeof(ulong))) {         var data = new byte[13];         ulong uvalue = Convert.ToUInt64(value);         data[0] = (byte)(uvalue & 0xff);         data[1] = (byte)((uvalue >> 8) & 0xff);         data[2] = (byte)((uvalue >> 16) & 0xff);         data[3] = (byte)((uvalue >> 24) & 0xff);         data[4] = (byte)((uvalue >> 32) & 0xff);         data[5] = (byte)((uvalue >> 40) & 0xff);         data[6] = (byte)((uvalue >> 48) & 0xff);         data[7] = (byte)((uvalue >> 56) & 0xff);         data[8] = (byte)0;         return EInteger.FromBytes(data' true);       }
Magic Number,PeterO.Cbor,PropertyMap,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\PropertyMap.cs,EnumToObject,The following statement contains a magic number: if (t.Equals(typeof(ulong))) {         var data = new byte[13];         ulong uvalue = Convert.ToUInt64(value);         data[0] = (byte)(uvalue & 0xff);         data[1] = (byte)((uvalue >> 8) & 0xff);         data[2] = (byte)((uvalue >> 16) & 0xff);         data[3] = (byte)((uvalue >> 24) & 0xff);         data[4] = (byte)((uvalue >> 32) & 0xff);         data[5] = (byte)((uvalue >> 40) & 0xff);         data[6] = (byte)((uvalue >> 48) & 0xff);         data[7] = (byte)((uvalue >> 56) & 0xff);         data[8] = (byte)0;         return EInteger.FromBytes(data' true);       }
Magic Number,PeterO.Cbor,PropertyMap,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\PropertyMap.cs,EnumToObject,The following statement contains a magic number: if (t.Equals(typeof(ulong))) {         var data = new byte[13];         ulong uvalue = Convert.ToUInt64(value);         data[0] = (byte)(uvalue & 0xff);         data[1] = (byte)((uvalue >> 8) & 0xff);         data[2] = (byte)((uvalue >> 16) & 0xff);         data[3] = (byte)((uvalue >> 24) & 0xff);         data[4] = (byte)((uvalue >> 32) & 0xff);         data[5] = (byte)((uvalue >> 40) & 0xff);         data[6] = (byte)((uvalue >> 48) & 0xff);         data[7] = (byte)((uvalue >> 56) & 0xff);         data[8] = (byte)0;         return EInteger.FromBytes(data' true);       }
Magic Number,PeterO.Cbor,StringOutput,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\StringOutput.cs,WriteCodePoint,The following statement contains a magic number: if (this.outputStream != null) {         if (codePoint < 0x80) {           this.outputStream.WriteByte((byte)codePoint);         } else if (codePoint <= 0x7ff) {           this.outputStream.WriteByte((byte)(0xc0 | ((codePoint >> 6) & 0x1f)));           this.outputStream.WriteByte((byte)(0x80 | (codePoint & 0x3f)));         } else if (codePoint <= 0xffff) {           if ((codePoint & 0xf800) == 0xd800) {             throw new ArgumentException("ch is a surrogate");           }           this.outputStream.WriteByte((byte)(0xe0 | ((codePoint >> 12) &                     0x0f)));           this.outputStream.WriteByte((byte)(0x80 | ((codePoint >> 6) & 0x3f)));           this.outputStream.WriteByte((byte)(0x80 | (codePoint & 0x3f)));         } else {           this.outputStream.WriteByte((byte)(0xf0 | ((codePoint >> 18) &                     0x08)));           this.outputStream.WriteByte((byte)(0x80 | ((codePoint >> 12) &                     0x3f)));           this.outputStream.WriteByte((byte)(0x80 | ((codePoint >> 6) & 0x3f)));           this.outputStream.WriteByte((byte)(0x80 | (codePoint & 0x3f)));         }       } else {         if ((codePoint & 0xfff800) == 0xd800) {           throw new ArgumentException("ch is a surrogate");         }         if (codePoint <= 0xffff) {           { this.builder.Append((char)codePoint);           }         } else if (codePoint <= 0x10ffff) {           this.builder.Append((char)((((codePoint - 0x10000) >> 10) &                     0x3ff) + 0xd800));           this.builder.Append((char)(((codePoint - 0x10000) & 0x3ff) + 0xdc00));         }       }
Magic Number,PeterO.Cbor,StringOutput,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\StringOutput.cs,WriteCodePoint,The following statement contains a magic number: if (this.outputStream != null) {         if (codePoint < 0x80) {           this.outputStream.WriteByte((byte)codePoint);         } else if (codePoint <= 0x7ff) {           this.outputStream.WriteByte((byte)(0xc0 | ((codePoint >> 6) & 0x1f)));           this.outputStream.WriteByte((byte)(0x80 | (codePoint & 0x3f)));         } else if (codePoint <= 0xffff) {           if ((codePoint & 0xf800) == 0xd800) {             throw new ArgumentException("ch is a surrogate");           }           this.outputStream.WriteByte((byte)(0xe0 | ((codePoint >> 12) &                     0x0f)));           this.outputStream.WriteByte((byte)(0x80 | ((codePoint >> 6) & 0x3f)));           this.outputStream.WriteByte((byte)(0x80 | (codePoint & 0x3f)));         } else {           this.outputStream.WriteByte((byte)(0xf0 | ((codePoint >> 18) &                     0x08)));           this.outputStream.WriteByte((byte)(0x80 | ((codePoint >> 12) &                     0x3f)));           this.outputStream.WriteByte((byte)(0x80 | ((codePoint >> 6) & 0x3f)));           this.outputStream.WriteByte((byte)(0x80 | (codePoint & 0x3f)));         }       } else {         if ((codePoint & 0xfff800) == 0xd800) {           throw new ArgumentException("ch is a surrogate");         }         if (codePoint <= 0xffff) {           { this.builder.Append((char)codePoint);           }         } else if (codePoint <= 0x10ffff) {           this.builder.Append((char)((((codePoint - 0x10000) >> 10) &                     0x3ff) + 0xd800));           this.builder.Append((char)(((codePoint - 0x10000) & 0x3ff) + 0xdc00));         }       }
Magic Number,PeterO.Cbor,StringOutput,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\StringOutput.cs,WriteCodePoint,The following statement contains a magic number: if (this.outputStream != null) {         if (codePoint < 0x80) {           this.outputStream.WriteByte((byte)codePoint);         } else if (codePoint <= 0x7ff) {           this.outputStream.WriteByte((byte)(0xc0 | ((codePoint >> 6) & 0x1f)));           this.outputStream.WriteByte((byte)(0x80 | (codePoint & 0x3f)));         } else if (codePoint <= 0xffff) {           if ((codePoint & 0xf800) == 0xd800) {             throw new ArgumentException("ch is a surrogate");           }           this.outputStream.WriteByte((byte)(0xe0 | ((codePoint >> 12) &                     0x0f)));           this.outputStream.WriteByte((byte)(0x80 | ((codePoint >> 6) & 0x3f)));           this.outputStream.WriteByte((byte)(0x80 | (codePoint & 0x3f)));         } else {           this.outputStream.WriteByte((byte)(0xf0 | ((codePoint >> 18) &                     0x08)));           this.outputStream.WriteByte((byte)(0x80 | ((codePoint >> 12) &                     0x3f)));           this.outputStream.WriteByte((byte)(0x80 | ((codePoint >> 6) & 0x3f)));           this.outputStream.WriteByte((byte)(0x80 | (codePoint & 0x3f)));         }       } else {         if ((codePoint & 0xfff800) == 0xd800) {           throw new ArgumentException("ch is a surrogate");         }         if (codePoint <= 0xffff) {           { this.builder.Append((char)codePoint);           }         } else if (codePoint <= 0x10ffff) {           this.builder.Append((char)((((codePoint - 0x10000) >> 10) &                     0x3ff) + 0xd800));           this.builder.Append((char)(((codePoint - 0x10000) & 0x3ff) + 0xdc00));         }       }
Magic Number,PeterO.Cbor,StringOutput,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\StringOutput.cs,WriteCodePoint,The following statement contains a magic number: if (this.outputStream != null) {         if (codePoint < 0x80) {           this.outputStream.WriteByte((byte)codePoint);         } else if (codePoint <= 0x7ff) {           this.outputStream.WriteByte((byte)(0xc0 | ((codePoint >> 6) & 0x1f)));           this.outputStream.WriteByte((byte)(0x80 | (codePoint & 0x3f)));         } else if (codePoint <= 0xffff) {           if ((codePoint & 0xf800) == 0xd800) {             throw new ArgumentException("ch is a surrogate");           }           this.outputStream.WriteByte((byte)(0xe0 | ((codePoint >> 12) &                     0x0f)));           this.outputStream.WriteByte((byte)(0x80 | ((codePoint >> 6) & 0x3f)));           this.outputStream.WriteByte((byte)(0x80 | (codePoint & 0x3f)));         } else {           this.outputStream.WriteByte((byte)(0xf0 | ((codePoint >> 18) &                     0x08)));           this.outputStream.WriteByte((byte)(0x80 | ((codePoint >> 12) &                     0x3f)));           this.outputStream.WriteByte((byte)(0x80 | ((codePoint >> 6) & 0x3f)));           this.outputStream.WriteByte((byte)(0x80 | (codePoint & 0x3f)));         }       } else {         if ((codePoint & 0xfff800) == 0xd800) {           throw new ArgumentException("ch is a surrogate");         }         if (codePoint <= 0xffff) {           { this.builder.Append((char)codePoint);           }         } else if (codePoint <= 0x10ffff) {           this.builder.Append((char)((((codePoint - 0x10000) >> 10) &                     0x3ff) + 0xd800));           this.builder.Append((char)(((codePoint - 0x10000) & 0x3ff) + 0xdc00));         }       }
Magic Number,PeterO.Cbor,StringOutput,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\StringOutput.cs,WriteCodePoint,The following statement contains a magic number: if (this.outputStream != null) {         if (codePoint < 0x80) {           this.outputStream.WriteByte((byte)codePoint);         } else if (codePoint <= 0x7ff) {           this.outputStream.WriteByte((byte)(0xc0 | ((codePoint >> 6) & 0x1f)));           this.outputStream.WriteByte((byte)(0x80 | (codePoint & 0x3f)));         } else if (codePoint <= 0xffff) {           if ((codePoint & 0xf800) == 0xd800) {             throw new ArgumentException("ch is a surrogate");           }           this.outputStream.WriteByte((byte)(0xe0 | ((codePoint >> 12) &                     0x0f)));           this.outputStream.WriteByte((byte)(0x80 | ((codePoint >> 6) & 0x3f)));           this.outputStream.WriteByte((byte)(0x80 | (codePoint & 0x3f)));         } else {           this.outputStream.WriteByte((byte)(0xf0 | ((codePoint >> 18) &                     0x08)));           this.outputStream.WriteByte((byte)(0x80 | ((codePoint >> 12) &                     0x3f)));           this.outputStream.WriteByte((byte)(0x80 | ((codePoint >> 6) & 0x3f)));           this.outputStream.WriteByte((byte)(0x80 | (codePoint & 0x3f)));         }       } else {         if ((codePoint & 0xfff800) == 0xd800) {           throw new ArgumentException("ch is a surrogate");         }         if (codePoint <= 0xffff) {           { this.builder.Append((char)codePoint);           }         } else if (codePoint <= 0x10ffff) {           this.builder.Append((char)((((codePoint - 0x10000) >> 10) &                     0x3ff) + 0xd800));           this.builder.Append((char)(((codePoint - 0x10000) & 0x3ff) + 0xdc00));         }       }
Magic Number,PeterO.Cbor,StringOutput,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\StringOutput.cs,WriteCodePoint,The following statement contains a magic number: if (this.outputStream != null) {         if (codePoint < 0x80) {           this.outputStream.WriteByte((byte)codePoint);         } else if (codePoint <= 0x7ff) {           this.outputStream.WriteByte((byte)(0xc0 | ((codePoint >> 6) & 0x1f)));           this.outputStream.WriteByte((byte)(0x80 | (codePoint & 0x3f)));         } else if (codePoint <= 0xffff) {           if ((codePoint & 0xf800) == 0xd800) {             throw new ArgumentException("ch is a surrogate");           }           this.outputStream.WriteByte((byte)(0xe0 | ((codePoint >> 12) &                     0x0f)));           this.outputStream.WriteByte((byte)(0x80 | ((codePoint >> 6) & 0x3f)));           this.outputStream.WriteByte((byte)(0x80 | (codePoint & 0x3f)));         } else {           this.outputStream.WriteByte((byte)(0xf0 | ((codePoint >> 18) &                     0x08)));           this.outputStream.WriteByte((byte)(0x80 | ((codePoint >> 12) &                     0x3f)));           this.outputStream.WriteByte((byte)(0x80 | ((codePoint >> 6) & 0x3f)));           this.outputStream.WriteByte((byte)(0x80 | (codePoint & 0x3f)));         }       } else {         if ((codePoint & 0xfff800) == 0xd800) {           throw new ArgumentException("ch is a surrogate");         }         if (codePoint <= 0xffff) {           { this.builder.Append((char)codePoint);           }         } else if (codePoint <= 0x10ffff) {           this.builder.Append((char)((((codePoint - 0x10000) >> 10) &                     0x3ff) + 0xd800));           this.builder.Append((char)(((codePoint - 0x10000) & 0x3ff) + 0xdc00));         }       }
Magic Number,PeterO.Cbor,StringOutput,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\StringOutput.cs,WriteCodePoint,The following statement contains a magic number: if (this.outputStream != null) {         if (codePoint < 0x80) {           this.outputStream.WriteByte((byte)codePoint);         } else if (codePoint <= 0x7ff) {           this.outputStream.WriteByte((byte)(0xc0 | ((codePoint >> 6) & 0x1f)));           this.outputStream.WriteByte((byte)(0x80 | (codePoint & 0x3f)));         } else if (codePoint <= 0xffff) {           if ((codePoint & 0xf800) == 0xd800) {             throw new ArgumentException("ch is a surrogate");           }           this.outputStream.WriteByte((byte)(0xe0 | ((codePoint >> 12) &                     0x0f)));           this.outputStream.WriteByte((byte)(0x80 | ((codePoint >> 6) & 0x3f)));           this.outputStream.WriteByte((byte)(0x80 | (codePoint & 0x3f)));         } else {           this.outputStream.WriteByte((byte)(0xf0 | ((codePoint >> 18) &                     0x08)));           this.outputStream.WriteByte((byte)(0x80 | ((codePoint >> 12) &                     0x3f)));           this.outputStream.WriteByte((byte)(0x80 | ((codePoint >> 6) & 0x3f)));           this.outputStream.WriteByte((byte)(0x80 | (codePoint & 0x3f)));         }       } else {         if ((codePoint & 0xfff800) == 0xd800) {           throw new ArgumentException("ch is a surrogate");         }         if (codePoint <= 0xffff) {           { this.builder.Append((char)codePoint);           }         } else if (codePoint <= 0x10ffff) {           this.builder.Append((char)((((codePoint - 0x10000) >> 10) &                     0x3ff) + 0xd800));           this.builder.Append((char)(((codePoint - 0x10000) & 0x3ff) + 0xdc00));         }       }
Magic Number,PeterO.Cbor,StringRefs,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\StringRefs.cs,AddStringIfNeeded,The following statement contains a magic number: if (lastList.Count < 24) {         addStr |= lengthHint >= 3;       } else if (lastList.Count < 256) {         addStr |= lengthHint >= 4;       } else if (lastList.Count < 65536) {         addStr |= lengthHint >= 5;       } else {         // NOTE: lastList's size can't be higher than (2^64)-1         addStr |= lengthHint >= 7;       }
Magic Number,PeterO.Cbor,StringRefs,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\StringRefs.cs,AddStringIfNeeded,The following statement contains a magic number: if (lastList.Count < 24) {         addStr |= lengthHint >= 3;       } else if (lastList.Count < 256) {         addStr |= lengthHint >= 4;       } else if (lastList.Count < 65536) {         addStr |= lengthHint >= 5;       } else {         // NOTE: lastList's size can't be higher than (2^64)-1         addStr |= lengthHint >= 7;       }
Magic Number,PeterO.Cbor,StringRefs,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\StringRefs.cs,AddStringIfNeeded,The following statement contains a magic number: if (lastList.Count < 24) {         addStr |= lengthHint >= 3;       } else if (lastList.Count < 256) {         addStr |= lengthHint >= 4;       } else if (lastList.Count < 65536) {         addStr |= lengthHint >= 5;       } else {         // NOTE: lastList's size can't be higher than (2^64)-1         addStr |= lengthHint >= 7;       }
Magic Number,PeterO.Cbor,StringRefs,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\StringRefs.cs,AddStringIfNeeded,The following statement contains a magic number: if (lastList.Count < 24) {         addStr |= lengthHint >= 3;       } else if (lastList.Count < 256) {         addStr |= lengthHint >= 4;       } else if (lastList.Count < 65536) {         addStr |= lengthHint >= 5;       } else {         // NOTE: lastList's size can't be higher than (2^64)-1         addStr |= lengthHint >= 7;       }
Magic Number,PeterO.Cbor,StringRefs,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\StringRefs.cs,AddStringIfNeeded,The following statement contains a magic number: if (lastList.Count < 24) {         addStr |= lengthHint >= 3;       } else if (lastList.Count < 256) {         addStr |= lengthHint >= 4;       } else if (lastList.Count < 65536) {         addStr |= lengthHint >= 5;       } else {         // NOTE: lastList's size can't be higher than (2^64)-1         addStr |= lengthHint >= 7;       }
Magic Number,PeterO.Cbor,StringRefs,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\StringRefs.cs,AddStringIfNeeded,The following statement contains a magic number: if (lastList.Count < 24) {         addStr |= lengthHint >= 3;       } else if (lastList.Count < 256) {         addStr |= lengthHint >= 4;       } else if (lastList.Count < 65536) {         addStr |= lengthHint >= 5;       } else {         // NOTE: lastList's size can't be higher than (2^64)-1         addStr |= lengthHint >= 7;       }
Magic Number,PeterO.Cbor,StringRefs,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\StringRefs.cs,AddStringIfNeeded,The following statement contains a magic number: if (lastList.Count < 24) {         addStr |= lengthHint >= 3;       } else if (lastList.Count < 256) {         addStr |= lengthHint >= 4;       } else if (lastList.Count < 65536) {         addStr |= lengthHint >= 5;       } else {         // NOTE: lastList's size can't be higher than (2^64)-1         addStr |= lengthHint >= 7;       }
Magic Number,PeterO.Cbor,URIUtility,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\URIUtility.cs,appendAuthority,The following statement contains a magic number: if (segments[2] >= 0) {         builder.Append("//");         builder.Append(   refValue.Substring(   segments[2]'   segments[3] - segments[2]));       }
Magic Number,PeterO.Cbor,URIUtility,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\URIUtility.cs,appendAuthority,The following statement contains a magic number: if (segments[2] >= 0) {         builder.Append("//");         builder.Append(   refValue.Substring(   segments[2]'   segments[3] - segments[2]));       }
Magic Number,PeterO.Cbor,URIUtility,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\URIUtility.cs,appendAuthority,The following statement contains a magic number: if (segments[2] >= 0) {         builder.Append("//");         builder.Append(   refValue.Substring(   segments[2]'   segments[3] - segments[2]));       }
Magic Number,PeterO.Cbor,URIUtility,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\URIUtility.cs,appendAuthority,The following statement contains a magic number: if (segments[2] >= 0) {         builder.Append("//");         builder.Append(   refValue.Substring(   segments[2]'   segments[3] - segments[2]));       }
Magic Number,PeterO.Cbor,URIUtility,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\URIUtility.cs,appendFragment,The following statement contains a magic number: if (segments[8] >= 0) {         builder.Append('#');         builder.Append(   refValue.Substring(   segments[8]'   segments[9] - segments[8]));       }
Magic Number,PeterO.Cbor,URIUtility,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\URIUtility.cs,appendFragment,The following statement contains a magic number: if (segments[8] >= 0) {         builder.Append('#');         builder.Append(   refValue.Substring(   segments[8]'   segments[9] - segments[8]));       }
Magic Number,PeterO.Cbor,URIUtility,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\URIUtility.cs,appendFragment,The following statement contains a magic number: if (segments[8] >= 0) {         builder.Append('#');         builder.Append(   refValue.Substring(   segments[8]'   segments[9] - segments[8]));       }
Magic Number,PeterO.Cbor,URIUtility,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\URIUtility.cs,appendFragment,The following statement contains a magic number: if (segments[8] >= 0) {         builder.Append('#');         builder.Append(   refValue.Substring(   segments[8]'   segments[9] - segments[8]));       }
Magic Number,PeterO.Cbor,URIUtility,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\URIUtility.cs,appendNormalizedPath,The following statement contains a magic number: builder.Append(         normalizePath(   refValue.Substring(   segments[4]'   segments[5] - segments[4])));
Magic Number,PeterO.Cbor,URIUtility,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\URIUtility.cs,appendNormalizedPath,The following statement contains a magic number: builder.Append(         normalizePath(   refValue.Substring(   segments[4]'   segments[5] - segments[4])));
Magic Number,PeterO.Cbor,URIUtility,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\URIUtility.cs,appendNormalizedPath,The following statement contains a magic number: builder.Append(         normalizePath(   refValue.Substring(   segments[4]'   segments[5] - segments[4])));
Magic Number,PeterO.Cbor,URIUtility,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\URIUtility.cs,appendPath,The following statement contains a magic number: builder.Append(   refValue.Substring(   segments[4]'   segments[5] - segments[4]));
Magic Number,PeterO.Cbor,URIUtility,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\URIUtility.cs,appendPath,The following statement contains a magic number: builder.Append(   refValue.Substring(   segments[4]'   segments[5] - segments[4]));
Magic Number,PeterO.Cbor,URIUtility,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\URIUtility.cs,appendPath,The following statement contains a magic number: builder.Append(   refValue.Substring(   segments[4]'   segments[5] - segments[4]));
Magic Number,PeterO.Cbor,URIUtility,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\URIUtility.cs,appendQuery,The following statement contains a magic number: if (segments[6] >= 0) {         builder.Append('?');         builder.Append(   refValue.Substring(   segments[6]'   segments[7] - segments[6]));       }
Magic Number,PeterO.Cbor,URIUtility,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\URIUtility.cs,appendQuery,The following statement contains a magic number: if (segments[6] >= 0) {         builder.Append('?');         builder.Append(   refValue.Substring(   segments[6]'   segments[7] - segments[6]));       }
Magic Number,PeterO.Cbor,URIUtility,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\URIUtility.cs,appendQuery,The following statement contains a magic number: if (segments[6] >= 0) {         builder.Append('?');         builder.Append(   refValue.Substring(   segments[6]'   segments[7] - segments[6]));       }
Magic Number,PeterO.Cbor,URIUtility,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\URIUtility.cs,appendQuery,The following statement contains a magic number: if (segments[6] >= 0) {         builder.Append('?');         builder.Append(   refValue.Substring(   segments[6]'   segments[7] - segments[6]));       }
Magic Number,PeterO.Cbor,URIUtility,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\URIUtility.cs,escapeURI,The following statement contains a magic number: while (index < valueSLength) {         int c = s[index];         if ((c & 0xfc00) == 0xd800 && index + 1 < valueSLength &&             s[index + 1] >= 0xdc00 && s[index + 1] <= 0xdfff) {           // Get the Unicode code point for the surrogate pair           c = 0x10000 + ((c - 0xd800) << 10) + (s[index + 1] - 0xdc00);           ++index;         } else if ((c & 0xf800) == 0xd800) {           c = 0xfffd;         }         if (mode == 0 || mode == 3) {           if (c == '%' && mode == 3) {             // Check for illegal percent encoding             if (index + 2 >= valueSLength || !isHexChar(s[index + 1]) ||                 !isHexChar(s[index + 2])) {               percentEncodeUtf8(builder' c);             } else {               if (c <= 0xffff) {                 builder.Append((char)c);               } else if (c <= 0x10ffff) {                 builder.Append((char)((((c - 0x10000) >> 10) & 0x3ff) +                     0xd800));                 builder.Append((char)(((c - 0x10000) & 0x3ff) + 0xdc00));               }             }             ++index;             continue;           }           if (c >= 0x7f || c <= 0x20 ||               ((c & 0x7f) == c && "{}|^\\`<>\"".IndexOf((char)c) >= 0)) {             percentEncodeUtf8(builder' c);           } else if (c == '[' || c == ']') {             if (components != null && index >= components[2] && index <                 components[3]) {               // within the authority component' so don't percent-encode               if (c <= 0xffff) {                 builder.Append((char)c);               } else if (c <= 0x10ffff) {                 builder.Append((char)((((c - 0x10000) >> 10) & 0x3ff) +                     0xd800));                 builder.Append((char)(((c - 0x10000) & 0x3ff) + 0xdc00));               }             } else {               // percent encode               percentEncodeUtf8(builder' c);             }           } else {             if (c <= 0xffff) {               builder.Append((char)c);             } else if (c <= 0x10ffff) {               builder.Append((char)((((c - 0x10000) >> 10) & 0x3ff) + 0xd800));               builder.Append((char)(((c - 0x10000) & 0x3ff) + 0xdc00));             }           }         } else if (mode == 1 || mode == 2) {           if (c >= 0x80) {             percentEncodeUtf8(builder' c);           } else if (c == '[' || c == ']') {             if (components != null && index >= components[2] && index <                 components[3]) {               // within the authority component' so don't percent-encode               if (c <= 0xffff) {                 builder.Append((char)c);               } else if (c <= 0x10ffff) {                 builder.Append((char)((((c - 0x10000) >> 10) & 0x3ff) +                     0xd800));                 builder.Append((char)(((c - 0x10000) & 0x3ff) + 0xdc00));               }             } else {               // percent encode               percentEncodeUtf8(builder' c);             }           } else {             if (c <= 0xffff) {               builder.Append((char)c);             } else if (c <= 0x10ffff) {               builder.Append((char)((((c - 0x10000) >> 10) & 0x3ff) + 0xd800));               builder.Append((char)(((c - 0x10000) & 0x3ff) + 0xdc00));             }           }         }         ++index;       }
Magic Number,PeterO.Cbor,URIUtility,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\URIUtility.cs,escapeURI,The following statement contains a magic number: while (index < valueSLength) {         int c = s[index];         if ((c & 0xfc00) == 0xd800 && index + 1 < valueSLength &&             s[index + 1] >= 0xdc00 && s[index + 1] <= 0xdfff) {           // Get the Unicode code point for the surrogate pair           c = 0x10000 + ((c - 0xd800) << 10) + (s[index + 1] - 0xdc00);           ++index;         } else if ((c & 0xf800) == 0xd800) {           c = 0xfffd;         }         if (mode == 0 || mode == 3) {           if (c == '%' && mode == 3) {             // Check for illegal percent encoding             if (index + 2 >= valueSLength || !isHexChar(s[index + 1]) ||                 !isHexChar(s[index + 2])) {               percentEncodeUtf8(builder' c);             } else {               if (c <= 0xffff) {                 builder.Append((char)c);               } else if (c <= 0x10ffff) {                 builder.Append((char)((((c - 0x10000) >> 10) & 0x3ff) +                     0xd800));                 builder.Append((char)(((c - 0x10000) & 0x3ff) + 0xdc00));               }             }             ++index;             continue;           }           if (c >= 0x7f || c <= 0x20 ||               ((c & 0x7f) == c && "{}|^\\`<>\"".IndexOf((char)c) >= 0)) {             percentEncodeUtf8(builder' c);           } else if (c == '[' || c == ']') {             if (components != null && index >= components[2] && index <                 components[3]) {               // within the authority component' so don't percent-encode               if (c <= 0xffff) {                 builder.Append((char)c);               } else if (c <= 0x10ffff) {                 builder.Append((char)((((c - 0x10000) >> 10) & 0x3ff) +                     0xd800));                 builder.Append((char)(((c - 0x10000) & 0x3ff) + 0xdc00));               }             } else {               // percent encode               percentEncodeUtf8(builder' c);             }           } else {             if (c <= 0xffff) {               builder.Append((char)c);             } else if (c <= 0x10ffff) {               builder.Append((char)((((c - 0x10000) >> 10) & 0x3ff) + 0xd800));               builder.Append((char)(((c - 0x10000) & 0x3ff) + 0xdc00));             }           }         } else if (mode == 1 || mode == 2) {           if (c >= 0x80) {             percentEncodeUtf8(builder' c);           } else if (c == '[' || c == ']') {             if (components != null && index >= components[2] && index <                 components[3]) {               // within the authority component' so don't percent-encode               if (c <= 0xffff) {                 builder.Append((char)c);               } else if (c <= 0x10ffff) {                 builder.Append((char)((((c - 0x10000) >> 10) & 0x3ff) +                     0xd800));                 builder.Append((char)(((c - 0x10000) & 0x3ff) + 0xdc00));               }             } else {               // percent encode               percentEncodeUtf8(builder' c);             }           } else {             if (c <= 0xffff) {               builder.Append((char)c);             } else if (c <= 0x10ffff) {               builder.Append((char)((((c - 0x10000) >> 10) & 0x3ff) + 0xd800));               builder.Append((char)(((c - 0x10000) & 0x3ff) + 0xdc00));             }           }         }         ++index;       }
Magic Number,PeterO.Cbor,URIUtility,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\URIUtility.cs,escapeURI,The following statement contains a magic number: while (index < valueSLength) {         int c = s[index];         if ((c & 0xfc00) == 0xd800 && index + 1 < valueSLength &&             s[index + 1] >= 0xdc00 && s[index + 1] <= 0xdfff) {           // Get the Unicode code point for the surrogate pair           c = 0x10000 + ((c - 0xd800) << 10) + (s[index + 1] - 0xdc00);           ++index;         } else if ((c & 0xf800) == 0xd800) {           c = 0xfffd;         }         if (mode == 0 || mode == 3) {           if (c == '%' && mode == 3) {             // Check for illegal percent encoding             if (index + 2 >= valueSLength || !isHexChar(s[index + 1]) ||                 !isHexChar(s[index + 2])) {               percentEncodeUtf8(builder' c);             } else {               if (c <= 0xffff) {                 builder.Append((char)c);               } else if (c <= 0x10ffff) {                 builder.Append((char)((((c - 0x10000) >> 10) & 0x3ff) +                     0xd800));                 builder.Append((char)(((c - 0x10000) & 0x3ff) + 0xdc00));               }             }             ++index;             continue;           }           if (c >= 0x7f || c <= 0x20 ||               ((c & 0x7f) == c && "{}|^\\`<>\"".IndexOf((char)c) >= 0)) {             percentEncodeUtf8(builder' c);           } else if (c == '[' || c == ']') {             if (components != null && index >= components[2] && index <                 components[3]) {               // within the authority component' so don't percent-encode               if (c <= 0xffff) {                 builder.Append((char)c);               } else if (c <= 0x10ffff) {                 builder.Append((char)((((c - 0x10000) >> 10) & 0x3ff) +                     0xd800));                 builder.Append((char)(((c - 0x10000) & 0x3ff) + 0xdc00));               }             } else {               // percent encode               percentEncodeUtf8(builder' c);             }           } else {             if (c <= 0xffff) {               builder.Append((char)c);             } else if (c <= 0x10ffff) {               builder.Append((char)((((c - 0x10000) >> 10) & 0x3ff) + 0xd800));               builder.Append((char)(((c - 0x10000) & 0x3ff) + 0xdc00));             }           }         } else if (mode == 1 || mode == 2) {           if (c >= 0x80) {             percentEncodeUtf8(builder' c);           } else if (c == '[' || c == ']') {             if (components != null && index >= components[2] && index <                 components[3]) {               // within the authority component' so don't percent-encode               if (c <= 0xffff) {                 builder.Append((char)c);               } else if (c <= 0x10ffff) {                 builder.Append((char)((((c - 0x10000) >> 10) & 0x3ff) +                     0xd800));                 builder.Append((char)(((c - 0x10000) & 0x3ff) + 0xdc00));               }             } else {               // percent encode               percentEncodeUtf8(builder' c);             }           } else {             if (c <= 0xffff) {               builder.Append((char)c);             } else if (c <= 0x10ffff) {               builder.Append((char)((((c - 0x10000) >> 10) & 0x3ff) + 0xd800));               builder.Append((char)(((c - 0x10000) & 0x3ff) + 0xdc00));             }           }         }         ++index;       }
Magic Number,PeterO.Cbor,URIUtility,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\URIUtility.cs,escapeURI,The following statement contains a magic number: while (index < valueSLength) {         int c = s[index];         if ((c & 0xfc00) == 0xd800 && index + 1 < valueSLength &&             s[index + 1] >= 0xdc00 && s[index + 1] <= 0xdfff) {           // Get the Unicode code point for the surrogate pair           c = 0x10000 + ((c - 0xd800) << 10) + (s[index + 1] - 0xdc00);           ++index;         } else if ((c & 0xf800) == 0xd800) {           c = 0xfffd;         }         if (mode == 0 || mode == 3) {           if (c == '%' && mode == 3) {             // Check for illegal percent encoding             if (index + 2 >= valueSLength || !isHexChar(s[index + 1]) ||                 !isHexChar(s[index + 2])) {               percentEncodeUtf8(builder' c);             } else {               if (c <= 0xffff) {                 builder.Append((char)c);               } else if (c <= 0x10ffff) {                 builder.Append((char)((((c - 0x10000) >> 10) & 0x3ff) +                     0xd800));                 builder.Append((char)(((c - 0x10000) & 0x3ff) + 0xdc00));               }             }             ++index;             continue;           }           if (c >= 0x7f || c <= 0x20 ||               ((c & 0x7f) == c && "{}|^\\`<>\"".IndexOf((char)c) >= 0)) {             percentEncodeUtf8(builder' c);           } else if (c == '[' || c == ']') {             if (components != null && index >= components[2] && index <                 components[3]) {               // within the authority component' so don't percent-encode               if (c <= 0xffff) {                 builder.Append((char)c);               } else if (c <= 0x10ffff) {                 builder.Append((char)((((c - 0x10000) >> 10) & 0x3ff) +                     0xd800));                 builder.Append((char)(((c - 0x10000) & 0x3ff) + 0xdc00));               }             } else {               // percent encode               percentEncodeUtf8(builder' c);             }           } else {             if (c <= 0xffff) {               builder.Append((char)c);             } else if (c <= 0x10ffff) {               builder.Append((char)((((c - 0x10000) >> 10) & 0x3ff) + 0xd800));               builder.Append((char)(((c - 0x10000) & 0x3ff) + 0xdc00));             }           }         } else if (mode == 1 || mode == 2) {           if (c >= 0x80) {             percentEncodeUtf8(builder' c);           } else if (c == '[' || c == ']') {             if (components != null && index >= components[2] && index <                 components[3]) {               // within the authority component' so don't percent-encode               if (c <= 0xffff) {                 builder.Append((char)c);               } else if (c <= 0x10ffff) {                 builder.Append((char)((((c - 0x10000) >> 10) & 0x3ff) +                     0xd800));                 builder.Append((char)(((c - 0x10000) & 0x3ff) + 0xdc00));               }             } else {               // percent encode               percentEncodeUtf8(builder' c);             }           } else {             if (c <= 0xffff) {               builder.Append((char)c);             } else if (c <= 0x10ffff) {               builder.Append((char)((((c - 0x10000) >> 10) & 0x3ff) + 0xd800));               builder.Append((char)(((c - 0x10000) & 0x3ff) + 0xdc00));             }           }         }         ++index;       }
Magic Number,PeterO.Cbor,URIUtility,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\URIUtility.cs,escapeURI,The following statement contains a magic number: while (index < valueSLength) {         int c = s[index];         if ((c & 0xfc00) == 0xd800 && index + 1 < valueSLength &&             s[index + 1] >= 0xdc00 && s[index + 1] <= 0xdfff) {           // Get the Unicode code point for the surrogate pair           c = 0x10000 + ((c - 0xd800) << 10) + (s[index + 1] - 0xdc00);           ++index;         } else if ((c & 0xf800) == 0xd800) {           c = 0xfffd;         }         if (mode == 0 || mode == 3) {           if (c == '%' && mode == 3) {             // Check for illegal percent encoding             if (index + 2 >= valueSLength || !isHexChar(s[index + 1]) ||                 !isHexChar(s[index + 2])) {               percentEncodeUtf8(builder' c);             } else {               if (c <= 0xffff) {                 builder.Append((char)c);               } else if (c <= 0x10ffff) {                 builder.Append((char)((((c - 0x10000) >> 10) & 0x3ff) +                     0xd800));                 builder.Append((char)(((c - 0x10000) & 0x3ff) + 0xdc00));               }             }             ++index;             continue;           }           if (c >= 0x7f || c <= 0x20 ||               ((c & 0x7f) == c && "{}|^\\`<>\"".IndexOf((char)c) >= 0)) {             percentEncodeUtf8(builder' c);           } else if (c == '[' || c == ']') {             if (components != null && index >= components[2] && index <                 components[3]) {               // within the authority component' so don't percent-encode               if (c <= 0xffff) {                 builder.Append((char)c);               } else if (c <= 0x10ffff) {                 builder.Append((char)((((c - 0x10000) >> 10) & 0x3ff) +                     0xd800));                 builder.Append((char)(((c - 0x10000) & 0x3ff) + 0xdc00));               }             } else {               // percent encode               percentEncodeUtf8(builder' c);             }           } else {             if (c <= 0xffff) {               builder.Append((char)c);             } else if (c <= 0x10ffff) {               builder.Append((char)((((c - 0x10000) >> 10) & 0x3ff) + 0xd800));               builder.Append((char)(((c - 0x10000) & 0x3ff) + 0xdc00));             }           }         } else if (mode == 1 || mode == 2) {           if (c >= 0x80) {             percentEncodeUtf8(builder' c);           } else if (c == '[' || c == ']') {             if (components != null && index >= components[2] && index <                 components[3]) {               // within the authority component' so don't percent-encode               if (c <= 0xffff) {                 builder.Append((char)c);               } else if (c <= 0x10ffff) {                 builder.Append((char)((((c - 0x10000) >> 10) & 0x3ff) +                     0xd800));                 builder.Append((char)(((c - 0x10000) & 0x3ff) + 0xdc00));               }             } else {               // percent encode               percentEncodeUtf8(builder' c);             }           } else {             if (c <= 0xffff) {               builder.Append((char)c);             } else if (c <= 0x10ffff) {               builder.Append((char)((((c - 0x10000) >> 10) & 0x3ff) + 0xd800));               builder.Append((char)(((c - 0x10000) & 0x3ff) + 0xdc00));             }           }         }         ++index;       }
Magic Number,PeterO.Cbor,URIUtility,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\URIUtility.cs,escapeURI,The following statement contains a magic number: while (index < valueSLength) {         int c = s[index];         if ((c & 0xfc00) == 0xd800 && index + 1 < valueSLength &&             s[index + 1] >= 0xdc00 && s[index + 1] <= 0xdfff) {           // Get the Unicode code point for the surrogate pair           c = 0x10000 + ((c - 0xd800) << 10) + (s[index + 1] - 0xdc00);           ++index;         } else if ((c & 0xf800) == 0xd800) {           c = 0xfffd;         }         if (mode == 0 || mode == 3) {           if (c == '%' && mode == 3) {             // Check for illegal percent encoding             if (index + 2 >= valueSLength || !isHexChar(s[index + 1]) ||                 !isHexChar(s[index + 2])) {               percentEncodeUtf8(builder' c);             } else {               if (c <= 0xffff) {                 builder.Append((char)c);               } else if (c <= 0x10ffff) {                 builder.Append((char)((((c - 0x10000) >> 10) & 0x3ff) +                     0xd800));                 builder.Append((char)(((c - 0x10000) & 0x3ff) + 0xdc00));               }             }             ++index;             continue;           }           if (c >= 0x7f || c <= 0x20 ||               ((c & 0x7f) == c && "{}|^\\`<>\"".IndexOf((char)c) >= 0)) {             percentEncodeUtf8(builder' c);           } else if (c == '[' || c == ']') {             if (components != null && index >= components[2] && index <                 components[3]) {               // within the authority component' so don't percent-encode               if (c <= 0xffff) {                 builder.Append((char)c);               } else if (c <= 0x10ffff) {                 builder.Append((char)((((c - 0x10000) >> 10) & 0x3ff) +                     0xd800));                 builder.Append((char)(((c - 0x10000) & 0x3ff) + 0xdc00));               }             } else {               // percent encode               percentEncodeUtf8(builder' c);             }           } else {             if (c <= 0xffff) {               builder.Append((char)c);             } else if (c <= 0x10ffff) {               builder.Append((char)((((c - 0x10000) >> 10) & 0x3ff) + 0xd800));               builder.Append((char)(((c - 0x10000) & 0x3ff) + 0xdc00));             }           }         } else if (mode == 1 || mode == 2) {           if (c >= 0x80) {             percentEncodeUtf8(builder' c);           } else if (c == '[' || c == ']') {             if (components != null && index >= components[2] && index <                 components[3]) {               // within the authority component' so don't percent-encode               if (c <= 0xffff) {                 builder.Append((char)c);               } else if (c <= 0x10ffff) {                 builder.Append((char)((((c - 0x10000) >> 10) & 0x3ff) +                     0xd800));                 builder.Append((char)(((c - 0x10000) & 0x3ff) + 0xdc00));               }             } else {               // percent encode               percentEncodeUtf8(builder' c);             }           } else {             if (c <= 0xffff) {               builder.Append((char)c);             } else if (c <= 0x10ffff) {               builder.Append((char)((((c - 0x10000) >> 10) & 0x3ff) + 0xd800));               builder.Append((char)(((c - 0x10000) & 0x3ff) + 0xdc00));             }           }         }         ++index;       }
Magic Number,PeterO.Cbor,URIUtility,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\URIUtility.cs,escapeURI,The following statement contains a magic number: while (index < valueSLength) {         int c = s[index];         if ((c & 0xfc00) == 0xd800 && index + 1 < valueSLength &&             s[index + 1] >= 0xdc00 && s[index + 1] <= 0xdfff) {           // Get the Unicode code point for the surrogate pair           c = 0x10000 + ((c - 0xd800) << 10) + (s[index + 1] - 0xdc00);           ++index;         } else if ((c & 0xf800) == 0xd800) {           c = 0xfffd;         }         if (mode == 0 || mode == 3) {           if (c == '%' && mode == 3) {             // Check for illegal percent encoding             if (index + 2 >= valueSLength || !isHexChar(s[index + 1]) ||                 !isHexChar(s[index + 2])) {               percentEncodeUtf8(builder' c);             } else {               if (c <= 0xffff) {                 builder.Append((char)c);               } else if (c <= 0x10ffff) {                 builder.Append((char)((((c - 0x10000) >> 10) & 0x3ff) +                     0xd800));                 builder.Append((char)(((c - 0x10000) & 0x3ff) + 0xdc00));               }             }             ++index;             continue;           }           if (c >= 0x7f || c <= 0x20 ||               ((c & 0x7f) == c && "{}|^\\`<>\"".IndexOf((char)c) >= 0)) {             percentEncodeUtf8(builder' c);           } else if (c == '[' || c == ']') {             if (components != null && index >= components[2] && index <                 components[3]) {               // within the authority component' so don't percent-encode               if (c <= 0xffff) {                 builder.Append((char)c);               } else if (c <= 0x10ffff) {                 builder.Append((char)((((c - 0x10000) >> 10) & 0x3ff) +                     0xd800));                 builder.Append((char)(((c - 0x10000) & 0x3ff) + 0xdc00));               }             } else {               // percent encode               percentEncodeUtf8(builder' c);             }           } else {             if (c <= 0xffff) {               builder.Append((char)c);             } else if (c <= 0x10ffff) {               builder.Append((char)((((c - 0x10000) >> 10) & 0x3ff) + 0xd800));               builder.Append((char)(((c - 0x10000) & 0x3ff) + 0xdc00));             }           }         } else if (mode == 1 || mode == 2) {           if (c >= 0x80) {             percentEncodeUtf8(builder' c);           } else if (c == '[' || c == ']') {             if (components != null && index >= components[2] && index <                 components[3]) {               // within the authority component' so don't percent-encode               if (c <= 0xffff) {                 builder.Append((char)c);               } else if (c <= 0x10ffff) {                 builder.Append((char)((((c - 0x10000) >> 10) & 0x3ff) +                     0xd800));                 builder.Append((char)(((c - 0x10000) & 0x3ff) + 0xdc00));               }             } else {               // percent encode               percentEncodeUtf8(builder' c);             }           } else {             if (c <= 0xffff) {               builder.Append((char)c);             } else if (c <= 0x10ffff) {               builder.Append((char)((((c - 0x10000) >> 10) & 0x3ff) + 0xd800));               builder.Append((char)(((c - 0x10000) & 0x3ff) + 0xdc00));             }           }         }         ++index;       }
Magic Number,PeterO.Cbor,URIUtility,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\URIUtility.cs,escapeURI,The following statement contains a magic number: while (index < valueSLength) {         int c = s[index];         if ((c & 0xfc00) == 0xd800 && index + 1 < valueSLength &&             s[index + 1] >= 0xdc00 && s[index + 1] <= 0xdfff) {           // Get the Unicode code point for the surrogate pair           c = 0x10000 + ((c - 0xd800) << 10) + (s[index + 1] - 0xdc00);           ++index;         } else if ((c & 0xf800) == 0xd800) {           c = 0xfffd;         }         if (mode == 0 || mode == 3) {           if (c == '%' && mode == 3) {             // Check for illegal percent encoding             if (index + 2 >= valueSLength || !isHexChar(s[index + 1]) ||                 !isHexChar(s[index + 2])) {               percentEncodeUtf8(builder' c);             } else {               if (c <= 0xffff) {                 builder.Append((char)c);               } else if (c <= 0x10ffff) {                 builder.Append((char)((((c - 0x10000) >> 10) & 0x3ff) +                     0xd800));                 builder.Append((char)(((c - 0x10000) & 0x3ff) + 0xdc00));               }             }             ++index;             continue;           }           if (c >= 0x7f || c <= 0x20 ||               ((c & 0x7f) == c && "{}|^\\`<>\"".IndexOf((char)c) >= 0)) {             percentEncodeUtf8(builder' c);           } else if (c == '[' || c == ']') {             if (components != null && index >= components[2] && index <                 components[3]) {               // within the authority component' so don't percent-encode               if (c <= 0xffff) {                 builder.Append((char)c);               } else if (c <= 0x10ffff) {                 builder.Append((char)((((c - 0x10000) >> 10) & 0x3ff) +                     0xd800));                 builder.Append((char)(((c - 0x10000) & 0x3ff) + 0xdc00));               }             } else {               // percent encode               percentEncodeUtf8(builder' c);             }           } else {             if (c <= 0xffff) {               builder.Append((char)c);             } else if (c <= 0x10ffff) {               builder.Append((char)((((c - 0x10000) >> 10) & 0x3ff) + 0xd800));               builder.Append((char)(((c - 0x10000) & 0x3ff) + 0xdc00));             }           }         } else if (mode == 1 || mode == 2) {           if (c >= 0x80) {             percentEncodeUtf8(builder' c);           } else if (c == '[' || c == ']') {             if (components != null && index >= components[2] && index <                 components[3]) {               // within the authority component' so don't percent-encode               if (c <= 0xffff) {                 builder.Append((char)c);               } else if (c <= 0x10ffff) {                 builder.Append((char)((((c - 0x10000) >> 10) & 0x3ff) +                     0xd800));                 builder.Append((char)(((c - 0x10000) & 0x3ff) + 0xdc00));               }             } else {               // percent encode               percentEncodeUtf8(builder' c);             }           } else {             if (c <= 0xffff) {               builder.Append((char)c);             } else if (c <= 0x10ffff) {               builder.Append((char)((((c - 0x10000) >> 10) & 0x3ff) + 0xd800));               builder.Append((char)(((c - 0x10000) & 0x3ff) + 0xdc00));             }           }         }         ++index;       }
Magic Number,PeterO.Cbor,URIUtility,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\URIUtility.cs,escapeURI,The following statement contains a magic number: while (index < valueSLength) {         int c = s[index];         if ((c & 0xfc00) == 0xd800 && index + 1 < valueSLength &&             s[index + 1] >= 0xdc00 && s[index + 1] <= 0xdfff) {           // Get the Unicode code point for the surrogate pair           c = 0x10000 + ((c - 0xd800) << 10) + (s[index + 1] - 0xdc00);           ++index;         } else if ((c & 0xf800) == 0xd800) {           c = 0xfffd;         }         if (mode == 0 || mode == 3) {           if (c == '%' && mode == 3) {             // Check for illegal percent encoding             if (index + 2 >= valueSLength || !isHexChar(s[index + 1]) ||                 !isHexChar(s[index + 2])) {               percentEncodeUtf8(builder' c);             } else {               if (c <= 0xffff) {                 builder.Append((char)c);               } else if (c <= 0x10ffff) {                 builder.Append((char)((((c - 0x10000) >> 10) & 0x3ff) +                     0xd800));                 builder.Append((char)(((c - 0x10000) & 0x3ff) + 0xdc00));               }             }             ++index;             continue;           }           if (c >= 0x7f || c <= 0x20 ||               ((c & 0x7f) == c && "{}|^\\`<>\"".IndexOf((char)c) >= 0)) {             percentEncodeUtf8(builder' c);           } else if (c == '[' || c == ']') {             if (components != null && index >= components[2] && index <                 components[3]) {               // within the authority component' so don't percent-encode               if (c <= 0xffff) {                 builder.Append((char)c);               } else if (c <= 0x10ffff) {                 builder.Append((char)((((c - 0x10000) >> 10) & 0x3ff) +                     0xd800));                 builder.Append((char)(((c - 0x10000) & 0x3ff) + 0xdc00));               }             } else {               // percent encode               percentEncodeUtf8(builder' c);             }           } else {             if (c <= 0xffff) {               builder.Append((char)c);             } else if (c <= 0x10ffff) {               builder.Append((char)((((c - 0x10000) >> 10) & 0x3ff) + 0xd800));               builder.Append((char)(((c - 0x10000) & 0x3ff) + 0xdc00));             }           }         } else if (mode == 1 || mode == 2) {           if (c >= 0x80) {             percentEncodeUtf8(builder' c);           } else if (c == '[' || c == ']') {             if (components != null && index >= components[2] && index <                 components[3]) {               // within the authority component' so don't percent-encode               if (c <= 0xffff) {                 builder.Append((char)c);               } else if (c <= 0x10ffff) {                 builder.Append((char)((((c - 0x10000) >> 10) & 0x3ff) +                     0xd800));                 builder.Append((char)(((c - 0x10000) & 0x3ff) + 0xdc00));               }             } else {               // percent encode               percentEncodeUtf8(builder' c);             }           } else {             if (c <= 0xffff) {               builder.Append((char)c);             } else if (c <= 0x10ffff) {               builder.Append((char)((((c - 0x10000) >> 10) & 0x3ff) + 0xd800));               builder.Append((char)(((c - 0x10000) & 0x3ff) + 0xdc00));             }           }         }         ++index;       }
Magic Number,PeterO.Cbor,URIUtility,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\URIUtility.cs,escapeURI,The following statement contains a magic number: while (index < valueSLength) {         int c = s[index];         if ((c & 0xfc00) == 0xd800 && index + 1 < valueSLength &&             s[index + 1] >= 0xdc00 && s[index + 1] <= 0xdfff) {           // Get the Unicode code point for the surrogate pair           c = 0x10000 + ((c - 0xd800) << 10) + (s[index + 1] - 0xdc00);           ++index;         } else if ((c & 0xf800) == 0xd800) {           c = 0xfffd;         }         if (mode == 0 || mode == 3) {           if (c == '%' && mode == 3) {             // Check for illegal percent encoding             if (index + 2 >= valueSLength || !isHexChar(s[index + 1]) ||                 !isHexChar(s[index + 2])) {               percentEncodeUtf8(builder' c);             } else {               if (c <= 0xffff) {                 builder.Append((char)c);               } else if (c <= 0x10ffff) {                 builder.Append((char)((((c - 0x10000) >> 10) & 0x3ff) +                     0xd800));                 builder.Append((char)(((c - 0x10000) & 0x3ff) + 0xdc00));               }             }             ++index;             continue;           }           if (c >= 0x7f || c <= 0x20 ||               ((c & 0x7f) == c && "{}|^\\`<>\"".IndexOf((char)c) >= 0)) {             percentEncodeUtf8(builder' c);           } else if (c == '[' || c == ']') {             if (components != null && index >= components[2] && index <                 components[3]) {               // within the authority component' so don't percent-encode               if (c <= 0xffff) {                 builder.Append((char)c);               } else if (c <= 0x10ffff) {                 builder.Append((char)((((c - 0x10000) >> 10) & 0x3ff) +                     0xd800));                 builder.Append((char)(((c - 0x10000) & 0x3ff) + 0xdc00));               }             } else {               // percent encode               percentEncodeUtf8(builder' c);             }           } else {             if (c <= 0xffff) {               builder.Append((char)c);             } else if (c <= 0x10ffff) {               builder.Append((char)((((c - 0x10000) >> 10) & 0x3ff) + 0xd800));               builder.Append((char)(((c - 0x10000) & 0x3ff) + 0xdc00));             }           }         } else if (mode == 1 || mode == 2) {           if (c >= 0x80) {             percentEncodeUtf8(builder' c);           } else if (c == '[' || c == ']') {             if (components != null && index >= components[2] && index <                 components[3]) {               // within the authority component' so don't percent-encode               if (c <= 0xffff) {                 builder.Append((char)c);               } else if (c <= 0x10ffff) {                 builder.Append((char)((((c - 0x10000) >> 10) & 0x3ff) +                     0xd800));                 builder.Append((char)(((c - 0x10000) & 0x3ff) + 0xdc00));               }             } else {               // percent encode               percentEncodeUtf8(builder' c);             }           } else {             if (c <= 0xffff) {               builder.Append((char)c);             } else if (c <= 0x10ffff) {               builder.Append((char)((((c - 0x10000) >> 10) & 0x3ff) + 0xd800));               builder.Append((char)(((c - 0x10000) & 0x3ff) + 0xdc00));             }           }         }         ++index;       }
Magic Number,PeterO.Cbor,URIUtility,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\URIUtility.cs,escapeURI,The following statement contains a magic number: while (index < valueSLength) {         int c = s[index];         if ((c & 0xfc00) == 0xd800 && index + 1 < valueSLength &&             s[index + 1] >= 0xdc00 && s[index + 1] <= 0xdfff) {           // Get the Unicode code point for the surrogate pair           c = 0x10000 + ((c - 0xd800) << 10) + (s[index + 1] - 0xdc00);           ++index;         } else if ((c & 0xf800) == 0xd800) {           c = 0xfffd;         }         if (mode == 0 || mode == 3) {           if (c == '%' && mode == 3) {             // Check for illegal percent encoding             if (index + 2 >= valueSLength || !isHexChar(s[index + 1]) ||                 !isHexChar(s[index + 2])) {               percentEncodeUtf8(builder' c);             } else {               if (c <= 0xffff) {                 builder.Append((char)c);               } else if (c <= 0x10ffff) {                 builder.Append((char)((((c - 0x10000) >> 10) & 0x3ff) +                     0xd800));                 builder.Append((char)(((c - 0x10000) & 0x3ff) + 0xdc00));               }             }             ++index;             continue;           }           if (c >= 0x7f || c <= 0x20 ||               ((c & 0x7f) == c && "{}|^\\`<>\"".IndexOf((char)c) >= 0)) {             percentEncodeUtf8(builder' c);           } else if (c == '[' || c == ']') {             if (components != null && index >= components[2] && index <                 components[3]) {               // within the authority component' so don't percent-encode               if (c <= 0xffff) {                 builder.Append((char)c);               } else if (c <= 0x10ffff) {                 builder.Append((char)((((c - 0x10000) >> 10) & 0x3ff) +                     0xd800));                 builder.Append((char)(((c - 0x10000) & 0x3ff) + 0xdc00));               }             } else {               // percent encode               percentEncodeUtf8(builder' c);             }           } else {             if (c <= 0xffff) {               builder.Append((char)c);             } else if (c <= 0x10ffff) {               builder.Append((char)((((c - 0x10000) >> 10) & 0x3ff) + 0xd800));               builder.Append((char)(((c - 0x10000) & 0x3ff) + 0xdc00));             }           }         } else if (mode == 1 || mode == 2) {           if (c >= 0x80) {             percentEncodeUtf8(builder' c);           } else if (c == '[' || c == ']') {             if (components != null && index >= components[2] && index <                 components[3]) {               // within the authority component' so don't percent-encode               if (c <= 0xffff) {                 builder.Append((char)c);               } else if (c <= 0x10ffff) {                 builder.Append((char)((((c - 0x10000) >> 10) & 0x3ff) +                     0xd800));                 builder.Append((char)(((c - 0x10000) & 0x3ff) + 0xdc00));               }             } else {               // percent encode               percentEncodeUtf8(builder' c);             }           } else {             if (c <= 0xffff) {               builder.Append((char)c);             } else if (c <= 0x10ffff) {               builder.Append((char)((((c - 0x10000) >> 10) & 0x3ff) + 0xd800));               builder.Append((char)(((c - 0x10000) & 0x3ff) + 0xdc00));             }           }         }         ++index;       }
Magic Number,PeterO.Cbor,URIUtility,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\URIUtility.cs,escapeURI,The following statement contains a magic number: while (index < valueSLength) {         int c = s[index];         if ((c & 0xfc00) == 0xd800 && index + 1 < valueSLength &&             s[index + 1] >= 0xdc00 && s[index + 1] <= 0xdfff) {           // Get the Unicode code point for the surrogate pair           c = 0x10000 + ((c - 0xd800) << 10) + (s[index + 1] - 0xdc00);           ++index;         } else if ((c & 0xf800) == 0xd800) {           c = 0xfffd;         }         if (mode == 0 || mode == 3) {           if (c == '%' && mode == 3) {             // Check for illegal percent encoding             if (index + 2 >= valueSLength || !isHexChar(s[index + 1]) ||                 !isHexChar(s[index + 2])) {               percentEncodeUtf8(builder' c);             } else {               if (c <= 0xffff) {                 builder.Append((char)c);               } else if (c <= 0x10ffff) {                 builder.Append((char)((((c - 0x10000) >> 10) & 0x3ff) +                     0xd800));                 builder.Append((char)(((c - 0x10000) & 0x3ff) + 0xdc00));               }             }             ++index;             continue;           }           if (c >= 0x7f || c <= 0x20 ||               ((c & 0x7f) == c && "{}|^\\`<>\"".IndexOf((char)c) >= 0)) {             percentEncodeUtf8(builder' c);           } else if (c == '[' || c == ']') {             if (components != null && index >= components[2] && index <                 components[3]) {               // within the authority component' so don't percent-encode               if (c <= 0xffff) {                 builder.Append((char)c);               } else if (c <= 0x10ffff) {                 builder.Append((char)((((c - 0x10000) >> 10) & 0x3ff) +                     0xd800));                 builder.Append((char)(((c - 0x10000) & 0x3ff) + 0xdc00));               }             } else {               // percent encode               percentEncodeUtf8(builder' c);             }           } else {             if (c <= 0xffff) {               builder.Append((char)c);             } else if (c <= 0x10ffff) {               builder.Append((char)((((c - 0x10000) >> 10) & 0x3ff) + 0xd800));               builder.Append((char)(((c - 0x10000) & 0x3ff) + 0xdc00));             }           }         } else if (mode == 1 || mode == 2) {           if (c >= 0x80) {             percentEncodeUtf8(builder' c);           } else if (c == '[' || c == ']') {             if (components != null && index >= components[2] && index <                 components[3]) {               // within the authority component' so don't percent-encode               if (c <= 0xffff) {                 builder.Append((char)c);               } else if (c <= 0x10ffff) {                 builder.Append((char)((((c - 0x10000) >> 10) & 0x3ff) +                     0xd800));                 builder.Append((char)(((c - 0x10000) & 0x3ff) + 0xdc00));               }             } else {               // percent encode               percentEncodeUtf8(builder' c);             }           } else {             if (c <= 0xffff) {               builder.Append((char)c);             } else if (c <= 0x10ffff) {               builder.Append((char)((((c - 0x10000) >> 10) & 0x3ff) + 0xd800));               builder.Append((char)(((c - 0x10000) & 0x3ff) + 0xdc00));             }           }         }         ++index;       }
Magic Number,PeterO.Cbor,URIUtility,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\URIUtility.cs,escapeURI,The following statement contains a magic number: while (index < valueSLength) {         int c = s[index];         if ((c & 0xfc00) == 0xd800 && index + 1 < valueSLength &&             s[index + 1] >= 0xdc00 && s[index + 1] <= 0xdfff) {           // Get the Unicode code point for the surrogate pair           c = 0x10000 + ((c - 0xd800) << 10) + (s[index + 1] - 0xdc00);           ++index;         } else if ((c & 0xf800) == 0xd800) {           c = 0xfffd;         }         if (mode == 0 || mode == 3) {           if (c == '%' && mode == 3) {             // Check for illegal percent encoding             if (index + 2 >= valueSLength || !isHexChar(s[index + 1]) ||                 !isHexChar(s[index + 2])) {               percentEncodeUtf8(builder' c);             } else {               if (c <= 0xffff) {                 builder.Append((char)c);               } else if (c <= 0x10ffff) {                 builder.Append((char)((((c - 0x10000) >> 10) & 0x3ff) +                     0xd800));                 builder.Append((char)(((c - 0x10000) & 0x3ff) + 0xdc00));               }             }             ++index;             continue;           }           if (c >= 0x7f || c <= 0x20 ||               ((c & 0x7f) == c && "{}|^\\`<>\"".IndexOf((char)c) >= 0)) {             percentEncodeUtf8(builder' c);           } else if (c == '[' || c == ']') {             if (components != null && index >= components[2] && index <                 components[3]) {               // within the authority component' so don't percent-encode               if (c <= 0xffff) {                 builder.Append((char)c);               } else if (c <= 0x10ffff) {                 builder.Append((char)((((c - 0x10000) >> 10) & 0x3ff) +                     0xd800));                 builder.Append((char)(((c - 0x10000) & 0x3ff) + 0xdc00));               }             } else {               // percent encode               percentEncodeUtf8(builder' c);             }           } else {             if (c <= 0xffff) {               builder.Append((char)c);             } else if (c <= 0x10ffff) {               builder.Append((char)((((c - 0x10000) >> 10) & 0x3ff) + 0xd800));               builder.Append((char)(((c - 0x10000) & 0x3ff) + 0xdc00));             }           }         } else if (mode == 1 || mode == 2) {           if (c >= 0x80) {             percentEncodeUtf8(builder' c);           } else if (c == '[' || c == ']') {             if (components != null && index >= components[2] && index <                 components[3]) {               // within the authority component' so don't percent-encode               if (c <= 0xffff) {                 builder.Append((char)c);               } else if (c <= 0x10ffff) {                 builder.Append((char)((((c - 0x10000) >> 10) & 0x3ff) +                     0xd800));                 builder.Append((char)(((c - 0x10000) & 0x3ff) + 0xdc00));               }             } else {               // percent encode               percentEncodeUtf8(builder' c);             }           } else {             if (c <= 0xffff) {               builder.Append((char)c);             } else if (c <= 0x10ffff) {               builder.Append((char)((((c - 0x10000) >> 10) & 0x3ff) + 0xd800));               builder.Append((char)(((c - 0x10000) & 0x3ff) + 0xdc00));             }           }         }         ++index;       }
Magic Number,PeterO.Cbor,URIUtility,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\URIUtility.cs,escapeURI,The following statement contains a magic number: while (index < valueSLength) {         int c = s[index];         if ((c & 0xfc00) == 0xd800 && index + 1 < valueSLength &&             s[index + 1] >= 0xdc00 && s[index + 1] <= 0xdfff) {           // Get the Unicode code point for the surrogate pair           c = 0x10000 + ((c - 0xd800) << 10) + (s[index + 1] - 0xdc00);           ++index;         } else if ((c & 0xf800) == 0xd800) {           c = 0xfffd;         }         if (mode == 0 || mode == 3) {           if (c == '%' && mode == 3) {             // Check for illegal percent encoding             if (index + 2 >= valueSLength || !isHexChar(s[index + 1]) ||                 !isHexChar(s[index + 2])) {               percentEncodeUtf8(builder' c);             } else {               if (c <= 0xffff) {                 builder.Append((char)c);               } else if (c <= 0x10ffff) {                 builder.Append((char)((((c - 0x10000) >> 10) & 0x3ff) +                     0xd800));                 builder.Append((char)(((c - 0x10000) & 0x3ff) + 0xdc00));               }             }             ++index;             continue;           }           if (c >= 0x7f || c <= 0x20 ||               ((c & 0x7f) == c && "{}|^\\`<>\"".IndexOf((char)c) >= 0)) {             percentEncodeUtf8(builder' c);           } else if (c == '[' || c == ']') {             if (components != null && index >= components[2] && index <                 components[3]) {               // within the authority component' so don't percent-encode               if (c <= 0xffff) {                 builder.Append((char)c);               } else if (c <= 0x10ffff) {                 builder.Append((char)((((c - 0x10000) >> 10) & 0x3ff) +                     0xd800));                 builder.Append((char)(((c - 0x10000) & 0x3ff) + 0xdc00));               }             } else {               // percent encode               percentEncodeUtf8(builder' c);             }           } else {             if (c <= 0xffff) {               builder.Append((char)c);             } else if (c <= 0x10ffff) {               builder.Append((char)((((c - 0x10000) >> 10) & 0x3ff) + 0xd800));               builder.Append((char)(((c - 0x10000) & 0x3ff) + 0xdc00));             }           }         } else if (mode == 1 || mode == 2) {           if (c >= 0x80) {             percentEncodeUtf8(builder' c);           } else if (c == '[' || c == ']') {             if (components != null && index >= components[2] && index <                 components[3]) {               // within the authority component' so don't percent-encode               if (c <= 0xffff) {                 builder.Append((char)c);               } else if (c <= 0x10ffff) {                 builder.Append((char)((((c - 0x10000) >> 10) & 0x3ff) +                     0xd800));                 builder.Append((char)(((c - 0x10000) & 0x3ff) + 0xdc00));               }             } else {               // percent encode               percentEncodeUtf8(builder' c);             }           } else {             if (c <= 0xffff) {               builder.Append((char)c);             } else if (c <= 0x10ffff) {               builder.Append((char)((((c - 0x10000) >> 10) & 0x3ff) + 0xd800));               builder.Append((char)(((c - 0x10000) & 0x3ff) + 0xdc00));             }           }         }         ++index;       }
Magic Number,PeterO.Cbor,URIUtility,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\URIUtility.cs,escapeURI,The following statement contains a magic number: while (index < valueSLength) {         int c = s[index];         if ((c & 0xfc00) == 0xd800 && index + 1 < valueSLength &&             s[index + 1] >= 0xdc00 && s[index + 1] <= 0xdfff) {           // Get the Unicode code point for the surrogate pair           c = 0x10000 + ((c - 0xd800) << 10) + (s[index + 1] - 0xdc00);           ++index;         } else if ((c & 0xf800) == 0xd800) {           c = 0xfffd;         }         if (mode == 0 || mode == 3) {           if (c == '%' && mode == 3) {             // Check for illegal percent encoding             if (index + 2 >= valueSLength || !isHexChar(s[index + 1]) ||                 !isHexChar(s[index + 2])) {               percentEncodeUtf8(builder' c);             } else {               if (c <= 0xffff) {                 builder.Append((char)c);               } else if (c <= 0x10ffff) {                 builder.Append((char)((((c - 0x10000) >> 10) & 0x3ff) +                     0xd800));                 builder.Append((char)(((c - 0x10000) & 0x3ff) + 0xdc00));               }             }             ++index;             continue;           }           if (c >= 0x7f || c <= 0x20 ||               ((c & 0x7f) == c && "{}|^\\`<>\"".IndexOf((char)c) >= 0)) {             percentEncodeUtf8(builder' c);           } else if (c == '[' || c == ']') {             if (components != null && index >= components[2] && index <                 components[3]) {               // within the authority component' so don't percent-encode               if (c <= 0xffff) {                 builder.Append((char)c);               } else if (c <= 0x10ffff) {                 builder.Append((char)((((c - 0x10000) >> 10) & 0x3ff) +                     0xd800));                 builder.Append((char)(((c - 0x10000) & 0x3ff) + 0xdc00));               }             } else {               // percent encode               percentEncodeUtf8(builder' c);             }           } else {             if (c <= 0xffff) {               builder.Append((char)c);             } else if (c <= 0x10ffff) {               builder.Append((char)((((c - 0x10000) >> 10) & 0x3ff) + 0xd800));               builder.Append((char)(((c - 0x10000) & 0x3ff) + 0xdc00));             }           }         } else if (mode == 1 || mode == 2) {           if (c >= 0x80) {             percentEncodeUtf8(builder' c);           } else if (c == '[' || c == ']') {             if (components != null && index >= components[2] && index <                 components[3]) {               // within the authority component' so don't percent-encode               if (c <= 0xffff) {                 builder.Append((char)c);               } else if (c <= 0x10ffff) {                 builder.Append((char)((((c - 0x10000) >> 10) & 0x3ff) +                     0xd800));                 builder.Append((char)(((c - 0x10000) & 0x3ff) + 0xdc00));               }             } else {               // percent encode               percentEncodeUtf8(builder' c);             }           } else {             if (c <= 0xffff) {               builder.Append((char)c);             } else if (c <= 0x10ffff) {               builder.Append((char)((((c - 0x10000) >> 10) & 0x3ff) + 0xd800));               builder.Append((char)(((c - 0x10000) & 0x3ff) + 0xdc00));             }           }         }         ++index;       }
Magic Number,PeterO.Cbor,URIUtility,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\URIUtility.cs,isValidCurieReference,The following statement contains a magic number: if (index + 2 <= valueSLength && s[index] == '/' && s[index + 1] == '/') {         // has an authority' which is not allowed         return false;       }
Magic Number,PeterO.Cbor,URIUtility,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\URIUtility.cs,isValidCurieReference,The following statement contains a magic number: while (index < valueSLength) {         // Get the next Unicode character         int c = s[index];         if ((c & 0xfc00) == 0xd800 && index + 1 < valueSLength &&             s[index + 1] >= 0xdc00 && s[index + 1] <= 0xdfff) {           // Get the Unicode code point for the surrogate pair           c = 0x10000 + ((c - 0xd800) << 10) + (s[index + 1] - 0xdc00);           ++index;         } else if ((c & 0xf800) == 0xd800) {           // error           return false;         }         if (c == '%') {           // Percent encoded character           if (index + 2 < valueSLength && isHexChar(s[index + 1]) &&               isHexChar(s[index + 2])) {             index += 3;             continue;           }           return false;         }         if (state == 0) {  // Path           if (c == '?') {             state = 1;  // move to query state           } else if (c == '#') {             state = 2;  // move to fragment state           } else if (!isIpchar(c)) {             return false;           }           ++index;         } else if (state == 1) {  // Query           if (c == '#') {             state = 2;  // move to fragment state           } else if (!isIqueryChar(c)) {             return false;           }           ++index;         } else if (state == 2) {  // Fragment           if (!isIfragmentChar(c)) {             return false;           }           ++index;         }       }
Magic Number,PeterO.Cbor,URIUtility,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\URIUtility.cs,isValidCurieReference,The following statement contains a magic number: while (index < valueSLength) {         // Get the next Unicode character         int c = s[index];         if ((c & 0xfc00) == 0xd800 && index + 1 < valueSLength &&             s[index + 1] >= 0xdc00 && s[index + 1] <= 0xdfff) {           // Get the Unicode code point for the surrogate pair           c = 0x10000 + ((c - 0xd800) << 10) + (s[index + 1] - 0xdc00);           ++index;         } else if ((c & 0xf800) == 0xd800) {           // error           return false;         }         if (c == '%') {           // Percent encoded character           if (index + 2 < valueSLength && isHexChar(s[index + 1]) &&               isHexChar(s[index + 2])) {             index += 3;             continue;           }           return false;         }         if (state == 0) {  // Path           if (c == '?') {             state = 1;  // move to query state           } else if (c == '#') {             state = 2;  // move to fragment state           } else if (!isIpchar(c)) {             return false;           }           ++index;         } else if (state == 1) {  // Query           if (c == '#') {             state = 2;  // move to fragment state           } else if (!isIqueryChar(c)) {             return false;           }           ++index;         } else if (state == 2) {  // Fragment           if (!isIfragmentChar(c)) {             return false;           }           ++index;         }       }
Magic Number,PeterO.Cbor,URIUtility,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\URIUtility.cs,isValidCurieReference,The following statement contains a magic number: while (index < valueSLength) {         // Get the next Unicode character         int c = s[index];         if ((c & 0xfc00) == 0xd800 && index + 1 < valueSLength &&             s[index + 1] >= 0xdc00 && s[index + 1] <= 0xdfff) {           // Get the Unicode code point for the surrogate pair           c = 0x10000 + ((c - 0xd800) << 10) + (s[index + 1] - 0xdc00);           ++index;         } else if ((c & 0xf800) == 0xd800) {           // error           return false;         }         if (c == '%') {           // Percent encoded character           if (index + 2 < valueSLength && isHexChar(s[index + 1]) &&               isHexChar(s[index + 2])) {             index += 3;             continue;           }           return false;         }         if (state == 0) {  // Path           if (c == '?') {             state = 1;  // move to query state           } else if (c == '#') {             state = 2;  // move to fragment state           } else if (!isIpchar(c)) {             return false;           }           ++index;         } else if (state == 1) {  // Query           if (c == '#') {             state = 2;  // move to fragment state           } else if (!isIqueryChar(c)) {             return false;           }           ++index;         } else if (state == 2) {  // Fragment           if (!isIfragmentChar(c)) {             return false;           }           ++index;         }       }
Magic Number,PeterO.Cbor,URIUtility,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\URIUtility.cs,isValidCurieReference,The following statement contains a magic number: while (index < valueSLength) {         // Get the next Unicode character         int c = s[index];         if ((c & 0xfc00) == 0xd800 && index + 1 < valueSLength &&             s[index + 1] >= 0xdc00 && s[index + 1] <= 0xdfff) {           // Get the Unicode code point for the surrogate pair           c = 0x10000 + ((c - 0xd800) << 10) + (s[index + 1] - 0xdc00);           ++index;         } else if ((c & 0xf800) == 0xd800) {           // error           return false;         }         if (c == '%') {           // Percent encoded character           if (index + 2 < valueSLength && isHexChar(s[index + 1]) &&               isHexChar(s[index + 2])) {             index += 3;             continue;           }           return false;         }         if (state == 0) {  // Path           if (c == '?') {             state = 1;  // move to query state           } else if (c == '#') {             state = 2;  // move to fragment state           } else if (!isIpchar(c)) {             return false;           }           ++index;         } else if (state == 1) {  // Query           if (c == '#') {             state = 2;  // move to fragment state           } else if (!isIqueryChar(c)) {             return false;           }           ++index;         } else if (state == 2) {  // Fragment           if (!isIfragmentChar(c)) {             return false;           }           ++index;         }       }
Magic Number,PeterO.Cbor,URIUtility,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\URIUtility.cs,isValidCurieReference,The following statement contains a magic number: while (index < valueSLength) {         // Get the next Unicode character         int c = s[index];         if ((c & 0xfc00) == 0xd800 && index + 1 < valueSLength &&             s[index + 1] >= 0xdc00 && s[index + 1] <= 0xdfff) {           // Get the Unicode code point for the surrogate pair           c = 0x10000 + ((c - 0xd800) << 10) + (s[index + 1] - 0xdc00);           ++index;         } else if ((c & 0xf800) == 0xd800) {           // error           return false;         }         if (c == '%') {           // Percent encoded character           if (index + 2 < valueSLength && isHexChar(s[index + 1]) &&               isHexChar(s[index + 2])) {             index += 3;             continue;           }           return false;         }         if (state == 0) {  // Path           if (c == '?') {             state = 1;  // move to query state           } else if (c == '#') {             state = 2;  // move to fragment state           } else if (!isIpchar(c)) {             return false;           }           ++index;         } else if (state == 1) {  // Query           if (c == '#') {             state = 2;  // move to fragment state           } else if (!isIqueryChar(c)) {             return false;           }           ++index;         } else if (state == 2) {  // Fragment           if (!isIfragmentChar(c)) {             return false;           }           ++index;         }       }
Magic Number,PeterO.Cbor,URIUtility,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\URIUtility.cs,isValidCurieReference,The following statement contains a magic number: while (index < valueSLength) {         // Get the next Unicode character         int c = s[index];         if ((c & 0xfc00) == 0xd800 && index + 1 < valueSLength &&             s[index + 1] >= 0xdc00 && s[index + 1] <= 0xdfff) {           // Get the Unicode code point for the surrogate pair           c = 0x10000 + ((c - 0xd800) << 10) + (s[index + 1] - 0xdc00);           ++index;         } else if ((c & 0xf800) == 0xd800) {           // error           return false;         }         if (c == '%') {           // Percent encoded character           if (index + 2 < valueSLength && isHexChar(s[index + 1]) &&               isHexChar(s[index + 2])) {             index += 3;             continue;           }           return false;         }         if (state == 0) {  // Path           if (c == '?') {             state = 1;  // move to query state           } else if (c == '#') {             state = 2;  // move to fragment state           } else if (!isIpchar(c)) {             return false;           }           ++index;         } else if (state == 1) {  // Query           if (c == '#') {             state = 2;  // move to fragment state           } else if (!isIqueryChar(c)) {             return false;           }           ++index;         } else if (state == 2) {  // Fragment           if (!isIfragmentChar(c)) {             return false;           }           ++index;         }       }
Magic Number,PeterO.Cbor,URIUtility,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\URIUtility.cs,isValidCurieReference,The following statement contains a magic number: while (index < valueSLength) {         // Get the next Unicode character         int c = s[index];         if ((c & 0xfc00) == 0xd800 && index + 1 < valueSLength &&             s[index + 1] >= 0xdc00 && s[index + 1] <= 0xdfff) {           // Get the Unicode code point for the surrogate pair           c = 0x10000 + ((c - 0xd800) << 10) + (s[index + 1] - 0xdc00);           ++index;         } else if ((c & 0xf800) == 0xd800) {           // error           return false;         }         if (c == '%') {           // Percent encoded character           if (index + 2 < valueSLength && isHexChar(s[index + 1]) &&               isHexChar(s[index + 2])) {             index += 3;             continue;           }           return false;         }         if (state == 0) {  // Path           if (c == '?') {             state = 1;  // move to query state           } else if (c == '#') {             state = 2;  // move to fragment state           } else if (!isIpchar(c)) {             return false;           }           ++index;         } else if (state == 1) {  // Query           if (c == '#') {             state = 2;  // move to fragment state           } else if (!isIqueryChar(c)) {             return false;           }           ++index;         } else if (state == 2) {  // Fragment           if (!isIfragmentChar(c)) {             return false;           }           ++index;         }       }
Magic Number,PeterO.Cbor,URIUtility,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\URIUtility.cs,normalizePath,The following statement contains a magic number: while (index < len) {         char c = path[index];         if ((index + 3 <= len && c == '/' && path[index + 1] == '.' &&              path[index + 2] == '/') || (index + 2 == len && c == '.' &&              path[index + 1] == '.')) {           // begins with "/./" or is "..";           // move index by 2           index += 2;           continue;         }         if (index + 3 <= len && c == '.' &&             path[index + 1] == '.' && path[index + 2] == '/') {           // begins with "../";           // move index by 3           index += 3;           continue;         }         if ((index + 2 <= len && c == '.' &&              path[index + 1] == '/') || (index + 1 == len && c == '.')) {           // begins with "./" or is ".";           // move index by 1           ++index;           continue;         }         if (index + 2 == len && c == '/' &&             path[index + 1] == '.') {           // is "/."; append '/' and break           builder.Append('/');           break;         }         if (index + 3 == len && c == '/' &&             path[index + 1] == '.' && path[index + 2] == '.') {           // is "/.."; remove last segment'           // append "/" and return           int index2 = builder.Length - 1;           string builderString = builder.ToString();           while (index2 >= 0) {             if (builderString[index2] == '/') {               break;             }             --index2;           }           if (index2 < 0) {             index2 = 0;           }           builder.Length = index2;           builder.Append('/');           break;         }         if (index + 4 <= len && c == '/' && path[index + 1] == '.' &&             path[index + 2] == '.' && path[index + 3] == '/') {           // begins with "/../"; remove last segment           int index2 = builder.Length - 1;           string builderString = builder.ToString();           while (index2 >= 0) {             if (builderString[index2] == '/') {               break;             }             --index2;           }           if (index2 < 0) {             index2 = 0;           }           builder.Length = index2;           index += 3;           continue;         }         builder.Append(c);         ++index;         while (index < len) {           // Move the rest of the           // path segment until the next '/'           c = path[index];           if (c == '/') {             break;           }           builder.Append(c);           ++index;         }       }
Magic Number,PeterO.Cbor,URIUtility,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\URIUtility.cs,normalizePath,The following statement contains a magic number: while (index < len) {         char c = path[index];         if ((index + 3 <= len && c == '/' && path[index + 1] == '.' &&              path[index + 2] == '/') || (index + 2 == len && c == '.' &&              path[index + 1] == '.')) {           // begins with "/./" or is "..";           // move index by 2           index += 2;           continue;         }         if (index + 3 <= len && c == '.' &&             path[index + 1] == '.' && path[index + 2] == '/') {           // begins with "../";           // move index by 3           index += 3;           continue;         }         if ((index + 2 <= len && c == '.' &&              path[index + 1] == '/') || (index + 1 == len && c == '.')) {           // begins with "./" or is ".";           // move index by 1           ++index;           continue;         }         if (index + 2 == len && c == '/' &&             path[index + 1] == '.') {           // is "/."; append '/' and break           builder.Append('/');           break;         }         if (index + 3 == len && c == '/' &&             path[index + 1] == '.' && path[index + 2] == '.') {           // is "/.."; remove last segment'           // append "/" and return           int index2 = builder.Length - 1;           string builderString = builder.ToString();           while (index2 >= 0) {             if (builderString[index2] == '/') {               break;             }             --index2;           }           if (index2 < 0) {             index2 = 0;           }           builder.Length = index2;           builder.Append('/');           break;         }         if (index + 4 <= len && c == '/' && path[index + 1] == '.' &&             path[index + 2] == '.' && path[index + 3] == '/') {           // begins with "/../"; remove last segment           int index2 = builder.Length - 1;           string builderString = builder.ToString();           while (index2 >= 0) {             if (builderString[index2] == '/') {               break;             }             --index2;           }           if (index2 < 0) {             index2 = 0;           }           builder.Length = index2;           index += 3;           continue;         }         builder.Append(c);         ++index;         while (index < len) {           // Move the rest of the           // path segment until the next '/'           c = path[index];           if (c == '/') {             break;           }           builder.Append(c);           ++index;         }       }
Magic Number,PeterO.Cbor,URIUtility,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\URIUtility.cs,normalizePath,The following statement contains a magic number: while (index < len) {         char c = path[index];         if ((index + 3 <= len && c == '/' && path[index + 1] == '.' &&              path[index + 2] == '/') || (index + 2 == len && c == '.' &&              path[index + 1] == '.')) {           // begins with "/./" or is "..";           // move index by 2           index += 2;           continue;         }         if (index + 3 <= len && c == '.' &&             path[index + 1] == '.' && path[index + 2] == '/') {           // begins with "../";           // move index by 3           index += 3;           continue;         }         if ((index + 2 <= len && c == '.' &&              path[index + 1] == '/') || (index + 1 == len && c == '.')) {           // begins with "./" or is ".";           // move index by 1           ++index;           continue;         }         if (index + 2 == len && c == '/' &&             path[index + 1] == '.') {           // is "/."; append '/' and break           builder.Append('/');           break;         }         if (index + 3 == len && c == '/' &&             path[index + 1] == '.' && path[index + 2] == '.') {           // is "/.."; remove last segment'           // append "/" and return           int index2 = builder.Length - 1;           string builderString = builder.ToString();           while (index2 >= 0) {             if (builderString[index2] == '/') {               break;             }             --index2;           }           if (index2 < 0) {             index2 = 0;           }           builder.Length = index2;           builder.Append('/');           break;         }         if (index + 4 <= len && c == '/' && path[index + 1] == '.' &&             path[index + 2] == '.' && path[index + 3] == '/') {           // begins with "/../"; remove last segment           int index2 = builder.Length - 1;           string builderString = builder.ToString();           while (index2 >= 0) {             if (builderString[index2] == '/') {               break;             }             --index2;           }           if (index2 < 0) {             index2 = 0;           }           builder.Length = index2;           index += 3;           continue;         }         builder.Append(c);         ++index;         while (index < len) {           // Move the rest of the           // path segment until the next '/'           c = path[index];           if (c == '/') {             break;           }           builder.Append(c);           ++index;         }       }
Magic Number,PeterO.Cbor,URIUtility,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\URIUtility.cs,normalizePath,The following statement contains a magic number: while (index < len) {         char c = path[index];         if ((index + 3 <= len && c == '/' && path[index + 1] == '.' &&              path[index + 2] == '/') || (index + 2 == len && c == '.' &&              path[index + 1] == '.')) {           // begins with "/./" or is "..";           // move index by 2           index += 2;           continue;         }         if (index + 3 <= len && c == '.' &&             path[index + 1] == '.' && path[index + 2] == '/') {           // begins with "../";           // move index by 3           index += 3;           continue;         }         if ((index + 2 <= len && c == '.' &&              path[index + 1] == '/') || (index + 1 == len && c == '.')) {           // begins with "./" or is ".";           // move index by 1           ++index;           continue;         }         if (index + 2 == len && c == '/' &&             path[index + 1] == '.') {           // is "/."; append '/' and break           builder.Append('/');           break;         }         if (index + 3 == len && c == '/' &&             path[index + 1] == '.' && path[index + 2] == '.') {           // is "/.."; remove last segment'           // append "/" and return           int index2 = builder.Length - 1;           string builderString = builder.ToString();           while (index2 >= 0) {             if (builderString[index2] == '/') {               break;             }             --index2;           }           if (index2 < 0) {             index2 = 0;           }           builder.Length = index2;           builder.Append('/');           break;         }         if (index + 4 <= len && c == '/' && path[index + 1] == '.' &&             path[index + 2] == '.' && path[index + 3] == '/') {           // begins with "/../"; remove last segment           int index2 = builder.Length - 1;           string builderString = builder.ToString();           while (index2 >= 0) {             if (builderString[index2] == '/') {               break;             }             --index2;           }           if (index2 < 0) {             index2 = 0;           }           builder.Length = index2;           index += 3;           continue;         }         builder.Append(c);         ++index;         while (index < len) {           // Move the rest of the           // path segment until the next '/'           c = path[index];           if (c == '/') {             break;           }           builder.Append(c);           ++index;         }       }
Magic Number,PeterO.Cbor,URIUtility,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\URIUtility.cs,normalizePath,The following statement contains a magic number: while (index < len) {         char c = path[index];         if ((index + 3 <= len && c == '/' && path[index + 1] == '.' &&              path[index + 2] == '/') || (index + 2 == len && c == '.' &&              path[index + 1] == '.')) {           // begins with "/./" or is "..";           // move index by 2           index += 2;           continue;         }         if (index + 3 <= len && c == '.' &&             path[index + 1] == '.' && path[index + 2] == '/') {           // begins with "../";           // move index by 3           index += 3;           continue;         }         if ((index + 2 <= len && c == '.' &&              path[index + 1] == '/') || (index + 1 == len && c == '.')) {           // begins with "./" or is ".";           // move index by 1           ++index;           continue;         }         if (index + 2 == len && c == '/' &&             path[index + 1] == '.') {           // is "/."; append '/' and break           builder.Append('/');           break;         }         if (index + 3 == len && c == '/' &&             path[index + 1] == '.' && path[index + 2] == '.') {           // is "/.."; remove last segment'           // append "/" and return           int index2 = builder.Length - 1;           string builderString = builder.ToString();           while (index2 >= 0) {             if (builderString[index2] == '/') {               break;             }             --index2;           }           if (index2 < 0) {             index2 = 0;           }           builder.Length = index2;           builder.Append('/');           break;         }         if (index + 4 <= len && c == '/' && path[index + 1] == '.' &&             path[index + 2] == '.' && path[index + 3] == '/') {           // begins with "/../"; remove last segment           int index2 = builder.Length - 1;           string builderString = builder.ToString();           while (index2 >= 0) {             if (builderString[index2] == '/') {               break;             }             --index2;           }           if (index2 < 0) {             index2 = 0;           }           builder.Length = index2;           index += 3;           continue;         }         builder.Append(c);         ++index;         while (index < len) {           // Move the rest of the           // path segment until the next '/'           c = path[index];           if (c == '/') {             break;           }           builder.Append(c);           ++index;         }       }
Magic Number,PeterO.Cbor,URIUtility,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\URIUtility.cs,normalizePath,The following statement contains a magic number: while (index < len) {         char c = path[index];         if ((index + 3 <= len && c == '/' && path[index + 1] == '.' &&              path[index + 2] == '/') || (index + 2 == len && c == '.' &&              path[index + 1] == '.')) {           // begins with "/./" or is "..";           // move index by 2           index += 2;           continue;         }         if (index + 3 <= len && c == '.' &&             path[index + 1] == '.' && path[index + 2] == '/') {           // begins with "../";           // move index by 3           index += 3;           continue;         }         if ((index + 2 <= len && c == '.' &&              path[index + 1] == '/') || (index + 1 == len && c == '.')) {           // begins with "./" or is ".";           // move index by 1           ++index;           continue;         }         if (index + 2 == len && c == '/' &&             path[index + 1] == '.') {           // is "/."; append '/' and break           builder.Append('/');           break;         }         if (index + 3 == len && c == '/' &&             path[index + 1] == '.' && path[index + 2] == '.') {           // is "/.."; remove last segment'           // append "/" and return           int index2 = builder.Length - 1;           string builderString = builder.ToString();           while (index2 >= 0) {             if (builderString[index2] == '/') {               break;             }             --index2;           }           if (index2 < 0) {             index2 = 0;           }           builder.Length = index2;           builder.Append('/');           break;         }         if (index + 4 <= len && c == '/' && path[index + 1] == '.' &&             path[index + 2] == '.' && path[index + 3] == '/') {           // begins with "/../"; remove last segment           int index2 = builder.Length - 1;           string builderString = builder.ToString();           while (index2 >= 0) {             if (builderString[index2] == '/') {               break;             }             --index2;           }           if (index2 < 0) {             index2 = 0;           }           builder.Length = index2;           index += 3;           continue;         }         builder.Append(c);         ++index;         while (index < len) {           // Move the rest of the           // path segment until the next '/'           c = path[index];           if (c == '/') {             break;           }           builder.Append(c);           ++index;         }       }
Magic Number,PeterO.Cbor,URIUtility,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\URIUtility.cs,normalizePath,The following statement contains a magic number: while (index < len) {         char c = path[index];         if ((index + 3 <= len && c == '/' && path[index + 1] == '.' &&              path[index + 2] == '/') || (index + 2 == len && c == '.' &&              path[index + 1] == '.')) {           // begins with "/./" or is "..";           // move index by 2           index += 2;           continue;         }         if (index + 3 <= len && c == '.' &&             path[index + 1] == '.' && path[index + 2] == '/') {           // begins with "../";           // move index by 3           index += 3;           continue;         }         if ((index + 2 <= len && c == '.' &&              path[index + 1] == '/') || (index + 1 == len && c == '.')) {           // begins with "./" or is ".";           // move index by 1           ++index;           continue;         }         if (index + 2 == len && c == '/' &&             path[index + 1] == '.') {           // is "/."; append '/' and break           builder.Append('/');           break;         }         if (index + 3 == len && c == '/' &&             path[index + 1] == '.' && path[index + 2] == '.') {           // is "/.."; remove last segment'           // append "/" and return           int index2 = builder.Length - 1;           string builderString = builder.ToString();           while (index2 >= 0) {             if (builderString[index2] == '/') {               break;             }             --index2;           }           if (index2 < 0) {             index2 = 0;           }           builder.Length = index2;           builder.Append('/');           break;         }         if (index + 4 <= len && c == '/' && path[index + 1] == '.' &&             path[index + 2] == '.' && path[index + 3] == '/') {           // begins with "/../"; remove last segment           int index2 = builder.Length - 1;           string builderString = builder.ToString();           while (index2 >= 0) {             if (builderString[index2] == '/') {               break;             }             --index2;           }           if (index2 < 0) {             index2 = 0;           }           builder.Length = index2;           index += 3;           continue;         }         builder.Append(c);         ++index;         while (index < len) {           // Move the rest of the           // path segment until the next '/'           c = path[index];           if (c == '/') {             break;           }           builder.Append(c);           ++index;         }       }
Magic Number,PeterO.Cbor,URIUtility,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\URIUtility.cs,normalizePath,The following statement contains a magic number: while (index < len) {         char c = path[index];         if ((index + 3 <= len && c == '/' && path[index + 1] == '.' &&              path[index + 2] == '/') || (index + 2 == len && c == '.' &&              path[index + 1] == '.')) {           // begins with "/./" or is "..";           // move index by 2           index += 2;           continue;         }         if (index + 3 <= len && c == '.' &&             path[index + 1] == '.' && path[index + 2] == '/') {           // begins with "../";           // move index by 3           index += 3;           continue;         }         if ((index + 2 <= len && c == '.' &&              path[index + 1] == '/') || (index + 1 == len && c == '.')) {           // begins with "./" or is ".";           // move index by 1           ++index;           continue;         }         if (index + 2 == len && c == '/' &&             path[index + 1] == '.') {           // is "/."; append '/' and break           builder.Append('/');           break;         }         if (index + 3 == len && c == '/' &&             path[index + 1] == '.' && path[index + 2] == '.') {           // is "/.."; remove last segment'           // append "/" and return           int index2 = builder.Length - 1;           string builderString = builder.ToString();           while (index2 >= 0) {             if (builderString[index2] == '/') {               break;             }             --index2;           }           if (index2 < 0) {             index2 = 0;           }           builder.Length = index2;           builder.Append('/');           break;         }         if (index + 4 <= len && c == '/' && path[index + 1] == '.' &&             path[index + 2] == '.' && path[index + 3] == '/') {           // begins with "/../"; remove last segment           int index2 = builder.Length - 1;           string builderString = builder.ToString();           while (index2 >= 0) {             if (builderString[index2] == '/') {               break;             }             --index2;           }           if (index2 < 0) {             index2 = 0;           }           builder.Length = index2;           index += 3;           continue;         }         builder.Append(c);         ++index;         while (index < len) {           // Move the rest of the           // path segment until the next '/'           c = path[index];           if (c == '/') {             break;           }           builder.Append(c);           ++index;         }       }
Magic Number,PeterO.Cbor,URIUtility,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\URIUtility.cs,normalizePath,The following statement contains a magic number: while (index < len) {         char c = path[index];         if ((index + 3 <= len && c == '/' && path[index + 1] == '.' &&              path[index + 2] == '/') || (index + 2 == len && c == '.' &&              path[index + 1] == '.')) {           // begins with "/./" or is "..";           // move index by 2           index += 2;           continue;         }         if (index + 3 <= len && c == '.' &&             path[index + 1] == '.' && path[index + 2] == '/') {           // begins with "../";           // move index by 3           index += 3;           continue;         }         if ((index + 2 <= len && c == '.' &&              path[index + 1] == '/') || (index + 1 == len && c == '.')) {           // begins with "./" or is ".";           // move index by 1           ++index;           continue;         }         if (index + 2 == len && c == '/' &&             path[index + 1] == '.') {           // is "/."; append '/' and break           builder.Append('/');           break;         }         if (index + 3 == len && c == '/' &&             path[index + 1] == '.' && path[index + 2] == '.') {           // is "/.."; remove last segment'           // append "/" and return           int index2 = builder.Length - 1;           string builderString = builder.ToString();           while (index2 >= 0) {             if (builderString[index2] == '/') {               break;             }             --index2;           }           if (index2 < 0) {             index2 = 0;           }           builder.Length = index2;           builder.Append('/');           break;         }         if (index + 4 <= len && c == '/' && path[index + 1] == '.' &&             path[index + 2] == '.' && path[index + 3] == '/') {           // begins with "/../"; remove last segment           int index2 = builder.Length - 1;           string builderString = builder.ToString();           while (index2 >= 0) {             if (builderString[index2] == '/') {               break;             }             --index2;           }           if (index2 < 0) {             index2 = 0;           }           builder.Length = index2;           index += 3;           continue;         }         builder.Append(c);         ++index;         while (index < len) {           // Move the rest of the           // path segment until the next '/'           c = path[index];           if (c == '/') {             break;           }           builder.Append(c);           ++index;         }       }
Magic Number,PeterO.Cbor,URIUtility,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\URIUtility.cs,normalizePath,The following statement contains a magic number: while (index < len) {         char c = path[index];         if ((index + 3 <= len && c == '/' && path[index + 1] == '.' &&              path[index + 2] == '/') || (index + 2 == len && c == '.' &&              path[index + 1] == '.')) {           // begins with "/./" or is "..";           // move index by 2           index += 2;           continue;         }         if (index + 3 <= len && c == '.' &&             path[index + 1] == '.' && path[index + 2] == '/') {           // begins with "../";           // move index by 3           index += 3;           continue;         }         if ((index + 2 <= len && c == '.' &&              path[index + 1] == '/') || (index + 1 == len && c == '.')) {           // begins with "./" or is ".";           // move index by 1           ++index;           continue;         }         if (index + 2 == len && c == '/' &&             path[index + 1] == '.') {           // is "/."; append '/' and break           builder.Append('/');           break;         }         if (index + 3 == len && c == '/' &&             path[index + 1] == '.' && path[index + 2] == '.') {           // is "/.."; remove last segment'           // append "/" and return           int index2 = builder.Length - 1;           string builderString = builder.ToString();           while (index2 >= 0) {             if (builderString[index2] == '/') {               break;             }             --index2;           }           if (index2 < 0) {             index2 = 0;           }           builder.Length = index2;           builder.Append('/');           break;         }         if (index + 4 <= len && c == '/' && path[index + 1] == '.' &&             path[index + 2] == '.' && path[index + 3] == '/') {           // begins with "/../"; remove last segment           int index2 = builder.Length - 1;           string builderString = builder.ToString();           while (index2 >= 0) {             if (builderString[index2] == '/') {               break;             }             --index2;           }           if (index2 < 0) {             index2 = 0;           }           builder.Length = index2;           index += 3;           continue;         }         builder.Append(c);         ++index;         while (index < len) {           // Move the rest of the           // path segment until the next '/'           c = path[index];           if (c == '/') {             break;           }           builder.Append(c);           ++index;         }       }
Magic Number,PeterO.Cbor,URIUtility,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\URIUtility.cs,normalizePath,The following statement contains a magic number: while (index < len) {         char c = path[index];         if ((index + 3 <= len && c == '/' && path[index + 1] == '.' &&              path[index + 2] == '/') || (index + 2 == len && c == '.' &&              path[index + 1] == '.')) {           // begins with "/./" or is "..";           // move index by 2           index += 2;           continue;         }         if (index + 3 <= len && c == '.' &&             path[index + 1] == '.' && path[index + 2] == '/') {           // begins with "../";           // move index by 3           index += 3;           continue;         }         if ((index + 2 <= len && c == '.' &&              path[index + 1] == '/') || (index + 1 == len && c == '.')) {           // begins with "./" or is ".";           // move index by 1           ++index;           continue;         }         if (index + 2 == len && c == '/' &&             path[index + 1] == '.') {           // is "/."; append '/' and break           builder.Append('/');           break;         }         if (index + 3 == len && c == '/' &&             path[index + 1] == '.' && path[index + 2] == '.') {           // is "/.."; remove last segment'           // append "/" and return           int index2 = builder.Length - 1;           string builderString = builder.ToString();           while (index2 >= 0) {             if (builderString[index2] == '/') {               break;             }             --index2;           }           if (index2 < 0) {             index2 = 0;           }           builder.Length = index2;           builder.Append('/');           break;         }         if (index + 4 <= len && c == '/' && path[index + 1] == '.' &&             path[index + 2] == '.' && path[index + 3] == '/') {           // begins with "/../"; remove last segment           int index2 = builder.Length - 1;           string builderString = builder.ToString();           while (index2 >= 0) {             if (builderString[index2] == '/') {               break;             }             --index2;           }           if (index2 < 0) {             index2 = 0;           }           builder.Length = index2;           index += 3;           continue;         }         builder.Append(c);         ++index;         while (index < len) {           // Move the rest of the           // path segment until the next '/'           c = path[index];           if (c == '/') {             break;           }           builder.Append(c);           ++index;         }       }
Magic Number,PeterO.Cbor,URIUtility,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\URIUtility.cs,normalizePath,The following statement contains a magic number: while (index < len) {         char c = path[index];         if ((index + 3 <= len && c == '/' && path[index + 1] == '.' &&              path[index + 2] == '/') || (index + 2 == len && c == '.' &&              path[index + 1] == '.')) {           // begins with "/./" or is "..";           // move index by 2           index += 2;           continue;         }         if (index + 3 <= len && c == '.' &&             path[index + 1] == '.' && path[index + 2] == '/') {           // begins with "../";           // move index by 3           index += 3;           continue;         }         if ((index + 2 <= len && c == '.' &&              path[index + 1] == '/') || (index + 1 == len && c == '.')) {           // begins with "./" or is ".";           // move index by 1           ++index;           continue;         }         if (index + 2 == len && c == '/' &&             path[index + 1] == '.') {           // is "/."; append '/' and break           builder.Append('/');           break;         }         if (index + 3 == len && c == '/' &&             path[index + 1] == '.' && path[index + 2] == '.') {           // is "/.."; remove last segment'           // append "/" and return           int index2 = builder.Length - 1;           string builderString = builder.ToString();           while (index2 >= 0) {             if (builderString[index2] == '/') {               break;             }             --index2;           }           if (index2 < 0) {             index2 = 0;           }           builder.Length = index2;           builder.Append('/');           break;         }         if (index + 4 <= len && c == '/' && path[index + 1] == '.' &&             path[index + 2] == '.' && path[index + 3] == '/') {           // begins with "/../"; remove last segment           int index2 = builder.Length - 1;           string builderString = builder.ToString();           while (index2 >= 0) {             if (builderString[index2] == '/') {               break;             }             --index2;           }           if (index2 < 0) {             index2 = 0;           }           builder.Length = index2;           index += 3;           continue;         }         builder.Append(c);         ++index;         while (index < len) {           // Move the rest of the           // path segment until the next '/'           c = path[index];           if (c == '/') {             break;           }           builder.Append(c);           ++index;         }       }
Magic Number,PeterO.Cbor,URIUtility,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\URIUtility.cs,normalizePath,The following statement contains a magic number: while (index < len) {         char c = path[index];         if ((index + 3 <= len && c == '/' && path[index + 1] == '.' &&              path[index + 2] == '/') || (index + 2 == len && c == '.' &&              path[index + 1] == '.')) {           // begins with "/./" or is "..";           // move index by 2           index += 2;           continue;         }         if (index + 3 <= len && c == '.' &&             path[index + 1] == '.' && path[index + 2] == '/') {           // begins with "../";           // move index by 3           index += 3;           continue;         }         if ((index + 2 <= len && c == '.' &&              path[index + 1] == '/') || (index + 1 == len && c == '.')) {           // begins with "./" or is ".";           // move index by 1           ++index;           continue;         }         if (index + 2 == len && c == '/' &&             path[index + 1] == '.') {           // is "/."; append '/' and break           builder.Append('/');           break;         }         if (index + 3 == len && c == '/' &&             path[index + 1] == '.' && path[index + 2] == '.') {           // is "/.."; remove last segment'           // append "/" and return           int index2 = builder.Length - 1;           string builderString = builder.ToString();           while (index2 >= 0) {             if (builderString[index2] == '/') {               break;             }             --index2;           }           if (index2 < 0) {             index2 = 0;           }           builder.Length = index2;           builder.Append('/');           break;         }         if (index + 4 <= len && c == '/' && path[index + 1] == '.' &&             path[index + 2] == '.' && path[index + 3] == '/') {           // begins with "/../"; remove last segment           int index2 = builder.Length - 1;           string builderString = builder.ToString();           while (index2 >= 0) {             if (builderString[index2] == '/') {               break;             }             --index2;           }           if (index2 < 0) {             index2 = 0;           }           builder.Length = index2;           index += 3;           continue;         }         builder.Append(c);         ++index;         while (index < len) {           // Move the rest of the           // path segment until the next '/'           c = path[index];           if (c == '/') {             break;           }           builder.Append(c);           ++index;         }       }
Magic Number,PeterO.Cbor,URIUtility,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\URIUtility.cs,normalizePath,The following statement contains a magic number: while (index < len) {         char c = path[index];         if ((index + 3 <= len && c == '/' && path[index + 1] == '.' &&              path[index + 2] == '/') || (index + 2 == len && c == '.' &&              path[index + 1] == '.')) {           // begins with "/./" or is "..";           // move index by 2           index += 2;           continue;         }         if (index + 3 <= len && c == '.' &&             path[index + 1] == '.' && path[index + 2] == '/') {           // begins with "../";           // move index by 3           index += 3;           continue;         }         if ((index + 2 <= len && c == '.' &&              path[index + 1] == '/') || (index + 1 == len && c == '.')) {           // begins with "./" or is ".";           // move index by 1           ++index;           continue;         }         if (index + 2 == len && c == '/' &&             path[index + 1] == '.') {           // is "/."; append '/' and break           builder.Append('/');           break;         }         if (index + 3 == len && c == '/' &&             path[index + 1] == '.' && path[index + 2] == '.') {           // is "/.."; remove last segment'           // append "/" and return           int index2 = builder.Length - 1;           string builderString = builder.ToString();           while (index2 >= 0) {             if (builderString[index2] == '/') {               break;             }             --index2;           }           if (index2 < 0) {             index2 = 0;           }           builder.Length = index2;           builder.Append('/');           break;         }         if (index + 4 <= len && c == '/' && path[index + 1] == '.' &&             path[index + 2] == '.' && path[index + 3] == '/') {           // begins with "/../"; remove last segment           int index2 = builder.Length - 1;           string builderString = builder.ToString();           while (index2 >= 0) {             if (builderString[index2] == '/') {               break;             }             --index2;           }           if (index2 < 0) {             index2 = 0;           }           builder.Length = index2;           index += 3;           continue;         }         builder.Append(c);         ++index;         while (index < len) {           // Move the rest of the           // path segment until the next '/'           c = path[index];           if (c == '/') {             break;           }           builder.Append(c);           ++index;         }       }
Magic Number,PeterO.Cbor,URIUtility,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\URIUtility.cs,normalizePath,The following statement contains a magic number: while (index < len) {         char c = path[index];         if ((index + 3 <= len && c == '/' && path[index + 1] == '.' &&              path[index + 2] == '/') || (index + 2 == len && c == '.' &&              path[index + 1] == '.')) {           // begins with "/./" or is "..";           // move index by 2           index += 2;           continue;         }         if (index + 3 <= len && c == '.' &&             path[index + 1] == '.' && path[index + 2] == '/') {           // begins with "../";           // move index by 3           index += 3;           continue;         }         if ((index + 2 <= len && c == '.' &&              path[index + 1] == '/') || (index + 1 == len && c == '.')) {           // begins with "./" or is ".";           // move index by 1           ++index;           continue;         }         if (index + 2 == len && c == '/' &&             path[index + 1] == '.') {           // is "/."; append '/' and break           builder.Append('/');           break;         }         if (index + 3 == len && c == '/' &&             path[index + 1] == '.' && path[index + 2] == '.') {           // is "/.."; remove last segment'           // append "/" and return           int index2 = builder.Length - 1;           string builderString = builder.ToString();           while (index2 >= 0) {             if (builderString[index2] == '/') {               break;             }             --index2;           }           if (index2 < 0) {             index2 = 0;           }           builder.Length = index2;           builder.Append('/');           break;         }         if (index + 4 <= len && c == '/' && path[index + 1] == '.' &&             path[index + 2] == '.' && path[index + 3] == '/') {           // begins with "/../"; remove last segment           int index2 = builder.Length - 1;           string builderString = builder.ToString();           while (index2 >= 0) {             if (builderString[index2] == '/') {               break;             }             --index2;           }           if (index2 < 0) {             index2 = 0;           }           builder.Length = index2;           index += 3;           continue;         }         builder.Append(c);         ++index;         while (index < len) {           // Move the rest of the           // path segment until the next '/'           c = path[index];           if (c == '/') {             break;           }           builder.Append(c);           ++index;         }       }
Magic Number,PeterO.Cbor,URIUtility,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\URIUtility.cs,parseDecOctet,The following statement contains a magic number: if (c >= '1' && c <= '9' && index + 2 < endOffset &&           s[index + 1] >= '0' && s[index + 1] <= '9' &&           s[index + 2] == delim) {         return ((c - '0') * 10) + (s[index + 1] - '0');       }
Magic Number,PeterO.Cbor,URIUtility,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\URIUtility.cs,parseDecOctet,The following statement contains a magic number: if (c >= '1' && c <= '9' && index + 2 < endOffset &&           s[index + 1] >= '0' && s[index + 1] <= '9' &&           s[index + 2] == delim) {         return ((c - '0') * 10) + (s[index + 1] - '0');       }
Magic Number,PeterO.Cbor,URIUtility,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\URIUtility.cs,parseDecOctet,The following statement contains a magic number: if (c >= '1' && c <= '9' && index + 2 < endOffset &&           s[index + 1] >= '0' && s[index + 1] <= '9' &&           s[index + 2] == delim) {         return ((c - '0') * 10) + (s[index + 1] - '0');       }
Magic Number,PeterO.Cbor,URIUtility,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\URIUtility.cs,parseDecOctet,The following statement contains a magic number: if (c == '2' && index + 3 < endOffset &&        (s[index + 1] == '5') && (s[index + 2] >= '0' && s[index + 2] <= '5') &&           s[index + 3] == delim) {         return 250 + (s[index + 2] - '0');       }
Magic Number,PeterO.Cbor,URIUtility,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\URIUtility.cs,parseDecOctet,The following statement contains a magic number: if (c == '2' && index + 3 < endOffset &&        (s[index + 1] == '5') && (s[index + 2] >= '0' && s[index + 2] <= '5') &&           s[index + 3] == delim) {         return 250 + (s[index + 2] - '0');       }
Magic Number,PeterO.Cbor,URIUtility,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\URIUtility.cs,parseDecOctet,The following statement contains a magic number: if (c == '2' && index + 3 < endOffset &&        (s[index + 1] == '5') && (s[index + 2] >= '0' && s[index + 2] <= '5') &&           s[index + 3] == delim) {         return 250 + (s[index + 2] - '0');       }
Magic Number,PeterO.Cbor,URIUtility,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\URIUtility.cs,parseDecOctet,The following statement contains a magic number: if (c == '2' && index + 3 < endOffset &&        (s[index + 1] == '5') && (s[index + 2] >= '0' && s[index + 2] <= '5') &&           s[index + 3] == delim) {         return 250 + (s[index + 2] - '0');       }
Magic Number,PeterO.Cbor,URIUtility,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\URIUtility.cs,parseDecOctet,The following statement contains a magic number: if (c == '2' && index + 3 < endOffset &&        (s[index + 1] == '5') && (s[index + 2] >= '0' && s[index + 2] <= '5') &&           s[index + 3] == delim) {         return 250 + (s[index + 2] - '0');       }
Magic Number,PeterO.Cbor,URIUtility,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\URIUtility.cs,parseDecOctet,The following statement contains a magic number: if (c == '2' && index + 3 < endOffset &&        (s[index + 1] == '5') && (s[index + 2] >= '0' && s[index + 2] <= '5') &&           s[index + 3] == delim) {         return 250 + (s[index + 2] - '0');       }
Magic Number,PeterO.Cbor,URIUtility,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\URIUtility.cs,parseDecOctet,The following statement contains a magic number: if (c == '2' && index + 3 < endOffset &&           s[index + 1] >= '0' && s[index + 1] <= '4' &&           s[index + 2] >= '0' && s[index + 2] <= '9' &&           s[index + 3] == delim) {         return 200 + ((s[index + 1] - '0') * 10) + (s[index + 2] - '0');       }
Magic Number,PeterO.Cbor,URIUtility,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\URIUtility.cs,parseDecOctet,The following statement contains a magic number: if (c == '2' && index + 3 < endOffset &&           s[index + 1] >= '0' && s[index + 1] <= '4' &&           s[index + 2] >= '0' && s[index + 2] <= '9' &&           s[index + 3] == delim) {         return 200 + ((s[index + 1] - '0') * 10) + (s[index + 2] - '0');       }
Magic Number,PeterO.Cbor,URIUtility,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\URIUtility.cs,parseDecOctet,The following statement contains a magic number: if (c == '2' && index + 3 < endOffset &&           s[index + 1] >= '0' && s[index + 1] <= '4' &&           s[index + 2] >= '0' && s[index + 2] <= '9' &&           s[index + 3] == delim) {         return 200 + ((s[index + 1] - '0') * 10) + (s[index + 2] - '0');       }
Magic Number,PeterO.Cbor,URIUtility,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\URIUtility.cs,parseDecOctet,The following statement contains a magic number: if (c == '2' && index + 3 < endOffset &&           s[index + 1] >= '0' && s[index + 1] <= '4' &&           s[index + 2] >= '0' && s[index + 2] <= '9' &&           s[index + 3] == delim) {         return 200 + ((s[index + 1] - '0') * 10) + (s[index + 2] - '0');       }
Magic Number,PeterO.Cbor,URIUtility,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\URIUtility.cs,parseDecOctet,The following statement contains a magic number: if (c == '2' && index + 3 < endOffset &&           s[index + 1] >= '0' && s[index + 1] <= '4' &&           s[index + 2] >= '0' && s[index + 2] <= '9' &&           s[index + 3] == delim) {         return 200 + ((s[index + 1] - '0') * 10) + (s[index + 2] - '0');       }
Magic Number,PeterO.Cbor,URIUtility,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\URIUtility.cs,parseDecOctet,The following statement contains a magic number: if (c == '2' && index + 3 < endOffset &&           s[index + 1] >= '0' && s[index + 1] <= '4' &&           s[index + 2] >= '0' && s[index + 2] <= '9' &&           s[index + 3] == delim) {         return 200 + ((s[index + 1] - '0') * 10) + (s[index + 2] - '0');       }
Magic Number,PeterO.Cbor,URIUtility,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\URIUtility.cs,parseDecOctet,The following statement contains a magic number: if (c == '2' && index + 3 < endOffset &&           s[index + 1] >= '0' && s[index + 1] <= '4' &&           s[index + 2] >= '0' && s[index + 2] <= '9' &&           s[index + 3] == delim) {         return 200 + ((s[index + 1] - '0') * 10) + (s[index + 2] - '0');       }
Magic Number,PeterO.Cbor,URIUtility,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\URIUtility.cs,parseDecOctet,The following statement contains a magic number: if (c == '1' && index + 3 < endOffset &&           s[index + 1] >= '0' && s[index + 1] <= '9' &&           s[index + 2] >= '0' && s[index + 2] <= '9' &&           s[index + 3] == delim) {         return 100 + ((s[index + 1] - '0') * 10) + (s[index + 2] - '0');       }
Magic Number,PeterO.Cbor,URIUtility,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\URIUtility.cs,parseDecOctet,The following statement contains a magic number: if (c == '1' && index + 3 < endOffset &&           s[index + 1] >= '0' && s[index + 1] <= '9' &&           s[index + 2] >= '0' && s[index + 2] <= '9' &&           s[index + 3] == delim) {         return 100 + ((s[index + 1] - '0') * 10) + (s[index + 2] - '0');       }
Magic Number,PeterO.Cbor,URIUtility,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\URIUtility.cs,parseDecOctet,The following statement contains a magic number: if (c == '1' && index + 3 < endOffset &&           s[index + 1] >= '0' && s[index + 1] <= '9' &&           s[index + 2] >= '0' && s[index + 2] <= '9' &&           s[index + 3] == delim) {         return 100 + ((s[index + 1] - '0') * 10) + (s[index + 2] - '0');       }
Magic Number,PeterO.Cbor,URIUtility,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\URIUtility.cs,parseDecOctet,The following statement contains a magic number: if (c == '1' && index + 3 < endOffset &&           s[index + 1] >= '0' && s[index + 1] <= '9' &&           s[index + 2] >= '0' && s[index + 2] <= '9' &&           s[index + 3] == delim) {         return 100 + ((s[index + 1] - '0') * 10) + (s[index + 2] - '0');       }
Magic Number,PeterO.Cbor,URIUtility,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\URIUtility.cs,parseDecOctet,The following statement contains a magic number: if (c == '1' && index + 3 < endOffset &&           s[index + 1] >= '0' && s[index + 1] <= '9' &&           s[index + 2] >= '0' && s[index + 2] <= '9' &&           s[index + 3] == delim) {         return 100 + ((s[index + 1] - '0') * 10) + (s[index + 2] - '0');       }
Magic Number,PeterO.Cbor,URIUtility,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\URIUtility.cs,parseDecOctet,The following statement contains a magic number: if (c == '1' && index + 3 < endOffset &&           s[index + 1] >= '0' && s[index + 1] <= '9' &&           s[index + 2] >= '0' && s[index + 2] <= '9' &&           s[index + 3] == delim) {         return 100 + ((s[index + 1] - '0') * 10) + (s[index + 2] - '0');       }
Magic Number,PeterO.Cbor,URIUtility,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\URIUtility.cs,parseDecOctet,The following statement contains a magic number: if (c == '1' && index + 3 < endOffset &&           s[index + 1] >= '0' && s[index + 1] <= '9' &&           s[index + 2] >= '0' && s[index + 2] <= '9' &&           s[index + 3] == delim) {         return 100 + ((s[index + 1] - '0') * 10) + (s[index + 2] - '0');       }
Magic Number,PeterO.Cbor,URIUtility,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\URIUtility.cs,parseIPLiteral,The following statement contains a magic number: if (s[index] == ':' ||           isHexChar(s[index])) {         // IPv6 Address         var phase1 = 0;         var phase2 = 0;         var phased = false;         var expectHex = false;         var expectColon = false;         while (index < endOffset) {           char c = s[index];           if (c == ':' && !expectHex) {             if ((phase1 + (phased ? 1 : 0) + phase2) >= 8) {               return -1;             }             ++index;             if (index < endOffset && s[index] == ':') {               if (phased) {                 return -1;               }               phased = true;               ++index;             }             expectHex = true;             expectColon = false;             continue;           }           if ((c >= '0' && c <= '9') && !expectColon &&               (phased || (phase1 + (phased ? 1 : 0) + phase2) == 6)) {             // Check for IPv4 address             int decOctet = parseDecOctet(s' index' endOffset' c' '.');             if (decOctet >= 0) {               if ((phase1 + (phased ? 1 : 0) + phase2) > 6) {                 // IPv4 address illegal at this point                 return -1;               } else {                 // Parse the rest of the IPv4 address                 phase2 += 2;                 if (decOctet >= 100) {                   index += 4;                 } else if (decOctet >= 10) {                   index += 3;                 } else {                   index += 2;                 }                 char tmpc = (index < endOffset) ? s[index] : '\0';                 decOctet = parseDecOctet(   s'   index'   endOffset'   tmpc'   '.');                 if (decOctet >= 100) {                   index += 4;                 } else if (decOctet >= 10) {                   index += 3;                 } else if (decOctet >= 0) {                   index += 2;                 } else {                   return -1;                 }                 tmpc = (index < endOffset) ? s[index] : '\0';                 decOctet = parseDecOctet(s' index' endOffset' tmpc' '.');                 if (decOctet >= 100) {                   index += 4;                 } else if (decOctet >= 10) {                   index += 3;                 } else if (decOctet >= 0) {                   index += 2;                 } else {                   return -1;                 }                 tmpc = (index < endOffset) ? s[index] : '\0';                 decOctet = parseDecOctet(s' index' endOffset' tmpc' ']');                 if (decOctet < 0) {                   tmpc = (index < endOffset) ? s[index] : '\0';                   decOctet = parseDecOctet(s' index' endOffset' tmpc' '%');                 }                 if (decOctet >= 100) {                   index += 3;                 } else if (decOctet >= 10) {                   index += 2;                 } else if (decOctet >= 0) {                   ++index;                 } else {                   return -1;                 }                 break;               }             }           }           if (isHexChar(c) && !expectColon) {             if (phased) {               ++phase2;             } else {               ++phase1;             }             ++index;             for (var i = 0; i < 3; ++i) {               if (index < endOffset && isHexChar(s[index])) {                 ++index;               } else {                 break;               }             }             expectHex = false;             expectColon = true;           } else {             break;           }         }         if ((phase1 + phase2) != 8 && !phased) {           return -1;         }         if (phase1 + 1 + phase2 > 8 && phased) {           return -1;         }         if (index >= endOffset) {           return -1;         }         if (s[index] != ']' && s[index] != '%') {           return -1;         }         if (s[index] == '%') {           if (index + 2 < endOffset && s[index + 1] == '2' &&               s[index + 2] == '5') {             // Zone identifier in an IPv6 address             // (see RFC6874)             index += 3;             var haveChar = false;             while (index < endOffset) {               char c = s[index];               if (c == ']') {                 return haveChar ? index + 1 : -1;               }               if (c == '%') {                 if (index + 2 < endOffset && isHexChar(s[index + 1]) &&                     isHexChar(s[index + 2])) {                   index += 3;                   haveChar = true;                   continue;                 }                 return -1;               }               if ((c >= 'a' && c <= 'z') || (c >= 'A' && c <= 'Z') ||              (c >= '0' && c <= '9') || c == '.' || c == '_' || c == '-' ||                 c == '~') {                 // unreserved character under RFC3986                 ++index;                 haveChar = true;                 continue;               }               return -1;             }             return -1;           }           return -1;         }         ++index;         return index;       }
Magic Number,PeterO.Cbor,URIUtility,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\URIUtility.cs,parseIPLiteral,The following statement contains a magic number: if (s[index] == ':' ||           isHexChar(s[index])) {         // IPv6 Address         var phase1 = 0;         var phase2 = 0;         var phased = false;         var expectHex = false;         var expectColon = false;         while (index < endOffset) {           char c = s[index];           if (c == ':' && !expectHex) {             if ((phase1 + (phased ? 1 : 0) + phase2) >= 8) {               return -1;             }             ++index;             if (index < endOffset && s[index] == ':') {               if (phased) {                 return -1;               }               phased = true;               ++index;             }             expectHex = true;             expectColon = false;             continue;           }           if ((c >= '0' && c <= '9') && !expectColon &&               (phased || (phase1 + (phased ? 1 : 0) + phase2) == 6)) {             // Check for IPv4 address             int decOctet = parseDecOctet(s' index' endOffset' c' '.');             if (decOctet >= 0) {               if ((phase1 + (phased ? 1 : 0) + phase2) > 6) {                 // IPv4 address illegal at this point                 return -1;               } else {                 // Parse the rest of the IPv4 address                 phase2 += 2;                 if (decOctet >= 100) {                   index += 4;                 } else if (decOctet >= 10) {                   index += 3;                 } else {                   index += 2;                 }                 char tmpc = (index < endOffset) ? s[index] : '\0';                 decOctet = parseDecOctet(   s'   index'   endOffset'   tmpc'   '.');                 if (decOctet >= 100) {                   index += 4;                 } else if (decOctet >= 10) {                   index += 3;                 } else if (decOctet >= 0) {                   index += 2;                 } else {                   return -1;                 }                 tmpc = (index < endOffset) ? s[index] : '\0';                 decOctet = parseDecOctet(s' index' endOffset' tmpc' '.');                 if (decOctet >= 100) {                   index += 4;                 } else if (decOctet >= 10) {                   index += 3;                 } else if (decOctet >= 0) {                   index += 2;                 } else {                   return -1;                 }                 tmpc = (index < endOffset) ? s[index] : '\0';                 decOctet = parseDecOctet(s' index' endOffset' tmpc' ']');                 if (decOctet < 0) {                   tmpc = (index < endOffset) ? s[index] : '\0';                   decOctet = parseDecOctet(s' index' endOffset' tmpc' '%');                 }                 if (decOctet >= 100) {                   index += 3;                 } else if (decOctet >= 10) {                   index += 2;                 } else if (decOctet >= 0) {                   ++index;                 } else {                   return -1;                 }                 break;               }             }           }           if (isHexChar(c) && !expectColon) {             if (phased) {               ++phase2;             } else {               ++phase1;             }             ++index;             for (var i = 0; i < 3; ++i) {               if (index < endOffset && isHexChar(s[index])) {                 ++index;               } else {                 break;               }             }             expectHex = false;             expectColon = true;           } else {             break;           }         }         if ((phase1 + phase2) != 8 && !phased) {           return -1;         }         if (phase1 + 1 + phase2 > 8 && phased) {           return -1;         }         if (index >= endOffset) {           return -1;         }         if (s[index] != ']' && s[index] != '%') {           return -1;         }         if (s[index] == '%') {           if (index + 2 < endOffset && s[index + 1] == '2' &&               s[index + 2] == '5') {             // Zone identifier in an IPv6 address             // (see RFC6874)             index += 3;             var haveChar = false;             while (index < endOffset) {               char c = s[index];               if (c == ']') {                 return haveChar ? index + 1 : -1;               }               if (c == '%') {                 if (index + 2 < endOffset && isHexChar(s[index + 1]) &&                     isHexChar(s[index + 2])) {                   index += 3;                   haveChar = true;                   continue;                 }                 return -1;               }               if ((c >= 'a' && c <= 'z') || (c >= 'A' && c <= 'Z') ||              (c >= '0' && c <= '9') || c == '.' || c == '_' || c == '-' ||                 c == '~') {                 // unreserved character under RFC3986                 ++index;                 haveChar = true;                 continue;               }               return -1;             }             return -1;           }           return -1;         }         ++index;         return index;       }
Magic Number,PeterO.Cbor,URIUtility,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\URIUtility.cs,parseIPLiteral,The following statement contains a magic number: if (s[index] == ':' ||           isHexChar(s[index])) {         // IPv6 Address         var phase1 = 0;         var phase2 = 0;         var phased = false;         var expectHex = false;         var expectColon = false;         while (index < endOffset) {           char c = s[index];           if (c == ':' && !expectHex) {             if ((phase1 + (phased ? 1 : 0) + phase2) >= 8) {               return -1;             }             ++index;             if (index < endOffset && s[index] == ':') {               if (phased) {                 return -1;               }               phased = true;               ++index;             }             expectHex = true;             expectColon = false;             continue;           }           if ((c >= '0' && c <= '9') && !expectColon &&               (phased || (phase1 + (phased ? 1 : 0) + phase2) == 6)) {             // Check for IPv4 address             int decOctet = parseDecOctet(s' index' endOffset' c' '.');             if (decOctet >= 0) {               if ((phase1 + (phased ? 1 : 0) + phase2) > 6) {                 // IPv4 address illegal at this point                 return -1;               } else {                 // Parse the rest of the IPv4 address                 phase2 += 2;                 if (decOctet >= 100) {                   index += 4;                 } else if (decOctet >= 10) {                   index += 3;                 } else {                   index += 2;                 }                 char tmpc = (index < endOffset) ? s[index] : '\0';                 decOctet = parseDecOctet(   s'   index'   endOffset'   tmpc'   '.');                 if (decOctet >= 100) {                   index += 4;                 } else if (decOctet >= 10) {                   index += 3;                 } else if (decOctet >= 0) {                   index += 2;                 } else {                   return -1;                 }                 tmpc = (index < endOffset) ? s[index] : '\0';                 decOctet = parseDecOctet(s' index' endOffset' tmpc' '.');                 if (decOctet >= 100) {                   index += 4;                 } else if (decOctet >= 10) {                   index += 3;                 } else if (decOctet >= 0) {                   index += 2;                 } else {                   return -1;                 }                 tmpc = (index < endOffset) ? s[index] : '\0';                 decOctet = parseDecOctet(s' index' endOffset' tmpc' ']');                 if (decOctet < 0) {                   tmpc = (index < endOffset) ? s[index] : '\0';                   decOctet = parseDecOctet(s' index' endOffset' tmpc' '%');                 }                 if (decOctet >= 100) {                   index += 3;                 } else if (decOctet >= 10) {                   index += 2;                 } else if (decOctet >= 0) {                   ++index;                 } else {                   return -1;                 }                 break;               }             }           }           if (isHexChar(c) && !expectColon) {             if (phased) {               ++phase2;             } else {               ++phase1;             }             ++index;             for (var i = 0; i < 3; ++i) {               if (index < endOffset && isHexChar(s[index])) {                 ++index;               } else {                 break;               }             }             expectHex = false;             expectColon = true;           } else {             break;           }         }         if ((phase1 + phase2) != 8 && !phased) {           return -1;         }         if (phase1 + 1 + phase2 > 8 && phased) {           return -1;         }         if (index >= endOffset) {           return -1;         }         if (s[index] != ']' && s[index] != '%') {           return -1;         }         if (s[index] == '%') {           if (index + 2 < endOffset && s[index + 1] == '2' &&               s[index + 2] == '5') {             // Zone identifier in an IPv6 address             // (see RFC6874)             index += 3;             var haveChar = false;             while (index < endOffset) {               char c = s[index];               if (c == ']') {                 return haveChar ? index + 1 : -1;               }               if (c == '%') {                 if (index + 2 < endOffset && isHexChar(s[index + 1]) &&                     isHexChar(s[index + 2])) {                   index += 3;                   haveChar = true;                   continue;                 }                 return -1;               }               if ((c >= 'a' && c <= 'z') || (c >= 'A' && c <= 'Z') ||              (c >= '0' && c <= '9') || c == '.' || c == '_' || c == '-' ||                 c == '~') {                 // unreserved character under RFC3986                 ++index;                 haveChar = true;                 continue;               }               return -1;             }             return -1;           }           return -1;         }         ++index;         return index;       }
Magic Number,PeterO.Cbor,URIUtility,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\URIUtility.cs,parseIPLiteral,The following statement contains a magic number: if (s[index] == ':' ||           isHexChar(s[index])) {         // IPv6 Address         var phase1 = 0;         var phase2 = 0;         var phased = false;         var expectHex = false;         var expectColon = false;         while (index < endOffset) {           char c = s[index];           if (c == ':' && !expectHex) {             if ((phase1 + (phased ? 1 : 0) + phase2) >= 8) {               return -1;             }             ++index;             if (index < endOffset && s[index] == ':') {               if (phased) {                 return -1;               }               phased = true;               ++index;             }             expectHex = true;             expectColon = false;             continue;           }           if ((c >= '0' && c <= '9') && !expectColon &&               (phased || (phase1 + (phased ? 1 : 0) + phase2) == 6)) {             // Check for IPv4 address             int decOctet = parseDecOctet(s' index' endOffset' c' '.');             if (decOctet >= 0) {               if ((phase1 + (phased ? 1 : 0) + phase2) > 6) {                 // IPv4 address illegal at this point                 return -1;               } else {                 // Parse the rest of the IPv4 address                 phase2 += 2;                 if (decOctet >= 100) {                   index += 4;                 } else if (decOctet >= 10) {                   index += 3;                 } else {                   index += 2;                 }                 char tmpc = (index < endOffset) ? s[index] : '\0';                 decOctet = parseDecOctet(   s'   index'   endOffset'   tmpc'   '.');                 if (decOctet >= 100) {                   index += 4;                 } else if (decOctet >= 10) {                   index += 3;                 } else if (decOctet >= 0) {                   index += 2;                 } else {                   return -1;                 }                 tmpc = (index < endOffset) ? s[index] : '\0';                 decOctet = parseDecOctet(s' index' endOffset' tmpc' '.');                 if (decOctet >= 100) {                   index += 4;                 } else if (decOctet >= 10) {                   index += 3;                 } else if (decOctet >= 0) {                   index += 2;                 } else {                   return -1;                 }                 tmpc = (index < endOffset) ? s[index] : '\0';                 decOctet = parseDecOctet(s' index' endOffset' tmpc' ']');                 if (decOctet < 0) {                   tmpc = (index < endOffset) ? s[index] : '\0';                   decOctet = parseDecOctet(s' index' endOffset' tmpc' '%');                 }                 if (decOctet >= 100) {                   index += 3;                 } else if (decOctet >= 10) {                   index += 2;                 } else if (decOctet >= 0) {                   ++index;                 } else {                   return -1;                 }                 break;               }             }           }           if (isHexChar(c) && !expectColon) {             if (phased) {               ++phase2;             } else {               ++phase1;             }             ++index;             for (var i = 0; i < 3; ++i) {               if (index < endOffset && isHexChar(s[index])) {                 ++index;               } else {                 break;               }             }             expectHex = false;             expectColon = true;           } else {             break;           }         }         if ((phase1 + phase2) != 8 && !phased) {           return -1;         }         if (phase1 + 1 + phase2 > 8 && phased) {           return -1;         }         if (index >= endOffset) {           return -1;         }         if (s[index] != ']' && s[index] != '%') {           return -1;         }         if (s[index] == '%') {           if (index + 2 < endOffset && s[index + 1] == '2' &&               s[index + 2] == '5') {             // Zone identifier in an IPv6 address             // (see RFC6874)             index += 3;             var haveChar = false;             while (index < endOffset) {               char c = s[index];               if (c == ']') {                 return haveChar ? index + 1 : -1;               }               if (c == '%') {                 if (index + 2 < endOffset && isHexChar(s[index + 1]) &&                     isHexChar(s[index + 2])) {                   index += 3;                   haveChar = true;                   continue;                 }                 return -1;               }               if ((c >= 'a' && c <= 'z') || (c >= 'A' && c <= 'Z') ||              (c >= '0' && c <= '9') || c == '.' || c == '_' || c == '-' ||                 c == '~') {                 // unreserved character under RFC3986                 ++index;                 haveChar = true;                 continue;               }               return -1;             }             return -1;           }           return -1;         }         ++index;         return index;       }
Magic Number,PeterO.Cbor,URIUtility,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\URIUtility.cs,parseIPLiteral,The following statement contains a magic number: if (s[index] == ':' ||           isHexChar(s[index])) {         // IPv6 Address         var phase1 = 0;         var phase2 = 0;         var phased = false;         var expectHex = false;         var expectColon = false;         while (index < endOffset) {           char c = s[index];           if (c == ':' && !expectHex) {             if ((phase1 + (phased ? 1 : 0) + phase2) >= 8) {               return -1;             }             ++index;             if (index < endOffset && s[index] == ':') {               if (phased) {                 return -1;               }               phased = true;               ++index;             }             expectHex = true;             expectColon = false;             continue;           }           if ((c >= '0' && c <= '9') && !expectColon &&               (phased || (phase1 + (phased ? 1 : 0) + phase2) == 6)) {             // Check for IPv4 address             int decOctet = parseDecOctet(s' index' endOffset' c' '.');             if (decOctet >= 0) {               if ((phase1 + (phased ? 1 : 0) + phase2) > 6) {                 // IPv4 address illegal at this point                 return -1;               } else {                 // Parse the rest of the IPv4 address                 phase2 += 2;                 if (decOctet >= 100) {                   index += 4;                 } else if (decOctet >= 10) {                   index += 3;                 } else {                   index += 2;                 }                 char tmpc = (index < endOffset) ? s[index] : '\0';                 decOctet = parseDecOctet(   s'   index'   endOffset'   tmpc'   '.');                 if (decOctet >= 100) {                   index += 4;                 } else if (decOctet >= 10) {                   index += 3;                 } else if (decOctet >= 0) {                   index += 2;                 } else {                   return -1;                 }                 tmpc = (index < endOffset) ? s[index] : '\0';                 decOctet = parseDecOctet(s' index' endOffset' tmpc' '.');                 if (decOctet >= 100) {                   index += 4;                 } else if (decOctet >= 10) {                   index += 3;                 } else if (decOctet >= 0) {                   index += 2;                 } else {                   return -1;                 }                 tmpc = (index < endOffset) ? s[index] : '\0';                 decOctet = parseDecOctet(s' index' endOffset' tmpc' ']');                 if (decOctet < 0) {                   tmpc = (index < endOffset) ? s[index] : '\0';                   decOctet = parseDecOctet(s' index' endOffset' tmpc' '%');                 }                 if (decOctet >= 100) {                   index += 3;                 } else if (decOctet >= 10) {                   index += 2;                 } else if (decOctet >= 0) {                   ++index;                 } else {                   return -1;                 }                 break;               }             }           }           if (isHexChar(c) && !expectColon) {             if (phased) {               ++phase2;             } else {               ++phase1;             }             ++index;             for (var i = 0; i < 3; ++i) {               if (index < endOffset && isHexChar(s[index])) {                 ++index;               } else {                 break;               }             }             expectHex = false;             expectColon = true;           } else {             break;           }         }         if ((phase1 + phase2) != 8 && !phased) {           return -1;         }         if (phase1 + 1 + phase2 > 8 && phased) {           return -1;         }         if (index >= endOffset) {           return -1;         }         if (s[index] != ']' && s[index] != '%') {           return -1;         }         if (s[index] == '%') {           if (index + 2 < endOffset && s[index + 1] == '2' &&               s[index + 2] == '5') {             // Zone identifier in an IPv6 address             // (see RFC6874)             index += 3;             var haveChar = false;             while (index < endOffset) {               char c = s[index];               if (c == ']') {                 return haveChar ? index + 1 : -1;               }               if (c == '%') {                 if (index + 2 < endOffset && isHexChar(s[index + 1]) &&                     isHexChar(s[index + 2])) {                   index += 3;                   haveChar = true;                   continue;                 }                 return -1;               }               if ((c >= 'a' && c <= 'z') || (c >= 'A' && c <= 'Z') ||              (c >= '0' && c <= '9') || c == '.' || c == '_' || c == '-' ||                 c == '~') {                 // unreserved character under RFC3986                 ++index;                 haveChar = true;                 continue;               }               return -1;             }             return -1;           }           return -1;         }         ++index;         return index;       }
Magic Number,PeterO.Cbor,URIUtility,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\URIUtility.cs,parseIPLiteral,The following statement contains a magic number: if (s[index] == ':' ||           isHexChar(s[index])) {         // IPv6 Address         var phase1 = 0;         var phase2 = 0;         var phased = false;         var expectHex = false;         var expectColon = false;         while (index < endOffset) {           char c = s[index];           if (c == ':' && !expectHex) {             if ((phase1 + (phased ? 1 : 0) + phase2) >= 8) {               return -1;             }             ++index;             if (index < endOffset && s[index] == ':') {               if (phased) {                 return -1;               }               phased = true;               ++index;             }             expectHex = true;             expectColon = false;             continue;           }           if ((c >= '0' && c <= '9') && !expectColon &&               (phased || (phase1 + (phased ? 1 : 0) + phase2) == 6)) {             // Check for IPv4 address             int decOctet = parseDecOctet(s' index' endOffset' c' '.');             if (decOctet >= 0) {               if ((phase1 + (phased ? 1 : 0) + phase2) > 6) {                 // IPv4 address illegal at this point                 return -1;               } else {                 // Parse the rest of the IPv4 address                 phase2 += 2;                 if (decOctet >= 100) {                   index += 4;                 } else if (decOctet >= 10) {                   index += 3;                 } else {                   index += 2;                 }                 char tmpc = (index < endOffset) ? s[index] : '\0';                 decOctet = parseDecOctet(   s'   index'   endOffset'   tmpc'   '.');                 if (decOctet >= 100) {                   index += 4;                 } else if (decOctet >= 10) {                   index += 3;                 } else if (decOctet >= 0) {                   index += 2;                 } else {                   return -1;                 }                 tmpc = (index < endOffset) ? s[index] : '\0';                 decOctet = parseDecOctet(s' index' endOffset' tmpc' '.');                 if (decOctet >= 100) {                   index += 4;                 } else if (decOctet >= 10) {                   index += 3;                 } else if (decOctet >= 0) {                   index += 2;                 } else {                   return -1;                 }                 tmpc = (index < endOffset) ? s[index] : '\0';                 decOctet = parseDecOctet(s' index' endOffset' tmpc' ']');                 if (decOctet < 0) {                   tmpc = (index < endOffset) ? s[index] : '\0';                   decOctet = parseDecOctet(s' index' endOffset' tmpc' '%');                 }                 if (decOctet >= 100) {                   index += 3;                 } else if (decOctet >= 10) {                   index += 2;                 } else if (decOctet >= 0) {                   ++index;                 } else {                   return -1;                 }                 break;               }             }           }           if (isHexChar(c) && !expectColon) {             if (phased) {               ++phase2;             } else {               ++phase1;             }             ++index;             for (var i = 0; i < 3; ++i) {               if (index < endOffset && isHexChar(s[index])) {                 ++index;               } else {                 break;               }             }             expectHex = false;             expectColon = true;           } else {             break;           }         }         if ((phase1 + phase2) != 8 && !phased) {           return -1;         }         if (phase1 + 1 + phase2 > 8 && phased) {           return -1;         }         if (index >= endOffset) {           return -1;         }         if (s[index] != ']' && s[index] != '%') {           return -1;         }         if (s[index] == '%') {           if (index + 2 < endOffset && s[index + 1] == '2' &&               s[index + 2] == '5') {             // Zone identifier in an IPv6 address             // (see RFC6874)             index += 3;             var haveChar = false;             while (index < endOffset) {               char c = s[index];               if (c == ']') {                 return haveChar ? index + 1 : -1;               }               if (c == '%') {                 if (index + 2 < endOffset && isHexChar(s[index + 1]) &&                     isHexChar(s[index + 2])) {                   index += 3;                   haveChar = true;                   continue;                 }                 return -1;               }               if ((c >= 'a' && c <= 'z') || (c >= 'A' && c <= 'Z') ||              (c >= '0' && c <= '9') || c == '.' || c == '_' || c == '-' ||                 c == '~') {                 // unreserved character under RFC3986                 ++index;                 haveChar = true;                 continue;               }               return -1;             }             return -1;           }           return -1;         }         ++index;         return index;       }
Magic Number,PeterO.Cbor,URIUtility,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\URIUtility.cs,parseIPLiteral,The following statement contains a magic number: if (s[index] == ':' ||           isHexChar(s[index])) {         // IPv6 Address         var phase1 = 0;         var phase2 = 0;         var phased = false;         var expectHex = false;         var expectColon = false;         while (index < endOffset) {           char c = s[index];           if (c == ':' && !expectHex) {             if ((phase1 + (phased ? 1 : 0) + phase2) >= 8) {               return -1;             }             ++index;             if (index < endOffset && s[index] == ':') {               if (phased) {                 return -1;               }               phased = true;               ++index;             }             expectHex = true;             expectColon = false;             continue;           }           if ((c >= '0' && c <= '9') && !expectColon &&               (phased || (phase1 + (phased ? 1 : 0) + phase2) == 6)) {             // Check for IPv4 address             int decOctet = parseDecOctet(s' index' endOffset' c' '.');             if (decOctet >= 0) {               if ((phase1 + (phased ? 1 : 0) + phase2) > 6) {                 // IPv4 address illegal at this point                 return -1;               } else {                 // Parse the rest of the IPv4 address                 phase2 += 2;                 if (decOctet >= 100) {                   index += 4;                 } else if (decOctet >= 10) {                   index += 3;                 } else {                   index += 2;                 }                 char tmpc = (index < endOffset) ? s[index] : '\0';                 decOctet = parseDecOctet(   s'   index'   endOffset'   tmpc'   '.');                 if (decOctet >= 100) {                   index += 4;                 } else if (decOctet >= 10) {                   index += 3;                 } else if (decOctet >= 0) {                   index += 2;                 } else {                   return -1;                 }                 tmpc = (index < endOffset) ? s[index] : '\0';                 decOctet = parseDecOctet(s' index' endOffset' tmpc' '.');                 if (decOctet >= 100) {                   index += 4;                 } else if (decOctet >= 10) {                   index += 3;                 } else if (decOctet >= 0) {                   index += 2;                 } else {                   return -1;                 }                 tmpc = (index < endOffset) ? s[index] : '\0';                 decOctet = parseDecOctet(s' index' endOffset' tmpc' ']');                 if (decOctet < 0) {                   tmpc = (index < endOffset) ? s[index] : '\0';                   decOctet = parseDecOctet(s' index' endOffset' tmpc' '%');                 }                 if (decOctet >= 100) {                   index += 3;                 } else if (decOctet >= 10) {                   index += 2;                 } else if (decOctet >= 0) {                   ++index;                 } else {                   return -1;                 }                 break;               }             }           }           if (isHexChar(c) && !expectColon) {             if (phased) {               ++phase2;             } else {               ++phase1;             }             ++index;             for (var i = 0; i < 3; ++i) {               if (index < endOffset && isHexChar(s[index])) {                 ++index;               } else {                 break;               }             }             expectHex = false;             expectColon = true;           } else {             break;           }         }         if ((phase1 + phase2) != 8 && !phased) {           return -1;         }         if (phase1 + 1 + phase2 > 8 && phased) {           return -1;         }         if (index >= endOffset) {           return -1;         }         if (s[index] != ']' && s[index] != '%') {           return -1;         }         if (s[index] == '%') {           if (index + 2 < endOffset && s[index + 1] == '2' &&               s[index + 2] == '5') {             // Zone identifier in an IPv6 address             // (see RFC6874)             index += 3;             var haveChar = false;             while (index < endOffset) {               char c = s[index];               if (c == ']') {                 return haveChar ? index + 1 : -1;               }               if (c == '%') {                 if (index + 2 < endOffset && isHexChar(s[index + 1]) &&                     isHexChar(s[index + 2])) {                   index += 3;                   haveChar = true;                   continue;                 }                 return -1;               }               if ((c >= 'a' && c <= 'z') || (c >= 'A' && c <= 'Z') ||              (c >= '0' && c <= '9') || c == '.' || c == '_' || c == '-' ||                 c == '~') {                 // unreserved character under RFC3986                 ++index;                 haveChar = true;                 continue;               }               return -1;             }             return -1;           }           return -1;         }         ++index;         return index;       }
Magic Number,PeterO.Cbor,URIUtility,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\URIUtility.cs,parseIPLiteral,The following statement contains a magic number: if (s[index] == ':' ||           isHexChar(s[index])) {         // IPv6 Address         var phase1 = 0;         var phase2 = 0;         var phased = false;         var expectHex = false;         var expectColon = false;         while (index < endOffset) {           char c = s[index];           if (c == ':' && !expectHex) {             if ((phase1 + (phased ? 1 : 0) + phase2) >= 8) {               return -1;             }             ++index;             if (index < endOffset && s[index] == ':') {               if (phased) {                 return -1;               }               phased = true;               ++index;             }             expectHex = true;             expectColon = false;             continue;           }           if ((c >= '0' && c <= '9') && !expectColon &&               (phased || (phase1 + (phased ? 1 : 0) + phase2) == 6)) {             // Check for IPv4 address             int decOctet = parseDecOctet(s' index' endOffset' c' '.');             if (decOctet >= 0) {               if ((phase1 + (phased ? 1 : 0) + phase2) > 6) {                 // IPv4 address illegal at this point                 return -1;               } else {                 // Parse the rest of the IPv4 address                 phase2 += 2;                 if (decOctet >= 100) {                   index += 4;                 } else if (decOctet >= 10) {                   index += 3;                 } else {                   index += 2;                 }                 char tmpc = (index < endOffset) ? s[index] : '\0';                 decOctet = parseDecOctet(   s'   index'   endOffset'   tmpc'   '.');                 if (decOctet >= 100) {                   index += 4;                 } else if (decOctet >= 10) {                   index += 3;                 } else if (decOctet >= 0) {                   index += 2;                 } else {                   return -1;                 }                 tmpc = (index < endOffset) ? s[index] : '\0';                 decOctet = parseDecOctet(s' index' endOffset' tmpc' '.');                 if (decOctet >= 100) {                   index += 4;                 } else if (decOctet >= 10) {                   index += 3;                 } else if (decOctet >= 0) {                   index += 2;                 } else {                   return -1;                 }                 tmpc = (index < endOffset) ? s[index] : '\0';                 decOctet = parseDecOctet(s' index' endOffset' tmpc' ']');                 if (decOctet < 0) {                   tmpc = (index < endOffset) ? s[index] : '\0';                   decOctet = parseDecOctet(s' index' endOffset' tmpc' '%');                 }                 if (decOctet >= 100) {                   index += 3;                 } else if (decOctet >= 10) {                   index += 2;                 } else if (decOctet >= 0) {                   ++index;                 } else {                   return -1;                 }                 break;               }             }           }           if (isHexChar(c) && !expectColon) {             if (phased) {               ++phase2;             } else {               ++phase1;             }             ++index;             for (var i = 0; i < 3; ++i) {               if (index < endOffset && isHexChar(s[index])) {                 ++index;               } else {                 break;               }             }             expectHex = false;             expectColon = true;           } else {             break;           }         }         if ((phase1 + phase2) != 8 && !phased) {           return -1;         }         if (phase1 + 1 + phase2 > 8 && phased) {           return -1;         }         if (index >= endOffset) {           return -1;         }         if (s[index] != ']' && s[index] != '%') {           return -1;         }         if (s[index] == '%') {           if (index + 2 < endOffset && s[index + 1] == '2' &&               s[index + 2] == '5') {             // Zone identifier in an IPv6 address             // (see RFC6874)             index += 3;             var haveChar = false;             while (index < endOffset) {               char c = s[index];               if (c == ']') {                 return haveChar ? index + 1 : -1;               }               if (c == '%') {                 if (index + 2 < endOffset && isHexChar(s[index + 1]) &&                     isHexChar(s[index + 2])) {                   index += 3;                   haveChar = true;                   continue;                 }                 return -1;               }               if ((c >= 'a' && c <= 'z') || (c >= 'A' && c <= 'Z') ||              (c >= '0' && c <= '9') || c == '.' || c == '_' || c == '-' ||                 c == '~') {                 // unreserved character under RFC3986                 ++index;                 haveChar = true;                 continue;               }               return -1;             }             return -1;           }           return -1;         }         ++index;         return index;       }
Magic Number,PeterO.Cbor,URIUtility,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\URIUtility.cs,parseIPLiteral,The following statement contains a magic number: if (s[index] == ':' ||           isHexChar(s[index])) {         // IPv6 Address         var phase1 = 0;         var phase2 = 0;         var phased = false;         var expectHex = false;         var expectColon = false;         while (index < endOffset) {           char c = s[index];           if (c == ':' && !expectHex) {             if ((phase1 + (phased ? 1 : 0) + phase2) >= 8) {               return -1;             }             ++index;             if (index < endOffset && s[index] == ':') {               if (phased) {                 return -1;               }               phased = true;               ++index;             }             expectHex = true;             expectColon = false;             continue;           }           if ((c >= '0' && c <= '9') && !expectColon &&               (phased || (phase1 + (phased ? 1 : 0) + phase2) == 6)) {             // Check for IPv4 address             int decOctet = parseDecOctet(s' index' endOffset' c' '.');             if (decOctet >= 0) {               if ((phase1 + (phased ? 1 : 0) + phase2) > 6) {                 // IPv4 address illegal at this point                 return -1;               } else {                 // Parse the rest of the IPv4 address                 phase2 += 2;                 if (decOctet >= 100) {                   index += 4;                 } else if (decOctet >= 10) {                   index += 3;                 } else {                   index += 2;                 }                 char tmpc = (index < endOffset) ? s[index] : '\0';                 decOctet = parseDecOctet(   s'   index'   endOffset'   tmpc'   '.');                 if (decOctet >= 100) {                   index += 4;                 } else if (decOctet >= 10) {                   index += 3;                 } else if (decOctet >= 0) {                   index += 2;                 } else {                   return -1;                 }                 tmpc = (index < endOffset) ? s[index] : '\0';                 decOctet = parseDecOctet(s' index' endOffset' tmpc' '.');                 if (decOctet >= 100) {                   index += 4;                 } else if (decOctet >= 10) {                   index += 3;                 } else if (decOctet >= 0) {                   index += 2;                 } else {                   return -1;                 }                 tmpc = (index < endOffset) ? s[index] : '\0';                 decOctet = parseDecOctet(s' index' endOffset' tmpc' ']');                 if (decOctet < 0) {                   tmpc = (index < endOffset) ? s[index] : '\0';                   decOctet = parseDecOctet(s' index' endOffset' tmpc' '%');                 }                 if (decOctet >= 100) {                   index += 3;                 } else if (decOctet >= 10) {                   index += 2;                 } else if (decOctet >= 0) {                   ++index;                 } else {                   return -1;                 }                 break;               }             }           }           if (isHexChar(c) && !expectColon) {             if (phased) {               ++phase2;             } else {               ++phase1;             }             ++index;             for (var i = 0; i < 3; ++i) {               if (index < endOffset && isHexChar(s[index])) {                 ++index;               } else {                 break;               }             }             expectHex = false;             expectColon = true;           } else {             break;           }         }         if ((phase1 + phase2) != 8 && !phased) {           return -1;         }         if (phase1 + 1 + phase2 > 8 && phased) {           return -1;         }         if (index >= endOffset) {           return -1;         }         if (s[index] != ']' && s[index] != '%') {           return -1;         }         if (s[index] == '%') {           if (index + 2 < endOffset && s[index + 1] == '2' &&               s[index + 2] == '5') {             // Zone identifier in an IPv6 address             // (see RFC6874)             index += 3;             var haveChar = false;             while (index < endOffset) {               char c = s[index];               if (c == ']') {                 return haveChar ? index + 1 : -1;               }               if (c == '%') {                 if (index + 2 < endOffset && isHexChar(s[index + 1]) &&                     isHexChar(s[index + 2])) {                   index += 3;                   haveChar = true;                   continue;                 }                 return -1;               }               if ((c >= 'a' && c <= 'z') || (c >= 'A' && c <= 'Z') ||              (c >= '0' && c <= '9') || c == '.' || c == '_' || c == '-' ||                 c == '~') {                 // unreserved character under RFC3986                 ++index;                 haveChar = true;                 continue;               }               return -1;             }             return -1;           }           return -1;         }         ++index;         return index;       }
Magic Number,PeterO.Cbor,URIUtility,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\URIUtility.cs,parseIPLiteral,The following statement contains a magic number: if (s[index] == ':' ||           isHexChar(s[index])) {         // IPv6 Address         var phase1 = 0;         var phase2 = 0;         var phased = false;         var expectHex = false;         var expectColon = false;         while (index < endOffset) {           char c = s[index];           if (c == ':' && !expectHex) {             if ((phase1 + (phased ? 1 : 0) + phase2) >= 8) {               return -1;             }             ++index;             if (index < endOffset && s[index] == ':') {               if (phased) {                 return -1;               }               phased = true;               ++index;             }             expectHex = true;             expectColon = false;             continue;           }           if ((c >= '0' && c <= '9') && !expectColon &&               (phased || (phase1 + (phased ? 1 : 0) + phase2) == 6)) {             // Check for IPv4 address             int decOctet = parseDecOctet(s' index' endOffset' c' '.');             if (decOctet >= 0) {               if ((phase1 + (phased ? 1 : 0) + phase2) > 6) {                 // IPv4 address illegal at this point                 return -1;               } else {                 // Parse the rest of the IPv4 address                 phase2 += 2;                 if (decOctet >= 100) {                   index += 4;                 } else if (decOctet >= 10) {                   index += 3;                 } else {                   index += 2;                 }                 char tmpc = (index < endOffset) ? s[index] : '\0';                 decOctet = parseDecOctet(   s'   index'   endOffset'   tmpc'   '.');                 if (decOctet >= 100) {                   index += 4;                 } else if (decOctet >= 10) {                   index += 3;                 } else if (decOctet >= 0) {                   index += 2;                 } else {                   return -1;                 }                 tmpc = (index < endOffset) ? s[index] : '\0';                 decOctet = parseDecOctet(s' index' endOffset' tmpc' '.');                 if (decOctet >= 100) {                   index += 4;                 } else if (decOctet >= 10) {                   index += 3;                 } else if (decOctet >= 0) {                   index += 2;                 } else {                   return -1;                 }                 tmpc = (index < endOffset) ? s[index] : '\0';                 decOctet = parseDecOctet(s' index' endOffset' tmpc' ']');                 if (decOctet < 0) {                   tmpc = (index < endOffset) ? s[index] : '\0';                   decOctet = parseDecOctet(s' index' endOffset' tmpc' '%');                 }                 if (decOctet >= 100) {                   index += 3;                 } else if (decOctet >= 10) {                   index += 2;                 } else if (decOctet >= 0) {                   ++index;                 } else {                   return -1;                 }                 break;               }             }           }           if (isHexChar(c) && !expectColon) {             if (phased) {               ++phase2;             } else {               ++phase1;             }             ++index;             for (var i = 0; i < 3; ++i) {               if (index < endOffset && isHexChar(s[index])) {                 ++index;               } else {                 break;               }             }             expectHex = false;             expectColon = true;           } else {             break;           }         }         if ((phase1 + phase2) != 8 && !phased) {           return -1;         }         if (phase1 + 1 + phase2 > 8 && phased) {           return -1;         }         if (index >= endOffset) {           return -1;         }         if (s[index] != ']' && s[index] != '%') {           return -1;         }         if (s[index] == '%') {           if (index + 2 < endOffset && s[index + 1] == '2' &&               s[index + 2] == '5') {             // Zone identifier in an IPv6 address             // (see RFC6874)             index += 3;             var haveChar = false;             while (index < endOffset) {               char c = s[index];               if (c == ']') {                 return haveChar ? index + 1 : -1;               }               if (c == '%') {                 if (index + 2 < endOffset && isHexChar(s[index + 1]) &&                     isHexChar(s[index + 2])) {                   index += 3;                   haveChar = true;                   continue;                 }                 return -1;               }               if ((c >= 'a' && c <= 'z') || (c >= 'A' && c <= 'Z') ||              (c >= '0' && c <= '9') || c == '.' || c == '_' || c == '-' ||                 c == '~') {                 // unreserved character under RFC3986                 ++index;                 haveChar = true;                 continue;               }               return -1;             }             return -1;           }           return -1;         }         ++index;         return index;       }
Magic Number,PeterO.Cbor,URIUtility,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\URIUtility.cs,parseIPLiteral,The following statement contains a magic number: if (s[index] == ':' ||           isHexChar(s[index])) {         // IPv6 Address         var phase1 = 0;         var phase2 = 0;         var phased = false;         var expectHex = false;         var expectColon = false;         while (index < endOffset) {           char c = s[index];           if (c == ':' && !expectHex) {             if ((phase1 + (phased ? 1 : 0) + phase2) >= 8) {               return -1;             }             ++index;             if (index < endOffset && s[index] == ':') {               if (phased) {                 return -1;               }               phased = true;               ++index;             }             expectHex = true;             expectColon = false;             continue;           }           if ((c >= '0' && c <= '9') && !expectColon &&               (phased || (phase1 + (phased ? 1 : 0) + phase2) == 6)) {             // Check for IPv4 address             int decOctet = parseDecOctet(s' index' endOffset' c' '.');             if (decOctet >= 0) {               if ((phase1 + (phased ? 1 : 0) + phase2) > 6) {                 // IPv4 address illegal at this point                 return -1;               } else {                 // Parse the rest of the IPv4 address                 phase2 += 2;                 if (decOctet >= 100) {                   index += 4;                 } else if (decOctet >= 10) {                   index += 3;                 } else {                   index += 2;                 }                 char tmpc = (index < endOffset) ? s[index] : '\0';                 decOctet = parseDecOctet(   s'   index'   endOffset'   tmpc'   '.');                 if (decOctet >= 100) {                   index += 4;                 } else if (decOctet >= 10) {                   index += 3;                 } else if (decOctet >= 0) {                   index += 2;                 } else {                   return -1;                 }                 tmpc = (index < endOffset) ? s[index] : '\0';                 decOctet = parseDecOctet(s' index' endOffset' tmpc' '.');                 if (decOctet >= 100) {                   index += 4;                 } else if (decOctet >= 10) {                   index += 3;                 } else if (decOctet >= 0) {                   index += 2;                 } else {                   return -1;                 }                 tmpc = (index < endOffset) ? s[index] : '\0';                 decOctet = parseDecOctet(s' index' endOffset' tmpc' ']');                 if (decOctet < 0) {                   tmpc = (index < endOffset) ? s[index] : '\0';                   decOctet = parseDecOctet(s' index' endOffset' tmpc' '%');                 }                 if (decOctet >= 100) {                   index += 3;                 } else if (decOctet >= 10) {                   index += 2;                 } else if (decOctet >= 0) {                   ++index;                 } else {                   return -1;                 }                 break;               }             }           }           if (isHexChar(c) && !expectColon) {             if (phased) {               ++phase2;             } else {               ++phase1;             }             ++index;             for (var i = 0; i < 3; ++i) {               if (index < endOffset && isHexChar(s[index])) {                 ++index;               } else {                 break;               }             }             expectHex = false;             expectColon = true;           } else {             break;           }         }         if ((phase1 + phase2) != 8 && !phased) {           return -1;         }         if (phase1 + 1 + phase2 > 8 && phased) {           return -1;         }         if (index >= endOffset) {           return -1;         }         if (s[index] != ']' && s[index] != '%') {           return -1;         }         if (s[index] == '%') {           if (index + 2 < endOffset && s[index + 1] == '2' &&               s[index + 2] == '5') {             // Zone identifier in an IPv6 address             // (see RFC6874)             index += 3;             var haveChar = false;             while (index < endOffset) {               char c = s[index];               if (c == ']') {                 return haveChar ? index + 1 : -1;               }               if (c == '%') {                 if (index + 2 < endOffset && isHexChar(s[index + 1]) &&                     isHexChar(s[index + 2])) {                   index += 3;                   haveChar = true;                   continue;                 }                 return -1;               }               if ((c >= 'a' && c <= 'z') || (c >= 'A' && c <= 'Z') ||              (c >= '0' && c <= '9') || c == '.' || c == '_' || c == '-' ||                 c == '~') {                 // unreserved character under RFC3986                 ++index;                 haveChar = true;                 continue;               }               return -1;             }             return -1;           }           return -1;         }         ++index;         return index;       }
Magic Number,PeterO.Cbor,URIUtility,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\URIUtility.cs,parseIPLiteral,The following statement contains a magic number: if (s[index] == ':' ||           isHexChar(s[index])) {         // IPv6 Address         var phase1 = 0;         var phase2 = 0;         var phased = false;         var expectHex = false;         var expectColon = false;         while (index < endOffset) {           char c = s[index];           if (c == ':' && !expectHex) {             if ((phase1 + (phased ? 1 : 0) + phase2) >= 8) {               return -1;             }             ++index;             if (index < endOffset && s[index] == ':') {               if (phased) {                 return -1;               }               phased = true;               ++index;             }             expectHex = true;             expectColon = false;             continue;           }           if ((c >= '0' && c <= '9') && !expectColon &&               (phased || (phase1 + (phased ? 1 : 0) + phase2) == 6)) {             // Check for IPv4 address             int decOctet = parseDecOctet(s' index' endOffset' c' '.');             if (decOctet >= 0) {               if ((phase1 + (phased ? 1 : 0) + phase2) > 6) {                 // IPv4 address illegal at this point                 return -1;               } else {                 // Parse the rest of the IPv4 address                 phase2 += 2;                 if (decOctet >= 100) {                   index += 4;                 } else if (decOctet >= 10) {                   index += 3;                 } else {                   index += 2;                 }                 char tmpc = (index < endOffset) ? s[index] : '\0';                 decOctet = parseDecOctet(   s'   index'   endOffset'   tmpc'   '.');                 if (decOctet >= 100) {                   index += 4;                 } else if (decOctet >= 10) {                   index += 3;                 } else if (decOctet >= 0) {                   index += 2;                 } else {                   return -1;                 }                 tmpc = (index < endOffset) ? s[index] : '\0';                 decOctet = parseDecOctet(s' index' endOffset' tmpc' '.');                 if (decOctet >= 100) {                   index += 4;                 } else if (decOctet >= 10) {                   index += 3;                 } else if (decOctet >= 0) {                   index += 2;                 } else {                   return -1;                 }                 tmpc = (index < endOffset) ? s[index] : '\0';                 decOctet = parseDecOctet(s' index' endOffset' tmpc' ']');                 if (decOctet < 0) {                   tmpc = (index < endOffset) ? s[index] : '\0';                   decOctet = parseDecOctet(s' index' endOffset' tmpc' '%');                 }                 if (decOctet >= 100) {                   index += 3;                 } else if (decOctet >= 10) {                   index += 2;                 } else if (decOctet >= 0) {                   ++index;                 } else {                   return -1;                 }                 break;               }             }           }           if (isHexChar(c) && !expectColon) {             if (phased) {               ++phase2;             } else {               ++phase1;             }             ++index;             for (var i = 0; i < 3; ++i) {               if (index < endOffset && isHexChar(s[index])) {                 ++index;               } else {                 break;               }             }             expectHex = false;             expectColon = true;           } else {             break;           }         }         if ((phase1 + phase2) != 8 && !phased) {           return -1;         }         if (phase1 + 1 + phase2 > 8 && phased) {           return -1;         }         if (index >= endOffset) {           return -1;         }         if (s[index] != ']' && s[index] != '%') {           return -1;         }         if (s[index] == '%') {           if (index + 2 < endOffset && s[index + 1] == '2' &&               s[index + 2] == '5') {             // Zone identifier in an IPv6 address             // (see RFC6874)             index += 3;             var haveChar = false;             while (index < endOffset) {               char c = s[index];               if (c == ']') {                 return haveChar ? index + 1 : -1;               }               if (c == '%') {                 if (index + 2 < endOffset && isHexChar(s[index + 1]) &&                     isHexChar(s[index + 2])) {                   index += 3;                   haveChar = true;                   continue;                 }                 return -1;               }               if ((c >= 'a' && c <= 'z') || (c >= 'A' && c <= 'Z') ||              (c >= '0' && c <= '9') || c == '.' || c == '_' || c == '-' ||                 c == '~') {                 // unreserved character under RFC3986                 ++index;                 haveChar = true;                 continue;               }               return -1;             }             return -1;           }           return -1;         }         ++index;         return index;       }
Magic Number,PeterO.Cbor,URIUtility,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\URIUtility.cs,parseIPLiteral,The following statement contains a magic number: if (s[index] == ':' ||           isHexChar(s[index])) {         // IPv6 Address         var phase1 = 0;         var phase2 = 0;         var phased = false;         var expectHex = false;         var expectColon = false;         while (index < endOffset) {           char c = s[index];           if (c == ':' && !expectHex) {             if ((phase1 + (phased ? 1 : 0) + phase2) >= 8) {               return -1;             }             ++index;             if (index < endOffset && s[index] == ':') {               if (phased) {                 return -1;               }               phased = true;               ++index;             }             expectHex = true;             expectColon = false;             continue;           }           if ((c >= '0' && c <= '9') && !expectColon &&               (phased || (phase1 + (phased ? 1 : 0) + phase2) == 6)) {             // Check for IPv4 address             int decOctet = parseDecOctet(s' index' endOffset' c' '.');             if (decOctet >= 0) {               if ((phase1 + (phased ? 1 : 0) + phase2) > 6) {                 // IPv4 address illegal at this point                 return -1;               } else {                 // Parse the rest of the IPv4 address                 phase2 += 2;                 if (decOctet >= 100) {                   index += 4;                 } else if (decOctet >= 10) {                   index += 3;                 } else {                   index += 2;                 }                 char tmpc = (index < endOffset) ? s[index] : '\0';                 decOctet = parseDecOctet(   s'   index'   endOffset'   tmpc'   '.');                 if (decOctet >= 100) {                   index += 4;                 } else if (decOctet >= 10) {                   index += 3;                 } else if (decOctet >= 0) {                   index += 2;                 } else {                   return -1;                 }                 tmpc = (index < endOffset) ? s[index] : '\0';                 decOctet = parseDecOctet(s' index' endOffset' tmpc' '.');                 if (decOctet >= 100) {                   index += 4;                 } else if (decOctet >= 10) {                   index += 3;                 } else if (decOctet >= 0) {                   index += 2;                 } else {                   return -1;                 }                 tmpc = (index < endOffset) ? s[index] : '\0';                 decOctet = parseDecOctet(s' index' endOffset' tmpc' ']');                 if (decOctet < 0) {                   tmpc = (index < endOffset) ? s[index] : '\0';                   decOctet = parseDecOctet(s' index' endOffset' tmpc' '%');                 }                 if (decOctet >= 100) {                   index += 3;                 } else if (decOctet >= 10) {                   index += 2;                 } else if (decOctet >= 0) {                   ++index;                 } else {                   return -1;                 }                 break;               }             }           }           if (isHexChar(c) && !expectColon) {             if (phased) {               ++phase2;             } else {               ++phase1;             }             ++index;             for (var i = 0; i < 3; ++i) {               if (index < endOffset && isHexChar(s[index])) {                 ++index;               } else {                 break;               }             }             expectHex = false;             expectColon = true;           } else {             break;           }         }         if ((phase1 + phase2) != 8 && !phased) {           return -1;         }         if (phase1 + 1 + phase2 > 8 && phased) {           return -1;         }         if (index >= endOffset) {           return -1;         }         if (s[index] != ']' && s[index] != '%') {           return -1;         }         if (s[index] == '%') {           if (index + 2 < endOffset && s[index + 1] == '2' &&               s[index + 2] == '5') {             // Zone identifier in an IPv6 address             // (see RFC6874)             index += 3;             var haveChar = false;             while (index < endOffset) {               char c = s[index];               if (c == ']') {                 return haveChar ? index + 1 : -1;               }               if (c == '%') {                 if (index + 2 < endOffset && isHexChar(s[index + 1]) &&                     isHexChar(s[index + 2])) {                   index += 3;                   haveChar = true;                   continue;                 }                 return -1;               }               if ((c >= 'a' && c <= 'z') || (c >= 'A' && c <= 'Z') ||              (c >= '0' && c <= '9') || c == '.' || c == '_' || c == '-' ||                 c == '~') {                 // unreserved character under RFC3986                 ++index;                 haveChar = true;                 continue;               }               return -1;             }             return -1;           }           return -1;         }         ++index;         return index;       }
Magic Number,PeterO.Cbor,URIUtility,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\URIUtility.cs,parseIPLiteral,The following statement contains a magic number: if (s[index] == ':' ||           isHexChar(s[index])) {         // IPv6 Address         var phase1 = 0;         var phase2 = 0;         var phased = false;         var expectHex = false;         var expectColon = false;         while (index < endOffset) {           char c = s[index];           if (c == ':' && !expectHex) {             if ((phase1 + (phased ? 1 : 0) + phase2) >= 8) {               return -1;             }             ++index;             if (index < endOffset && s[index] == ':') {               if (phased) {                 return -1;               }               phased = true;               ++index;             }             expectHex = true;             expectColon = false;             continue;           }           if ((c >= '0' && c <= '9') && !expectColon &&               (phased || (phase1 + (phased ? 1 : 0) + phase2) == 6)) {             // Check for IPv4 address             int decOctet = parseDecOctet(s' index' endOffset' c' '.');             if (decOctet >= 0) {               if ((phase1 + (phased ? 1 : 0) + phase2) > 6) {                 // IPv4 address illegal at this point                 return -1;               } else {                 // Parse the rest of the IPv4 address                 phase2 += 2;                 if (decOctet >= 100) {                   index += 4;                 } else if (decOctet >= 10) {                   index += 3;                 } else {                   index += 2;                 }                 char tmpc = (index < endOffset) ? s[index] : '\0';                 decOctet = parseDecOctet(   s'   index'   endOffset'   tmpc'   '.');                 if (decOctet >= 100) {                   index += 4;                 } else if (decOctet >= 10) {                   index += 3;                 } else if (decOctet >= 0) {                   index += 2;                 } else {                   return -1;                 }                 tmpc = (index < endOffset) ? s[index] : '\0';                 decOctet = parseDecOctet(s' index' endOffset' tmpc' '.');                 if (decOctet >= 100) {                   index += 4;                 } else if (decOctet >= 10) {                   index += 3;                 } else if (decOctet >= 0) {                   index += 2;                 } else {                   return -1;                 }                 tmpc = (index < endOffset) ? s[index] : '\0';                 decOctet = parseDecOctet(s' index' endOffset' tmpc' ']');                 if (decOctet < 0) {                   tmpc = (index < endOffset) ? s[index] : '\0';                   decOctet = parseDecOctet(s' index' endOffset' tmpc' '%');                 }                 if (decOctet >= 100) {                   index += 3;                 } else if (decOctet >= 10) {                   index += 2;                 } else if (decOctet >= 0) {                   ++index;                 } else {                   return -1;                 }                 break;               }             }           }           if (isHexChar(c) && !expectColon) {             if (phased) {               ++phase2;             } else {               ++phase1;             }             ++index;             for (var i = 0; i < 3; ++i) {               if (index < endOffset && isHexChar(s[index])) {                 ++index;               } else {                 break;               }             }             expectHex = false;             expectColon = true;           } else {             break;           }         }         if ((phase1 + phase2) != 8 && !phased) {           return -1;         }         if (phase1 + 1 + phase2 > 8 && phased) {           return -1;         }         if (index >= endOffset) {           return -1;         }         if (s[index] != ']' && s[index] != '%') {           return -1;         }         if (s[index] == '%') {           if (index + 2 < endOffset && s[index + 1] == '2' &&               s[index + 2] == '5') {             // Zone identifier in an IPv6 address             // (see RFC6874)             index += 3;             var haveChar = false;             while (index < endOffset) {               char c = s[index];               if (c == ']') {                 return haveChar ? index + 1 : -1;               }               if (c == '%') {                 if (index + 2 < endOffset && isHexChar(s[index + 1]) &&                     isHexChar(s[index + 2])) {                   index += 3;                   haveChar = true;                   continue;                 }                 return -1;               }               if ((c >= 'a' && c <= 'z') || (c >= 'A' && c <= 'Z') ||              (c >= '0' && c <= '9') || c == '.' || c == '_' || c == '-' ||                 c == '~') {                 // unreserved character under RFC3986                 ++index;                 haveChar = true;                 continue;               }               return -1;             }             return -1;           }           return -1;         }         ++index;         return index;       }
Magic Number,PeterO.Cbor,URIUtility,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\URIUtility.cs,parseIPLiteral,The following statement contains a magic number: if (s[index] == ':' ||           isHexChar(s[index])) {         // IPv6 Address         var phase1 = 0;         var phase2 = 0;         var phased = false;         var expectHex = false;         var expectColon = false;         while (index < endOffset) {           char c = s[index];           if (c == ':' && !expectHex) {             if ((phase1 + (phased ? 1 : 0) + phase2) >= 8) {               return -1;             }             ++index;             if (index < endOffset && s[index] == ':') {               if (phased) {                 return -1;               }               phased = true;               ++index;             }             expectHex = true;             expectColon = false;             continue;           }           if ((c >= '0' && c <= '9') && !expectColon &&               (phased || (phase1 + (phased ? 1 : 0) + phase2) == 6)) {             // Check for IPv4 address             int decOctet = parseDecOctet(s' index' endOffset' c' '.');             if (decOctet >= 0) {               if ((phase1 + (phased ? 1 : 0) + phase2) > 6) {                 // IPv4 address illegal at this point                 return -1;               } else {                 // Parse the rest of the IPv4 address                 phase2 += 2;                 if (decOctet >= 100) {                   index += 4;                 } else if (decOctet >= 10) {                   index += 3;                 } else {                   index += 2;                 }                 char tmpc = (index < endOffset) ? s[index] : '\0';                 decOctet = parseDecOctet(   s'   index'   endOffset'   tmpc'   '.');                 if (decOctet >= 100) {                   index += 4;                 } else if (decOctet >= 10) {                   index += 3;                 } else if (decOctet >= 0) {                   index += 2;                 } else {                   return -1;                 }                 tmpc = (index < endOffset) ? s[index] : '\0';                 decOctet = parseDecOctet(s' index' endOffset' tmpc' '.');                 if (decOctet >= 100) {                   index += 4;                 } else if (decOctet >= 10) {                   index += 3;                 } else if (decOctet >= 0) {                   index += 2;                 } else {                   return -1;                 }                 tmpc = (index < endOffset) ? s[index] : '\0';                 decOctet = parseDecOctet(s' index' endOffset' tmpc' ']');                 if (decOctet < 0) {                   tmpc = (index < endOffset) ? s[index] : '\0';                   decOctet = parseDecOctet(s' index' endOffset' tmpc' '%');                 }                 if (decOctet >= 100) {                   index += 3;                 } else if (decOctet >= 10) {                   index += 2;                 } else if (decOctet >= 0) {                   ++index;                 } else {                   return -1;                 }                 break;               }             }           }           if (isHexChar(c) && !expectColon) {             if (phased) {               ++phase2;             } else {               ++phase1;             }             ++index;             for (var i = 0; i < 3; ++i) {               if (index < endOffset && isHexChar(s[index])) {                 ++index;               } else {                 break;               }             }             expectHex = false;             expectColon = true;           } else {             break;           }         }         if ((phase1 + phase2) != 8 && !phased) {           return -1;         }         if (phase1 + 1 + phase2 > 8 && phased) {           return -1;         }         if (index >= endOffset) {           return -1;         }         if (s[index] != ']' && s[index] != '%') {           return -1;         }         if (s[index] == '%') {           if (index + 2 < endOffset && s[index + 1] == '2' &&               s[index + 2] == '5') {             // Zone identifier in an IPv6 address             // (see RFC6874)             index += 3;             var haveChar = false;             while (index < endOffset) {               char c = s[index];               if (c == ']') {                 return haveChar ? index + 1 : -1;               }               if (c == '%') {                 if (index + 2 < endOffset && isHexChar(s[index + 1]) &&                     isHexChar(s[index + 2])) {                   index += 3;                   haveChar = true;                   continue;                 }                 return -1;               }               if ((c >= 'a' && c <= 'z') || (c >= 'A' && c <= 'Z') ||              (c >= '0' && c <= '9') || c == '.' || c == '_' || c == '-' ||                 c == '~') {                 // unreserved character under RFC3986                 ++index;                 haveChar = true;                 continue;               }               return -1;             }             return -1;           }           return -1;         }         ++index;         return index;       }
Magic Number,PeterO.Cbor,URIUtility,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\URIUtility.cs,parseIPLiteral,The following statement contains a magic number: if (s[index] == ':' ||           isHexChar(s[index])) {         // IPv6 Address         var phase1 = 0;         var phase2 = 0;         var phased = false;         var expectHex = false;         var expectColon = false;         while (index < endOffset) {           char c = s[index];           if (c == ':' && !expectHex) {             if ((phase1 + (phased ? 1 : 0) + phase2) >= 8) {               return -1;             }             ++index;             if (index < endOffset && s[index] == ':') {               if (phased) {                 return -1;               }               phased = true;               ++index;             }             expectHex = true;             expectColon = false;             continue;           }           if ((c >= '0' && c <= '9') && !expectColon &&               (phased || (phase1 + (phased ? 1 : 0) + phase2) == 6)) {             // Check for IPv4 address             int decOctet = parseDecOctet(s' index' endOffset' c' '.');             if (decOctet >= 0) {               if ((phase1 + (phased ? 1 : 0) + phase2) > 6) {                 // IPv4 address illegal at this point                 return -1;               } else {                 // Parse the rest of the IPv4 address                 phase2 += 2;                 if (decOctet >= 100) {                   index += 4;                 } else if (decOctet >= 10) {                   index += 3;                 } else {                   index += 2;                 }                 char tmpc = (index < endOffset) ? s[index] : '\0';                 decOctet = parseDecOctet(   s'   index'   endOffset'   tmpc'   '.');                 if (decOctet >= 100) {                   index += 4;                 } else if (decOctet >= 10) {                   index += 3;                 } else if (decOctet >= 0) {                   index += 2;                 } else {                   return -1;                 }                 tmpc = (index < endOffset) ? s[index] : '\0';                 decOctet = parseDecOctet(s' index' endOffset' tmpc' '.');                 if (decOctet >= 100) {                   index += 4;                 } else if (decOctet >= 10) {                   index += 3;                 } else if (decOctet >= 0) {                   index += 2;                 } else {                   return -1;                 }                 tmpc = (index < endOffset) ? s[index] : '\0';                 decOctet = parseDecOctet(s' index' endOffset' tmpc' ']');                 if (decOctet < 0) {                   tmpc = (index < endOffset) ? s[index] : '\0';                   decOctet = parseDecOctet(s' index' endOffset' tmpc' '%');                 }                 if (decOctet >= 100) {                   index += 3;                 } else if (decOctet >= 10) {                   index += 2;                 } else if (decOctet >= 0) {                   ++index;                 } else {                   return -1;                 }                 break;               }             }           }           if (isHexChar(c) && !expectColon) {             if (phased) {               ++phase2;             } else {               ++phase1;             }             ++index;             for (var i = 0; i < 3; ++i) {               if (index < endOffset && isHexChar(s[index])) {                 ++index;               } else {                 break;               }             }             expectHex = false;             expectColon = true;           } else {             break;           }         }         if ((phase1 + phase2) != 8 && !phased) {           return -1;         }         if (phase1 + 1 + phase2 > 8 && phased) {           return -1;         }         if (index >= endOffset) {           return -1;         }         if (s[index] != ']' && s[index] != '%') {           return -1;         }         if (s[index] == '%') {           if (index + 2 < endOffset && s[index + 1] == '2' &&               s[index + 2] == '5') {             // Zone identifier in an IPv6 address             // (see RFC6874)             index += 3;             var haveChar = false;             while (index < endOffset) {               char c = s[index];               if (c == ']') {                 return haveChar ? index + 1 : -1;               }               if (c == '%') {                 if (index + 2 < endOffset && isHexChar(s[index + 1]) &&                     isHexChar(s[index + 2])) {                   index += 3;                   haveChar = true;                   continue;                 }                 return -1;               }               if ((c >= 'a' && c <= 'z') || (c >= 'A' && c <= 'Z') ||              (c >= '0' && c <= '9') || c == '.' || c == '_' || c == '-' ||                 c == '~') {                 // unreserved character under RFC3986                 ++index;                 haveChar = true;                 continue;               }               return -1;             }             return -1;           }           return -1;         }         ++index;         return index;       }
Magic Number,PeterO.Cbor,URIUtility,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\URIUtility.cs,parseIPLiteral,The following statement contains a magic number: if (s[index] == ':' ||           isHexChar(s[index])) {         // IPv6 Address         var phase1 = 0;         var phase2 = 0;         var phased = false;         var expectHex = false;         var expectColon = false;         while (index < endOffset) {           char c = s[index];           if (c == ':' && !expectHex) {             if ((phase1 + (phased ? 1 : 0) + phase2) >= 8) {               return -1;             }             ++index;             if (index < endOffset && s[index] == ':') {               if (phased) {                 return -1;               }               phased = true;               ++index;             }             expectHex = true;             expectColon = false;             continue;           }           if ((c >= '0' && c <= '9') && !expectColon &&               (phased || (phase1 + (phased ? 1 : 0) + phase2) == 6)) {             // Check for IPv4 address             int decOctet = parseDecOctet(s' index' endOffset' c' '.');             if (decOctet >= 0) {               if ((phase1 + (phased ? 1 : 0) + phase2) > 6) {                 // IPv4 address illegal at this point                 return -1;               } else {                 // Parse the rest of the IPv4 address                 phase2 += 2;                 if (decOctet >= 100) {                   index += 4;                 } else if (decOctet >= 10) {                   index += 3;                 } else {                   index += 2;                 }                 char tmpc = (index < endOffset) ? s[index] : '\0';                 decOctet = parseDecOctet(   s'   index'   endOffset'   tmpc'   '.');                 if (decOctet >= 100) {                   index += 4;                 } else if (decOctet >= 10) {                   index += 3;                 } else if (decOctet >= 0) {                   index += 2;                 } else {                   return -1;                 }                 tmpc = (index < endOffset) ? s[index] : '\0';                 decOctet = parseDecOctet(s' index' endOffset' tmpc' '.');                 if (decOctet >= 100) {                   index += 4;                 } else if (decOctet >= 10) {                   index += 3;                 } else if (decOctet >= 0) {                   index += 2;                 } else {                   return -1;                 }                 tmpc = (index < endOffset) ? s[index] : '\0';                 decOctet = parseDecOctet(s' index' endOffset' tmpc' ']');                 if (decOctet < 0) {                   tmpc = (index < endOffset) ? s[index] : '\0';                   decOctet = parseDecOctet(s' index' endOffset' tmpc' '%');                 }                 if (decOctet >= 100) {                   index += 3;                 } else if (decOctet >= 10) {                   index += 2;                 } else if (decOctet >= 0) {                   ++index;                 } else {                   return -1;                 }                 break;               }             }           }           if (isHexChar(c) && !expectColon) {             if (phased) {               ++phase2;             } else {               ++phase1;             }             ++index;             for (var i = 0; i < 3; ++i) {               if (index < endOffset && isHexChar(s[index])) {                 ++index;               } else {                 break;               }             }             expectHex = false;             expectColon = true;           } else {             break;           }         }         if ((phase1 + phase2) != 8 && !phased) {           return -1;         }         if (phase1 + 1 + phase2 > 8 && phased) {           return -1;         }         if (index >= endOffset) {           return -1;         }         if (s[index] != ']' && s[index] != '%') {           return -1;         }         if (s[index] == '%') {           if (index + 2 < endOffset && s[index + 1] == '2' &&               s[index + 2] == '5') {             // Zone identifier in an IPv6 address             // (see RFC6874)             index += 3;             var haveChar = false;             while (index < endOffset) {               char c = s[index];               if (c == ']') {                 return haveChar ? index + 1 : -1;               }               if (c == '%') {                 if (index + 2 < endOffset && isHexChar(s[index + 1]) &&                     isHexChar(s[index + 2])) {                   index += 3;                   haveChar = true;                   continue;                 }                 return -1;               }               if ((c >= 'a' && c <= 'z') || (c >= 'A' && c <= 'Z') ||              (c >= '0' && c <= '9') || c == '.' || c == '_' || c == '-' ||                 c == '~') {                 // unreserved character under RFC3986                 ++index;                 haveChar = true;                 continue;               }               return -1;             }             return -1;           }           return -1;         }         ++index;         return index;       }
Magic Number,PeterO.Cbor,URIUtility,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\URIUtility.cs,parseIPLiteral,The following statement contains a magic number: if (s[index] == ':' ||           isHexChar(s[index])) {         // IPv6 Address         var phase1 = 0;         var phase2 = 0;         var phased = false;         var expectHex = false;         var expectColon = false;         while (index < endOffset) {           char c = s[index];           if (c == ':' && !expectHex) {             if ((phase1 + (phased ? 1 : 0) + phase2) >= 8) {               return -1;             }             ++index;             if (index < endOffset && s[index] == ':') {               if (phased) {                 return -1;               }               phased = true;               ++index;             }             expectHex = true;             expectColon = false;             continue;           }           if ((c >= '0' && c <= '9') && !expectColon &&               (phased || (phase1 + (phased ? 1 : 0) + phase2) == 6)) {             // Check for IPv4 address             int decOctet = parseDecOctet(s' index' endOffset' c' '.');             if (decOctet >= 0) {               if ((phase1 + (phased ? 1 : 0) + phase2) > 6) {                 // IPv4 address illegal at this point                 return -1;               } else {                 // Parse the rest of the IPv4 address                 phase2 += 2;                 if (decOctet >= 100) {                   index += 4;                 } else if (decOctet >= 10) {                   index += 3;                 } else {                   index += 2;                 }                 char tmpc = (index < endOffset) ? s[index] : '\0';                 decOctet = parseDecOctet(   s'   index'   endOffset'   tmpc'   '.');                 if (decOctet >= 100) {                   index += 4;                 } else if (decOctet >= 10) {                   index += 3;                 } else if (decOctet >= 0) {                   index += 2;                 } else {                   return -1;                 }                 tmpc = (index < endOffset) ? s[index] : '\0';                 decOctet = parseDecOctet(s' index' endOffset' tmpc' '.');                 if (decOctet >= 100) {                   index += 4;                 } else if (decOctet >= 10) {                   index += 3;                 } else if (decOctet >= 0) {                   index += 2;                 } else {                   return -1;                 }                 tmpc = (index < endOffset) ? s[index] : '\0';                 decOctet = parseDecOctet(s' index' endOffset' tmpc' ']');                 if (decOctet < 0) {                   tmpc = (index < endOffset) ? s[index] : '\0';                   decOctet = parseDecOctet(s' index' endOffset' tmpc' '%');                 }                 if (decOctet >= 100) {                   index += 3;                 } else if (decOctet >= 10) {                   index += 2;                 } else if (decOctet >= 0) {                   ++index;                 } else {                   return -1;                 }                 break;               }             }           }           if (isHexChar(c) && !expectColon) {             if (phased) {               ++phase2;             } else {               ++phase1;             }             ++index;             for (var i = 0; i < 3; ++i) {               if (index < endOffset && isHexChar(s[index])) {                 ++index;               } else {                 break;               }             }             expectHex = false;             expectColon = true;           } else {             break;           }         }         if ((phase1 + phase2) != 8 && !phased) {           return -1;         }         if (phase1 + 1 + phase2 > 8 && phased) {           return -1;         }         if (index >= endOffset) {           return -1;         }         if (s[index] != ']' && s[index] != '%') {           return -1;         }         if (s[index] == '%') {           if (index + 2 < endOffset && s[index + 1] == '2' &&               s[index + 2] == '5') {             // Zone identifier in an IPv6 address             // (see RFC6874)             index += 3;             var haveChar = false;             while (index < endOffset) {               char c = s[index];               if (c == ']') {                 return haveChar ? index + 1 : -1;               }               if (c == '%') {                 if (index + 2 < endOffset && isHexChar(s[index + 1]) &&                     isHexChar(s[index + 2])) {                   index += 3;                   haveChar = true;                   continue;                 }                 return -1;               }               if ((c >= 'a' && c <= 'z') || (c >= 'A' && c <= 'Z') ||              (c >= '0' && c <= '9') || c == '.' || c == '_' || c == '-' ||                 c == '~') {                 // unreserved character under RFC3986                 ++index;                 haveChar = true;                 continue;               }               return -1;             }             return -1;           }           return -1;         }         ++index;         return index;       }
Magic Number,PeterO.Cbor,URIUtility,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\URIUtility.cs,parseIPLiteral,The following statement contains a magic number: if (s[index] == ':' ||           isHexChar(s[index])) {         // IPv6 Address         var phase1 = 0;         var phase2 = 0;         var phased = false;         var expectHex = false;         var expectColon = false;         while (index < endOffset) {           char c = s[index];           if (c == ':' && !expectHex) {             if ((phase1 + (phased ? 1 : 0) + phase2) >= 8) {               return -1;             }             ++index;             if (index < endOffset && s[index] == ':') {               if (phased) {                 return -1;               }               phased = true;               ++index;             }             expectHex = true;             expectColon = false;             continue;           }           if ((c >= '0' && c <= '9') && !expectColon &&               (phased || (phase1 + (phased ? 1 : 0) + phase2) == 6)) {             // Check for IPv4 address             int decOctet = parseDecOctet(s' index' endOffset' c' '.');             if (decOctet >= 0) {               if ((phase1 + (phased ? 1 : 0) + phase2) > 6) {                 // IPv4 address illegal at this point                 return -1;               } else {                 // Parse the rest of the IPv4 address                 phase2 += 2;                 if (decOctet >= 100) {                   index += 4;                 } else if (decOctet >= 10) {                   index += 3;                 } else {                   index += 2;                 }                 char tmpc = (index < endOffset) ? s[index] : '\0';                 decOctet = parseDecOctet(   s'   index'   endOffset'   tmpc'   '.');                 if (decOctet >= 100) {                   index += 4;                 } else if (decOctet >= 10) {                   index += 3;                 } else if (decOctet >= 0) {                   index += 2;                 } else {                   return -1;                 }                 tmpc = (index < endOffset) ? s[index] : '\0';                 decOctet = parseDecOctet(s' index' endOffset' tmpc' '.');                 if (decOctet >= 100) {                   index += 4;                 } else if (decOctet >= 10) {                   index += 3;                 } else if (decOctet >= 0) {                   index += 2;                 } else {                   return -1;                 }                 tmpc = (index < endOffset) ? s[index] : '\0';                 decOctet = parseDecOctet(s' index' endOffset' tmpc' ']');                 if (decOctet < 0) {                   tmpc = (index < endOffset) ? s[index] : '\0';                   decOctet = parseDecOctet(s' index' endOffset' tmpc' '%');                 }                 if (decOctet >= 100) {                   index += 3;                 } else if (decOctet >= 10) {                   index += 2;                 } else if (decOctet >= 0) {                   ++index;                 } else {                   return -1;                 }                 break;               }             }           }           if (isHexChar(c) && !expectColon) {             if (phased) {               ++phase2;             } else {               ++phase1;             }             ++index;             for (var i = 0; i < 3; ++i) {               if (index < endOffset && isHexChar(s[index])) {                 ++index;               } else {                 break;               }             }             expectHex = false;             expectColon = true;           } else {             break;           }         }         if ((phase1 + phase2) != 8 && !phased) {           return -1;         }         if (phase1 + 1 + phase2 > 8 && phased) {           return -1;         }         if (index >= endOffset) {           return -1;         }         if (s[index] != ']' && s[index] != '%') {           return -1;         }         if (s[index] == '%') {           if (index + 2 < endOffset && s[index + 1] == '2' &&               s[index + 2] == '5') {             // Zone identifier in an IPv6 address             // (see RFC6874)             index += 3;             var haveChar = false;             while (index < endOffset) {               char c = s[index];               if (c == ']') {                 return haveChar ? index + 1 : -1;               }               if (c == '%') {                 if (index + 2 < endOffset && isHexChar(s[index + 1]) &&                     isHexChar(s[index + 2])) {                   index += 3;                   haveChar = true;                   continue;                 }                 return -1;               }               if ((c >= 'a' && c <= 'z') || (c >= 'A' && c <= 'Z') ||              (c >= '0' && c <= '9') || c == '.' || c == '_' || c == '-' ||                 c == '~') {                 // unreserved character under RFC3986                 ++index;                 haveChar = true;                 continue;               }               return -1;             }             return -1;           }           return -1;         }         ++index;         return index;       }
Magic Number,PeterO.Cbor,URIUtility,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\URIUtility.cs,parseIPLiteral,The following statement contains a magic number: if (s[index] == ':' ||           isHexChar(s[index])) {         // IPv6 Address         var phase1 = 0;         var phase2 = 0;         var phased = false;         var expectHex = false;         var expectColon = false;         while (index < endOffset) {           char c = s[index];           if (c == ':' && !expectHex) {             if ((phase1 + (phased ? 1 : 0) + phase2) >= 8) {               return -1;             }             ++index;             if (index < endOffset && s[index] == ':') {               if (phased) {                 return -1;               }               phased = true;               ++index;             }             expectHex = true;             expectColon = false;             continue;           }           if ((c >= '0' && c <= '9') && !expectColon &&               (phased || (phase1 + (phased ? 1 : 0) + phase2) == 6)) {             // Check for IPv4 address             int decOctet = parseDecOctet(s' index' endOffset' c' '.');             if (decOctet >= 0) {               if ((phase1 + (phased ? 1 : 0) + phase2) > 6) {                 // IPv4 address illegal at this point                 return -1;               } else {                 // Parse the rest of the IPv4 address                 phase2 += 2;                 if (decOctet >= 100) {                   index += 4;                 } else if (decOctet >= 10) {                   index += 3;                 } else {                   index += 2;                 }                 char tmpc = (index < endOffset) ? s[index] : '\0';                 decOctet = parseDecOctet(   s'   index'   endOffset'   tmpc'   '.');                 if (decOctet >= 100) {                   index += 4;                 } else if (decOctet >= 10) {                   index += 3;                 } else if (decOctet >= 0) {                   index += 2;                 } else {                   return -1;                 }                 tmpc = (index < endOffset) ? s[index] : '\0';                 decOctet = parseDecOctet(s' index' endOffset' tmpc' '.');                 if (decOctet >= 100) {                   index += 4;                 } else if (decOctet >= 10) {                   index += 3;                 } else if (decOctet >= 0) {                   index += 2;                 } else {                   return -1;                 }                 tmpc = (index < endOffset) ? s[index] : '\0';                 decOctet = parseDecOctet(s' index' endOffset' tmpc' ']');                 if (decOctet < 0) {                   tmpc = (index < endOffset) ? s[index] : '\0';                   decOctet = parseDecOctet(s' index' endOffset' tmpc' '%');                 }                 if (decOctet >= 100) {                   index += 3;                 } else if (decOctet >= 10) {                   index += 2;                 } else if (decOctet >= 0) {                   ++index;                 } else {                   return -1;                 }                 break;               }             }           }           if (isHexChar(c) && !expectColon) {             if (phased) {               ++phase2;             } else {               ++phase1;             }             ++index;             for (var i = 0; i < 3; ++i) {               if (index < endOffset && isHexChar(s[index])) {                 ++index;               } else {                 break;               }             }             expectHex = false;             expectColon = true;           } else {             break;           }         }         if ((phase1 + phase2) != 8 && !phased) {           return -1;         }         if (phase1 + 1 + phase2 > 8 && phased) {           return -1;         }         if (index >= endOffset) {           return -1;         }         if (s[index] != ']' && s[index] != '%') {           return -1;         }         if (s[index] == '%') {           if (index + 2 < endOffset && s[index + 1] == '2' &&               s[index + 2] == '5') {             // Zone identifier in an IPv6 address             // (see RFC6874)             index += 3;             var haveChar = false;             while (index < endOffset) {               char c = s[index];               if (c == ']') {                 return haveChar ? index + 1 : -1;               }               if (c == '%') {                 if (index + 2 < endOffset && isHexChar(s[index + 1]) &&                     isHexChar(s[index + 2])) {                   index += 3;                   haveChar = true;                   continue;                 }                 return -1;               }               if ((c >= 'a' && c <= 'z') || (c >= 'A' && c <= 'Z') ||              (c >= '0' && c <= '9') || c == '.' || c == '_' || c == '-' ||                 c == '~') {                 // unreserved character under RFC3986                 ++index;                 haveChar = true;                 continue;               }               return -1;             }             return -1;           }           return -1;         }         ++index;         return index;       }
Magic Number,PeterO.Cbor,URIUtility,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\URIUtility.cs,parseIPLiteral,The following statement contains a magic number: if (s[index] == ':' ||           isHexChar(s[index])) {         // IPv6 Address         var phase1 = 0;         var phase2 = 0;         var phased = false;         var expectHex = false;         var expectColon = false;         while (index < endOffset) {           char c = s[index];           if (c == ':' && !expectHex) {             if ((phase1 + (phased ? 1 : 0) + phase2) >= 8) {               return -1;             }             ++index;             if (index < endOffset && s[index] == ':') {               if (phased) {                 return -1;               }               phased = true;               ++index;             }             expectHex = true;             expectColon = false;             continue;           }           if ((c >= '0' && c <= '9') && !expectColon &&               (phased || (phase1 + (phased ? 1 : 0) + phase2) == 6)) {             // Check for IPv4 address             int decOctet = parseDecOctet(s' index' endOffset' c' '.');             if (decOctet >= 0) {               if ((phase1 + (phased ? 1 : 0) + phase2) > 6) {                 // IPv4 address illegal at this point                 return -1;               } else {                 // Parse the rest of the IPv4 address                 phase2 += 2;                 if (decOctet >= 100) {                   index += 4;                 } else if (decOctet >= 10) {                   index += 3;                 } else {                   index += 2;                 }                 char tmpc = (index < endOffset) ? s[index] : '\0';                 decOctet = parseDecOctet(   s'   index'   endOffset'   tmpc'   '.');                 if (decOctet >= 100) {                   index += 4;                 } else if (decOctet >= 10) {                   index += 3;                 } else if (decOctet >= 0) {                   index += 2;                 } else {                   return -1;                 }                 tmpc = (index < endOffset) ? s[index] : '\0';                 decOctet = parseDecOctet(s' index' endOffset' tmpc' '.');                 if (decOctet >= 100) {                   index += 4;                 } else if (decOctet >= 10) {                   index += 3;                 } else if (decOctet >= 0) {                   index += 2;                 } else {                   return -1;                 }                 tmpc = (index < endOffset) ? s[index] : '\0';                 decOctet = parseDecOctet(s' index' endOffset' tmpc' ']');                 if (decOctet < 0) {                   tmpc = (index < endOffset) ? s[index] : '\0';                   decOctet = parseDecOctet(s' index' endOffset' tmpc' '%');                 }                 if (decOctet >= 100) {                   index += 3;                 } else if (decOctet >= 10) {                   index += 2;                 } else if (decOctet >= 0) {                   ++index;                 } else {                   return -1;                 }                 break;               }             }           }           if (isHexChar(c) && !expectColon) {             if (phased) {               ++phase2;             } else {               ++phase1;             }             ++index;             for (var i = 0; i < 3; ++i) {               if (index < endOffset && isHexChar(s[index])) {                 ++index;               } else {                 break;               }             }             expectHex = false;             expectColon = true;           } else {             break;           }         }         if ((phase1 + phase2) != 8 && !phased) {           return -1;         }         if (phase1 + 1 + phase2 > 8 && phased) {           return -1;         }         if (index >= endOffset) {           return -1;         }         if (s[index] != ']' && s[index] != '%') {           return -1;         }         if (s[index] == '%') {           if (index + 2 < endOffset && s[index + 1] == '2' &&               s[index + 2] == '5') {             // Zone identifier in an IPv6 address             // (see RFC6874)             index += 3;             var haveChar = false;             while (index < endOffset) {               char c = s[index];               if (c == ']') {                 return haveChar ? index + 1 : -1;               }               if (c == '%') {                 if (index + 2 < endOffset && isHexChar(s[index + 1]) &&                     isHexChar(s[index + 2])) {                   index += 3;                   haveChar = true;                   continue;                 }                 return -1;               }               if ((c >= 'a' && c <= 'z') || (c >= 'A' && c <= 'Z') ||              (c >= '0' && c <= '9') || c == '.' || c == '_' || c == '-' ||                 c == '~') {                 // unreserved character under RFC3986                 ++index;                 haveChar = true;                 continue;               }               return -1;             }             return -1;           }           return -1;         }         ++index;         return index;       }
Magic Number,PeterO.Cbor,URIUtility,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\URIUtility.cs,parseIPLiteral,The following statement contains a magic number: if (s[index] == ':' ||           isHexChar(s[index])) {         // IPv6 Address         var phase1 = 0;         var phase2 = 0;         var phased = false;         var expectHex = false;         var expectColon = false;         while (index < endOffset) {           char c = s[index];           if (c == ':' && !expectHex) {             if ((phase1 + (phased ? 1 : 0) + phase2) >= 8) {               return -1;             }             ++index;             if (index < endOffset && s[index] == ':') {               if (phased) {                 return -1;               }               phased = true;               ++index;             }             expectHex = true;             expectColon = false;             continue;           }           if ((c >= '0' && c <= '9') && !expectColon &&               (phased || (phase1 + (phased ? 1 : 0) + phase2) == 6)) {             // Check for IPv4 address             int decOctet = parseDecOctet(s' index' endOffset' c' '.');             if (decOctet >= 0) {               if ((phase1 + (phased ? 1 : 0) + phase2) > 6) {                 // IPv4 address illegal at this point                 return -1;               } else {                 // Parse the rest of the IPv4 address                 phase2 += 2;                 if (decOctet >= 100) {                   index += 4;                 } else if (decOctet >= 10) {                   index += 3;                 } else {                   index += 2;                 }                 char tmpc = (index < endOffset) ? s[index] : '\0';                 decOctet = parseDecOctet(   s'   index'   endOffset'   tmpc'   '.');                 if (decOctet >= 100) {                   index += 4;                 } else if (decOctet >= 10) {                   index += 3;                 } else if (decOctet >= 0) {                   index += 2;                 } else {                   return -1;                 }                 tmpc = (index < endOffset) ? s[index] : '\0';                 decOctet = parseDecOctet(s' index' endOffset' tmpc' '.');                 if (decOctet >= 100) {                   index += 4;                 } else if (decOctet >= 10) {                   index += 3;                 } else if (decOctet >= 0) {                   index += 2;                 } else {                   return -1;                 }                 tmpc = (index < endOffset) ? s[index] : '\0';                 decOctet = parseDecOctet(s' index' endOffset' tmpc' ']');                 if (decOctet < 0) {                   tmpc = (index < endOffset) ? s[index] : '\0';                   decOctet = parseDecOctet(s' index' endOffset' tmpc' '%');                 }                 if (decOctet >= 100) {                   index += 3;                 } else if (decOctet >= 10) {                   index += 2;                 } else if (decOctet >= 0) {                   ++index;                 } else {                   return -1;                 }                 break;               }             }           }           if (isHexChar(c) && !expectColon) {             if (phased) {               ++phase2;             } else {               ++phase1;             }             ++index;             for (var i = 0; i < 3; ++i) {               if (index < endOffset && isHexChar(s[index])) {                 ++index;               } else {                 break;               }             }             expectHex = false;             expectColon = true;           } else {             break;           }         }         if ((phase1 + phase2) != 8 && !phased) {           return -1;         }         if (phase1 + 1 + phase2 > 8 && phased) {           return -1;         }         if (index >= endOffset) {           return -1;         }         if (s[index] != ']' && s[index] != '%') {           return -1;         }         if (s[index] == '%') {           if (index + 2 < endOffset && s[index + 1] == '2' &&               s[index + 2] == '5') {             // Zone identifier in an IPv6 address             // (see RFC6874)             index += 3;             var haveChar = false;             while (index < endOffset) {               char c = s[index];               if (c == ']') {                 return haveChar ? index + 1 : -1;               }               if (c == '%') {                 if (index + 2 < endOffset && isHexChar(s[index + 1]) &&                     isHexChar(s[index + 2])) {                   index += 3;                   haveChar = true;                   continue;                 }                 return -1;               }               if ((c >= 'a' && c <= 'z') || (c >= 'A' && c <= 'Z') ||              (c >= '0' && c <= '9') || c == '.' || c == '_' || c == '-' ||                 c == '~') {                 // unreserved character under RFC3986                 ++index;                 haveChar = true;                 continue;               }               return -1;             }             return -1;           }           return -1;         }         ++index;         return index;       }
Magic Number,PeterO.Cbor,URIUtility,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\URIUtility.cs,parseIPLiteral,The following statement contains a magic number: if (s[index] == ':' ||           isHexChar(s[index])) {         // IPv6 Address         var phase1 = 0;         var phase2 = 0;         var phased = false;         var expectHex = false;         var expectColon = false;         while (index < endOffset) {           char c = s[index];           if (c == ':' && !expectHex) {             if ((phase1 + (phased ? 1 : 0) + phase2) >= 8) {               return -1;             }             ++index;             if (index < endOffset && s[index] == ':') {               if (phased) {                 return -1;               }               phased = true;               ++index;             }             expectHex = true;             expectColon = false;             continue;           }           if ((c >= '0' && c <= '9') && !expectColon &&               (phased || (phase1 + (phased ? 1 : 0) + phase2) == 6)) {             // Check for IPv4 address             int decOctet = parseDecOctet(s' index' endOffset' c' '.');             if (decOctet >= 0) {               if ((phase1 + (phased ? 1 : 0) + phase2) > 6) {                 // IPv4 address illegal at this point                 return -1;               } else {                 // Parse the rest of the IPv4 address                 phase2 += 2;                 if (decOctet >= 100) {                   index += 4;                 } else if (decOctet >= 10) {                   index += 3;                 } else {                   index += 2;                 }                 char tmpc = (index < endOffset) ? s[index] : '\0';                 decOctet = parseDecOctet(   s'   index'   endOffset'   tmpc'   '.');                 if (decOctet >= 100) {                   index += 4;                 } else if (decOctet >= 10) {                   index += 3;                 } else if (decOctet >= 0) {                   index += 2;                 } else {                   return -1;                 }                 tmpc = (index < endOffset) ? s[index] : '\0';                 decOctet = parseDecOctet(s' index' endOffset' tmpc' '.');                 if (decOctet >= 100) {                   index += 4;                 } else if (decOctet >= 10) {                   index += 3;                 } else if (decOctet >= 0) {                   index += 2;                 } else {                   return -1;                 }                 tmpc = (index < endOffset) ? s[index] : '\0';                 decOctet = parseDecOctet(s' index' endOffset' tmpc' ']');                 if (decOctet < 0) {                   tmpc = (index < endOffset) ? s[index] : '\0';                   decOctet = parseDecOctet(s' index' endOffset' tmpc' '%');                 }                 if (decOctet >= 100) {                   index += 3;                 } else if (decOctet >= 10) {                   index += 2;                 } else if (decOctet >= 0) {                   ++index;                 } else {                   return -1;                 }                 break;               }             }           }           if (isHexChar(c) && !expectColon) {             if (phased) {               ++phase2;             } else {               ++phase1;             }             ++index;             for (var i = 0; i < 3; ++i) {               if (index < endOffset && isHexChar(s[index])) {                 ++index;               } else {                 break;               }             }             expectHex = false;             expectColon = true;           } else {             break;           }         }         if ((phase1 + phase2) != 8 && !phased) {           return -1;         }         if (phase1 + 1 + phase2 > 8 && phased) {           return -1;         }         if (index >= endOffset) {           return -1;         }         if (s[index] != ']' && s[index] != '%') {           return -1;         }         if (s[index] == '%') {           if (index + 2 < endOffset && s[index + 1] == '2' &&               s[index + 2] == '5') {             // Zone identifier in an IPv6 address             // (see RFC6874)             index += 3;             var haveChar = false;             while (index < endOffset) {               char c = s[index];               if (c == ']') {                 return haveChar ? index + 1 : -1;               }               if (c == '%') {                 if (index + 2 < endOffset && isHexChar(s[index + 1]) &&                     isHexChar(s[index + 2])) {                   index += 3;                   haveChar = true;                   continue;                 }                 return -1;               }               if ((c >= 'a' && c <= 'z') || (c >= 'A' && c <= 'Z') ||              (c >= '0' && c <= '9') || c == '.' || c == '_' || c == '-' ||                 c == '~') {                 // unreserved character under RFC3986                 ++index;                 haveChar = true;                 continue;               }               return -1;             }             return -1;           }           return -1;         }         ++index;         return index;       }
Magic Number,PeterO.Cbor,URIUtility,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\URIUtility.cs,parseIPLiteral,The following statement contains a magic number: if (s[index] == ':' ||           isHexChar(s[index])) {         // IPv6 Address         var phase1 = 0;         var phase2 = 0;         var phased = false;         var expectHex = false;         var expectColon = false;         while (index < endOffset) {           char c = s[index];           if (c == ':' && !expectHex) {             if ((phase1 + (phased ? 1 : 0) + phase2) >= 8) {               return -1;             }             ++index;             if (index < endOffset && s[index] == ':') {               if (phased) {                 return -1;               }               phased = true;               ++index;             }             expectHex = true;             expectColon = false;             continue;           }           if ((c >= '0' && c <= '9') && !expectColon &&               (phased || (phase1 + (phased ? 1 : 0) + phase2) == 6)) {             // Check for IPv4 address             int decOctet = parseDecOctet(s' index' endOffset' c' '.');             if (decOctet >= 0) {               if ((phase1 + (phased ? 1 : 0) + phase2) > 6) {                 // IPv4 address illegal at this point                 return -1;               } else {                 // Parse the rest of the IPv4 address                 phase2 += 2;                 if (decOctet >= 100) {                   index += 4;                 } else if (decOctet >= 10) {                   index += 3;                 } else {                   index += 2;                 }                 char tmpc = (index < endOffset) ? s[index] : '\0';                 decOctet = parseDecOctet(   s'   index'   endOffset'   tmpc'   '.');                 if (decOctet >= 100) {                   index += 4;                 } else if (decOctet >= 10) {                   index += 3;                 } else if (decOctet >= 0) {                   index += 2;                 } else {                   return -1;                 }                 tmpc = (index < endOffset) ? s[index] : '\0';                 decOctet = parseDecOctet(s' index' endOffset' tmpc' '.');                 if (decOctet >= 100) {                   index += 4;                 } else if (decOctet >= 10) {                   index += 3;                 } else if (decOctet >= 0) {                   index += 2;                 } else {                   return -1;                 }                 tmpc = (index < endOffset) ? s[index] : '\0';                 decOctet = parseDecOctet(s' index' endOffset' tmpc' ']');                 if (decOctet < 0) {                   tmpc = (index < endOffset) ? s[index] : '\0';                   decOctet = parseDecOctet(s' index' endOffset' tmpc' '%');                 }                 if (decOctet >= 100) {                   index += 3;                 } else if (decOctet >= 10) {                   index += 2;                 } else if (decOctet >= 0) {                   ++index;                 } else {                   return -1;                 }                 break;               }             }           }           if (isHexChar(c) && !expectColon) {             if (phased) {               ++phase2;             } else {               ++phase1;             }             ++index;             for (var i = 0; i < 3; ++i) {               if (index < endOffset && isHexChar(s[index])) {                 ++index;               } else {                 break;               }             }             expectHex = false;             expectColon = true;           } else {             break;           }         }         if ((phase1 + phase2) != 8 && !phased) {           return -1;         }         if (phase1 + 1 + phase2 > 8 && phased) {           return -1;         }         if (index >= endOffset) {           return -1;         }         if (s[index] != ']' && s[index] != '%') {           return -1;         }         if (s[index] == '%') {           if (index + 2 < endOffset && s[index + 1] == '2' &&               s[index + 2] == '5') {             // Zone identifier in an IPv6 address             // (see RFC6874)             index += 3;             var haveChar = false;             while (index < endOffset) {               char c = s[index];               if (c == ']') {                 return haveChar ? index + 1 : -1;               }               if (c == '%') {                 if (index + 2 < endOffset && isHexChar(s[index + 1]) &&                     isHexChar(s[index + 2])) {                   index += 3;                   haveChar = true;                   continue;                 }                 return -1;               }               if ((c >= 'a' && c <= 'z') || (c >= 'A' && c <= 'Z') ||              (c >= '0' && c <= '9') || c == '.' || c == '_' || c == '-' ||                 c == '~') {                 // unreserved character under RFC3986                 ++index;                 haveChar = true;                 continue;               }               return -1;             }             return -1;           }           return -1;         }         ++index;         return index;       }
Magic Number,PeterO.Cbor,URIUtility,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\URIUtility.cs,parseIPLiteral,The following statement contains a magic number: if (s[index] == ':' ||           isHexChar(s[index])) {         // IPv6 Address         var phase1 = 0;         var phase2 = 0;         var phased = false;         var expectHex = false;         var expectColon = false;         while (index < endOffset) {           char c = s[index];           if (c == ':' && !expectHex) {             if ((phase1 + (phased ? 1 : 0) + phase2) >= 8) {               return -1;             }             ++index;             if (index < endOffset && s[index] == ':') {               if (phased) {                 return -1;               }               phased = true;               ++index;             }             expectHex = true;             expectColon = false;             continue;           }           if ((c >= '0' && c <= '9') && !expectColon &&               (phased || (phase1 + (phased ? 1 : 0) + phase2) == 6)) {             // Check for IPv4 address             int decOctet = parseDecOctet(s' index' endOffset' c' '.');             if (decOctet >= 0) {               if ((phase1 + (phased ? 1 : 0) + phase2) > 6) {                 // IPv4 address illegal at this point                 return -1;               } else {                 // Parse the rest of the IPv4 address                 phase2 += 2;                 if (decOctet >= 100) {                   index += 4;                 } else if (decOctet >= 10) {                   index += 3;                 } else {                   index += 2;                 }                 char tmpc = (index < endOffset) ? s[index] : '\0';                 decOctet = parseDecOctet(   s'   index'   endOffset'   tmpc'   '.');                 if (decOctet >= 100) {                   index += 4;                 } else if (decOctet >= 10) {                   index += 3;                 } else if (decOctet >= 0) {                   index += 2;                 } else {                   return -1;                 }                 tmpc = (index < endOffset) ? s[index] : '\0';                 decOctet = parseDecOctet(s' index' endOffset' tmpc' '.');                 if (decOctet >= 100) {                   index += 4;                 } else if (decOctet >= 10) {                   index += 3;                 } else if (decOctet >= 0) {                   index += 2;                 } else {                   return -1;                 }                 tmpc = (index < endOffset) ? s[index] : '\0';                 decOctet = parseDecOctet(s' index' endOffset' tmpc' ']');                 if (decOctet < 0) {                   tmpc = (index < endOffset) ? s[index] : '\0';                   decOctet = parseDecOctet(s' index' endOffset' tmpc' '%');                 }                 if (decOctet >= 100) {                   index += 3;                 } else if (decOctet >= 10) {                   index += 2;                 } else if (decOctet >= 0) {                   ++index;                 } else {                   return -1;                 }                 break;               }             }           }           if (isHexChar(c) && !expectColon) {             if (phased) {               ++phase2;             } else {               ++phase1;             }             ++index;             for (var i = 0; i < 3; ++i) {               if (index < endOffset && isHexChar(s[index])) {                 ++index;               } else {                 break;               }             }             expectHex = false;             expectColon = true;           } else {             break;           }         }         if ((phase1 + phase2) != 8 && !phased) {           return -1;         }         if (phase1 + 1 + phase2 > 8 && phased) {           return -1;         }         if (index >= endOffset) {           return -1;         }         if (s[index] != ']' && s[index] != '%') {           return -1;         }         if (s[index] == '%') {           if (index + 2 < endOffset && s[index + 1] == '2' &&               s[index + 2] == '5') {             // Zone identifier in an IPv6 address             // (see RFC6874)             index += 3;             var haveChar = false;             while (index < endOffset) {               char c = s[index];               if (c == ']') {                 return haveChar ? index + 1 : -1;               }               if (c == '%') {                 if (index + 2 < endOffset && isHexChar(s[index + 1]) &&                     isHexChar(s[index + 2])) {                   index += 3;                   haveChar = true;                   continue;                 }                 return -1;               }               if ((c >= 'a' && c <= 'z') || (c >= 'A' && c <= 'Z') ||              (c >= '0' && c <= '9') || c == '.' || c == '_' || c == '-' ||                 c == '~') {                 // unreserved character under RFC3986                 ++index;                 haveChar = true;                 continue;               }               return -1;             }             return -1;           }           return -1;         }         ++index;         return index;       }
Magic Number,PeterO.Cbor,URIUtility,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\URIUtility.cs,parseIPLiteral,The following statement contains a magic number: if (s[index] == ':' ||           isHexChar(s[index])) {         // IPv6 Address         var phase1 = 0;         var phase2 = 0;         var phased = false;         var expectHex = false;         var expectColon = false;         while (index < endOffset) {           char c = s[index];           if (c == ':' && !expectHex) {             if ((phase1 + (phased ? 1 : 0) + phase2) >= 8) {               return -1;             }             ++index;             if (index < endOffset && s[index] == ':') {               if (phased) {                 return -1;               }               phased = true;               ++index;             }             expectHex = true;             expectColon = false;             continue;           }           if ((c >= '0' && c <= '9') && !expectColon &&               (phased || (phase1 + (phased ? 1 : 0) + phase2) == 6)) {             // Check for IPv4 address             int decOctet = parseDecOctet(s' index' endOffset' c' '.');             if (decOctet >= 0) {               if ((phase1 + (phased ? 1 : 0) + phase2) > 6) {                 // IPv4 address illegal at this point                 return -1;               } else {                 // Parse the rest of the IPv4 address                 phase2 += 2;                 if (decOctet >= 100) {                   index += 4;                 } else if (decOctet >= 10) {                   index += 3;                 } else {                   index += 2;                 }                 char tmpc = (index < endOffset) ? s[index] : '\0';                 decOctet = parseDecOctet(   s'   index'   endOffset'   tmpc'   '.');                 if (decOctet >= 100) {                   index += 4;                 } else if (decOctet >= 10) {                   index += 3;                 } else if (decOctet >= 0) {                   index += 2;                 } else {                   return -1;                 }                 tmpc = (index < endOffset) ? s[index] : '\0';                 decOctet = parseDecOctet(s' index' endOffset' tmpc' '.');                 if (decOctet >= 100) {                   index += 4;                 } else if (decOctet >= 10) {                   index += 3;                 } else if (decOctet >= 0) {                   index += 2;                 } else {                   return -1;                 }                 tmpc = (index < endOffset) ? s[index] : '\0';                 decOctet = parseDecOctet(s' index' endOffset' tmpc' ']');                 if (decOctet < 0) {                   tmpc = (index < endOffset) ? s[index] : '\0';                   decOctet = parseDecOctet(s' index' endOffset' tmpc' '%');                 }                 if (decOctet >= 100) {                   index += 3;                 } else if (decOctet >= 10) {                   index += 2;                 } else if (decOctet >= 0) {                   ++index;                 } else {                   return -1;                 }                 break;               }             }           }           if (isHexChar(c) && !expectColon) {             if (phased) {               ++phase2;             } else {               ++phase1;             }             ++index;             for (var i = 0; i < 3; ++i) {               if (index < endOffset && isHexChar(s[index])) {                 ++index;               } else {                 break;               }             }             expectHex = false;             expectColon = true;           } else {             break;           }         }         if ((phase1 + phase2) != 8 && !phased) {           return -1;         }         if (phase1 + 1 + phase2 > 8 && phased) {           return -1;         }         if (index >= endOffset) {           return -1;         }         if (s[index] != ']' && s[index] != '%') {           return -1;         }         if (s[index] == '%') {           if (index + 2 < endOffset && s[index + 1] == '2' &&               s[index + 2] == '5') {             // Zone identifier in an IPv6 address             // (see RFC6874)             index += 3;             var haveChar = false;             while (index < endOffset) {               char c = s[index];               if (c == ']') {                 return haveChar ? index + 1 : -1;               }               if (c == '%') {                 if (index + 2 < endOffset && isHexChar(s[index + 1]) &&                     isHexChar(s[index + 2])) {                   index += 3;                   haveChar = true;                   continue;                 }                 return -1;               }               if ((c >= 'a' && c <= 'z') || (c >= 'A' && c <= 'Z') ||              (c >= '0' && c <= '9') || c == '.' || c == '_' || c == '-' ||                 c == '~') {                 // unreserved character under RFC3986                 ++index;                 haveChar = true;                 continue;               }               return -1;             }             return -1;           }           return -1;         }         ++index;         return index;       }
Magic Number,PeterO.Cbor,URIUtility,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\URIUtility.cs,parseIPLiteral,The following statement contains a magic number: if (s[index] == ':' ||           isHexChar(s[index])) {         // IPv6 Address         var phase1 = 0;         var phase2 = 0;         var phased = false;         var expectHex = false;         var expectColon = false;         while (index < endOffset) {           char c = s[index];           if (c == ':' && !expectHex) {             if ((phase1 + (phased ? 1 : 0) + phase2) >= 8) {               return -1;             }             ++index;             if (index < endOffset && s[index] == ':') {               if (phased) {                 return -1;               }               phased = true;               ++index;             }             expectHex = true;             expectColon = false;             continue;           }           if ((c >= '0' && c <= '9') && !expectColon &&               (phased || (phase1 + (phased ? 1 : 0) + phase2) == 6)) {             // Check for IPv4 address             int decOctet = parseDecOctet(s' index' endOffset' c' '.');             if (decOctet >= 0) {               if ((phase1 + (phased ? 1 : 0) + phase2) > 6) {                 // IPv4 address illegal at this point                 return -1;               } else {                 // Parse the rest of the IPv4 address                 phase2 += 2;                 if (decOctet >= 100) {                   index += 4;                 } else if (decOctet >= 10) {                   index += 3;                 } else {                   index += 2;                 }                 char tmpc = (index < endOffset) ? s[index] : '\0';                 decOctet = parseDecOctet(   s'   index'   endOffset'   tmpc'   '.');                 if (decOctet >= 100) {                   index += 4;                 } else if (decOctet >= 10) {                   index += 3;                 } else if (decOctet >= 0) {                   index += 2;                 } else {                   return -1;                 }                 tmpc = (index < endOffset) ? s[index] : '\0';                 decOctet = parseDecOctet(s' index' endOffset' tmpc' '.');                 if (decOctet >= 100) {                   index += 4;                 } else if (decOctet >= 10) {                   index += 3;                 } else if (decOctet >= 0) {                   index += 2;                 } else {                   return -1;                 }                 tmpc = (index < endOffset) ? s[index] : '\0';                 decOctet = parseDecOctet(s' index' endOffset' tmpc' ']');                 if (decOctet < 0) {                   tmpc = (index < endOffset) ? s[index] : '\0';                   decOctet = parseDecOctet(s' index' endOffset' tmpc' '%');                 }                 if (decOctet >= 100) {                   index += 3;                 } else if (decOctet >= 10) {                   index += 2;                 } else if (decOctet >= 0) {                   ++index;                 } else {                   return -1;                 }                 break;               }             }           }           if (isHexChar(c) && !expectColon) {             if (phased) {               ++phase2;             } else {               ++phase1;             }             ++index;             for (var i = 0; i < 3; ++i) {               if (index < endOffset && isHexChar(s[index])) {                 ++index;               } else {                 break;               }             }             expectHex = false;             expectColon = true;           } else {             break;           }         }         if ((phase1 + phase2) != 8 && !phased) {           return -1;         }         if (phase1 + 1 + phase2 > 8 && phased) {           return -1;         }         if (index >= endOffset) {           return -1;         }         if (s[index] != ']' && s[index] != '%') {           return -1;         }         if (s[index] == '%') {           if (index + 2 < endOffset && s[index + 1] == '2' &&               s[index + 2] == '5') {             // Zone identifier in an IPv6 address             // (see RFC6874)             index += 3;             var haveChar = false;             while (index < endOffset) {               char c = s[index];               if (c == ']') {                 return haveChar ? index + 1 : -1;               }               if (c == '%') {                 if (index + 2 < endOffset && isHexChar(s[index + 1]) &&                     isHexChar(s[index + 2])) {                   index += 3;                   haveChar = true;                   continue;                 }                 return -1;               }               if ((c >= 'a' && c <= 'z') || (c >= 'A' && c <= 'Z') ||              (c >= '0' && c <= '9') || c == '.' || c == '_' || c == '-' ||                 c == '~') {                 // unreserved character under RFC3986                 ++index;                 haveChar = true;                 continue;               }               return -1;             }             return -1;           }           return -1;         }         ++index;         return index;       }
Magic Number,PeterO.Cbor,URIUtility,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\URIUtility.cs,parseIPLiteral,The following statement contains a magic number: if (s[index] == ':' ||           isHexChar(s[index])) {         // IPv6 Address         var phase1 = 0;         var phase2 = 0;         var phased = false;         var expectHex = false;         var expectColon = false;         while (index < endOffset) {           char c = s[index];           if (c == ':' && !expectHex) {             if ((phase1 + (phased ? 1 : 0) + phase2) >= 8) {               return -1;             }             ++index;             if (index < endOffset && s[index] == ':') {               if (phased) {                 return -1;               }               phased = true;               ++index;             }             expectHex = true;             expectColon = false;             continue;           }           if ((c >= '0' && c <= '9') && !expectColon &&               (phased || (phase1 + (phased ? 1 : 0) + phase2) == 6)) {             // Check for IPv4 address             int decOctet = parseDecOctet(s' index' endOffset' c' '.');             if (decOctet >= 0) {               if ((phase1 + (phased ? 1 : 0) + phase2) > 6) {                 // IPv4 address illegal at this point                 return -1;               } else {                 // Parse the rest of the IPv4 address                 phase2 += 2;                 if (decOctet >= 100) {                   index += 4;                 } else if (decOctet >= 10) {                   index += 3;                 } else {                   index += 2;                 }                 char tmpc = (index < endOffset) ? s[index] : '\0';                 decOctet = parseDecOctet(   s'   index'   endOffset'   tmpc'   '.');                 if (decOctet >= 100) {                   index += 4;                 } else if (decOctet >= 10) {                   index += 3;                 } else if (decOctet >= 0) {                   index += 2;                 } else {                   return -1;                 }                 tmpc = (index < endOffset) ? s[index] : '\0';                 decOctet = parseDecOctet(s' index' endOffset' tmpc' '.');                 if (decOctet >= 100) {                   index += 4;                 } else if (decOctet >= 10) {                   index += 3;                 } else if (decOctet >= 0) {                   index += 2;                 } else {                   return -1;                 }                 tmpc = (index < endOffset) ? s[index] : '\0';                 decOctet = parseDecOctet(s' index' endOffset' tmpc' ']');                 if (decOctet < 0) {                   tmpc = (index < endOffset) ? s[index] : '\0';                   decOctet = parseDecOctet(s' index' endOffset' tmpc' '%');                 }                 if (decOctet >= 100) {                   index += 3;                 } else if (decOctet >= 10) {                   index += 2;                 } else if (decOctet >= 0) {                   ++index;                 } else {                   return -1;                 }                 break;               }             }           }           if (isHexChar(c) && !expectColon) {             if (phased) {               ++phase2;             } else {               ++phase1;             }             ++index;             for (var i = 0; i < 3; ++i) {               if (index < endOffset && isHexChar(s[index])) {                 ++index;               } else {                 break;               }             }             expectHex = false;             expectColon = true;           } else {             break;           }         }         if ((phase1 + phase2) != 8 && !phased) {           return -1;         }         if (phase1 + 1 + phase2 > 8 && phased) {           return -1;         }         if (index >= endOffset) {           return -1;         }         if (s[index] != ']' && s[index] != '%') {           return -1;         }         if (s[index] == '%') {           if (index + 2 < endOffset && s[index + 1] == '2' &&               s[index + 2] == '5') {             // Zone identifier in an IPv6 address             // (see RFC6874)             index += 3;             var haveChar = false;             while (index < endOffset) {               char c = s[index];               if (c == ']') {                 return haveChar ? index + 1 : -1;               }               if (c == '%') {                 if (index + 2 < endOffset && isHexChar(s[index + 1]) &&                     isHexChar(s[index + 2])) {                   index += 3;                   haveChar = true;                   continue;                 }                 return -1;               }               if ((c >= 'a' && c <= 'z') || (c >= 'A' && c <= 'Z') ||              (c >= '0' && c <= '9') || c == '.' || c == '_' || c == '-' ||                 c == '~') {                 // unreserved character under RFC3986                 ++index;                 haveChar = true;                 continue;               }               return -1;             }             return -1;           }           return -1;         }         ++index;         return index;       }
Magic Number,PeterO.Cbor,URIUtility,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\URIUtility.cs,parseIPLiteral,The following statement contains a magic number: if (s[index] == ':' ||           isHexChar(s[index])) {         // IPv6 Address         var phase1 = 0;         var phase2 = 0;         var phased = false;         var expectHex = false;         var expectColon = false;         while (index < endOffset) {           char c = s[index];           if (c == ':' && !expectHex) {             if ((phase1 + (phased ? 1 : 0) + phase2) >= 8) {               return -1;             }             ++index;             if (index < endOffset && s[index] == ':') {               if (phased) {                 return -1;               }               phased = true;               ++index;             }             expectHex = true;             expectColon = false;             continue;           }           if ((c >= '0' && c <= '9') && !expectColon &&               (phased || (phase1 + (phased ? 1 : 0) + phase2) == 6)) {             // Check for IPv4 address             int decOctet = parseDecOctet(s' index' endOffset' c' '.');             if (decOctet >= 0) {               if ((phase1 + (phased ? 1 : 0) + phase2) > 6) {                 // IPv4 address illegal at this point                 return -1;               } else {                 // Parse the rest of the IPv4 address                 phase2 += 2;                 if (decOctet >= 100) {                   index += 4;                 } else if (decOctet >= 10) {                   index += 3;                 } else {                   index += 2;                 }                 char tmpc = (index < endOffset) ? s[index] : '\0';                 decOctet = parseDecOctet(   s'   index'   endOffset'   tmpc'   '.');                 if (decOctet >= 100) {                   index += 4;                 } else if (decOctet >= 10) {                   index += 3;                 } else if (decOctet >= 0) {                   index += 2;                 } else {                   return -1;                 }                 tmpc = (index < endOffset) ? s[index] : '\0';                 decOctet = parseDecOctet(s' index' endOffset' tmpc' '.');                 if (decOctet >= 100) {                   index += 4;                 } else if (decOctet >= 10) {                   index += 3;                 } else if (decOctet >= 0) {                   index += 2;                 } else {                   return -1;                 }                 tmpc = (index < endOffset) ? s[index] : '\0';                 decOctet = parseDecOctet(s' index' endOffset' tmpc' ']');                 if (decOctet < 0) {                   tmpc = (index < endOffset) ? s[index] : '\0';                   decOctet = parseDecOctet(s' index' endOffset' tmpc' '%');                 }                 if (decOctet >= 100) {                   index += 3;                 } else if (decOctet >= 10) {                   index += 2;                 } else if (decOctet >= 0) {                   ++index;                 } else {                   return -1;                 }                 break;               }             }           }           if (isHexChar(c) && !expectColon) {             if (phased) {               ++phase2;             } else {               ++phase1;             }             ++index;             for (var i = 0; i < 3; ++i) {               if (index < endOffset && isHexChar(s[index])) {                 ++index;               } else {                 break;               }             }             expectHex = false;             expectColon = true;           } else {             break;           }         }         if ((phase1 + phase2) != 8 && !phased) {           return -1;         }         if (phase1 + 1 + phase2 > 8 && phased) {           return -1;         }         if (index >= endOffset) {           return -1;         }         if (s[index] != ']' && s[index] != '%') {           return -1;         }         if (s[index] == '%') {           if (index + 2 < endOffset && s[index + 1] == '2' &&               s[index + 2] == '5') {             // Zone identifier in an IPv6 address             // (see RFC6874)             index += 3;             var haveChar = false;             while (index < endOffset) {               char c = s[index];               if (c == ']') {                 return haveChar ? index + 1 : -1;               }               if (c == '%') {                 if (index + 2 < endOffset && isHexChar(s[index + 1]) &&                     isHexChar(s[index + 2])) {                   index += 3;                   haveChar = true;                   continue;                 }                 return -1;               }               if ((c >= 'a' && c <= 'z') || (c >= 'A' && c <= 'Z') ||              (c >= '0' && c <= '9') || c == '.' || c == '_' || c == '-' ||                 c == '~') {                 // unreserved character under RFC3986                 ++index;                 haveChar = true;                 continue;               }               return -1;             }             return -1;           }           return -1;         }         ++index;         return index;       }
Magic Number,PeterO.Cbor,URIUtility,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\URIUtility.cs,parseIPLiteral,The following statement contains a magic number: if (s[index] == ':' ||           isHexChar(s[index])) {         // IPv6 Address         var phase1 = 0;         var phase2 = 0;         var phased = false;         var expectHex = false;         var expectColon = false;         while (index < endOffset) {           char c = s[index];           if (c == ':' && !expectHex) {             if ((phase1 + (phased ? 1 : 0) + phase2) >= 8) {               return -1;             }             ++index;             if (index < endOffset && s[index] == ':') {               if (phased) {                 return -1;               }               phased = true;               ++index;             }             expectHex = true;             expectColon = false;             continue;           }           if ((c >= '0' && c <= '9') && !expectColon &&               (phased || (phase1 + (phased ? 1 : 0) + phase2) == 6)) {             // Check for IPv4 address             int decOctet = parseDecOctet(s' index' endOffset' c' '.');             if (decOctet >= 0) {               if ((phase1 + (phased ? 1 : 0) + phase2) > 6) {                 // IPv4 address illegal at this point                 return -1;               } else {                 // Parse the rest of the IPv4 address                 phase2 += 2;                 if (decOctet >= 100) {                   index += 4;                 } else if (decOctet >= 10) {                   index += 3;                 } else {                   index += 2;                 }                 char tmpc = (index < endOffset) ? s[index] : '\0';                 decOctet = parseDecOctet(   s'   index'   endOffset'   tmpc'   '.');                 if (decOctet >= 100) {                   index += 4;                 } else if (decOctet >= 10) {                   index += 3;                 } else if (decOctet >= 0) {                   index += 2;                 } else {                   return -1;                 }                 tmpc = (index < endOffset) ? s[index] : '\0';                 decOctet = parseDecOctet(s' index' endOffset' tmpc' '.');                 if (decOctet >= 100) {                   index += 4;                 } else if (decOctet >= 10) {                   index += 3;                 } else if (decOctet >= 0) {                   index += 2;                 } else {                   return -1;                 }                 tmpc = (index < endOffset) ? s[index] : '\0';                 decOctet = parseDecOctet(s' index' endOffset' tmpc' ']');                 if (decOctet < 0) {                   tmpc = (index < endOffset) ? s[index] : '\0';                   decOctet = parseDecOctet(s' index' endOffset' tmpc' '%');                 }                 if (decOctet >= 100) {                   index += 3;                 } else if (decOctet >= 10) {                   index += 2;                 } else if (decOctet >= 0) {                   ++index;                 } else {                   return -1;                 }                 break;               }             }           }           if (isHexChar(c) && !expectColon) {             if (phased) {               ++phase2;             } else {               ++phase1;             }             ++index;             for (var i = 0; i < 3; ++i) {               if (index < endOffset && isHexChar(s[index])) {                 ++index;               } else {                 break;               }             }             expectHex = false;             expectColon = true;           } else {             break;           }         }         if ((phase1 + phase2) != 8 && !phased) {           return -1;         }         if (phase1 + 1 + phase2 > 8 && phased) {           return -1;         }         if (index >= endOffset) {           return -1;         }         if (s[index] != ']' && s[index] != '%') {           return -1;         }         if (s[index] == '%') {           if (index + 2 < endOffset && s[index + 1] == '2' &&               s[index + 2] == '5') {             // Zone identifier in an IPv6 address             // (see RFC6874)             index += 3;             var haveChar = false;             while (index < endOffset) {               char c = s[index];               if (c == ']') {                 return haveChar ? index + 1 : -1;               }               if (c == '%') {                 if (index + 2 < endOffset && isHexChar(s[index + 1]) &&                     isHexChar(s[index + 2])) {                   index += 3;                   haveChar = true;                   continue;                 }                 return -1;               }               if ((c >= 'a' && c <= 'z') || (c >= 'A' && c <= 'Z') ||              (c >= '0' && c <= '9') || c == '.' || c == '_' || c == '-' ||                 c == '~') {                 // unreserved character under RFC3986                 ++index;                 haveChar = true;                 continue;               }               return -1;             }             return -1;           }           return -1;         }         ++index;         return index;       }
Magic Number,PeterO.Cbor,URIUtility,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\URIUtility.cs,parseIPLiteral,The following statement contains a magic number: if (s[index] == ':' ||           isHexChar(s[index])) {         // IPv6 Address         var phase1 = 0;         var phase2 = 0;         var phased = false;         var expectHex = false;         var expectColon = false;         while (index < endOffset) {           char c = s[index];           if (c == ':' && !expectHex) {             if ((phase1 + (phased ? 1 : 0) + phase2) >= 8) {               return -1;             }             ++index;             if (index < endOffset && s[index] == ':') {               if (phased) {                 return -1;               }               phased = true;               ++index;             }             expectHex = true;             expectColon = false;             continue;           }           if ((c >= '0' && c <= '9') && !expectColon &&               (phased || (phase1 + (phased ? 1 : 0) + phase2) == 6)) {             // Check for IPv4 address             int decOctet = parseDecOctet(s' index' endOffset' c' '.');             if (decOctet >= 0) {               if ((phase1 + (phased ? 1 : 0) + phase2) > 6) {                 // IPv4 address illegal at this point                 return -1;               } else {                 // Parse the rest of the IPv4 address                 phase2 += 2;                 if (decOctet >= 100) {                   index += 4;                 } else if (decOctet >= 10) {                   index += 3;                 } else {                   index += 2;                 }                 char tmpc = (index < endOffset) ? s[index] : '\0';                 decOctet = parseDecOctet(   s'   index'   endOffset'   tmpc'   '.');                 if (decOctet >= 100) {                   index += 4;                 } else if (decOctet >= 10) {                   index += 3;                 } else if (decOctet >= 0) {                   index += 2;                 } else {                   return -1;                 }                 tmpc = (index < endOffset) ? s[index] : '\0';                 decOctet = parseDecOctet(s' index' endOffset' tmpc' '.');                 if (decOctet >= 100) {                   index += 4;                 } else if (decOctet >= 10) {                   index += 3;                 } else if (decOctet >= 0) {                   index += 2;                 } else {                   return -1;                 }                 tmpc = (index < endOffset) ? s[index] : '\0';                 decOctet = parseDecOctet(s' index' endOffset' tmpc' ']');                 if (decOctet < 0) {                   tmpc = (index < endOffset) ? s[index] : '\0';                   decOctet = parseDecOctet(s' index' endOffset' tmpc' '%');                 }                 if (decOctet >= 100) {                   index += 3;                 } else if (decOctet >= 10) {                   index += 2;                 } else if (decOctet >= 0) {                   ++index;                 } else {                   return -1;                 }                 break;               }             }           }           if (isHexChar(c) && !expectColon) {             if (phased) {               ++phase2;             } else {               ++phase1;             }             ++index;             for (var i = 0; i < 3; ++i) {               if (index < endOffset && isHexChar(s[index])) {                 ++index;               } else {                 break;               }             }             expectHex = false;             expectColon = true;           } else {             break;           }         }         if ((phase1 + phase2) != 8 && !phased) {           return -1;         }         if (phase1 + 1 + phase2 > 8 && phased) {           return -1;         }         if (index >= endOffset) {           return -1;         }         if (s[index] != ']' && s[index] != '%') {           return -1;         }         if (s[index] == '%') {           if (index + 2 < endOffset && s[index + 1] == '2' &&               s[index + 2] == '5') {             // Zone identifier in an IPv6 address             // (see RFC6874)             index += 3;             var haveChar = false;             while (index < endOffset) {               char c = s[index];               if (c == ']') {                 return haveChar ? index + 1 : -1;               }               if (c == '%') {                 if (index + 2 < endOffset && isHexChar(s[index + 1]) &&                     isHexChar(s[index + 2])) {                   index += 3;                   haveChar = true;                   continue;                 }                 return -1;               }               if ((c >= 'a' && c <= 'z') || (c >= 'A' && c <= 'Z') ||              (c >= '0' && c <= '9') || c == '.' || c == '_' || c == '-' ||                 c == '~') {                 // unreserved character under RFC3986                 ++index;                 haveChar = true;                 continue;               }               return -1;             }             return -1;           }           return -1;         }         ++index;         return index;       }
Magic Number,PeterO.Cbor,URIUtility,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\URIUtility.cs,parseIPLiteral,The following statement contains a magic number: if (s[index] == ':' ||           isHexChar(s[index])) {         // IPv6 Address         var phase1 = 0;         var phase2 = 0;         var phased = false;         var expectHex = false;         var expectColon = false;         while (index < endOffset) {           char c = s[index];           if (c == ':' && !expectHex) {             if ((phase1 + (phased ? 1 : 0) + phase2) >= 8) {               return -1;             }             ++index;             if (index < endOffset && s[index] == ':') {               if (phased) {                 return -1;               }               phased = true;               ++index;             }             expectHex = true;             expectColon = false;             continue;           }           if ((c >= '0' && c <= '9') && !expectColon &&               (phased || (phase1 + (phased ? 1 : 0) + phase2) == 6)) {             // Check for IPv4 address             int decOctet = parseDecOctet(s' index' endOffset' c' '.');             if (decOctet >= 0) {               if ((phase1 + (phased ? 1 : 0) + phase2) > 6) {                 // IPv4 address illegal at this point                 return -1;               } else {                 // Parse the rest of the IPv4 address                 phase2 += 2;                 if (decOctet >= 100) {                   index += 4;                 } else if (decOctet >= 10) {                   index += 3;                 } else {                   index += 2;                 }                 char tmpc = (index < endOffset) ? s[index] : '\0';                 decOctet = parseDecOctet(   s'   index'   endOffset'   tmpc'   '.');                 if (decOctet >= 100) {                   index += 4;                 } else if (decOctet >= 10) {                   index += 3;                 } else if (decOctet >= 0) {                   index += 2;                 } else {                   return -1;                 }                 tmpc = (index < endOffset) ? s[index] : '\0';                 decOctet = parseDecOctet(s' index' endOffset' tmpc' '.');                 if (decOctet >= 100) {                   index += 4;                 } else if (decOctet >= 10) {                   index += 3;                 } else if (decOctet >= 0) {                   index += 2;                 } else {                   return -1;                 }                 tmpc = (index < endOffset) ? s[index] : '\0';                 decOctet = parseDecOctet(s' index' endOffset' tmpc' ']');                 if (decOctet < 0) {                   tmpc = (index < endOffset) ? s[index] : '\0';                   decOctet = parseDecOctet(s' index' endOffset' tmpc' '%');                 }                 if (decOctet >= 100) {                   index += 3;                 } else if (decOctet >= 10) {                   index += 2;                 } else if (decOctet >= 0) {                   ++index;                 } else {                   return -1;                 }                 break;               }             }           }           if (isHexChar(c) && !expectColon) {             if (phased) {               ++phase2;             } else {               ++phase1;             }             ++index;             for (var i = 0; i < 3; ++i) {               if (index < endOffset && isHexChar(s[index])) {                 ++index;               } else {                 break;               }             }             expectHex = false;             expectColon = true;           } else {             break;           }         }         if ((phase1 + phase2) != 8 && !phased) {           return -1;         }         if (phase1 + 1 + phase2 > 8 && phased) {           return -1;         }         if (index >= endOffset) {           return -1;         }         if (s[index] != ']' && s[index] != '%') {           return -1;         }         if (s[index] == '%') {           if (index + 2 < endOffset && s[index + 1] == '2' &&               s[index + 2] == '5') {             // Zone identifier in an IPv6 address             // (see RFC6874)             index += 3;             var haveChar = false;             while (index < endOffset) {               char c = s[index];               if (c == ']') {                 return haveChar ? index + 1 : -1;               }               if (c == '%') {                 if (index + 2 < endOffset && isHexChar(s[index + 1]) &&                     isHexChar(s[index + 2])) {                   index += 3;                   haveChar = true;                   continue;                 }                 return -1;               }               if ((c >= 'a' && c <= 'z') || (c >= 'A' && c <= 'Z') ||              (c >= '0' && c <= '9') || c == '.' || c == '_' || c == '-' ||                 c == '~') {                 // unreserved character under RFC3986                 ++index;                 haveChar = true;                 continue;               }               return -1;             }             return -1;           }           return -1;         }         ++index;         return index;       }
Magic Number,PeterO.Cbor,URIUtility,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\URIUtility.cs,percentEncode,The following statement contains a magic number: buffer.Append(HexChars[(b >> 4) & 0x0f]);
Magic Number,PeterO.Cbor,URIUtility,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\URIUtility.cs,percentEncodeUtf8,The following statement contains a magic number: if (cp <= 0x7f) {         buffer.Append('%');         buffer.Append(HexChars[(cp >> 4) & 0x0f]);         buffer.Append(HexChars[cp & 0x0f]);       } else if (cp <= 0x7ff) {         percentEncode(buffer' 0xc0 | ((cp >> 6) & 0x1f));         percentEncode(buffer' 0x80 | (cp & 0x3f));       } else if (cp <= 0xffff) {         percentEncode(buffer' 0xe0 | ((cp >> 12) & 0x0f));         percentEncode(buffer' 0x80 | ((cp >> 6) & 0x3f));         percentEncode(buffer' 0x80 | (cp & 0x3f));       } else {         percentEncode(buffer' 0xf0 | ((cp >> 18) & 0x07));         percentEncode(buffer' 0x80 | ((cp >> 12) & 0x3f));         percentEncode(buffer' 0x80 | ((cp >> 6) & 0x3f));         percentEncode(buffer' 0x80 | (cp & 0x3f));       }
Magic Number,PeterO.Cbor,URIUtility,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\URIUtility.cs,percentEncodeUtf8,The following statement contains a magic number: if (cp <= 0x7f) {         buffer.Append('%');         buffer.Append(HexChars[(cp >> 4) & 0x0f]);         buffer.Append(HexChars[cp & 0x0f]);       } else if (cp <= 0x7ff) {         percentEncode(buffer' 0xc0 | ((cp >> 6) & 0x1f));         percentEncode(buffer' 0x80 | (cp & 0x3f));       } else if (cp <= 0xffff) {         percentEncode(buffer' 0xe0 | ((cp >> 12) & 0x0f));         percentEncode(buffer' 0x80 | ((cp >> 6) & 0x3f));         percentEncode(buffer' 0x80 | (cp & 0x3f));       } else {         percentEncode(buffer' 0xf0 | ((cp >> 18) & 0x07));         percentEncode(buffer' 0x80 | ((cp >> 12) & 0x3f));         percentEncode(buffer' 0x80 | ((cp >> 6) & 0x3f));         percentEncode(buffer' 0x80 | (cp & 0x3f));       }
Magic Number,PeterO.Cbor,URIUtility,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\URIUtility.cs,percentEncodeUtf8,The following statement contains a magic number: if (cp <= 0x7f) {         buffer.Append('%');         buffer.Append(HexChars[(cp >> 4) & 0x0f]);         buffer.Append(HexChars[cp & 0x0f]);       } else if (cp <= 0x7ff) {         percentEncode(buffer' 0xc0 | ((cp >> 6) & 0x1f));         percentEncode(buffer' 0x80 | (cp & 0x3f));       } else if (cp <= 0xffff) {         percentEncode(buffer' 0xe0 | ((cp >> 12) & 0x0f));         percentEncode(buffer' 0x80 | ((cp >> 6) & 0x3f));         percentEncode(buffer' 0x80 | (cp & 0x3f));       } else {         percentEncode(buffer' 0xf0 | ((cp >> 18) & 0x07));         percentEncode(buffer' 0x80 | ((cp >> 12) & 0x3f));         percentEncode(buffer' 0x80 | ((cp >> 6) & 0x3f));         percentEncode(buffer' 0x80 | (cp & 0x3f));       }
Magic Number,PeterO.Cbor,URIUtility,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\URIUtility.cs,percentEncodeUtf8,The following statement contains a magic number: if (cp <= 0x7f) {         buffer.Append('%');         buffer.Append(HexChars[(cp >> 4) & 0x0f]);         buffer.Append(HexChars[cp & 0x0f]);       } else if (cp <= 0x7ff) {         percentEncode(buffer' 0xc0 | ((cp >> 6) & 0x1f));         percentEncode(buffer' 0x80 | (cp & 0x3f));       } else if (cp <= 0xffff) {         percentEncode(buffer' 0xe0 | ((cp >> 12) & 0x0f));         percentEncode(buffer' 0x80 | ((cp >> 6) & 0x3f));         percentEncode(buffer' 0x80 | (cp & 0x3f));       } else {         percentEncode(buffer' 0xf0 | ((cp >> 18) & 0x07));         percentEncode(buffer' 0x80 | ((cp >> 12) & 0x3f));         percentEncode(buffer' 0x80 | ((cp >> 6) & 0x3f));         percentEncode(buffer' 0x80 | (cp & 0x3f));       }
Magic Number,PeterO.Cbor,URIUtility,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\URIUtility.cs,percentEncodeUtf8,The following statement contains a magic number: if (cp <= 0x7f) {         buffer.Append('%');         buffer.Append(HexChars[(cp >> 4) & 0x0f]);         buffer.Append(HexChars[cp & 0x0f]);       } else if (cp <= 0x7ff) {         percentEncode(buffer' 0xc0 | ((cp >> 6) & 0x1f));         percentEncode(buffer' 0x80 | (cp & 0x3f));       } else if (cp <= 0xffff) {         percentEncode(buffer' 0xe0 | ((cp >> 12) & 0x0f));         percentEncode(buffer' 0x80 | ((cp >> 6) & 0x3f));         percentEncode(buffer' 0x80 | (cp & 0x3f));       } else {         percentEncode(buffer' 0xf0 | ((cp >> 18) & 0x07));         percentEncode(buffer' 0x80 | ((cp >> 12) & 0x3f));         percentEncode(buffer' 0x80 | ((cp >> 6) & 0x3f));         percentEncode(buffer' 0x80 | (cp & 0x3f));       }
Magic Number,PeterO.Cbor,URIUtility,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\URIUtility.cs,percentEncodeUtf8,The following statement contains a magic number: if (cp <= 0x7f) {         buffer.Append('%');         buffer.Append(HexChars[(cp >> 4) & 0x0f]);         buffer.Append(HexChars[cp & 0x0f]);       } else if (cp <= 0x7ff) {         percentEncode(buffer' 0xc0 | ((cp >> 6) & 0x1f));         percentEncode(buffer' 0x80 | (cp & 0x3f));       } else if (cp <= 0xffff) {         percentEncode(buffer' 0xe0 | ((cp >> 12) & 0x0f));         percentEncode(buffer' 0x80 | ((cp >> 6) & 0x3f));         percentEncode(buffer' 0x80 | (cp & 0x3f));       } else {         percentEncode(buffer' 0xf0 | ((cp >> 18) & 0x07));         percentEncode(buffer' 0x80 | ((cp >> 12) & 0x3f));         percentEncode(buffer' 0x80 | ((cp >> 6) & 0x3f));         percentEncode(buffer' 0x80 | (cp & 0x3f));       }
Magic Number,PeterO.Cbor,URIUtility,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\URIUtility.cs,percentEncodeUtf8,The following statement contains a magic number: if (cp <= 0x7f) {         buffer.Append('%');         buffer.Append(HexChars[(cp >> 4) & 0x0f]);         buffer.Append(HexChars[cp & 0x0f]);       } else if (cp <= 0x7ff) {         percentEncode(buffer' 0xc0 | ((cp >> 6) & 0x1f));         percentEncode(buffer' 0x80 | (cp & 0x3f));       } else if (cp <= 0xffff) {         percentEncode(buffer' 0xe0 | ((cp >> 12) & 0x0f));         percentEncode(buffer' 0x80 | ((cp >> 6) & 0x3f));         percentEncode(buffer' 0x80 | (cp & 0x3f));       } else {         percentEncode(buffer' 0xf0 | ((cp >> 18) & 0x07));         percentEncode(buffer' 0x80 | ((cp >> 12) & 0x3f));         percentEncode(buffer' 0x80 | ((cp >> 6) & 0x3f));         percentEncode(buffer' 0x80 | (cp & 0x3f));       }
Magic Number,PeterO.Cbor,URIUtility,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\URIUtility.cs,relativeResolve,The following statement contains a magic number: if (segments[0] >= 0) {  // scheme present         appendScheme(builder' refValue' segments);         appendAuthority(builder' refValue' segments);         appendNormalizedPath(builder' refValue' segments);         appendQuery(builder' refValue' segments);         appendFragment(builder' refValue' segments);       } else if (segments[2] >= 0) {  // authority present         appendScheme(builder' baseURI' segmentsBase);         appendAuthority(builder' refValue' segments);         appendNormalizedPath(builder' refValue' segments);         appendQuery(builder' refValue' segments);         appendFragment(builder' refValue' segments);       } else if (segments[4] == segments[5]) {         appendScheme(builder' baseURI' segmentsBase);         appendAuthority(builder' baseURI' segmentsBase);         appendPath(builder' baseURI' segmentsBase);         if (segments[6] >= 0) {           appendQuery(builder' refValue' segments);         } else {           appendQuery(builder' baseURI' segmentsBase);         }         appendFragment(builder' refValue' segments);       } else {         appendScheme(builder' baseURI' segmentsBase);         appendAuthority(builder' baseURI' segmentsBase);         if (segments[4] < segments[5] && refValue[segments[4]] == '/') {           appendNormalizedPath(builder' refValue' segments);         } else {           var merged = new StringBuilder();           if (segmentsBase[2] >= 0 && segmentsBase[4] == segmentsBase[5]) {             merged.Append('/');             appendPath(merged' refValue' segments);             builder.Append(normalizePath(merged.ToString()));           } else {             merged.Append(               pathParent(   baseURI'   segmentsBase[4]'   segmentsBase[5]));             appendPath(merged' refValue' segments);             builder.Append(normalizePath(merged.ToString()));           }         }         appendQuery(builder' refValue' segments);         appendFragment(builder' refValue' segments);       }
Magic Number,PeterO.Cbor,URIUtility,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\URIUtility.cs,relativeResolve,The following statement contains a magic number: if (segments[0] >= 0) {  // scheme present         appendScheme(builder' refValue' segments);         appendAuthority(builder' refValue' segments);         appendNormalizedPath(builder' refValue' segments);         appendQuery(builder' refValue' segments);         appendFragment(builder' refValue' segments);       } else if (segments[2] >= 0) {  // authority present         appendScheme(builder' baseURI' segmentsBase);         appendAuthority(builder' refValue' segments);         appendNormalizedPath(builder' refValue' segments);         appendQuery(builder' refValue' segments);         appendFragment(builder' refValue' segments);       } else if (segments[4] == segments[5]) {         appendScheme(builder' baseURI' segmentsBase);         appendAuthority(builder' baseURI' segmentsBase);         appendPath(builder' baseURI' segmentsBase);         if (segments[6] >= 0) {           appendQuery(builder' refValue' segments);         } else {           appendQuery(builder' baseURI' segmentsBase);         }         appendFragment(builder' refValue' segments);       } else {         appendScheme(builder' baseURI' segmentsBase);         appendAuthority(builder' baseURI' segmentsBase);         if (segments[4] < segments[5] && refValue[segments[4]] == '/') {           appendNormalizedPath(builder' refValue' segments);         } else {           var merged = new StringBuilder();           if (segmentsBase[2] >= 0 && segmentsBase[4] == segmentsBase[5]) {             merged.Append('/');             appendPath(merged' refValue' segments);             builder.Append(normalizePath(merged.ToString()));           } else {             merged.Append(               pathParent(   baseURI'   segmentsBase[4]'   segmentsBase[5]));             appendPath(merged' refValue' segments);             builder.Append(normalizePath(merged.ToString()));           }         }         appendQuery(builder' refValue' segments);         appendFragment(builder' refValue' segments);       }
Magic Number,PeterO.Cbor,URIUtility,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\URIUtility.cs,relativeResolve,The following statement contains a magic number: if (segments[0] >= 0) {  // scheme present         appendScheme(builder' refValue' segments);         appendAuthority(builder' refValue' segments);         appendNormalizedPath(builder' refValue' segments);         appendQuery(builder' refValue' segments);         appendFragment(builder' refValue' segments);       } else if (segments[2] >= 0) {  // authority present         appendScheme(builder' baseURI' segmentsBase);         appendAuthority(builder' refValue' segments);         appendNormalizedPath(builder' refValue' segments);         appendQuery(builder' refValue' segments);         appendFragment(builder' refValue' segments);       } else if (segments[4] == segments[5]) {         appendScheme(builder' baseURI' segmentsBase);         appendAuthority(builder' baseURI' segmentsBase);         appendPath(builder' baseURI' segmentsBase);         if (segments[6] >= 0) {           appendQuery(builder' refValue' segments);         } else {           appendQuery(builder' baseURI' segmentsBase);         }         appendFragment(builder' refValue' segments);       } else {         appendScheme(builder' baseURI' segmentsBase);         appendAuthority(builder' baseURI' segmentsBase);         if (segments[4] < segments[5] && refValue[segments[4]] == '/') {           appendNormalizedPath(builder' refValue' segments);         } else {           var merged = new StringBuilder();           if (segmentsBase[2] >= 0 && segmentsBase[4] == segmentsBase[5]) {             merged.Append('/');             appendPath(merged' refValue' segments);             builder.Append(normalizePath(merged.ToString()));           } else {             merged.Append(               pathParent(   baseURI'   segmentsBase[4]'   segmentsBase[5]));             appendPath(merged' refValue' segments);             builder.Append(normalizePath(merged.ToString()));           }         }         appendQuery(builder' refValue' segments);         appendFragment(builder' refValue' segments);       }
Magic Number,PeterO.Cbor,URIUtility,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\URIUtility.cs,relativeResolve,The following statement contains a magic number: if (segments[0] >= 0) {  // scheme present         appendScheme(builder' refValue' segments);         appendAuthority(builder' refValue' segments);         appendNormalizedPath(builder' refValue' segments);         appendQuery(builder' refValue' segments);         appendFragment(builder' refValue' segments);       } else if (segments[2] >= 0) {  // authority present         appendScheme(builder' baseURI' segmentsBase);         appendAuthority(builder' refValue' segments);         appendNormalizedPath(builder' refValue' segments);         appendQuery(builder' refValue' segments);         appendFragment(builder' refValue' segments);       } else if (segments[4] == segments[5]) {         appendScheme(builder' baseURI' segmentsBase);         appendAuthority(builder' baseURI' segmentsBase);         appendPath(builder' baseURI' segmentsBase);         if (segments[6] >= 0) {           appendQuery(builder' refValue' segments);         } else {           appendQuery(builder' baseURI' segmentsBase);         }         appendFragment(builder' refValue' segments);       } else {         appendScheme(builder' baseURI' segmentsBase);         appendAuthority(builder' baseURI' segmentsBase);         if (segments[4] < segments[5] && refValue[segments[4]] == '/') {           appendNormalizedPath(builder' refValue' segments);         } else {           var merged = new StringBuilder();           if (segmentsBase[2] >= 0 && segmentsBase[4] == segmentsBase[5]) {             merged.Append('/');             appendPath(merged' refValue' segments);             builder.Append(normalizePath(merged.ToString()));           } else {             merged.Append(               pathParent(   baseURI'   segmentsBase[4]'   segmentsBase[5]));             appendPath(merged' refValue' segments);             builder.Append(normalizePath(merged.ToString()));           }         }         appendQuery(builder' refValue' segments);         appendFragment(builder' refValue' segments);       }
Magic Number,PeterO.Cbor,URIUtility,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\URIUtility.cs,relativeResolve,The following statement contains a magic number: if (segments[0] >= 0) {  // scheme present         appendScheme(builder' refValue' segments);         appendAuthority(builder' refValue' segments);         appendNormalizedPath(builder' refValue' segments);         appendQuery(builder' refValue' segments);         appendFragment(builder' refValue' segments);       } else if (segments[2] >= 0) {  // authority present         appendScheme(builder' baseURI' segmentsBase);         appendAuthority(builder' refValue' segments);         appendNormalizedPath(builder' refValue' segments);         appendQuery(builder' refValue' segments);         appendFragment(builder' refValue' segments);       } else if (segments[4] == segments[5]) {         appendScheme(builder' baseURI' segmentsBase);         appendAuthority(builder' baseURI' segmentsBase);         appendPath(builder' baseURI' segmentsBase);         if (segments[6] >= 0) {           appendQuery(builder' refValue' segments);         } else {           appendQuery(builder' baseURI' segmentsBase);         }         appendFragment(builder' refValue' segments);       } else {         appendScheme(builder' baseURI' segmentsBase);         appendAuthority(builder' baseURI' segmentsBase);         if (segments[4] < segments[5] && refValue[segments[4]] == '/') {           appendNormalizedPath(builder' refValue' segments);         } else {           var merged = new StringBuilder();           if (segmentsBase[2] >= 0 && segmentsBase[4] == segmentsBase[5]) {             merged.Append('/');             appendPath(merged' refValue' segments);             builder.Append(normalizePath(merged.ToString()));           } else {             merged.Append(               pathParent(   baseURI'   segmentsBase[4]'   segmentsBase[5]));             appendPath(merged' refValue' segments);             builder.Append(normalizePath(merged.ToString()));           }         }         appendQuery(builder' refValue' segments);         appendFragment(builder' refValue' segments);       }
Magic Number,PeterO.Cbor,URIUtility,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\URIUtility.cs,relativeResolve,The following statement contains a magic number: if (segments[0] >= 0) {  // scheme present         appendScheme(builder' refValue' segments);         appendAuthority(builder' refValue' segments);         appendNormalizedPath(builder' refValue' segments);         appendQuery(builder' refValue' segments);         appendFragment(builder' refValue' segments);       } else if (segments[2] >= 0) {  // authority present         appendScheme(builder' baseURI' segmentsBase);         appendAuthority(builder' refValue' segments);         appendNormalizedPath(builder' refValue' segments);         appendQuery(builder' refValue' segments);         appendFragment(builder' refValue' segments);       } else if (segments[4] == segments[5]) {         appendScheme(builder' baseURI' segmentsBase);         appendAuthority(builder' baseURI' segmentsBase);         appendPath(builder' baseURI' segmentsBase);         if (segments[6] >= 0) {           appendQuery(builder' refValue' segments);         } else {           appendQuery(builder' baseURI' segmentsBase);         }         appendFragment(builder' refValue' segments);       } else {         appendScheme(builder' baseURI' segmentsBase);         appendAuthority(builder' baseURI' segmentsBase);         if (segments[4] < segments[5] && refValue[segments[4]] == '/') {           appendNormalizedPath(builder' refValue' segments);         } else {           var merged = new StringBuilder();           if (segmentsBase[2] >= 0 && segmentsBase[4] == segmentsBase[5]) {             merged.Append('/');             appendPath(merged' refValue' segments);             builder.Append(normalizePath(merged.ToString()));           } else {             merged.Append(               pathParent(   baseURI'   segmentsBase[4]'   segmentsBase[5]));             appendPath(merged' refValue' segments);             builder.Append(normalizePath(merged.ToString()));           }         }         appendQuery(builder' refValue' segments);         appendFragment(builder' refValue' segments);       }
Magic Number,PeterO.Cbor,URIUtility,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\URIUtility.cs,relativeResolve,The following statement contains a magic number: if (segments[0] >= 0) {  // scheme present         appendScheme(builder' refValue' segments);         appendAuthority(builder' refValue' segments);         appendNormalizedPath(builder' refValue' segments);         appendQuery(builder' refValue' segments);         appendFragment(builder' refValue' segments);       } else if (segments[2] >= 0) {  // authority present         appendScheme(builder' baseURI' segmentsBase);         appendAuthority(builder' refValue' segments);         appendNormalizedPath(builder' refValue' segments);         appendQuery(builder' refValue' segments);         appendFragment(builder' refValue' segments);       } else if (segments[4] == segments[5]) {         appendScheme(builder' baseURI' segmentsBase);         appendAuthority(builder' baseURI' segmentsBase);         appendPath(builder' baseURI' segmentsBase);         if (segments[6] >= 0) {           appendQuery(builder' refValue' segments);         } else {           appendQuery(builder' baseURI' segmentsBase);         }         appendFragment(builder' refValue' segments);       } else {         appendScheme(builder' baseURI' segmentsBase);         appendAuthority(builder' baseURI' segmentsBase);         if (segments[4] < segments[5] && refValue[segments[4]] == '/') {           appendNormalizedPath(builder' refValue' segments);         } else {           var merged = new StringBuilder();           if (segmentsBase[2] >= 0 && segmentsBase[4] == segmentsBase[5]) {             merged.Append('/');             appendPath(merged' refValue' segments);             builder.Append(normalizePath(merged.ToString()));           } else {             merged.Append(               pathParent(   baseURI'   segmentsBase[4]'   segmentsBase[5]));             appendPath(merged' refValue' segments);             builder.Append(normalizePath(merged.ToString()));           }         }         appendQuery(builder' refValue' segments);         appendFragment(builder' refValue' segments);       }
Magic Number,PeterO.Cbor,URIUtility,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\URIUtility.cs,relativeResolve,The following statement contains a magic number: if (segments[0] >= 0) {  // scheme present         appendScheme(builder' refValue' segments);         appendAuthority(builder' refValue' segments);         appendNormalizedPath(builder' refValue' segments);         appendQuery(builder' refValue' segments);         appendFragment(builder' refValue' segments);       } else if (segments[2] >= 0) {  // authority present         appendScheme(builder' baseURI' segmentsBase);         appendAuthority(builder' refValue' segments);         appendNormalizedPath(builder' refValue' segments);         appendQuery(builder' refValue' segments);         appendFragment(builder' refValue' segments);       } else if (segments[4] == segments[5]) {         appendScheme(builder' baseURI' segmentsBase);         appendAuthority(builder' baseURI' segmentsBase);         appendPath(builder' baseURI' segmentsBase);         if (segments[6] >= 0) {           appendQuery(builder' refValue' segments);         } else {           appendQuery(builder' baseURI' segmentsBase);         }         appendFragment(builder' refValue' segments);       } else {         appendScheme(builder' baseURI' segmentsBase);         appendAuthority(builder' baseURI' segmentsBase);         if (segments[4] < segments[5] && refValue[segments[4]] == '/') {           appendNormalizedPath(builder' refValue' segments);         } else {           var merged = new StringBuilder();           if (segmentsBase[2] >= 0 && segmentsBase[4] == segmentsBase[5]) {             merged.Append('/');             appendPath(merged' refValue' segments);             builder.Append(normalizePath(merged.ToString()));           } else {             merged.Append(               pathParent(   baseURI'   segmentsBase[4]'   segmentsBase[5]));             appendPath(merged' refValue' segments);             builder.Append(normalizePath(merged.ToString()));           }         }         appendQuery(builder' refValue' segments);         appendFragment(builder' refValue' segments);       }
Magic Number,PeterO.Cbor,URIUtility,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\URIUtility.cs,relativeResolve,The following statement contains a magic number: if (segments[0] >= 0) {  // scheme present         appendScheme(builder' refValue' segments);         appendAuthority(builder' refValue' segments);         appendNormalizedPath(builder' refValue' segments);         appendQuery(builder' refValue' segments);         appendFragment(builder' refValue' segments);       } else if (segments[2] >= 0) {  // authority present         appendScheme(builder' baseURI' segmentsBase);         appendAuthority(builder' refValue' segments);         appendNormalizedPath(builder' refValue' segments);         appendQuery(builder' refValue' segments);         appendFragment(builder' refValue' segments);       } else if (segments[4] == segments[5]) {         appendScheme(builder' baseURI' segmentsBase);         appendAuthority(builder' baseURI' segmentsBase);         appendPath(builder' baseURI' segmentsBase);         if (segments[6] >= 0) {           appendQuery(builder' refValue' segments);         } else {           appendQuery(builder' baseURI' segmentsBase);         }         appendFragment(builder' refValue' segments);       } else {         appendScheme(builder' baseURI' segmentsBase);         appendAuthority(builder' baseURI' segmentsBase);         if (segments[4] < segments[5] && refValue[segments[4]] == '/') {           appendNormalizedPath(builder' refValue' segments);         } else {           var merged = new StringBuilder();           if (segmentsBase[2] >= 0 && segmentsBase[4] == segmentsBase[5]) {             merged.Append('/');             appendPath(merged' refValue' segments);             builder.Append(normalizePath(merged.ToString()));           } else {             merged.Append(               pathParent(   baseURI'   segmentsBase[4]'   segmentsBase[5]));             appendPath(merged' refValue' segments);             builder.Append(normalizePath(merged.ToString()));           }         }         appendQuery(builder' refValue' segments);         appendFragment(builder' refValue' segments);       }
Magic Number,PeterO.Cbor,URIUtility,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\URIUtility.cs,relativeResolve,The following statement contains a magic number: if (segments[0] >= 0) {  // scheme present         appendScheme(builder' refValue' segments);         appendAuthority(builder' refValue' segments);         appendNormalizedPath(builder' refValue' segments);         appendQuery(builder' refValue' segments);         appendFragment(builder' refValue' segments);       } else if (segments[2] >= 0) {  // authority present         appendScheme(builder' baseURI' segmentsBase);         appendAuthority(builder' refValue' segments);         appendNormalizedPath(builder' refValue' segments);         appendQuery(builder' refValue' segments);         appendFragment(builder' refValue' segments);       } else if (segments[4] == segments[5]) {         appendScheme(builder' baseURI' segmentsBase);         appendAuthority(builder' baseURI' segmentsBase);         appendPath(builder' baseURI' segmentsBase);         if (segments[6] >= 0) {           appendQuery(builder' refValue' segments);         } else {           appendQuery(builder' baseURI' segmentsBase);         }         appendFragment(builder' refValue' segments);       } else {         appendScheme(builder' baseURI' segmentsBase);         appendAuthority(builder' baseURI' segmentsBase);         if (segments[4] < segments[5] && refValue[segments[4]] == '/') {           appendNormalizedPath(builder' refValue' segments);         } else {           var merged = new StringBuilder();           if (segmentsBase[2] >= 0 && segmentsBase[4] == segmentsBase[5]) {             merged.Append('/');             appendPath(merged' refValue' segments);             builder.Append(normalizePath(merged.ToString()));           } else {             merged.Append(               pathParent(   baseURI'   segmentsBase[4]'   segmentsBase[5]));             appendPath(merged' refValue' segments);             builder.Append(normalizePath(merged.ToString()));           }         }         appendQuery(builder' refValue' segments);         appendFragment(builder' refValue' segments);       }
Magic Number,PeterO.Cbor,URIUtility,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\URIUtility.cs,relativeResolve,The following statement contains a magic number: if (segments[0] >= 0) {  // scheme present         appendScheme(builder' refValue' segments);         appendAuthority(builder' refValue' segments);         appendNormalizedPath(builder' refValue' segments);         appendQuery(builder' refValue' segments);         appendFragment(builder' refValue' segments);       } else if (segments[2] >= 0) {  // authority present         appendScheme(builder' baseURI' segmentsBase);         appendAuthority(builder' refValue' segments);         appendNormalizedPath(builder' refValue' segments);         appendQuery(builder' refValue' segments);         appendFragment(builder' refValue' segments);       } else if (segments[4] == segments[5]) {         appendScheme(builder' baseURI' segmentsBase);         appendAuthority(builder' baseURI' segmentsBase);         appendPath(builder' baseURI' segmentsBase);         if (segments[6] >= 0) {           appendQuery(builder' refValue' segments);         } else {           appendQuery(builder' baseURI' segmentsBase);         }         appendFragment(builder' refValue' segments);       } else {         appendScheme(builder' baseURI' segmentsBase);         appendAuthority(builder' baseURI' segmentsBase);         if (segments[4] < segments[5] && refValue[segments[4]] == '/') {           appendNormalizedPath(builder' refValue' segments);         } else {           var merged = new StringBuilder();           if (segmentsBase[2] >= 0 && segmentsBase[4] == segmentsBase[5]) {             merged.Append('/');             appendPath(merged' refValue' segments);             builder.Append(normalizePath(merged.ToString()));           } else {             merged.Append(               pathParent(   baseURI'   segmentsBase[4]'   segmentsBase[5]));             appendPath(merged' refValue' segments);             builder.Append(normalizePath(merged.ToString()));           }         }         appendQuery(builder' refValue' segments);         appendFragment(builder' refValue' segments);       }
Magic Number,PeterO.Cbor,URIUtility,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\URIUtility.cs,relativeResolve,The following statement contains a magic number: if (segments[0] >= 0) {  // scheme present         appendScheme(builder' refValue' segments);         appendAuthority(builder' refValue' segments);         appendNormalizedPath(builder' refValue' segments);         appendQuery(builder' refValue' segments);         appendFragment(builder' refValue' segments);       } else if (segments[2] >= 0) {  // authority present         appendScheme(builder' baseURI' segmentsBase);         appendAuthority(builder' refValue' segments);         appendNormalizedPath(builder' refValue' segments);         appendQuery(builder' refValue' segments);         appendFragment(builder' refValue' segments);       } else if (segments[4] == segments[5]) {         appendScheme(builder' baseURI' segmentsBase);         appendAuthority(builder' baseURI' segmentsBase);         appendPath(builder' baseURI' segmentsBase);         if (segments[6] >= 0) {           appendQuery(builder' refValue' segments);         } else {           appendQuery(builder' baseURI' segmentsBase);         }         appendFragment(builder' refValue' segments);       } else {         appendScheme(builder' baseURI' segmentsBase);         appendAuthority(builder' baseURI' segmentsBase);         if (segments[4] < segments[5] && refValue[segments[4]] == '/') {           appendNormalizedPath(builder' refValue' segments);         } else {           var merged = new StringBuilder();           if (segmentsBase[2] >= 0 && segmentsBase[4] == segmentsBase[5]) {             merged.Append('/');             appendPath(merged' refValue' segments);             builder.Append(normalizePath(merged.ToString()));           } else {             merged.Append(               pathParent(   baseURI'   segmentsBase[4]'   segmentsBase[5]));             appendPath(merged' refValue' segments);             builder.Append(normalizePath(merged.ToString()));           }         }         appendQuery(builder' refValue' segments);         appendFragment(builder' refValue' segments);       }
Magic Number,PeterO.Cbor,URIUtility,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\URIUtility.cs,splitIRI,The following statement contains a magic number: if (length == 0) {         retval[4] = 0;         retval[5] = 0;         return retval;       }
Magic Number,PeterO.Cbor,URIUtility,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\URIUtility.cs,splitIRI,The following statement contains a magic number: if (length == 0) {         retval[4] = 0;         retval[5] = 0;         return retval;       }
Magic Number,PeterO.Cbor,URIUtility,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\URIUtility.cs,splitIRI,The following statement contains a magic number: if (index + 2 <= valueSLength && s[index] == '/' && s[index + 1] == '/') {         // authority         // (index + 2' valueSLength)         index += 2;         int authorityStart = index;         retval[2] = authorityStart;         retval[3] = valueSLength;         state = 0;  // userinfo         // Check for userinfo         while (index < valueSLength) {           int c = s[index];           if (asciiOnly && c >= 0x80) {             return null;           }           if ((c & 0xfc00) == 0xd800 && index + 1 < valueSLength &&               s[index + 1] >= 0xdc00 && s[index + 1] <= 0xdfff) {             // Get the Unicode code point for the surrogate pair             c = 0x10000 + ((c - 0xd800) << 10) + (s[index + 1] - 0xdc00);             ++index;           } else if ((c & 0xf800) == 0xd800) {             if (parseMode == ParseMode.IRISurrogateLenient) {               c = 0xfffd;             } else {               return null;             }           }           if (c == '%' && (state == 0 || state == 1) && strict) {             // Percent encoded character (except in port)             if (index + 2 < valueSLength && isHexChar(s[index + 1]) &&                 isHexChar(s[index + 2])) {               index += 3;               continue;             }             return null;           }           if (state == 0) {  // User info             if (c == '/' || c == '?' || c == '#') {               // not user info               state = 1;               index = authorityStart;               continue;             }             if (strict && c == '@') {               // is user info               ++index;               state = 1;               continue;             }             if (strict && isIUserInfoChar(c)) {               ++index;               if (index == valueSLength) {                 // not user info                 state = 1;                 index = authorityStart;                 continue;               }             } else {               // not user info               state = 1;               index = authorityStart;               continue;             }           } else if (state == 1) {  // host             if (c == '/' || c == '?' || c == '#') {               // end of authority               retval[3] = index;               break;             }             if (!strict) {               ++index;             } else if (c == '[') {               ++index;               index = parseIPLiteral(s' index' valueSLength);               if (index < 0) {                 return null;               }               continue;             } else if (c == ':') {               // port               state = 2;               ++index;             } else if (isIRegNameChar(c)) {               // is valid host name char               // (note: IPv4 addresses included               // in ireg-name)               ++index;             } else {               return null;             }           } else if (state == 2) {  // Port             if (c == '/' || c == '?' || c == '#') {               // end of authority               retval[3] = index;               break;             }             if (c >= '0' && c <= '9') {               ++index;             } else {               return null;             }           }         }       }
Magic Number,PeterO.Cbor,URIUtility,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\URIUtility.cs,splitIRI,The following statement contains a magic number: if (index + 2 <= valueSLength && s[index] == '/' && s[index + 1] == '/') {         // authority         // (index + 2' valueSLength)         index += 2;         int authorityStart = index;         retval[2] = authorityStart;         retval[3] = valueSLength;         state = 0;  // userinfo         // Check for userinfo         while (index < valueSLength) {           int c = s[index];           if (asciiOnly && c >= 0x80) {             return null;           }           if ((c & 0xfc00) == 0xd800 && index + 1 < valueSLength &&               s[index + 1] >= 0xdc00 && s[index + 1] <= 0xdfff) {             // Get the Unicode code point for the surrogate pair             c = 0x10000 + ((c - 0xd800) << 10) + (s[index + 1] - 0xdc00);             ++index;           } else if ((c & 0xf800) == 0xd800) {             if (parseMode == ParseMode.IRISurrogateLenient) {               c = 0xfffd;             } else {               return null;             }           }           if (c == '%' && (state == 0 || state == 1) && strict) {             // Percent encoded character (except in port)             if (index + 2 < valueSLength && isHexChar(s[index + 1]) &&                 isHexChar(s[index + 2])) {               index += 3;               continue;             }             return null;           }           if (state == 0) {  // User info             if (c == '/' || c == '?' || c == '#') {               // not user info               state = 1;               index = authorityStart;               continue;             }             if (strict && c == '@') {               // is user info               ++index;               state = 1;               continue;             }             if (strict && isIUserInfoChar(c)) {               ++index;               if (index == valueSLength) {                 // not user info                 state = 1;                 index = authorityStart;                 continue;               }             } else {               // not user info               state = 1;               index = authorityStart;               continue;             }           } else if (state == 1) {  // host             if (c == '/' || c == '?' || c == '#') {               // end of authority               retval[3] = index;               break;             }             if (!strict) {               ++index;             } else if (c == '[') {               ++index;               index = parseIPLiteral(s' index' valueSLength);               if (index < 0) {                 return null;               }               continue;             } else if (c == ':') {               // port               state = 2;               ++index;             } else if (isIRegNameChar(c)) {               // is valid host name char               // (note: IPv4 addresses included               // in ireg-name)               ++index;             } else {               return null;             }           } else if (state == 2) {  // Port             if (c == '/' || c == '?' || c == '#') {               // end of authority               retval[3] = index;               break;             }             if (c >= '0' && c <= '9') {               ++index;             } else {               return null;             }           }         }       }
Magic Number,PeterO.Cbor,URIUtility,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\URIUtility.cs,splitIRI,The following statement contains a magic number: if (index + 2 <= valueSLength && s[index] == '/' && s[index + 1] == '/') {         // authority         // (index + 2' valueSLength)         index += 2;         int authorityStart = index;         retval[2] = authorityStart;         retval[3] = valueSLength;         state = 0;  // userinfo         // Check for userinfo         while (index < valueSLength) {           int c = s[index];           if (asciiOnly && c >= 0x80) {             return null;           }           if ((c & 0xfc00) == 0xd800 && index + 1 < valueSLength &&               s[index + 1] >= 0xdc00 && s[index + 1] <= 0xdfff) {             // Get the Unicode code point for the surrogate pair             c = 0x10000 + ((c - 0xd800) << 10) + (s[index + 1] - 0xdc00);             ++index;           } else if ((c & 0xf800) == 0xd800) {             if (parseMode == ParseMode.IRISurrogateLenient) {               c = 0xfffd;             } else {               return null;             }           }           if (c == '%' && (state == 0 || state == 1) && strict) {             // Percent encoded character (except in port)             if (index + 2 < valueSLength && isHexChar(s[index + 1]) &&                 isHexChar(s[index + 2])) {               index += 3;               continue;             }             return null;           }           if (state == 0) {  // User info             if (c == '/' || c == '?' || c == '#') {               // not user info               state = 1;               index = authorityStart;               continue;             }             if (strict && c == '@') {               // is user info               ++index;               state = 1;               continue;             }             if (strict && isIUserInfoChar(c)) {               ++index;               if (index == valueSLength) {                 // not user info                 state = 1;                 index = authorityStart;                 continue;               }             } else {               // not user info               state = 1;               index = authorityStart;               continue;             }           } else if (state == 1) {  // host             if (c == '/' || c == '?' || c == '#') {               // end of authority               retval[3] = index;               break;             }             if (!strict) {               ++index;             } else if (c == '[') {               ++index;               index = parseIPLiteral(s' index' valueSLength);               if (index < 0) {                 return null;               }               continue;             } else if (c == ':') {               // port               state = 2;               ++index;             } else if (isIRegNameChar(c)) {               // is valid host name char               // (note: IPv4 addresses included               // in ireg-name)               ++index;             } else {               return null;             }           } else if (state == 2) {  // Port             if (c == '/' || c == '?' || c == '#') {               // end of authority               retval[3] = index;               break;             }             if (c >= '0' && c <= '9') {               ++index;             } else {               return null;             }           }         }       }
Magic Number,PeterO.Cbor,URIUtility,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\URIUtility.cs,splitIRI,The following statement contains a magic number: if (index + 2 <= valueSLength && s[index] == '/' && s[index + 1] == '/') {         // authority         // (index + 2' valueSLength)         index += 2;         int authorityStart = index;         retval[2] = authorityStart;         retval[3] = valueSLength;         state = 0;  // userinfo         // Check for userinfo         while (index < valueSLength) {           int c = s[index];           if (asciiOnly && c >= 0x80) {             return null;           }           if ((c & 0xfc00) == 0xd800 && index + 1 < valueSLength &&               s[index + 1] >= 0xdc00 && s[index + 1] <= 0xdfff) {             // Get the Unicode code point for the surrogate pair             c = 0x10000 + ((c - 0xd800) << 10) + (s[index + 1] - 0xdc00);             ++index;           } else if ((c & 0xf800) == 0xd800) {             if (parseMode == ParseMode.IRISurrogateLenient) {               c = 0xfffd;             } else {               return null;             }           }           if (c == '%' && (state == 0 || state == 1) && strict) {             // Percent encoded character (except in port)             if (index + 2 < valueSLength && isHexChar(s[index + 1]) &&                 isHexChar(s[index + 2])) {               index += 3;               continue;             }             return null;           }           if (state == 0) {  // User info             if (c == '/' || c == '?' || c == '#') {               // not user info               state = 1;               index = authorityStart;               continue;             }             if (strict && c == '@') {               // is user info               ++index;               state = 1;               continue;             }             if (strict && isIUserInfoChar(c)) {               ++index;               if (index == valueSLength) {                 // not user info                 state = 1;                 index = authorityStart;                 continue;               }             } else {               // not user info               state = 1;               index = authorityStart;               continue;             }           } else if (state == 1) {  // host             if (c == '/' || c == '?' || c == '#') {               // end of authority               retval[3] = index;               break;             }             if (!strict) {               ++index;             } else if (c == '[') {               ++index;               index = parseIPLiteral(s' index' valueSLength);               if (index < 0) {                 return null;               }               continue;             } else if (c == ':') {               // port               state = 2;               ++index;             } else if (isIRegNameChar(c)) {               // is valid host name char               // (note: IPv4 addresses included               // in ireg-name)               ++index;             } else {               return null;             }           } else if (state == 2) {  // Port             if (c == '/' || c == '?' || c == '#') {               // end of authority               retval[3] = index;               break;             }             if (c >= '0' && c <= '9') {               ++index;             } else {               return null;             }           }         }       }
Magic Number,PeterO.Cbor,URIUtility,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\URIUtility.cs,splitIRI,The following statement contains a magic number: if (index + 2 <= valueSLength && s[index] == '/' && s[index + 1] == '/') {         // authority         // (index + 2' valueSLength)         index += 2;         int authorityStart = index;         retval[2] = authorityStart;         retval[3] = valueSLength;         state = 0;  // userinfo         // Check for userinfo         while (index < valueSLength) {           int c = s[index];           if (asciiOnly && c >= 0x80) {             return null;           }           if ((c & 0xfc00) == 0xd800 && index + 1 < valueSLength &&               s[index + 1] >= 0xdc00 && s[index + 1] <= 0xdfff) {             // Get the Unicode code point for the surrogate pair             c = 0x10000 + ((c - 0xd800) << 10) + (s[index + 1] - 0xdc00);             ++index;           } else if ((c & 0xf800) == 0xd800) {             if (parseMode == ParseMode.IRISurrogateLenient) {               c = 0xfffd;             } else {               return null;             }           }           if (c == '%' && (state == 0 || state == 1) && strict) {             // Percent encoded character (except in port)             if (index + 2 < valueSLength && isHexChar(s[index + 1]) &&                 isHexChar(s[index + 2])) {               index += 3;               continue;             }             return null;           }           if (state == 0) {  // User info             if (c == '/' || c == '?' || c == '#') {               // not user info               state = 1;               index = authorityStart;               continue;             }             if (strict && c == '@') {               // is user info               ++index;               state = 1;               continue;             }             if (strict && isIUserInfoChar(c)) {               ++index;               if (index == valueSLength) {                 // not user info                 state = 1;                 index = authorityStart;                 continue;               }             } else {               // not user info               state = 1;               index = authorityStart;               continue;             }           } else if (state == 1) {  // host             if (c == '/' || c == '?' || c == '#') {               // end of authority               retval[3] = index;               break;             }             if (!strict) {               ++index;             } else if (c == '[') {               ++index;               index = parseIPLiteral(s' index' valueSLength);               if (index < 0) {                 return null;               }               continue;             } else if (c == ':') {               // port               state = 2;               ++index;             } else if (isIRegNameChar(c)) {               // is valid host name char               // (note: IPv4 addresses included               // in ireg-name)               ++index;             } else {               return null;             }           } else if (state == 2) {  // Port             if (c == '/' || c == '?' || c == '#') {               // end of authority               retval[3] = index;               break;             }             if (c >= '0' && c <= '9') {               ++index;             } else {               return null;             }           }         }       }
Magic Number,PeterO.Cbor,URIUtility,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\URIUtility.cs,splitIRI,The following statement contains a magic number: if (index + 2 <= valueSLength && s[index] == '/' && s[index + 1] == '/') {         // authority         // (index + 2' valueSLength)         index += 2;         int authorityStart = index;         retval[2] = authorityStart;         retval[3] = valueSLength;         state = 0;  // userinfo         // Check for userinfo         while (index < valueSLength) {           int c = s[index];           if (asciiOnly && c >= 0x80) {             return null;           }           if ((c & 0xfc00) == 0xd800 && index + 1 < valueSLength &&               s[index + 1] >= 0xdc00 && s[index + 1] <= 0xdfff) {             // Get the Unicode code point for the surrogate pair             c = 0x10000 + ((c - 0xd800) << 10) + (s[index + 1] - 0xdc00);             ++index;           } else if ((c & 0xf800) == 0xd800) {             if (parseMode == ParseMode.IRISurrogateLenient) {               c = 0xfffd;             } else {               return null;             }           }           if (c == '%' && (state == 0 || state == 1) && strict) {             // Percent encoded character (except in port)             if (index + 2 < valueSLength && isHexChar(s[index + 1]) &&                 isHexChar(s[index + 2])) {               index += 3;               continue;             }             return null;           }           if (state == 0) {  // User info             if (c == '/' || c == '?' || c == '#') {               // not user info               state = 1;               index = authorityStart;               continue;             }             if (strict && c == '@') {               // is user info               ++index;               state = 1;               continue;             }             if (strict && isIUserInfoChar(c)) {               ++index;               if (index == valueSLength) {                 // not user info                 state = 1;                 index = authorityStart;                 continue;               }             } else {               // not user info               state = 1;               index = authorityStart;               continue;             }           } else if (state == 1) {  // host             if (c == '/' || c == '?' || c == '#') {               // end of authority               retval[3] = index;               break;             }             if (!strict) {               ++index;             } else if (c == '[') {               ++index;               index = parseIPLiteral(s' index' valueSLength);               if (index < 0) {                 return null;               }               continue;             } else if (c == ':') {               // port               state = 2;               ++index;             } else if (isIRegNameChar(c)) {               // is valid host name char               // (note: IPv4 addresses included               // in ireg-name)               ++index;             } else {               return null;             }           } else if (state == 2) {  // Port             if (c == '/' || c == '?' || c == '#') {               // end of authority               retval[3] = index;               break;             }             if (c >= '0' && c <= '9') {               ++index;             } else {               return null;             }           }         }       }
Magic Number,PeterO.Cbor,URIUtility,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\URIUtility.cs,splitIRI,The following statement contains a magic number: if (index + 2 <= valueSLength && s[index] == '/' && s[index + 1] == '/') {         // authority         // (index + 2' valueSLength)         index += 2;         int authorityStart = index;         retval[2] = authorityStart;         retval[3] = valueSLength;         state = 0;  // userinfo         // Check for userinfo         while (index < valueSLength) {           int c = s[index];           if (asciiOnly && c >= 0x80) {             return null;           }           if ((c & 0xfc00) == 0xd800 && index + 1 < valueSLength &&               s[index + 1] >= 0xdc00 && s[index + 1] <= 0xdfff) {             // Get the Unicode code point for the surrogate pair             c = 0x10000 + ((c - 0xd800) << 10) + (s[index + 1] - 0xdc00);             ++index;           } else if ((c & 0xf800) == 0xd800) {             if (parseMode == ParseMode.IRISurrogateLenient) {               c = 0xfffd;             } else {               return null;             }           }           if (c == '%' && (state == 0 || state == 1) && strict) {             // Percent encoded character (except in port)             if (index + 2 < valueSLength && isHexChar(s[index + 1]) &&                 isHexChar(s[index + 2])) {               index += 3;               continue;             }             return null;           }           if (state == 0) {  // User info             if (c == '/' || c == '?' || c == '#') {               // not user info               state = 1;               index = authorityStart;               continue;             }             if (strict && c == '@') {               // is user info               ++index;               state = 1;               continue;             }             if (strict && isIUserInfoChar(c)) {               ++index;               if (index == valueSLength) {                 // not user info                 state = 1;                 index = authorityStart;                 continue;               }             } else {               // not user info               state = 1;               index = authorityStart;               continue;             }           } else if (state == 1) {  // host             if (c == '/' || c == '?' || c == '#') {               // end of authority               retval[3] = index;               break;             }             if (!strict) {               ++index;             } else if (c == '[') {               ++index;               index = parseIPLiteral(s' index' valueSLength);               if (index < 0) {                 return null;               }               continue;             } else if (c == ':') {               // port               state = 2;               ++index;             } else if (isIRegNameChar(c)) {               // is valid host name char               // (note: IPv4 addresses included               // in ireg-name)               ++index;             } else {               return null;             }           } else if (state == 2) {  // Port             if (c == '/' || c == '?' || c == '#') {               // end of authority               retval[3] = index;               break;             }             if (c >= '0' && c <= '9') {               ++index;             } else {               return null;             }           }         }       }
Magic Number,PeterO.Cbor,URIUtility,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\URIUtility.cs,splitIRI,The following statement contains a magic number: if (index + 2 <= valueSLength && s[index] == '/' && s[index + 1] == '/') {         // authority         // (index + 2' valueSLength)         index += 2;         int authorityStart = index;         retval[2] = authorityStart;         retval[3] = valueSLength;         state = 0;  // userinfo         // Check for userinfo         while (index < valueSLength) {           int c = s[index];           if (asciiOnly && c >= 0x80) {             return null;           }           if ((c & 0xfc00) == 0xd800 && index + 1 < valueSLength &&               s[index + 1] >= 0xdc00 && s[index + 1] <= 0xdfff) {             // Get the Unicode code point for the surrogate pair             c = 0x10000 + ((c - 0xd800) << 10) + (s[index + 1] - 0xdc00);             ++index;           } else if ((c & 0xf800) == 0xd800) {             if (parseMode == ParseMode.IRISurrogateLenient) {               c = 0xfffd;             } else {               return null;             }           }           if (c == '%' && (state == 0 || state == 1) && strict) {             // Percent encoded character (except in port)             if (index + 2 < valueSLength && isHexChar(s[index + 1]) &&                 isHexChar(s[index + 2])) {               index += 3;               continue;             }             return null;           }           if (state == 0) {  // User info             if (c == '/' || c == '?' || c == '#') {               // not user info               state = 1;               index = authorityStart;               continue;             }             if (strict && c == '@') {               // is user info               ++index;               state = 1;               continue;             }             if (strict && isIUserInfoChar(c)) {               ++index;               if (index == valueSLength) {                 // not user info                 state = 1;                 index = authorityStart;                 continue;               }             } else {               // not user info               state = 1;               index = authorityStart;               continue;             }           } else if (state == 1) {  // host             if (c == '/' || c == '?' || c == '#') {               // end of authority               retval[3] = index;               break;             }             if (!strict) {               ++index;             } else if (c == '[') {               ++index;               index = parseIPLiteral(s' index' valueSLength);               if (index < 0) {                 return null;               }               continue;             } else if (c == ':') {               // port               state = 2;               ++index;             } else if (isIRegNameChar(c)) {               // is valid host name char               // (note: IPv4 addresses included               // in ireg-name)               ++index;             } else {               return null;             }           } else if (state == 2) {  // Port             if (c == '/' || c == '?' || c == '#') {               // end of authority               retval[3] = index;               break;             }             if (c >= '0' && c <= '9') {               ++index;             } else {               return null;             }           }         }       }
Magic Number,PeterO.Cbor,URIUtility,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\URIUtility.cs,splitIRI,The following statement contains a magic number: if (index + 2 <= valueSLength && s[index] == '/' && s[index + 1] == '/') {         // authority         // (index + 2' valueSLength)         index += 2;         int authorityStart = index;         retval[2] = authorityStart;         retval[3] = valueSLength;         state = 0;  // userinfo         // Check for userinfo         while (index < valueSLength) {           int c = s[index];           if (asciiOnly && c >= 0x80) {             return null;           }           if ((c & 0xfc00) == 0xd800 && index + 1 < valueSLength &&               s[index + 1] >= 0xdc00 && s[index + 1] <= 0xdfff) {             // Get the Unicode code point for the surrogate pair             c = 0x10000 + ((c - 0xd800) << 10) + (s[index + 1] - 0xdc00);             ++index;           } else if ((c & 0xf800) == 0xd800) {             if (parseMode == ParseMode.IRISurrogateLenient) {               c = 0xfffd;             } else {               return null;             }           }           if (c == '%' && (state == 0 || state == 1) && strict) {             // Percent encoded character (except in port)             if (index + 2 < valueSLength && isHexChar(s[index + 1]) &&                 isHexChar(s[index + 2])) {               index += 3;               continue;             }             return null;           }           if (state == 0) {  // User info             if (c == '/' || c == '?' || c == '#') {               // not user info               state = 1;               index = authorityStart;               continue;             }             if (strict && c == '@') {               // is user info               ++index;               state = 1;               continue;             }             if (strict && isIUserInfoChar(c)) {               ++index;               if (index == valueSLength) {                 // not user info                 state = 1;                 index = authorityStart;                 continue;               }             } else {               // not user info               state = 1;               index = authorityStart;               continue;             }           } else if (state == 1) {  // host             if (c == '/' || c == '?' || c == '#') {               // end of authority               retval[3] = index;               break;             }             if (!strict) {               ++index;             } else if (c == '[') {               ++index;               index = parseIPLiteral(s' index' valueSLength);               if (index < 0) {                 return null;               }               continue;             } else if (c == ':') {               // port               state = 2;               ++index;             } else if (isIRegNameChar(c)) {               // is valid host name char               // (note: IPv4 addresses included               // in ireg-name)               ++index;             } else {               return null;             }           } else if (state == 2) {  // Port             if (c == '/' || c == '?' || c == '#') {               // end of authority               retval[3] = index;               break;             }             if (c >= '0' && c <= '9') {               ++index;             } else {               return null;             }           }         }       }
Magic Number,PeterO.Cbor,URIUtility,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\URIUtility.cs,splitIRI,The following statement contains a magic number: if (index + 2 <= valueSLength && s[index] == '/' && s[index + 1] == '/') {         // authority         // (index + 2' valueSLength)         index += 2;         int authorityStart = index;         retval[2] = authorityStart;         retval[3] = valueSLength;         state = 0;  // userinfo         // Check for userinfo         while (index < valueSLength) {           int c = s[index];           if (asciiOnly && c >= 0x80) {             return null;           }           if ((c & 0xfc00) == 0xd800 && index + 1 < valueSLength &&               s[index + 1] >= 0xdc00 && s[index + 1] <= 0xdfff) {             // Get the Unicode code point for the surrogate pair             c = 0x10000 + ((c - 0xd800) << 10) + (s[index + 1] - 0xdc00);             ++index;           } else if ((c & 0xf800) == 0xd800) {             if (parseMode == ParseMode.IRISurrogateLenient) {               c = 0xfffd;             } else {               return null;             }           }           if (c == '%' && (state == 0 || state == 1) && strict) {             // Percent encoded character (except in port)             if (index + 2 < valueSLength && isHexChar(s[index + 1]) &&                 isHexChar(s[index + 2])) {               index += 3;               continue;             }             return null;           }           if (state == 0) {  // User info             if (c == '/' || c == '?' || c == '#') {               // not user info               state = 1;               index = authorityStart;               continue;             }             if (strict && c == '@') {               // is user info               ++index;               state = 1;               continue;             }             if (strict && isIUserInfoChar(c)) {               ++index;               if (index == valueSLength) {                 // not user info                 state = 1;                 index = authorityStart;                 continue;               }             } else {               // not user info               state = 1;               index = authorityStart;               continue;             }           } else if (state == 1) {  // host             if (c == '/' || c == '?' || c == '#') {               // end of authority               retval[3] = index;               break;             }             if (!strict) {               ++index;             } else if (c == '[') {               ++index;               index = parseIPLiteral(s' index' valueSLength);               if (index < 0) {                 return null;               }               continue;             } else if (c == ':') {               // port               state = 2;               ++index;             } else if (isIRegNameChar(c)) {               // is valid host name char               // (note: IPv4 addresses included               // in ireg-name)               ++index;             } else {               return null;             }           } else if (state == 2) {  // Port             if (c == '/' || c == '?' || c == '#') {               // end of authority               retval[3] = index;               break;             }             if (c >= '0' && c <= '9') {               ++index;             } else {               return null;             }           }         }       }
Magic Number,PeterO.Cbor,URIUtility,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\URIUtility.cs,splitIRI,The following statement contains a magic number: if (index + 2 <= valueSLength && s[index] == '/' && s[index + 1] == '/') {         // authority         // (index + 2' valueSLength)         index += 2;         int authorityStart = index;         retval[2] = authorityStart;         retval[3] = valueSLength;         state = 0;  // userinfo         // Check for userinfo         while (index < valueSLength) {           int c = s[index];           if (asciiOnly && c >= 0x80) {             return null;           }           if ((c & 0xfc00) == 0xd800 && index + 1 < valueSLength &&               s[index + 1] >= 0xdc00 && s[index + 1] <= 0xdfff) {             // Get the Unicode code point for the surrogate pair             c = 0x10000 + ((c - 0xd800) << 10) + (s[index + 1] - 0xdc00);             ++index;           } else if ((c & 0xf800) == 0xd800) {             if (parseMode == ParseMode.IRISurrogateLenient) {               c = 0xfffd;             } else {               return null;             }           }           if (c == '%' && (state == 0 || state == 1) && strict) {             // Percent encoded character (except in port)             if (index + 2 < valueSLength && isHexChar(s[index + 1]) &&                 isHexChar(s[index + 2])) {               index += 3;               continue;             }             return null;           }           if (state == 0) {  // User info             if (c == '/' || c == '?' || c == '#') {               // not user info               state = 1;               index = authorityStart;               continue;             }             if (strict && c == '@') {               // is user info               ++index;               state = 1;               continue;             }             if (strict && isIUserInfoChar(c)) {               ++index;               if (index == valueSLength) {                 // not user info                 state = 1;                 index = authorityStart;                 continue;               }             } else {               // not user info               state = 1;               index = authorityStart;               continue;             }           } else if (state == 1) {  // host             if (c == '/' || c == '?' || c == '#') {               // end of authority               retval[3] = index;               break;             }             if (!strict) {               ++index;             } else if (c == '[') {               ++index;               index = parseIPLiteral(s' index' valueSLength);               if (index < 0) {                 return null;               }               continue;             } else if (c == ':') {               // port               state = 2;               ++index;             } else if (isIRegNameChar(c)) {               // is valid host name char               // (note: IPv4 addresses included               // in ireg-name)               ++index;             } else {               return null;             }           } else if (state == 2) {  // Port             if (c == '/' || c == '?' || c == '#') {               // end of authority               retval[3] = index;               break;             }             if (c >= '0' && c <= '9') {               ++index;             } else {               return null;             }           }         }       }
Magic Number,PeterO.Cbor,URIUtility,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\URIUtility.cs,splitIRI,The following statement contains a magic number: if (index + 2 <= valueSLength && s[index] == '/' && s[index + 1] == '/') {         // authority         // (index + 2' valueSLength)         index += 2;         int authorityStart = index;         retval[2] = authorityStart;         retval[3] = valueSLength;         state = 0;  // userinfo         // Check for userinfo         while (index < valueSLength) {           int c = s[index];           if (asciiOnly && c >= 0x80) {             return null;           }           if ((c & 0xfc00) == 0xd800 && index + 1 < valueSLength &&               s[index + 1] >= 0xdc00 && s[index + 1] <= 0xdfff) {             // Get the Unicode code point for the surrogate pair             c = 0x10000 + ((c - 0xd800) << 10) + (s[index + 1] - 0xdc00);             ++index;           } else if ((c & 0xf800) == 0xd800) {             if (parseMode == ParseMode.IRISurrogateLenient) {               c = 0xfffd;             } else {               return null;             }           }           if (c == '%' && (state == 0 || state == 1) && strict) {             // Percent encoded character (except in port)             if (index + 2 < valueSLength && isHexChar(s[index + 1]) &&                 isHexChar(s[index + 2])) {               index += 3;               continue;             }             return null;           }           if (state == 0) {  // User info             if (c == '/' || c == '?' || c == '#') {               // not user info               state = 1;               index = authorityStart;               continue;             }             if (strict && c == '@') {               // is user info               ++index;               state = 1;               continue;             }             if (strict && isIUserInfoChar(c)) {               ++index;               if (index == valueSLength) {                 // not user info                 state = 1;                 index = authorityStart;                 continue;               }             } else {               // not user info               state = 1;               index = authorityStart;               continue;             }           } else if (state == 1) {  // host             if (c == '/' || c == '?' || c == '#') {               // end of authority               retval[3] = index;               break;             }             if (!strict) {               ++index;             } else if (c == '[') {               ++index;               index = parseIPLiteral(s' index' valueSLength);               if (index < 0) {                 return null;               }               continue;             } else if (c == ':') {               // port               state = 2;               ++index;             } else if (isIRegNameChar(c)) {               // is valid host name char               // (note: IPv4 addresses included               // in ireg-name)               ++index;             } else {               return null;             }           } else if (state == 2) {  // Port             if (c == '/' || c == '?' || c == '#') {               // end of authority               retval[3] = index;               break;             }             if (c >= '0' && c <= '9') {               ++index;             } else {               return null;             }           }         }       }
Magic Number,PeterO.Cbor,URIUtility,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\URIUtility.cs,splitIRI,The following statement contains a magic number: retval[4] = index;
Magic Number,PeterO.Cbor,URIUtility,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\URIUtility.cs,splitIRI,The following statement contains a magic number: retval[5] = valueSLength;
Magic Number,PeterO.Cbor,URIUtility,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\URIUtility.cs,splitIRI,The following statement contains a magic number: while (index < valueSLength) {         // Get the next Unicode character         int c = s[index];         if (asciiOnly && c >= 0x80) {           return null;         }         if ((c & 0xfc00) == 0xd800 && index + 1 < valueSLength &&             s[index + 1] >= 0xdc00 && s[index + 1] <= 0xdfff) {           // Get the Unicode code point for the surrogate pair           c = 0x10000 + ((c - 0xd800) << 10) + (s[index + 1] - 0xdc00);           ++index;         } else if ((c & 0xf800) == 0xd800) {           // error           return null;         }         if (c == '%' && strict) {           // Percent encoded character           if (index + 2 < valueSLength && isHexChar(s[index + 1]) &&               isHexChar(s[index + 2])) {             index += 3;             continue;           }           return null;         }         if (state == 0) {  // Path           if (c == ':' && fullyRelative) {             colon = true;           } else if (c == '/' && fullyRelative && !segment) {             // noscheme path can't have colon before slash             if (strict && colon) {               return null;             }             segment = true;           }           if (c == '?') {             retval[5] = index;             retval[6] = index + 1;             retval[7] = valueSLength;             state = 1;  // move to query state           } else if (c == '#') {             retval[5] = index;             retval[8] = index + 1;             retval[9] = valueSLength;             state = 2;  // move to fragment state           } else if (strict && !isIpchar(c)) {             return null;           }           ++index;         } else if (state == 1) {  // Query           if (c == '#') {             retval[7] = index;             retval[8] = index + 1;             retval[9] = valueSLength;             state = 2;  // move to fragment state           } else if (strict && !isIqueryChar(c)) {             return null;           }           ++index;         } else if (state == 2) {  // Fragment           if (strict && !isIfragmentChar(c)) {             return null;           }           ++index;         }       }
Magic Number,PeterO.Cbor,URIUtility,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\URIUtility.cs,splitIRI,The following statement contains a magic number: while (index < valueSLength) {         // Get the next Unicode character         int c = s[index];         if (asciiOnly && c >= 0x80) {           return null;         }         if ((c & 0xfc00) == 0xd800 && index + 1 < valueSLength &&             s[index + 1] >= 0xdc00 && s[index + 1] <= 0xdfff) {           // Get the Unicode code point for the surrogate pair           c = 0x10000 + ((c - 0xd800) << 10) + (s[index + 1] - 0xdc00);           ++index;         } else if ((c & 0xf800) == 0xd800) {           // error           return null;         }         if (c == '%' && strict) {           // Percent encoded character           if (index + 2 < valueSLength && isHexChar(s[index + 1]) &&               isHexChar(s[index + 2])) {             index += 3;             continue;           }           return null;         }         if (state == 0) {  // Path           if (c == ':' && fullyRelative) {             colon = true;           } else if (c == '/' && fullyRelative && !segment) {             // noscheme path can't have colon before slash             if (strict && colon) {               return null;             }             segment = true;           }           if (c == '?') {             retval[5] = index;             retval[6] = index + 1;             retval[7] = valueSLength;             state = 1;  // move to query state           } else if (c == '#') {             retval[5] = index;             retval[8] = index + 1;             retval[9] = valueSLength;             state = 2;  // move to fragment state           } else if (strict && !isIpchar(c)) {             return null;           }           ++index;         } else if (state == 1) {  // Query           if (c == '#') {             retval[7] = index;             retval[8] = index + 1;             retval[9] = valueSLength;             state = 2;  // move to fragment state           } else if (strict && !isIqueryChar(c)) {             return null;           }           ++index;         } else if (state == 2) {  // Fragment           if (strict && !isIfragmentChar(c)) {             return null;           }           ++index;         }       }
Magic Number,PeterO.Cbor,URIUtility,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\URIUtility.cs,splitIRI,The following statement contains a magic number: while (index < valueSLength) {         // Get the next Unicode character         int c = s[index];         if (asciiOnly && c >= 0x80) {           return null;         }         if ((c & 0xfc00) == 0xd800 && index + 1 < valueSLength &&             s[index + 1] >= 0xdc00 && s[index + 1] <= 0xdfff) {           // Get the Unicode code point for the surrogate pair           c = 0x10000 + ((c - 0xd800) << 10) + (s[index + 1] - 0xdc00);           ++index;         } else if ((c & 0xf800) == 0xd800) {           // error           return null;         }         if (c == '%' && strict) {           // Percent encoded character           if (index + 2 < valueSLength && isHexChar(s[index + 1]) &&               isHexChar(s[index + 2])) {             index += 3;             continue;           }           return null;         }         if (state == 0) {  // Path           if (c == ':' && fullyRelative) {             colon = true;           } else if (c == '/' && fullyRelative && !segment) {             // noscheme path can't have colon before slash             if (strict && colon) {               return null;             }             segment = true;           }           if (c == '?') {             retval[5] = index;             retval[6] = index + 1;             retval[7] = valueSLength;             state = 1;  // move to query state           } else if (c == '#') {             retval[5] = index;             retval[8] = index + 1;             retval[9] = valueSLength;             state = 2;  // move to fragment state           } else if (strict && !isIpchar(c)) {             return null;           }           ++index;         } else if (state == 1) {  // Query           if (c == '#') {             retval[7] = index;             retval[8] = index + 1;             retval[9] = valueSLength;             state = 2;  // move to fragment state           } else if (strict && !isIqueryChar(c)) {             return null;           }           ++index;         } else if (state == 2) {  // Fragment           if (strict && !isIfragmentChar(c)) {             return null;           }           ++index;         }       }
Magic Number,PeterO.Cbor,URIUtility,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\URIUtility.cs,splitIRI,The following statement contains a magic number: while (index < valueSLength) {         // Get the next Unicode character         int c = s[index];         if (asciiOnly && c >= 0x80) {           return null;         }         if ((c & 0xfc00) == 0xd800 && index + 1 < valueSLength &&             s[index + 1] >= 0xdc00 && s[index + 1] <= 0xdfff) {           // Get the Unicode code point for the surrogate pair           c = 0x10000 + ((c - 0xd800) << 10) + (s[index + 1] - 0xdc00);           ++index;         } else if ((c & 0xf800) == 0xd800) {           // error           return null;         }         if (c == '%' && strict) {           // Percent encoded character           if (index + 2 < valueSLength && isHexChar(s[index + 1]) &&               isHexChar(s[index + 2])) {             index += 3;             continue;           }           return null;         }         if (state == 0) {  // Path           if (c == ':' && fullyRelative) {             colon = true;           } else if (c == '/' && fullyRelative && !segment) {             // noscheme path can't have colon before slash             if (strict && colon) {               return null;             }             segment = true;           }           if (c == '?') {             retval[5] = index;             retval[6] = index + 1;             retval[7] = valueSLength;             state = 1;  // move to query state           } else if (c == '#') {             retval[5] = index;             retval[8] = index + 1;             retval[9] = valueSLength;             state = 2;  // move to fragment state           } else if (strict && !isIpchar(c)) {             return null;           }           ++index;         } else if (state == 1) {  // Query           if (c == '#') {             retval[7] = index;             retval[8] = index + 1;             retval[9] = valueSLength;             state = 2;  // move to fragment state           } else if (strict && !isIqueryChar(c)) {             return null;           }           ++index;         } else if (state == 2) {  // Fragment           if (strict && !isIfragmentChar(c)) {             return null;           }           ++index;         }       }
Magic Number,PeterO.Cbor,URIUtility,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\URIUtility.cs,splitIRI,The following statement contains a magic number: while (index < valueSLength) {         // Get the next Unicode character         int c = s[index];         if (asciiOnly && c >= 0x80) {           return null;         }         if ((c & 0xfc00) == 0xd800 && index + 1 < valueSLength &&             s[index + 1] >= 0xdc00 && s[index + 1] <= 0xdfff) {           // Get the Unicode code point for the surrogate pair           c = 0x10000 + ((c - 0xd800) << 10) + (s[index + 1] - 0xdc00);           ++index;         } else if ((c & 0xf800) == 0xd800) {           // error           return null;         }         if (c == '%' && strict) {           // Percent encoded character           if (index + 2 < valueSLength && isHexChar(s[index + 1]) &&               isHexChar(s[index + 2])) {             index += 3;             continue;           }           return null;         }         if (state == 0) {  // Path           if (c == ':' && fullyRelative) {             colon = true;           } else if (c == '/' && fullyRelative && !segment) {             // noscheme path can't have colon before slash             if (strict && colon) {               return null;             }             segment = true;           }           if (c == '?') {             retval[5] = index;             retval[6] = index + 1;             retval[7] = valueSLength;             state = 1;  // move to query state           } else if (c == '#') {             retval[5] = index;             retval[8] = index + 1;             retval[9] = valueSLength;             state = 2;  // move to fragment state           } else if (strict && !isIpchar(c)) {             return null;           }           ++index;         } else if (state == 1) {  // Query           if (c == '#') {             retval[7] = index;             retval[8] = index + 1;             retval[9] = valueSLength;             state = 2;  // move to fragment state           } else if (strict && !isIqueryChar(c)) {             return null;           }           ++index;         } else if (state == 2) {  // Fragment           if (strict && !isIfragmentChar(c)) {             return null;           }           ++index;         }       }
Magic Number,PeterO.Cbor,URIUtility,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\URIUtility.cs,splitIRI,The following statement contains a magic number: while (index < valueSLength) {         // Get the next Unicode character         int c = s[index];         if (asciiOnly && c >= 0x80) {           return null;         }         if ((c & 0xfc00) == 0xd800 && index + 1 < valueSLength &&             s[index + 1] >= 0xdc00 && s[index + 1] <= 0xdfff) {           // Get the Unicode code point for the surrogate pair           c = 0x10000 + ((c - 0xd800) << 10) + (s[index + 1] - 0xdc00);           ++index;         } else if ((c & 0xf800) == 0xd800) {           // error           return null;         }         if (c == '%' && strict) {           // Percent encoded character           if (index + 2 < valueSLength && isHexChar(s[index + 1]) &&               isHexChar(s[index + 2])) {             index += 3;             continue;           }           return null;         }         if (state == 0) {  // Path           if (c == ':' && fullyRelative) {             colon = true;           } else if (c == '/' && fullyRelative && !segment) {             // noscheme path can't have colon before slash             if (strict && colon) {               return null;             }             segment = true;           }           if (c == '?') {             retval[5] = index;             retval[6] = index + 1;             retval[7] = valueSLength;             state = 1;  // move to query state           } else if (c == '#') {             retval[5] = index;             retval[8] = index + 1;             retval[9] = valueSLength;             state = 2;  // move to fragment state           } else if (strict && !isIpchar(c)) {             return null;           }           ++index;         } else if (state == 1) {  // Query           if (c == '#') {             retval[7] = index;             retval[8] = index + 1;             retval[9] = valueSLength;             state = 2;  // move to fragment state           } else if (strict && !isIqueryChar(c)) {             return null;           }           ++index;         } else if (state == 2) {  // Fragment           if (strict && !isIfragmentChar(c)) {             return null;           }           ++index;         }       }
Magic Number,PeterO.Cbor,URIUtility,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\URIUtility.cs,splitIRI,The following statement contains a magic number: while (index < valueSLength) {         // Get the next Unicode character         int c = s[index];         if (asciiOnly && c >= 0x80) {           return null;         }         if ((c & 0xfc00) == 0xd800 && index + 1 < valueSLength &&             s[index + 1] >= 0xdc00 && s[index + 1] <= 0xdfff) {           // Get the Unicode code point for the surrogate pair           c = 0x10000 + ((c - 0xd800) << 10) + (s[index + 1] - 0xdc00);           ++index;         } else if ((c & 0xf800) == 0xd800) {           // error           return null;         }         if (c == '%' && strict) {           // Percent encoded character           if (index + 2 < valueSLength && isHexChar(s[index + 1]) &&               isHexChar(s[index + 2])) {             index += 3;             continue;           }           return null;         }         if (state == 0) {  // Path           if (c == ':' && fullyRelative) {             colon = true;           } else if (c == '/' && fullyRelative && !segment) {             // noscheme path can't have colon before slash             if (strict && colon) {               return null;             }             segment = true;           }           if (c == '?') {             retval[5] = index;             retval[6] = index + 1;             retval[7] = valueSLength;             state = 1;  // move to query state           } else if (c == '#') {             retval[5] = index;             retval[8] = index + 1;             retval[9] = valueSLength;             state = 2;  // move to fragment state           } else if (strict && !isIpchar(c)) {             return null;           }           ++index;         } else if (state == 1) {  // Query           if (c == '#') {             retval[7] = index;             retval[8] = index + 1;             retval[9] = valueSLength;             state = 2;  // move to fragment state           } else if (strict && !isIqueryChar(c)) {             return null;           }           ++index;         } else if (state == 2) {  // Fragment           if (strict && !isIfragmentChar(c)) {             return null;           }           ++index;         }       }
Magic Number,PeterO.Cbor,URIUtility,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\URIUtility.cs,splitIRI,The following statement contains a magic number: while (index < valueSLength) {         // Get the next Unicode character         int c = s[index];         if (asciiOnly && c >= 0x80) {           return null;         }         if ((c & 0xfc00) == 0xd800 && index + 1 < valueSLength &&             s[index + 1] >= 0xdc00 && s[index + 1] <= 0xdfff) {           // Get the Unicode code point for the surrogate pair           c = 0x10000 + ((c - 0xd800) << 10) + (s[index + 1] - 0xdc00);           ++index;         } else if ((c & 0xf800) == 0xd800) {           // error           return null;         }         if (c == '%' && strict) {           // Percent encoded character           if (index + 2 < valueSLength && isHexChar(s[index + 1]) &&               isHexChar(s[index + 2])) {             index += 3;             continue;           }           return null;         }         if (state == 0) {  // Path           if (c == ':' && fullyRelative) {             colon = true;           } else if (c == '/' && fullyRelative && !segment) {             // noscheme path can't have colon before slash             if (strict && colon) {               return null;             }             segment = true;           }           if (c == '?') {             retval[5] = index;             retval[6] = index + 1;             retval[7] = valueSLength;             state = 1;  // move to query state           } else if (c == '#') {             retval[5] = index;             retval[8] = index + 1;             retval[9] = valueSLength;             state = 2;  // move to fragment state           } else if (strict && !isIpchar(c)) {             return null;           }           ++index;         } else if (state == 1) {  // Query           if (c == '#') {             retval[7] = index;             retval[8] = index + 1;             retval[9] = valueSLength;             state = 2;  // move to fragment state           } else if (strict && !isIqueryChar(c)) {             return null;           }           ++index;         } else if (state == 2) {  // Fragment           if (strict && !isIfragmentChar(c)) {             return null;           }           ++index;         }       }
Magic Number,PeterO.Cbor,URIUtility,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\URIUtility.cs,splitIRI,The following statement contains a magic number: while (index < valueSLength) {         // Get the next Unicode character         int c = s[index];         if (asciiOnly && c >= 0x80) {           return null;         }         if ((c & 0xfc00) == 0xd800 && index + 1 < valueSLength &&             s[index + 1] >= 0xdc00 && s[index + 1] <= 0xdfff) {           // Get the Unicode code point for the surrogate pair           c = 0x10000 + ((c - 0xd800) << 10) + (s[index + 1] - 0xdc00);           ++index;         } else if ((c & 0xf800) == 0xd800) {           // error           return null;         }         if (c == '%' && strict) {           // Percent encoded character           if (index + 2 < valueSLength && isHexChar(s[index + 1]) &&               isHexChar(s[index + 2])) {             index += 3;             continue;           }           return null;         }         if (state == 0) {  // Path           if (c == ':' && fullyRelative) {             colon = true;           } else if (c == '/' && fullyRelative && !segment) {             // noscheme path can't have colon before slash             if (strict && colon) {               return null;             }             segment = true;           }           if (c == '?') {             retval[5] = index;             retval[6] = index + 1;             retval[7] = valueSLength;             state = 1;  // move to query state           } else if (c == '#') {             retval[5] = index;             retval[8] = index + 1;             retval[9] = valueSLength;             state = 2;  // move to fragment state           } else if (strict && !isIpchar(c)) {             return null;           }           ++index;         } else if (state == 1) {  // Query           if (c == '#') {             retval[7] = index;             retval[8] = index + 1;             retval[9] = valueSLength;             state = 2;  // move to fragment state           } else if (strict && !isIqueryChar(c)) {             return null;           }           ++index;         } else if (state == 2) {  // Fragment           if (strict && !isIfragmentChar(c)) {             return null;           }           ++index;         }       }
Magic Number,PeterO.Cbor,URIUtility,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\URIUtility.cs,splitIRI,The following statement contains a magic number: while (index < valueSLength) {         // Get the next Unicode character         int c = s[index];         if (asciiOnly && c >= 0x80) {           return null;         }         if ((c & 0xfc00) == 0xd800 && index + 1 < valueSLength &&             s[index + 1] >= 0xdc00 && s[index + 1] <= 0xdfff) {           // Get the Unicode code point for the surrogate pair           c = 0x10000 + ((c - 0xd800) << 10) + (s[index + 1] - 0xdc00);           ++index;         } else if ((c & 0xf800) == 0xd800) {           // error           return null;         }         if (c == '%' && strict) {           // Percent encoded character           if (index + 2 < valueSLength && isHexChar(s[index + 1]) &&               isHexChar(s[index + 2])) {             index += 3;             continue;           }           return null;         }         if (state == 0) {  // Path           if (c == ':' && fullyRelative) {             colon = true;           } else if (c == '/' && fullyRelative && !segment) {             // noscheme path can't have colon before slash             if (strict && colon) {               return null;             }             segment = true;           }           if (c == '?') {             retval[5] = index;             retval[6] = index + 1;             retval[7] = valueSLength;             state = 1;  // move to query state           } else if (c == '#') {             retval[5] = index;             retval[8] = index + 1;             retval[9] = valueSLength;             state = 2;  // move to fragment state           } else if (strict && !isIpchar(c)) {             return null;           }           ++index;         } else if (state == 1) {  // Query           if (c == '#') {             retval[7] = index;             retval[8] = index + 1;             retval[9] = valueSLength;             state = 2;  // move to fragment state           } else if (strict && !isIqueryChar(c)) {             return null;           }           ++index;         } else if (state == 2) {  // Fragment           if (strict && !isIfragmentChar(c)) {             return null;           }           ++index;         }       }
Magic Number,PeterO.Cbor,URIUtility,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\URIUtility.cs,splitIRI,The following statement contains a magic number: while (index < valueSLength) {         // Get the next Unicode character         int c = s[index];         if (asciiOnly && c >= 0x80) {           return null;         }         if ((c & 0xfc00) == 0xd800 && index + 1 < valueSLength &&             s[index + 1] >= 0xdc00 && s[index + 1] <= 0xdfff) {           // Get the Unicode code point for the surrogate pair           c = 0x10000 + ((c - 0xd800) << 10) + (s[index + 1] - 0xdc00);           ++index;         } else if ((c & 0xf800) == 0xd800) {           // error           return null;         }         if (c == '%' && strict) {           // Percent encoded character           if (index + 2 < valueSLength && isHexChar(s[index + 1]) &&               isHexChar(s[index + 2])) {             index += 3;             continue;           }           return null;         }         if (state == 0) {  // Path           if (c == ':' && fullyRelative) {             colon = true;           } else if (c == '/' && fullyRelative && !segment) {             // noscheme path can't have colon before slash             if (strict && colon) {               return null;             }             segment = true;           }           if (c == '?') {             retval[5] = index;             retval[6] = index + 1;             retval[7] = valueSLength;             state = 1;  // move to query state           } else if (c == '#') {             retval[5] = index;             retval[8] = index + 1;             retval[9] = valueSLength;             state = 2;  // move to fragment state           } else if (strict && !isIpchar(c)) {             return null;           }           ++index;         } else if (state == 1) {  // Query           if (c == '#') {             retval[7] = index;             retval[8] = index + 1;             retval[9] = valueSLength;             state = 2;  // move to fragment state           } else if (strict && !isIqueryChar(c)) {             return null;           }           ++index;         } else if (state == 2) {  // Fragment           if (strict && !isIfragmentChar(c)) {             return null;           }           ++index;         }       }
Magic Number,PeterO.Cbor,URIUtility,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\URIUtility.cs,splitIRI,The following statement contains a magic number: while (index < valueSLength) {         // Get the next Unicode character         int c = s[index];         if (asciiOnly && c >= 0x80) {           return null;         }         if ((c & 0xfc00) == 0xd800 && index + 1 < valueSLength &&             s[index + 1] >= 0xdc00 && s[index + 1] <= 0xdfff) {           // Get the Unicode code point for the surrogate pair           c = 0x10000 + ((c - 0xd800) << 10) + (s[index + 1] - 0xdc00);           ++index;         } else if ((c & 0xf800) == 0xd800) {           // error           return null;         }         if (c == '%' && strict) {           // Percent encoded character           if (index + 2 < valueSLength && isHexChar(s[index + 1]) &&               isHexChar(s[index + 2])) {             index += 3;             continue;           }           return null;         }         if (state == 0) {  // Path           if (c == ':' && fullyRelative) {             colon = true;           } else if (c == '/' && fullyRelative && !segment) {             // noscheme path can't have colon before slash             if (strict && colon) {               return null;             }             segment = true;           }           if (c == '?') {             retval[5] = index;             retval[6] = index + 1;             retval[7] = valueSLength;             state = 1;  // move to query state           } else if (c == '#') {             retval[5] = index;             retval[8] = index + 1;             retval[9] = valueSLength;             state = 2;  // move to fragment state           } else if (strict && !isIpchar(c)) {             return null;           }           ++index;         } else if (state == 1) {  // Query           if (c == '#') {             retval[7] = index;             retval[8] = index + 1;             retval[9] = valueSLength;             state = 2;  // move to fragment state           } else if (strict && !isIqueryChar(c)) {             return null;           }           ++index;         } else if (state == 2) {  // Fragment           if (strict && !isIfragmentChar(c)) {             return null;           }           ++index;         }       }
Magic Number,PeterO.Cbor,URIUtility,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\URIUtility.cs,splitIRI,The following statement contains a magic number: while (index < valueSLength) {         // Get the next Unicode character         int c = s[index];         if (asciiOnly && c >= 0x80) {           return null;         }         if ((c & 0xfc00) == 0xd800 && index + 1 < valueSLength &&             s[index + 1] >= 0xdc00 && s[index + 1] <= 0xdfff) {           // Get the Unicode code point for the surrogate pair           c = 0x10000 + ((c - 0xd800) << 10) + (s[index + 1] - 0xdc00);           ++index;         } else if ((c & 0xf800) == 0xd800) {           // error           return null;         }         if (c == '%' && strict) {           // Percent encoded character           if (index + 2 < valueSLength && isHexChar(s[index + 1]) &&               isHexChar(s[index + 2])) {             index += 3;             continue;           }           return null;         }         if (state == 0) {  // Path           if (c == ':' && fullyRelative) {             colon = true;           } else if (c == '/' && fullyRelative && !segment) {             // noscheme path can't have colon before slash             if (strict && colon) {               return null;             }             segment = true;           }           if (c == '?') {             retval[5] = index;             retval[6] = index + 1;             retval[7] = valueSLength;             state = 1;  // move to query state           } else if (c == '#') {             retval[5] = index;             retval[8] = index + 1;             retval[9] = valueSLength;             state = 2;  // move to fragment state           } else if (strict && !isIpchar(c)) {             return null;           }           ++index;         } else if (state == 1) {  // Query           if (c == '#') {             retval[7] = index;             retval[8] = index + 1;             retval[9] = valueSLength;             state = 2;  // move to fragment state           } else if (strict && !isIqueryChar(c)) {             return null;           }           ++index;         } else if (state == 2) {  // Fragment           if (strict && !isIfragmentChar(c)) {             return null;           }           ++index;         }       }
Magic Number,PeterO.Cbor,URIUtility,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\URIUtility.cs,splitIRI,The following statement contains a magic number: while (index < valueSLength) {         // Get the next Unicode character         int c = s[index];         if (asciiOnly && c >= 0x80) {           return null;         }         if ((c & 0xfc00) == 0xd800 && index + 1 < valueSLength &&             s[index + 1] >= 0xdc00 && s[index + 1] <= 0xdfff) {           // Get the Unicode code point for the surrogate pair           c = 0x10000 + ((c - 0xd800) << 10) + (s[index + 1] - 0xdc00);           ++index;         } else if ((c & 0xf800) == 0xd800) {           // error           return null;         }         if (c == '%' && strict) {           // Percent encoded character           if (index + 2 < valueSLength && isHexChar(s[index + 1]) &&               isHexChar(s[index + 2])) {             index += 3;             continue;           }           return null;         }         if (state == 0) {  // Path           if (c == ':' && fullyRelative) {             colon = true;           } else if (c == '/' && fullyRelative && !segment) {             // noscheme path can't have colon before slash             if (strict && colon) {               return null;             }             segment = true;           }           if (c == '?') {             retval[5] = index;             retval[6] = index + 1;             retval[7] = valueSLength;             state = 1;  // move to query state           } else if (c == '#') {             retval[5] = index;             retval[8] = index + 1;             retval[9] = valueSLength;             state = 2;  // move to fragment state           } else if (strict && !isIpchar(c)) {             return null;           }           ++index;         } else if (state == 1) {  // Query           if (c == '#') {             retval[7] = index;             retval[8] = index + 1;             retval[9] = valueSLength;             state = 2;  // move to fragment state           } else if (strict && !isIqueryChar(c)) {             return null;           }           ++index;         } else if (state == 2) {  // Fragment           if (strict && !isIfragmentChar(c)) {             return null;           }           ++index;         }       }
Magic Number,PeterO.Cbor,URIUtility,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\URIUtility.cs,splitIRI,The following statement contains a magic number: while (index < valueSLength) {         // Get the next Unicode character         int c = s[index];         if (asciiOnly && c >= 0x80) {           return null;         }         if ((c & 0xfc00) == 0xd800 && index + 1 < valueSLength &&             s[index + 1] >= 0xdc00 && s[index + 1] <= 0xdfff) {           // Get the Unicode code point for the surrogate pair           c = 0x10000 + ((c - 0xd800) << 10) + (s[index + 1] - 0xdc00);           ++index;         } else if ((c & 0xf800) == 0xd800) {           // error           return null;         }         if (c == '%' && strict) {           // Percent encoded character           if (index + 2 < valueSLength && isHexChar(s[index + 1]) &&               isHexChar(s[index + 2])) {             index += 3;             continue;           }           return null;         }         if (state == 0) {  // Path           if (c == ':' && fullyRelative) {             colon = true;           } else if (c == '/' && fullyRelative && !segment) {             // noscheme path can't have colon before slash             if (strict && colon) {               return null;             }             segment = true;           }           if (c == '?') {             retval[5] = index;             retval[6] = index + 1;             retval[7] = valueSLength;             state = 1;  // move to query state           } else if (c == '#') {             retval[5] = index;             retval[8] = index + 1;             retval[9] = valueSLength;             state = 2;  // move to fragment state           } else if (strict && !isIpchar(c)) {             return null;           }           ++index;         } else if (state == 1) {  // Query           if (c == '#') {             retval[7] = index;             retval[8] = index + 1;             retval[9] = valueSLength;             state = 2;  // move to fragment state           } else if (strict && !isIqueryChar(c)) {             return null;           }           ++index;         } else if (state == 2) {  // Fragment           if (strict && !isIfragmentChar(c)) {             return null;           }           ++index;         }       }
Magic Number,PeterO.Cbor,URIUtility,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\URIUtility.cs,splitIRI,The following statement contains a magic number: while (index < valueSLength) {         // Get the next Unicode character         int c = s[index];         if (asciiOnly && c >= 0x80) {           return null;         }         if ((c & 0xfc00) == 0xd800 && index + 1 < valueSLength &&             s[index + 1] >= 0xdc00 && s[index + 1] <= 0xdfff) {           // Get the Unicode code point for the surrogate pair           c = 0x10000 + ((c - 0xd800) << 10) + (s[index + 1] - 0xdc00);           ++index;         } else if ((c & 0xf800) == 0xd800) {           // error           return null;         }         if (c == '%' && strict) {           // Percent encoded character           if (index + 2 < valueSLength && isHexChar(s[index + 1]) &&               isHexChar(s[index + 2])) {             index += 3;             continue;           }           return null;         }         if (state == 0) {  // Path           if (c == ':' && fullyRelative) {             colon = true;           } else if (c == '/' && fullyRelative && !segment) {             // noscheme path can't have colon before slash             if (strict && colon) {               return null;             }             segment = true;           }           if (c == '?') {             retval[5] = index;             retval[6] = index + 1;             retval[7] = valueSLength;             state = 1;  // move to query state           } else if (c == '#') {             retval[5] = index;             retval[8] = index + 1;             retval[9] = valueSLength;             state = 2;  // move to fragment state           } else if (strict && !isIpchar(c)) {             return null;           }           ++index;         } else if (state == 1) {  // Query           if (c == '#') {             retval[7] = index;             retval[8] = index + 1;             retval[9] = valueSLength;             state = 2;  // move to fragment state           } else if (strict && !isIqueryChar(c)) {             return null;           }           ++index;         } else if (state == 2) {  // Fragment           if (strict && !isIfragmentChar(c)) {             return null;           }           ++index;         }       }
Duplicate Code,PeterO.Cbor,URIUtility,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\URIUtility.cs,escapeURI,The method contains a code clone-set at the following line numbers (starting from the method definition): ((56' 79)' (82' 105))
Missing Default,PeterO.Cbor,CBORObject,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORObject.cs,EncodeToBytes,The following switch statement is missing a default case: switch (this.ItemType) {           case CBORObjectTypeTextString: {               byte[] ret = GetOptimizedBytesIfShortAscii(                 this.AsString()' tagged ? (((int)tagbyte) & 0xff) : -1);               if (ret != null) {                 return ret;               }               break;             }           case CBORObjectTypeSimpleValue: {               if (tagged) {                 if (this.IsFalse) {                   return new[] { tagbyte' (byte)0xf4 };                 }                 if (this.IsTrue) {                   return new[] { tagbyte' (byte)0xf5 };                 }                 if (this.IsNull) {                   return new[] { tagbyte' (byte)0xf6 };                 }                 if (this.IsUndefined) {                   return new[] { tagbyte' (byte)0xf7 };                 }               } else {                 if (this.IsFalse) {                   return new[] { (byte)0xf4 };                 }                 if (this.IsTrue) {                   return new[] { (byte)0xf5 };                 }                 if (this.IsNull) {                   return new[] { (byte)0xf6 };                 }                 if (this.IsUndefined) {                   return new[] { (byte)0xf7 };                 }               }               break;             }           case CBORObjectTypeInteger: {               var value = (long)this.ThisItem;               byte[] intBytes = null;               if (value >= 0) {                 intBytes = GetPositiveInt64Bytes(0' value);               } else {                 ++value;                 value = -value;  // Will never overflow                 intBytes = GetPositiveInt64Bytes(1' value);               }               if (!tagged) {                 return intBytes;               }               var ret2 = new byte[intBytes.Length + 1];               Array.Copy(intBytes' 0' ret2' 1' intBytes.Length);               ret2[0] = tagbyte;               return ret2;             }           case CBORObjectTypeSingle: {               var value = (float)this.ThisItem;               int bits = BitConverter.ToInt32(BitConverter.GetBytes(value)' 0);               return tagged ? new[] { tagbyte' (byte)0xfa'                 (byte)((bits >> 24) & 0xff)' (byte)((bits >> 16) & 0xff)'                 (byte)((bits >> 8) & 0xff)' (byte)(bits & 0xff) } :                 new[] { (byte)0xfa' (byte)((bits >> 24) & 0xff)'                 (byte)((bits >> 16) & 0xff)' (byte)((bits >> 8) & 0xff)'                 (byte)(bits & 0xff) };             }           case CBORObjectTypeDouble: {               var value = (double)this.ThisItem;               long bits = BitConverter.ToInt64(BitConverter.GetBytes(value)' 0);               return tagged ? new[] { tagbyte' (byte)0xfb'                 (byte)((bits >> 56) & 0xff)' (byte)((bits >> 48) & 0xff)'                 (byte)((bits >> 40) & 0xff)' (byte)((bits >> 32) & 0xff)'                 (byte)((bits >> 24) & 0xff)' (byte)((bits >> 16) & 0xff)'                 (byte)((bits >> 8) & 0xff)' (byte)(bits & 0xff) } :                 new[] { (byte)0xfb' (byte)((bits >> 56) & 0xff)'                 (byte)((bits >> 48) & 0xff)' (byte)((bits >> 40) & 0xff)'                 (byte)((bits >> 32) & 0xff)' (byte)((bits >> 24) & 0xff)'                 (byte)((bits >> 16) & 0xff)' (byte)((bits >> 8) & 0xff)'                 (byte)(bits & 0xff) };             }         }
Missing Default,PeterO.Cbor,CBORReader,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORReader.cs,ReadForFirstByte,The following switch statement is missing a default case: switch (firstbyte & 0x1f) {         case 24: {             int tmp = this.stream.ReadByte();             if (tmp < 0) {               throw new CBORException("Premature end of data");             }             lowAdditional = tmp;             uadditional = lowAdditional;             break;           }         case 25: {             if (this.stream.Read(data' 0' 2) != 2) {               throw new CBORException("Premature end of data");             }             lowAdditional = ((int)(data[0] & (int)0xff)) << 8;             lowAdditional |= (int)(data[1] & (int)0xff);             uadditional = lowAdditional;             break;           }         case 26: {             if (this.stream.Read(data' 0' 4) != 4) {               throw new CBORException("Premature end of data");             }             uadditional = ((long)(data[0] & (long)0xff)) << 24;             uadditional |= ((long)(data[1] & (long)0xff)) << 16;             uadditional |= ((long)(data[2] & (long)0xff)) << 8;             uadditional |= (long)(data[3] & (long)0xff);             break;           }         case 27: {             if (this.stream.Read(data' 0' 8) != 8) {               throw new CBORException("Premature end of data");             }             if ((((int)data[0]) & 0x80) != 0) {               // Won't fit in a signed 64-bit number               var uabytes = new byte[9];               uabytes[0] = data[7];               uabytes[1] = data[6];               uabytes[2] = data[5];               uabytes[3] = data[4];               uabytes[4] = data[3];               uabytes[5] = data[2];               uabytes[6] = data[1];               uabytes[7] = data[0];               uabytes[8] = 0;               hasBigAdditional = true;               bigintAdditional = EInteger.FromBytes(uabytes' true);             } else {               uadditional = ((long)(data[0] & (long)0xff)) << 56;               uadditional |= ((long)(data[1] & (long)0xff)) << 48;               uadditional |= ((long)(data[2] & (long)0xff)) << 40;               uadditional |= ((long)(data[3] & (long)0xff)) << 32;               uadditional |= ((long)(data[4] & (long)0xff)) << 24;               uadditional |= ((long)(data[5] & (long)0xff)) << 16;               uadditional |= ((long)(data[6] & (long)0xff)) << 8;               uadditional |= (long)(data[7] & (long)0xff);             }             break;           }       }
Missing Default,PeterO.Cbor,CBORReader,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORReader.cs,ReadForFirstByte,The following switch statement is missing a default case: switch (   DataUtilities.ReadUtf8(   this.stream'   (int)len'   builder'   false)) {                 case -1:                   throw new CBORException("Invalid UTF-8");                 case -2:                   throw new CBORException("Premature end of data");               }
Missing Default,PeterO.Cbor,CBORReader,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORReader.cs,ReadForFirstByte,The following switch statement is missing a default case: switch (   DataUtilities.ReadUtf8(   this.stream'   (int)uadditional'   builder'   false)) {             case -1:               throw new CBORException("Invalid UTF-8");             case -2:               throw new CBORException("Premature end of data");           }
Missing Default,PeterO.Cbor,CBORReader,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORReader.cs,ReadForFirstByte,The following switch statement is missing a default case: switch (uad) {             case 256:               // Tag 256: String namespace               this.stringRefs = this.stringRefs ?? (new StringRefs());               this.stringRefs.Push();               break;             case 25:               // String reference               if (this.stringRefs == null) {                 throw new CBORException("No stringref namespace");               }               break;      case 28:      case 29:           this.hasSharableObjects = true;        break;           }
Missing Default,PeterO.Cbor,CBORReader,C:\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORReader.cs,ReadForFirstByte,The following switch statement is missing a default case: switch (uaddl) {             case 256:               // string tag               this.stringRefs.Pop();               break;             case 25:               // stringref tag               return this.stringRefs.GetString(o.AsEInteger());           }
