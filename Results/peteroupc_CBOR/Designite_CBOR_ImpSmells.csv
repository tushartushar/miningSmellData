Implementation smell,Namespace,Class,File,Method,Description
Long Method,PeterO.Cbor,CBORDataUtilities,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORDataUtilities.cs,ToStringHelper,The method has 151 lines of code.
Long Method,PeterO.Cbor,CBORDataUtilities,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORDataUtilities.cs,ParseJSONNumber,The method has 245 lines of code.
Long Method,PeterO.Cbor,CBORJson,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORJson.cs,NextJSONString,The method has 114 lines of code.
Long Method,PeterO.Cbor,CBORJson,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORJson.cs,NextJSONValue,The method has 199 lines of code.
Long Method,PeterO.Cbor,CBORJson2,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORJson2.cs,NextJSONString,The method has 184 lines of code.
Long Method,PeterO.Cbor,CBORJson3,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORJson3.cs,NextJSONString,The method has 137 lines of code.
Long Method,PeterO.Cbor,CBORJsonWriter,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORJsonWriter.cs,WriteJSONToInternal,The method has 180 lines of code.
Long Method,PeterO.Cbor,CBORNumber,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORNumber.cs,BigFracToNumber,The method has 102 lines of code.
Long Method,PeterO.Cbor,CBORNumber,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORNumber.cs,CompareTo,The method has 130 lines of code.
Long Method,PeterO.Cbor,CBORObject,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORObject.cs,FromObject,The method has 143 lines of code.
Long Method,PeterO.Cbor,CBORObject,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORObject.cs,CompareTo,The method has 110 lines of code.
Long Method,PeterO.Cbor,CBORObject,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORObject.cs,EncodeToBytes,The method has 101 lines of code.
Long Method,PeterO.Cbor,CBORObject,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORObject.cs,GetFixedLengthObject,The method has 120 lines of code.
Long Method,PeterO.Cbor,CBORObject,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORObject.cs,WriteStreamedString,The method has 100 lines of code.
Long Method,PeterO.Cbor,CBORReader,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORReader.cs,ReadStringArrayMap,The method has 105 lines of code.
Long Method,PeterO.Cbor,CBORReader,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORReader.cs,ReadForFirstByte,The method has 259 lines of code.
Long Method,PeterO.Cbor,CharacterReader,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CharacterReader.cs,DetectUtf8Or16Or32,The method has 132 lines of code.
Long Method,PeterO.Cbor,PropertyMap,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\PropertyMap.cs,TypeToObject,The method has 267 lines of code.
Long Method,PeterO,DataUtilities,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\DataUtilities.cs,WriteUtf8,The method has 137 lines of code.
Long Method,PeterO,DataUtilities,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\DataUtilities.cs,ReadUtf8FromBytes,The method has 106 lines of code.
Long Method,PeterO,DataUtilities,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\DataUtilities.cs,ReadUtf8,The method has 122 lines of code.
Complex Method,PeterO.Cbor,Base64,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\Base64.cs,WriteBase64,Cyclomatic complexity of the method is 12
Complex Method,PeterO.Cbor,CBORCanonical,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORCanonical.cs,CtapCanonicalEncode,Cyclomatic complexity of the method is 12
Complex Method,PeterO.Cbor,CtapByteComparer,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORCanonical.cs,Compare,Cyclomatic complexity of the method is 10
Complex Method,PeterO.Cbor,CtapComparer,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORCanonical.cs,MajorType,Cyclomatic complexity of the method is 8
Complex Method,PeterO.Cbor,CtapComparer,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORCanonical.cs,Compare,Cyclomatic complexity of the method is 9
Complex Method,PeterO.Cbor,CBORDataUtilities,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORDataUtilities.cs,ToStringHelper,Cyclomatic complexity of the method is 27
Complex Method,PeterO.Cbor,CBORDataUtilities,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORDataUtilities.cs,ParseJSONNumber,Cyclomatic complexity of the method is 55
Complex Method,PeterO.Cbor,CBORJson,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORJson.cs,NextJSONString,Cyclomatic complexity of the method is 25
Complex Method,PeterO.Cbor,CBORJson,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORJson.cs,NextJSONNegativeNumber,Cyclomatic complexity of the method is 9
Complex Method,PeterO.Cbor,CBORJson,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORJson.cs,NextJSONValue,Cyclomatic complexity of the method is 35
Complex Method,PeterO.Cbor,CBORJson,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORJson.cs,ParseJSONSequence,Cyclomatic complexity of the method is 8
Complex Method,PeterO.Cbor,CBORJson,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORJson.cs,ParseJSONObject,Cyclomatic complexity of the method is 12
Complex Method,PeterO.Cbor,CBORJson,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORJson.cs,ParseJSONArray,Cyclomatic complexity of the method is 8
Complex Method,PeterO.Cbor,CBORJson2,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORJson2.cs,NextJSONString,Cyclomatic complexity of the method is 41
Complex Method,PeterO.Cbor,CBORJson2,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORJson2.cs,NextJSONNegativeNumber,Cyclomatic complexity of the method is 8
Complex Method,PeterO.Cbor,CBORJson2,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORJson2.cs,NextJSONNonnegativeNumber,Cyclomatic complexity of the method is 14
Complex Method,PeterO.Cbor,CBORJson2,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORJson2.cs,NextJSONValue,Cyclomatic complexity of the method is 13
Complex Method,PeterO.Cbor,CBORJson2,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORJson2.cs,ParseJSONObject,Cyclomatic complexity of the method is 12
Complex Method,PeterO.Cbor,CBORJson2,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORJson2.cs,ParseJSONArray,Cyclomatic complexity of the method is 8
Complex Method,PeterO.Cbor,CBORJson3,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORJson3.cs,NextJSONString,Cyclomatic complexity of the method is 29
Complex Method,PeterO.Cbor,CBORJson3,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORJson3.cs,NextJSONNegativeNumber,Cyclomatic complexity of the method is 10
Complex Method,PeterO.Cbor,CBORJson3,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORJson3.cs,NextJSONNonnegativeNumber,Cyclomatic complexity of the method is 14
Complex Method,PeterO.Cbor,CBORJson3,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORJson3.cs,NextJSONValue,Cyclomatic complexity of the method is 13
Complex Method,PeterO.Cbor,CBORJson3,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORJson3.cs,ParseJSONObject,Cyclomatic complexity of the method is 12
Complex Method,PeterO.Cbor,CBORJson3,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORJson3.cs,ParseJSONArray,Cyclomatic complexity of the method is 8
Complex Method,PeterO.Cbor,CBORJsonWriter,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORJsonWriter.cs,WriteJSONStringUnquoted,Cyclomatic complexity of the method is 20
Complex Method,PeterO.Cbor,CBORJsonWriter,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORJsonWriter.cs,WriteJSONToInternal,Cyclomatic complexity of the method is 29
Complex Method,PeterO.Cbor,CBORNumber,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORNumber.cs,FromCBORObject,Cyclomatic complexity of the method is 8
Complex Method,PeterO.Cbor,CBORNumber,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORNumber.cs,RationalToNumber,Cyclomatic complexity of the method is 20
Complex Method,PeterO.Cbor,CBORNumber,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORNumber.cs,CheckRationalToNumber,Cyclomatic complexity of the method is 14
Complex Method,PeterO.Cbor,CBORNumber,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORNumber.cs,CheckBigFracToNumber,Cyclomatic complexity of the method is 15
Complex Method,PeterO.Cbor,CBORNumber,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORNumber.cs,BigFracToNumber,Cyclomatic complexity of the method is 26
Complex Method,PeterO.Cbor,CBORNumber,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORNumber.cs,BignumToNumber,Cyclomatic complexity of the method is 10
Complex Method,PeterO.Cbor,CBORNumber,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORNumber.cs,ToJSONString,Cyclomatic complexity of the method is 13
Complex Method,PeterO.Cbor,CBORNumber,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORNumber.cs,Divide,Cyclomatic complexity of the method is 13
Complex Method,PeterO.Cbor,CBORNumber,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORNumber.cs,CompareTo,Cyclomatic complexity of the method is 22
Complex Method,PeterO.Cbor,CBORObject,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORObject.cs,DecodeFromBytes,Cyclomatic complexity of the method is 10
Complex Method,PeterO.Cbor,CBORObject,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORObject.cs,ToObject,Cyclomatic complexity of the method is 16
Complex Method,PeterO.Cbor,CBORObject,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORObject.cs,CalcEncodedSize,Cyclomatic complexity of the method is 16
Complex Method,PeterO.Cbor,CBORObject,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORObject.cs,FromObject,Cyclomatic complexity of the method is 9
Complex Method,PeterO.Cbor,CBORObject,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORObject.cs,FromObject,Cyclomatic complexity of the method is 36
Complex Method,PeterO.Cbor,CBORObject,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORObject.cs,FromJSONBytes,Cyclomatic complexity of the method is 11
Complex Method,PeterO.Cbor,CBORObject,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORObject.cs,Write,Cyclomatic complexity of the method is 17
Complex Method,PeterO.Cbor,CBORObject,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORObject.cs,Write,Cyclomatic complexity of the method is 8
Complex Method,PeterO.Cbor,CBORObject,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORObject.cs,CompareTo,Cyclomatic complexity of the method is 20
Complex Method,PeterO.Cbor,CBORObject,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORObject.cs,EncodeToBytes,Cyclomatic complexity of the method is 21
Complex Method,PeterO.Cbor,CBORObject,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORObject.cs,Equals,Cyclomatic complexity of the method is 9
Complex Method,PeterO.Cbor,CBORObject,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORObject.cs,Set,Cyclomatic complexity of the method is 9
Complex Method,PeterO.Cbor,CBORObject,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORObject.cs,WriteValue,Cyclomatic complexity of the method is 9
Complex Method,PeterO.Cbor,CBORObject,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORObject.cs,WriteValue,Cyclomatic complexity of the method is 9
Complex Method,PeterO.Cbor,CBORObject,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORObject.cs,WriteValue,Cyclomatic complexity of the method is 9
Complex Method,PeterO.Cbor,CBORObject,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORObject.cs,WriteTo,Cyclomatic complexity of the method is 14
Complex Method,PeterO.Cbor,CBORObject,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORObject.cs,GetFixedLengthObject,Cyclomatic complexity of the method is 23
Complex Method,PeterO.Cbor,CBORObject,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORObject.cs,GetOptimizedBytesIfShortAscii,Cyclomatic complexity of the method is 8
Complex Method,PeterO.Cbor,CBORObject,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORObject.cs,MapCompare,Cyclomatic complexity of the method is 12
Complex Method,PeterO.Cbor,CBORObject,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORObject.cs,WriteStreamedString,Cyclomatic complexity of the method is 18
Complex Method,PeterO.Cbor,CBORReader,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORReader.cs,ResolveSharedRefs,Cyclomatic complexity of the method is 10
Complex Method,PeterO.Cbor,CBORReader,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORReader.cs,ReadStringArrayMap,Cyclomatic complexity of the method is 23
Complex Method,PeterO.Cbor,CBORReader,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORReader.cs,ReadForFirstByte,Cyclomatic complexity of the method is 55
Complex Method,PeterO.Cbor,CBORReader,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORReader.cs,ReadByteData,Cyclomatic complexity of the method is 12
Complex Method,PeterO.Cbor,CBORReader,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORReader.cs,ReadDataLength,Cyclomatic complexity of the method is 18
Complex Method,PeterO.Cbor,CBORUtilities,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORUtilities.cs,FastPathStringCompare,Cyclomatic complexity of the method is 17
Complex Method,PeterO.Cbor,CBORUtilities,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORUtilities.cs,LongToString,Cyclomatic complexity of the method is 15
Complex Method,PeterO.Cbor,CBORUtilities,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORUtilities.cs,GetNormalizedPartProlepticGregorian,Cyclomatic complexity of the method is 9
Complex Method,PeterO.Cbor,CBORUtilities,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORUtilities.cs,GetNumberOfDaysProlepticGregorian,Cyclomatic complexity of the method is 14
Complex Method,PeterO.Cbor,CBORUtilities,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORUtilities.cs,IsValidDateTime,Cyclomatic complexity of the method is 8
Complex Method,PeterO.Cbor,CBORUtilities,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORUtilities.cs,ParseAtomDateTimeString,Cyclomatic complexity of the method is 20
Complex Method,PeterO.Cbor,CBORUtilities,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORUtilities.cs,BigIntegerFromDouble,Cyclomatic complexity of the method is 10
Complex Method,PeterO.Cbor,CharacterInputWithCount,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CharacterInputWithCount.cs,Read,Cyclomatic complexity of the method is 8
Complex Method,PeterO.Cbor,CharacterReader,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CharacterReader.cs,Read,Cyclomatic complexity of the method is 9
Complex Method,PeterO.Cbor,CharacterReader,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CharacterReader.cs,DetectUtf8Or16Or32,Cyclomatic complexity of the method is 16
Complex Method,PeterO.Cbor,CharacterReader,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CharacterReader.cs,DetectUtf8OrUtf16,Cyclomatic complexity of the method is 9
Complex Method,PeterO.Cbor,CharacterReader,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CharacterReader.cs,DetectUnicodeEncoding,Cyclomatic complexity of the method is 8
Complex Method,PeterO.Cbor,Utf16Reader,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CharacterReader.cs,ReadChar,Cyclomatic complexity of the method is 11
Complex Method,PeterO.Cbor,Utf8Reader,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CharacterReader.cs,ReadChar,Cyclomatic complexity of the method is 15
Complex Method,PeterO.Cbor,PropertyMap,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\PropertyMap.cs,GetPropertyList,Cyclomatic complexity of the method is 13
Complex Method,PeterO.Cbor,PropertyMap,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\PropertyMap.cs,BuildCBORArray,Cyclomatic complexity of the method is 9
Complex Method,PeterO.Cbor,PropertyMap,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\PropertyMap.cs,TypeToIntegerObject,Cyclomatic complexity of the method is 9
Complex Method,PeterO.Cbor,PropertyMap,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\PropertyMap.cs,TypeToObject,Cyclomatic complexity of the method is 48
Complex Method,PeterO.Cbor,StringOutput,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\StringOutput.cs,WriteCodePoint,Cyclomatic complexity of the method is 11
Complex Method,PeterO.Cbor,StringRefs,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\StringRefs.cs,AddStringIfNeeded,Cyclomatic complexity of the method is 8
Complex Method,PeterO,DataUtilities,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\DataUtilities.cs,GetUtf8String,Cyclomatic complexity of the method is 8
Complex Method,PeterO,DataUtilities,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\DataUtilities.cs,GetUtf8Bytes,Cyclomatic complexity of the method is 11
Complex Method,PeterO,DataUtilities,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\DataUtilities.cs,GetUtf8Length,Cyclomatic complexity of the method is 10
Complex Method,PeterO,DataUtilities,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\DataUtilities.cs,CodePointCompare,Cyclomatic complexity of the method is 13
Complex Method,PeterO,DataUtilities,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\DataUtilities.cs,WriteUtf8,Cyclomatic complexity of the method is 28
Complex Method,PeterO,DataUtilities,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\DataUtilities.cs,ReadUtf8FromBytes,Cyclomatic complexity of the method is 21
Complex Method,PeterO,DataUtilities,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\DataUtilities.cs,ReadUtf8,Cyclomatic complexity of the method is 26
Long Parameter List,PeterO.Cbor,Base64,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\Base64.cs,WriteBase64,The method has 5 parameters. Parameters: writer' data' offset' count' padding
Long Parameter List,PeterO.Cbor,Base64,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\Base64.cs,WriteBase64URL,The method has 5 parameters. Parameters: writer' data' offset' count' padding
Long Parameter List,PeterO.Cbor,Base64,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\Base64.cs,WriteBase64,The method has 6 parameters. Parameters: writer' data' offset' count' classic' padding
Long Parameter List,PeterO.Cbor,CBORDataUtilities,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORDataUtilities.cs,ParseJSONNumber,The method has 5 parameters. Parameters: str' offset' count' options' endOfNumber
Long Parameter List,PeterO.Cbor,CBORJson2,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORJson2.cs,ParseJSONValue,The method has 5 parameters. Parameters: bytes' index' endPos' options' nextchar
Long Parameter List,PeterO.Cbor,CBORJson3,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORJson3.cs,ParseJSONValue,The method has 5 parameters. Parameters: jstring' index' endPos' options' nextchar
Long Parameter List,PeterO.Cbor,CBORObject,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORObject.cs,WriteChildObject,The method has 5 parameters. Parameters: parentThisItem' child' outputStream' stack' options
Long Parameter List,PeterO.Cbor,CharacterReader,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CharacterReader.cs,CharacterReader,The method has 5 parameters. Parameters: str' offset' length' skipByteOrderMark' errorThrow
Long Parameter List,PeterO.Cbor,PropertyMap,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\PropertyMap.cs,FillArray,The method has 6 parameters. Parameters: arr' elementType' cbor' mapper' options' depth
Long Parameter List,PeterO.Cbor,PropertyMap,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\PropertyMap.cs,TypeToObject,The method has 5 parameters. Parameters: objThis' t' mapper' options' depth
Long Parameter List,PeterO.Cbor,PropertyMap,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\PropertyMap.cs,ObjectWithProperties,The method has 5 parameters. Parameters: t' keysValues' mapper' options' depth
Long Parameter List,PeterO,DataUtilities,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\DataUtilities.cs,WriteUtf8,The method has 5 parameters. Parameters: str' offset' length' stream' replace
Long Parameter List,PeterO,DataUtilities,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\DataUtilities.cs,WriteUtf8,The method has 6 parameters. Parameters: str' offset' length' stream' replace' lenientLineBreaks
Long Parameter List,PeterO,DataUtilities,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\DataUtilities.cs,ReadUtf8FromBytes,The method has 5 parameters. Parameters: data' offset' bytesCount' builder' replace
Complex Conditional,PeterO.Cbor,CBORCanonical,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORCanonical.cs,CtapCanonicalEncode,The conditional expression  "valueAType == CBORType.SimpleValue ||         valueAType == CBORType.Boolean || valueAType == CBORType.ByteString ||         valueAType == CBORType.TextString"  is complex.
Complex Conditional,PeterO.Cbor,CBORDataUtilities,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORDataUtilities.cs,ParseJSONNumber,The conditional expression  "str[i] >= '0' && str[i] <= '9' && (i > 0 || str[i] != '-')"  is complex.
Complex Conditional,PeterO.Cbor,CBORDataUtilities,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORDataUtilities.cs,ParseJSONNumber,The conditional expression  "str[i] >= '0' && str[i] <= '9' && (i > 0 || str[i] != '-')"  is complex.
Complex Conditional,PeterO.Cbor,CBORDataUtilities,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORDataUtilities.cs,ParseJSONNumber,The conditional expression  "endPos - 1 > k && str[k] == '0' && str[k + 1] >= '0' &&          str[k + 1] <= '9'"  is complex.
Complex Conditional,PeterO.Cbor,CBORDataUtilities,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORDataUtilities.cs,ParseJSONNumber,The conditional expression  "c != ''' && c != ']' && c != '}' &&               c != 0x20 && c != 0x0a && c != 0x0d && c != 0x09"  is complex.
Complex Conditional,PeterO.Cbor,CBORDataUtilities,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORDataUtilities.cs,ParseJSONNumber,The conditional expression  "c != ''' && c != ']' && c != '}' &&               c != 0x20 && c != 0x0a && c != 0x0d && c != 0x09"  is complex.
Complex Conditional,PeterO.Cbor,CBORDataUtilities,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORDataUtilities.cs,ParseJSONNumber,The conditional expression  "!Double.IsNaN(dbl) && dbl >= -9007199254740991.0 &&           dbl <= 9007199254740991.0 && Math.Floor(dbl) == dbl"  is complex.
Complex Conditional,PeterO.Cbor,CBORDataUtilities,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORDataUtilities.cs,ParseJSONNumber,The conditional expression  "!Double.IsNaN(dbl) && dbl >= -9007199254740991.0 &&             dbl <= 9007199254740991.0 && Math.Floor(dbl) == dbl"  is complex.
Complex Conditional,PeterO.Cbor,CBORJson,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORJson.cs,SkipWhitespaceJSON,The conditional expression  "c == -1 || (c != 0x20 && c != 0x0a && c != 0x0d && c != 0x09)"  is complex.
Complex Conditional,PeterO.Cbor,CBORJson,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORJson.cs,SkipWhitespaceJSON,The conditional expression  "lastChar == 0x20 || lastChar == 0x0a || lastChar == 0x0d ||         lastChar == 0x09"  is complex.
Complex Conditional,PeterO.Cbor,CBORJson,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORJson.cs,NextJSONNegativeNumber,The conditional expression  "c == '-' || c == '+' || c == '.' || (c >= '0' && c <= '9') ||         c == 'e' || c == 'E'"  is complex.
Complex Conditional,PeterO.Cbor,CBORJson,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORJson.cs,NextJSONNegativeNumber,The conditional expression  "c != ''' && c != ']' && c != '}' && c != -1 &&         c != 0x20 && c != 0x0a && c != 0x0d && c != 0x09"  is complex.
Complex Conditional,PeterO.Cbor,CBORJson,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORJson.cs,NextJSONNegativeNumber,The conditional expression  "c == 0x20 || c == 0x0a || c == 0x0d || c == 0x09"  is complex.
Complex Conditional,PeterO.Cbor,CBORJson,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORJson.cs,NextJSONValue,The conditional expression  "c == 0x20 || c == 0x0a || c == 0x0d || c == 0x09"  is complex.
Complex Conditional,PeterO.Cbor,CBORJson,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORJson.cs,NextJSONValue,The conditional expression  "(c = this.ReadChar()) != 'a' || (c = this.ReadChar()) != 'l' ||             (c = this.ReadChar()) != 's' || (c = this.ReadChar()) != 'e'"  is complex.
Complex Conditional,PeterO.Cbor,CBORJson,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORJson.cs,NextJSONValue,The conditional expression  "c == 0x20 || c == 0x0a || c == 0x0d || c == 0x09"  is complex.
Complex Conditional,PeterO.Cbor,CBORJson,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORJson.cs,NextJSONValue,The conditional expression  "c == 0x20 || c == 0x0a || c == 0x0d || c == 0x09"  is complex.
Complex Conditional,PeterO.Cbor,CBORJson,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORJson.cs,NextJSONValue,The conditional expression  "!(c == '-' || c == '+' || c == '.' || (c >= '0' && c <= '9') ||               c == 'e' || c == 'E')"  is complex.
Complex Conditional,PeterO.Cbor,CBORJson,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORJson.cs,NextJSONValue,The conditional expression  "c == 'e' || c == 'E' || c == '.' || (c >= '0' && c <= '9')"  is complex.
Complex Conditional,PeterO.Cbor,CBORJson,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORJson.cs,NextJSONValue,The conditional expression  "!(c == '-' || c == '+' || c == '.' || c == 'e' || c                 == 'E')"  is complex.
Complex Conditional,PeterO.Cbor,CBORJson,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORJson.cs,NextJSONValue,The conditional expression  "c == '-' || c == '+' || c == '.' || (c >= '0' && c <= '9') ||               c == 'e' || c == 'E'"  is complex.
Complex Conditional,PeterO.Cbor,CBORJson,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORJson.cs,NextJSONValue,The conditional expression  "c != ''' && c != ']' && c != '}' && c != -1 &&               c != 0x20 && c != 0x0a && c != 0x0d && c != 0x09"  is complex.
Complex Conditional,PeterO.Cbor,CBORJson,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORJson.cs,NextJSONValue,The conditional expression  "c == 0x20 || c == 0x0a || c == 0x0d || c == 0x09"  is complex.
Complex Conditional,PeterO.Cbor,CBORJson2,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORJson2.cs,SkipWhitespaceJSON,The conditional expression  "c != 0x20 && c != 0x0a && c != 0x0d && c != 0x09"  is complex.
Complex Conditional,PeterO.Cbor,CBORJson2,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORJson2.cs,NextJSONString,The conditional expression  "c1 < lower || c1 > upper || c2 < 0x80 || c2 > 0xbf"  is complex.
Complex Conditional,PeterO.Cbor,CBORJson2,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORJson2.cs,NextJSONString,The conditional expression  "c1 < lower || c1 > upper || c2 < 0x80 || c2 > 0xbf ||                 c3 < 0x80 || c3 > 0xbf"  is complex.
Complex Conditional,PeterO.Cbor,CBORJson2,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORJson2.cs,NextJSONNegativeNumber,The conditional expression  "c == '-' || c == '+' || c == '.' || (c >= '0' && c <= '9') ||         c == 'e' || c == 'E'"  is complex.
Complex Conditional,PeterO.Cbor,CBORJson2,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORJson2.cs,NextJSONNegativeNumber,The conditional expression  "c != ''' && c != ']' && c != '}' && c != -1 &&         c != 0x20 && c != 0x0a && c != 0x0d && c != 0x09"  is complex.
Complex Conditional,PeterO.Cbor,CBORJson2,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORJson2.cs,NextJSONNegativeNumber,The conditional expression  "c == -1 || (c != 0x20 && c != 0x0a && c != 0x0d && c != 0x09)"  is complex.
Complex Conditional,PeterO.Cbor,CBORJson2,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORJson2.cs,NextJSONNonnegativeNumber,The conditional expression  "!(c == '-' || c == '+' || c == '.' || (c >= '0' && c <= '9') ||           c == 'e' || c == 'E')"  is complex.
Complex Conditional,PeterO.Cbor,CBORJson2,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORJson2.cs,NextJSONNonnegativeNumber,The conditional expression  "!(c == 'e' || c == 'E' || c == '.' || (c >= '0' && c <=                 '9'))"  is complex.
Complex Conditional,PeterO.Cbor,CBORJson2,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORJson2.cs,NextJSONNonnegativeNumber,The conditional expression  "!(c == '-' || c == '+' || c == '.' || c == 'e' || c             == 'E')"  is complex.
Complex Conditional,PeterO.Cbor,CBORJson2,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORJson2.cs,NextJSONNonnegativeNumber,The conditional expression  "c == '-' || c == '+' || c == '.' || (c >= '0' && c <= '9') ||           c == 'e' || c == 'E'"  is complex.
Complex Conditional,PeterO.Cbor,CBORJson2,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORJson2.cs,NextJSONNonnegativeNumber,The conditional expression  "c != ''' && c != ']' && c != '}' && c != -1 &&           c != 0x20 && c != 0x0a && c != 0x0d && c != 0x09"  is complex.
Complex Conditional,PeterO.Cbor,CBORJson2,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORJson2.cs,NextJSONNonnegativeNumber,The conditional expression  "c == -1 || (c != 0x20 && c != 0x0a && c != 0x0d && c != 0x09)"  is complex.
Complex Conditional,PeterO.Cbor,CBORJson2,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORJson2.cs,NextJSONValue,The conditional expression  "this.endPos - this.index <= 2 ||             this.bytes[this.index] != (byte)0x72 ||             this.bytes[this.index + 1] != (byte)0x75 ||             this.bytes[this.index + 2] != (byte)0x65"  is complex.
Complex Conditional,PeterO.Cbor,CBORJson2,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORJson2.cs,NextJSONValue,The conditional expression  "this.endPos - this.index <= 3 ||             this.bytes[this.index] != (byte)0x61 ||             this.bytes[this.index + 1] != (byte)0x6c ||             this.bytes[this.index + 2] != (byte)0x73 ||             this.bytes[this.index + 3] != (byte)0x65"  is complex.
Complex Conditional,PeterO.Cbor,CBORJson2,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORJson2.cs,NextJSONValue,The conditional expression  "this.endPos - this.index <= 2 ||             this.bytes[this.index] != (byte)0x75 ||             this.bytes[this.index + 1] != (byte)0x6c ||             this.bytes[this.index + 2] != (byte)0x6c"  is complex.
Complex Conditional,PeterO.Cbor,CBORJson3,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORJson3.cs,SkipWhitespaceJSON,The conditional expression  "c != 0x20 && c != 0x0a && c != 0x0d && c != 0x09"  is complex.
Complex Conditional,PeterO.Cbor,CBORJson3,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORJson3.cs,NextJSONNegativeNumber,The conditional expression  "c2 == 0x20 || c2 == 0x0a || c2 == 0x0d || c2 == 0x09"  is complex.
Complex Conditional,PeterO.Cbor,CBORJson3,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORJson3.cs,NextJSONNegativeNumber,The conditional expression  "c != ''' && c != ']' && c != '}' && c != -1 &&           c != 0x20 && c != 0x0a && c != 0x0d && c != 0x09"  is complex.
Complex Conditional,PeterO.Cbor,CBORJson3,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORJson3.cs,NextJSONNegativeNumber,The conditional expression  "c == -1 || (c != 0x20 && c != 0x0a && c != 0x0d && c != 0x09)"  is complex.
Complex Conditional,PeterO.Cbor,CBORJson3,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORJson3.cs,NextJSONNonnegativeNumber,The conditional expression  "!(c == '-' || c == '+' || c == '.' || (c >= '0' && c <= '9') ||           c == 'e' || c == 'E')"  is complex.
Complex Conditional,PeterO.Cbor,CBORJson3,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORJson3.cs,NextJSONNonnegativeNumber,The conditional expression  "!(c == 'e' || c == 'E' || c == '.' || (c >= '0' && c <=                 '9'))"  is complex.
Complex Conditional,PeterO.Cbor,CBORJson3,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORJson3.cs,NextJSONNonnegativeNumber,The conditional expression  "!(c == '-' || c == '+' || c == '.' || c == 'e' || c             == 'E')"  is complex.
Complex Conditional,PeterO.Cbor,CBORJson3,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORJson3.cs,NextJSONNonnegativeNumber,The conditional expression  "c != ''' && c != ']' && c != '}' && c != -1 &&           c != 0x20 && c != 0x0a && c != 0x0d && c != 0x09"  is complex.
Complex Conditional,PeterO.Cbor,CBORJson3,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORJson3.cs,NextJSONNonnegativeNumber,The conditional expression  "c == -1 || (c != 0x20 && c != 0x0a && c != 0x0d && c != 0x09)"  is complex.
Complex Conditional,PeterO.Cbor,CBORJson3,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORJson3.cs,NextJSONValue,The conditional expression  "this.endPos - this.index <= 2 ||             (((int)this.jstring[this.index]) & 0xFF) != 'r' ||             (((int)this.jstring[this.index + 1]) & 0xFF) != 'u' ||             (((int)this.jstring[this.index + 2]) & 0xFF) != 'e'"  is complex.
Complex Conditional,PeterO.Cbor,CBORJson3,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORJson3.cs,NextJSONValue,The conditional expression  "this.endPos - this.index <= 3 ||             (((int)this.jstring[this.index]) & 0xFF) != 'a' ||             (((int)this.jstring[this.index + 1]) & 0xFF) != 'l' ||             (((int)this.jstring[this.index + 2]) & 0xFF) != 's' ||             (((int)this.jstring[this.index + 3]) & 0xFF) != 'e'"  is complex.
Complex Conditional,PeterO.Cbor,CBORJson3,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORJson3.cs,NextJSONValue,The conditional expression  "this.endPos - this.index <= 2 ||             (((int)this.jstring[this.index]) & 0xFF) != 'u' ||             (((int)this.jstring[this.index + 1]) & 0xFF) != 'l' ||             (((int)this.jstring[this.index + 2]) & 0xFF) != 'l'"  is complex.
Complex Conditional,PeterO.Cbor,CBORJsonWriter,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORJsonWriter.cs,WriteJSONStringUnquoted,The conditional expression  "c < 0x20 || (c >= 0x7f && (c == 0x2028 || c == 0x2029 ||               (c >= 0x7f && c <= 0xa0) || c == 0xfeff || c == 0xfffe ||               c == 0xffff))"  is complex.
Complex Conditional,PeterO.Cbor,CBORNumber,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORNumber.cs,IsNumber,The conditional expression  "o.HasOneTag(4) ||    o.HasOneTag(5) ||    o.HasOneTag(264) ||    o.HasOneTag(265) ||    o.HasOneTag(268) ||    o.HasOneTag(269)"  is complex.
Complex Conditional,PeterO.Cbor,CBORNumber,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORNumber.cs,FromCBORObject,The conditional expression  "o.HasOneTag(4) ||    o.HasOneTag(5) ||    o.HasOneTag(264) ||    o.HasOneTag(265) ||    o.HasOneTag(268) ||    o.HasOneTag(269)"  is complex.
Complex Conditional,PeterO.Cbor,CBORNumber,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORNumber.cs,Add,The conditional expression  "(valueA < 0 && valueB < Int64.MinValue - valueA) ||           (valueA > 0 && valueB > Int64.MaxValue - valueA)"  is complex.
Complex Conditional,PeterO.Cbor,CBORNumber,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORNumber.cs,Add,The conditional expression  "typeA == NumberKind.EFloat || typeB == NumberKind.EFloat ||         typeA == NumberKind.Double || typeB == NumberKind.Double"  is complex.
Complex Conditional,PeterO.Cbor,CBORNumber,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORNumber.cs,Subtract,The conditional expression  "(valueB < 0 && Int64.MaxValue + valueB < valueA) ||           (valueB > 0 && Int64.MinValue + valueB > valueA)"  is complex.
Complex Conditional,PeterO.Cbor,CBORNumber,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORNumber.cs,Subtract,The conditional expression  "typeA == NumberKind.EFloat || typeB == NumberKind.EFloat ||         typeA == NumberKind.Double || typeB == NumberKind.Double"  is complex.
Complex Conditional,PeterO.Cbor,CBORNumber,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORNumber.cs,Multiply,The conditional expression  "(apos && ((!bpos && (Int64.MinValue / valueA) > valueB) ||               (bpos && valueA > (Int64.MaxValue / valueB)))) ||           (!apos && ((!bpos && valueA != 0L &&                 (Int64.MaxValue / valueA) > valueB) ||               (bpos && valueA < (Int64.MinValue / valueB))))"  is complex.
Complex Conditional,PeterO.Cbor,CBORNumber,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORNumber.cs,Multiply,The conditional expression  "typeA == NumberKind.EFloat || typeB ==         NumberKind.EFloat || typeA == NumberKind.Double || typeB ==         NumberKind.Double"  is complex.
Complex Conditional,PeterO.Cbor,CBORNumber,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORNumber.cs,Divide,The conditional expression  "typeA == NumberKind.EFloat || typeB ==         NumberKind.EFloat || typeA == NumberKind.Double || typeB ==         NumberKind.Double"  is complex.
Complex Conditional,PeterO.Cbor,CBORNumber,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORNumber.cs,Remainder,The conditional expression  "typeA == NumberKind.EFloat ||         typeB == NumberKind.EFloat || typeA == NumberKind.Double || typeB ==         NumberKind.Double"  is complex.
Complex Conditional,PeterO.Cbor,CBORNumber,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORNumber.cs,CompareTo,The conditional expression  "typeA == NumberKind.EFloat || typeB ==             NumberKind.EFloat || typeA == NumberKind.Double || typeB ==             NumberKind.Double"  is complex.
Complex Conditional,PeterO.Cbor,CBORObject,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORObject.cs,DecodeFromBytes,The conditional expression  "!options.Ctap2Canonical ||           (firstbyte >= 0x00 && firstbyte < 0x18) ||           (firstbyte >= 0x20 && firstbyte < 0x38)"  is complex.
Complex Conditional,PeterO.Cbor,CBORObject,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORObject.cs,FromObject,The conditional expression  "bigValue.IsInfinity() || bigValue.IsNaN() ||         (bigValue.IsNegative && bigValue.IsZero)"  is complex.
Complex Conditional,PeterO.Cbor,CBORObject,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORObject.cs,FromObject,The conditional expression  "bigValue.IsInfinity() || bigValue.IsNaN() ||         (bigValue.IsNegative && bigValue.IsZero)"  is complex.
Complex Conditional,PeterO.Cbor,CBORObject,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORObject.cs,FromObject,The conditional expression  "bigValue.IsInfinity() || bigValue.IsNaN() ||         (bigValue.IsNegative && bigValue.IsZero)"  is complex.
Complex Conditional,PeterO.Cbor,CBORObject,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORObject.cs,FromJSONBytes,The conditional expression  "bytes[offset] >= 0x01 && bytes[offset] <= 0x7f && count >= 2 && bytes[offset + 1] != 0"  is complex.
Complex Conditional,PeterO.Cbor,CBORObject,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORObject.cs,Write,The conditional expression  "(bignum.IsZero && bignum.IsNegative) || bignum.IsInfinity() ||         bignum.IsNaN()"  is complex.
Complex Conditional,PeterO.Cbor,CBORObject,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORObject.cs,CompareTo,The conditional expression  "(typeB == CBORObjectTypeInteger && typeA ==           CBORObjectTypeEInteger) || (typeA == CBORObjectTypeInteger && typeB ==           CBORObjectTypeEInteger)"  is complex.
Complex Conditional,PeterO.Cbor,CBORObject,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORObject.cs,EncodeToBytes,The conditional expression  "taggedItem.IsTagged || this.tagHigh != 0 ||           (this.tagLow >> 16) != 0 || this.tagLow >= 24"  is complex.
Complex Conditional,PeterO.Cbor,CBORUtilities,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORUtilities.cs,IsValidDateTime,The conditional expression  "dateTime[1] == 4 || dateTime[1] == 6 || dateTime[1] == 9 ||         dateTime[1] == 11"  is complex.
Complex Conditional,PeterO.Cbor,CBORUuidConverter,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORUuidConverter.cs,FromCBORObject,The conditional expression  "i == 4 || i == 6 || i == 8 || i == 10"  is complex.
Complex Conditional,PeterO.Cbor,CharacterReader,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CharacterReader.cs,ReadChar,The conditional expression  "(c & 0xfc00) == 0xd800 && this.offset + 1 < this.strLength &&           this.str[this.offset + 1] >= 0xdc00 && this.str[this.offset + 1]           <= 0xdfff"  is complex.
Complex Conditional,PeterO.Cbor,CharacterReader,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CharacterReader.cs,DetectUtf8Or16Or32,The conditional expression  "c2 == 0 &&           ((c3 == 0xfe && c4 == 0xff) ||             (c3 == 0 && c4 >= 0x01 && c4 <= 0x7f))"  is complex.
Complex Conditional,PeterO.Cbor,PropertyMap,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\PropertyMap.cs,GetPropertyList,The conditional expression  "pi.CanRead && (pi.CanWrite || anonymous) &&             pi.GetIndexParameters().Length == 0"  is complex.
Magic Number,PeterO.Cbor,Base64,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\Base64.cs,WriteBase64,The following statement contains a magic number: var buffer = new char[4];
Magic Number,PeterO.Cbor,Base64,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\Base64.cs,WriteBase64,The following statement contains a magic number: buffer[0] = (char)alphabet[(data[i] >> 2) & 63];
Magic Number,PeterO.Cbor,Base64,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\Base64.cs,WriteBase64,The following statement contains a magic number: buffer[0] = (char)alphabet[(data[i] >> 2) & 63];
Magic Number,PeterO.Cbor,Base64,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\Base64.cs,WriteBase64,The following statement contains a magic number: buffer[1] = (char)alphabet[((data[i] & 3) << 4) +             ((data[i + 1] >> 4) & 15)];
Magic Number,PeterO.Cbor,Base64,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\Base64.cs,WriteBase64,The following statement contains a magic number: buffer[1] = (char)alphabet[((data[i] & 3) << 4) +             ((data[i + 1] >> 4) & 15)];
Magic Number,PeterO.Cbor,Base64,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\Base64.cs,WriteBase64,The following statement contains a magic number: buffer[1] = (char)alphabet[((data[i] & 3) << 4) +             ((data[i + 1] >> 4) & 15)];
Magic Number,PeterO.Cbor,Base64,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\Base64.cs,WriteBase64,The following statement contains a magic number: buffer[1] = (char)alphabet[((data[i] & 3) << 4) +             ((data[i + 1] >> 4) & 15)];
Magic Number,PeterO.Cbor,Base64,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\Base64.cs,WriteBase64,The following statement contains a magic number: buffer[2] = (char)alphabet[((data[i + 1] & 15) << 2) + ((data[i +                   2] >> 6) & 3)];
Magic Number,PeterO.Cbor,Base64,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\Base64.cs,WriteBase64,The following statement contains a magic number: buffer[2] = (char)alphabet[((data[i + 1] & 15) << 2) + ((data[i +                   2] >> 6) & 3)];
Magic Number,PeterO.Cbor,Base64,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\Base64.cs,WriteBase64,The following statement contains a magic number: buffer[2] = (char)alphabet[((data[i + 1] & 15) << 2) + ((data[i +                   2] >> 6) & 3)];
Magic Number,PeterO.Cbor,Base64,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\Base64.cs,WriteBase64,The following statement contains a magic number: buffer[2] = (char)alphabet[((data[i + 1] & 15) << 2) + ((data[i +                   2] >> 6) & 3)];
Magic Number,PeterO.Cbor,Base64,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\Base64.cs,WriteBase64,The following statement contains a magic number: buffer[2] = (char)alphabet[((data[i + 1] & 15) << 2) + ((data[i +                   2] >> 6) & 3)];
Magic Number,PeterO.Cbor,Base64,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\Base64.cs,WriteBase64,The following statement contains a magic number: buffer[2] = (char)alphabet[((data[i + 1] & 15) << 2) + ((data[i +                   2] >> 6) & 3)];
Magic Number,PeterO.Cbor,Base64,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\Base64.cs,WriteBase64,The following statement contains a magic number: buffer[3] = (char)alphabet[data[i + 2] & 63];
Magic Number,PeterO.Cbor,Base64,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\Base64.cs,WriteBase64,The following statement contains a magic number: buffer[3] = (char)alphabet[data[i + 2] & 63];
Magic Number,PeterO.Cbor,Base64,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\Base64.cs,WriteBase64,The following statement contains a magic number: buffer[3] = (char)alphabet[data[i + 2] & 63];
Magic Number,PeterO.Cbor,Base64,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\Base64.cs,WriteBase64,The following statement contains a magic number: writer.WriteCodePoint((int)buffer[2]);
Magic Number,PeterO.Cbor,Base64,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\Base64.cs,WriteBase64,The following statement contains a magic number: writer.WriteCodePoint((int)buffer[3]);
Magic Number,PeterO.Cbor,Base64,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\Base64.cs,WriteBase64,The following statement contains a magic number: i < (length - 2)
Magic Number,PeterO.Cbor,Base64,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\Base64.cs,WriteBase64,The following statement contains a magic number: int lenmod3 = count % 3;
Magic Number,PeterO.Cbor,Base64,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\Base64.cs,WriteBase64,The following statement contains a magic number: buffer[0] = (char)alphabet[(data[i] >> 2) & 63];
Magic Number,PeterO.Cbor,Base64,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\Base64.cs,WriteBase64,The following statement contains a magic number: buffer[0] = (char)alphabet[(data[i] >> 2) & 63];
Magic Number,PeterO.Cbor,Base64,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\Base64.cs,WriteBase64,The following statement contains a magic number: buffer[1] = (char)alphabet[((data[i] & 3) << 4) + ((data[i + 1] >>                   4) & 15)];
Magic Number,PeterO.Cbor,Base64,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\Base64.cs,WriteBase64,The following statement contains a magic number: buffer[1] = (char)alphabet[((data[i] & 3) << 4) + ((data[i + 1] >>                   4) & 15)];
Magic Number,PeterO.Cbor,Base64,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\Base64.cs,WriteBase64,The following statement contains a magic number: buffer[1] = (char)alphabet[((data[i] & 3) << 4) + ((data[i + 1] >>                   4) & 15)];
Magic Number,PeterO.Cbor,Base64,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\Base64.cs,WriteBase64,The following statement contains a magic number: buffer[1] = (char)alphabet[((data[i] & 3) << 4) + ((data[i + 1] >>                   4) & 15)];
Magic Number,PeterO.Cbor,Base64,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\Base64.cs,WriteBase64,The following statement contains a magic number: buffer[2] = (char)alphabet[(data[i + 1] & 15) << 2];
Magic Number,PeterO.Cbor,Base64,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\Base64.cs,WriteBase64,The following statement contains a magic number: buffer[2] = (char)alphabet[(data[i + 1] & 15) << 2];
Magic Number,PeterO.Cbor,Base64,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\Base64.cs,WriteBase64,The following statement contains a magic number: buffer[2] = (char)alphabet[(data[i + 1] & 15) << 2];
Magic Number,PeterO.Cbor,Base64,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\Base64.cs,WriteBase64,The following statement contains a magic number: writer.WriteCodePoint((int)buffer[2]);
Magic Number,PeterO.Cbor,Base64,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\Base64.cs,WriteBase64,The following statement contains a magic number: lenmod3 == 2
Magic Number,PeterO.Cbor,CBORCanonical,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORCanonical.cs,CheckDepth,The following statement contains a magic number: depth >= 3 && IsArrayOrMap(cbor[i])
Magic Number,PeterO.Cbor,CBORCanonical,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORCanonical.cs,CtapCanonicalEncode,The following statement contains a magic number: CBORObject.WriteValue(ms' 4' cbor.Count);
Magic Number,PeterO.Cbor,CBORCanonical,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORCanonical.cs,CtapCanonicalEncode,The following statement contains a magic number: depth >= 3 && IsArrayOrMap(cbor[i])
Magic Number,PeterO.Cbor,CtapComparer,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORCanonical.cs,MajorType,The following statement contains a magic number: return 6;
Magic Number,PeterO.Cbor,CtapComparer,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORCanonical.cs,MajorType,The following statement contains a magic number: switch (a.Type) {           case CBORType.Integer:             return a.AsNumber().IsNegative() ? 1 : 0;           case CBORType.SimpleValue:           case CBORType.Boolean:           case CBORType.FloatingPoint:             return 7;           case CBORType.ByteString:             return 2;           case CBORType.TextString:             return 3;           case CBORType.Array:             return 4;           case CBORType.Map:             return 5;           default: throw new InvalidOperationException();         }
Magic Number,PeterO.Cbor,CtapComparer,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORCanonical.cs,MajorType,The following statement contains a magic number: switch (a.Type) {           case CBORType.Integer:             return a.AsNumber().IsNegative() ? 1 : 0;           case CBORType.SimpleValue:           case CBORType.Boolean:           case CBORType.FloatingPoint:             return 7;           case CBORType.ByteString:             return 2;           case CBORType.TextString:             return 3;           case CBORType.Array:             return 4;           case CBORType.Map:             return 5;           default: throw new InvalidOperationException();         }
Magic Number,PeterO.Cbor,CtapComparer,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORCanonical.cs,MajorType,The following statement contains a magic number: switch (a.Type) {           case CBORType.Integer:             return a.AsNumber().IsNegative() ? 1 : 0;           case CBORType.SimpleValue:           case CBORType.Boolean:           case CBORType.FloatingPoint:             return 7;           case CBORType.ByteString:             return 2;           case CBORType.TextString:             return 3;           case CBORType.Array:             return 4;           case CBORType.Map:             return 5;           default: throw new InvalidOperationException();         }
Magic Number,PeterO.Cbor,CtapComparer,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORCanonical.cs,MajorType,The following statement contains a magic number: switch (a.Type) {           case CBORType.Integer:             return a.AsNumber().IsNegative() ? 1 : 0;           case CBORType.SimpleValue:           case CBORType.Boolean:           case CBORType.FloatingPoint:             return 7;           case CBORType.ByteString:             return 2;           case CBORType.TextString:             return 3;           case CBORType.Array:             return 4;           case CBORType.Map:             return 5;           default: throw new InvalidOperationException();         }
Magic Number,PeterO.Cbor,CtapComparer,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORCanonical.cs,MajorType,The following statement contains a magic number: switch (a.Type) {           case CBORType.Integer:             return a.AsNumber().IsNegative() ? 1 : 0;           case CBORType.SimpleValue:           case CBORType.Boolean:           case CBORType.FloatingPoint:             return 7;           case CBORType.ByteString:             return 2;           case CBORType.TextString:             return 3;           case CBORType.Array:             return 4;           case CBORType.Map:             return 5;           default: throw new InvalidOperationException();         }
Magic Number,PeterO.Cbor,CtapComparer,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORCanonical.cs,Compare,The following statement contains a magic number: amt == 2
Magic Number,PeterO.Cbor,CBORDataUtilities,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORDataUtilities.cs,ToStringHelper,The following statement contains a magic number: sb = new StringBuilder(Math.Min(str.Length' 4096) + 16);
Magic Number,PeterO.Cbor,CBORDataUtilities,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORDataUtilities.cs,ToStringHelper,The following statement contains a magic number: sb = new StringBuilder(Math.Min(str.Length' 4096) + 16);
Magic Number,PeterO.Cbor,CBORDataUtilities,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORDataUtilities.cs,ToStringHelper,The following statement contains a magic number: switch (type) {         case CBORType.SimpleValue:           sb = sb ?? new StringBuilder();           if (obj.IsUndefined) {             sb.Append("undefined");           } else if (obj.IsNull) {             sb.Append("null");           } else {             sb.Append("simple(");             int thisItemInt = obj.SimpleValue;             char c;             if (thisItemInt >= 100) {               // NOTE: '0'-'9' have ASCII code 0x30-0x39               c = (char)(0x30 + ((thisItemInt / 100) % 10));               sb.Append(c);             }             if (thisItemInt >= 10) {               c = (char)(0x30 + ((thisItemInt / 10) % 10));               sb.Append(c);               c = (char)(0x30 + (thisItemInt % 10));             } else {               c = (char)(0x30 + thisItemInt);             }             sb.Append(c);             sb.Append(")");           }           break;         case CBORType.Boolean:         case CBORType.Integer:           simvalue = obj.Untag().ToJSONString();           if (sb == null) {             return simvalue;           }           sb.Append(simvalue);           break;         case CBORType.FloatingPoint: {           double f = obj.AsDoubleValue();           simvalue = Double.IsNegativeInfinity(f) ? "-Infinity" : (Double.IsPositiveInfinity(f) ? "Infinity" : (Double.IsNaN(f) ?                  "NaN" : obj.Untag().ToJSONString()));           if (sb == null) {             return simvalue;           }           sb.Append(simvalue);           break;         }         case CBORType.ByteString: {           sb = sb ?? new StringBuilder();           sb.Append("h'");           byte[] data = obj.GetByteString();           int length = data.Length;           for (var i = 0; i < length; ++i) {             sb.Append(HexAlphabet[(data[i] >> 4) & 15]);             sb.Append(HexAlphabet[data[i] & 15]);           }           sb.Append("'");           break;         }         case CBORType.TextString: {           if (sb == null) {             return "\"" + obj.AsString() + "\"";           }           sb.Append('\"');           sb.Append(obj.AsString());           sb.Append('\"');           break;         }         case CBORType.Array: {           sb = sb ?? new StringBuilder();           var first = true;           sb.Append("[");           if (depth >= 50) {             sb.Append("...");           } else {             for (var i = 0; i < obj.Count; ++i) {               if (!first) {                 sb.Append("' ");               }               sb.Append(ToStringHelper(obj[i]' depth + 1));               first = false;             }           }           sb.Append("]");           break;         }         case CBORType.Map: {           sb = sb ?? new StringBuilder();           var first = true;           sb.Append("{");           if (depth >= 50) {             sb.Append("...");           } else {             ICollection<KeyValuePair<CBORObject' CBORObject>> entries =               obj.Entries;             foreach (KeyValuePair<CBORObject' CBORObject> entry               in entries) {               CBORObject key = entry.Key;               CBORObject value = entry.Value;               if (!first) {                 sb.Append("' ");               }               sb.Append(ToStringHelper(key' depth + 1));               sb.Append(": ");               sb.Append(ToStringHelper(value' depth + 1));               first = false;             }           }           sb.Append("}");           break;         }         default: {           sb = sb ?? new StringBuilder();           sb.Append("???");           break;         }       }
Magic Number,PeterO.Cbor,CBORDataUtilities,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORDataUtilities.cs,ToStringHelper,The following statement contains a magic number: switch (type) {         case CBORType.SimpleValue:           sb = sb ?? new StringBuilder();           if (obj.IsUndefined) {             sb.Append("undefined");           } else if (obj.IsNull) {             sb.Append("null");           } else {             sb.Append("simple(");             int thisItemInt = obj.SimpleValue;             char c;             if (thisItemInt >= 100) {               // NOTE: '0'-'9' have ASCII code 0x30-0x39               c = (char)(0x30 + ((thisItemInt / 100) % 10));               sb.Append(c);             }             if (thisItemInt >= 10) {               c = (char)(0x30 + ((thisItemInt / 10) % 10));               sb.Append(c);               c = (char)(0x30 + (thisItemInt % 10));             } else {               c = (char)(0x30 + thisItemInt);             }             sb.Append(c);             sb.Append(")");           }           break;         case CBORType.Boolean:         case CBORType.Integer:           simvalue = obj.Untag().ToJSONString();           if (sb == null) {             return simvalue;           }           sb.Append(simvalue);           break;         case CBORType.FloatingPoint: {           double f = obj.AsDoubleValue();           simvalue = Double.IsNegativeInfinity(f) ? "-Infinity" : (Double.IsPositiveInfinity(f) ? "Infinity" : (Double.IsNaN(f) ?                  "NaN" : obj.Untag().ToJSONString()));           if (sb == null) {             return simvalue;           }           sb.Append(simvalue);           break;         }         case CBORType.ByteString: {           sb = sb ?? new StringBuilder();           sb.Append("h'");           byte[] data = obj.GetByteString();           int length = data.Length;           for (var i = 0; i < length; ++i) {             sb.Append(HexAlphabet[(data[i] >> 4) & 15]);             sb.Append(HexAlphabet[data[i] & 15]);           }           sb.Append("'");           break;         }         case CBORType.TextString: {           if (sb == null) {             return "\"" + obj.AsString() + "\"";           }           sb.Append('\"');           sb.Append(obj.AsString());           sb.Append('\"');           break;         }         case CBORType.Array: {           sb = sb ?? new StringBuilder();           var first = true;           sb.Append("[");           if (depth >= 50) {             sb.Append("...");           } else {             for (var i = 0; i < obj.Count; ++i) {               if (!first) {                 sb.Append("' ");               }               sb.Append(ToStringHelper(obj[i]' depth + 1));               first = false;             }           }           sb.Append("]");           break;         }         case CBORType.Map: {           sb = sb ?? new StringBuilder();           var first = true;           sb.Append("{");           if (depth >= 50) {             sb.Append("...");           } else {             ICollection<KeyValuePair<CBORObject' CBORObject>> entries =               obj.Entries;             foreach (KeyValuePair<CBORObject' CBORObject> entry               in entries) {               CBORObject key = entry.Key;               CBORObject value = entry.Value;               if (!first) {                 sb.Append("' ");               }               sb.Append(ToStringHelper(key' depth + 1));               sb.Append(": ");               sb.Append(ToStringHelper(value' depth + 1));               first = false;             }           }           sb.Append("}");           break;         }         default: {           sb = sb ?? new StringBuilder();           sb.Append("???");           break;         }       }
Magic Number,PeterO.Cbor,CBORDataUtilities,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORDataUtilities.cs,ToStringHelper,The following statement contains a magic number: switch (type) {         case CBORType.SimpleValue:           sb = sb ?? new StringBuilder();           if (obj.IsUndefined) {             sb.Append("undefined");           } else if (obj.IsNull) {             sb.Append("null");           } else {             sb.Append("simple(");             int thisItemInt = obj.SimpleValue;             char c;             if (thisItemInt >= 100) {               // NOTE: '0'-'9' have ASCII code 0x30-0x39               c = (char)(0x30 + ((thisItemInt / 100) % 10));               sb.Append(c);             }             if (thisItemInt >= 10) {               c = (char)(0x30 + ((thisItemInt / 10) % 10));               sb.Append(c);               c = (char)(0x30 + (thisItemInt % 10));             } else {               c = (char)(0x30 + thisItemInt);             }             sb.Append(c);             sb.Append(")");           }           break;         case CBORType.Boolean:         case CBORType.Integer:           simvalue = obj.Untag().ToJSONString();           if (sb == null) {             return simvalue;           }           sb.Append(simvalue);           break;         case CBORType.FloatingPoint: {           double f = obj.AsDoubleValue();           simvalue = Double.IsNegativeInfinity(f) ? "-Infinity" : (Double.IsPositiveInfinity(f) ? "Infinity" : (Double.IsNaN(f) ?                  "NaN" : obj.Untag().ToJSONString()));           if (sb == null) {             return simvalue;           }           sb.Append(simvalue);           break;         }         case CBORType.ByteString: {           sb = sb ?? new StringBuilder();           sb.Append("h'");           byte[] data = obj.GetByteString();           int length = data.Length;           for (var i = 0; i < length; ++i) {             sb.Append(HexAlphabet[(data[i] >> 4) & 15]);             sb.Append(HexAlphabet[data[i] & 15]);           }           sb.Append("'");           break;         }         case CBORType.TextString: {           if (sb == null) {             return "\"" + obj.AsString() + "\"";           }           sb.Append('\"');           sb.Append(obj.AsString());           sb.Append('\"');           break;         }         case CBORType.Array: {           sb = sb ?? new StringBuilder();           var first = true;           sb.Append("[");           if (depth >= 50) {             sb.Append("...");           } else {             for (var i = 0; i < obj.Count; ++i) {               if (!first) {                 sb.Append("' ");               }               sb.Append(ToStringHelper(obj[i]' depth + 1));               first = false;             }           }           sb.Append("]");           break;         }         case CBORType.Map: {           sb = sb ?? new StringBuilder();           var first = true;           sb.Append("{");           if (depth >= 50) {             sb.Append("...");           } else {             ICollection<KeyValuePair<CBORObject' CBORObject>> entries =               obj.Entries;             foreach (KeyValuePair<CBORObject' CBORObject> entry               in entries) {               CBORObject key = entry.Key;               CBORObject value = entry.Value;               if (!first) {                 sb.Append("' ");               }               sb.Append(ToStringHelper(key' depth + 1));               sb.Append(": ");               sb.Append(ToStringHelper(value' depth + 1));               first = false;             }           }           sb.Append("}");           break;         }         default: {           sb = sb ?? new StringBuilder();           sb.Append("???");           break;         }       }
Magic Number,PeterO.Cbor,CBORDataUtilities,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORDataUtilities.cs,ToStringHelper,The following statement contains a magic number: switch (type) {         case CBORType.SimpleValue:           sb = sb ?? new StringBuilder();           if (obj.IsUndefined) {             sb.Append("undefined");           } else if (obj.IsNull) {             sb.Append("null");           } else {             sb.Append("simple(");             int thisItemInt = obj.SimpleValue;             char c;             if (thisItemInt >= 100) {               // NOTE: '0'-'9' have ASCII code 0x30-0x39               c = (char)(0x30 + ((thisItemInt / 100) % 10));               sb.Append(c);             }             if (thisItemInt >= 10) {               c = (char)(0x30 + ((thisItemInt / 10) % 10));               sb.Append(c);               c = (char)(0x30 + (thisItemInt % 10));             } else {               c = (char)(0x30 + thisItemInt);             }             sb.Append(c);             sb.Append(")");           }           break;         case CBORType.Boolean:         case CBORType.Integer:           simvalue = obj.Untag().ToJSONString();           if (sb == null) {             return simvalue;           }           sb.Append(simvalue);           break;         case CBORType.FloatingPoint: {           double f = obj.AsDoubleValue();           simvalue = Double.IsNegativeInfinity(f) ? "-Infinity" : (Double.IsPositiveInfinity(f) ? "Infinity" : (Double.IsNaN(f) ?                  "NaN" : obj.Untag().ToJSONString()));           if (sb == null) {             return simvalue;           }           sb.Append(simvalue);           break;         }         case CBORType.ByteString: {           sb = sb ?? new StringBuilder();           sb.Append("h'");           byte[] data = obj.GetByteString();           int length = data.Length;           for (var i = 0; i < length; ++i) {             sb.Append(HexAlphabet[(data[i] >> 4) & 15]);             sb.Append(HexAlphabet[data[i] & 15]);           }           sb.Append("'");           break;         }         case CBORType.TextString: {           if (sb == null) {             return "\"" + obj.AsString() + "\"";           }           sb.Append('\"');           sb.Append(obj.AsString());           sb.Append('\"');           break;         }         case CBORType.Array: {           sb = sb ?? new StringBuilder();           var first = true;           sb.Append("[");           if (depth >= 50) {             sb.Append("...");           } else {             for (var i = 0; i < obj.Count; ++i) {               if (!first) {                 sb.Append("' ");               }               sb.Append(ToStringHelper(obj[i]' depth + 1));               first = false;             }           }           sb.Append("]");           break;         }         case CBORType.Map: {           sb = sb ?? new StringBuilder();           var first = true;           sb.Append("{");           if (depth >= 50) {             sb.Append("...");           } else {             ICollection<KeyValuePair<CBORObject' CBORObject>> entries =               obj.Entries;             foreach (KeyValuePair<CBORObject' CBORObject> entry               in entries) {               CBORObject key = entry.Key;               CBORObject value = entry.Value;               if (!first) {                 sb.Append("' ");               }               sb.Append(ToStringHelper(key' depth + 1));               sb.Append(": ");               sb.Append(ToStringHelper(value' depth + 1));               first = false;             }           }           sb.Append("}");           break;         }         default: {           sb = sb ?? new StringBuilder();           sb.Append("???");           break;         }       }
Magic Number,PeterO.Cbor,CBORDataUtilities,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORDataUtilities.cs,ToStringHelper,The following statement contains a magic number: switch (type) {         case CBORType.SimpleValue:           sb = sb ?? new StringBuilder();           if (obj.IsUndefined) {             sb.Append("undefined");           } else if (obj.IsNull) {             sb.Append("null");           } else {             sb.Append("simple(");             int thisItemInt = obj.SimpleValue;             char c;             if (thisItemInt >= 100) {               // NOTE: '0'-'9' have ASCII code 0x30-0x39               c = (char)(0x30 + ((thisItemInt / 100) % 10));               sb.Append(c);             }             if (thisItemInt >= 10) {               c = (char)(0x30 + ((thisItemInt / 10) % 10));               sb.Append(c);               c = (char)(0x30 + (thisItemInt % 10));             } else {               c = (char)(0x30 + thisItemInt);             }             sb.Append(c);             sb.Append(")");           }           break;         case CBORType.Boolean:         case CBORType.Integer:           simvalue = obj.Untag().ToJSONString();           if (sb == null) {             return simvalue;           }           sb.Append(simvalue);           break;         case CBORType.FloatingPoint: {           double f = obj.AsDoubleValue();           simvalue = Double.IsNegativeInfinity(f) ? "-Infinity" : (Double.IsPositiveInfinity(f) ? "Infinity" : (Double.IsNaN(f) ?                  "NaN" : obj.Untag().ToJSONString()));           if (sb == null) {             return simvalue;           }           sb.Append(simvalue);           break;         }         case CBORType.ByteString: {           sb = sb ?? new StringBuilder();           sb.Append("h'");           byte[] data = obj.GetByteString();           int length = data.Length;           for (var i = 0; i < length; ++i) {             sb.Append(HexAlphabet[(data[i] >> 4) & 15]);             sb.Append(HexAlphabet[data[i] & 15]);           }           sb.Append("'");           break;         }         case CBORType.TextString: {           if (sb == null) {             return "\"" + obj.AsString() + "\"";           }           sb.Append('\"');           sb.Append(obj.AsString());           sb.Append('\"');           break;         }         case CBORType.Array: {           sb = sb ?? new StringBuilder();           var first = true;           sb.Append("[");           if (depth >= 50) {             sb.Append("...");           } else {             for (var i = 0; i < obj.Count; ++i) {               if (!first) {                 sb.Append("' ");               }               sb.Append(ToStringHelper(obj[i]' depth + 1));               first = false;             }           }           sb.Append("]");           break;         }         case CBORType.Map: {           sb = sb ?? new StringBuilder();           var first = true;           sb.Append("{");           if (depth >= 50) {             sb.Append("...");           } else {             ICollection<KeyValuePair<CBORObject' CBORObject>> entries =               obj.Entries;             foreach (KeyValuePair<CBORObject' CBORObject> entry               in entries) {               CBORObject key = entry.Key;               CBORObject value = entry.Value;               if (!first) {                 sb.Append("' ");               }               sb.Append(ToStringHelper(key' depth + 1));               sb.Append(": ");               sb.Append(ToStringHelper(value' depth + 1));               first = false;             }           }           sb.Append("}");           break;         }         default: {           sb = sb ?? new StringBuilder();           sb.Append("???");           break;         }       }
Magic Number,PeterO.Cbor,CBORDataUtilities,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORDataUtilities.cs,ToStringHelper,The following statement contains a magic number: switch (type) {         case CBORType.SimpleValue:           sb = sb ?? new StringBuilder();           if (obj.IsUndefined) {             sb.Append("undefined");           } else if (obj.IsNull) {             sb.Append("null");           } else {             sb.Append("simple(");             int thisItemInt = obj.SimpleValue;             char c;             if (thisItemInt >= 100) {               // NOTE: '0'-'9' have ASCII code 0x30-0x39               c = (char)(0x30 + ((thisItemInt / 100) % 10));               sb.Append(c);             }             if (thisItemInt >= 10) {               c = (char)(0x30 + ((thisItemInt / 10) % 10));               sb.Append(c);               c = (char)(0x30 + (thisItemInt % 10));             } else {               c = (char)(0x30 + thisItemInt);             }             sb.Append(c);             sb.Append(")");           }           break;         case CBORType.Boolean:         case CBORType.Integer:           simvalue = obj.Untag().ToJSONString();           if (sb == null) {             return simvalue;           }           sb.Append(simvalue);           break;         case CBORType.FloatingPoint: {           double f = obj.AsDoubleValue();           simvalue = Double.IsNegativeInfinity(f) ? "-Infinity" : (Double.IsPositiveInfinity(f) ? "Infinity" : (Double.IsNaN(f) ?                  "NaN" : obj.Untag().ToJSONString()));           if (sb == null) {             return simvalue;           }           sb.Append(simvalue);           break;         }         case CBORType.ByteString: {           sb = sb ?? new StringBuilder();           sb.Append("h'");           byte[] data = obj.GetByteString();           int length = data.Length;           for (var i = 0; i < length; ++i) {             sb.Append(HexAlphabet[(data[i] >> 4) & 15]);             sb.Append(HexAlphabet[data[i] & 15]);           }           sb.Append("'");           break;         }         case CBORType.TextString: {           if (sb == null) {             return "\"" + obj.AsString() + "\"";           }           sb.Append('\"');           sb.Append(obj.AsString());           sb.Append('\"');           break;         }         case CBORType.Array: {           sb = sb ?? new StringBuilder();           var first = true;           sb.Append("[");           if (depth >= 50) {             sb.Append("...");           } else {             for (var i = 0; i < obj.Count; ++i) {               if (!first) {                 sb.Append("' ");               }               sb.Append(ToStringHelper(obj[i]' depth + 1));               first = false;             }           }           sb.Append("]");           break;         }         case CBORType.Map: {           sb = sb ?? new StringBuilder();           var first = true;           sb.Append("{");           if (depth >= 50) {             sb.Append("...");           } else {             ICollection<KeyValuePair<CBORObject' CBORObject>> entries =               obj.Entries;             foreach (KeyValuePair<CBORObject' CBORObject> entry               in entries) {               CBORObject key = entry.Key;               CBORObject value = entry.Value;               if (!first) {                 sb.Append("' ");               }               sb.Append(ToStringHelper(key' depth + 1));               sb.Append(": ");               sb.Append(ToStringHelper(value' depth + 1));               first = false;             }           }           sb.Append("}");           break;         }         default: {           sb = sb ?? new StringBuilder();           sb.Append("???");           break;         }       }
Magic Number,PeterO.Cbor,CBORDataUtilities,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORDataUtilities.cs,ToStringHelper,The following statement contains a magic number: switch (type) {         case CBORType.SimpleValue:           sb = sb ?? new StringBuilder();           if (obj.IsUndefined) {             sb.Append("undefined");           } else if (obj.IsNull) {             sb.Append("null");           } else {             sb.Append("simple(");             int thisItemInt = obj.SimpleValue;             char c;             if (thisItemInt >= 100) {               // NOTE: '0'-'9' have ASCII code 0x30-0x39               c = (char)(0x30 + ((thisItemInt / 100) % 10));               sb.Append(c);             }             if (thisItemInt >= 10) {               c = (char)(0x30 + ((thisItemInt / 10) % 10));               sb.Append(c);               c = (char)(0x30 + (thisItemInt % 10));             } else {               c = (char)(0x30 + thisItemInt);             }             sb.Append(c);             sb.Append(")");           }           break;         case CBORType.Boolean:         case CBORType.Integer:           simvalue = obj.Untag().ToJSONString();           if (sb == null) {             return simvalue;           }           sb.Append(simvalue);           break;         case CBORType.FloatingPoint: {           double f = obj.AsDoubleValue();           simvalue = Double.IsNegativeInfinity(f) ? "-Infinity" : (Double.IsPositiveInfinity(f) ? "Infinity" : (Double.IsNaN(f) ?                  "NaN" : obj.Untag().ToJSONString()));           if (sb == null) {             return simvalue;           }           sb.Append(simvalue);           break;         }         case CBORType.ByteString: {           sb = sb ?? new StringBuilder();           sb.Append("h'");           byte[] data = obj.GetByteString();           int length = data.Length;           for (var i = 0; i < length; ++i) {             sb.Append(HexAlphabet[(data[i] >> 4) & 15]);             sb.Append(HexAlphabet[data[i] & 15]);           }           sb.Append("'");           break;         }         case CBORType.TextString: {           if (sb == null) {             return "\"" + obj.AsString() + "\"";           }           sb.Append('\"');           sb.Append(obj.AsString());           sb.Append('\"');           break;         }         case CBORType.Array: {           sb = sb ?? new StringBuilder();           var first = true;           sb.Append("[");           if (depth >= 50) {             sb.Append("...");           } else {             for (var i = 0; i < obj.Count; ++i) {               if (!first) {                 sb.Append("' ");               }               sb.Append(ToStringHelper(obj[i]' depth + 1));               first = false;             }           }           sb.Append("]");           break;         }         case CBORType.Map: {           sb = sb ?? new StringBuilder();           var first = true;           sb.Append("{");           if (depth >= 50) {             sb.Append("...");           } else {             ICollection<KeyValuePair<CBORObject' CBORObject>> entries =               obj.Entries;             foreach (KeyValuePair<CBORObject' CBORObject> entry               in entries) {               CBORObject key = entry.Key;               CBORObject value = entry.Value;               if (!first) {                 sb.Append("' ");               }               sb.Append(ToStringHelper(key' depth + 1));               sb.Append(": ");               sb.Append(ToStringHelper(value' depth + 1));               first = false;             }           }           sb.Append("}");           break;         }         default: {           sb = sb ?? new StringBuilder();           sb.Append("???");           break;         }       }
Magic Number,PeterO.Cbor,CBORDataUtilities,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORDataUtilities.cs,ToStringHelper,The following statement contains a magic number: switch (type) {         case CBORType.SimpleValue:           sb = sb ?? new StringBuilder();           if (obj.IsUndefined) {             sb.Append("undefined");           } else if (obj.IsNull) {             sb.Append("null");           } else {             sb.Append("simple(");             int thisItemInt = obj.SimpleValue;             char c;             if (thisItemInt >= 100) {               // NOTE: '0'-'9' have ASCII code 0x30-0x39               c = (char)(0x30 + ((thisItemInt / 100) % 10));               sb.Append(c);             }             if (thisItemInt >= 10) {               c = (char)(0x30 + ((thisItemInt / 10) % 10));               sb.Append(c);               c = (char)(0x30 + (thisItemInt % 10));             } else {               c = (char)(0x30 + thisItemInt);             }             sb.Append(c);             sb.Append(")");           }           break;         case CBORType.Boolean:         case CBORType.Integer:           simvalue = obj.Untag().ToJSONString();           if (sb == null) {             return simvalue;           }           sb.Append(simvalue);           break;         case CBORType.FloatingPoint: {           double f = obj.AsDoubleValue();           simvalue = Double.IsNegativeInfinity(f) ? "-Infinity" : (Double.IsPositiveInfinity(f) ? "Infinity" : (Double.IsNaN(f) ?                  "NaN" : obj.Untag().ToJSONString()));           if (sb == null) {             return simvalue;           }           sb.Append(simvalue);           break;         }         case CBORType.ByteString: {           sb = sb ?? new StringBuilder();           sb.Append("h'");           byte[] data = obj.GetByteString();           int length = data.Length;           for (var i = 0; i < length; ++i) {             sb.Append(HexAlphabet[(data[i] >> 4) & 15]);             sb.Append(HexAlphabet[data[i] & 15]);           }           sb.Append("'");           break;         }         case CBORType.TextString: {           if (sb == null) {             return "\"" + obj.AsString() + "\"";           }           sb.Append('\"');           sb.Append(obj.AsString());           sb.Append('\"');           break;         }         case CBORType.Array: {           sb = sb ?? new StringBuilder();           var first = true;           sb.Append("[");           if (depth >= 50) {             sb.Append("...");           } else {             for (var i = 0; i < obj.Count; ++i) {               if (!first) {                 sb.Append("' ");               }               sb.Append(ToStringHelper(obj[i]' depth + 1));               first = false;             }           }           sb.Append("]");           break;         }         case CBORType.Map: {           sb = sb ?? new StringBuilder();           var first = true;           sb.Append("{");           if (depth >= 50) {             sb.Append("...");           } else {             ICollection<KeyValuePair<CBORObject' CBORObject>> entries =               obj.Entries;             foreach (KeyValuePair<CBORObject' CBORObject> entry               in entries) {               CBORObject key = entry.Key;               CBORObject value = entry.Value;               if (!first) {                 sb.Append("' ");               }               sb.Append(ToStringHelper(key' depth + 1));               sb.Append(": ");               sb.Append(ToStringHelper(value' depth + 1));               first = false;             }           }           sb.Append("}");           break;         }         default: {           sb = sb ?? new StringBuilder();           sb.Append("???");           break;         }       }
Magic Number,PeterO.Cbor,CBORDataUtilities,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORDataUtilities.cs,ToStringHelper,The following statement contains a magic number: switch (type) {         case CBORType.SimpleValue:           sb = sb ?? new StringBuilder();           if (obj.IsUndefined) {             sb.Append("undefined");           } else if (obj.IsNull) {             sb.Append("null");           } else {             sb.Append("simple(");             int thisItemInt = obj.SimpleValue;             char c;             if (thisItemInt >= 100) {               // NOTE: '0'-'9' have ASCII code 0x30-0x39               c = (char)(0x30 + ((thisItemInt / 100) % 10));               sb.Append(c);             }             if (thisItemInt >= 10) {               c = (char)(0x30 + ((thisItemInt / 10) % 10));               sb.Append(c);               c = (char)(0x30 + (thisItemInt % 10));             } else {               c = (char)(0x30 + thisItemInt);             }             sb.Append(c);             sb.Append(")");           }           break;         case CBORType.Boolean:         case CBORType.Integer:           simvalue = obj.Untag().ToJSONString();           if (sb == null) {             return simvalue;           }           sb.Append(simvalue);           break;         case CBORType.FloatingPoint: {           double f = obj.AsDoubleValue();           simvalue = Double.IsNegativeInfinity(f) ? "-Infinity" : (Double.IsPositiveInfinity(f) ? "Infinity" : (Double.IsNaN(f) ?                  "NaN" : obj.Untag().ToJSONString()));           if (sb == null) {             return simvalue;           }           sb.Append(simvalue);           break;         }         case CBORType.ByteString: {           sb = sb ?? new StringBuilder();           sb.Append("h'");           byte[] data = obj.GetByteString();           int length = data.Length;           for (var i = 0; i < length; ++i) {             sb.Append(HexAlphabet[(data[i] >> 4) & 15]);             sb.Append(HexAlphabet[data[i] & 15]);           }           sb.Append("'");           break;         }         case CBORType.TextString: {           if (sb == null) {             return "\"" + obj.AsString() + "\"";           }           sb.Append('\"');           sb.Append(obj.AsString());           sb.Append('\"');           break;         }         case CBORType.Array: {           sb = sb ?? new StringBuilder();           var first = true;           sb.Append("[");           if (depth >= 50) {             sb.Append("...");           } else {             for (var i = 0; i < obj.Count; ++i) {               if (!first) {                 sb.Append("' ");               }               sb.Append(ToStringHelper(obj[i]' depth + 1));               first = false;             }           }           sb.Append("]");           break;         }         case CBORType.Map: {           sb = sb ?? new StringBuilder();           var first = true;           sb.Append("{");           if (depth >= 50) {             sb.Append("...");           } else {             ICollection<KeyValuePair<CBORObject' CBORObject>> entries =               obj.Entries;             foreach (KeyValuePair<CBORObject' CBORObject> entry               in entries) {               CBORObject key = entry.Key;               CBORObject value = entry.Value;               if (!first) {                 sb.Append("' ");               }               sb.Append(ToStringHelper(key' depth + 1));               sb.Append(": ");               sb.Append(ToStringHelper(value' depth + 1));               first = false;             }           }           sb.Append("}");           break;         }         default: {           sb = sb ?? new StringBuilder();           sb.Append("???");           break;         }       }
Magic Number,PeterO.Cbor,CBORDataUtilities,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORDataUtilities.cs,ToStringHelper,The following statement contains a magic number: switch (type) {         case CBORType.SimpleValue:           sb = sb ?? new StringBuilder();           if (obj.IsUndefined) {             sb.Append("undefined");           } else if (obj.IsNull) {             sb.Append("null");           } else {             sb.Append("simple(");             int thisItemInt = obj.SimpleValue;             char c;             if (thisItemInt >= 100) {               // NOTE: '0'-'9' have ASCII code 0x30-0x39               c = (char)(0x30 + ((thisItemInt / 100) % 10));               sb.Append(c);             }             if (thisItemInt >= 10) {               c = (char)(0x30 + ((thisItemInt / 10) % 10));               sb.Append(c);               c = (char)(0x30 + (thisItemInt % 10));             } else {               c = (char)(0x30 + thisItemInt);             }             sb.Append(c);             sb.Append(")");           }           break;         case CBORType.Boolean:         case CBORType.Integer:           simvalue = obj.Untag().ToJSONString();           if (sb == null) {             return simvalue;           }           sb.Append(simvalue);           break;         case CBORType.FloatingPoint: {           double f = obj.AsDoubleValue();           simvalue = Double.IsNegativeInfinity(f) ? "-Infinity" : (Double.IsPositiveInfinity(f) ? "Infinity" : (Double.IsNaN(f) ?                  "NaN" : obj.Untag().ToJSONString()));           if (sb == null) {             return simvalue;           }           sb.Append(simvalue);           break;         }         case CBORType.ByteString: {           sb = sb ?? new StringBuilder();           sb.Append("h'");           byte[] data = obj.GetByteString();           int length = data.Length;           for (var i = 0; i < length; ++i) {             sb.Append(HexAlphabet[(data[i] >> 4) & 15]);             sb.Append(HexAlphabet[data[i] & 15]);           }           sb.Append("'");           break;         }         case CBORType.TextString: {           if (sb == null) {             return "\"" + obj.AsString() + "\"";           }           sb.Append('\"');           sb.Append(obj.AsString());           sb.Append('\"');           break;         }         case CBORType.Array: {           sb = sb ?? new StringBuilder();           var first = true;           sb.Append("[");           if (depth >= 50) {             sb.Append("...");           } else {             for (var i = 0; i < obj.Count; ++i) {               if (!first) {                 sb.Append("' ");               }               sb.Append(ToStringHelper(obj[i]' depth + 1));               first = false;             }           }           sb.Append("]");           break;         }         case CBORType.Map: {           sb = sb ?? new StringBuilder();           var first = true;           sb.Append("{");           if (depth >= 50) {             sb.Append("...");           } else {             ICollection<KeyValuePair<CBORObject' CBORObject>> entries =               obj.Entries;             foreach (KeyValuePair<CBORObject' CBORObject> entry               in entries) {               CBORObject key = entry.Key;               CBORObject value = entry.Value;               if (!first) {                 sb.Append("' ");               }               sb.Append(ToStringHelper(key' depth + 1));               sb.Append(": ");               sb.Append(ToStringHelper(value' depth + 1));               first = false;             }           }           sb.Append("}");           break;         }         default: {           sb = sb ?? new StringBuilder();           sb.Append("???");           break;         }       }
Magic Number,PeterO.Cbor,CBORDataUtilities,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORDataUtilities.cs,ToStringHelper,The following statement contains a magic number: switch (type) {         case CBORType.SimpleValue:           sb = sb ?? new StringBuilder();           if (obj.IsUndefined) {             sb.Append("undefined");           } else if (obj.IsNull) {             sb.Append("null");           } else {             sb.Append("simple(");             int thisItemInt = obj.SimpleValue;             char c;             if (thisItemInt >= 100) {               // NOTE: '0'-'9' have ASCII code 0x30-0x39               c = (char)(0x30 + ((thisItemInt / 100) % 10));               sb.Append(c);             }             if (thisItemInt >= 10) {               c = (char)(0x30 + ((thisItemInt / 10) % 10));               sb.Append(c);               c = (char)(0x30 + (thisItemInt % 10));             } else {               c = (char)(0x30 + thisItemInt);             }             sb.Append(c);             sb.Append(")");           }           break;         case CBORType.Boolean:         case CBORType.Integer:           simvalue = obj.Untag().ToJSONString();           if (sb == null) {             return simvalue;           }           sb.Append(simvalue);           break;         case CBORType.FloatingPoint: {           double f = obj.AsDoubleValue();           simvalue = Double.IsNegativeInfinity(f) ? "-Infinity" : (Double.IsPositiveInfinity(f) ? "Infinity" : (Double.IsNaN(f) ?                  "NaN" : obj.Untag().ToJSONString()));           if (sb == null) {             return simvalue;           }           sb.Append(simvalue);           break;         }         case CBORType.ByteString: {           sb = sb ?? new StringBuilder();           sb.Append("h'");           byte[] data = obj.GetByteString();           int length = data.Length;           for (var i = 0; i < length; ++i) {             sb.Append(HexAlphabet[(data[i] >> 4) & 15]);             sb.Append(HexAlphabet[data[i] & 15]);           }           sb.Append("'");           break;         }         case CBORType.TextString: {           if (sb == null) {             return "\"" + obj.AsString() + "\"";           }           sb.Append('\"');           sb.Append(obj.AsString());           sb.Append('\"');           break;         }         case CBORType.Array: {           sb = sb ?? new StringBuilder();           var first = true;           sb.Append("[");           if (depth >= 50) {             sb.Append("...");           } else {             for (var i = 0; i < obj.Count; ++i) {               if (!first) {                 sb.Append("' ");               }               sb.Append(ToStringHelper(obj[i]' depth + 1));               first = false;             }           }           sb.Append("]");           break;         }         case CBORType.Map: {           sb = sb ?? new StringBuilder();           var first = true;           sb.Append("{");           if (depth >= 50) {             sb.Append("...");           } else {             ICollection<KeyValuePair<CBORObject' CBORObject>> entries =               obj.Entries;             foreach (KeyValuePair<CBORObject' CBORObject> entry               in entries) {               CBORObject key = entry.Key;               CBORObject value = entry.Value;               if (!first) {                 sb.Append("' ");               }               sb.Append(ToStringHelper(key' depth + 1));               sb.Append(": ");               sb.Append(ToStringHelper(value' depth + 1));               first = false;             }           }           sb.Append("}");           break;         }         default: {           sb = sb ?? new StringBuilder();           sb.Append("???");           break;         }       }
Magic Number,PeterO.Cbor,CBORDataUtilities,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORDataUtilities.cs,ToStringHelper,The following statement contains a magic number: switch (type) {         case CBORType.SimpleValue:           sb = sb ?? new StringBuilder();           if (obj.IsUndefined) {             sb.Append("undefined");           } else if (obj.IsNull) {             sb.Append("null");           } else {             sb.Append("simple(");             int thisItemInt = obj.SimpleValue;             char c;             if (thisItemInt >= 100) {               // NOTE: '0'-'9' have ASCII code 0x30-0x39               c = (char)(0x30 + ((thisItemInt / 100) % 10));               sb.Append(c);             }             if (thisItemInt >= 10) {               c = (char)(0x30 + ((thisItemInt / 10) % 10));               sb.Append(c);               c = (char)(0x30 + (thisItemInt % 10));             } else {               c = (char)(0x30 + thisItemInt);             }             sb.Append(c);             sb.Append(")");           }           break;         case CBORType.Boolean:         case CBORType.Integer:           simvalue = obj.Untag().ToJSONString();           if (sb == null) {             return simvalue;           }           sb.Append(simvalue);           break;         case CBORType.FloatingPoint: {           double f = obj.AsDoubleValue();           simvalue = Double.IsNegativeInfinity(f) ? "-Infinity" : (Double.IsPositiveInfinity(f) ? "Infinity" : (Double.IsNaN(f) ?                  "NaN" : obj.Untag().ToJSONString()));           if (sb == null) {             return simvalue;           }           sb.Append(simvalue);           break;         }         case CBORType.ByteString: {           sb = sb ?? new StringBuilder();           sb.Append("h'");           byte[] data = obj.GetByteString();           int length = data.Length;           for (var i = 0; i < length; ++i) {             sb.Append(HexAlphabet[(data[i] >> 4) & 15]);             sb.Append(HexAlphabet[data[i] & 15]);           }           sb.Append("'");           break;         }         case CBORType.TextString: {           if (sb == null) {             return "\"" + obj.AsString() + "\"";           }           sb.Append('\"');           sb.Append(obj.AsString());           sb.Append('\"');           break;         }         case CBORType.Array: {           sb = sb ?? new StringBuilder();           var first = true;           sb.Append("[");           if (depth >= 50) {             sb.Append("...");           } else {             for (var i = 0; i < obj.Count; ++i) {               if (!first) {                 sb.Append("' ");               }               sb.Append(ToStringHelper(obj[i]' depth + 1));               first = false;             }           }           sb.Append("]");           break;         }         case CBORType.Map: {           sb = sb ?? new StringBuilder();           var first = true;           sb.Append("{");           if (depth >= 50) {             sb.Append("...");           } else {             ICollection<KeyValuePair<CBORObject' CBORObject>> entries =               obj.Entries;             foreach (KeyValuePair<CBORObject' CBORObject> entry               in entries) {               CBORObject key = entry.Key;               CBORObject value = entry.Value;               if (!first) {                 sb.Append("' ");               }               sb.Append(ToStringHelper(key' depth + 1));               sb.Append(": ");               sb.Append(ToStringHelper(value' depth + 1));               first = false;             }           }           sb.Append("}");           break;         }         default: {           sb = sb ?? new StringBuilder();           sb.Append("???");           break;         }       }
Magic Number,PeterO.Cbor,CBORDataUtilities,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORDataUtilities.cs,ParseJSONNumber,The following statement contains a magic number: endOfNumber[0] = k + 2;
Magic Number,PeterO.Cbor,CBORDataUtilities,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORDataUtilities.cs,ParseJSONNumber,The following statement contains a magic number: v = (v * 10) + (int)(str[vi] - '0');
Magic Number,PeterO.Cbor,CBORDataUtilities,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORDataUtilities.cs,ParseJSONNumber,The following statement contains a magic number: (v != 0 || !negative) && v < (1L << 53) - 1
Magic Number,PeterO.Cbor,CBORDataUtilities,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORDataUtilities.cs,ParseJSONNumber,The following statement contains a magic number: !haveExponent && !haveDecimalPoint &&          (endPos - numOffset) <= 16
Magic Number,PeterO.Cbor,CBORDataUtilities,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORDataUtilities.cs,ParseJSONNumber,The following statement contains a magic number: return CBORObject.FromFloatingPointBits(0x8000' 2);
Magic Number,PeterO.Cbor,CBORDataUtilities,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORDataUtilities.cs,ParseJSONNumber,The following statement contains a magic number: lv = checked((lv * 10) + (int)(str[vi] - '0'));
Magic Number,PeterO.Cbor,CBORDataUtilities,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORDataUtilities.cs,ParseJSONNumber,The following statement contains a magic number: lv = checked((lv * 10) + (int)(str[vi] - '0'));
Magic Number,PeterO.Cbor,CBORDataUtilities,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORDataUtilities.cs,ParseJSONNumber,The following statement contains a magic number: return cbor.WithTag(4);
Magic Number,PeterO.Cbor,CBORDataUtilities,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORDataUtilities.cs,ParseJSONNumber,The following statement contains a magic number: !haveExponent && haveDecimalPoint && (endPos - numOffset) <= 19
Magic Number,PeterO.Cbor,CBORDataUtilities,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORDataUtilities.cs,ParseJSONNumber,The following statement contains a magic number: return CBORObject.FromFloatingPointBits(0x8000' 2);
Magic Number,PeterO.Cbor,CBORDateConverter,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORDateConverter.cs,DateTimeToString,The following statement contains a magic number: var lesserFields = new int[7];
Magic Number,PeterO.Cbor,CBORDateConverter,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORDateConverter.cs,StringToDateTime,The following statement contains a magic number: var lesserFields = new int[7];
Magic Number,PeterO.Cbor,CBORDouble,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORDouble.cs,AsInt64,The following statement contains a magic number: fltItem >= -9223372036854775808.0 && fltItem <         9223372036854775808.0
Magic Number,PeterO.Cbor,CBORDouble,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORDouble.cs,AsInt64,The following statement contains a magic number: fltItem >= -9223372036854775808.0 && fltItem <         9223372036854775808.0
Magic Number,PeterO.Cbor,CBORDouble,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORDouble.cs,CanTruncatedIntFitInInt64,The following statement contains a magic number: return fltItem2 >= -9223372036854775808.0 && fltItem2 <         9223372036854775808.0;
Magic Number,PeterO.Cbor,CBORDouble,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORDouble.cs,CanTruncatedIntFitInInt64,The following statement contains a magic number: return fltItem2 >= -9223372036854775808.0 && fltItem2 <         9223372036854775808.0;
Magic Number,PeterO.Cbor,CBORDouble,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORDouble.cs,Sign,The following statement contains a magic number: return Double.IsNaN(flt) ? 2 : ((double)flt == 0.0 ? 0 : (flt < 0.0f ?             -1 : 1));
Magic Number,PeterO.Cbor,CBORDouble,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORDouble.cs,IsNegative,The following statement contains a magic number: return (lvalue >> 63) != 0;
Magic Number,PeterO.Cbor,CBORExtendedDecimal,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORExtendedDecimal.cs,CanTruncatedIntFitInInt64,The following statement contains a magic number: ef.Exponent.CompareTo((EInteger)21) >= 0
Magic Number,PeterO.Cbor,CBORExtendedDecimal,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORExtendedDecimal.cs,CanTruncatedIntFitInInt32,The following statement contains a magic number: ef.Exponent.CompareTo((EInteger)11) >= 0
Magic Number,PeterO.Cbor,CBORExtendedDecimal,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORExtendedDecimal.cs,Sign,The following statement contains a magic number: return ed.IsNaN() ? 2 : ed.Sign;
Magic Number,PeterO.Cbor,CBORExtendedFloat,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORExtendedFloat.cs,CanTruncatedIntFitInInt64,The following statement contains a magic number: ef.Exponent.CompareTo((EInteger)65) >= 0
Magic Number,PeterO.Cbor,CBORExtendedFloat,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORExtendedFloat.cs,CanTruncatedIntFitInInt32,The following statement contains a magic number: ef.Exponent.CompareTo((EInteger)33) >= 0
Magic Number,PeterO.Cbor,CBORExtendedFloat,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORExtendedFloat.cs,Sign,The following statement contains a magic number: return ef.IsNaN() ? 2 : ef.Sign;
Magic Number,PeterO.Cbor,CBORInteger,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORInteger.cs,Abs,The following statement contains a magic number: return (val == Int32.MinValue) ? (EInteger.One << 63) : ((val < 0) ?           -val : obj);
Magic Number,PeterO.Cbor,CBORInteger,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORInteger.cs,CanFitInDouble,The following statement contains a magic number: intItem >= (1L << 53) && (intItem & 1) == 0
Magic Number,PeterO.Cbor,CBORInteger,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORInteger.cs,CanFitInDouble,The following statement contains a magic number: return intItem < (1L << 53);
Magic Number,PeterO.Cbor,CBORInteger,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORInteger.cs,CanFitInSingle,The following statement contains a magic number: intItem >= (1L << 24) && (intItem & 1) == 0
Magic Number,PeterO.Cbor,CBORInteger,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORInteger.cs,CanFitInSingle,The following statement contains a magic number: return intItem < (1L << 24);
Magic Number,PeterO.Cbor,CBORInteger,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORInteger.cs,Negate,The following statement contains a magic number: return (((long)obj) == Int64.MinValue) ? (EInteger.One << 63) : (-((long)obj));
Magic Number,PeterO.Cbor,CBORJson,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORJson.cs,NextJSONString,The following statement contains a magic number: switch (c) {           case '\\':             c = this.ReadChar();             switch (c) {               case '\\':               case '/':               case '\"':                 // Slash is now allowed to be escaped under RFC 8259                 this.sb.Append((char)c);                 break;               case 'b':                 this.sb.Append('\b');                 break;               case 'f':                 this.sb.Append('\f');                 break;               case 'n':                 this.sb.Append('\n');                 break;               case 'r':                 this.sb.Append('\r');                 break;               case 't':                 this.sb.Append('\t');                 break;               case 'u': { // Unicode escape                 c = 0;                 // Consists of 4 hex digits                 for (var i = 0; i < 4; ++i) {                   int ch = this.ReadChar();                   if (ch >= '0' && ch <= '9') {                     c <<= 4;                     c |= ch - '0';                   } else if (ch >= 'A' && ch <= 'F') {                     c <<= 4;                     c |= ch + 10 - 'A';                   } else if (ch >= 'a' && ch <= 'f') {                     c <<= 4;                     c |= ch + 10 - 'a';                   } else {                     this.RaiseError(                       "Invalid Unicode escaped character");                   }                 }                 if ((c & 0xf800) != 0xd800) {                   // Non-surrogate                   this.sb.Append((char)c);                 } else if ((c & 0xfc00) == 0xd800) {                   int ch = this.ReadChar();                   if (ch != '\\' || this.ReadChar() != 'u') {                     this.RaiseError("Invalid escaped character");                   }                   var c2 = 0;                   for (var i = 0; i < 4; ++i) {                     ch = this.ReadChar();                     if (ch >= '0' && ch <= '9') {                       c2 <<= 4;                       c2 |= ch - '0';                     } else if (ch >= 'A' && ch <= 'F') {                       c2 <<= 4;                       c2 |= ch + 10 - 'A';                     } else if (ch >= 'a' && ch <= 'f') {                       c2 <<= 4;                       c2 |= ch + 10 - 'a';                     } else {                       this.RaiseError(                         "Invalid Unicode escaped character");                     }                   }                   if ((c2 & 0xfc00) != 0xdc00) {                     this.RaiseError("Unpaired surrogate code point");                   } else {                     this.sb.Append((char)c);                     this.sb.Append((char)c2);                   }                 } else {                   this.RaiseError("Unpaired surrogate code point");                 }                 break;               }               default: {                 this.RaiseError("Invalid escaped character");                 break;               }             }             break;           case 0x22: // double quote             return this.sb.ToString();           default: {             // NOTE: Assumes the character reader             // throws an error on finding illegal surrogate             // pairs in the string or invalid encoding             // in the stream             if ((c >> 16) == 0) {               this.sb.Append((char)c);             } else {               this.sb.Append((char)((((c - 0x10000) >> 10) & 0x3ff) |                   0xd800));               this.sb.Append((char)(((c - 0x10000) & 0x3ff) | 0xdc00));             }             break;           }         }
Magic Number,PeterO.Cbor,CBORJson,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORJson.cs,NextJSONString,The following statement contains a magic number: switch (c) {           case '\\':             c = this.ReadChar();             switch (c) {               case '\\':               case '/':               case '\"':                 // Slash is now allowed to be escaped under RFC 8259                 this.sb.Append((char)c);                 break;               case 'b':                 this.sb.Append('\b');                 break;               case 'f':                 this.sb.Append('\f');                 break;               case 'n':                 this.sb.Append('\n');                 break;               case 'r':                 this.sb.Append('\r');                 break;               case 't':                 this.sb.Append('\t');                 break;               case 'u': { // Unicode escape                 c = 0;                 // Consists of 4 hex digits                 for (var i = 0; i < 4; ++i) {                   int ch = this.ReadChar();                   if (ch >= '0' && ch <= '9') {                     c <<= 4;                     c |= ch - '0';                   } else if (ch >= 'A' && ch <= 'F') {                     c <<= 4;                     c |= ch + 10 - 'A';                   } else if (ch >= 'a' && ch <= 'f') {                     c <<= 4;                     c |= ch + 10 - 'a';                   } else {                     this.RaiseError(                       "Invalid Unicode escaped character");                   }                 }                 if ((c & 0xf800) != 0xd800) {                   // Non-surrogate                   this.sb.Append((char)c);                 } else if ((c & 0xfc00) == 0xd800) {                   int ch = this.ReadChar();                   if (ch != '\\' || this.ReadChar() != 'u') {                     this.RaiseError("Invalid escaped character");                   }                   var c2 = 0;                   for (var i = 0; i < 4; ++i) {                     ch = this.ReadChar();                     if (ch >= '0' && ch <= '9') {                       c2 <<= 4;                       c2 |= ch - '0';                     } else if (ch >= 'A' && ch <= 'F') {                       c2 <<= 4;                       c2 |= ch + 10 - 'A';                     } else if (ch >= 'a' && ch <= 'f') {                       c2 <<= 4;                       c2 |= ch + 10 - 'a';                     } else {                       this.RaiseError(                         "Invalid Unicode escaped character");                     }                   }                   if ((c2 & 0xfc00) != 0xdc00) {                     this.RaiseError("Unpaired surrogate code point");                   } else {                     this.sb.Append((char)c);                     this.sb.Append((char)c2);                   }                 } else {                   this.RaiseError("Unpaired surrogate code point");                 }                 break;               }               default: {                 this.RaiseError("Invalid escaped character");                 break;               }             }             break;           case 0x22: // double quote             return this.sb.ToString();           default: {             // NOTE: Assumes the character reader             // throws an error on finding illegal surrogate             // pairs in the string or invalid encoding             // in the stream             if ((c >> 16) == 0) {               this.sb.Append((char)c);             } else {               this.sb.Append((char)((((c - 0x10000) >> 10) & 0x3ff) |                   0xd800));               this.sb.Append((char)(((c - 0x10000) & 0x3ff) | 0xdc00));             }             break;           }         }
Magic Number,PeterO.Cbor,CBORJson,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORJson.cs,NextJSONString,The following statement contains a magic number: switch (c) {           case '\\':             c = this.ReadChar();             switch (c) {               case '\\':               case '/':               case '\"':                 // Slash is now allowed to be escaped under RFC 8259                 this.sb.Append((char)c);                 break;               case 'b':                 this.sb.Append('\b');                 break;               case 'f':                 this.sb.Append('\f');                 break;               case 'n':                 this.sb.Append('\n');                 break;               case 'r':                 this.sb.Append('\r');                 break;               case 't':                 this.sb.Append('\t');                 break;               case 'u': { // Unicode escape                 c = 0;                 // Consists of 4 hex digits                 for (var i = 0; i < 4; ++i) {                   int ch = this.ReadChar();                   if (ch >= '0' && ch <= '9') {                     c <<= 4;                     c |= ch - '0';                   } else if (ch >= 'A' && ch <= 'F') {                     c <<= 4;                     c |= ch + 10 - 'A';                   } else if (ch >= 'a' && ch <= 'f') {                     c <<= 4;                     c |= ch + 10 - 'a';                   } else {                     this.RaiseError(                       "Invalid Unicode escaped character");                   }                 }                 if ((c & 0xf800) != 0xd800) {                   // Non-surrogate                   this.sb.Append((char)c);                 } else if ((c & 0xfc00) == 0xd800) {                   int ch = this.ReadChar();                   if (ch != '\\' || this.ReadChar() != 'u') {                     this.RaiseError("Invalid escaped character");                   }                   var c2 = 0;                   for (var i = 0; i < 4; ++i) {                     ch = this.ReadChar();                     if (ch >= '0' && ch <= '9') {                       c2 <<= 4;                       c2 |= ch - '0';                     } else if (ch >= 'A' && ch <= 'F') {                       c2 <<= 4;                       c2 |= ch + 10 - 'A';                     } else if (ch >= 'a' && ch <= 'f') {                       c2 <<= 4;                       c2 |= ch + 10 - 'a';                     } else {                       this.RaiseError(                         "Invalid Unicode escaped character");                     }                   }                   if ((c2 & 0xfc00) != 0xdc00) {                     this.RaiseError("Unpaired surrogate code point");                   } else {                     this.sb.Append((char)c);                     this.sb.Append((char)c2);                   }                 } else {                   this.RaiseError("Unpaired surrogate code point");                 }                 break;               }               default: {                 this.RaiseError("Invalid escaped character");                 break;               }             }             break;           case 0x22: // double quote             return this.sb.ToString();           default: {             // NOTE: Assumes the character reader             // throws an error on finding illegal surrogate             // pairs in the string or invalid encoding             // in the stream             if ((c >> 16) == 0) {               this.sb.Append((char)c);             } else {               this.sb.Append((char)((((c - 0x10000) >> 10) & 0x3ff) |                   0xd800));               this.sb.Append((char)(((c - 0x10000) & 0x3ff) | 0xdc00));             }             break;           }         }
Magic Number,PeterO.Cbor,CBORJson,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORJson.cs,NextJSONString,The following statement contains a magic number: switch (c) {           case '\\':             c = this.ReadChar();             switch (c) {               case '\\':               case '/':               case '\"':                 // Slash is now allowed to be escaped under RFC 8259                 this.sb.Append((char)c);                 break;               case 'b':                 this.sb.Append('\b');                 break;               case 'f':                 this.sb.Append('\f');                 break;               case 'n':                 this.sb.Append('\n');                 break;               case 'r':                 this.sb.Append('\r');                 break;               case 't':                 this.sb.Append('\t');                 break;               case 'u': { // Unicode escape                 c = 0;                 // Consists of 4 hex digits                 for (var i = 0; i < 4; ++i) {                   int ch = this.ReadChar();                   if (ch >= '0' && ch <= '9') {                     c <<= 4;                     c |= ch - '0';                   } else if (ch >= 'A' && ch <= 'F') {                     c <<= 4;                     c |= ch + 10 - 'A';                   } else if (ch >= 'a' && ch <= 'f') {                     c <<= 4;                     c |= ch + 10 - 'a';                   } else {                     this.RaiseError(                       "Invalid Unicode escaped character");                   }                 }                 if ((c & 0xf800) != 0xd800) {                   // Non-surrogate                   this.sb.Append((char)c);                 } else if ((c & 0xfc00) == 0xd800) {                   int ch = this.ReadChar();                   if (ch != '\\' || this.ReadChar() != 'u') {                     this.RaiseError("Invalid escaped character");                   }                   var c2 = 0;                   for (var i = 0; i < 4; ++i) {                     ch = this.ReadChar();                     if (ch >= '0' && ch <= '9') {                       c2 <<= 4;                       c2 |= ch - '0';                     } else if (ch >= 'A' && ch <= 'F') {                       c2 <<= 4;                       c2 |= ch + 10 - 'A';                     } else if (ch >= 'a' && ch <= 'f') {                       c2 <<= 4;                       c2 |= ch + 10 - 'a';                     } else {                       this.RaiseError(                         "Invalid Unicode escaped character");                     }                   }                   if ((c2 & 0xfc00) != 0xdc00) {                     this.RaiseError("Unpaired surrogate code point");                   } else {                     this.sb.Append((char)c);                     this.sb.Append((char)c2);                   }                 } else {                   this.RaiseError("Unpaired surrogate code point");                 }                 break;               }               default: {                 this.RaiseError("Invalid escaped character");                 break;               }             }             break;           case 0x22: // double quote             return this.sb.ToString();           default: {             // NOTE: Assumes the character reader             // throws an error on finding illegal surrogate             // pairs in the string or invalid encoding             // in the stream             if ((c >> 16) == 0) {               this.sb.Append((char)c);             } else {               this.sb.Append((char)((((c - 0x10000) >> 10) & 0x3ff) |                   0xd800));               this.sb.Append((char)(((c - 0x10000) & 0x3ff) | 0xdc00));             }             break;           }         }
Magic Number,PeterO.Cbor,CBORJson,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORJson.cs,NextJSONString,The following statement contains a magic number: switch (c) {           case '\\':             c = this.ReadChar();             switch (c) {               case '\\':               case '/':               case '\"':                 // Slash is now allowed to be escaped under RFC 8259                 this.sb.Append((char)c);                 break;               case 'b':                 this.sb.Append('\b');                 break;               case 'f':                 this.sb.Append('\f');                 break;               case 'n':                 this.sb.Append('\n');                 break;               case 'r':                 this.sb.Append('\r');                 break;               case 't':                 this.sb.Append('\t');                 break;               case 'u': { // Unicode escape                 c = 0;                 // Consists of 4 hex digits                 for (var i = 0; i < 4; ++i) {                   int ch = this.ReadChar();                   if (ch >= '0' && ch <= '9') {                     c <<= 4;                     c |= ch - '0';                   } else if (ch >= 'A' && ch <= 'F') {                     c <<= 4;                     c |= ch + 10 - 'A';                   } else if (ch >= 'a' && ch <= 'f') {                     c <<= 4;                     c |= ch + 10 - 'a';                   } else {                     this.RaiseError(                       "Invalid Unicode escaped character");                   }                 }                 if ((c & 0xf800) != 0xd800) {                   // Non-surrogate                   this.sb.Append((char)c);                 } else if ((c & 0xfc00) == 0xd800) {                   int ch = this.ReadChar();                   if (ch != '\\' || this.ReadChar() != 'u') {                     this.RaiseError("Invalid escaped character");                   }                   var c2 = 0;                   for (var i = 0; i < 4; ++i) {                     ch = this.ReadChar();                     if (ch >= '0' && ch <= '9') {                       c2 <<= 4;                       c2 |= ch - '0';                     } else if (ch >= 'A' && ch <= 'F') {                       c2 <<= 4;                       c2 |= ch + 10 - 'A';                     } else if (ch >= 'a' && ch <= 'f') {                       c2 <<= 4;                       c2 |= ch + 10 - 'a';                     } else {                       this.RaiseError(                         "Invalid Unicode escaped character");                     }                   }                   if ((c2 & 0xfc00) != 0xdc00) {                     this.RaiseError("Unpaired surrogate code point");                   } else {                     this.sb.Append((char)c);                     this.sb.Append((char)c2);                   }                 } else {                   this.RaiseError("Unpaired surrogate code point");                 }                 break;               }               default: {                 this.RaiseError("Invalid escaped character");                 break;               }             }             break;           case 0x22: // double quote             return this.sb.ToString();           default: {             // NOTE: Assumes the character reader             // throws an error on finding illegal surrogate             // pairs in the string or invalid encoding             // in the stream             if ((c >> 16) == 0) {               this.sb.Append((char)c);             } else {               this.sb.Append((char)((((c - 0x10000) >> 10) & 0x3ff) |                   0xd800));               this.sb.Append((char)(((c - 0x10000) & 0x3ff) | 0xdc00));             }             break;           }         }
Magic Number,PeterO.Cbor,CBORJson,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORJson.cs,NextJSONString,The following statement contains a magic number: switch (c) {           case '\\':             c = this.ReadChar();             switch (c) {               case '\\':               case '/':               case '\"':                 // Slash is now allowed to be escaped under RFC 8259                 this.sb.Append((char)c);                 break;               case 'b':                 this.sb.Append('\b');                 break;               case 'f':                 this.sb.Append('\f');                 break;               case 'n':                 this.sb.Append('\n');                 break;               case 'r':                 this.sb.Append('\r');                 break;               case 't':                 this.sb.Append('\t');                 break;               case 'u': { // Unicode escape                 c = 0;                 // Consists of 4 hex digits                 for (var i = 0; i < 4; ++i) {                   int ch = this.ReadChar();                   if (ch >= '0' && ch <= '9') {                     c <<= 4;                     c |= ch - '0';                   } else if (ch >= 'A' && ch <= 'F') {                     c <<= 4;                     c |= ch + 10 - 'A';                   } else if (ch >= 'a' && ch <= 'f') {                     c <<= 4;                     c |= ch + 10 - 'a';                   } else {                     this.RaiseError(                       "Invalid Unicode escaped character");                   }                 }                 if ((c & 0xf800) != 0xd800) {                   // Non-surrogate                   this.sb.Append((char)c);                 } else if ((c & 0xfc00) == 0xd800) {                   int ch = this.ReadChar();                   if (ch != '\\' || this.ReadChar() != 'u') {                     this.RaiseError("Invalid escaped character");                   }                   var c2 = 0;                   for (var i = 0; i < 4; ++i) {                     ch = this.ReadChar();                     if (ch >= '0' && ch <= '9') {                       c2 <<= 4;                       c2 |= ch - '0';                     } else if (ch >= 'A' && ch <= 'F') {                       c2 <<= 4;                       c2 |= ch + 10 - 'A';                     } else if (ch >= 'a' && ch <= 'f') {                       c2 <<= 4;                       c2 |= ch + 10 - 'a';                     } else {                       this.RaiseError(                         "Invalid Unicode escaped character");                     }                   }                   if ((c2 & 0xfc00) != 0xdc00) {                     this.RaiseError("Unpaired surrogate code point");                   } else {                     this.sb.Append((char)c);                     this.sb.Append((char)c2);                   }                 } else {                   this.RaiseError("Unpaired surrogate code point");                 }                 break;               }               default: {                 this.RaiseError("Invalid escaped character");                 break;               }             }             break;           case 0x22: // double quote             return this.sb.ToString();           default: {             // NOTE: Assumes the character reader             // throws an error on finding illegal surrogate             // pairs in the string or invalid encoding             // in the stream             if ((c >> 16) == 0) {               this.sb.Append((char)c);             } else {               this.sb.Append((char)((((c - 0x10000) >> 10) & 0x3ff) |                   0xd800));               this.sb.Append((char)(((c - 0x10000) & 0x3ff) | 0xdc00));             }             break;           }         }
Magic Number,PeterO.Cbor,CBORJson,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORJson.cs,NextJSONString,The following statement contains a magic number: switch (c) {           case '\\':             c = this.ReadChar();             switch (c) {               case '\\':               case '/':               case '\"':                 // Slash is now allowed to be escaped under RFC 8259                 this.sb.Append((char)c);                 break;               case 'b':                 this.sb.Append('\b');                 break;               case 'f':                 this.sb.Append('\f');                 break;               case 'n':                 this.sb.Append('\n');                 break;               case 'r':                 this.sb.Append('\r');                 break;               case 't':                 this.sb.Append('\t');                 break;               case 'u': { // Unicode escape                 c = 0;                 // Consists of 4 hex digits                 for (var i = 0; i < 4; ++i) {                   int ch = this.ReadChar();                   if (ch >= '0' && ch <= '9') {                     c <<= 4;                     c |= ch - '0';                   } else if (ch >= 'A' && ch <= 'F') {                     c <<= 4;                     c |= ch + 10 - 'A';                   } else if (ch >= 'a' && ch <= 'f') {                     c <<= 4;                     c |= ch + 10 - 'a';                   } else {                     this.RaiseError(                       "Invalid Unicode escaped character");                   }                 }                 if ((c & 0xf800) != 0xd800) {                   // Non-surrogate                   this.sb.Append((char)c);                 } else if ((c & 0xfc00) == 0xd800) {                   int ch = this.ReadChar();                   if (ch != '\\' || this.ReadChar() != 'u') {                     this.RaiseError("Invalid escaped character");                   }                   var c2 = 0;                   for (var i = 0; i < 4; ++i) {                     ch = this.ReadChar();                     if (ch >= '0' && ch <= '9') {                       c2 <<= 4;                       c2 |= ch - '0';                     } else if (ch >= 'A' && ch <= 'F') {                       c2 <<= 4;                       c2 |= ch + 10 - 'A';                     } else if (ch >= 'a' && ch <= 'f') {                       c2 <<= 4;                       c2 |= ch + 10 - 'a';                     } else {                       this.RaiseError(                         "Invalid Unicode escaped character");                     }                   }                   if ((c2 & 0xfc00) != 0xdc00) {                     this.RaiseError("Unpaired surrogate code point");                   } else {                     this.sb.Append((char)c);                     this.sb.Append((char)c2);                   }                 } else {                   this.RaiseError("Unpaired surrogate code point");                 }                 break;               }               default: {                 this.RaiseError("Invalid escaped character");                 break;               }             }             break;           case 0x22: // double quote             return this.sb.ToString();           default: {             // NOTE: Assumes the character reader             // throws an error on finding illegal surrogate             // pairs in the string or invalid encoding             // in the stream             if ((c >> 16) == 0) {               this.sb.Append((char)c);             } else {               this.sb.Append((char)((((c - 0x10000) >> 10) & 0x3ff) |                   0xd800));               this.sb.Append((char)(((c - 0x10000) & 0x3ff) | 0xdc00));             }             break;           }         }
Magic Number,PeterO.Cbor,CBORJson,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORJson.cs,NextJSONString,The following statement contains a magic number: switch (c) {           case '\\':             c = this.ReadChar();             switch (c) {               case '\\':               case '/':               case '\"':                 // Slash is now allowed to be escaped under RFC 8259                 this.sb.Append((char)c);                 break;               case 'b':                 this.sb.Append('\b');                 break;               case 'f':                 this.sb.Append('\f');                 break;               case 'n':                 this.sb.Append('\n');                 break;               case 'r':                 this.sb.Append('\r');                 break;               case 't':                 this.sb.Append('\t');                 break;               case 'u': { // Unicode escape                 c = 0;                 // Consists of 4 hex digits                 for (var i = 0; i < 4; ++i) {                   int ch = this.ReadChar();                   if (ch >= '0' && ch <= '9') {                     c <<= 4;                     c |= ch - '0';                   } else if (ch >= 'A' && ch <= 'F') {                     c <<= 4;                     c |= ch + 10 - 'A';                   } else if (ch >= 'a' && ch <= 'f') {                     c <<= 4;                     c |= ch + 10 - 'a';                   } else {                     this.RaiseError(                       "Invalid Unicode escaped character");                   }                 }                 if ((c & 0xf800) != 0xd800) {                   // Non-surrogate                   this.sb.Append((char)c);                 } else if ((c & 0xfc00) == 0xd800) {                   int ch = this.ReadChar();                   if (ch != '\\' || this.ReadChar() != 'u') {                     this.RaiseError("Invalid escaped character");                   }                   var c2 = 0;                   for (var i = 0; i < 4; ++i) {                     ch = this.ReadChar();                     if (ch >= '0' && ch <= '9') {                       c2 <<= 4;                       c2 |= ch - '0';                     } else if (ch >= 'A' && ch <= 'F') {                       c2 <<= 4;                       c2 |= ch + 10 - 'A';                     } else if (ch >= 'a' && ch <= 'f') {                       c2 <<= 4;                       c2 |= ch + 10 - 'a';                     } else {                       this.RaiseError(                         "Invalid Unicode escaped character");                     }                   }                   if ((c2 & 0xfc00) != 0xdc00) {                     this.RaiseError("Unpaired surrogate code point");                   } else {                     this.sb.Append((char)c);                     this.sb.Append((char)c2);                   }                 } else {                   this.RaiseError("Unpaired surrogate code point");                 }                 break;               }               default: {                 this.RaiseError("Invalid escaped character");                 break;               }             }             break;           case 0x22: // double quote             return this.sb.ToString();           default: {             // NOTE: Assumes the character reader             // throws an error on finding illegal surrogate             // pairs in the string or invalid encoding             // in the stream             if ((c >> 16) == 0) {               this.sb.Append((char)c);             } else {               this.sb.Append((char)((((c - 0x10000) >> 10) & 0x3ff) |                   0xd800));               this.sb.Append((char)(((c - 0x10000) & 0x3ff) | 0xdc00));             }             break;           }         }
Magic Number,PeterO.Cbor,CBORJson,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORJson.cs,NextJSONString,The following statement contains a magic number: switch (c) {           case '\\':             c = this.ReadChar();             switch (c) {               case '\\':               case '/':               case '\"':                 // Slash is now allowed to be escaped under RFC 8259                 this.sb.Append((char)c);                 break;               case 'b':                 this.sb.Append('\b');                 break;               case 'f':                 this.sb.Append('\f');                 break;               case 'n':                 this.sb.Append('\n');                 break;               case 'r':                 this.sb.Append('\r');                 break;               case 't':                 this.sb.Append('\t');                 break;               case 'u': { // Unicode escape                 c = 0;                 // Consists of 4 hex digits                 for (var i = 0; i < 4; ++i) {                   int ch = this.ReadChar();                   if (ch >= '0' && ch <= '9') {                     c <<= 4;                     c |= ch - '0';                   } else if (ch >= 'A' && ch <= 'F') {                     c <<= 4;                     c |= ch + 10 - 'A';                   } else if (ch >= 'a' && ch <= 'f') {                     c <<= 4;                     c |= ch + 10 - 'a';                   } else {                     this.RaiseError(                       "Invalid Unicode escaped character");                   }                 }                 if ((c & 0xf800) != 0xd800) {                   // Non-surrogate                   this.sb.Append((char)c);                 } else if ((c & 0xfc00) == 0xd800) {                   int ch = this.ReadChar();                   if (ch != '\\' || this.ReadChar() != 'u') {                     this.RaiseError("Invalid escaped character");                   }                   var c2 = 0;                   for (var i = 0; i < 4; ++i) {                     ch = this.ReadChar();                     if (ch >= '0' && ch <= '9') {                       c2 <<= 4;                       c2 |= ch - '0';                     } else if (ch >= 'A' && ch <= 'F') {                       c2 <<= 4;                       c2 |= ch + 10 - 'A';                     } else if (ch >= 'a' && ch <= 'f') {                       c2 <<= 4;                       c2 |= ch + 10 - 'a';                     } else {                       this.RaiseError(                         "Invalid Unicode escaped character");                     }                   }                   if ((c2 & 0xfc00) != 0xdc00) {                     this.RaiseError("Unpaired surrogate code point");                   } else {                     this.sb.Append((char)c);                     this.sb.Append((char)c2);                   }                 } else {                   this.RaiseError("Unpaired surrogate code point");                 }                 break;               }               default: {                 this.RaiseError("Invalid escaped character");                 break;               }             }             break;           case 0x22: // double quote             return this.sb.ToString();           default: {             // NOTE: Assumes the character reader             // throws an error on finding illegal surrogate             // pairs in the string or invalid encoding             // in the stream             if ((c >> 16) == 0) {               this.sb.Append((char)c);             } else {               this.sb.Append((char)((((c - 0x10000) >> 10) & 0x3ff) |                   0xd800));               this.sb.Append((char)(((c - 0x10000) & 0x3ff) | 0xdc00));             }             break;           }         }
Magic Number,PeterO.Cbor,CBORJson,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORJson.cs,NextJSONString,The following statement contains a magic number: switch (c) {           case '\\':             c = this.ReadChar();             switch (c) {               case '\\':               case '/':               case '\"':                 // Slash is now allowed to be escaped under RFC 8259                 this.sb.Append((char)c);                 break;               case 'b':                 this.sb.Append('\b');                 break;               case 'f':                 this.sb.Append('\f');                 break;               case 'n':                 this.sb.Append('\n');                 break;               case 'r':                 this.sb.Append('\r');                 break;               case 't':                 this.sb.Append('\t');                 break;               case 'u': { // Unicode escape                 c = 0;                 // Consists of 4 hex digits                 for (var i = 0; i < 4; ++i) {                   int ch = this.ReadChar();                   if (ch >= '0' && ch <= '9') {                     c <<= 4;                     c |= ch - '0';                   } else if (ch >= 'A' && ch <= 'F') {                     c <<= 4;                     c |= ch + 10 - 'A';                   } else if (ch >= 'a' && ch <= 'f') {                     c <<= 4;                     c |= ch + 10 - 'a';                   } else {                     this.RaiseError(                       "Invalid Unicode escaped character");                   }                 }                 if ((c & 0xf800) != 0xd800) {                   // Non-surrogate                   this.sb.Append((char)c);                 } else if ((c & 0xfc00) == 0xd800) {                   int ch = this.ReadChar();                   if (ch != '\\' || this.ReadChar() != 'u') {                     this.RaiseError("Invalid escaped character");                   }                   var c2 = 0;                   for (var i = 0; i < 4; ++i) {                     ch = this.ReadChar();                     if (ch >= '0' && ch <= '9') {                       c2 <<= 4;                       c2 |= ch - '0';                     } else if (ch >= 'A' && ch <= 'F') {                       c2 <<= 4;                       c2 |= ch + 10 - 'A';                     } else if (ch >= 'a' && ch <= 'f') {                       c2 <<= 4;                       c2 |= ch + 10 - 'a';                     } else {                       this.RaiseError(                         "Invalid Unicode escaped character");                     }                   }                   if ((c2 & 0xfc00) != 0xdc00) {                     this.RaiseError("Unpaired surrogate code point");                   } else {                     this.sb.Append((char)c);                     this.sb.Append((char)c2);                   }                 } else {                   this.RaiseError("Unpaired surrogate code point");                 }                 break;               }               default: {                 this.RaiseError("Invalid escaped character");                 break;               }             }             break;           case 0x22: // double quote             return this.sb.ToString();           default: {             // NOTE: Assumes the character reader             // throws an error on finding illegal surrogate             // pairs in the string or invalid encoding             // in the stream             if ((c >> 16) == 0) {               this.sb.Append((char)c);             } else {               this.sb.Append((char)((((c - 0x10000) >> 10) & 0x3ff) |                   0xd800));               this.sb.Append((char)(((c - 0x10000) & 0x3ff) | 0xdc00));             }             break;           }         }
Magic Number,PeterO.Cbor,CBORJson,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORJson.cs,NextJSONString,The following statement contains a magic number: switch (c) {           case '\\':             c = this.ReadChar();             switch (c) {               case '\\':               case '/':               case '\"':                 // Slash is now allowed to be escaped under RFC 8259                 this.sb.Append((char)c);                 break;               case 'b':                 this.sb.Append('\b');                 break;               case 'f':                 this.sb.Append('\f');                 break;               case 'n':                 this.sb.Append('\n');                 break;               case 'r':                 this.sb.Append('\r');                 break;               case 't':                 this.sb.Append('\t');                 break;               case 'u': { // Unicode escape                 c = 0;                 // Consists of 4 hex digits                 for (var i = 0; i < 4; ++i) {                   int ch = this.ReadChar();                   if (ch >= '0' && ch <= '9') {                     c <<= 4;                     c |= ch - '0';                   } else if (ch >= 'A' && ch <= 'F') {                     c <<= 4;                     c |= ch + 10 - 'A';                   } else if (ch >= 'a' && ch <= 'f') {                     c <<= 4;                     c |= ch + 10 - 'a';                   } else {                     this.RaiseError(                       "Invalid Unicode escaped character");                   }                 }                 if ((c & 0xf800) != 0xd800) {                   // Non-surrogate                   this.sb.Append((char)c);                 } else if ((c & 0xfc00) == 0xd800) {                   int ch = this.ReadChar();                   if (ch != '\\' || this.ReadChar() != 'u') {                     this.RaiseError("Invalid escaped character");                   }                   var c2 = 0;                   for (var i = 0; i < 4; ++i) {                     ch = this.ReadChar();                     if (ch >= '0' && ch <= '9') {                       c2 <<= 4;                       c2 |= ch - '0';                     } else if (ch >= 'A' && ch <= 'F') {                       c2 <<= 4;                       c2 |= ch + 10 - 'A';                     } else if (ch >= 'a' && ch <= 'f') {                       c2 <<= 4;                       c2 |= ch + 10 - 'a';                     } else {                       this.RaiseError(                         "Invalid Unicode escaped character");                     }                   }                   if ((c2 & 0xfc00) != 0xdc00) {                     this.RaiseError("Unpaired surrogate code point");                   } else {                     this.sb.Append((char)c);                     this.sb.Append((char)c2);                   }                 } else {                   this.RaiseError("Unpaired surrogate code point");                 }                 break;               }               default: {                 this.RaiseError("Invalid escaped character");                 break;               }             }             break;           case 0x22: // double quote             return this.sb.ToString();           default: {             // NOTE: Assumes the character reader             // throws an error on finding illegal surrogate             // pairs in the string or invalid encoding             // in the stream             if ((c >> 16) == 0) {               this.sb.Append((char)c);             } else {               this.sb.Append((char)((((c - 0x10000) >> 10) & 0x3ff) |                   0xd800));               this.sb.Append((char)(((c - 0x10000) & 0x3ff) | 0xdc00));             }             break;           }         }
Magic Number,PeterO.Cbor,CBORJson,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORJson.cs,NextJSONString,The following statement contains a magic number: switch (c) {           case '\\':             c = this.ReadChar();             switch (c) {               case '\\':               case '/':               case '\"':                 // Slash is now allowed to be escaped under RFC 8259                 this.sb.Append((char)c);                 break;               case 'b':                 this.sb.Append('\b');                 break;               case 'f':                 this.sb.Append('\f');                 break;               case 'n':                 this.sb.Append('\n');                 break;               case 'r':                 this.sb.Append('\r');                 break;               case 't':                 this.sb.Append('\t');                 break;               case 'u': { // Unicode escape                 c = 0;                 // Consists of 4 hex digits                 for (var i = 0; i < 4; ++i) {                   int ch = this.ReadChar();                   if (ch >= '0' && ch <= '9') {                     c <<= 4;                     c |= ch - '0';                   } else if (ch >= 'A' && ch <= 'F') {                     c <<= 4;                     c |= ch + 10 - 'A';                   } else if (ch >= 'a' && ch <= 'f') {                     c <<= 4;                     c |= ch + 10 - 'a';                   } else {                     this.RaiseError(                       "Invalid Unicode escaped character");                   }                 }                 if ((c & 0xf800) != 0xd800) {                   // Non-surrogate                   this.sb.Append((char)c);                 } else if ((c & 0xfc00) == 0xd800) {                   int ch = this.ReadChar();                   if (ch != '\\' || this.ReadChar() != 'u') {                     this.RaiseError("Invalid escaped character");                   }                   var c2 = 0;                   for (var i = 0; i < 4; ++i) {                     ch = this.ReadChar();                     if (ch >= '0' && ch <= '9') {                       c2 <<= 4;                       c2 |= ch - '0';                     } else if (ch >= 'A' && ch <= 'F') {                       c2 <<= 4;                       c2 |= ch + 10 - 'A';                     } else if (ch >= 'a' && ch <= 'f') {                       c2 <<= 4;                       c2 |= ch + 10 - 'a';                     } else {                       this.RaiseError(                         "Invalid Unicode escaped character");                     }                   }                   if ((c2 & 0xfc00) != 0xdc00) {                     this.RaiseError("Unpaired surrogate code point");                   } else {                     this.sb.Append((char)c);                     this.sb.Append((char)c2);                   }                 } else {                   this.RaiseError("Unpaired surrogate code point");                 }                 break;               }               default: {                 this.RaiseError("Invalid escaped character");                 break;               }             }             break;           case 0x22: // double quote             return this.sb.ToString();           default: {             // NOTE: Assumes the character reader             // throws an error on finding illegal surrogate             // pairs in the string or invalid encoding             // in the stream             if ((c >> 16) == 0) {               this.sb.Append((char)c);             } else {               this.sb.Append((char)((((c - 0x10000) >> 10) & 0x3ff) |                   0xd800));               this.sb.Append((char)(((c - 0x10000) & 0x3ff) | 0xdc00));             }             break;           }         }
Magic Number,PeterO.Cbor,CBORJson,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORJson.cs,NextJSONString,The following statement contains a magic number: switch (c) {           case '\\':             c = this.ReadChar();             switch (c) {               case '\\':               case '/':               case '\"':                 // Slash is now allowed to be escaped under RFC 8259                 this.sb.Append((char)c);                 break;               case 'b':                 this.sb.Append('\b');                 break;               case 'f':                 this.sb.Append('\f');                 break;               case 'n':                 this.sb.Append('\n');                 break;               case 'r':                 this.sb.Append('\r');                 break;               case 't':                 this.sb.Append('\t');                 break;               case 'u': { // Unicode escape                 c = 0;                 // Consists of 4 hex digits                 for (var i = 0; i < 4; ++i) {                   int ch = this.ReadChar();                   if (ch >= '0' && ch <= '9') {                     c <<= 4;                     c |= ch - '0';                   } else if (ch >= 'A' && ch <= 'F') {                     c <<= 4;                     c |= ch + 10 - 'A';                   } else if (ch >= 'a' && ch <= 'f') {                     c <<= 4;                     c |= ch + 10 - 'a';                   } else {                     this.RaiseError(                       "Invalid Unicode escaped character");                   }                 }                 if ((c & 0xf800) != 0xd800) {                   // Non-surrogate                   this.sb.Append((char)c);                 } else if ((c & 0xfc00) == 0xd800) {                   int ch = this.ReadChar();                   if (ch != '\\' || this.ReadChar() != 'u') {                     this.RaiseError("Invalid escaped character");                   }                   var c2 = 0;                   for (var i = 0; i < 4; ++i) {                     ch = this.ReadChar();                     if (ch >= '0' && ch <= '9') {                       c2 <<= 4;                       c2 |= ch - '0';                     } else if (ch >= 'A' && ch <= 'F') {                       c2 <<= 4;                       c2 |= ch + 10 - 'A';                     } else if (ch >= 'a' && ch <= 'f') {                       c2 <<= 4;                       c2 |= ch + 10 - 'a';                     } else {                       this.RaiseError(                         "Invalid Unicode escaped character");                     }                   }                   if ((c2 & 0xfc00) != 0xdc00) {                     this.RaiseError("Unpaired surrogate code point");                   } else {                     this.sb.Append((char)c);                     this.sb.Append((char)c2);                   }                 } else {                   this.RaiseError("Unpaired surrogate code point");                 }                 break;               }               default: {                 this.RaiseError("Invalid escaped character");                 break;               }             }             break;           case 0x22: // double quote             return this.sb.ToString();           default: {             // NOTE: Assumes the character reader             // throws an error on finding illegal surrogate             // pairs in the string or invalid encoding             // in the stream             if ((c >> 16) == 0) {               this.sb.Append((char)c);             } else {               this.sb.Append((char)((((c - 0x10000) >> 10) & 0x3ff) |                   0xd800));               this.sb.Append((char)(((c - 0x10000) & 0x3ff) | 0xdc00));             }             break;           }         }
Magic Number,PeterO.Cbor,CBORJson,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORJson.cs,NextJSONString,The following statement contains a magic number: switch (c) {           case '\\':             c = this.ReadChar();             switch (c) {               case '\\':               case '/':               case '\"':                 // Slash is now allowed to be escaped under RFC 8259                 this.sb.Append((char)c);                 break;               case 'b':                 this.sb.Append('\b');                 break;               case 'f':                 this.sb.Append('\f');                 break;               case 'n':                 this.sb.Append('\n');                 break;               case 'r':                 this.sb.Append('\r');                 break;               case 't':                 this.sb.Append('\t');                 break;               case 'u': { // Unicode escape                 c = 0;                 // Consists of 4 hex digits                 for (var i = 0; i < 4; ++i) {                   int ch = this.ReadChar();                   if (ch >= '0' && ch <= '9') {                     c <<= 4;                     c |= ch - '0';                   } else if (ch >= 'A' && ch <= 'F') {                     c <<= 4;                     c |= ch + 10 - 'A';                   } else if (ch >= 'a' && ch <= 'f') {                     c <<= 4;                     c |= ch + 10 - 'a';                   } else {                     this.RaiseError(                       "Invalid Unicode escaped character");                   }                 }                 if ((c & 0xf800) != 0xd800) {                   // Non-surrogate                   this.sb.Append((char)c);                 } else if ((c & 0xfc00) == 0xd800) {                   int ch = this.ReadChar();                   if (ch != '\\' || this.ReadChar() != 'u') {                     this.RaiseError("Invalid escaped character");                   }                   var c2 = 0;                   for (var i = 0; i < 4; ++i) {                     ch = this.ReadChar();                     if (ch >= '0' && ch <= '9') {                       c2 <<= 4;                       c2 |= ch - '0';                     } else if (ch >= 'A' && ch <= 'F') {                       c2 <<= 4;                       c2 |= ch + 10 - 'A';                     } else if (ch >= 'a' && ch <= 'f') {                       c2 <<= 4;                       c2 |= ch + 10 - 'a';                     } else {                       this.RaiseError(                         "Invalid Unicode escaped character");                     }                   }                   if ((c2 & 0xfc00) != 0xdc00) {                     this.RaiseError("Unpaired surrogate code point");                   } else {                     this.sb.Append((char)c);                     this.sb.Append((char)c2);                   }                 } else {                   this.RaiseError("Unpaired surrogate code point");                 }                 break;               }               default: {                 this.RaiseError("Invalid escaped character");                 break;               }             }             break;           case 0x22: // double quote             return this.sb.ToString();           default: {             // NOTE: Assumes the character reader             // throws an error on finding illegal surrogate             // pairs in the string or invalid encoding             // in the stream             if ((c >> 16) == 0) {               this.sb.Append((char)c);             } else {               this.sb.Append((char)((((c - 0x10000) >> 10) & 0x3ff) |                   0xd800));               this.sb.Append((char)(((c - 0x10000) & 0x3ff) | 0xdc00));             }             break;           }         }
Magic Number,PeterO.Cbor,CBORJson,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORJson.cs,NextJSONNegativeNumber,The following statement contains a magic number: var charbuf = new char[32];
Magic Number,PeterO.Cbor,CBORJson,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORJson.cs,NextJSONNegativeNumber,The following statement contains a magic number: this.sb.Append(charbuf' 0' 32);
Magic Number,PeterO.Cbor,CBORJson,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORJson.cs,NextJSONNegativeNumber,The following statement contains a magic number: charbufptr >= 32
Magic Number,PeterO.Cbor,CBORJson,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORJson.cs,NextJSONNegativeNumber,The following statement contains a magic number: string errstr = (str.Length <= 100) ? str : (str.Substring(0'               100) + "...");
Magic Number,PeterO.Cbor,CBORJson,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORJson.cs,NextJSONNegativeNumber,The following statement contains a magic number: string errstr = (str.Length <= 100) ? str : (str.Substring(0'               100) + "...");
Magic Number,PeterO.Cbor,CBORJson,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORJson.cs,NextJSONValue,The following statement contains a magic number: switch (c) {         case '"': {           // Parse a string           // The tokenizer already checked the string for invalid           // surrogate pairs' so just call the CBORObject           // constructor directly           obj = CBORObject.FromRaw(this.NextJSONString());           nextChar[0] = this.SkipWhitespaceJSON();           return obj;         }         case '{': {           // Parse an object           obj = this.ParseJSONObject(depth + 1);           nextChar[0] = this.SkipWhitespaceJSON();           return obj;         }         case '[': {           // Parse an array           obj = this.ParseJSONArray(depth + 1);           nextChar[0] = this.SkipWhitespaceJSON();           return obj;         }         case 't': {           // Parse true           if ((c = this.ReadChar()) != 'r' || (c = this.ReadChar()) != 'u' ||             (c = this.ReadChar()) != 'e') {             this.RaiseError("Value can't be parsed.");           }           c = this.ReadChar();           if (c == 0x20 || c == 0x0a || c == 0x0d || c == 0x09) {             nextChar[0] = this.SkipWhitespaceJSON();           } else if (this.jsonSequenceMode && depth == 0) {             nextChar[0] = c;             this.RaiseError("JSON whitespace expected after top-level " +               "number in JSON sequence");           } else {             nextChar[0] = c;           }           return CBORObject.True;         }         case 'f': {           // Parse false           if ((c = this.ReadChar()) != 'a' || (c = this.ReadChar()) != 'l' ||             (c = this.ReadChar()) != 's' || (c = this.ReadChar()) != 'e') {             this.RaiseError("Value can't be parsed.");           }           c = this.ReadChar();           if (c == 0x20 || c == 0x0a || c == 0x0d || c == 0x09) {             nextChar[0] = this.SkipWhitespaceJSON();           } else if (this.jsonSequenceMode && depth == 0) {             nextChar[0] = c;             this.RaiseError("JSON whitespace expected after top-level " +               "number in JSON sequence");           } else {             nextChar[0] = c;           }           return CBORObject.False;         }         case 'n': {           // Parse null           if ((c = this.ReadChar()) != 'u' || (c = this.ReadChar()) != 'l' ||             (c = this.ReadChar()) != 'l') {             this.RaiseError("Value can't be parsed.");           }           c = this.ReadChar();           if (c == 0x20 || c == 0x0a || c == 0x0d || c == 0x09) {             nextChar[0] = this.SkipWhitespaceJSON();           } else if (this.jsonSequenceMode && depth == 0) {             nextChar[0] = c;             this.RaiseError("JSON whitespace expected after top-level " +               "number in JSON sequence");           } else {             nextChar[0] = c;           }           return CBORObject.Null;         }         case '-': {           // Parse a negative number           return this.NextJSONNegativeNumber(nextChar' depth);         }         case '0':         case '1':         case '2':         case '3':         case '4':         case '5':         case '6':         case '7':         case '8':         case '9': {           // Parse a nonnegative number           int cval = c - '0';           int cstart = c;           var needObj = true;           c = this.ReadChar();           if (!(c == '-' || c == '+' || c == '.' || (c >= '0' && c <= '9') ||               c == 'e' || c == 'E')) {             // Optimize for common case where JSON number             // is a single digit without sign or exponent             obj = CBORDataUtilities.ParseSmallNumber(cval' this.options);             needObj = false;           } else if (c >= '0' && c <= '9') {             int csecond = c;             if (cstart == '0') {               // Leading zero followed by any digit is not allowed               this.RaiseError("JSON number can't be parsed.");             }             cval = (cval * 10) + (int)(c - '0');             c = this.ReadChar();             if (c >= '0' && c <= '9') {               var digits = 2;               var ctmp = new int[10];               ctmp[0] = cstart;               ctmp[1] = csecond;               while (digits < 9 && (c >= '0' && c <= '9')) {                 cval = (cval * 10) + (int)(c - '0');                 ctmp[digits++] = c;                 c = this.ReadChar();               }               if (c == 'e' || c == 'E' || c == '.' || (c >= '0' && c <= '9')) {                 // Not an all-digit number' or too long                 this.sb = this.sb ?? new StringBuilder();                 this.sb.Remove(0' this.sb.Length);                 for (var vi = 0; vi < digits; ++vi) {                   this.sb.Append((char)ctmp[vi]);                 }               } else {                 obj = CBORDataUtilities.ParseSmallNumber(cval' this.options);                 needObj = false;               }             } else if (!(c == '-' || c == '+' || c == '.' || c == 'e' || c                 == 'E')) {               // Optimize for common case where JSON number               // is two digits without sign' decimal point' or exponent               obj = CBORDataUtilities.ParseSmallNumber(cval' this.options);               needObj = false;             } else {               this.sb = this.sb ?? new StringBuilder();               this.sb.Remove(0' this.sb.Length);               this.sb.Append((char)cstart);               this.sb.Append((char)csecond);             }           } else {             this.sb = this.sb ?? new StringBuilder();             this.sb.Remove(0' this.sb.Length);             this.sb.Append((char)cstart);           }           if (needObj) {             var charbuf = new char[32];             var charbufptr = 0;             while (               c == '-' || c == '+' || c == '.' || (c >= '0' && c <= '9') ||               c == 'e' || c == 'E') {               charbuf[charbufptr++] = (char)c;               if (charbufptr >= 32) {                 this.sb.Append(charbuf' 0' 32);                 charbufptr = 0;               }               c = this.ReadChar();             }             if (charbufptr > 0) {               this.sb.Append(charbuf' 0' charbufptr);             }             // check if character can validly appear after a JSON number             if (c != ''' && c != ']' && c != '}' && c != -1 &&               c != 0x20 && c != 0x0a && c != 0x0d && c != 0x09) {               this.RaiseError("Invalid character after JSON number");             }             str = this.sb.ToString();             obj = CBORDataUtilities.ParseJSONNumber(str' this.options);             if (obj == null) {               string errstr = (str.Length <= 100) ? str : (str.Substring(0'                     100) + "...");               this.RaiseError("JSON number can't be parsed. " + errstr);             }           }           if (c == 0x20 || c == 0x0a || c == 0x0d || c == 0x09) {             nextChar[0] = this.SkipWhitespaceJSON();           } else if (this.jsonSequenceMode && depth == 0) {             nextChar[0] = c;             this.RaiseError("JSON whitespace expected after top-level " +               "number in JSON sequence");           } else {             nextChar[0] = c;           }           return obj;         }         default: this.RaiseError("Value can't be parsed.");           break;       }
Magic Number,PeterO.Cbor,CBORJson,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORJson.cs,NextJSONValue,The following statement contains a magic number: switch (c) {         case '"': {           // Parse a string           // The tokenizer already checked the string for invalid           // surrogate pairs' so just call the CBORObject           // constructor directly           obj = CBORObject.FromRaw(this.NextJSONString());           nextChar[0] = this.SkipWhitespaceJSON();           return obj;         }         case '{': {           // Parse an object           obj = this.ParseJSONObject(depth + 1);           nextChar[0] = this.SkipWhitespaceJSON();           return obj;         }         case '[': {           // Parse an array           obj = this.ParseJSONArray(depth + 1);           nextChar[0] = this.SkipWhitespaceJSON();           return obj;         }         case 't': {           // Parse true           if ((c = this.ReadChar()) != 'r' || (c = this.ReadChar()) != 'u' ||             (c = this.ReadChar()) != 'e') {             this.RaiseError("Value can't be parsed.");           }           c = this.ReadChar();           if (c == 0x20 || c == 0x0a || c == 0x0d || c == 0x09) {             nextChar[0] = this.SkipWhitespaceJSON();           } else if (this.jsonSequenceMode && depth == 0) {             nextChar[0] = c;             this.RaiseError("JSON whitespace expected after top-level " +               "number in JSON sequence");           } else {             nextChar[0] = c;           }           return CBORObject.True;         }         case 'f': {           // Parse false           if ((c = this.ReadChar()) != 'a' || (c = this.ReadChar()) != 'l' ||             (c = this.ReadChar()) != 's' || (c = this.ReadChar()) != 'e') {             this.RaiseError("Value can't be parsed.");           }           c = this.ReadChar();           if (c == 0x20 || c == 0x0a || c == 0x0d || c == 0x09) {             nextChar[0] = this.SkipWhitespaceJSON();           } else if (this.jsonSequenceMode && depth == 0) {             nextChar[0] = c;             this.RaiseError("JSON whitespace expected after top-level " +               "number in JSON sequence");           } else {             nextChar[0] = c;           }           return CBORObject.False;         }         case 'n': {           // Parse null           if ((c = this.ReadChar()) != 'u' || (c = this.ReadChar()) != 'l' ||             (c = this.ReadChar()) != 'l') {             this.RaiseError("Value can't be parsed.");           }           c = this.ReadChar();           if (c == 0x20 || c == 0x0a || c == 0x0d || c == 0x09) {             nextChar[0] = this.SkipWhitespaceJSON();           } else if (this.jsonSequenceMode && depth == 0) {             nextChar[0] = c;             this.RaiseError("JSON whitespace expected after top-level " +               "number in JSON sequence");           } else {             nextChar[0] = c;           }           return CBORObject.Null;         }         case '-': {           // Parse a negative number           return this.NextJSONNegativeNumber(nextChar' depth);         }         case '0':         case '1':         case '2':         case '3':         case '4':         case '5':         case '6':         case '7':         case '8':         case '9': {           // Parse a nonnegative number           int cval = c - '0';           int cstart = c;           var needObj = true;           c = this.ReadChar();           if (!(c == '-' || c == '+' || c == '.' || (c >= '0' && c <= '9') ||               c == 'e' || c == 'E')) {             // Optimize for common case where JSON number             // is a single digit without sign or exponent             obj = CBORDataUtilities.ParseSmallNumber(cval' this.options);             needObj = false;           } else if (c >= '0' && c <= '9') {             int csecond = c;             if (cstart == '0') {               // Leading zero followed by any digit is not allowed               this.RaiseError("JSON number can't be parsed.");             }             cval = (cval * 10) + (int)(c - '0');             c = this.ReadChar();             if (c >= '0' && c <= '9') {               var digits = 2;               var ctmp = new int[10];               ctmp[0] = cstart;               ctmp[1] = csecond;               while (digits < 9 && (c >= '0' && c <= '9')) {                 cval = (cval * 10) + (int)(c - '0');                 ctmp[digits++] = c;                 c = this.ReadChar();               }               if (c == 'e' || c == 'E' || c == '.' || (c >= '0' && c <= '9')) {                 // Not an all-digit number' or too long                 this.sb = this.sb ?? new StringBuilder();                 this.sb.Remove(0' this.sb.Length);                 for (var vi = 0; vi < digits; ++vi) {                   this.sb.Append((char)ctmp[vi]);                 }               } else {                 obj = CBORDataUtilities.ParseSmallNumber(cval' this.options);                 needObj = false;               }             } else if (!(c == '-' || c == '+' || c == '.' || c == 'e' || c                 == 'E')) {               // Optimize for common case where JSON number               // is two digits without sign' decimal point' or exponent               obj = CBORDataUtilities.ParseSmallNumber(cval' this.options);               needObj = false;             } else {               this.sb = this.sb ?? new StringBuilder();               this.sb.Remove(0' this.sb.Length);               this.sb.Append((char)cstart);               this.sb.Append((char)csecond);             }           } else {             this.sb = this.sb ?? new StringBuilder();             this.sb.Remove(0' this.sb.Length);             this.sb.Append((char)cstart);           }           if (needObj) {             var charbuf = new char[32];             var charbufptr = 0;             while (               c == '-' || c == '+' || c == '.' || (c >= '0' && c <= '9') ||               c == 'e' || c == 'E') {               charbuf[charbufptr++] = (char)c;               if (charbufptr >= 32) {                 this.sb.Append(charbuf' 0' 32);                 charbufptr = 0;               }               c = this.ReadChar();             }             if (charbufptr > 0) {               this.sb.Append(charbuf' 0' charbufptr);             }             // check if character can validly appear after a JSON number             if (c != ''' && c != ']' && c != '}' && c != -1 &&               c != 0x20 && c != 0x0a && c != 0x0d && c != 0x09) {               this.RaiseError("Invalid character after JSON number");             }             str = this.sb.ToString();             obj = CBORDataUtilities.ParseJSONNumber(str' this.options);             if (obj == null) {               string errstr = (str.Length <= 100) ? str : (str.Substring(0'                     100) + "...");               this.RaiseError("JSON number can't be parsed. " + errstr);             }           }           if (c == 0x20 || c == 0x0a || c == 0x0d || c == 0x09) {             nextChar[0] = this.SkipWhitespaceJSON();           } else if (this.jsonSequenceMode && depth == 0) {             nextChar[0] = c;             this.RaiseError("JSON whitespace expected after top-level " +               "number in JSON sequence");           } else {             nextChar[0] = c;           }           return obj;         }         default: this.RaiseError("Value can't be parsed.");           break;       }
Magic Number,PeterO.Cbor,CBORJson,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORJson.cs,NextJSONValue,The following statement contains a magic number: switch (c) {         case '"': {           // Parse a string           // The tokenizer already checked the string for invalid           // surrogate pairs' so just call the CBORObject           // constructor directly           obj = CBORObject.FromRaw(this.NextJSONString());           nextChar[0] = this.SkipWhitespaceJSON();           return obj;         }         case '{': {           // Parse an object           obj = this.ParseJSONObject(depth + 1);           nextChar[0] = this.SkipWhitespaceJSON();           return obj;         }         case '[': {           // Parse an array           obj = this.ParseJSONArray(depth + 1);           nextChar[0] = this.SkipWhitespaceJSON();           return obj;         }         case 't': {           // Parse true           if ((c = this.ReadChar()) != 'r' || (c = this.ReadChar()) != 'u' ||             (c = this.ReadChar()) != 'e') {             this.RaiseError("Value can't be parsed.");           }           c = this.ReadChar();           if (c == 0x20 || c == 0x0a || c == 0x0d || c == 0x09) {             nextChar[0] = this.SkipWhitespaceJSON();           } else if (this.jsonSequenceMode && depth == 0) {             nextChar[0] = c;             this.RaiseError("JSON whitespace expected after top-level " +               "number in JSON sequence");           } else {             nextChar[0] = c;           }           return CBORObject.True;         }         case 'f': {           // Parse false           if ((c = this.ReadChar()) != 'a' || (c = this.ReadChar()) != 'l' ||             (c = this.ReadChar()) != 's' || (c = this.ReadChar()) != 'e') {             this.RaiseError("Value can't be parsed.");           }           c = this.ReadChar();           if (c == 0x20 || c == 0x0a || c == 0x0d || c == 0x09) {             nextChar[0] = this.SkipWhitespaceJSON();           } else if (this.jsonSequenceMode && depth == 0) {             nextChar[0] = c;             this.RaiseError("JSON whitespace expected after top-level " +               "number in JSON sequence");           } else {             nextChar[0] = c;           }           return CBORObject.False;         }         case 'n': {           // Parse null           if ((c = this.ReadChar()) != 'u' || (c = this.ReadChar()) != 'l' ||             (c = this.ReadChar()) != 'l') {             this.RaiseError("Value can't be parsed.");           }           c = this.ReadChar();           if (c == 0x20 || c == 0x0a || c == 0x0d || c == 0x09) {             nextChar[0] = this.SkipWhitespaceJSON();           } else if (this.jsonSequenceMode && depth == 0) {             nextChar[0] = c;             this.RaiseError("JSON whitespace expected after top-level " +               "number in JSON sequence");           } else {             nextChar[0] = c;           }           return CBORObject.Null;         }         case '-': {           // Parse a negative number           return this.NextJSONNegativeNumber(nextChar' depth);         }         case '0':         case '1':         case '2':         case '3':         case '4':         case '5':         case '6':         case '7':         case '8':         case '9': {           // Parse a nonnegative number           int cval = c - '0';           int cstart = c;           var needObj = true;           c = this.ReadChar();           if (!(c == '-' || c == '+' || c == '.' || (c >= '0' && c <= '9') ||               c == 'e' || c == 'E')) {             // Optimize for common case where JSON number             // is a single digit without sign or exponent             obj = CBORDataUtilities.ParseSmallNumber(cval' this.options);             needObj = false;           } else if (c >= '0' && c <= '9') {             int csecond = c;             if (cstart == '0') {               // Leading zero followed by any digit is not allowed               this.RaiseError("JSON number can't be parsed.");             }             cval = (cval * 10) + (int)(c - '0');             c = this.ReadChar();             if (c >= '0' && c <= '9') {               var digits = 2;               var ctmp = new int[10];               ctmp[0] = cstart;               ctmp[1] = csecond;               while (digits < 9 && (c >= '0' && c <= '9')) {                 cval = (cval * 10) + (int)(c - '0');                 ctmp[digits++] = c;                 c = this.ReadChar();               }               if (c == 'e' || c == 'E' || c == '.' || (c >= '0' && c <= '9')) {                 // Not an all-digit number' or too long                 this.sb = this.sb ?? new StringBuilder();                 this.sb.Remove(0' this.sb.Length);                 for (var vi = 0; vi < digits; ++vi) {                   this.sb.Append((char)ctmp[vi]);                 }               } else {                 obj = CBORDataUtilities.ParseSmallNumber(cval' this.options);                 needObj = false;               }             } else if (!(c == '-' || c == '+' || c == '.' || c == 'e' || c                 == 'E')) {               // Optimize for common case where JSON number               // is two digits without sign' decimal point' or exponent               obj = CBORDataUtilities.ParseSmallNumber(cval' this.options);               needObj = false;             } else {               this.sb = this.sb ?? new StringBuilder();               this.sb.Remove(0' this.sb.Length);               this.sb.Append((char)cstart);               this.sb.Append((char)csecond);             }           } else {             this.sb = this.sb ?? new StringBuilder();             this.sb.Remove(0' this.sb.Length);             this.sb.Append((char)cstart);           }           if (needObj) {             var charbuf = new char[32];             var charbufptr = 0;             while (               c == '-' || c == '+' || c == '.' || (c >= '0' && c <= '9') ||               c == 'e' || c == 'E') {               charbuf[charbufptr++] = (char)c;               if (charbufptr >= 32) {                 this.sb.Append(charbuf' 0' 32);                 charbufptr = 0;               }               c = this.ReadChar();             }             if (charbufptr > 0) {               this.sb.Append(charbuf' 0' charbufptr);             }             // check if character can validly appear after a JSON number             if (c != ''' && c != ']' && c != '}' && c != -1 &&               c != 0x20 && c != 0x0a && c != 0x0d && c != 0x09) {               this.RaiseError("Invalid character after JSON number");             }             str = this.sb.ToString();             obj = CBORDataUtilities.ParseJSONNumber(str' this.options);             if (obj == null) {               string errstr = (str.Length <= 100) ? str : (str.Substring(0'                     100) + "...");               this.RaiseError("JSON number can't be parsed. " + errstr);             }           }           if (c == 0x20 || c == 0x0a || c == 0x0d || c == 0x09) {             nextChar[0] = this.SkipWhitespaceJSON();           } else if (this.jsonSequenceMode && depth == 0) {             nextChar[0] = c;             this.RaiseError("JSON whitespace expected after top-level " +               "number in JSON sequence");           } else {             nextChar[0] = c;           }           return obj;         }         default: this.RaiseError("Value can't be parsed.");           break;       }
Magic Number,PeterO.Cbor,CBORJson,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORJson.cs,NextJSONValue,The following statement contains a magic number: switch (c) {         case '"': {           // Parse a string           // The tokenizer already checked the string for invalid           // surrogate pairs' so just call the CBORObject           // constructor directly           obj = CBORObject.FromRaw(this.NextJSONString());           nextChar[0] = this.SkipWhitespaceJSON();           return obj;         }         case '{': {           // Parse an object           obj = this.ParseJSONObject(depth + 1);           nextChar[0] = this.SkipWhitespaceJSON();           return obj;         }         case '[': {           // Parse an array           obj = this.ParseJSONArray(depth + 1);           nextChar[0] = this.SkipWhitespaceJSON();           return obj;         }         case 't': {           // Parse true           if ((c = this.ReadChar()) != 'r' || (c = this.ReadChar()) != 'u' ||             (c = this.ReadChar()) != 'e') {             this.RaiseError("Value can't be parsed.");           }           c = this.ReadChar();           if (c == 0x20 || c == 0x0a || c == 0x0d || c == 0x09) {             nextChar[0] = this.SkipWhitespaceJSON();           } else if (this.jsonSequenceMode && depth == 0) {             nextChar[0] = c;             this.RaiseError("JSON whitespace expected after top-level " +               "number in JSON sequence");           } else {             nextChar[0] = c;           }           return CBORObject.True;         }         case 'f': {           // Parse false           if ((c = this.ReadChar()) != 'a' || (c = this.ReadChar()) != 'l' ||             (c = this.ReadChar()) != 's' || (c = this.ReadChar()) != 'e') {             this.RaiseError("Value can't be parsed.");           }           c = this.ReadChar();           if (c == 0x20 || c == 0x0a || c == 0x0d || c == 0x09) {             nextChar[0] = this.SkipWhitespaceJSON();           } else if (this.jsonSequenceMode && depth == 0) {             nextChar[0] = c;             this.RaiseError("JSON whitespace expected after top-level " +               "number in JSON sequence");           } else {             nextChar[0] = c;           }           return CBORObject.False;         }         case 'n': {           // Parse null           if ((c = this.ReadChar()) != 'u' || (c = this.ReadChar()) != 'l' ||             (c = this.ReadChar()) != 'l') {             this.RaiseError("Value can't be parsed.");           }           c = this.ReadChar();           if (c == 0x20 || c == 0x0a || c == 0x0d || c == 0x09) {             nextChar[0] = this.SkipWhitespaceJSON();           } else if (this.jsonSequenceMode && depth == 0) {             nextChar[0] = c;             this.RaiseError("JSON whitespace expected after top-level " +               "number in JSON sequence");           } else {             nextChar[0] = c;           }           return CBORObject.Null;         }         case '-': {           // Parse a negative number           return this.NextJSONNegativeNumber(nextChar' depth);         }         case '0':         case '1':         case '2':         case '3':         case '4':         case '5':         case '6':         case '7':         case '8':         case '9': {           // Parse a nonnegative number           int cval = c - '0';           int cstart = c;           var needObj = true;           c = this.ReadChar();           if (!(c == '-' || c == '+' || c == '.' || (c >= '0' && c <= '9') ||               c == 'e' || c == 'E')) {             // Optimize for common case where JSON number             // is a single digit without sign or exponent             obj = CBORDataUtilities.ParseSmallNumber(cval' this.options);             needObj = false;           } else if (c >= '0' && c <= '9') {             int csecond = c;             if (cstart == '0') {               // Leading zero followed by any digit is not allowed               this.RaiseError("JSON number can't be parsed.");             }             cval = (cval * 10) + (int)(c - '0');             c = this.ReadChar();             if (c >= '0' && c <= '9') {               var digits = 2;               var ctmp = new int[10];               ctmp[0] = cstart;               ctmp[1] = csecond;               while (digits < 9 && (c >= '0' && c <= '9')) {                 cval = (cval * 10) + (int)(c - '0');                 ctmp[digits++] = c;                 c = this.ReadChar();               }               if (c == 'e' || c == 'E' || c == '.' || (c >= '0' && c <= '9')) {                 // Not an all-digit number' or too long                 this.sb = this.sb ?? new StringBuilder();                 this.sb.Remove(0' this.sb.Length);                 for (var vi = 0; vi < digits; ++vi) {                   this.sb.Append((char)ctmp[vi]);                 }               } else {                 obj = CBORDataUtilities.ParseSmallNumber(cval' this.options);                 needObj = false;               }             } else if (!(c == '-' || c == '+' || c == '.' || c == 'e' || c                 == 'E')) {               // Optimize for common case where JSON number               // is two digits without sign' decimal point' or exponent               obj = CBORDataUtilities.ParseSmallNumber(cval' this.options);               needObj = false;             } else {               this.sb = this.sb ?? new StringBuilder();               this.sb.Remove(0' this.sb.Length);               this.sb.Append((char)cstart);               this.sb.Append((char)csecond);             }           } else {             this.sb = this.sb ?? new StringBuilder();             this.sb.Remove(0' this.sb.Length);             this.sb.Append((char)cstart);           }           if (needObj) {             var charbuf = new char[32];             var charbufptr = 0;             while (               c == '-' || c == '+' || c == '.' || (c >= '0' && c <= '9') ||               c == 'e' || c == 'E') {               charbuf[charbufptr++] = (char)c;               if (charbufptr >= 32) {                 this.sb.Append(charbuf' 0' 32);                 charbufptr = 0;               }               c = this.ReadChar();             }             if (charbufptr > 0) {               this.sb.Append(charbuf' 0' charbufptr);             }             // check if character can validly appear after a JSON number             if (c != ''' && c != ']' && c != '}' && c != -1 &&               c != 0x20 && c != 0x0a && c != 0x0d && c != 0x09) {               this.RaiseError("Invalid character after JSON number");             }             str = this.sb.ToString();             obj = CBORDataUtilities.ParseJSONNumber(str' this.options);             if (obj == null) {               string errstr = (str.Length <= 100) ? str : (str.Substring(0'                     100) + "...");               this.RaiseError("JSON number can't be parsed. " + errstr);             }           }           if (c == 0x20 || c == 0x0a || c == 0x0d || c == 0x09) {             nextChar[0] = this.SkipWhitespaceJSON();           } else if (this.jsonSequenceMode && depth == 0) {             nextChar[0] = c;             this.RaiseError("JSON whitespace expected after top-level " +               "number in JSON sequence");           } else {             nextChar[0] = c;           }           return obj;         }         default: this.RaiseError("Value can't be parsed.");           break;       }
Magic Number,PeterO.Cbor,CBORJson,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORJson.cs,NextJSONValue,The following statement contains a magic number: switch (c) {         case '"': {           // Parse a string           // The tokenizer already checked the string for invalid           // surrogate pairs' so just call the CBORObject           // constructor directly           obj = CBORObject.FromRaw(this.NextJSONString());           nextChar[0] = this.SkipWhitespaceJSON();           return obj;         }         case '{': {           // Parse an object           obj = this.ParseJSONObject(depth + 1);           nextChar[0] = this.SkipWhitespaceJSON();           return obj;         }         case '[': {           // Parse an array           obj = this.ParseJSONArray(depth + 1);           nextChar[0] = this.SkipWhitespaceJSON();           return obj;         }         case 't': {           // Parse true           if ((c = this.ReadChar()) != 'r' || (c = this.ReadChar()) != 'u' ||             (c = this.ReadChar()) != 'e') {             this.RaiseError("Value can't be parsed.");           }           c = this.ReadChar();           if (c == 0x20 || c == 0x0a || c == 0x0d || c == 0x09) {             nextChar[0] = this.SkipWhitespaceJSON();           } else if (this.jsonSequenceMode && depth == 0) {             nextChar[0] = c;             this.RaiseError("JSON whitespace expected after top-level " +               "number in JSON sequence");           } else {             nextChar[0] = c;           }           return CBORObject.True;         }         case 'f': {           // Parse false           if ((c = this.ReadChar()) != 'a' || (c = this.ReadChar()) != 'l' ||             (c = this.ReadChar()) != 's' || (c = this.ReadChar()) != 'e') {             this.RaiseError("Value can't be parsed.");           }           c = this.ReadChar();           if (c == 0x20 || c == 0x0a || c == 0x0d || c == 0x09) {             nextChar[0] = this.SkipWhitespaceJSON();           } else if (this.jsonSequenceMode && depth == 0) {             nextChar[0] = c;             this.RaiseError("JSON whitespace expected after top-level " +               "number in JSON sequence");           } else {             nextChar[0] = c;           }           return CBORObject.False;         }         case 'n': {           // Parse null           if ((c = this.ReadChar()) != 'u' || (c = this.ReadChar()) != 'l' ||             (c = this.ReadChar()) != 'l') {             this.RaiseError("Value can't be parsed.");           }           c = this.ReadChar();           if (c == 0x20 || c == 0x0a || c == 0x0d || c == 0x09) {             nextChar[0] = this.SkipWhitespaceJSON();           } else if (this.jsonSequenceMode && depth == 0) {             nextChar[0] = c;             this.RaiseError("JSON whitespace expected after top-level " +               "number in JSON sequence");           } else {             nextChar[0] = c;           }           return CBORObject.Null;         }         case '-': {           // Parse a negative number           return this.NextJSONNegativeNumber(nextChar' depth);         }         case '0':         case '1':         case '2':         case '3':         case '4':         case '5':         case '6':         case '7':         case '8':         case '9': {           // Parse a nonnegative number           int cval = c - '0';           int cstart = c;           var needObj = true;           c = this.ReadChar();           if (!(c == '-' || c == '+' || c == '.' || (c >= '0' && c <= '9') ||               c == 'e' || c == 'E')) {             // Optimize for common case where JSON number             // is a single digit without sign or exponent             obj = CBORDataUtilities.ParseSmallNumber(cval' this.options);             needObj = false;           } else if (c >= '0' && c <= '9') {             int csecond = c;             if (cstart == '0') {               // Leading zero followed by any digit is not allowed               this.RaiseError("JSON number can't be parsed.");             }             cval = (cval * 10) + (int)(c - '0');             c = this.ReadChar();             if (c >= '0' && c <= '9') {               var digits = 2;               var ctmp = new int[10];               ctmp[0] = cstart;               ctmp[1] = csecond;               while (digits < 9 && (c >= '0' && c <= '9')) {                 cval = (cval * 10) + (int)(c - '0');                 ctmp[digits++] = c;                 c = this.ReadChar();               }               if (c == 'e' || c == 'E' || c == '.' || (c >= '0' && c <= '9')) {                 // Not an all-digit number' or too long                 this.sb = this.sb ?? new StringBuilder();                 this.sb.Remove(0' this.sb.Length);                 for (var vi = 0; vi < digits; ++vi) {                   this.sb.Append((char)ctmp[vi]);                 }               } else {                 obj = CBORDataUtilities.ParseSmallNumber(cval' this.options);                 needObj = false;               }             } else if (!(c == '-' || c == '+' || c == '.' || c == 'e' || c                 == 'E')) {               // Optimize for common case where JSON number               // is two digits without sign' decimal point' or exponent               obj = CBORDataUtilities.ParseSmallNumber(cval' this.options);               needObj = false;             } else {               this.sb = this.sb ?? new StringBuilder();               this.sb.Remove(0' this.sb.Length);               this.sb.Append((char)cstart);               this.sb.Append((char)csecond);             }           } else {             this.sb = this.sb ?? new StringBuilder();             this.sb.Remove(0' this.sb.Length);             this.sb.Append((char)cstart);           }           if (needObj) {             var charbuf = new char[32];             var charbufptr = 0;             while (               c == '-' || c == '+' || c == '.' || (c >= '0' && c <= '9') ||               c == 'e' || c == 'E') {               charbuf[charbufptr++] = (char)c;               if (charbufptr >= 32) {                 this.sb.Append(charbuf' 0' 32);                 charbufptr = 0;               }               c = this.ReadChar();             }             if (charbufptr > 0) {               this.sb.Append(charbuf' 0' charbufptr);             }             // check if character can validly appear after a JSON number             if (c != ''' && c != ']' && c != '}' && c != -1 &&               c != 0x20 && c != 0x0a && c != 0x0d && c != 0x09) {               this.RaiseError("Invalid character after JSON number");             }             str = this.sb.ToString();             obj = CBORDataUtilities.ParseJSONNumber(str' this.options);             if (obj == null) {               string errstr = (str.Length <= 100) ? str : (str.Substring(0'                     100) + "...");               this.RaiseError("JSON number can't be parsed. " + errstr);             }           }           if (c == 0x20 || c == 0x0a || c == 0x0d || c == 0x09) {             nextChar[0] = this.SkipWhitespaceJSON();           } else if (this.jsonSequenceMode && depth == 0) {             nextChar[0] = c;             this.RaiseError("JSON whitespace expected after top-level " +               "number in JSON sequence");           } else {             nextChar[0] = c;           }           return obj;         }         default: this.RaiseError("Value can't be parsed.");           break;       }
Magic Number,PeterO.Cbor,CBORJson,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORJson.cs,NextJSONValue,The following statement contains a magic number: switch (c) {         case '"': {           // Parse a string           // The tokenizer already checked the string for invalid           // surrogate pairs' so just call the CBORObject           // constructor directly           obj = CBORObject.FromRaw(this.NextJSONString());           nextChar[0] = this.SkipWhitespaceJSON();           return obj;         }         case '{': {           // Parse an object           obj = this.ParseJSONObject(depth + 1);           nextChar[0] = this.SkipWhitespaceJSON();           return obj;         }         case '[': {           // Parse an array           obj = this.ParseJSONArray(depth + 1);           nextChar[0] = this.SkipWhitespaceJSON();           return obj;         }         case 't': {           // Parse true           if ((c = this.ReadChar()) != 'r' || (c = this.ReadChar()) != 'u' ||             (c = this.ReadChar()) != 'e') {             this.RaiseError("Value can't be parsed.");           }           c = this.ReadChar();           if (c == 0x20 || c == 0x0a || c == 0x0d || c == 0x09) {             nextChar[0] = this.SkipWhitespaceJSON();           } else if (this.jsonSequenceMode && depth == 0) {             nextChar[0] = c;             this.RaiseError("JSON whitespace expected after top-level " +               "number in JSON sequence");           } else {             nextChar[0] = c;           }           return CBORObject.True;         }         case 'f': {           // Parse false           if ((c = this.ReadChar()) != 'a' || (c = this.ReadChar()) != 'l' ||             (c = this.ReadChar()) != 's' || (c = this.ReadChar()) != 'e') {             this.RaiseError("Value can't be parsed.");           }           c = this.ReadChar();           if (c == 0x20 || c == 0x0a || c == 0x0d || c == 0x09) {             nextChar[0] = this.SkipWhitespaceJSON();           } else if (this.jsonSequenceMode && depth == 0) {             nextChar[0] = c;             this.RaiseError("JSON whitespace expected after top-level " +               "number in JSON sequence");           } else {             nextChar[0] = c;           }           return CBORObject.False;         }         case 'n': {           // Parse null           if ((c = this.ReadChar()) != 'u' || (c = this.ReadChar()) != 'l' ||             (c = this.ReadChar()) != 'l') {             this.RaiseError("Value can't be parsed.");           }           c = this.ReadChar();           if (c == 0x20 || c == 0x0a || c == 0x0d || c == 0x09) {             nextChar[0] = this.SkipWhitespaceJSON();           } else if (this.jsonSequenceMode && depth == 0) {             nextChar[0] = c;             this.RaiseError("JSON whitespace expected after top-level " +               "number in JSON sequence");           } else {             nextChar[0] = c;           }           return CBORObject.Null;         }         case '-': {           // Parse a negative number           return this.NextJSONNegativeNumber(nextChar' depth);         }         case '0':         case '1':         case '2':         case '3':         case '4':         case '5':         case '6':         case '7':         case '8':         case '9': {           // Parse a nonnegative number           int cval = c - '0';           int cstart = c;           var needObj = true;           c = this.ReadChar();           if (!(c == '-' || c == '+' || c == '.' || (c >= '0' && c <= '9') ||               c == 'e' || c == 'E')) {             // Optimize for common case where JSON number             // is a single digit without sign or exponent             obj = CBORDataUtilities.ParseSmallNumber(cval' this.options);             needObj = false;           } else if (c >= '0' && c <= '9') {             int csecond = c;             if (cstart == '0') {               // Leading zero followed by any digit is not allowed               this.RaiseError("JSON number can't be parsed.");             }             cval = (cval * 10) + (int)(c - '0');             c = this.ReadChar();             if (c >= '0' && c <= '9') {               var digits = 2;               var ctmp = new int[10];               ctmp[0] = cstart;               ctmp[1] = csecond;               while (digits < 9 && (c >= '0' && c <= '9')) {                 cval = (cval * 10) + (int)(c - '0');                 ctmp[digits++] = c;                 c = this.ReadChar();               }               if (c == 'e' || c == 'E' || c == '.' || (c >= '0' && c <= '9')) {                 // Not an all-digit number' or too long                 this.sb = this.sb ?? new StringBuilder();                 this.sb.Remove(0' this.sb.Length);                 for (var vi = 0; vi < digits; ++vi) {                   this.sb.Append((char)ctmp[vi]);                 }               } else {                 obj = CBORDataUtilities.ParseSmallNumber(cval' this.options);                 needObj = false;               }             } else if (!(c == '-' || c == '+' || c == '.' || c == 'e' || c                 == 'E')) {               // Optimize for common case where JSON number               // is two digits without sign' decimal point' or exponent               obj = CBORDataUtilities.ParseSmallNumber(cval' this.options);               needObj = false;             } else {               this.sb = this.sb ?? new StringBuilder();               this.sb.Remove(0' this.sb.Length);               this.sb.Append((char)cstart);               this.sb.Append((char)csecond);             }           } else {             this.sb = this.sb ?? new StringBuilder();             this.sb.Remove(0' this.sb.Length);             this.sb.Append((char)cstart);           }           if (needObj) {             var charbuf = new char[32];             var charbufptr = 0;             while (               c == '-' || c == '+' || c == '.' || (c >= '0' && c <= '9') ||               c == 'e' || c == 'E') {               charbuf[charbufptr++] = (char)c;               if (charbufptr >= 32) {                 this.sb.Append(charbuf' 0' 32);                 charbufptr = 0;               }               c = this.ReadChar();             }             if (charbufptr > 0) {               this.sb.Append(charbuf' 0' charbufptr);             }             // check if character can validly appear after a JSON number             if (c != ''' && c != ']' && c != '}' && c != -1 &&               c != 0x20 && c != 0x0a && c != 0x0d && c != 0x09) {               this.RaiseError("Invalid character after JSON number");             }             str = this.sb.ToString();             obj = CBORDataUtilities.ParseJSONNumber(str' this.options);             if (obj == null) {               string errstr = (str.Length <= 100) ? str : (str.Substring(0'                     100) + "...");               this.RaiseError("JSON number can't be parsed. " + errstr);             }           }           if (c == 0x20 || c == 0x0a || c == 0x0d || c == 0x09) {             nextChar[0] = this.SkipWhitespaceJSON();           } else if (this.jsonSequenceMode && depth == 0) {             nextChar[0] = c;             this.RaiseError("JSON whitespace expected after top-level " +               "number in JSON sequence");           } else {             nextChar[0] = c;           }           return obj;         }         default: this.RaiseError("Value can't be parsed.");           break;       }
Magic Number,PeterO.Cbor,CBORJson,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORJson.cs,NextJSONValue,The following statement contains a magic number: switch (c) {         case '"': {           // Parse a string           // The tokenizer already checked the string for invalid           // surrogate pairs' so just call the CBORObject           // constructor directly           obj = CBORObject.FromRaw(this.NextJSONString());           nextChar[0] = this.SkipWhitespaceJSON();           return obj;         }         case '{': {           // Parse an object           obj = this.ParseJSONObject(depth + 1);           nextChar[0] = this.SkipWhitespaceJSON();           return obj;         }         case '[': {           // Parse an array           obj = this.ParseJSONArray(depth + 1);           nextChar[0] = this.SkipWhitespaceJSON();           return obj;         }         case 't': {           // Parse true           if ((c = this.ReadChar()) != 'r' || (c = this.ReadChar()) != 'u' ||             (c = this.ReadChar()) != 'e') {             this.RaiseError("Value can't be parsed.");           }           c = this.ReadChar();           if (c == 0x20 || c == 0x0a || c == 0x0d || c == 0x09) {             nextChar[0] = this.SkipWhitespaceJSON();           } else if (this.jsonSequenceMode && depth == 0) {             nextChar[0] = c;             this.RaiseError("JSON whitespace expected after top-level " +               "number in JSON sequence");           } else {             nextChar[0] = c;           }           return CBORObject.True;         }         case 'f': {           // Parse false           if ((c = this.ReadChar()) != 'a' || (c = this.ReadChar()) != 'l' ||             (c = this.ReadChar()) != 's' || (c = this.ReadChar()) != 'e') {             this.RaiseError("Value can't be parsed.");           }           c = this.ReadChar();           if (c == 0x20 || c == 0x0a || c == 0x0d || c == 0x09) {             nextChar[0] = this.SkipWhitespaceJSON();           } else if (this.jsonSequenceMode && depth == 0) {             nextChar[0] = c;             this.RaiseError("JSON whitespace expected after top-level " +               "number in JSON sequence");           } else {             nextChar[0] = c;           }           return CBORObject.False;         }         case 'n': {           // Parse null           if ((c = this.ReadChar()) != 'u' || (c = this.ReadChar()) != 'l' ||             (c = this.ReadChar()) != 'l') {             this.RaiseError("Value can't be parsed.");           }           c = this.ReadChar();           if (c == 0x20 || c == 0x0a || c == 0x0d || c == 0x09) {             nextChar[0] = this.SkipWhitespaceJSON();           } else if (this.jsonSequenceMode && depth == 0) {             nextChar[0] = c;             this.RaiseError("JSON whitespace expected after top-level " +               "number in JSON sequence");           } else {             nextChar[0] = c;           }           return CBORObject.Null;         }         case '-': {           // Parse a negative number           return this.NextJSONNegativeNumber(nextChar' depth);         }         case '0':         case '1':         case '2':         case '3':         case '4':         case '5':         case '6':         case '7':         case '8':         case '9': {           // Parse a nonnegative number           int cval = c - '0';           int cstart = c;           var needObj = true;           c = this.ReadChar();           if (!(c == '-' || c == '+' || c == '.' || (c >= '0' && c <= '9') ||               c == 'e' || c == 'E')) {             // Optimize for common case where JSON number             // is a single digit without sign or exponent             obj = CBORDataUtilities.ParseSmallNumber(cval' this.options);             needObj = false;           } else if (c >= '0' && c <= '9') {             int csecond = c;             if (cstart == '0') {               // Leading zero followed by any digit is not allowed               this.RaiseError("JSON number can't be parsed.");             }             cval = (cval * 10) + (int)(c - '0');             c = this.ReadChar();             if (c >= '0' && c <= '9') {               var digits = 2;               var ctmp = new int[10];               ctmp[0] = cstart;               ctmp[1] = csecond;               while (digits < 9 && (c >= '0' && c <= '9')) {                 cval = (cval * 10) + (int)(c - '0');                 ctmp[digits++] = c;                 c = this.ReadChar();               }               if (c == 'e' || c == 'E' || c == '.' || (c >= '0' && c <= '9')) {                 // Not an all-digit number' or too long                 this.sb = this.sb ?? new StringBuilder();                 this.sb.Remove(0' this.sb.Length);                 for (var vi = 0; vi < digits; ++vi) {                   this.sb.Append((char)ctmp[vi]);                 }               } else {                 obj = CBORDataUtilities.ParseSmallNumber(cval' this.options);                 needObj = false;               }             } else if (!(c == '-' || c == '+' || c == '.' || c == 'e' || c                 == 'E')) {               // Optimize for common case where JSON number               // is two digits without sign' decimal point' or exponent               obj = CBORDataUtilities.ParseSmallNumber(cval' this.options);               needObj = false;             } else {               this.sb = this.sb ?? new StringBuilder();               this.sb.Remove(0' this.sb.Length);               this.sb.Append((char)cstart);               this.sb.Append((char)csecond);             }           } else {             this.sb = this.sb ?? new StringBuilder();             this.sb.Remove(0' this.sb.Length);             this.sb.Append((char)cstart);           }           if (needObj) {             var charbuf = new char[32];             var charbufptr = 0;             while (               c == '-' || c == '+' || c == '.' || (c >= '0' && c <= '9') ||               c == 'e' || c == 'E') {               charbuf[charbufptr++] = (char)c;               if (charbufptr >= 32) {                 this.sb.Append(charbuf' 0' 32);                 charbufptr = 0;               }               c = this.ReadChar();             }             if (charbufptr > 0) {               this.sb.Append(charbuf' 0' charbufptr);             }             // check if character can validly appear after a JSON number             if (c != ''' && c != ']' && c != '}' && c != -1 &&               c != 0x20 && c != 0x0a && c != 0x0d && c != 0x09) {               this.RaiseError("Invalid character after JSON number");             }             str = this.sb.ToString();             obj = CBORDataUtilities.ParseJSONNumber(str' this.options);             if (obj == null) {               string errstr = (str.Length <= 100) ? str : (str.Substring(0'                     100) + "...");               this.RaiseError("JSON number can't be parsed. " + errstr);             }           }           if (c == 0x20 || c == 0x0a || c == 0x0d || c == 0x09) {             nextChar[0] = this.SkipWhitespaceJSON();           } else if (this.jsonSequenceMode && depth == 0) {             nextChar[0] = c;             this.RaiseError("JSON whitespace expected after top-level " +               "number in JSON sequence");           } else {             nextChar[0] = c;           }           return obj;         }         default: this.RaiseError("Value can't be parsed.");           break;       }
Magic Number,PeterO.Cbor,CBORJson,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORJson.cs,NextJSONValue,The following statement contains a magic number: switch (c) {         case '"': {           // Parse a string           // The tokenizer already checked the string for invalid           // surrogate pairs' so just call the CBORObject           // constructor directly           obj = CBORObject.FromRaw(this.NextJSONString());           nextChar[0] = this.SkipWhitespaceJSON();           return obj;         }         case '{': {           // Parse an object           obj = this.ParseJSONObject(depth + 1);           nextChar[0] = this.SkipWhitespaceJSON();           return obj;         }         case '[': {           // Parse an array           obj = this.ParseJSONArray(depth + 1);           nextChar[0] = this.SkipWhitespaceJSON();           return obj;         }         case 't': {           // Parse true           if ((c = this.ReadChar()) != 'r' || (c = this.ReadChar()) != 'u' ||             (c = this.ReadChar()) != 'e') {             this.RaiseError("Value can't be parsed.");           }           c = this.ReadChar();           if (c == 0x20 || c == 0x0a || c == 0x0d || c == 0x09) {             nextChar[0] = this.SkipWhitespaceJSON();           } else if (this.jsonSequenceMode && depth == 0) {             nextChar[0] = c;             this.RaiseError("JSON whitespace expected after top-level " +               "number in JSON sequence");           } else {             nextChar[0] = c;           }           return CBORObject.True;         }         case 'f': {           // Parse false           if ((c = this.ReadChar()) != 'a' || (c = this.ReadChar()) != 'l' ||             (c = this.ReadChar()) != 's' || (c = this.ReadChar()) != 'e') {             this.RaiseError("Value can't be parsed.");           }           c = this.ReadChar();           if (c == 0x20 || c == 0x0a || c == 0x0d || c == 0x09) {             nextChar[0] = this.SkipWhitespaceJSON();           } else if (this.jsonSequenceMode && depth == 0) {             nextChar[0] = c;             this.RaiseError("JSON whitespace expected after top-level " +               "number in JSON sequence");           } else {             nextChar[0] = c;           }           return CBORObject.False;         }         case 'n': {           // Parse null           if ((c = this.ReadChar()) != 'u' || (c = this.ReadChar()) != 'l' ||             (c = this.ReadChar()) != 'l') {             this.RaiseError("Value can't be parsed.");           }           c = this.ReadChar();           if (c == 0x20 || c == 0x0a || c == 0x0d || c == 0x09) {             nextChar[0] = this.SkipWhitespaceJSON();           } else if (this.jsonSequenceMode && depth == 0) {             nextChar[0] = c;             this.RaiseError("JSON whitespace expected after top-level " +               "number in JSON sequence");           } else {             nextChar[0] = c;           }           return CBORObject.Null;         }         case '-': {           // Parse a negative number           return this.NextJSONNegativeNumber(nextChar' depth);         }         case '0':         case '1':         case '2':         case '3':         case '4':         case '5':         case '6':         case '7':         case '8':         case '9': {           // Parse a nonnegative number           int cval = c - '0';           int cstart = c;           var needObj = true;           c = this.ReadChar();           if (!(c == '-' || c == '+' || c == '.' || (c >= '0' && c <= '9') ||               c == 'e' || c == 'E')) {             // Optimize for common case where JSON number             // is a single digit without sign or exponent             obj = CBORDataUtilities.ParseSmallNumber(cval' this.options);             needObj = false;           } else if (c >= '0' && c <= '9') {             int csecond = c;             if (cstart == '0') {               // Leading zero followed by any digit is not allowed               this.RaiseError("JSON number can't be parsed.");             }             cval = (cval * 10) + (int)(c - '0');             c = this.ReadChar();             if (c >= '0' && c <= '9') {               var digits = 2;               var ctmp = new int[10];               ctmp[0] = cstart;               ctmp[1] = csecond;               while (digits < 9 && (c >= '0' && c <= '9')) {                 cval = (cval * 10) + (int)(c - '0');                 ctmp[digits++] = c;                 c = this.ReadChar();               }               if (c == 'e' || c == 'E' || c == '.' || (c >= '0' && c <= '9')) {                 // Not an all-digit number' or too long                 this.sb = this.sb ?? new StringBuilder();                 this.sb.Remove(0' this.sb.Length);                 for (var vi = 0; vi < digits; ++vi) {                   this.sb.Append((char)ctmp[vi]);                 }               } else {                 obj = CBORDataUtilities.ParseSmallNumber(cval' this.options);                 needObj = false;               }             } else if (!(c == '-' || c == '+' || c == '.' || c == 'e' || c                 == 'E')) {               // Optimize for common case where JSON number               // is two digits without sign' decimal point' or exponent               obj = CBORDataUtilities.ParseSmallNumber(cval' this.options);               needObj = false;             } else {               this.sb = this.sb ?? new StringBuilder();               this.sb.Remove(0' this.sb.Length);               this.sb.Append((char)cstart);               this.sb.Append((char)csecond);             }           } else {             this.sb = this.sb ?? new StringBuilder();             this.sb.Remove(0' this.sb.Length);             this.sb.Append((char)cstart);           }           if (needObj) {             var charbuf = new char[32];             var charbufptr = 0;             while (               c == '-' || c == '+' || c == '.' || (c >= '0' && c <= '9') ||               c == 'e' || c == 'E') {               charbuf[charbufptr++] = (char)c;               if (charbufptr >= 32) {                 this.sb.Append(charbuf' 0' 32);                 charbufptr = 0;               }               c = this.ReadChar();             }             if (charbufptr > 0) {               this.sb.Append(charbuf' 0' charbufptr);             }             // check if character can validly appear after a JSON number             if (c != ''' && c != ']' && c != '}' && c != -1 &&               c != 0x20 && c != 0x0a && c != 0x0d && c != 0x09) {               this.RaiseError("Invalid character after JSON number");             }             str = this.sb.ToString();             obj = CBORDataUtilities.ParseJSONNumber(str' this.options);             if (obj == null) {               string errstr = (str.Length <= 100) ? str : (str.Substring(0'                     100) + "...");               this.RaiseError("JSON number can't be parsed. " + errstr);             }           }           if (c == 0x20 || c == 0x0a || c == 0x0d || c == 0x09) {             nextChar[0] = this.SkipWhitespaceJSON();           } else if (this.jsonSequenceMode && depth == 0) {             nextChar[0] = c;             this.RaiseError("JSON whitespace expected after top-level " +               "number in JSON sequence");           } else {             nextChar[0] = c;           }           return obj;         }         default: this.RaiseError("Value can't be parsed.");           break;       }
Magic Number,PeterO.Cbor,CBORJson,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORJson.cs,NextJSONValue,The following statement contains a magic number: switch (c) {         case '"': {           // Parse a string           // The tokenizer already checked the string for invalid           // surrogate pairs' so just call the CBORObject           // constructor directly           obj = CBORObject.FromRaw(this.NextJSONString());           nextChar[0] = this.SkipWhitespaceJSON();           return obj;         }         case '{': {           // Parse an object           obj = this.ParseJSONObject(depth + 1);           nextChar[0] = this.SkipWhitespaceJSON();           return obj;         }         case '[': {           // Parse an array           obj = this.ParseJSONArray(depth + 1);           nextChar[0] = this.SkipWhitespaceJSON();           return obj;         }         case 't': {           // Parse true           if ((c = this.ReadChar()) != 'r' || (c = this.ReadChar()) != 'u' ||             (c = this.ReadChar()) != 'e') {             this.RaiseError("Value can't be parsed.");           }           c = this.ReadChar();           if (c == 0x20 || c == 0x0a || c == 0x0d || c == 0x09) {             nextChar[0] = this.SkipWhitespaceJSON();           } else if (this.jsonSequenceMode && depth == 0) {             nextChar[0] = c;             this.RaiseError("JSON whitespace expected after top-level " +               "number in JSON sequence");           } else {             nextChar[0] = c;           }           return CBORObject.True;         }         case 'f': {           // Parse false           if ((c = this.ReadChar()) != 'a' || (c = this.ReadChar()) != 'l' ||             (c = this.ReadChar()) != 's' || (c = this.ReadChar()) != 'e') {             this.RaiseError("Value can't be parsed.");           }           c = this.ReadChar();           if (c == 0x20 || c == 0x0a || c == 0x0d || c == 0x09) {             nextChar[0] = this.SkipWhitespaceJSON();           } else if (this.jsonSequenceMode && depth == 0) {             nextChar[0] = c;             this.RaiseError("JSON whitespace expected after top-level " +               "number in JSON sequence");           } else {             nextChar[0] = c;           }           return CBORObject.False;         }         case 'n': {           // Parse null           if ((c = this.ReadChar()) != 'u' || (c = this.ReadChar()) != 'l' ||             (c = this.ReadChar()) != 'l') {             this.RaiseError("Value can't be parsed.");           }           c = this.ReadChar();           if (c == 0x20 || c == 0x0a || c == 0x0d || c == 0x09) {             nextChar[0] = this.SkipWhitespaceJSON();           } else if (this.jsonSequenceMode && depth == 0) {             nextChar[0] = c;             this.RaiseError("JSON whitespace expected after top-level " +               "number in JSON sequence");           } else {             nextChar[0] = c;           }           return CBORObject.Null;         }         case '-': {           // Parse a negative number           return this.NextJSONNegativeNumber(nextChar' depth);         }         case '0':         case '1':         case '2':         case '3':         case '4':         case '5':         case '6':         case '7':         case '8':         case '9': {           // Parse a nonnegative number           int cval = c - '0';           int cstart = c;           var needObj = true;           c = this.ReadChar();           if (!(c == '-' || c == '+' || c == '.' || (c >= '0' && c <= '9') ||               c == 'e' || c == 'E')) {             // Optimize for common case where JSON number             // is a single digit without sign or exponent             obj = CBORDataUtilities.ParseSmallNumber(cval' this.options);             needObj = false;           } else if (c >= '0' && c <= '9') {             int csecond = c;             if (cstart == '0') {               // Leading zero followed by any digit is not allowed               this.RaiseError("JSON number can't be parsed.");             }             cval = (cval * 10) + (int)(c - '0');             c = this.ReadChar();             if (c >= '0' && c <= '9') {               var digits = 2;               var ctmp = new int[10];               ctmp[0] = cstart;               ctmp[1] = csecond;               while (digits < 9 && (c >= '0' && c <= '9')) {                 cval = (cval * 10) + (int)(c - '0');                 ctmp[digits++] = c;                 c = this.ReadChar();               }               if (c == 'e' || c == 'E' || c == '.' || (c >= '0' && c <= '9')) {                 // Not an all-digit number' or too long                 this.sb = this.sb ?? new StringBuilder();                 this.sb.Remove(0' this.sb.Length);                 for (var vi = 0; vi < digits; ++vi) {                   this.sb.Append((char)ctmp[vi]);                 }               } else {                 obj = CBORDataUtilities.ParseSmallNumber(cval' this.options);                 needObj = false;               }             } else if (!(c == '-' || c == '+' || c == '.' || c == 'e' || c                 == 'E')) {               // Optimize for common case where JSON number               // is two digits without sign' decimal point' or exponent               obj = CBORDataUtilities.ParseSmallNumber(cval' this.options);               needObj = false;             } else {               this.sb = this.sb ?? new StringBuilder();               this.sb.Remove(0' this.sb.Length);               this.sb.Append((char)cstart);               this.sb.Append((char)csecond);             }           } else {             this.sb = this.sb ?? new StringBuilder();             this.sb.Remove(0' this.sb.Length);             this.sb.Append((char)cstart);           }           if (needObj) {             var charbuf = new char[32];             var charbufptr = 0;             while (               c == '-' || c == '+' || c == '.' || (c >= '0' && c <= '9') ||               c == 'e' || c == 'E') {               charbuf[charbufptr++] = (char)c;               if (charbufptr >= 32) {                 this.sb.Append(charbuf' 0' 32);                 charbufptr = 0;               }               c = this.ReadChar();             }             if (charbufptr > 0) {               this.sb.Append(charbuf' 0' charbufptr);             }             // check if character can validly appear after a JSON number             if (c != ''' && c != ']' && c != '}' && c != -1 &&               c != 0x20 && c != 0x0a && c != 0x0d && c != 0x09) {               this.RaiseError("Invalid character after JSON number");             }             str = this.sb.ToString();             obj = CBORDataUtilities.ParseJSONNumber(str' this.options);             if (obj == null) {               string errstr = (str.Length <= 100) ? str : (str.Substring(0'                     100) + "...");               this.RaiseError("JSON number can't be parsed. " + errstr);             }           }           if (c == 0x20 || c == 0x0a || c == 0x0d || c == 0x09) {             nextChar[0] = this.SkipWhitespaceJSON();           } else if (this.jsonSequenceMode && depth == 0) {             nextChar[0] = c;             this.RaiseError("JSON whitespace expected after top-level " +               "number in JSON sequence");           } else {             nextChar[0] = c;           }           return obj;         }         default: this.RaiseError("Value can't be parsed.");           break;       }
Magic Number,PeterO.Cbor,CBORJson,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORJson.cs,NextJSONValue,The following statement contains a magic number: switch (c) {         case '"': {           // Parse a string           // The tokenizer already checked the string for invalid           // surrogate pairs' so just call the CBORObject           // constructor directly           obj = CBORObject.FromRaw(this.NextJSONString());           nextChar[0] = this.SkipWhitespaceJSON();           return obj;         }         case '{': {           // Parse an object           obj = this.ParseJSONObject(depth + 1);           nextChar[0] = this.SkipWhitespaceJSON();           return obj;         }         case '[': {           // Parse an array           obj = this.ParseJSONArray(depth + 1);           nextChar[0] = this.SkipWhitespaceJSON();           return obj;         }         case 't': {           // Parse true           if ((c = this.ReadChar()) != 'r' || (c = this.ReadChar()) != 'u' ||             (c = this.ReadChar()) != 'e') {             this.RaiseError("Value can't be parsed.");           }           c = this.ReadChar();           if (c == 0x20 || c == 0x0a || c == 0x0d || c == 0x09) {             nextChar[0] = this.SkipWhitespaceJSON();           } else if (this.jsonSequenceMode && depth == 0) {             nextChar[0] = c;             this.RaiseError("JSON whitespace expected after top-level " +               "number in JSON sequence");           } else {             nextChar[0] = c;           }           return CBORObject.True;         }         case 'f': {           // Parse false           if ((c = this.ReadChar()) != 'a' || (c = this.ReadChar()) != 'l' ||             (c = this.ReadChar()) != 's' || (c = this.ReadChar()) != 'e') {             this.RaiseError("Value can't be parsed.");           }           c = this.ReadChar();           if (c == 0x20 || c == 0x0a || c == 0x0d || c == 0x09) {             nextChar[0] = this.SkipWhitespaceJSON();           } else if (this.jsonSequenceMode && depth == 0) {             nextChar[0] = c;             this.RaiseError("JSON whitespace expected after top-level " +               "number in JSON sequence");           } else {             nextChar[0] = c;           }           return CBORObject.False;         }         case 'n': {           // Parse null           if ((c = this.ReadChar()) != 'u' || (c = this.ReadChar()) != 'l' ||             (c = this.ReadChar()) != 'l') {             this.RaiseError("Value can't be parsed.");           }           c = this.ReadChar();           if (c == 0x20 || c == 0x0a || c == 0x0d || c == 0x09) {             nextChar[0] = this.SkipWhitespaceJSON();           } else if (this.jsonSequenceMode && depth == 0) {             nextChar[0] = c;             this.RaiseError("JSON whitespace expected after top-level " +               "number in JSON sequence");           } else {             nextChar[0] = c;           }           return CBORObject.Null;         }         case '-': {           // Parse a negative number           return this.NextJSONNegativeNumber(nextChar' depth);         }         case '0':         case '1':         case '2':         case '3':         case '4':         case '5':         case '6':         case '7':         case '8':         case '9': {           // Parse a nonnegative number           int cval = c - '0';           int cstart = c;           var needObj = true;           c = this.ReadChar();           if (!(c == '-' || c == '+' || c == '.' || (c >= '0' && c <= '9') ||               c == 'e' || c == 'E')) {             // Optimize for common case where JSON number             // is a single digit without sign or exponent             obj = CBORDataUtilities.ParseSmallNumber(cval' this.options);             needObj = false;           } else if (c >= '0' && c <= '9') {             int csecond = c;             if (cstart == '0') {               // Leading zero followed by any digit is not allowed               this.RaiseError("JSON number can't be parsed.");             }             cval = (cval * 10) + (int)(c - '0');             c = this.ReadChar();             if (c >= '0' && c <= '9') {               var digits = 2;               var ctmp = new int[10];               ctmp[0] = cstart;               ctmp[1] = csecond;               while (digits < 9 && (c >= '0' && c <= '9')) {                 cval = (cval * 10) + (int)(c - '0');                 ctmp[digits++] = c;                 c = this.ReadChar();               }               if (c == 'e' || c == 'E' || c == '.' || (c >= '0' && c <= '9')) {                 // Not an all-digit number' or too long                 this.sb = this.sb ?? new StringBuilder();                 this.sb.Remove(0' this.sb.Length);                 for (var vi = 0; vi < digits; ++vi) {                   this.sb.Append((char)ctmp[vi]);                 }               } else {                 obj = CBORDataUtilities.ParseSmallNumber(cval' this.options);                 needObj = false;               }             } else if (!(c == '-' || c == '+' || c == '.' || c == 'e' || c                 == 'E')) {               // Optimize for common case where JSON number               // is two digits without sign' decimal point' or exponent               obj = CBORDataUtilities.ParseSmallNumber(cval' this.options);               needObj = false;             } else {               this.sb = this.sb ?? new StringBuilder();               this.sb.Remove(0' this.sb.Length);               this.sb.Append((char)cstart);               this.sb.Append((char)csecond);             }           } else {             this.sb = this.sb ?? new StringBuilder();             this.sb.Remove(0' this.sb.Length);             this.sb.Append((char)cstart);           }           if (needObj) {             var charbuf = new char[32];             var charbufptr = 0;             while (               c == '-' || c == '+' || c == '.' || (c >= '0' && c <= '9') ||               c == 'e' || c == 'E') {               charbuf[charbufptr++] = (char)c;               if (charbufptr >= 32) {                 this.sb.Append(charbuf' 0' 32);                 charbufptr = 0;               }               c = this.ReadChar();             }             if (charbufptr > 0) {               this.sb.Append(charbuf' 0' charbufptr);             }             // check if character can validly appear after a JSON number             if (c != ''' && c != ']' && c != '}' && c != -1 &&               c != 0x20 && c != 0x0a && c != 0x0d && c != 0x09) {               this.RaiseError("Invalid character after JSON number");             }             str = this.sb.ToString();             obj = CBORDataUtilities.ParseJSONNumber(str' this.options);             if (obj == null) {               string errstr = (str.Length <= 100) ? str : (str.Substring(0'                     100) + "...");               this.RaiseError("JSON number can't be parsed. " + errstr);             }           }           if (c == 0x20 || c == 0x0a || c == 0x0d || c == 0x09) {             nextChar[0] = this.SkipWhitespaceJSON();           } else if (this.jsonSequenceMode && depth == 0) {             nextChar[0] = c;             this.RaiseError("JSON whitespace expected after top-level " +               "number in JSON sequence");           } else {             nextChar[0] = c;           }           return obj;         }         default: this.RaiseError("Value can't be parsed.");           break;       }
Magic Number,PeterO.Cbor,CBORJson,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORJson.cs,ParseJSONObject,The following statement contains a magic number: depth > 1000
Magic Number,PeterO.Cbor,CBORJson,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORJson.cs,ParseJSONArray,The following statement contains a magic number: depth > 1000
Magic Number,PeterO.Cbor,CBORJson2,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORJson2.cs,NextJSONString,The following statement contains a magic number: i < 64
Magic Number,PeterO.Cbor,CBORJson2,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORJson2.cs,NextJSONString,The following statement contains a magic number: switch (c) {           case '\\':             c = this.index < this.endPos ? ((int)this.bytes[this.index++]) &               0xff : -1;             switch (c) {               case '\\':               case '/':               case '\"':                 // Slash is now allowed to be escaped under RFC 8259                 this.sb.Append((char)c);                 break;               case 'b':                 this.sb.Append('\b');                 break;               case 'f':                 this.sb.Append('\f');                 break;               case 'n':                 this.sb.Append('\n');                 break;               case 'r':                 this.sb.Append('\r');                 break;               case 't':                 this.sb.Append('\t');                 break;               case 'u': { // Unicode escape                 c = 0;                 // Consists of 4 hex digits                 for (var i = 0; i < 4; ++i) {                   int ch = this.index < this.endPos ?                     ((int)this.bytes[this.index++]) & 0xff : -1;                   if (ch >= '0' && ch <= '9') {                     c <<= 4;                     c |= ch - '0';                   } else if (ch >= 'A' && ch <= 'F') {                     c <<= 4;                     c |= ch + 10 - 'A';                   } else if (ch >= 'a' && ch <= 'f') {                     c <<= 4;                     c |= ch + 10 - 'a';                   } else {                     this.RaiseError(                       "Invalid Unicode escaped character");                   }                 }                 if ((c & 0xf800) != 0xd800) {                   // Non-surrogate                   this.sb.Append((char)c);                 } else if ((c & 0xfc00) == 0xd800) {                   int ch = this.index < this.endPos ?                     ((int)this.bytes[this.index++]) & 0xff : -1;                   if (ch != '\\' || (this.index < this.endPos ?                       ((int)this.bytes[this.index++]) & 0xff : -1) != 'u') {                     this.RaiseError("Invalid escaped character");                   }                   var c2 = 0;                   for (var i = 0; i < 4; ++i) {                     ch = this.index < this.endPos ?                       ((int)this.bytes[this.index++]) & 0xff : -1;                     if (ch >= '0' && ch <= '9') {                       c2 <<= 4;                       c2 |= ch - '0';                     } else if (ch >= 'A' && ch <= 'F') {                       c2 <<= 4;                       c2 |= ch + 10 - 'A';                     } else if (ch >= 'a' && ch <= 'f') {                       c2 <<= 4;                       c2 |= ch + 10 - 'a';                     } else {                       this.RaiseError(                         "Invalid Unicode escaped character");                     }                   }                   if ((c2 & 0xfc00) != 0xdc00) {                     this.RaiseError("Unpaired surrogate code point");                   } else {                     this.sb.Append((char)c);                     this.sb.Append((char)c2);                   }                 } else {                   this.RaiseError("Unpaired surrogate code point");                 }                 break;               }               default: {                 this.RaiseError("Invalid escaped character");                 break;               }             }             break;           case 0x22: // double quote             return this.sb.ToString();           default: {             if (c <= 0x7f) {               this.sb.Append((char)c);             } else if (c >= 0xc2 && c <= 0xdf) {               int c1 = this.index < this.endPos ?                 ((int)this.bytes[this.index++]) & 0xff : -1;               if (c1 < 0x80 || c1 > 0xbf) {                 this.RaiseError("Invalid encoding");               }               c = ((c - 0xc0) << 6) | (c1 - 0x80);               this.sb.Append((char)c);             } else if (c >= 0xe0 && c <= 0xef) {               int c1 = this.index < this.endPos ?                 ((int)this.bytes[this.index++]) & 0xff : -1;               int c2 = this.index < this.endPos ?                 ((int)this.bytes[this.index++]) & 0xff : -1;               int lower = (c == 0xe0) ? 0xa0 : 0x80;               int upper = (c == 0xed) ? 0x9f : 0xbf;               if (c1 < lower || c1 > upper || c2 < 0x80 || c2 > 0xbf) {                 this.RaiseError("Invalid encoding");               }               c = ((c - 0xc0) << 12) | ((c1 - 0x80) << 6) | (c2 - 0x80);               this.sb.Append((char)c);             } else if (c >= 0xf0 && c <= 0xf4) {               int c1 = this.index < this.endPos ?                 ((int)this.bytes[this.index++]) & 0xff : -1;               int c2 = this.index < this.endPos ?                 ((int)this.bytes[this.index++]) & 0xff : -1;               int c3 = this.index < this.endPos ?                 ((int)this.bytes[this.index++]) & 0xff : -1;               int lower = (c == 0xf0) ? 0x90 : 0x80;               int upper = (c == 0xf4) ? 0x8f : 0xbf;               if (c1 < lower || c1 > upper || c2 < 0x80 || c2 > 0xbf ||                 c3 < 0x80 || c3 > 0xbf) {                 this.RaiseError("Invalid encoding");               }               c = ((c - 0xc0) << 12) | ((c1 - 0x80) << 12) | ((c2 - 0x80) <<                   6) | (c3 - 0x80);               if (c <= 0xffff) {                 { this.sb.Append((char)c);                 }               } else if (c <= 0x10ffff) {                 this.sb.Append((char)((((c - 0x10000) >> 10) & 0x3ff) | 0xd800));                 this.sb.Append((char)(((c - 0x10000) & 0x3ff) | 0xdc00));               }             } else {               this.RaiseError("Invalid encoding");             }             break;           }         }
Magic Number,PeterO.Cbor,CBORJson2,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORJson2.cs,NextJSONString,The following statement contains a magic number: switch (c) {           case '\\':             c = this.index < this.endPos ? ((int)this.bytes[this.index++]) &               0xff : -1;             switch (c) {               case '\\':               case '/':               case '\"':                 // Slash is now allowed to be escaped under RFC 8259                 this.sb.Append((char)c);                 break;               case 'b':                 this.sb.Append('\b');                 break;               case 'f':                 this.sb.Append('\f');                 break;               case 'n':                 this.sb.Append('\n');                 break;               case 'r':                 this.sb.Append('\r');                 break;               case 't':                 this.sb.Append('\t');                 break;               case 'u': { // Unicode escape                 c = 0;                 // Consists of 4 hex digits                 for (var i = 0; i < 4; ++i) {                   int ch = this.index < this.endPos ?                     ((int)this.bytes[this.index++]) & 0xff : -1;                   if (ch >= '0' && ch <= '9') {                     c <<= 4;                     c |= ch - '0';                   } else if (ch >= 'A' && ch <= 'F') {                     c <<= 4;                     c |= ch + 10 - 'A';                   } else if (ch >= 'a' && ch <= 'f') {                     c <<= 4;                     c |= ch + 10 - 'a';                   } else {                     this.RaiseError(                       "Invalid Unicode escaped character");                   }                 }                 if ((c & 0xf800) != 0xd800) {                   // Non-surrogate                   this.sb.Append((char)c);                 } else if ((c & 0xfc00) == 0xd800) {                   int ch = this.index < this.endPos ?                     ((int)this.bytes[this.index++]) & 0xff : -1;                   if (ch != '\\' || (this.index < this.endPos ?                       ((int)this.bytes[this.index++]) & 0xff : -1) != 'u') {                     this.RaiseError("Invalid escaped character");                   }                   var c2 = 0;                   for (var i = 0; i < 4; ++i) {                     ch = this.index < this.endPos ?                       ((int)this.bytes[this.index++]) & 0xff : -1;                     if (ch >= '0' && ch <= '9') {                       c2 <<= 4;                       c2 |= ch - '0';                     } else if (ch >= 'A' && ch <= 'F') {                       c2 <<= 4;                       c2 |= ch + 10 - 'A';                     } else if (ch >= 'a' && ch <= 'f') {                       c2 <<= 4;                       c2 |= ch + 10 - 'a';                     } else {                       this.RaiseError(                         "Invalid Unicode escaped character");                     }                   }                   if ((c2 & 0xfc00) != 0xdc00) {                     this.RaiseError("Unpaired surrogate code point");                   } else {                     this.sb.Append((char)c);                     this.sb.Append((char)c2);                   }                 } else {                   this.RaiseError("Unpaired surrogate code point");                 }                 break;               }               default: {                 this.RaiseError("Invalid escaped character");                 break;               }             }             break;           case 0x22: // double quote             return this.sb.ToString();           default: {             if (c <= 0x7f) {               this.sb.Append((char)c);             } else if (c >= 0xc2 && c <= 0xdf) {               int c1 = this.index < this.endPos ?                 ((int)this.bytes[this.index++]) & 0xff : -1;               if (c1 < 0x80 || c1 > 0xbf) {                 this.RaiseError("Invalid encoding");               }               c = ((c - 0xc0) << 6) | (c1 - 0x80);               this.sb.Append((char)c);             } else if (c >= 0xe0 && c <= 0xef) {               int c1 = this.index < this.endPos ?                 ((int)this.bytes[this.index++]) & 0xff : -1;               int c2 = this.index < this.endPos ?                 ((int)this.bytes[this.index++]) & 0xff : -1;               int lower = (c == 0xe0) ? 0xa0 : 0x80;               int upper = (c == 0xed) ? 0x9f : 0xbf;               if (c1 < lower || c1 > upper || c2 < 0x80 || c2 > 0xbf) {                 this.RaiseError("Invalid encoding");               }               c = ((c - 0xc0) << 12) | ((c1 - 0x80) << 6) | (c2 - 0x80);               this.sb.Append((char)c);             } else if (c >= 0xf0 && c <= 0xf4) {               int c1 = this.index < this.endPos ?                 ((int)this.bytes[this.index++]) & 0xff : -1;               int c2 = this.index < this.endPos ?                 ((int)this.bytes[this.index++]) & 0xff : -1;               int c3 = this.index < this.endPos ?                 ((int)this.bytes[this.index++]) & 0xff : -1;               int lower = (c == 0xf0) ? 0x90 : 0x80;               int upper = (c == 0xf4) ? 0x8f : 0xbf;               if (c1 < lower || c1 > upper || c2 < 0x80 || c2 > 0xbf ||                 c3 < 0x80 || c3 > 0xbf) {                 this.RaiseError("Invalid encoding");               }               c = ((c - 0xc0) << 12) | ((c1 - 0x80) << 12) | ((c2 - 0x80) <<                   6) | (c3 - 0x80);               if (c <= 0xffff) {                 { this.sb.Append((char)c);                 }               } else if (c <= 0x10ffff) {                 this.sb.Append((char)((((c - 0x10000) >> 10) & 0x3ff) | 0xd800));                 this.sb.Append((char)(((c - 0x10000) & 0x3ff) | 0xdc00));               }             } else {               this.RaiseError("Invalid encoding");             }             break;           }         }
Magic Number,PeterO.Cbor,CBORJson2,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORJson2.cs,NextJSONString,The following statement contains a magic number: switch (c) {           case '\\':             c = this.index < this.endPos ? ((int)this.bytes[this.index++]) &               0xff : -1;             switch (c) {               case '\\':               case '/':               case '\"':                 // Slash is now allowed to be escaped under RFC 8259                 this.sb.Append((char)c);                 break;               case 'b':                 this.sb.Append('\b');                 break;               case 'f':                 this.sb.Append('\f');                 break;               case 'n':                 this.sb.Append('\n');                 break;               case 'r':                 this.sb.Append('\r');                 break;               case 't':                 this.sb.Append('\t');                 break;               case 'u': { // Unicode escape                 c = 0;                 // Consists of 4 hex digits                 for (var i = 0; i < 4; ++i) {                   int ch = this.index < this.endPos ?                     ((int)this.bytes[this.index++]) & 0xff : -1;                   if (ch >= '0' && ch <= '9') {                     c <<= 4;                     c |= ch - '0';                   } else if (ch >= 'A' && ch <= 'F') {                     c <<= 4;                     c |= ch + 10 - 'A';                   } else if (ch >= 'a' && ch <= 'f') {                     c <<= 4;                     c |= ch + 10 - 'a';                   } else {                     this.RaiseError(                       "Invalid Unicode escaped character");                   }                 }                 if ((c & 0xf800) != 0xd800) {                   // Non-surrogate                   this.sb.Append((char)c);                 } else if ((c & 0xfc00) == 0xd800) {                   int ch = this.index < this.endPos ?                     ((int)this.bytes[this.index++]) & 0xff : -1;                   if (ch != '\\' || (this.index < this.endPos ?                       ((int)this.bytes[this.index++]) & 0xff : -1) != 'u') {                     this.RaiseError("Invalid escaped character");                   }                   var c2 = 0;                   for (var i = 0; i < 4; ++i) {                     ch = this.index < this.endPos ?                       ((int)this.bytes[this.index++]) & 0xff : -1;                     if (ch >= '0' && ch <= '9') {                       c2 <<= 4;                       c2 |= ch - '0';                     } else if (ch >= 'A' && ch <= 'F') {                       c2 <<= 4;                       c2 |= ch + 10 - 'A';                     } else if (ch >= 'a' && ch <= 'f') {                       c2 <<= 4;                       c2 |= ch + 10 - 'a';                     } else {                       this.RaiseError(                         "Invalid Unicode escaped character");                     }                   }                   if ((c2 & 0xfc00) != 0xdc00) {                     this.RaiseError("Unpaired surrogate code point");                   } else {                     this.sb.Append((char)c);                     this.sb.Append((char)c2);                   }                 } else {                   this.RaiseError("Unpaired surrogate code point");                 }                 break;               }               default: {                 this.RaiseError("Invalid escaped character");                 break;               }             }             break;           case 0x22: // double quote             return this.sb.ToString();           default: {             if (c <= 0x7f) {               this.sb.Append((char)c);             } else if (c >= 0xc2 && c <= 0xdf) {               int c1 = this.index < this.endPos ?                 ((int)this.bytes[this.index++]) & 0xff : -1;               if (c1 < 0x80 || c1 > 0xbf) {                 this.RaiseError("Invalid encoding");               }               c = ((c - 0xc0) << 6) | (c1 - 0x80);               this.sb.Append((char)c);             } else if (c >= 0xe0 && c <= 0xef) {               int c1 = this.index < this.endPos ?                 ((int)this.bytes[this.index++]) & 0xff : -1;               int c2 = this.index < this.endPos ?                 ((int)this.bytes[this.index++]) & 0xff : -1;               int lower = (c == 0xe0) ? 0xa0 : 0x80;               int upper = (c == 0xed) ? 0x9f : 0xbf;               if (c1 < lower || c1 > upper || c2 < 0x80 || c2 > 0xbf) {                 this.RaiseError("Invalid encoding");               }               c = ((c - 0xc0) << 12) | ((c1 - 0x80) << 6) | (c2 - 0x80);               this.sb.Append((char)c);             } else if (c >= 0xf0 && c <= 0xf4) {               int c1 = this.index < this.endPos ?                 ((int)this.bytes[this.index++]) & 0xff : -1;               int c2 = this.index < this.endPos ?                 ((int)this.bytes[this.index++]) & 0xff : -1;               int c3 = this.index < this.endPos ?                 ((int)this.bytes[this.index++]) & 0xff : -1;               int lower = (c == 0xf0) ? 0x90 : 0x80;               int upper = (c == 0xf4) ? 0x8f : 0xbf;               if (c1 < lower || c1 > upper || c2 < 0x80 || c2 > 0xbf ||                 c3 < 0x80 || c3 > 0xbf) {                 this.RaiseError("Invalid encoding");               }               c = ((c - 0xc0) << 12) | ((c1 - 0x80) << 12) | ((c2 - 0x80) <<                   6) | (c3 - 0x80);               if (c <= 0xffff) {                 { this.sb.Append((char)c);                 }               } else if (c <= 0x10ffff) {                 this.sb.Append((char)((((c - 0x10000) >> 10) & 0x3ff) | 0xd800));                 this.sb.Append((char)(((c - 0x10000) & 0x3ff) | 0xdc00));               }             } else {               this.RaiseError("Invalid encoding");             }             break;           }         }
Magic Number,PeterO.Cbor,CBORJson2,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORJson2.cs,NextJSONString,The following statement contains a magic number: switch (c) {           case '\\':             c = this.index < this.endPos ? ((int)this.bytes[this.index++]) &               0xff : -1;             switch (c) {               case '\\':               case '/':               case '\"':                 // Slash is now allowed to be escaped under RFC 8259                 this.sb.Append((char)c);                 break;               case 'b':                 this.sb.Append('\b');                 break;               case 'f':                 this.sb.Append('\f');                 break;               case 'n':                 this.sb.Append('\n');                 break;               case 'r':                 this.sb.Append('\r');                 break;               case 't':                 this.sb.Append('\t');                 break;               case 'u': { // Unicode escape                 c = 0;                 // Consists of 4 hex digits                 for (var i = 0; i < 4; ++i) {                   int ch = this.index < this.endPos ?                     ((int)this.bytes[this.index++]) & 0xff : -1;                   if (ch >= '0' && ch <= '9') {                     c <<= 4;                     c |= ch - '0';                   } else if (ch >= 'A' && ch <= 'F') {                     c <<= 4;                     c |= ch + 10 - 'A';                   } else if (ch >= 'a' && ch <= 'f') {                     c <<= 4;                     c |= ch + 10 - 'a';                   } else {                     this.RaiseError(                       "Invalid Unicode escaped character");                   }                 }                 if ((c & 0xf800) != 0xd800) {                   // Non-surrogate                   this.sb.Append((char)c);                 } else if ((c & 0xfc00) == 0xd800) {                   int ch = this.index < this.endPos ?                     ((int)this.bytes[this.index++]) & 0xff : -1;                   if (ch != '\\' || (this.index < this.endPos ?                       ((int)this.bytes[this.index++]) & 0xff : -1) != 'u') {                     this.RaiseError("Invalid escaped character");                   }                   var c2 = 0;                   for (var i = 0; i < 4; ++i) {                     ch = this.index < this.endPos ?                       ((int)this.bytes[this.index++]) & 0xff : -1;                     if (ch >= '0' && ch <= '9') {                       c2 <<= 4;                       c2 |= ch - '0';                     } else if (ch >= 'A' && ch <= 'F') {                       c2 <<= 4;                       c2 |= ch + 10 - 'A';                     } else if (ch >= 'a' && ch <= 'f') {                       c2 <<= 4;                       c2 |= ch + 10 - 'a';                     } else {                       this.RaiseError(                         "Invalid Unicode escaped character");                     }                   }                   if ((c2 & 0xfc00) != 0xdc00) {                     this.RaiseError("Unpaired surrogate code point");                   } else {                     this.sb.Append((char)c);                     this.sb.Append((char)c2);                   }                 } else {                   this.RaiseError("Unpaired surrogate code point");                 }                 break;               }               default: {                 this.RaiseError("Invalid escaped character");                 break;               }             }             break;           case 0x22: // double quote             return this.sb.ToString();           default: {             if (c <= 0x7f) {               this.sb.Append((char)c);             } else if (c >= 0xc2 && c <= 0xdf) {               int c1 = this.index < this.endPos ?                 ((int)this.bytes[this.index++]) & 0xff : -1;               if (c1 < 0x80 || c1 > 0xbf) {                 this.RaiseError("Invalid encoding");               }               c = ((c - 0xc0) << 6) | (c1 - 0x80);               this.sb.Append((char)c);             } else if (c >= 0xe0 && c <= 0xef) {               int c1 = this.index < this.endPos ?                 ((int)this.bytes[this.index++]) & 0xff : -1;               int c2 = this.index < this.endPos ?                 ((int)this.bytes[this.index++]) & 0xff : -1;               int lower = (c == 0xe0) ? 0xa0 : 0x80;               int upper = (c == 0xed) ? 0x9f : 0xbf;               if (c1 < lower || c1 > upper || c2 < 0x80 || c2 > 0xbf) {                 this.RaiseError("Invalid encoding");               }               c = ((c - 0xc0) << 12) | ((c1 - 0x80) << 6) | (c2 - 0x80);               this.sb.Append((char)c);             } else if (c >= 0xf0 && c <= 0xf4) {               int c1 = this.index < this.endPos ?                 ((int)this.bytes[this.index++]) & 0xff : -1;               int c2 = this.index < this.endPos ?                 ((int)this.bytes[this.index++]) & 0xff : -1;               int c3 = this.index < this.endPos ?                 ((int)this.bytes[this.index++]) & 0xff : -1;               int lower = (c == 0xf0) ? 0x90 : 0x80;               int upper = (c == 0xf4) ? 0x8f : 0xbf;               if (c1 < lower || c1 > upper || c2 < 0x80 || c2 > 0xbf ||                 c3 < 0x80 || c3 > 0xbf) {                 this.RaiseError("Invalid encoding");               }               c = ((c - 0xc0) << 12) | ((c1 - 0x80) << 12) | ((c2 - 0x80) <<                   6) | (c3 - 0x80);               if (c <= 0xffff) {                 { this.sb.Append((char)c);                 }               } else if (c <= 0x10ffff) {                 this.sb.Append((char)((((c - 0x10000) >> 10) & 0x3ff) | 0xd800));                 this.sb.Append((char)(((c - 0x10000) & 0x3ff) | 0xdc00));               }             } else {               this.RaiseError("Invalid encoding");             }             break;           }         }
Magic Number,PeterO.Cbor,CBORJson2,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORJson2.cs,NextJSONString,The following statement contains a magic number: switch (c) {           case '\\':             c = this.index < this.endPos ? ((int)this.bytes[this.index++]) &               0xff : -1;             switch (c) {               case '\\':               case '/':               case '\"':                 // Slash is now allowed to be escaped under RFC 8259                 this.sb.Append((char)c);                 break;               case 'b':                 this.sb.Append('\b');                 break;               case 'f':                 this.sb.Append('\f');                 break;               case 'n':                 this.sb.Append('\n');                 break;               case 'r':                 this.sb.Append('\r');                 break;               case 't':                 this.sb.Append('\t');                 break;               case 'u': { // Unicode escape                 c = 0;                 // Consists of 4 hex digits                 for (var i = 0; i < 4; ++i) {                   int ch = this.index < this.endPos ?                     ((int)this.bytes[this.index++]) & 0xff : -1;                   if (ch >= '0' && ch <= '9') {                     c <<= 4;                     c |= ch - '0';                   } else if (ch >= 'A' && ch <= 'F') {                     c <<= 4;                     c |= ch + 10 - 'A';                   } else if (ch >= 'a' && ch <= 'f') {                     c <<= 4;                     c |= ch + 10 - 'a';                   } else {                     this.RaiseError(                       "Invalid Unicode escaped character");                   }                 }                 if ((c & 0xf800) != 0xd800) {                   // Non-surrogate                   this.sb.Append((char)c);                 } else if ((c & 0xfc00) == 0xd800) {                   int ch = this.index < this.endPos ?                     ((int)this.bytes[this.index++]) & 0xff : -1;                   if (ch != '\\' || (this.index < this.endPos ?                       ((int)this.bytes[this.index++]) & 0xff : -1) != 'u') {                     this.RaiseError("Invalid escaped character");                   }                   var c2 = 0;                   for (var i = 0; i < 4; ++i) {                     ch = this.index < this.endPos ?                       ((int)this.bytes[this.index++]) & 0xff : -1;                     if (ch >= '0' && ch <= '9') {                       c2 <<= 4;                       c2 |= ch - '0';                     } else if (ch >= 'A' && ch <= 'F') {                       c2 <<= 4;                       c2 |= ch + 10 - 'A';                     } else if (ch >= 'a' && ch <= 'f') {                       c2 <<= 4;                       c2 |= ch + 10 - 'a';                     } else {                       this.RaiseError(                         "Invalid Unicode escaped character");                     }                   }                   if ((c2 & 0xfc00) != 0xdc00) {                     this.RaiseError("Unpaired surrogate code point");                   } else {                     this.sb.Append((char)c);                     this.sb.Append((char)c2);                   }                 } else {                   this.RaiseError("Unpaired surrogate code point");                 }                 break;               }               default: {                 this.RaiseError("Invalid escaped character");                 break;               }             }             break;           case 0x22: // double quote             return this.sb.ToString();           default: {             if (c <= 0x7f) {               this.sb.Append((char)c);             } else if (c >= 0xc2 && c <= 0xdf) {               int c1 = this.index < this.endPos ?                 ((int)this.bytes[this.index++]) & 0xff : -1;               if (c1 < 0x80 || c1 > 0xbf) {                 this.RaiseError("Invalid encoding");               }               c = ((c - 0xc0) << 6) | (c1 - 0x80);               this.sb.Append((char)c);             } else if (c >= 0xe0 && c <= 0xef) {               int c1 = this.index < this.endPos ?                 ((int)this.bytes[this.index++]) & 0xff : -1;               int c2 = this.index < this.endPos ?                 ((int)this.bytes[this.index++]) & 0xff : -1;               int lower = (c == 0xe0) ? 0xa0 : 0x80;               int upper = (c == 0xed) ? 0x9f : 0xbf;               if (c1 < lower || c1 > upper || c2 < 0x80 || c2 > 0xbf) {                 this.RaiseError("Invalid encoding");               }               c = ((c - 0xc0) << 12) | ((c1 - 0x80) << 6) | (c2 - 0x80);               this.sb.Append((char)c);             } else if (c >= 0xf0 && c <= 0xf4) {               int c1 = this.index < this.endPos ?                 ((int)this.bytes[this.index++]) & 0xff : -1;               int c2 = this.index < this.endPos ?                 ((int)this.bytes[this.index++]) & 0xff : -1;               int c3 = this.index < this.endPos ?                 ((int)this.bytes[this.index++]) & 0xff : -1;               int lower = (c == 0xf0) ? 0x90 : 0x80;               int upper = (c == 0xf4) ? 0x8f : 0xbf;               if (c1 < lower || c1 > upper || c2 < 0x80 || c2 > 0xbf ||                 c3 < 0x80 || c3 > 0xbf) {                 this.RaiseError("Invalid encoding");               }               c = ((c - 0xc0) << 12) | ((c1 - 0x80) << 12) | ((c2 - 0x80) <<                   6) | (c3 - 0x80);               if (c <= 0xffff) {                 { this.sb.Append((char)c);                 }               } else if (c <= 0x10ffff) {                 this.sb.Append((char)((((c - 0x10000) >> 10) & 0x3ff) | 0xd800));                 this.sb.Append((char)(((c - 0x10000) & 0x3ff) | 0xdc00));               }             } else {               this.RaiseError("Invalid encoding");             }             break;           }         }
Magic Number,PeterO.Cbor,CBORJson2,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORJson2.cs,NextJSONString,The following statement contains a magic number: switch (c) {           case '\\':             c = this.index < this.endPos ? ((int)this.bytes[this.index++]) &               0xff : -1;             switch (c) {               case '\\':               case '/':               case '\"':                 // Slash is now allowed to be escaped under RFC 8259                 this.sb.Append((char)c);                 break;               case 'b':                 this.sb.Append('\b');                 break;               case 'f':                 this.sb.Append('\f');                 break;               case 'n':                 this.sb.Append('\n');                 break;               case 'r':                 this.sb.Append('\r');                 break;               case 't':                 this.sb.Append('\t');                 break;               case 'u': { // Unicode escape                 c = 0;                 // Consists of 4 hex digits                 for (var i = 0; i < 4; ++i) {                   int ch = this.index < this.endPos ?                     ((int)this.bytes[this.index++]) & 0xff : -1;                   if (ch >= '0' && ch <= '9') {                     c <<= 4;                     c |= ch - '0';                   } else if (ch >= 'A' && ch <= 'F') {                     c <<= 4;                     c |= ch + 10 - 'A';                   } else if (ch >= 'a' && ch <= 'f') {                     c <<= 4;                     c |= ch + 10 - 'a';                   } else {                     this.RaiseError(                       "Invalid Unicode escaped character");                   }                 }                 if ((c & 0xf800) != 0xd800) {                   // Non-surrogate                   this.sb.Append((char)c);                 } else if ((c & 0xfc00) == 0xd800) {                   int ch = this.index < this.endPos ?                     ((int)this.bytes[this.index++]) & 0xff : -1;                   if (ch != '\\' || (this.index < this.endPos ?                       ((int)this.bytes[this.index++]) & 0xff : -1) != 'u') {                     this.RaiseError("Invalid escaped character");                   }                   var c2 = 0;                   for (var i = 0; i < 4; ++i) {                     ch = this.index < this.endPos ?                       ((int)this.bytes[this.index++]) & 0xff : -1;                     if (ch >= '0' && ch <= '9') {                       c2 <<= 4;                       c2 |= ch - '0';                     } else if (ch >= 'A' && ch <= 'F') {                       c2 <<= 4;                       c2 |= ch + 10 - 'A';                     } else if (ch >= 'a' && ch <= 'f') {                       c2 <<= 4;                       c2 |= ch + 10 - 'a';                     } else {                       this.RaiseError(                         "Invalid Unicode escaped character");                     }                   }                   if ((c2 & 0xfc00) != 0xdc00) {                     this.RaiseError("Unpaired surrogate code point");                   } else {                     this.sb.Append((char)c);                     this.sb.Append((char)c2);                   }                 } else {                   this.RaiseError("Unpaired surrogate code point");                 }                 break;               }               default: {                 this.RaiseError("Invalid escaped character");                 break;               }             }             break;           case 0x22: // double quote             return this.sb.ToString();           default: {             if (c <= 0x7f) {               this.sb.Append((char)c);             } else if (c >= 0xc2 && c <= 0xdf) {               int c1 = this.index < this.endPos ?                 ((int)this.bytes[this.index++]) & 0xff : -1;               if (c1 < 0x80 || c1 > 0xbf) {                 this.RaiseError("Invalid encoding");               }               c = ((c - 0xc0) << 6) | (c1 - 0x80);               this.sb.Append((char)c);             } else if (c >= 0xe0 && c <= 0xef) {               int c1 = this.index < this.endPos ?                 ((int)this.bytes[this.index++]) & 0xff : -1;               int c2 = this.index < this.endPos ?                 ((int)this.bytes[this.index++]) & 0xff : -1;               int lower = (c == 0xe0) ? 0xa0 : 0x80;               int upper = (c == 0xed) ? 0x9f : 0xbf;               if (c1 < lower || c1 > upper || c2 < 0x80 || c2 > 0xbf) {                 this.RaiseError("Invalid encoding");               }               c = ((c - 0xc0) << 12) | ((c1 - 0x80) << 6) | (c2 - 0x80);               this.sb.Append((char)c);             } else if (c >= 0xf0 && c <= 0xf4) {               int c1 = this.index < this.endPos ?                 ((int)this.bytes[this.index++]) & 0xff : -1;               int c2 = this.index < this.endPos ?                 ((int)this.bytes[this.index++]) & 0xff : -1;               int c3 = this.index < this.endPos ?                 ((int)this.bytes[this.index++]) & 0xff : -1;               int lower = (c == 0xf0) ? 0x90 : 0x80;               int upper = (c == 0xf4) ? 0x8f : 0xbf;               if (c1 < lower || c1 > upper || c2 < 0x80 || c2 > 0xbf ||                 c3 < 0x80 || c3 > 0xbf) {                 this.RaiseError("Invalid encoding");               }               c = ((c - 0xc0) << 12) | ((c1 - 0x80) << 12) | ((c2 - 0x80) <<                   6) | (c3 - 0x80);               if (c <= 0xffff) {                 { this.sb.Append((char)c);                 }               } else if (c <= 0x10ffff) {                 this.sb.Append((char)((((c - 0x10000) >> 10) & 0x3ff) | 0xd800));                 this.sb.Append((char)(((c - 0x10000) & 0x3ff) | 0xdc00));               }             } else {               this.RaiseError("Invalid encoding");             }             break;           }         }
Magic Number,PeterO.Cbor,CBORJson2,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORJson2.cs,NextJSONString,The following statement contains a magic number: switch (c) {           case '\\':             c = this.index < this.endPos ? ((int)this.bytes[this.index++]) &               0xff : -1;             switch (c) {               case '\\':               case '/':               case '\"':                 // Slash is now allowed to be escaped under RFC 8259                 this.sb.Append((char)c);                 break;               case 'b':                 this.sb.Append('\b');                 break;               case 'f':                 this.sb.Append('\f');                 break;               case 'n':                 this.sb.Append('\n');                 break;               case 'r':                 this.sb.Append('\r');                 break;               case 't':                 this.sb.Append('\t');                 break;               case 'u': { // Unicode escape                 c = 0;                 // Consists of 4 hex digits                 for (var i = 0; i < 4; ++i) {                   int ch = this.index < this.endPos ?                     ((int)this.bytes[this.index++]) & 0xff : -1;                   if (ch >= '0' && ch <= '9') {                     c <<= 4;                     c |= ch - '0';                   } else if (ch >= 'A' && ch <= 'F') {                     c <<= 4;                     c |= ch + 10 - 'A';                   } else if (ch >= 'a' && ch <= 'f') {                     c <<= 4;                     c |= ch + 10 - 'a';                   } else {                     this.RaiseError(                       "Invalid Unicode escaped character");                   }                 }                 if ((c & 0xf800) != 0xd800) {                   // Non-surrogate                   this.sb.Append((char)c);                 } else if ((c & 0xfc00) == 0xd800) {                   int ch = this.index < this.endPos ?                     ((int)this.bytes[this.index++]) & 0xff : -1;                   if (ch != '\\' || (this.index < this.endPos ?                       ((int)this.bytes[this.index++]) & 0xff : -1) != 'u') {                     this.RaiseError("Invalid escaped character");                   }                   var c2 = 0;                   for (var i = 0; i < 4; ++i) {                     ch = this.index < this.endPos ?                       ((int)this.bytes[this.index++]) & 0xff : -1;                     if (ch >= '0' && ch <= '9') {                       c2 <<= 4;                       c2 |= ch - '0';                     } else if (ch >= 'A' && ch <= 'F') {                       c2 <<= 4;                       c2 |= ch + 10 - 'A';                     } else if (ch >= 'a' && ch <= 'f') {                       c2 <<= 4;                       c2 |= ch + 10 - 'a';                     } else {                       this.RaiseError(                         "Invalid Unicode escaped character");                     }                   }                   if ((c2 & 0xfc00) != 0xdc00) {                     this.RaiseError("Unpaired surrogate code point");                   } else {                     this.sb.Append((char)c);                     this.sb.Append((char)c2);                   }                 } else {                   this.RaiseError("Unpaired surrogate code point");                 }                 break;               }               default: {                 this.RaiseError("Invalid escaped character");                 break;               }             }             break;           case 0x22: // double quote             return this.sb.ToString();           default: {             if (c <= 0x7f) {               this.sb.Append((char)c);             } else if (c >= 0xc2 && c <= 0xdf) {               int c1 = this.index < this.endPos ?                 ((int)this.bytes[this.index++]) & 0xff : -1;               if (c1 < 0x80 || c1 > 0xbf) {                 this.RaiseError("Invalid encoding");               }               c = ((c - 0xc0) << 6) | (c1 - 0x80);               this.sb.Append((char)c);             } else if (c >= 0xe0 && c <= 0xef) {               int c1 = this.index < this.endPos ?                 ((int)this.bytes[this.index++]) & 0xff : -1;               int c2 = this.index < this.endPos ?                 ((int)this.bytes[this.index++]) & 0xff : -1;               int lower = (c == 0xe0) ? 0xa0 : 0x80;               int upper = (c == 0xed) ? 0x9f : 0xbf;               if (c1 < lower || c1 > upper || c2 < 0x80 || c2 > 0xbf) {                 this.RaiseError("Invalid encoding");               }               c = ((c - 0xc0) << 12) | ((c1 - 0x80) << 6) | (c2 - 0x80);               this.sb.Append((char)c);             } else if (c >= 0xf0 && c <= 0xf4) {               int c1 = this.index < this.endPos ?                 ((int)this.bytes[this.index++]) & 0xff : -1;               int c2 = this.index < this.endPos ?                 ((int)this.bytes[this.index++]) & 0xff : -1;               int c3 = this.index < this.endPos ?                 ((int)this.bytes[this.index++]) & 0xff : -1;               int lower = (c == 0xf0) ? 0x90 : 0x80;               int upper = (c == 0xf4) ? 0x8f : 0xbf;               if (c1 < lower || c1 > upper || c2 < 0x80 || c2 > 0xbf ||                 c3 < 0x80 || c3 > 0xbf) {                 this.RaiseError("Invalid encoding");               }               c = ((c - 0xc0) << 12) | ((c1 - 0x80) << 12) | ((c2 - 0x80) <<                   6) | (c3 - 0x80);               if (c <= 0xffff) {                 { this.sb.Append((char)c);                 }               } else if (c <= 0x10ffff) {                 this.sb.Append((char)((((c - 0x10000) >> 10) & 0x3ff) | 0xd800));                 this.sb.Append((char)(((c - 0x10000) & 0x3ff) | 0xdc00));               }             } else {               this.RaiseError("Invalid encoding");             }             break;           }         }
Magic Number,PeterO.Cbor,CBORJson2,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORJson2.cs,NextJSONString,The following statement contains a magic number: switch (c) {           case '\\':             c = this.index < this.endPos ? ((int)this.bytes[this.index++]) &               0xff : -1;             switch (c) {               case '\\':               case '/':               case '\"':                 // Slash is now allowed to be escaped under RFC 8259                 this.sb.Append((char)c);                 break;               case 'b':                 this.sb.Append('\b');                 break;               case 'f':                 this.sb.Append('\f');                 break;               case 'n':                 this.sb.Append('\n');                 break;               case 'r':                 this.sb.Append('\r');                 break;               case 't':                 this.sb.Append('\t');                 break;               case 'u': { // Unicode escape                 c = 0;                 // Consists of 4 hex digits                 for (var i = 0; i < 4; ++i) {                   int ch = this.index < this.endPos ?                     ((int)this.bytes[this.index++]) & 0xff : -1;                   if (ch >= '0' && ch <= '9') {                     c <<= 4;                     c |= ch - '0';                   } else if (ch >= 'A' && ch <= 'F') {                     c <<= 4;                     c |= ch + 10 - 'A';                   } else if (ch >= 'a' && ch <= 'f') {                     c <<= 4;                     c |= ch + 10 - 'a';                   } else {                     this.RaiseError(                       "Invalid Unicode escaped character");                   }                 }                 if ((c & 0xf800) != 0xd800) {                   // Non-surrogate                   this.sb.Append((char)c);                 } else if ((c & 0xfc00) == 0xd800) {                   int ch = this.index < this.endPos ?                     ((int)this.bytes[this.index++]) & 0xff : -1;                   if (ch != '\\' || (this.index < this.endPos ?                       ((int)this.bytes[this.index++]) & 0xff : -1) != 'u') {                     this.RaiseError("Invalid escaped character");                   }                   var c2 = 0;                   for (var i = 0; i < 4; ++i) {                     ch = this.index < this.endPos ?                       ((int)this.bytes[this.index++]) & 0xff : -1;                     if (ch >= '0' && ch <= '9') {                       c2 <<= 4;                       c2 |= ch - '0';                     } else if (ch >= 'A' && ch <= 'F') {                       c2 <<= 4;                       c2 |= ch + 10 - 'A';                     } else if (ch >= 'a' && ch <= 'f') {                       c2 <<= 4;                       c2 |= ch + 10 - 'a';                     } else {                       this.RaiseError(                         "Invalid Unicode escaped character");                     }                   }                   if ((c2 & 0xfc00) != 0xdc00) {                     this.RaiseError("Unpaired surrogate code point");                   } else {                     this.sb.Append((char)c);                     this.sb.Append((char)c2);                   }                 } else {                   this.RaiseError("Unpaired surrogate code point");                 }                 break;               }               default: {                 this.RaiseError("Invalid escaped character");                 break;               }             }             break;           case 0x22: // double quote             return this.sb.ToString();           default: {             if (c <= 0x7f) {               this.sb.Append((char)c);             } else if (c >= 0xc2 && c <= 0xdf) {               int c1 = this.index < this.endPos ?                 ((int)this.bytes[this.index++]) & 0xff : -1;               if (c1 < 0x80 || c1 > 0xbf) {                 this.RaiseError("Invalid encoding");               }               c = ((c - 0xc0) << 6) | (c1 - 0x80);               this.sb.Append((char)c);             } else if (c >= 0xe0 && c <= 0xef) {               int c1 = this.index < this.endPos ?                 ((int)this.bytes[this.index++]) & 0xff : -1;               int c2 = this.index < this.endPos ?                 ((int)this.bytes[this.index++]) & 0xff : -1;               int lower = (c == 0xe0) ? 0xa0 : 0x80;               int upper = (c == 0xed) ? 0x9f : 0xbf;               if (c1 < lower || c1 > upper || c2 < 0x80 || c2 > 0xbf) {                 this.RaiseError("Invalid encoding");               }               c = ((c - 0xc0) << 12) | ((c1 - 0x80) << 6) | (c2 - 0x80);               this.sb.Append((char)c);             } else if (c >= 0xf0 && c <= 0xf4) {               int c1 = this.index < this.endPos ?                 ((int)this.bytes[this.index++]) & 0xff : -1;               int c2 = this.index < this.endPos ?                 ((int)this.bytes[this.index++]) & 0xff : -1;               int c3 = this.index < this.endPos ?                 ((int)this.bytes[this.index++]) & 0xff : -1;               int lower = (c == 0xf0) ? 0x90 : 0x80;               int upper = (c == 0xf4) ? 0x8f : 0xbf;               if (c1 < lower || c1 > upper || c2 < 0x80 || c2 > 0xbf ||                 c3 < 0x80 || c3 > 0xbf) {                 this.RaiseError("Invalid encoding");               }               c = ((c - 0xc0) << 12) | ((c1 - 0x80) << 12) | ((c2 - 0x80) <<                   6) | (c3 - 0x80);               if (c <= 0xffff) {                 { this.sb.Append((char)c);                 }               } else if (c <= 0x10ffff) {                 this.sb.Append((char)((((c - 0x10000) >> 10) & 0x3ff) | 0xd800));                 this.sb.Append((char)(((c - 0x10000) & 0x3ff) | 0xdc00));               }             } else {               this.RaiseError("Invalid encoding");             }             break;           }         }
Magic Number,PeterO.Cbor,CBORJson2,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORJson2.cs,NextJSONString,The following statement contains a magic number: switch (c) {           case '\\':             c = this.index < this.endPos ? ((int)this.bytes[this.index++]) &               0xff : -1;             switch (c) {               case '\\':               case '/':               case '\"':                 // Slash is now allowed to be escaped under RFC 8259                 this.sb.Append((char)c);                 break;               case 'b':                 this.sb.Append('\b');                 break;               case 'f':                 this.sb.Append('\f');                 break;               case 'n':                 this.sb.Append('\n');                 break;               case 'r':                 this.sb.Append('\r');                 break;               case 't':                 this.sb.Append('\t');                 break;               case 'u': { // Unicode escape                 c = 0;                 // Consists of 4 hex digits                 for (var i = 0; i < 4; ++i) {                   int ch = this.index < this.endPos ?                     ((int)this.bytes[this.index++]) & 0xff : -1;                   if (ch >= '0' && ch <= '9') {                     c <<= 4;                     c |= ch - '0';                   } else if (ch >= 'A' && ch <= 'F') {                     c <<= 4;                     c |= ch + 10 - 'A';                   } else if (ch >= 'a' && ch <= 'f') {                     c <<= 4;                     c |= ch + 10 - 'a';                   } else {                     this.RaiseError(                       "Invalid Unicode escaped character");                   }                 }                 if ((c & 0xf800) != 0xd800) {                   // Non-surrogate                   this.sb.Append((char)c);                 } else if ((c & 0xfc00) == 0xd800) {                   int ch = this.index < this.endPos ?                     ((int)this.bytes[this.index++]) & 0xff : -1;                   if (ch != '\\' || (this.index < this.endPos ?                       ((int)this.bytes[this.index++]) & 0xff : -1) != 'u') {                     this.RaiseError("Invalid escaped character");                   }                   var c2 = 0;                   for (var i = 0; i < 4; ++i) {                     ch = this.index < this.endPos ?                       ((int)this.bytes[this.index++]) & 0xff : -1;                     if (ch >= '0' && ch <= '9') {                       c2 <<= 4;                       c2 |= ch - '0';                     } else if (ch >= 'A' && ch <= 'F') {                       c2 <<= 4;                       c2 |= ch + 10 - 'A';                     } else if (ch >= 'a' && ch <= 'f') {                       c2 <<= 4;                       c2 |= ch + 10 - 'a';                     } else {                       this.RaiseError(                         "Invalid Unicode escaped character");                     }                   }                   if ((c2 & 0xfc00) != 0xdc00) {                     this.RaiseError("Unpaired surrogate code point");                   } else {                     this.sb.Append((char)c);                     this.sb.Append((char)c2);                   }                 } else {                   this.RaiseError("Unpaired surrogate code point");                 }                 break;               }               default: {                 this.RaiseError("Invalid escaped character");                 break;               }             }             break;           case 0x22: // double quote             return this.sb.ToString();           default: {             if (c <= 0x7f) {               this.sb.Append((char)c);             } else if (c >= 0xc2 && c <= 0xdf) {               int c1 = this.index < this.endPos ?                 ((int)this.bytes[this.index++]) & 0xff : -1;               if (c1 < 0x80 || c1 > 0xbf) {                 this.RaiseError("Invalid encoding");               }               c = ((c - 0xc0) << 6) | (c1 - 0x80);               this.sb.Append((char)c);             } else if (c >= 0xe0 && c <= 0xef) {               int c1 = this.index < this.endPos ?                 ((int)this.bytes[this.index++]) & 0xff : -1;               int c2 = this.index < this.endPos ?                 ((int)this.bytes[this.index++]) & 0xff : -1;               int lower = (c == 0xe0) ? 0xa0 : 0x80;               int upper = (c == 0xed) ? 0x9f : 0xbf;               if (c1 < lower || c1 > upper || c2 < 0x80 || c2 > 0xbf) {                 this.RaiseError("Invalid encoding");               }               c = ((c - 0xc0) << 12) | ((c1 - 0x80) << 6) | (c2 - 0x80);               this.sb.Append((char)c);             } else if (c >= 0xf0 && c <= 0xf4) {               int c1 = this.index < this.endPos ?                 ((int)this.bytes[this.index++]) & 0xff : -1;               int c2 = this.index < this.endPos ?                 ((int)this.bytes[this.index++]) & 0xff : -1;               int c3 = this.index < this.endPos ?                 ((int)this.bytes[this.index++]) & 0xff : -1;               int lower = (c == 0xf0) ? 0x90 : 0x80;               int upper = (c == 0xf4) ? 0x8f : 0xbf;               if (c1 < lower || c1 > upper || c2 < 0x80 || c2 > 0xbf ||                 c3 < 0x80 || c3 > 0xbf) {                 this.RaiseError("Invalid encoding");               }               c = ((c - 0xc0) << 12) | ((c1 - 0x80) << 12) | ((c2 - 0x80) <<                   6) | (c3 - 0x80);               if (c <= 0xffff) {                 { this.sb.Append((char)c);                 }               } else if (c <= 0x10ffff) {                 this.sb.Append((char)((((c - 0x10000) >> 10) & 0x3ff) | 0xd800));                 this.sb.Append((char)(((c - 0x10000) & 0x3ff) | 0xdc00));               }             } else {               this.RaiseError("Invalid encoding");             }             break;           }         }
Magic Number,PeterO.Cbor,CBORJson2,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORJson2.cs,NextJSONString,The following statement contains a magic number: switch (c) {           case '\\':             c = this.index < this.endPos ? ((int)this.bytes[this.index++]) &               0xff : -1;             switch (c) {               case '\\':               case '/':               case '\"':                 // Slash is now allowed to be escaped under RFC 8259                 this.sb.Append((char)c);                 break;               case 'b':                 this.sb.Append('\b');                 break;               case 'f':                 this.sb.Append('\f');                 break;               case 'n':                 this.sb.Append('\n');                 break;               case 'r':                 this.sb.Append('\r');                 break;               case 't':                 this.sb.Append('\t');                 break;               case 'u': { // Unicode escape                 c = 0;                 // Consists of 4 hex digits                 for (var i = 0; i < 4; ++i) {                   int ch = this.index < this.endPos ?                     ((int)this.bytes[this.index++]) & 0xff : -1;                   if (ch >= '0' && ch <= '9') {                     c <<= 4;                     c |= ch - '0';                   } else if (ch >= 'A' && ch <= 'F') {                     c <<= 4;                     c |= ch + 10 - 'A';                   } else if (ch >= 'a' && ch <= 'f') {                     c <<= 4;                     c |= ch + 10 - 'a';                   } else {                     this.RaiseError(                       "Invalid Unicode escaped character");                   }                 }                 if ((c & 0xf800) != 0xd800) {                   // Non-surrogate                   this.sb.Append((char)c);                 } else if ((c & 0xfc00) == 0xd800) {                   int ch = this.index < this.endPos ?                     ((int)this.bytes[this.index++]) & 0xff : -1;                   if (ch != '\\' || (this.index < this.endPos ?                       ((int)this.bytes[this.index++]) & 0xff : -1) != 'u') {                     this.RaiseError("Invalid escaped character");                   }                   var c2 = 0;                   for (var i = 0; i < 4; ++i) {                     ch = this.index < this.endPos ?                       ((int)this.bytes[this.index++]) & 0xff : -1;                     if (ch >= '0' && ch <= '9') {                       c2 <<= 4;                       c2 |= ch - '0';                     } else if (ch >= 'A' && ch <= 'F') {                       c2 <<= 4;                       c2 |= ch + 10 - 'A';                     } else if (ch >= 'a' && ch <= 'f') {                       c2 <<= 4;                       c2 |= ch + 10 - 'a';                     } else {                       this.RaiseError(                         "Invalid Unicode escaped character");                     }                   }                   if ((c2 & 0xfc00) != 0xdc00) {                     this.RaiseError("Unpaired surrogate code point");                   } else {                     this.sb.Append((char)c);                     this.sb.Append((char)c2);                   }                 } else {                   this.RaiseError("Unpaired surrogate code point");                 }                 break;               }               default: {                 this.RaiseError("Invalid escaped character");                 break;               }             }             break;           case 0x22: // double quote             return this.sb.ToString();           default: {             if (c <= 0x7f) {               this.sb.Append((char)c);             } else if (c >= 0xc2 && c <= 0xdf) {               int c1 = this.index < this.endPos ?                 ((int)this.bytes[this.index++]) & 0xff : -1;               if (c1 < 0x80 || c1 > 0xbf) {                 this.RaiseError("Invalid encoding");               }               c = ((c - 0xc0) << 6) | (c1 - 0x80);               this.sb.Append((char)c);             } else if (c >= 0xe0 && c <= 0xef) {               int c1 = this.index < this.endPos ?                 ((int)this.bytes[this.index++]) & 0xff : -1;               int c2 = this.index < this.endPos ?                 ((int)this.bytes[this.index++]) & 0xff : -1;               int lower = (c == 0xe0) ? 0xa0 : 0x80;               int upper = (c == 0xed) ? 0x9f : 0xbf;               if (c1 < lower || c1 > upper || c2 < 0x80 || c2 > 0xbf) {                 this.RaiseError("Invalid encoding");               }               c = ((c - 0xc0) << 12) | ((c1 - 0x80) << 6) | (c2 - 0x80);               this.sb.Append((char)c);             } else if (c >= 0xf0 && c <= 0xf4) {               int c1 = this.index < this.endPos ?                 ((int)this.bytes[this.index++]) & 0xff : -1;               int c2 = this.index < this.endPos ?                 ((int)this.bytes[this.index++]) & 0xff : -1;               int c3 = this.index < this.endPos ?                 ((int)this.bytes[this.index++]) & 0xff : -1;               int lower = (c == 0xf0) ? 0x90 : 0x80;               int upper = (c == 0xf4) ? 0x8f : 0xbf;               if (c1 < lower || c1 > upper || c2 < 0x80 || c2 > 0xbf ||                 c3 < 0x80 || c3 > 0xbf) {                 this.RaiseError("Invalid encoding");               }               c = ((c - 0xc0) << 12) | ((c1 - 0x80) << 12) | ((c2 - 0x80) <<                   6) | (c3 - 0x80);               if (c <= 0xffff) {                 { this.sb.Append((char)c);                 }               } else if (c <= 0x10ffff) {                 this.sb.Append((char)((((c - 0x10000) >> 10) & 0x3ff) | 0xd800));                 this.sb.Append((char)(((c - 0x10000) & 0x3ff) | 0xdc00));               }             } else {               this.RaiseError("Invalid encoding");             }             break;           }         }
Magic Number,PeterO.Cbor,CBORJson2,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORJson2.cs,NextJSONString,The following statement contains a magic number: switch (c) {           case '\\':             c = this.index < this.endPos ? ((int)this.bytes[this.index++]) &               0xff : -1;             switch (c) {               case '\\':               case '/':               case '\"':                 // Slash is now allowed to be escaped under RFC 8259                 this.sb.Append((char)c);                 break;               case 'b':                 this.sb.Append('\b');                 break;               case 'f':                 this.sb.Append('\f');                 break;               case 'n':                 this.sb.Append('\n');                 break;               case 'r':                 this.sb.Append('\r');                 break;               case 't':                 this.sb.Append('\t');                 break;               case 'u': { // Unicode escape                 c = 0;                 // Consists of 4 hex digits                 for (var i = 0; i < 4; ++i) {                   int ch = this.index < this.endPos ?                     ((int)this.bytes[this.index++]) & 0xff : -1;                   if (ch >= '0' && ch <= '9') {                     c <<= 4;                     c |= ch - '0';                   } else if (ch >= 'A' && ch <= 'F') {                     c <<= 4;                     c |= ch + 10 - 'A';                   } else if (ch >= 'a' && ch <= 'f') {                     c <<= 4;                     c |= ch + 10 - 'a';                   } else {                     this.RaiseError(                       "Invalid Unicode escaped character");                   }                 }                 if ((c & 0xf800) != 0xd800) {                   // Non-surrogate                   this.sb.Append((char)c);                 } else if ((c & 0xfc00) == 0xd800) {                   int ch = this.index < this.endPos ?                     ((int)this.bytes[this.index++]) & 0xff : -1;                   if (ch != '\\' || (this.index < this.endPos ?                       ((int)this.bytes[this.index++]) & 0xff : -1) != 'u') {                     this.RaiseError("Invalid escaped character");                   }                   var c2 = 0;                   for (var i = 0; i < 4; ++i) {                     ch = this.index < this.endPos ?                       ((int)this.bytes[this.index++]) & 0xff : -1;                     if (ch >= '0' && ch <= '9') {                       c2 <<= 4;                       c2 |= ch - '0';                     } else if (ch >= 'A' && ch <= 'F') {                       c2 <<= 4;                       c2 |= ch + 10 - 'A';                     } else if (ch >= 'a' && ch <= 'f') {                       c2 <<= 4;                       c2 |= ch + 10 - 'a';                     } else {                       this.RaiseError(                         "Invalid Unicode escaped character");                     }                   }                   if ((c2 & 0xfc00) != 0xdc00) {                     this.RaiseError("Unpaired surrogate code point");                   } else {                     this.sb.Append((char)c);                     this.sb.Append((char)c2);                   }                 } else {                   this.RaiseError("Unpaired surrogate code point");                 }                 break;               }               default: {                 this.RaiseError("Invalid escaped character");                 break;               }             }             break;           case 0x22: // double quote             return this.sb.ToString();           default: {             if (c <= 0x7f) {               this.sb.Append((char)c);             } else if (c >= 0xc2 && c <= 0xdf) {               int c1 = this.index < this.endPos ?                 ((int)this.bytes[this.index++]) & 0xff : -1;               if (c1 < 0x80 || c1 > 0xbf) {                 this.RaiseError("Invalid encoding");               }               c = ((c - 0xc0) << 6) | (c1 - 0x80);               this.sb.Append((char)c);             } else if (c >= 0xe0 && c <= 0xef) {               int c1 = this.index < this.endPos ?                 ((int)this.bytes[this.index++]) & 0xff : -1;               int c2 = this.index < this.endPos ?                 ((int)this.bytes[this.index++]) & 0xff : -1;               int lower = (c == 0xe0) ? 0xa0 : 0x80;               int upper = (c == 0xed) ? 0x9f : 0xbf;               if (c1 < lower || c1 > upper || c2 < 0x80 || c2 > 0xbf) {                 this.RaiseError("Invalid encoding");               }               c = ((c - 0xc0) << 12) | ((c1 - 0x80) << 6) | (c2 - 0x80);               this.sb.Append((char)c);             } else if (c >= 0xf0 && c <= 0xf4) {               int c1 = this.index < this.endPos ?                 ((int)this.bytes[this.index++]) & 0xff : -1;               int c2 = this.index < this.endPos ?                 ((int)this.bytes[this.index++]) & 0xff : -1;               int c3 = this.index < this.endPos ?                 ((int)this.bytes[this.index++]) & 0xff : -1;               int lower = (c == 0xf0) ? 0x90 : 0x80;               int upper = (c == 0xf4) ? 0x8f : 0xbf;               if (c1 < lower || c1 > upper || c2 < 0x80 || c2 > 0xbf ||                 c3 < 0x80 || c3 > 0xbf) {                 this.RaiseError("Invalid encoding");               }               c = ((c - 0xc0) << 12) | ((c1 - 0x80) << 12) | ((c2 - 0x80) <<                   6) | (c3 - 0x80);               if (c <= 0xffff) {                 { this.sb.Append((char)c);                 }               } else if (c <= 0x10ffff) {                 this.sb.Append((char)((((c - 0x10000) >> 10) & 0x3ff) | 0xd800));                 this.sb.Append((char)(((c - 0x10000) & 0x3ff) | 0xdc00));               }             } else {               this.RaiseError("Invalid encoding");             }             break;           }         }
Magic Number,PeterO.Cbor,CBORJson2,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORJson2.cs,NextJSONString,The following statement contains a magic number: switch (c) {           case '\\':             c = this.index < this.endPos ? ((int)this.bytes[this.index++]) &               0xff : -1;             switch (c) {               case '\\':               case '/':               case '\"':                 // Slash is now allowed to be escaped under RFC 8259                 this.sb.Append((char)c);                 break;               case 'b':                 this.sb.Append('\b');                 break;               case 'f':                 this.sb.Append('\f');                 break;               case 'n':                 this.sb.Append('\n');                 break;               case 'r':                 this.sb.Append('\r');                 break;               case 't':                 this.sb.Append('\t');                 break;               case 'u': { // Unicode escape                 c = 0;                 // Consists of 4 hex digits                 for (var i = 0; i < 4; ++i) {                   int ch = this.index < this.endPos ?                     ((int)this.bytes[this.index++]) & 0xff : -1;                   if (ch >= '0' && ch <= '9') {                     c <<= 4;                     c |= ch - '0';                   } else if (ch >= 'A' && ch <= 'F') {                     c <<= 4;                     c |= ch + 10 - 'A';                   } else if (ch >= 'a' && ch <= 'f') {                     c <<= 4;                     c |= ch + 10 - 'a';                   } else {                     this.RaiseError(                       "Invalid Unicode escaped character");                   }                 }                 if ((c & 0xf800) != 0xd800) {                   // Non-surrogate                   this.sb.Append((char)c);                 } else if ((c & 0xfc00) == 0xd800) {                   int ch = this.index < this.endPos ?                     ((int)this.bytes[this.index++]) & 0xff : -1;                   if (ch != '\\' || (this.index < this.endPos ?                       ((int)this.bytes[this.index++]) & 0xff : -1) != 'u') {                     this.RaiseError("Invalid escaped character");                   }                   var c2 = 0;                   for (var i = 0; i < 4; ++i) {                     ch = this.index < this.endPos ?                       ((int)this.bytes[this.index++]) & 0xff : -1;                     if (ch >= '0' && ch <= '9') {                       c2 <<= 4;                       c2 |= ch - '0';                     } else if (ch >= 'A' && ch <= 'F') {                       c2 <<= 4;                       c2 |= ch + 10 - 'A';                     } else if (ch >= 'a' && ch <= 'f') {                       c2 <<= 4;                       c2 |= ch + 10 - 'a';                     } else {                       this.RaiseError(                         "Invalid Unicode escaped character");                     }                   }                   if ((c2 & 0xfc00) != 0xdc00) {                     this.RaiseError("Unpaired surrogate code point");                   } else {                     this.sb.Append((char)c);                     this.sb.Append((char)c2);                   }                 } else {                   this.RaiseError("Unpaired surrogate code point");                 }                 break;               }               default: {                 this.RaiseError("Invalid escaped character");                 break;               }             }             break;           case 0x22: // double quote             return this.sb.ToString();           default: {             if (c <= 0x7f) {               this.sb.Append((char)c);             } else if (c >= 0xc2 && c <= 0xdf) {               int c1 = this.index < this.endPos ?                 ((int)this.bytes[this.index++]) & 0xff : -1;               if (c1 < 0x80 || c1 > 0xbf) {                 this.RaiseError("Invalid encoding");               }               c = ((c - 0xc0) << 6) | (c1 - 0x80);               this.sb.Append((char)c);             } else if (c >= 0xe0 && c <= 0xef) {               int c1 = this.index < this.endPos ?                 ((int)this.bytes[this.index++]) & 0xff : -1;               int c2 = this.index < this.endPos ?                 ((int)this.bytes[this.index++]) & 0xff : -1;               int lower = (c == 0xe0) ? 0xa0 : 0x80;               int upper = (c == 0xed) ? 0x9f : 0xbf;               if (c1 < lower || c1 > upper || c2 < 0x80 || c2 > 0xbf) {                 this.RaiseError("Invalid encoding");               }               c = ((c - 0xc0) << 12) | ((c1 - 0x80) << 6) | (c2 - 0x80);               this.sb.Append((char)c);             } else if (c >= 0xf0 && c <= 0xf4) {               int c1 = this.index < this.endPos ?                 ((int)this.bytes[this.index++]) & 0xff : -1;               int c2 = this.index < this.endPos ?                 ((int)this.bytes[this.index++]) & 0xff : -1;               int c3 = this.index < this.endPos ?                 ((int)this.bytes[this.index++]) & 0xff : -1;               int lower = (c == 0xf0) ? 0x90 : 0x80;               int upper = (c == 0xf4) ? 0x8f : 0xbf;               if (c1 < lower || c1 > upper || c2 < 0x80 || c2 > 0xbf ||                 c3 < 0x80 || c3 > 0xbf) {                 this.RaiseError("Invalid encoding");               }               c = ((c - 0xc0) << 12) | ((c1 - 0x80) << 12) | ((c2 - 0x80) <<                   6) | (c3 - 0x80);               if (c <= 0xffff) {                 { this.sb.Append((char)c);                 }               } else if (c <= 0x10ffff) {                 this.sb.Append((char)((((c - 0x10000) >> 10) & 0x3ff) | 0xd800));                 this.sb.Append((char)(((c - 0x10000) & 0x3ff) | 0xdc00));               }             } else {               this.RaiseError("Invalid encoding");             }             break;           }         }
Magic Number,PeterO.Cbor,CBORJson2,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORJson2.cs,NextJSONString,The following statement contains a magic number: switch (c) {           case '\\':             c = this.index < this.endPos ? ((int)this.bytes[this.index++]) &               0xff : -1;             switch (c) {               case '\\':               case '/':               case '\"':                 // Slash is now allowed to be escaped under RFC 8259                 this.sb.Append((char)c);                 break;               case 'b':                 this.sb.Append('\b');                 break;               case 'f':                 this.sb.Append('\f');                 break;               case 'n':                 this.sb.Append('\n');                 break;               case 'r':                 this.sb.Append('\r');                 break;               case 't':                 this.sb.Append('\t');                 break;               case 'u': { // Unicode escape                 c = 0;                 // Consists of 4 hex digits                 for (var i = 0; i < 4; ++i) {                   int ch = this.index < this.endPos ?                     ((int)this.bytes[this.index++]) & 0xff : -1;                   if (ch >= '0' && ch <= '9') {                     c <<= 4;                     c |= ch - '0';                   } else if (ch >= 'A' && ch <= 'F') {                     c <<= 4;                     c |= ch + 10 - 'A';                   } else if (ch >= 'a' && ch <= 'f') {                     c <<= 4;                     c |= ch + 10 - 'a';                   } else {                     this.RaiseError(                       "Invalid Unicode escaped character");                   }                 }                 if ((c & 0xf800) != 0xd800) {                   // Non-surrogate                   this.sb.Append((char)c);                 } else if ((c & 0xfc00) == 0xd800) {                   int ch = this.index < this.endPos ?                     ((int)this.bytes[this.index++]) & 0xff : -1;                   if (ch != '\\' || (this.index < this.endPos ?                       ((int)this.bytes[this.index++]) & 0xff : -1) != 'u') {                     this.RaiseError("Invalid escaped character");                   }                   var c2 = 0;                   for (var i = 0; i < 4; ++i) {                     ch = this.index < this.endPos ?                       ((int)this.bytes[this.index++]) & 0xff : -1;                     if (ch >= '0' && ch <= '9') {                       c2 <<= 4;                       c2 |= ch - '0';                     } else if (ch >= 'A' && ch <= 'F') {                       c2 <<= 4;                       c2 |= ch + 10 - 'A';                     } else if (ch >= 'a' && ch <= 'f') {                       c2 <<= 4;                       c2 |= ch + 10 - 'a';                     } else {                       this.RaiseError(                         "Invalid Unicode escaped character");                     }                   }                   if ((c2 & 0xfc00) != 0xdc00) {                     this.RaiseError("Unpaired surrogate code point");                   } else {                     this.sb.Append((char)c);                     this.sb.Append((char)c2);                   }                 } else {                   this.RaiseError("Unpaired surrogate code point");                 }                 break;               }               default: {                 this.RaiseError("Invalid escaped character");                 break;               }             }             break;           case 0x22: // double quote             return this.sb.ToString();           default: {             if (c <= 0x7f) {               this.sb.Append((char)c);             } else if (c >= 0xc2 && c <= 0xdf) {               int c1 = this.index < this.endPos ?                 ((int)this.bytes[this.index++]) & 0xff : -1;               if (c1 < 0x80 || c1 > 0xbf) {                 this.RaiseError("Invalid encoding");               }               c = ((c - 0xc0) << 6) | (c1 - 0x80);               this.sb.Append((char)c);             } else if (c >= 0xe0 && c <= 0xef) {               int c1 = this.index < this.endPos ?                 ((int)this.bytes[this.index++]) & 0xff : -1;               int c2 = this.index < this.endPos ?                 ((int)this.bytes[this.index++]) & 0xff : -1;               int lower = (c == 0xe0) ? 0xa0 : 0x80;               int upper = (c == 0xed) ? 0x9f : 0xbf;               if (c1 < lower || c1 > upper || c2 < 0x80 || c2 > 0xbf) {                 this.RaiseError("Invalid encoding");               }               c = ((c - 0xc0) << 12) | ((c1 - 0x80) << 6) | (c2 - 0x80);               this.sb.Append((char)c);             } else if (c >= 0xf0 && c <= 0xf4) {               int c1 = this.index < this.endPos ?                 ((int)this.bytes[this.index++]) & 0xff : -1;               int c2 = this.index < this.endPos ?                 ((int)this.bytes[this.index++]) & 0xff : -1;               int c3 = this.index < this.endPos ?                 ((int)this.bytes[this.index++]) & 0xff : -1;               int lower = (c == 0xf0) ? 0x90 : 0x80;               int upper = (c == 0xf4) ? 0x8f : 0xbf;               if (c1 < lower || c1 > upper || c2 < 0x80 || c2 > 0xbf ||                 c3 < 0x80 || c3 > 0xbf) {                 this.RaiseError("Invalid encoding");               }               c = ((c - 0xc0) << 12) | ((c1 - 0x80) << 12) | ((c2 - 0x80) <<                   6) | (c3 - 0x80);               if (c <= 0xffff) {                 { this.sb.Append((char)c);                 }               } else if (c <= 0x10ffff) {                 this.sb.Append((char)((((c - 0x10000) >> 10) & 0x3ff) | 0xd800));                 this.sb.Append((char)(((c - 0x10000) & 0x3ff) | 0xdc00));               }             } else {               this.RaiseError("Invalid encoding");             }             break;           }         }
Magic Number,PeterO.Cbor,CBORJson2,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORJson2.cs,NextJSONString,The following statement contains a magic number: switch (c) {           case '\\':             c = this.index < this.endPos ? ((int)this.bytes[this.index++]) &               0xff : -1;             switch (c) {               case '\\':               case '/':               case '\"':                 // Slash is now allowed to be escaped under RFC 8259                 this.sb.Append((char)c);                 break;               case 'b':                 this.sb.Append('\b');                 break;               case 'f':                 this.sb.Append('\f');                 break;               case 'n':                 this.sb.Append('\n');                 break;               case 'r':                 this.sb.Append('\r');                 break;               case 't':                 this.sb.Append('\t');                 break;               case 'u': { // Unicode escape                 c = 0;                 // Consists of 4 hex digits                 for (var i = 0; i < 4; ++i) {                   int ch = this.index < this.endPos ?                     ((int)this.bytes[this.index++]) & 0xff : -1;                   if (ch >= '0' && ch <= '9') {                     c <<= 4;                     c |= ch - '0';                   } else if (ch >= 'A' && ch <= 'F') {                     c <<= 4;                     c |= ch + 10 - 'A';                   } else if (ch >= 'a' && ch <= 'f') {                     c <<= 4;                     c |= ch + 10 - 'a';                   } else {                     this.RaiseError(                       "Invalid Unicode escaped character");                   }                 }                 if ((c & 0xf800) != 0xd800) {                   // Non-surrogate                   this.sb.Append((char)c);                 } else if ((c & 0xfc00) == 0xd800) {                   int ch = this.index < this.endPos ?                     ((int)this.bytes[this.index++]) & 0xff : -1;                   if (ch != '\\' || (this.index < this.endPos ?                       ((int)this.bytes[this.index++]) & 0xff : -1) != 'u') {                     this.RaiseError("Invalid escaped character");                   }                   var c2 = 0;                   for (var i = 0; i < 4; ++i) {                     ch = this.index < this.endPos ?                       ((int)this.bytes[this.index++]) & 0xff : -1;                     if (ch >= '0' && ch <= '9') {                       c2 <<= 4;                       c2 |= ch - '0';                     } else if (ch >= 'A' && ch <= 'F') {                       c2 <<= 4;                       c2 |= ch + 10 - 'A';                     } else if (ch >= 'a' && ch <= 'f') {                       c2 <<= 4;                       c2 |= ch + 10 - 'a';                     } else {                       this.RaiseError(                         "Invalid Unicode escaped character");                     }                   }                   if ((c2 & 0xfc00) != 0xdc00) {                     this.RaiseError("Unpaired surrogate code point");                   } else {                     this.sb.Append((char)c);                     this.sb.Append((char)c2);                   }                 } else {                   this.RaiseError("Unpaired surrogate code point");                 }                 break;               }               default: {                 this.RaiseError("Invalid escaped character");                 break;               }             }             break;           case 0x22: // double quote             return this.sb.ToString();           default: {             if (c <= 0x7f) {               this.sb.Append((char)c);             } else if (c >= 0xc2 && c <= 0xdf) {               int c1 = this.index < this.endPos ?                 ((int)this.bytes[this.index++]) & 0xff : -1;               if (c1 < 0x80 || c1 > 0xbf) {                 this.RaiseError("Invalid encoding");               }               c = ((c - 0xc0) << 6) | (c1 - 0x80);               this.sb.Append((char)c);             } else if (c >= 0xe0 && c <= 0xef) {               int c1 = this.index < this.endPos ?                 ((int)this.bytes[this.index++]) & 0xff : -1;               int c2 = this.index < this.endPos ?                 ((int)this.bytes[this.index++]) & 0xff : -1;               int lower = (c == 0xe0) ? 0xa0 : 0x80;               int upper = (c == 0xed) ? 0x9f : 0xbf;               if (c1 < lower || c1 > upper || c2 < 0x80 || c2 > 0xbf) {                 this.RaiseError("Invalid encoding");               }               c = ((c - 0xc0) << 12) | ((c1 - 0x80) << 6) | (c2 - 0x80);               this.sb.Append((char)c);             } else if (c >= 0xf0 && c <= 0xf4) {               int c1 = this.index < this.endPos ?                 ((int)this.bytes[this.index++]) & 0xff : -1;               int c2 = this.index < this.endPos ?                 ((int)this.bytes[this.index++]) & 0xff : -1;               int c3 = this.index < this.endPos ?                 ((int)this.bytes[this.index++]) & 0xff : -1;               int lower = (c == 0xf0) ? 0x90 : 0x80;               int upper = (c == 0xf4) ? 0x8f : 0xbf;               if (c1 < lower || c1 > upper || c2 < 0x80 || c2 > 0xbf ||                 c3 < 0x80 || c3 > 0xbf) {                 this.RaiseError("Invalid encoding");               }               c = ((c - 0xc0) << 12) | ((c1 - 0x80) << 12) | ((c2 - 0x80) <<                   6) | (c3 - 0x80);               if (c <= 0xffff) {                 { this.sb.Append((char)c);                 }               } else if (c <= 0x10ffff) {                 this.sb.Append((char)((((c - 0x10000) >> 10) & 0x3ff) | 0xd800));                 this.sb.Append((char)(((c - 0x10000) & 0x3ff) | 0xdc00));               }             } else {               this.RaiseError("Invalid encoding");             }             break;           }         }
Magic Number,PeterO.Cbor,CBORJson2,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORJson2.cs,NextJSONString,The following statement contains a magic number: switch (c) {           case '\\':             c = this.index < this.endPos ? ((int)this.bytes[this.index++]) &               0xff : -1;             switch (c) {               case '\\':               case '/':               case '\"':                 // Slash is now allowed to be escaped under RFC 8259                 this.sb.Append((char)c);                 break;               case 'b':                 this.sb.Append('\b');                 break;               case 'f':                 this.sb.Append('\f');                 break;               case 'n':                 this.sb.Append('\n');                 break;               case 'r':                 this.sb.Append('\r');                 break;               case 't':                 this.sb.Append('\t');                 break;               case 'u': { // Unicode escape                 c = 0;                 // Consists of 4 hex digits                 for (var i = 0; i < 4; ++i) {                   int ch = this.index < this.endPos ?                     ((int)this.bytes[this.index++]) & 0xff : -1;                   if (ch >= '0' && ch <= '9') {                     c <<= 4;                     c |= ch - '0';                   } else if (ch >= 'A' && ch <= 'F') {                     c <<= 4;                     c |= ch + 10 - 'A';                   } else if (ch >= 'a' && ch <= 'f') {                     c <<= 4;                     c |= ch + 10 - 'a';                   } else {                     this.RaiseError(                       "Invalid Unicode escaped character");                   }                 }                 if ((c & 0xf800) != 0xd800) {                   // Non-surrogate                   this.sb.Append((char)c);                 } else if ((c & 0xfc00) == 0xd800) {                   int ch = this.index < this.endPos ?                     ((int)this.bytes[this.index++]) & 0xff : -1;                   if (ch != '\\' || (this.index < this.endPos ?                       ((int)this.bytes[this.index++]) & 0xff : -1) != 'u') {                     this.RaiseError("Invalid escaped character");                   }                   var c2 = 0;                   for (var i = 0; i < 4; ++i) {                     ch = this.index < this.endPos ?                       ((int)this.bytes[this.index++]) & 0xff : -1;                     if (ch >= '0' && ch <= '9') {                       c2 <<= 4;                       c2 |= ch - '0';                     } else if (ch >= 'A' && ch <= 'F') {                       c2 <<= 4;                       c2 |= ch + 10 - 'A';                     } else if (ch >= 'a' && ch <= 'f') {                       c2 <<= 4;                       c2 |= ch + 10 - 'a';                     } else {                       this.RaiseError(                         "Invalid Unicode escaped character");                     }                   }                   if ((c2 & 0xfc00) != 0xdc00) {                     this.RaiseError("Unpaired surrogate code point");                   } else {                     this.sb.Append((char)c);                     this.sb.Append((char)c2);                   }                 } else {                   this.RaiseError("Unpaired surrogate code point");                 }                 break;               }               default: {                 this.RaiseError("Invalid escaped character");                 break;               }             }             break;           case 0x22: // double quote             return this.sb.ToString();           default: {             if (c <= 0x7f) {               this.sb.Append((char)c);             } else if (c >= 0xc2 && c <= 0xdf) {               int c1 = this.index < this.endPos ?                 ((int)this.bytes[this.index++]) & 0xff : -1;               if (c1 < 0x80 || c1 > 0xbf) {                 this.RaiseError("Invalid encoding");               }               c = ((c - 0xc0) << 6) | (c1 - 0x80);               this.sb.Append((char)c);             } else if (c >= 0xe0 && c <= 0xef) {               int c1 = this.index < this.endPos ?                 ((int)this.bytes[this.index++]) & 0xff : -1;               int c2 = this.index < this.endPos ?                 ((int)this.bytes[this.index++]) & 0xff : -1;               int lower = (c == 0xe0) ? 0xa0 : 0x80;               int upper = (c == 0xed) ? 0x9f : 0xbf;               if (c1 < lower || c1 > upper || c2 < 0x80 || c2 > 0xbf) {                 this.RaiseError("Invalid encoding");               }               c = ((c - 0xc0) << 12) | ((c1 - 0x80) << 6) | (c2 - 0x80);               this.sb.Append((char)c);             } else if (c >= 0xf0 && c <= 0xf4) {               int c1 = this.index < this.endPos ?                 ((int)this.bytes[this.index++]) & 0xff : -1;               int c2 = this.index < this.endPos ?                 ((int)this.bytes[this.index++]) & 0xff : -1;               int c3 = this.index < this.endPos ?                 ((int)this.bytes[this.index++]) & 0xff : -1;               int lower = (c == 0xf0) ? 0x90 : 0x80;               int upper = (c == 0xf4) ? 0x8f : 0xbf;               if (c1 < lower || c1 > upper || c2 < 0x80 || c2 > 0xbf ||                 c3 < 0x80 || c3 > 0xbf) {                 this.RaiseError("Invalid encoding");               }               c = ((c - 0xc0) << 12) | ((c1 - 0x80) << 12) | ((c2 - 0x80) <<                   6) | (c3 - 0x80);               if (c <= 0xffff) {                 { this.sb.Append((char)c);                 }               } else if (c <= 0x10ffff) {                 this.sb.Append((char)((((c - 0x10000) >> 10) & 0x3ff) | 0xd800));                 this.sb.Append((char)(((c - 0x10000) & 0x3ff) | 0xdc00));               }             } else {               this.RaiseError("Invalid encoding");             }             break;           }         }
Magic Number,PeterO.Cbor,CBORJson2,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORJson2.cs,NextJSONString,The following statement contains a magic number: switch (c) {           case '\\':             c = this.index < this.endPos ? ((int)this.bytes[this.index++]) &               0xff : -1;             switch (c) {               case '\\':               case '/':               case '\"':                 // Slash is now allowed to be escaped under RFC 8259                 this.sb.Append((char)c);                 break;               case 'b':                 this.sb.Append('\b');                 break;               case 'f':                 this.sb.Append('\f');                 break;               case 'n':                 this.sb.Append('\n');                 break;               case 'r':                 this.sb.Append('\r');                 break;               case 't':                 this.sb.Append('\t');                 break;               case 'u': { // Unicode escape                 c = 0;                 // Consists of 4 hex digits                 for (var i = 0; i < 4; ++i) {                   int ch = this.index < this.endPos ?                     ((int)this.bytes[this.index++]) & 0xff : -1;                   if (ch >= '0' && ch <= '9') {                     c <<= 4;                     c |= ch - '0';                   } else if (ch >= 'A' && ch <= 'F') {                     c <<= 4;                     c |= ch + 10 - 'A';                   } else if (ch >= 'a' && ch <= 'f') {                     c <<= 4;                     c |= ch + 10 - 'a';                   } else {                     this.RaiseError(                       "Invalid Unicode escaped character");                   }                 }                 if ((c & 0xf800) != 0xd800) {                   // Non-surrogate                   this.sb.Append((char)c);                 } else if ((c & 0xfc00) == 0xd800) {                   int ch = this.index < this.endPos ?                     ((int)this.bytes[this.index++]) & 0xff : -1;                   if (ch != '\\' || (this.index < this.endPos ?                       ((int)this.bytes[this.index++]) & 0xff : -1) != 'u') {                     this.RaiseError("Invalid escaped character");                   }                   var c2 = 0;                   for (var i = 0; i < 4; ++i) {                     ch = this.index < this.endPos ?                       ((int)this.bytes[this.index++]) & 0xff : -1;                     if (ch >= '0' && ch <= '9') {                       c2 <<= 4;                       c2 |= ch - '0';                     } else if (ch >= 'A' && ch <= 'F') {                       c2 <<= 4;                       c2 |= ch + 10 - 'A';                     } else if (ch >= 'a' && ch <= 'f') {                       c2 <<= 4;                       c2 |= ch + 10 - 'a';                     } else {                       this.RaiseError(                         "Invalid Unicode escaped character");                     }                   }                   if ((c2 & 0xfc00) != 0xdc00) {                     this.RaiseError("Unpaired surrogate code point");                   } else {                     this.sb.Append((char)c);                     this.sb.Append((char)c2);                   }                 } else {                   this.RaiseError("Unpaired surrogate code point");                 }                 break;               }               default: {                 this.RaiseError("Invalid escaped character");                 break;               }             }             break;           case 0x22: // double quote             return this.sb.ToString();           default: {             if (c <= 0x7f) {               this.sb.Append((char)c);             } else if (c >= 0xc2 && c <= 0xdf) {               int c1 = this.index < this.endPos ?                 ((int)this.bytes[this.index++]) & 0xff : -1;               if (c1 < 0x80 || c1 > 0xbf) {                 this.RaiseError("Invalid encoding");               }               c = ((c - 0xc0) << 6) | (c1 - 0x80);               this.sb.Append((char)c);             } else if (c >= 0xe0 && c <= 0xef) {               int c1 = this.index < this.endPos ?                 ((int)this.bytes[this.index++]) & 0xff : -1;               int c2 = this.index < this.endPos ?                 ((int)this.bytes[this.index++]) & 0xff : -1;               int lower = (c == 0xe0) ? 0xa0 : 0x80;               int upper = (c == 0xed) ? 0x9f : 0xbf;               if (c1 < lower || c1 > upper || c2 < 0x80 || c2 > 0xbf) {                 this.RaiseError("Invalid encoding");               }               c = ((c - 0xc0) << 12) | ((c1 - 0x80) << 6) | (c2 - 0x80);               this.sb.Append((char)c);             } else if (c >= 0xf0 && c <= 0xf4) {               int c1 = this.index < this.endPos ?                 ((int)this.bytes[this.index++]) & 0xff : -1;               int c2 = this.index < this.endPos ?                 ((int)this.bytes[this.index++]) & 0xff : -1;               int c3 = this.index < this.endPos ?                 ((int)this.bytes[this.index++]) & 0xff : -1;               int lower = (c == 0xf0) ? 0x90 : 0x80;               int upper = (c == 0xf4) ? 0x8f : 0xbf;               if (c1 < lower || c1 > upper || c2 < 0x80 || c2 > 0xbf ||                 c3 < 0x80 || c3 > 0xbf) {                 this.RaiseError("Invalid encoding");               }               c = ((c - 0xc0) << 12) | ((c1 - 0x80) << 12) | ((c2 - 0x80) <<                   6) | (c3 - 0x80);               if (c <= 0xffff) {                 { this.sb.Append((char)c);                 }               } else if (c <= 0x10ffff) {                 this.sb.Append((char)((((c - 0x10000) >> 10) & 0x3ff) | 0xd800));                 this.sb.Append((char)(((c - 0x10000) & 0x3ff) | 0xdc00));               }             } else {               this.RaiseError("Invalid encoding");             }             break;           }         }
Magic Number,PeterO.Cbor,CBORJson2,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORJson2.cs,NextJSONString,The following statement contains a magic number: switch (c) {           case '\\':             c = this.index < this.endPos ? ((int)this.bytes[this.index++]) &               0xff : -1;             switch (c) {               case '\\':               case '/':               case '\"':                 // Slash is now allowed to be escaped under RFC 8259                 this.sb.Append((char)c);                 break;               case 'b':                 this.sb.Append('\b');                 break;               case 'f':                 this.sb.Append('\f');                 break;               case 'n':                 this.sb.Append('\n');                 break;               case 'r':                 this.sb.Append('\r');                 break;               case 't':                 this.sb.Append('\t');                 break;               case 'u': { // Unicode escape                 c = 0;                 // Consists of 4 hex digits                 for (var i = 0; i < 4; ++i) {                   int ch = this.index < this.endPos ?                     ((int)this.bytes[this.index++]) & 0xff : -1;                   if (ch >= '0' && ch <= '9') {                     c <<= 4;                     c |= ch - '0';                   } else if (ch >= 'A' && ch <= 'F') {                     c <<= 4;                     c |= ch + 10 - 'A';                   } else if (ch >= 'a' && ch <= 'f') {                     c <<= 4;                     c |= ch + 10 - 'a';                   } else {                     this.RaiseError(                       "Invalid Unicode escaped character");                   }                 }                 if ((c & 0xf800) != 0xd800) {                   // Non-surrogate                   this.sb.Append((char)c);                 } else if ((c & 0xfc00) == 0xd800) {                   int ch = this.index < this.endPos ?                     ((int)this.bytes[this.index++]) & 0xff : -1;                   if (ch != '\\' || (this.index < this.endPos ?                       ((int)this.bytes[this.index++]) & 0xff : -1) != 'u') {                     this.RaiseError("Invalid escaped character");                   }                   var c2 = 0;                   for (var i = 0; i < 4; ++i) {                     ch = this.index < this.endPos ?                       ((int)this.bytes[this.index++]) & 0xff : -1;                     if (ch >= '0' && ch <= '9') {                       c2 <<= 4;                       c2 |= ch - '0';                     } else if (ch >= 'A' && ch <= 'F') {                       c2 <<= 4;                       c2 |= ch + 10 - 'A';                     } else if (ch >= 'a' && ch <= 'f') {                       c2 <<= 4;                       c2 |= ch + 10 - 'a';                     } else {                       this.RaiseError(                         "Invalid Unicode escaped character");                     }                   }                   if ((c2 & 0xfc00) != 0xdc00) {                     this.RaiseError("Unpaired surrogate code point");                   } else {                     this.sb.Append((char)c);                     this.sb.Append((char)c2);                   }                 } else {                   this.RaiseError("Unpaired surrogate code point");                 }                 break;               }               default: {                 this.RaiseError("Invalid escaped character");                 break;               }             }             break;           case 0x22: // double quote             return this.sb.ToString();           default: {             if (c <= 0x7f) {               this.sb.Append((char)c);             } else if (c >= 0xc2 && c <= 0xdf) {               int c1 = this.index < this.endPos ?                 ((int)this.bytes[this.index++]) & 0xff : -1;               if (c1 < 0x80 || c1 > 0xbf) {                 this.RaiseError("Invalid encoding");               }               c = ((c - 0xc0) << 6) | (c1 - 0x80);               this.sb.Append((char)c);             } else if (c >= 0xe0 && c <= 0xef) {               int c1 = this.index < this.endPos ?                 ((int)this.bytes[this.index++]) & 0xff : -1;               int c2 = this.index < this.endPos ?                 ((int)this.bytes[this.index++]) & 0xff : -1;               int lower = (c == 0xe0) ? 0xa0 : 0x80;               int upper = (c == 0xed) ? 0x9f : 0xbf;               if (c1 < lower || c1 > upper || c2 < 0x80 || c2 > 0xbf) {                 this.RaiseError("Invalid encoding");               }               c = ((c - 0xc0) << 12) | ((c1 - 0x80) << 6) | (c2 - 0x80);               this.sb.Append((char)c);             } else if (c >= 0xf0 && c <= 0xf4) {               int c1 = this.index < this.endPos ?                 ((int)this.bytes[this.index++]) & 0xff : -1;               int c2 = this.index < this.endPos ?                 ((int)this.bytes[this.index++]) & 0xff : -1;               int c3 = this.index < this.endPos ?                 ((int)this.bytes[this.index++]) & 0xff : -1;               int lower = (c == 0xf0) ? 0x90 : 0x80;               int upper = (c == 0xf4) ? 0x8f : 0xbf;               if (c1 < lower || c1 > upper || c2 < 0x80 || c2 > 0xbf ||                 c3 < 0x80 || c3 > 0xbf) {                 this.RaiseError("Invalid encoding");               }               c = ((c - 0xc0) << 12) | ((c1 - 0x80) << 12) | ((c2 - 0x80) <<                   6) | (c3 - 0x80);               if (c <= 0xffff) {                 { this.sb.Append((char)c);                 }               } else if (c <= 0x10ffff) {                 this.sb.Append((char)((((c - 0x10000) >> 10) & 0x3ff) | 0xd800));                 this.sb.Append((char)(((c - 0x10000) & 0x3ff) | 0xdc00));               }             } else {               this.RaiseError("Invalid encoding");             }             break;           }         }
Magic Number,PeterO.Cbor,CBORJson2,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORJson2.cs,NextJSONString,The following statement contains a magic number: switch (c) {           case '\\':             c = this.index < this.endPos ? ((int)this.bytes[this.index++]) &               0xff : -1;             switch (c) {               case '\\':               case '/':               case '\"':                 // Slash is now allowed to be escaped under RFC 8259                 this.sb.Append((char)c);                 break;               case 'b':                 this.sb.Append('\b');                 break;               case 'f':                 this.sb.Append('\f');                 break;               case 'n':                 this.sb.Append('\n');                 break;               case 'r':                 this.sb.Append('\r');                 break;               case 't':                 this.sb.Append('\t');                 break;               case 'u': { // Unicode escape                 c = 0;                 // Consists of 4 hex digits                 for (var i = 0; i < 4; ++i) {                   int ch = this.index < this.endPos ?                     ((int)this.bytes[this.index++]) & 0xff : -1;                   if (ch >= '0' && ch <= '9') {                     c <<= 4;                     c |= ch - '0';                   } else if (ch >= 'A' && ch <= 'F') {                     c <<= 4;                     c |= ch + 10 - 'A';                   } else if (ch >= 'a' && ch <= 'f') {                     c <<= 4;                     c |= ch + 10 - 'a';                   } else {                     this.RaiseError(                       "Invalid Unicode escaped character");                   }                 }                 if ((c & 0xf800) != 0xd800) {                   // Non-surrogate                   this.sb.Append((char)c);                 } else if ((c & 0xfc00) == 0xd800) {                   int ch = this.index < this.endPos ?                     ((int)this.bytes[this.index++]) & 0xff : -1;                   if (ch != '\\' || (this.index < this.endPos ?                       ((int)this.bytes[this.index++]) & 0xff : -1) != 'u') {                     this.RaiseError("Invalid escaped character");                   }                   var c2 = 0;                   for (var i = 0; i < 4; ++i) {                     ch = this.index < this.endPos ?                       ((int)this.bytes[this.index++]) & 0xff : -1;                     if (ch >= '0' && ch <= '9') {                       c2 <<= 4;                       c2 |= ch - '0';                     } else if (ch >= 'A' && ch <= 'F') {                       c2 <<= 4;                       c2 |= ch + 10 - 'A';                     } else if (ch >= 'a' && ch <= 'f') {                       c2 <<= 4;                       c2 |= ch + 10 - 'a';                     } else {                       this.RaiseError(                         "Invalid Unicode escaped character");                     }                   }                   if ((c2 & 0xfc00) != 0xdc00) {                     this.RaiseError("Unpaired surrogate code point");                   } else {                     this.sb.Append((char)c);                     this.sb.Append((char)c2);                   }                 } else {                   this.RaiseError("Unpaired surrogate code point");                 }                 break;               }               default: {                 this.RaiseError("Invalid escaped character");                 break;               }             }             break;           case 0x22: // double quote             return this.sb.ToString();           default: {             if (c <= 0x7f) {               this.sb.Append((char)c);             } else if (c >= 0xc2 && c <= 0xdf) {               int c1 = this.index < this.endPos ?                 ((int)this.bytes[this.index++]) & 0xff : -1;               if (c1 < 0x80 || c1 > 0xbf) {                 this.RaiseError("Invalid encoding");               }               c = ((c - 0xc0) << 6) | (c1 - 0x80);               this.sb.Append((char)c);             } else if (c >= 0xe0 && c <= 0xef) {               int c1 = this.index < this.endPos ?                 ((int)this.bytes[this.index++]) & 0xff : -1;               int c2 = this.index < this.endPos ?                 ((int)this.bytes[this.index++]) & 0xff : -1;               int lower = (c == 0xe0) ? 0xa0 : 0x80;               int upper = (c == 0xed) ? 0x9f : 0xbf;               if (c1 < lower || c1 > upper || c2 < 0x80 || c2 > 0xbf) {                 this.RaiseError("Invalid encoding");               }               c = ((c - 0xc0) << 12) | ((c1 - 0x80) << 6) | (c2 - 0x80);               this.sb.Append((char)c);             } else if (c >= 0xf0 && c <= 0xf4) {               int c1 = this.index < this.endPos ?                 ((int)this.bytes[this.index++]) & 0xff : -1;               int c2 = this.index < this.endPos ?                 ((int)this.bytes[this.index++]) & 0xff : -1;               int c3 = this.index < this.endPos ?                 ((int)this.bytes[this.index++]) & 0xff : -1;               int lower = (c == 0xf0) ? 0x90 : 0x80;               int upper = (c == 0xf4) ? 0x8f : 0xbf;               if (c1 < lower || c1 > upper || c2 < 0x80 || c2 > 0xbf ||                 c3 < 0x80 || c3 > 0xbf) {                 this.RaiseError("Invalid encoding");               }               c = ((c - 0xc0) << 12) | ((c1 - 0x80) << 12) | ((c2 - 0x80) <<                   6) | (c3 - 0x80);               if (c <= 0xffff) {                 { this.sb.Append((char)c);                 }               } else if (c <= 0x10ffff) {                 this.sb.Append((char)((((c - 0x10000) >> 10) & 0x3ff) | 0xd800));                 this.sb.Append((char)(((c - 0x10000) & 0x3ff) | 0xdc00));               }             } else {               this.RaiseError("Invalid encoding");             }             break;           }         }
Magic Number,PeterO.Cbor,CBORJson2,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORJson2.cs,NextJSONString,The following statement contains a magic number: switch (c) {           case '\\':             c = this.index < this.endPos ? ((int)this.bytes[this.index++]) &               0xff : -1;             switch (c) {               case '\\':               case '/':               case '\"':                 // Slash is now allowed to be escaped under RFC 8259                 this.sb.Append((char)c);                 break;               case 'b':                 this.sb.Append('\b');                 break;               case 'f':                 this.sb.Append('\f');                 break;               case 'n':                 this.sb.Append('\n');                 break;               case 'r':                 this.sb.Append('\r');                 break;               case 't':                 this.sb.Append('\t');                 break;               case 'u': { // Unicode escape                 c = 0;                 // Consists of 4 hex digits                 for (var i = 0; i < 4; ++i) {                   int ch = this.index < this.endPos ?                     ((int)this.bytes[this.index++]) & 0xff : -1;                   if (ch >= '0' && ch <= '9') {                     c <<= 4;                     c |= ch - '0';                   } else if (ch >= 'A' && ch <= 'F') {                     c <<= 4;                     c |= ch + 10 - 'A';                   } else if (ch >= 'a' && ch <= 'f') {                     c <<= 4;                     c |= ch + 10 - 'a';                   } else {                     this.RaiseError(                       "Invalid Unicode escaped character");                   }                 }                 if ((c & 0xf800) != 0xd800) {                   // Non-surrogate                   this.sb.Append((char)c);                 } else if ((c & 0xfc00) == 0xd800) {                   int ch = this.index < this.endPos ?                     ((int)this.bytes[this.index++]) & 0xff : -1;                   if (ch != '\\' || (this.index < this.endPos ?                       ((int)this.bytes[this.index++]) & 0xff : -1) != 'u') {                     this.RaiseError("Invalid escaped character");                   }                   var c2 = 0;                   for (var i = 0; i < 4; ++i) {                     ch = this.index < this.endPos ?                       ((int)this.bytes[this.index++]) & 0xff : -1;                     if (ch >= '0' && ch <= '9') {                       c2 <<= 4;                       c2 |= ch - '0';                     } else if (ch >= 'A' && ch <= 'F') {                       c2 <<= 4;                       c2 |= ch + 10 - 'A';                     } else if (ch >= 'a' && ch <= 'f') {                       c2 <<= 4;                       c2 |= ch + 10 - 'a';                     } else {                       this.RaiseError(                         "Invalid Unicode escaped character");                     }                   }                   if ((c2 & 0xfc00) != 0xdc00) {                     this.RaiseError("Unpaired surrogate code point");                   } else {                     this.sb.Append((char)c);                     this.sb.Append((char)c2);                   }                 } else {                   this.RaiseError("Unpaired surrogate code point");                 }                 break;               }               default: {                 this.RaiseError("Invalid escaped character");                 break;               }             }             break;           case 0x22: // double quote             return this.sb.ToString();           default: {             if (c <= 0x7f) {               this.sb.Append((char)c);             } else if (c >= 0xc2 && c <= 0xdf) {               int c1 = this.index < this.endPos ?                 ((int)this.bytes[this.index++]) & 0xff : -1;               if (c1 < 0x80 || c1 > 0xbf) {                 this.RaiseError("Invalid encoding");               }               c = ((c - 0xc0) << 6) | (c1 - 0x80);               this.sb.Append((char)c);             } else if (c >= 0xe0 && c <= 0xef) {               int c1 = this.index < this.endPos ?                 ((int)this.bytes[this.index++]) & 0xff : -1;               int c2 = this.index < this.endPos ?                 ((int)this.bytes[this.index++]) & 0xff : -1;               int lower = (c == 0xe0) ? 0xa0 : 0x80;               int upper = (c == 0xed) ? 0x9f : 0xbf;               if (c1 < lower || c1 > upper || c2 < 0x80 || c2 > 0xbf) {                 this.RaiseError("Invalid encoding");               }               c = ((c - 0xc0) << 12) | ((c1 - 0x80) << 6) | (c2 - 0x80);               this.sb.Append((char)c);             } else if (c >= 0xf0 && c <= 0xf4) {               int c1 = this.index < this.endPos ?                 ((int)this.bytes[this.index++]) & 0xff : -1;               int c2 = this.index < this.endPos ?                 ((int)this.bytes[this.index++]) & 0xff : -1;               int c3 = this.index < this.endPos ?                 ((int)this.bytes[this.index++]) & 0xff : -1;               int lower = (c == 0xf0) ? 0x90 : 0x80;               int upper = (c == 0xf4) ? 0x8f : 0xbf;               if (c1 < lower || c1 > upper || c2 < 0x80 || c2 > 0xbf ||                 c3 < 0x80 || c3 > 0xbf) {                 this.RaiseError("Invalid encoding");               }               c = ((c - 0xc0) << 12) | ((c1 - 0x80) << 12) | ((c2 - 0x80) <<                   6) | (c3 - 0x80);               if (c <= 0xffff) {                 { this.sb.Append((char)c);                 }               } else if (c <= 0x10ffff) {                 this.sb.Append((char)((((c - 0x10000) >> 10) & 0x3ff) | 0xd800));                 this.sb.Append((char)(((c - 0x10000) & 0x3ff) | 0xdc00));               }             } else {               this.RaiseError("Invalid encoding");             }             break;           }         }
Magic Number,PeterO.Cbor,CBORJson2,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORJson2.cs,NextJSONNegativeNumber,The following statement contains a magic number: numberEndIndex - numberStartIndex == 2 && cstart != '0'
Magic Number,PeterO.Cbor,CBORJson2,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORJson2.cs,NextJSONNonnegativeNumber,The following statement contains a magic number: string errstr = (str.Length <= 100) ? str : (str.Substring(0'                 100) + "...");
Magic Number,PeterO.Cbor,CBORJson2,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORJson2.cs,NextJSONNonnegativeNumber,The following statement contains a magic number: string errstr = (str.Length <= 100) ? str : (str.Substring(0'                 100) + "...");
Magic Number,PeterO.Cbor,CBORJson2,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORJson2.cs,NextJSONValue,The following statement contains a magic number: switch (c) {         case '"': {           // Parse a string           // The tokenizer already checked the string for invalid           // surrogate pairs' so just call the CBORObject           // constructor directly           obj = CBORObject.FromRaw(this.NextJSONString());           nextChar[0] = this.SkipWhitespaceJSON();           return obj;         }         case '{': {           // Parse an object           obj = this.ParseJSONObject(depth + 1);           nextChar[0] = this.SkipWhitespaceJSON();           return obj;         }         case '[': {           // Parse an array           obj = this.ParseJSONArray(depth + 1);           nextChar[0] = this.SkipWhitespaceJSON();           return obj;         }         case 't': {           // Parse true           if (this.endPos - this.index <= 2 ||             this.bytes[this.index] != (byte)0x72 ||             this.bytes[this.index + 1] != (byte)0x75 ||             this.bytes[this.index + 2] != (byte)0x65) {             this.RaiseError("Value can't be parsed.");           }           this.index += 3;           nextChar[0] = this.SkipWhitespaceJSON();           return CBORObject.True;         }         case 'f': {           // Parse false           if (this.endPos - this.index <= 3 ||             this.bytes[this.index] != (byte)0x61 ||             this.bytes[this.index + 1] != (byte)0x6c ||             this.bytes[this.index + 2] != (byte)0x73 ||             this.bytes[this.index + 3] != (byte)0x65) {             this.RaiseError("Value can't be parsed.");           }           this.index += 4;           nextChar[0] = this.SkipWhitespaceJSON();           return CBORObject.False;         }         case 'n': {           // Parse null           if (this.endPos - this.index <= 2 ||             this.bytes[this.index] != (byte)0x75 ||             this.bytes[this.index + 1] != (byte)0x6c ||             this.bytes[this.index + 2] != (byte)0x6c) {             this.RaiseError("Value can't be parsed.");           }           this.index += 3;           nextChar[0] = this.SkipWhitespaceJSON();           return CBORObject.Null;         }         case '-': {           // Parse a negative number           return this.NextJSONNegativeNumber(nextChar);         }         case '0':         case '1':         case '2':         case '3':         case '4':         case '5':         case '6':         case '7':         case '8':         case '9': {           // Parse a nonnegative number           return this.NextJSONNonnegativeNumber(c' nextChar);         }         default:           this.RaiseError("Value can't be parsed.");           break;       }
Magic Number,PeterO.Cbor,CBORJson2,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORJson2.cs,NextJSONValue,The following statement contains a magic number: switch (c) {         case '"': {           // Parse a string           // The tokenizer already checked the string for invalid           // surrogate pairs' so just call the CBORObject           // constructor directly           obj = CBORObject.FromRaw(this.NextJSONString());           nextChar[0] = this.SkipWhitespaceJSON();           return obj;         }         case '{': {           // Parse an object           obj = this.ParseJSONObject(depth + 1);           nextChar[0] = this.SkipWhitespaceJSON();           return obj;         }         case '[': {           // Parse an array           obj = this.ParseJSONArray(depth + 1);           nextChar[0] = this.SkipWhitespaceJSON();           return obj;         }         case 't': {           // Parse true           if (this.endPos - this.index <= 2 ||             this.bytes[this.index] != (byte)0x72 ||             this.bytes[this.index + 1] != (byte)0x75 ||             this.bytes[this.index + 2] != (byte)0x65) {             this.RaiseError("Value can't be parsed.");           }           this.index += 3;           nextChar[0] = this.SkipWhitespaceJSON();           return CBORObject.True;         }         case 'f': {           // Parse false           if (this.endPos - this.index <= 3 ||             this.bytes[this.index] != (byte)0x61 ||             this.bytes[this.index + 1] != (byte)0x6c ||             this.bytes[this.index + 2] != (byte)0x73 ||             this.bytes[this.index + 3] != (byte)0x65) {             this.RaiseError("Value can't be parsed.");           }           this.index += 4;           nextChar[0] = this.SkipWhitespaceJSON();           return CBORObject.False;         }         case 'n': {           // Parse null           if (this.endPos - this.index <= 2 ||             this.bytes[this.index] != (byte)0x75 ||             this.bytes[this.index + 1] != (byte)0x6c ||             this.bytes[this.index + 2] != (byte)0x6c) {             this.RaiseError("Value can't be parsed.");           }           this.index += 3;           nextChar[0] = this.SkipWhitespaceJSON();           return CBORObject.Null;         }         case '-': {           // Parse a negative number           return this.NextJSONNegativeNumber(nextChar);         }         case '0':         case '1':         case '2':         case '3':         case '4':         case '5':         case '6':         case '7':         case '8':         case '9': {           // Parse a nonnegative number           return this.NextJSONNonnegativeNumber(c' nextChar);         }         default:           this.RaiseError("Value can't be parsed.");           break;       }
Magic Number,PeterO.Cbor,CBORJson2,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORJson2.cs,NextJSONValue,The following statement contains a magic number: switch (c) {         case '"': {           // Parse a string           // The tokenizer already checked the string for invalid           // surrogate pairs' so just call the CBORObject           // constructor directly           obj = CBORObject.FromRaw(this.NextJSONString());           nextChar[0] = this.SkipWhitespaceJSON();           return obj;         }         case '{': {           // Parse an object           obj = this.ParseJSONObject(depth + 1);           nextChar[0] = this.SkipWhitespaceJSON();           return obj;         }         case '[': {           // Parse an array           obj = this.ParseJSONArray(depth + 1);           nextChar[0] = this.SkipWhitespaceJSON();           return obj;         }         case 't': {           // Parse true           if (this.endPos - this.index <= 2 ||             this.bytes[this.index] != (byte)0x72 ||             this.bytes[this.index + 1] != (byte)0x75 ||             this.bytes[this.index + 2] != (byte)0x65) {             this.RaiseError("Value can't be parsed.");           }           this.index += 3;           nextChar[0] = this.SkipWhitespaceJSON();           return CBORObject.True;         }         case 'f': {           // Parse false           if (this.endPos - this.index <= 3 ||             this.bytes[this.index] != (byte)0x61 ||             this.bytes[this.index + 1] != (byte)0x6c ||             this.bytes[this.index + 2] != (byte)0x73 ||             this.bytes[this.index + 3] != (byte)0x65) {             this.RaiseError("Value can't be parsed.");           }           this.index += 4;           nextChar[0] = this.SkipWhitespaceJSON();           return CBORObject.False;         }         case 'n': {           // Parse null           if (this.endPos - this.index <= 2 ||             this.bytes[this.index] != (byte)0x75 ||             this.bytes[this.index + 1] != (byte)0x6c ||             this.bytes[this.index + 2] != (byte)0x6c) {             this.RaiseError("Value can't be parsed.");           }           this.index += 3;           nextChar[0] = this.SkipWhitespaceJSON();           return CBORObject.Null;         }         case '-': {           // Parse a negative number           return this.NextJSONNegativeNumber(nextChar);         }         case '0':         case '1':         case '2':         case '3':         case '4':         case '5':         case '6':         case '7':         case '8':         case '9': {           // Parse a nonnegative number           return this.NextJSONNonnegativeNumber(c' nextChar);         }         default:           this.RaiseError("Value can't be parsed.");           break;       }
Magic Number,PeterO.Cbor,CBORJson2,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORJson2.cs,NextJSONValue,The following statement contains a magic number: switch (c) {         case '"': {           // Parse a string           // The tokenizer already checked the string for invalid           // surrogate pairs' so just call the CBORObject           // constructor directly           obj = CBORObject.FromRaw(this.NextJSONString());           nextChar[0] = this.SkipWhitespaceJSON();           return obj;         }         case '{': {           // Parse an object           obj = this.ParseJSONObject(depth + 1);           nextChar[0] = this.SkipWhitespaceJSON();           return obj;         }         case '[': {           // Parse an array           obj = this.ParseJSONArray(depth + 1);           nextChar[0] = this.SkipWhitespaceJSON();           return obj;         }         case 't': {           // Parse true           if (this.endPos - this.index <= 2 ||             this.bytes[this.index] != (byte)0x72 ||             this.bytes[this.index + 1] != (byte)0x75 ||             this.bytes[this.index + 2] != (byte)0x65) {             this.RaiseError("Value can't be parsed.");           }           this.index += 3;           nextChar[0] = this.SkipWhitespaceJSON();           return CBORObject.True;         }         case 'f': {           // Parse false           if (this.endPos - this.index <= 3 ||             this.bytes[this.index] != (byte)0x61 ||             this.bytes[this.index + 1] != (byte)0x6c ||             this.bytes[this.index + 2] != (byte)0x73 ||             this.bytes[this.index + 3] != (byte)0x65) {             this.RaiseError("Value can't be parsed.");           }           this.index += 4;           nextChar[0] = this.SkipWhitespaceJSON();           return CBORObject.False;         }         case 'n': {           // Parse null           if (this.endPos - this.index <= 2 ||             this.bytes[this.index] != (byte)0x75 ||             this.bytes[this.index + 1] != (byte)0x6c ||             this.bytes[this.index + 2] != (byte)0x6c) {             this.RaiseError("Value can't be parsed.");           }           this.index += 3;           nextChar[0] = this.SkipWhitespaceJSON();           return CBORObject.Null;         }         case '-': {           // Parse a negative number           return this.NextJSONNegativeNumber(nextChar);         }         case '0':         case '1':         case '2':         case '3':         case '4':         case '5':         case '6':         case '7':         case '8':         case '9': {           // Parse a nonnegative number           return this.NextJSONNonnegativeNumber(c' nextChar);         }         default:           this.RaiseError("Value can't be parsed.");           break;       }
Magic Number,PeterO.Cbor,CBORJson2,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORJson2.cs,NextJSONValue,The following statement contains a magic number: switch (c) {         case '"': {           // Parse a string           // The tokenizer already checked the string for invalid           // surrogate pairs' so just call the CBORObject           // constructor directly           obj = CBORObject.FromRaw(this.NextJSONString());           nextChar[0] = this.SkipWhitespaceJSON();           return obj;         }         case '{': {           // Parse an object           obj = this.ParseJSONObject(depth + 1);           nextChar[0] = this.SkipWhitespaceJSON();           return obj;         }         case '[': {           // Parse an array           obj = this.ParseJSONArray(depth + 1);           nextChar[0] = this.SkipWhitespaceJSON();           return obj;         }         case 't': {           // Parse true           if (this.endPos - this.index <= 2 ||             this.bytes[this.index] != (byte)0x72 ||             this.bytes[this.index + 1] != (byte)0x75 ||             this.bytes[this.index + 2] != (byte)0x65) {             this.RaiseError("Value can't be parsed.");           }           this.index += 3;           nextChar[0] = this.SkipWhitespaceJSON();           return CBORObject.True;         }         case 'f': {           // Parse false           if (this.endPos - this.index <= 3 ||             this.bytes[this.index] != (byte)0x61 ||             this.bytes[this.index + 1] != (byte)0x6c ||             this.bytes[this.index + 2] != (byte)0x73 ||             this.bytes[this.index + 3] != (byte)0x65) {             this.RaiseError("Value can't be parsed.");           }           this.index += 4;           nextChar[0] = this.SkipWhitespaceJSON();           return CBORObject.False;         }         case 'n': {           // Parse null           if (this.endPos - this.index <= 2 ||             this.bytes[this.index] != (byte)0x75 ||             this.bytes[this.index + 1] != (byte)0x6c ||             this.bytes[this.index + 2] != (byte)0x6c) {             this.RaiseError("Value can't be parsed.");           }           this.index += 3;           nextChar[0] = this.SkipWhitespaceJSON();           return CBORObject.Null;         }         case '-': {           // Parse a negative number           return this.NextJSONNegativeNumber(nextChar);         }         case '0':         case '1':         case '2':         case '3':         case '4':         case '5':         case '6':         case '7':         case '8':         case '9': {           // Parse a nonnegative number           return this.NextJSONNonnegativeNumber(c' nextChar);         }         default:           this.RaiseError("Value can't be parsed.");           break;       }
Magic Number,PeterO.Cbor,CBORJson2,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORJson2.cs,NextJSONValue,The following statement contains a magic number: switch (c) {         case '"': {           // Parse a string           // The tokenizer already checked the string for invalid           // surrogate pairs' so just call the CBORObject           // constructor directly           obj = CBORObject.FromRaw(this.NextJSONString());           nextChar[0] = this.SkipWhitespaceJSON();           return obj;         }         case '{': {           // Parse an object           obj = this.ParseJSONObject(depth + 1);           nextChar[0] = this.SkipWhitespaceJSON();           return obj;         }         case '[': {           // Parse an array           obj = this.ParseJSONArray(depth + 1);           nextChar[0] = this.SkipWhitespaceJSON();           return obj;         }         case 't': {           // Parse true           if (this.endPos - this.index <= 2 ||             this.bytes[this.index] != (byte)0x72 ||             this.bytes[this.index + 1] != (byte)0x75 ||             this.bytes[this.index + 2] != (byte)0x65) {             this.RaiseError("Value can't be parsed.");           }           this.index += 3;           nextChar[0] = this.SkipWhitespaceJSON();           return CBORObject.True;         }         case 'f': {           // Parse false           if (this.endPos - this.index <= 3 ||             this.bytes[this.index] != (byte)0x61 ||             this.bytes[this.index + 1] != (byte)0x6c ||             this.bytes[this.index + 2] != (byte)0x73 ||             this.bytes[this.index + 3] != (byte)0x65) {             this.RaiseError("Value can't be parsed.");           }           this.index += 4;           nextChar[0] = this.SkipWhitespaceJSON();           return CBORObject.False;         }         case 'n': {           // Parse null           if (this.endPos - this.index <= 2 ||             this.bytes[this.index] != (byte)0x75 ||             this.bytes[this.index + 1] != (byte)0x6c ||             this.bytes[this.index + 2] != (byte)0x6c) {             this.RaiseError("Value can't be parsed.");           }           this.index += 3;           nextChar[0] = this.SkipWhitespaceJSON();           return CBORObject.Null;         }         case '-': {           // Parse a negative number           return this.NextJSONNegativeNumber(nextChar);         }         case '0':         case '1':         case '2':         case '3':         case '4':         case '5':         case '6':         case '7':         case '8':         case '9': {           // Parse a nonnegative number           return this.NextJSONNonnegativeNumber(c' nextChar);         }         default:           this.RaiseError("Value can't be parsed.");           break;       }
Magic Number,PeterO.Cbor,CBORJson2,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORJson2.cs,NextJSONValue,The following statement contains a magic number: switch (c) {         case '"': {           // Parse a string           // The tokenizer already checked the string for invalid           // surrogate pairs' so just call the CBORObject           // constructor directly           obj = CBORObject.FromRaw(this.NextJSONString());           nextChar[0] = this.SkipWhitespaceJSON();           return obj;         }         case '{': {           // Parse an object           obj = this.ParseJSONObject(depth + 1);           nextChar[0] = this.SkipWhitespaceJSON();           return obj;         }         case '[': {           // Parse an array           obj = this.ParseJSONArray(depth + 1);           nextChar[0] = this.SkipWhitespaceJSON();           return obj;         }         case 't': {           // Parse true           if (this.endPos - this.index <= 2 ||             this.bytes[this.index] != (byte)0x72 ||             this.bytes[this.index + 1] != (byte)0x75 ||             this.bytes[this.index + 2] != (byte)0x65) {             this.RaiseError("Value can't be parsed.");           }           this.index += 3;           nextChar[0] = this.SkipWhitespaceJSON();           return CBORObject.True;         }         case 'f': {           // Parse false           if (this.endPos - this.index <= 3 ||             this.bytes[this.index] != (byte)0x61 ||             this.bytes[this.index + 1] != (byte)0x6c ||             this.bytes[this.index + 2] != (byte)0x73 ||             this.bytes[this.index + 3] != (byte)0x65) {             this.RaiseError("Value can't be parsed.");           }           this.index += 4;           nextChar[0] = this.SkipWhitespaceJSON();           return CBORObject.False;         }         case 'n': {           // Parse null           if (this.endPos - this.index <= 2 ||             this.bytes[this.index] != (byte)0x75 ||             this.bytes[this.index + 1] != (byte)0x6c ||             this.bytes[this.index + 2] != (byte)0x6c) {             this.RaiseError("Value can't be parsed.");           }           this.index += 3;           nextChar[0] = this.SkipWhitespaceJSON();           return CBORObject.Null;         }         case '-': {           // Parse a negative number           return this.NextJSONNegativeNumber(nextChar);         }         case '0':         case '1':         case '2':         case '3':         case '4':         case '5':         case '6':         case '7':         case '8':         case '9': {           // Parse a nonnegative number           return this.NextJSONNonnegativeNumber(c' nextChar);         }         default:           this.RaiseError("Value can't be parsed.");           break;       }
Magic Number,PeterO.Cbor,CBORJson2,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORJson2.cs,NextJSONValue,The following statement contains a magic number: switch (c) {         case '"': {           // Parse a string           // The tokenizer already checked the string for invalid           // surrogate pairs' so just call the CBORObject           // constructor directly           obj = CBORObject.FromRaw(this.NextJSONString());           nextChar[0] = this.SkipWhitespaceJSON();           return obj;         }         case '{': {           // Parse an object           obj = this.ParseJSONObject(depth + 1);           nextChar[0] = this.SkipWhitespaceJSON();           return obj;         }         case '[': {           // Parse an array           obj = this.ParseJSONArray(depth + 1);           nextChar[0] = this.SkipWhitespaceJSON();           return obj;         }         case 't': {           // Parse true           if (this.endPos - this.index <= 2 ||             this.bytes[this.index] != (byte)0x72 ||             this.bytes[this.index + 1] != (byte)0x75 ||             this.bytes[this.index + 2] != (byte)0x65) {             this.RaiseError("Value can't be parsed.");           }           this.index += 3;           nextChar[0] = this.SkipWhitespaceJSON();           return CBORObject.True;         }         case 'f': {           // Parse false           if (this.endPos - this.index <= 3 ||             this.bytes[this.index] != (byte)0x61 ||             this.bytes[this.index + 1] != (byte)0x6c ||             this.bytes[this.index + 2] != (byte)0x73 ||             this.bytes[this.index + 3] != (byte)0x65) {             this.RaiseError("Value can't be parsed.");           }           this.index += 4;           nextChar[0] = this.SkipWhitespaceJSON();           return CBORObject.False;         }         case 'n': {           // Parse null           if (this.endPos - this.index <= 2 ||             this.bytes[this.index] != (byte)0x75 ||             this.bytes[this.index + 1] != (byte)0x6c ||             this.bytes[this.index + 2] != (byte)0x6c) {             this.RaiseError("Value can't be parsed.");           }           this.index += 3;           nextChar[0] = this.SkipWhitespaceJSON();           return CBORObject.Null;         }         case '-': {           // Parse a negative number           return this.NextJSONNegativeNumber(nextChar);         }         case '0':         case '1':         case '2':         case '3':         case '4':         case '5':         case '6':         case '7':         case '8':         case '9': {           // Parse a nonnegative number           return this.NextJSONNonnegativeNumber(c' nextChar);         }         default:           this.RaiseError("Value can't be parsed.");           break;       }
Magic Number,PeterO.Cbor,CBORJson2,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORJson2.cs,NextJSONValue,The following statement contains a magic number: switch (c) {         case '"': {           // Parse a string           // The tokenizer already checked the string for invalid           // surrogate pairs' so just call the CBORObject           // constructor directly           obj = CBORObject.FromRaw(this.NextJSONString());           nextChar[0] = this.SkipWhitespaceJSON();           return obj;         }         case '{': {           // Parse an object           obj = this.ParseJSONObject(depth + 1);           nextChar[0] = this.SkipWhitespaceJSON();           return obj;         }         case '[': {           // Parse an array           obj = this.ParseJSONArray(depth + 1);           nextChar[0] = this.SkipWhitespaceJSON();           return obj;         }         case 't': {           // Parse true           if (this.endPos - this.index <= 2 ||             this.bytes[this.index] != (byte)0x72 ||             this.bytes[this.index + 1] != (byte)0x75 ||             this.bytes[this.index + 2] != (byte)0x65) {             this.RaiseError("Value can't be parsed.");           }           this.index += 3;           nextChar[0] = this.SkipWhitespaceJSON();           return CBORObject.True;         }         case 'f': {           // Parse false           if (this.endPos - this.index <= 3 ||             this.bytes[this.index] != (byte)0x61 ||             this.bytes[this.index + 1] != (byte)0x6c ||             this.bytes[this.index + 2] != (byte)0x73 ||             this.bytes[this.index + 3] != (byte)0x65) {             this.RaiseError("Value can't be parsed.");           }           this.index += 4;           nextChar[0] = this.SkipWhitespaceJSON();           return CBORObject.False;         }         case 'n': {           // Parse null           if (this.endPos - this.index <= 2 ||             this.bytes[this.index] != (byte)0x75 ||             this.bytes[this.index + 1] != (byte)0x6c ||             this.bytes[this.index + 2] != (byte)0x6c) {             this.RaiseError("Value can't be parsed.");           }           this.index += 3;           nextChar[0] = this.SkipWhitespaceJSON();           return CBORObject.Null;         }         case '-': {           // Parse a negative number           return this.NextJSONNegativeNumber(nextChar);         }         case '0':         case '1':         case '2':         case '3':         case '4':         case '5':         case '6':         case '7':         case '8':         case '9': {           // Parse a nonnegative number           return this.NextJSONNonnegativeNumber(c' nextChar);         }         default:           this.RaiseError("Value can't be parsed.");           break;       }
Magic Number,PeterO.Cbor,CBORJson2,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORJson2.cs,NextJSONValue,The following statement contains a magic number: switch (c) {         case '"': {           // Parse a string           // The tokenizer already checked the string for invalid           // surrogate pairs' so just call the CBORObject           // constructor directly           obj = CBORObject.FromRaw(this.NextJSONString());           nextChar[0] = this.SkipWhitespaceJSON();           return obj;         }         case '{': {           // Parse an object           obj = this.ParseJSONObject(depth + 1);           nextChar[0] = this.SkipWhitespaceJSON();           return obj;         }         case '[': {           // Parse an array           obj = this.ParseJSONArray(depth + 1);           nextChar[0] = this.SkipWhitespaceJSON();           return obj;         }         case 't': {           // Parse true           if (this.endPos - this.index <= 2 ||             this.bytes[this.index] != (byte)0x72 ||             this.bytes[this.index + 1] != (byte)0x75 ||             this.bytes[this.index + 2] != (byte)0x65) {             this.RaiseError("Value can't be parsed.");           }           this.index += 3;           nextChar[0] = this.SkipWhitespaceJSON();           return CBORObject.True;         }         case 'f': {           // Parse false           if (this.endPos - this.index <= 3 ||             this.bytes[this.index] != (byte)0x61 ||             this.bytes[this.index + 1] != (byte)0x6c ||             this.bytes[this.index + 2] != (byte)0x73 ||             this.bytes[this.index + 3] != (byte)0x65) {             this.RaiseError("Value can't be parsed.");           }           this.index += 4;           nextChar[0] = this.SkipWhitespaceJSON();           return CBORObject.False;         }         case 'n': {           // Parse null           if (this.endPos - this.index <= 2 ||             this.bytes[this.index] != (byte)0x75 ||             this.bytes[this.index + 1] != (byte)0x6c ||             this.bytes[this.index + 2] != (byte)0x6c) {             this.RaiseError("Value can't be parsed.");           }           this.index += 3;           nextChar[0] = this.SkipWhitespaceJSON();           return CBORObject.Null;         }         case '-': {           // Parse a negative number           return this.NextJSONNegativeNumber(nextChar);         }         case '0':         case '1':         case '2':         case '3':         case '4':         case '5':         case '6':         case '7':         case '8':         case '9': {           // Parse a nonnegative number           return this.NextJSONNonnegativeNumber(c' nextChar);         }         default:           this.RaiseError("Value can't be parsed.");           break;       }
Magic Number,PeterO.Cbor,CBORJson2,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORJson2.cs,ParseJSONObject,The following statement contains a magic number: depth > 1000
Magic Number,PeterO.Cbor,CBORJson2,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORJson2.cs,ParseJSONArray,The following statement contains a magic number: depth > 1000
Magic Number,PeterO.Cbor,CBORJson3,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORJson3.cs,NextJSONString,The following statement contains a magic number: switch (c) {           case '\\':             endIndex = this.index - 1;             c = this.index < this.endPos ? ((int)this.jstring[this.index++]) &               0xffff : -1;             unescaped = false;             this.sb = this.sb ?? new StringBuilder();             this.sb.Remove(0' this.sb.Length);             this.sb.Append(this.jstring' startIndex' endIndex - startIndex);             switch (c) {               case '\\':               case '/':               case '\"':                 // Slash is now allowed to be escaped under RFC 8259                 this.sb.Append((char)c);                 break;               case 'b':                 this.sb.Append('\b');                 break;               case 'f':                 this.sb.Append('\f');                 break;               case 'n':                 this.sb.Append('\n');                 break;               case 'r':                 this.sb.Append('\r');                 break;               case 't':                 this.sb.Append('\t');                 break;               case 'u': { // Unicode escape                 c = 0;                 // Consists of 4 hex digits                 for (var i = 0; i < 4; ++i) {                   int ch = this.index < this.endPos ?                     ((int)this.jstring[this.index++]) : -1;                   if (ch >= '0' && ch <= '9') {                     c <<= 4;                     c |= ch - '0';                   } else if (ch >= 'A' && ch <= 'F') {                     c <<= 4;                     c |= ch + 10 - 'A';                   } else if (ch >= 'a' && ch <= 'f') {                     c <<= 4;                     c |= ch + 10 - 'a';                   } else {                     this.RaiseError(                       "Invalid Unicode escaped character");                   }                 }                 if ((c & 0xf800) != 0xd800) {                   // Non-surrogate                   this.sb.Append((char)c);                 } else if ((c & 0xfc00) == 0xd800) {                   int ch = this.index < this.endPos ?                     ((int)this.jstring[this.index++]) : -1;                   if (ch != '\\' || (this.index < this.endPos ?                       ((int)this.jstring[this.index++]) : -1) != 'u') {                     this.RaiseError("Invalid escaped character");                   }                   var c2 = 0;                   for (var i = 0; i < 4; ++i) {                     ch = this.index < this.endPos ?                       ((int)this.jstring[this.index++]) : -1;                     if (ch >= '0' && ch <= '9') {                       c2 <<= 4;                       c2 |= ch - '0';                     } else if (ch >= 'A' && ch <= 'F') {                       c2 <<= 4;                       c2 |= ch + 10 - 'A';                     } else if (ch >= 'a' && ch <= 'f') {                       c2 <<= 4;                       c2 |= ch + 10 - 'a';                     } else {                       this.RaiseError(                         "Invalid Unicode escaped character");                     }                   }                   if ((c2 & 0xfc00) != 0xdc00) {                     this.RaiseError("Unpaired surrogate code point");                   } else {                     this.sb.Append((char)c);                     this.sb.Append((char)c2);                   }                 } else {                   this.RaiseError("Unpaired surrogate code point");                 }                 break;               }               default: {                 this.RaiseError("Invalid escaped character");                 break;               }             }             break;           case 0x22: // double quote           if (unescaped) {               return this.jstring.Substring(startIndex' (this.index - 1) - startIndex);             } else {  return this.sb.ToString(); }           default: {             // NOTE: Differs from CBORJson2             if ((c & 0xf800) != 0xd800) {               // Non-surrogate               if (!unescaped) {                 this.sb.Append((char)c);               }             } else if ((c & 0xfc00) == 0xd800 && this.index < this.endPos &&               (this.jstring[this.index] & 0xfc00) == 0xdc00) {               // Surrogate pair               if (!unescaped) {                 this.sb.Append((char)c);                 this.sb.Append(this.jstring[this.index]);               }               ++this.index;             } else {               this.RaiseError("Unpaired surrogate code point");             }             break;           }         }
Magic Number,PeterO.Cbor,CBORJson3,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORJson3.cs,NextJSONString,The following statement contains a magic number: switch (c) {           case '\\':             endIndex = this.index - 1;             c = this.index < this.endPos ? ((int)this.jstring[this.index++]) &               0xffff : -1;             unescaped = false;             this.sb = this.sb ?? new StringBuilder();             this.sb.Remove(0' this.sb.Length);             this.sb.Append(this.jstring' startIndex' endIndex - startIndex);             switch (c) {               case '\\':               case '/':               case '\"':                 // Slash is now allowed to be escaped under RFC 8259                 this.sb.Append((char)c);                 break;               case 'b':                 this.sb.Append('\b');                 break;               case 'f':                 this.sb.Append('\f');                 break;               case 'n':                 this.sb.Append('\n');                 break;               case 'r':                 this.sb.Append('\r');                 break;               case 't':                 this.sb.Append('\t');                 break;               case 'u': { // Unicode escape                 c = 0;                 // Consists of 4 hex digits                 for (var i = 0; i < 4; ++i) {                   int ch = this.index < this.endPos ?                     ((int)this.jstring[this.index++]) : -1;                   if (ch >= '0' && ch <= '9') {                     c <<= 4;                     c |= ch - '0';                   } else if (ch >= 'A' && ch <= 'F') {                     c <<= 4;                     c |= ch + 10 - 'A';                   } else if (ch >= 'a' && ch <= 'f') {                     c <<= 4;                     c |= ch + 10 - 'a';                   } else {                     this.RaiseError(                       "Invalid Unicode escaped character");                   }                 }                 if ((c & 0xf800) != 0xd800) {                   // Non-surrogate                   this.sb.Append((char)c);                 } else if ((c & 0xfc00) == 0xd800) {                   int ch = this.index < this.endPos ?                     ((int)this.jstring[this.index++]) : -1;                   if (ch != '\\' || (this.index < this.endPos ?                       ((int)this.jstring[this.index++]) : -1) != 'u') {                     this.RaiseError("Invalid escaped character");                   }                   var c2 = 0;                   for (var i = 0; i < 4; ++i) {                     ch = this.index < this.endPos ?                       ((int)this.jstring[this.index++]) : -1;                     if (ch >= '0' && ch <= '9') {                       c2 <<= 4;                       c2 |= ch - '0';                     } else if (ch >= 'A' && ch <= 'F') {                       c2 <<= 4;                       c2 |= ch + 10 - 'A';                     } else if (ch >= 'a' && ch <= 'f') {                       c2 <<= 4;                       c2 |= ch + 10 - 'a';                     } else {                       this.RaiseError(                         "Invalid Unicode escaped character");                     }                   }                   if ((c2 & 0xfc00) != 0xdc00) {                     this.RaiseError("Unpaired surrogate code point");                   } else {                     this.sb.Append((char)c);                     this.sb.Append((char)c2);                   }                 } else {                   this.RaiseError("Unpaired surrogate code point");                 }                 break;               }               default: {                 this.RaiseError("Invalid escaped character");                 break;               }             }             break;           case 0x22: // double quote           if (unescaped) {               return this.jstring.Substring(startIndex' (this.index - 1) - startIndex);             } else {  return this.sb.ToString(); }           default: {             // NOTE: Differs from CBORJson2             if ((c & 0xf800) != 0xd800) {               // Non-surrogate               if (!unescaped) {                 this.sb.Append((char)c);               }             } else if ((c & 0xfc00) == 0xd800 && this.index < this.endPos &&               (this.jstring[this.index] & 0xfc00) == 0xdc00) {               // Surrogate pair               if (!unescaped) {                 this.sb.Append((char)c);                 this.sb.Append(this.jstring[this.index]);               }               ++this.index;             } else {               this.RaiseError("Unpaired surrogate code point");             }             break;           }         }
Magic Number,PeterO.Cbor,CBORJson3,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORJson3.cs,NextJSONString,The following statement contains a magic number: switch (c) {           case '\\':             endIndex = this.index - 1;             c = this.index < this.endPos ? ((int)this.jstring[this.index++]) &               0xffff : -1;             unescaped = false;             this.sb = this.sb ?? new StringBuilder();             this.sb.Remove(0' this.sb.Length);             this.sb.Append(this.jstring' startIndex' endIndex - startIndex);             switch (c) {               case '\\':               case '/':               case '\"':                 // Slash is now allowed to be escaped under RFC 8259                 this.sb.Append((char)c);                 break;               case 'b':                 this.sb.Append('\b');                 break;               case 'f':                 this.sb.Append('\f');                 break;               case 'n':                 this.sb.Append('\n');                 break;               case 'r':                 this.sb.Append('\r');                 break;               case 't':                 this.sb.Append('\t');                 break;               case 'u': { // Unicode escape                 c = 0;                 // Consists of 4 hex digits                 for (var i = 0; i < 4; ++i) {                   int ch = this.index < this.endPos ?                     ((int)this.jstring[this.index++]) : -1;                   if (ch >= '0' && ch <= '9') {                     c <<= 4;                     c |= ch - '0';                   } else if (ch >= 'A' && ch <= 'F') {                     c <<= 4;                     c |= ch + 10 - 'A';                   } else if (ch >= 'a' && ch <= 'f') {                     c <<= 4;                     c |= ch + 10 - 'a';                   } else {                     this.RaiseError(                       "Invalid Unicode escaped character");                   }                 }                 if ((c & 0xf800) != 0xd800) {                   // Non-surrogate                   this.sb.Append((char)c);                 } else if ((c & 0xfc00) == 0xd800) {                   int ch = this.index < this.endPos ?                     ((int)this.jstring[this.index++]) : -1;                   if (ch != '\\' || (this.index < this.endPos ?                       ((int)this.jstring[this.index++]) : -1) != 'u') {                     this.RaiseError("Invalid escaped character");                   }                   var c2 = 0;                   for (var i = 0; i < 4; ++i) {                     ch = this.index < this.endPos ?                       ((int)this.jstring[this.index++]) : -1;                     if (ch >= '0' && ch <= '9') {                       c2 <<= 4;                       c2 |= ch - '0';                     } else if (ch >= 'A' && ch <= 'F') {                       c2 <<= 4;                       c2 |= ch + 10 - 'A';                     } else if (ch >= 'a' && ch <= 'f') {                       c2 <<= 4;                       c2 |= ch + 10 - 'a';                     } else {                       this.RaiseError(                         "Invalid Unicode escaped character");                     }                   }                   if ((c2 & 0xfc00) != 0xdc00) {                     this.RaiseError("Unpaired surrogate code point");                   } else {                     this.sb.Append((char)c);                     this.sb.Append((char)c2);                   }                 } else {                   this.RaiseError("Unpaired surrogate code point");                 }                 break;               }               default: {                 this.RaiseError("Invalid escaped character");                 break;               }             }             break;           case 0x22: // double quote           if (unescaped) {               return this.jstring.Substring(startIndex' (this.index - 1) - startIndex);             } else {  return this.sb.ToString(); }           default: {             // NOTE: Differs from CBORJson2             if ((c & 0xf800) != 0xd800) {               // Non-surrogate               if (!unescaped) {                 this.sb.Append((char)c);               }             } else if ((c & 0xfc00) == 0xd800 && this.index < this.endPos &&               (this.jstring[this.index] & 0xfc00) == 0xdc00) {               // Surrogate pair               if (!unescaped) {                 this.sb.Append((char)c);                 this.sb.Append(this.jstring[this.index]);               }               ++this.index;             } else {               this.RaiseError("Unpaired surrogate code point");             }             break;           }         }
Magic Number,PeterO.Cbor,CBORJson3,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORJson3.cs,NextJSONString,The following statement contains a magic number: switch (c) {           case '\\':             endIndex = this.index - 1;             c = this.index < this.endPos ? ((int)this.jstring[this.index++]) &               0xffff : -1;             unescaped = false;             this.sb = this.sb ?? new StringBuilder();             this.sb.Remove(0' this.sb.Length);             this.sb.Append(this.jstring' startIndex' endIndex - startIndex);             switch (c) {               case '\\':               case '/':               case '\"':                 // Slash is now allowed to be escaped under RFC 8259                 this.sb.Append((char)c);                 break;               case 'b':                 this.sb.Append('\b');                 break;               case 'f':                 this.sb.Append('\f');                 break;               case 'n':                 this.sb.Append('\n');                 break;               case 'r':                 this.sb.Append('\r');                 break;               case 't':                 this.sb.Append('\t');                 break;               case 'u': { // Unicode escape                 c = 0;                 // Consists of 4 hex digits                 for (var i = 0; i < 4; ++i) {                   int ch = this.index < this.endPos ?                     ((int)this.jstring[this.index++]) : -1;                   if (ch >= '0' && ch <= '9') {                     c <<= 4;                     c |= ch - '0';                   } else if (ch >= 'A' && ch <= 'F') {                     c <<= 4;                     c |= ch + 10 - 'A';                   } else if (ch >= 'a' && ch <= 'f') {                     c <<= 4;                     c |= ch + 10 - 'a';                   } else {                     this.RaiseError(                       "Invalid Unicode escaped character");                   }                 }                 if ((c & 0xf800) != 0xd800) {                   // Non-surrogate                   this.sb.Append((char)c);                 } else if ((c & 0xfc00) == 0xd800) {                   int ch = this.index < this.endPos ?                     ((int)this.jstring[this.index++]) : -1;                   if (ch != '\\' || (this.index < this.endPos ?                       ((int)this.jstring[this.index++]) : -1) != 'u') {                     this.RaiseError("Invalid escaped character");                   }                   var c2 = 0;                   for (var i = 0; i < 4; ++i) {                     ch = this.index < this.endPos ?                       ((int)this.jstring[this.index++]) : -1;                     if (ch >= '0' && ch <= '9') {                       c2 <<= 4;                       c2 |= ch - '0';                     } else if (ch >= 'A' && ch <= 'F') {                       c2 <<= 4;                       c2 |= ch + 10 - 'A';                     } else if (ch >= 'a' && ch <= 'f') {                       c2 <<= 4;                       c2 |= ch + 10 - 'a';                     } else {                       this.RaiseError(                         "Invalid Unicode escaped character");                     }                   }                   if ((c2 & 0xfc00) != 0xdc00) {                     this.RaiseError("Unpaired surrogate code point");                   } else {                     this.sb.Append((char)c);                     this.sb.Append((char)c2);                   }                 } else {                   this.RaiseError("Unpaired surrogate code point");                 }                 break;               }               default: {                 this.RaiseError("Invalid escaped character");                 break;               }             }             break;           case 0x22: // double quote           if (unescaped) {               return this.jstring.Substring(startIndex' (this.index - 1) - startIndex);             } else {  return this.sb.ToString(); }           default: {             // NOTE: Differs from CBORJson2             if ((c & 0xf800) != 0xd800) {               // Non-surrogate               if (!unescaped) {                 this.sb.Append((char)c);               }             } else if ((c & 0xfc00) == 0xd800 && this.index < this.endPos &&               (this.jstring[this.index] & 0xfc00) == 0xdc00) {               // Surrogate pair               if (!unescaped) {                 this.sb.Append((char)c);                 this.sb.Append(this.jstring[this.index]);               }               ++this.index;             } else {               this.RaiseError("Unpaired surrogate code point");             }             break;           }         }
Magic Number,PeterO.Cbor,CBORJson3,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORJson3.cs,NextJSONString,The following statement contains a magic number: switch (c) {           case '\\':             endIndex = this.index - 1;             c = this.index < this.endPos ? ((int)this.jstring[this.index++]) &               0xffff : -1;             unescaped = false;             this.sb = this.sb ?? new StringBuilder();             this.sb.Remove(0' this.sb.Length);             this.sb.Append(this.jstring' startIndex' endIndex - startIndex);             switch (c) {               case '\\':               case '/':               case '\"':                 // Slash is now allowed to be escaped under RFC 8259                 this.sb.Append((char)c);                 break;               case 'b':                 this.sb.Append('\b');                 break;               case 'f':                 this.sb.Append('\f');                 break;               case 'n':                 this.sb.Append('\n');                 break;               case 'r':                 this.sb.Append('\r');                 break;               case 't':                 this.sb.Append('\t');                 break;               case 'u': { // Unicode escape                 c = 0;                 // Consists of 4 hex digits                 for (var i = 0; i < 4; ++i) {                   int ch = this.index < this.endPos ?                     ((int)this.jstring[this.index++]) : -1;                   if (ch >= '0' && ch <= '9') {                     c <<= 4;                     c |= ch - '0';                   } else if (ch >= 'A' && ch <= 'F') {                     c <<= 4;                     c |= ch + 10 - 'A';                   } else if (ch >= 'a' && ch <= 'f') {                     c <<= 4;                     c |= ch + 10 - 'a';                   } else {                     this.RaiseError(                       "Invalid Unicode escaped character");                   }                 }                 if ((c & 0xf800) != 0xd800) {                   // Non-surrogate                   this.sb.Append((char)c);                 } else if ((c & 0xfc00) == 0xd800) {                   int ch = this.index < this.endPos ?                     ((int)this.jstring[this.index++]) : -1;                   if (ch != '\\' || (this.index < this.endPos ?                       ((int)this.jstring[this.index++]) : -1) != 'u') {                     this.RaiseError("Invalid escaped character");                   }                   var c2 = 0;                   for (var i = 0; i < 4; ++i) {                     ch = this.index < this.endPos ?                       ((int)this.jstring[this.index++]) : -1;                     if (ch >= '0' && ch <= '9') {                       c2 <<= 4;                       c2 |= ch - '0';                     } else if (ch >= 'A' && ch <= 'F') {                       c2 <<= 4;                       c2 |= ch + 10 - 'A';                     } else if (ch >= 'a' && ch <= 'f') {                       c2 <<= 4;                       c2 |= ch + 10 - 'a';                     } else {                       this.RaiseError(                         "Invalid Unicode escaped character");                     }                   }                   if ((c2 & 0xfc00) != 0xdc00) {                     this.RaiseError("Unpaired surrogate code point");                   } else {                     this.sb.Append((char)c);                     this.sb.Append((char)c2);                   }                 } else {                   this.RaiseError("Unpaired surrogate code point");                 }                 break;               }               default: {                 this.RaiseError("Invalid escaped character");                 break;               }             }             break;           case 0x22: // double quote           if (unescaped) {               return this.jstring.Substring(startIndex' (this.index - 1) - startIndex);             } else {  return this.sb.ToString(); }           default: {             // NOTE: Differs from CBORJson2             if ((c & 0xf800) != 0xd800) {               // Non-surrogate               if (!unescaped) {                 this.sb.Append((char)c);               }             } else if ((c & 0xfc00) == 0xd800 && this.index < this.endPos &&               (this.jstring[this.index] & 0xfc00) == 0xdc00) {               // Surrogate pair               if (!unescaped) {                 this.sb.Append((char)c);                 this.sb.Append(this.jstring[this.index]);               }               ++this.index;             } else {               this.RaiseError("Unpaired surrogate code point");             }             break;           }         }
Magic Number,PeterO.Cbor,CBORJson3,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORJson3.cs,NextJSONString,The following statement contains a magic number: switch (c) {           case '\\':             endIndex = this.index - 1;             c = this.index < this.endPos ? ((int)this.jstring[this.index++]) &               0xffff : -1;             unescaped = false;             this.sb = this.sb ?? new StringBuilder();             this.sb.Remove(0' this.sb.Length);             this.sb.Append(this.jstring' startIndex' endIndex - startIndex);             switch (c) {               case '\\':               case '/':               case '\"':                 // Slash is now allowed to be escaped under RFC 8259                 this.sb.Append((char)c);                 break;               case 'b':                 this.sb.Append('\b');                 break;               case 'f':                 this.sb.Append('\f');                 break;               case 'n':                 this.sb.Append('\n');                 break;               case 'r':                 this.sb.Append('\r');                 break;               case 't':                 this.sb.Append('\t');                 break;               case 'u': { // Unicode escape                 c = 0;                 // Consists of 4 hex digits                 for (var i = 0; i < 4; ++i) {                   int ch = this.index < this.endPos ?                     ((int)this.jstring[this.index++]) : -1;                   if (ch >= '0' && ch <= '9') {                     c <<= 4;                     c |= ch - '0';                   } else if (ch >= 'A' && ch <= 'F') {                     c <<= 4;                     c |= ch + 10 - 'A';                   } else if (ch >= 'a' && ch <= 'f') {                     c <<= 4;                     c |= ch + 10 - 'a';                   } else {                     this.RaiseError(                       "Invalid Unicode escaped character");                   }                 }                 if ((c & 0xf800) != 0xd800) {                   // Non-surrogate                   this.sb.Append((char)c);                 } else if ((c & 0xfc00) == 0xd800) {                   int ch = this.index < this.endPos ?                     ((int)this.jstring[this.index++]) : -1;                   if (ch != '\\' || (this.index < this.endPos ?                       ((int)this.jstring[this.index++]) : -1) != 'u') {                     this.RaiseError("Invalid escaped character");                   }                   var c2 = 0;                   for (var i = 0; i < 4; ++i) {                     ch = this.index < this.endPos ?                       ((int)this.jstring[this.index++]) : -1;                     if (ch >= '0' && ch <= '9') {                       c2 <<= 4;                       c2 |= ch - '0';                     } else if (ch >= 'A' && ch <= 'F') {                       c2 <<= 4;                       c2 |= ch + 10 - 'A';                     } else if (ch >= 'a' && ch <= 'f') {                       c2 <<= 4;                       c2 |= ch + 10 - 'a';                     } else {                       this.RaiseError(                         "Invalid Unicode escaped character");                     }                   }                   if ((c2 & 0xfc00) != 0xdc00) {                     this.RaiseError("Unpaired surrogate code point");                   } else {                     this.sb.Append((char)c);                     this.sb.Append((char)c2);                   }                 } else {                   this.RaiseError("Unpaired surrogate code point");                 }                 break;               }               default: {                 this.RaiseError("Invalid escaped character");                 break;               }             }             break;           case 0x22: // double quote           if (unescaped) {               return this.jstring.Substring(startIndex' (this.index - 1) - startIndex);             } else {  return this.sb.ToString(); }           default: {             // NOTE: Differs from CBORJson2             if ((c & 0xf800) != 0xd800) {               // Non-surrogate               if (!unescaped) {                 this.sb.Append((char)c);               }             } else if ((c & 0xfc00) == 0xd800 && this.index < this.endPos &&               (this.jstring[this.index] & 0xfc00) == 0xdc00) {               // Surrogate pair               if (!unescaped) {                 this.sb.Append((char)c);                 this.sb.Append(this.jstring[this.index]);               }               ++this.index;             } else {               this.RaiseError("Unpaired surrogate code point");             }             break;           }         }
Magic Number,PeterO.Cbor,CBORJson3,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORJson3.cs,NextJSONString,The following statement contains a magic number: switch (c) {           case '\\':             endIndex = this.index - 1;             c = this.index < this.endPos ? ((int)this.jstring[this.index++]) &               0xffff : -1;             unescaped = false;             this.sb = this.sb ?? new StringBuilder();             this.sb.Remove(0' this.sb.Length);             this.sb.Append(this.jstring' startIndex' endIndex - startIndex);             switch (c) {               case '\\':               case '/':               case '\"':                 // Slash is now allowed to be escaped under RFC 8259                 this.sb.Append((char)c);                 break;               case 'b':                 this.sb.Append('\b');                 break;               case 'f':                 this.sb.Append('\f');                 break;               case 'n':                 this.sb.Append('\n');                 break;               case 'r':                 this.sb.Append('\r');                 break;               case 't':                 this.sb.Append('\t');                 break;               case 'u': { // Unicode escape                 c = 0;                 // Consists of 4 hex digits                 for (var i = 0; i < 4; ++i) {                   int ch = this.index < this.endPos ?                     ((int)this.jstring[this.index++]) : -1;                   if (ch >= '0' && ch <= '9') {                     c <<= 4;                     c |= ch - '0';                   } else if (ch >= 'A' && ch <= 'F') {                     c <<= 4;                     c |= ch + 10 - 'A';                   } else if (ch >= 'a' && ch <= 'f') {                     c <<= 4;                     c |= ch + 10 - 'a';                   } else {                     this.RaiseError(                       "Invalid Unicode escaped character");                   }                 }                 if ((c & 0xf800) != 0xd800) {                   // Non-surrogate                   this.sb.Append((char)c);                 } else if ((c & 0xfc00) == 0xd800) {                   int ch = this.index < this.endPos ?                     ((int)this.jstring[this.index++]) : -1;                   if (ch != '\\' || (this.index < this.endPos ?                       ((int)this.jstring[this.index++]) : -1) != 'u') {                     this.RaiseError("Invalid escaped character");                   }                   var c2 = 0;                   for (var i = 0; i < 4; ++i) {                     ch = this.index < this.endPos ?                       ((int)this.jstring[this.index++]) : -1;                     if (ch >= '0' && ch <= '9') {                       c2 <<= 4;                       c2 |= ch - '0';                     } else if (ch >= 'A' && ch <= 'F') {                       c2 <<= 4;                       c2 |= ch + 10 - 'A';                     } else if (ch >= 'a' && ch <= 'f') {                       c2 <<= 4;                       c2 |= ch + 10 - 'a';                     } else {                       this.RaiseError(                         "Invalid Unicode escaped character");                     }                   }                   if ((c2 & 0xfc00) != 0xdc00) {                     this.RaiseError("Unpaired surrogate code point");                   } else {                     this.sb.Append((char)c);                     this.sb.Append((char)c2);                   }                 } else {                   this.RaiseError("Unpaired surrogate code point");                 }                 break;               }               default: {                 this.RaiseError("Invalid escaped character");                 break;               }             }             break;           case 0x22: // double quote           if (unescaped) {               return this.jstring.Substring(startIndex' (this.index - 1) - startIndex);             } else {  return this.sb.ToString(); }           default: {             // NOTE: Differs from CBORJson2             if ((c & 0xf800) != 0xd800) {               // Non-surrogate               if (!unescaped) {                 this.sb.Append((char)c);               }             } else if ((c & 0xfc00) == 0xd800 && this.index < this.endPos &&               (this.jstring[this.index] & 0xfc00) == 0xdc00) {               // Surrogate pair               if (!unescaped) {                 this.sb.Append((char)c);                 this.sb.Append(this.jstring[this.index]);               }               ++this.index;             } else {               this.RaiseError("Unpaired surrogate code point");             }             break;           }         }
Magic Number,PeterO.Cbor,CBORJson3,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORJson3.cs,NextJSONString,The following statement contains a magic number: switch (c) {           case '\\':             endIndex = this.index - 1;             c = this.index < this.endPos ? ((int)this.jstring[this.index++]) &               0xffff : -1;             unescaped = false;             this.sb = this.sb ?? new StringBuilder();             this.sb.Remove(0' this.sb.Length);             this.sb.Append(this.jstring' startIndex' endIndex - startIndex);             switch (c) {               case '\\':               case '/':               case '\"':                 // Slash is now allowed to be escaped under RFC 8259                 this.sb.Append((char)c);                 break;               case 'b':                 this.sb.Append('\b');                 break;               case 'f':                 this.sb.Append('\f');                 break;               case 'n':                 this.sb.Append('\n');                 break;               case 'r':                 this.sb.Append('\r');                 break;               case 't':                 this.sb.Append('\t');                 break;               case 'u': { // Unicode escape                 c = 0;                 // Consists of 4 hex digits                 for (var i = 0; i < 4; ++i) {                   int ch = this.index < this.endPos ?                     ((int)this.jstring[this.index++]) : -1;                   if (ch >= '0' && ch <= '9') {                     c <<= 4;                     c |= ch - '0';                   } else if (ch >= 'A' && ch <= 'F') {                     c <<= 4;                     c |= ch + 10 - 'A';                   } else if (ch >= 'a' && ch <= 'f') {                     c <<= 4;                     c |= ch + 10 - 'a';                   } else {                     this.RaiseError(                       "Invalid Unicode escaped character");                   }                 }                 if ((c & 0xf800) != 0xd800) {                   // Non-surrogate                   this.sb.Append((char)c);                 } else if ((c & 0xfc00) == 0xd800) {                   int ch = this.index < this.endPos ?                     ((int)this.jstring[this.index++]) : -1;                   if (ch != '\\' || (this.index < this.endPos ?                       ((int)this.jstring[this.index++]) : -1) != 'u') {                     this.RaiseError("Invalid escaped character");                   }                   var c2 = 0;                   for (var i = 0; i < 4; ++i) {                     ch = this.index < this.endPos ?                       ((int)this.jstring[this.index++]) : -1;                     if (ch >= '0' && ch <= '9') {                       c2 <<= 4;                       c2 |= ch - '0';                     } else if (ch >= 'A' && ch <= 'F') {                       c2 <<= 4;                       c2 |= ch + 10 - 'A';                     } else if (ch >= 'a' && ch <= 'f') {                       c2 <<= 4;                       c2 |= ch + 10 - 'a';                     } else {                       this.RaiseError(                         "Invalid Unicode escaped character");                     }                   }                   if ((c2 & 0xfc00) != 0xdc00) {                     this.RaiseError("Unpaired surrogate code point");                   } else {                     this.sb.Append((char)c);                     this.sb.Append((char)c2);                   }                 } else {                   this.RaiseError("Unpaired surrogate code point");                 }                 break;               }               default: {                 this.RaiseError("Invalid escaped character");                 break;               }             }             break;           case 0x22: // double quote           if (unescaped) {               return this.jstring.Substring(startIndex' (this.index - 1) - startIndex);             } else {  return this.sb.ToString(); }           default: {             // NOTE: Differs from CBORJson2             if ((c & 0xf800) != 0xd800) {               // Non-surrogate               if (!unescaped) {                 this.sb.Append((char)c);               }             } else if ((c & 0xfc00) == 0xd800 && this.index < this.endPos &&               (this.jstring[this.index] & 0xfc00) == 0xdc00) {               // Surrogate pair               if (!unescaped) {                 this.sb.Append((char)c);                 this.sb.Append(this.jstring[this.index]);               }               ++this.index;             } else {               this.RaiseError("Unpaired surrogate code point");             }             break;           }         }
Magic Number,PeterO.Cbor,CBORJson3,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORJson3.cs,NextJSONString,The following statement contains a magic number: switch (c) {           case '\\':             endIndex = this.index - 1;             c = this.index < this.endPos ? ((int)this.jstring[this.index++]) &               0xffff : -1;             unescaped = false;             this.sb = this.sb ?? new StringBuilder();             this.sb.Remove(0' this.sb.Length);             this.sb.Append(this.jstring' startIndex' endIndex - startIndex);             switch (c) {               case '\\':               case '/':               case '\"':                 // Slash is now allowed to be escaped under RFC 8259                 this.sb.Append((char)c);                 break;               case 'b':                 this.sb.Append('\b');                 break;               case 'f':                 this.sb.Append('\f');                 break;               case 'n':                 this.sb.Append('\n');                 break;               case 'r':                 this.sb.Append('\r');                 break;               case 't':                 this.sb.Append('\t');                 break;               case 'u': { // Unicode escape                 c = 0;                 // Consists of 4 hex digits                 for (var i = 0; i < 4; ++i) {                   int ch = this.index < this.endPos ?                     ((int)this.jstring[this.index++]) : -1;                   if (ch >= '0' && ch <= '9') {                     c <<= 4;                     c |= ch - '0';                   } else if (ch >= 'A' && ch <= 'F') {                     c <<= 4;                     c |= ch + 10 - 'A';                   } else if (ch >= 'a' && ch <= 'f') {                     c <<= 4;                     c |= ch + 10 - 'a';                   } else {                     this.RaiseError(                       "Invalid Unicode escaped character");                   }                 }                 if ((c & 0xf800) != 0xd800) {                   // Non-surrogate                   this.sb.Append((char)c);                 } else if ((c & 0xfc00) == 0xd800) {                   int ch = this.index < this.endPos ?                     ((int)this.jstring[this.index++]) : -1;                   if (ch != '\\' || (this.index < this.endPos ?                       ((int)this.jstring[this.index++]) : -1) != 'u') {                     this.RaiseError("Invalid escaped character");                   }                   var c2 = 0;                   for (var i = 0; i < 4; ++i) {                     ch = this.index < this.endPos ?                       ((int)this.jstring[this.index++]) : -1;                     if (ch >= '0' && ch <= '9') {                       c2 <<= 4;                       c2 |= ch - '0';                     } else if (ch >= 'A' && ch <= 'F') {                       c2 <<= 4;                       c2 |= ch + 10 - 'A';                     } else if (ch >= 'a' && ch <= 'f') {                       c2 <<= 4;                       c2 |= ch + 10 - 'a';                     } else {                       this.RaiseError(                         "Invalid Unicode escaped character");                     }                   }                   if ((c2 & 0xfc00) != 0xdc00) {                     this.RaiseError("Unpaired surrogate code point");                   } else {                     this.sb.Append((char)c);                     this.sb.Append((char)c2);                   }                 } else {                   this.RaiseError("Unpaired surrogate code point");                 }                 break;               }               default: {                 this.RaiseError("Invalid escaped character");                 break;               }             }             break;           case 0x22: // double quote           if (unescaped) {               return this.jstring.Substring(startIndex' (this.index - 1) - startIndex);             } else {  return this.sb.ToString(); }           default: {             // NOTE: Differs from CBORJson2             if ((c & 0xf800) != 0xd800) {               // Non-surrogate               if (!unescaped) {                 this.sb.Append((char)c);               }             } else if ((c & 0xfc00) == 0xd800 && this.index < this.endPos &&               (this.jstring[this.index] & 0xfc00) == 0xdc00) {               // Surrogate pair               if (!unescaped) {                 this.sb.Append((char)c);                 this.sb.Append(this.jstring[this.index]);               }               ++this.index;             } else {               this.RaiseError("Unpaired surrogate code point");             }             break;           }         }
Magic Number,PeterO.Cbor,CBORJson3,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORJson3.cs,NextJSONString,The following statement contains a magic number: switch (c) {           case '\\':             endIndex = this.index - 1;             c = this.index < this.endPos ? ((int)this.jstring[this.index++]) &               0xffff : -1;             unescaped = false;             this.sb = this.sb ?? new StringBuilder();             this.sb.Remove(0' this.sb.Length);             this.sb.Append(this.jstring' startIndex' endIndex - startIndex);             switch (c) {               case '\\':               case '/':               case '\"':                 // Slash is now allowed to be escaped under RFC 8259                 this.sb.Append((char)c);                 break;               case 'b':                 this.sb.Append('\b');                 break;               case 'f':                 this.sb.Append('\f');                 break;               case 'n':                 this.sb.Append('\n');                 break;               case 'r':                 this.sb.Append('\r');                 break;               case 't':                 this.sb.Append('\t');                 break;               case 'u': { // Unicode escape                 c = 0;                 // Consists of 4 hex digits                 for (var i = 0; i < 4; ++i) {                   int ch = this.index < this.endPos ?                     ((int)this.jstring[this.index++]) : -1;                   if (ch >= '0' && ch <= '9') {                     c <<= 4;                     c |= ch - '0';                   } else if (ch >= 'A' && ch <= 'F') {                     c <<= 4;                     c |= ch + 10 - 'A';                   } else if (ch >= 'a' && ch <= 'f') {                     c <<= 4;                     c |= ch + 10 - 'a';                   } else {                     this.RaiseError(                       "Invalid Unicode escaped character");                   }                 }                 if ((c & 0xf800) != 0xd800) {                   // Non-surrogate                   this.sb.Append((char)c);                 } else if ((c & 0xfc00) == 0xd800) {                   int ch = this.index < this.endPos ?                     ((int)this.jstring[this.index++]) : -1;                   if (ch != '\\' || (this.index < this.endPos ?                       ((int)this.jstring[this.index++]) : -1) != 'u') {                     this.RaiseError("Invalid escaped character");                   }                   var c2 = 0;                   for (var i = 0; i < 4; ++i) {                     ch = this.index < this.endPos ?                       ((int)this.jstring[this.index++]) : -1;                     if (ch >= '0' && ch <= '9') {                       c2 <<= 4;                       c2 |= ch - '0';                     } else if (ch >= 'A' && ch <= 'F') {                       c2 <<= 4;                       c2 |= ch + 10 - 'A';                     } else if (ch >= 'a' && ch <= 'f') {                       c2 <<= 4;                       c2 |= ch + 10 - 'a';                     } else {                       this.RaiseError(                         "Invalid Unicode escaped character");                     }                   }                   if ((c2 & 0xfc00) != 0xdc00) {                     this.RaiseError("Unpaired surrogate code point");                   } else {                     this.sb.Append((char)c);                     this.sb.Append((char)c2);                   }                 } else {                   this.RaiseError("Unpaired surrogate code point");                 }                 break;               }               default: {                 this.RaiseError("Invalid escaped character");                 break;               }             }             break;           case 0x22: // double quote           if (unescaped) {               return this.jstring.Substring(startIndex' (this.index - 1) - startIndex);             } else {  return this.sb.ToString(); }           default: {             // NOTE: Differs from CBORJson2             if ((c & 0xf800) != 0xd800) {               // Non-surrogate               if (!unescaped) {                 this.sb.Append((char)c);               }             } else if ((c & 0xfc00) == 0xd800 && this.index < this.endPos &&               (this.jstring[this.index] & 0xfc00) == 0xdc00) {               // Surrogate pair               if (!unescaped) {                 this.sb.Append((char)c);                 this.sb.Append(this.jstring[this.index]);               }               ++this.index;             } else {               this.RaiseError("Unpaired surrogate code point");             }             break;           }         }
Magic Number,PeterO.Cbor,CBORJson3,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORJson3.cs,NextJSONString,The following statement contains a magic number: switch (c) {           case '\\':             endIndex = this.index - 1;             c = this.index < this.endPos ? ((int)this.jstring[this.index++]) &               0xffff : -1;             unescaped = false;             this.sb = this.sb ?? new StringBuilder();             this.sb.Remove(0' this.sb.Length);             this.sb.Append(this.jstring' startIndex' endIndex - startIndex);             switch (c) {               case '\\':               case '/':               case '\"':                 // Slash is now allowed to be escaped under RFC 8259                 this.sb.Append((char)c);                 break;               case 'b':                 this.sb.Append('\b');                 break;               case 'f':                 this.sb.Append('\f');                 break;               case 'n':                 this.sb.Append('\n');                 break;               case 'r':                 this.sb.Append('\r');                 break;               case 't':                 this.sb.Append('\t');                 break;               case 'u': { // Unicode escape                 c = 0;                 // Consists of 4 hex digits                 for (var i = 0; i < 4; ++i) {                   int ch = this.index < this.endPos ?                     ((int)this.jstring[this.index++]) : -1;                   if (ch >= '0' && ch <= '9') {                     c <<= 4;                     c |= ch - '0';                   } else if (ch >= 'A' && ch <= 'F') {                     c <<= 4;                     c |= ch + 10 - 'A';                   } else if (ch >= 'a' && ch <= 'f') {                     c <<= 4;                     c |= ch + 10 - 'a';                   } else {                     this.RaiseError(                       "Invalid Unicode escaped character");                   }                 }                 if ((c & 0xf800) != 0xd800) {                   // Non-surrogate                   this.sb.Append((char)c);                 } else if ((c & 0xfc00) == 0xd800) {                   int ch = this.index < this.endPos ?                     ((int)this.jstring[this.index++]) : -1;                   if (ch != '\\' || (this.index < this.endPos ?                       ((int)this.jstring[this.index++]) : -1) != 'u') {                     this.RaiseError("Invalid escaped character");                   }                   var c2 = 0;                   for (var i = 0; i < 4; ++i) {                     ch = this.index < this.endPos ?                       ((int)this.jstring[this.index++]) : -1;                     if (ch >= '0' && ch <= '9') {                       c2 <<= 4;                       c2 |= ch - '0';                     } else if (ch >= 'A' && ch <= 'F') {                       c2 <<= 4;                       c2 |= ch + 10 - 'A';                     } else if (ch >= 'a' && ch <= 'f') {                       c2 <<= 4;                       c2 |= ch + 10 - 'a';                     } else {                       this.RaiseError(                         "Invalid Unicode escaped character");                     }                   }                   if ((c2 & 0xfc00) != 0xdc00) {                     this.RaiseError("Unpaired surrogate code point");                   } else {                     this.sb.Append((char)c);                     this.sb.Append((char)c2);                   }                 } else {                   this.RaiseError("Unpaired surrogate code point");                 }                 break;               }               default: {                 this.RaiseError("Invalid escaped character");                 break;               }             }             break;           case 0x22: // double quote           if (unescaped) {               return this.jstring.Substring(startIndex' (this.index - 1) - startIndex);             } else {  return this.sb.ToString(); }           default: {             // NOTE: Differs from CBORJson2             if ((c & 0xf800) != 0xd800) {               // Non-surrogate               if (!unescaped) {                 this.sb.Append((char)c);               }             } else if ((c & 0xfc00) == 0xd800 && this.index < this.endPos &&               (this.jstring[this.index] & 0xfc00) == 0xdc00) {               // Surrogate pair               if (!unescaped) {                 this.sb.Append((char)c);                 this.sb.Append(this.jstring[this.index]);               }               ++this.index;             } else {               this.RaiseError("Unpaired surrogate code point");             }             break;           }         }
Magic Number,PeterO.Cbor,CBORJson3,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORJson3.cs,NextJSONString,The following statement contains a magic number: switch (c) {           case '\\':             endIndex = this.index - 1;             c = this.index < this.endPos ? ((int)this.jstring[this.index++]) &               0xffff : -1;             unescaped = false;             this.sb = this.sb ?? new StringBuilder();             this.sb.Remove(0' this.sb.Length);             this.sb.Append(this.jstring' startIndex' endIndex - startIndex);             switch (c) {               case '\\':               case '/':               case '\"':                 // Slash is now allowed to be escaped under RFC 8259                 this.sb.Append((char)c);                 break;               case 'b':                 this.sb.Append('\b');                 break;               case 'f':                 this.sb.Append('\f');                 break;               case 'n':                 this.sb.Append('\n');                 break;               case 'r':                 this.sb.Append('\r');                 break;               case 't':                 this.sb.Append('\t');                 break;               case 'u': { // Unicode escape                 c = 0;                 // Consists of 4 hex digits                 for (var i = 0; i < 4; ++i) {                   int ch = this.index < this.endPos ?                     ((int)this.jstring[this.index++]) : -1;                   if (ch >= '0' && ch <= '9') {                     c <<= 4;                     c |= ch - '0';                   } else if (ch >= 'A' && ch <= 'F') {                     c <<= 4;                     c |= ch + 10 - 'A';                   } else if (ch >= 'a' && ch <= 'f') {                     c <<= 4;                     c |= ch + 10 - 'a';                   } else {                     this.RaiseError(                       "Invalid Unicode escaped character");                   }                 }                 if ((c & 0xf800) != 0xd800) {                   // Non-surrogate                   this.sb.Append((char)c);                 } else if ((c & 0xfc00) == 0xd800) {                   int ch = this.index < this.endPos ?                     ((int)this.jstring[this.index++]) : -1;                   if (ch != '\\' || (this.index < this.endPos ?                       ((int)this.jstring[this.index++]) : -1) != 'u') {                     this.RaiseError("Invalid escaped character");                   }                   var c2 = 0;                   for (var i = 0; i < 4; ++i) {                     ch = this.index < this.endPos ?                       ((int)this.jstring[this.index++]) : -1;                     if (ch >= '0' && ch <= '9') {                       c2 <<= 4;                       c2 |= ch - '0';                     } else if (ch >= 'A' && ch <= 'F') {                       c2 <<= 4;                       c2 |= ch + 10 - 'A';                     } else if (ch >= 'a' && ch <= 'f') {                       c2 <<= 4;                       c2 |= ch + 10 - 'a';                     } else {                       this.RaiseError(                         "Invalid Unicode escaped character");                     }                   }                   if ((c2 & 0xfc00) != 0xdc00) {                     this.RaiseError("Unpaired surrogate code point");                   } else {                     this.sb.Append((char)c);                     this.sb.Append((char)c2);                   }                 } else {                   this.RaiseError("Unpaired surrogate code point");                 }                 break;               }               default: {                 this.RaiseError("Invalid escaped character");                 break;               }             }             break;           case 0x22: // double quote           if (unescaped) {               return this.jstring.Substring(startIndex' (this.index - 1) - startIndex);             } else {  return this.sb.ToString(); }           default: {             // NOTE: Differs from CBORJson2             if ((c & 0xf800) != 0xd800) {               // Non-surrogate               if (!unescaped) {                 this.sb.Append((char)c);               }             } else if ((c & 0xfc00) == 0xd800 && this.index < this.endPos &&               (this.jstring[this.index] & 0xfc00) == 0xdc00) {               // Surrogate pair               if (!unescaped) {                 this.sb.Append((char)c);                 this.sb.Append(this.jstring[this.index]);               }               ++this.index;             } else {               this.RaiseError("Unpaired surrogate code point");             }             break;           }         }
Magic Number,PeterO.Cbor,CBORJson3,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORJson3.cs,NextJSONNegativeNumber,The following statement contains a magic number: string errstr = this.jstring.Substring(numberStartIndex'             Math.Min(100' strlen));
Magic Number,PeterO.Cbor,CBORJson3,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORJson3.cs,NextJSONNegativeNumber,The following statement contains a magic number: strlen > 100
Magic Number,PeterO.Cbor,CBORJson3,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORJson3.cs,NextJSONNonnegativeNumber,The following statement contains a magic number: string errstr = this.jstring.Substring(numberStartIndex'               Math.Min(100' strlen));
Magic Number,PeterO.Cbor,CBORJson3,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORJson3.cs,NextJSONNonnegativeNumber,The following statement contains a magic number: strlen > 100
Magic Number,PeterO.Cbor,CBORJson3,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORJson3.cs,NextJSONValue,The following statement contains a magic number: switch (c) {         case '"': {           // Parse a string           // The tokenizer already checked the string for invalid           // surrogate pairs' so just call the CBORObject           // constructor directly           obj = CBORObject.FromRaw(this.NextJSONString());           nextChar[0] = this.SkipWhitespaceJSON();           return obj;         }         case '{': {           // Parse an object           obj = this.ParseJSONObject(depth + 1);           nextChar[0] = this.SkipWhitespaceJSON();           return obj;         }         case '[': {           // Parse an array           obj = this.ParseJSONArray(depth + 1);           nextChar[0] = this.SkipWhitespaceJSON();           return obj;         }         case 't': {           // Parse true           if (this.endPos - this.index <= 2 ||             (((int)this.jstring[this.index]) & 0xFF) != 'r' ||             (((int)this.jstring[this.index + 1]) & 0xFF) != 'u' ||             (((int)this.jstring[this.index + 2]) & 0xFF) != 'e') {             this.RaiseError("Value can't be parsed.");           }           this.index += 3;           nextChar[0] = this.SkipWhitespaceJSON();           return CBORObject.True;         }         case 'f': {           // Parse false           if (this.endPos - this.index <= 3 ||             (((int)this.jstring[this.index]) & 0xFF) != 'a' ||             (((int)this.jstring[this.index + 1]) & 0xFF) != 'l' ||             (((int)this.jstring[this.index + 2]) & 0xFF) != 's' ||             (((int)this.jstring[this.index + 3]) & 0xFF) != 'e') {             this.RaiseError("Value can't be parsed.");           }           this.index += 4;           nextChar[0] = this.SkipWhitespaceJSON();           return CBORObject.False;         }         case 'n': {           // Parse null           if (this.endPos - this.index <= 2 ||             (((int)this.jstring[this.index]) & 0xFF) != 'u' ||             (((int)this.jstring[this.index + 1]) & 0xFF) != 'l' ||             (((int)this.jstring[this.index + 2]) & 0xFF) != 'l') {             this.RaiseError("Value can't be parsed.");           }           this.index += 3;           nextChar[0] = this.SkipWhitespaceJSON();           return CBORObject.Null;         }         case '-': {           // Parse a negative number           return this.NextJSONNegativeNumber(nextChar);         }         case '0':         case '1':         case '2':         case '3':         case '4':         case '5':         case '6':         case '7':         case '8':         case '9': {           // Parse a nonnegative number           return this.NextJSONNonnegativeNumber(c' nextChar);         }         default:           this.RaiseError("Value can't be parsed.");           break;       }
Magic Number,PeterO.Cbor,CBORJson3,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORJson3.cs,NextJSONValue,The following statement contains a magic number: switch (c) {         case '"': {           // Parse a string           // The tokenizer already checked the string for invalid           // surrogate pairs' so just call the CBORObject           // constructor directly           obj = CBORObject.FromRaw(this.NextJSONString());           nextChar[0] = this.SkipWhitespaceJSON();           return obj;         }         case '{': {           // Parse an object           obj = this.ParseJSONObject(depth + 1);           nextChar[0] = this.SkipWhitespaceJSON();           return obj;         }         case '[': {           // Parse an array           obj = this.ParseJSONArray(depth + 1);           nextChar[0] = this.SkipWhitespaceJSON();           return obj;         }         case 't': {           // Parse true           if (this.endPos - this.index <= 2 ||             (((int)this.jstring[this.index]) & 0xFF) != 'r' ||             (((int)this.jstring[this.index + 1]) & 0xFF) != 'u' ||             (((int)this.jstring[this.index + 2]) & 0xFF) != 'e') {             this.RaiseError("Value can't be parsed.");           }           this.index += 3;           nextChar[0] = this.SkipWhitespaceJSON();           return CBORObject.True;         }         case 'f': {           // Parse false           if (this.endPos - this.index <= 3 ||             (((int)this.jstring[this.index]) & 0xFF) != 'a' ||             (((int)this.jstring[this.index + 1]) & 0xFF) != 'l' ||             (((int)this.jstring[this.index + 2]) & 0xFF) != 's' ||             (((int)this.jstring[this.index + 3]) & 0xFF) != 'e') {             this.RaiseError("Value can't be parsed.");           }           this.index += 4;           nextChar[0] = this.SkipWhitespaceJSON();           return CBORObject.False;         }         case 'n': {           // Parse null           if (this.endPos - this.index <= 2 ||             (((int)this.jstring[this.index]) & 0xFF) != 'u' ||             (((int)this.jstring[this.index + 1]) & 0xFF) != 'l' ||             (((int)this.jstring[this.index + 2]) & 0xFF) != 'l') {             this.RaiseError("Value can't be parsed.");           }           this.index += 3;           nextChar[0] = this.SkipWhitespaceJSON();           return CBORObject.Null;         }         case '-': {           // Parse a negative number           return this.NextJSONNegativeNumber(nextChar);         }         case '0':         case '1':         case '2':         case '3':         case '4':         case '5':         case '6':         case '7':         case '8':         case '9': {           // Parse a nonnegative number           return this.NextJSONNonnegativeNumber(c' nextChar);         }         default:           this.RaiseError("Value can't be parsed.");           break;       }
Magic Number,PeterO.Cbor,CBORJson3,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORJson3.cs,NextJSONValue,The following statement contains a magic number: switch (c) {         case '"': {           // Parse a string           // The tokenizer already checked the string for invalid           // surrogate pairs' so just call the CBORObject           // constructor directly           obj = CBORObject.FromRaw(this.NextJSONString());           nextChar[0] = this.SkipWhitespaceJSON();           return obj;         }         case '{': {           // Parse an object           obj = this.ParseJSONObject(depth + 1);           nextChar[0] = this.SkipWhitespaceJSON();           return obj;         }         case '[': {           // Parse an array           obj = this.ParseJSONArray(depth + 1);           nextChar[0] = this.SkipWhitespaceJSON();           return obj;         }         case 't': {           // Parse true           if (this.endPos - this.index <= 2 ||             (((int)this.jstring[this.index]) & 0xFF) != 'r' ||             (((int)this.jstring[this.index + 1]) & 0xFF) != 'u' ||             (((int)this.jstring[this.index + 2]) & 0xFF) != 'e') {             this.RaiseError("Value can't be parsed.");           }           this.index += 3;           nextChar[0] = this.SkipWhitespaceJSON();           return CBORObject.True;         }         case 'f': {           // Parse false           if (this.endPos - this.index <= 3 ||             (((int)this.jstring[this.index]) & 0xFF) != 'a' ||             (((int)this.jstring[this.index + 1]) & 0xFF) != 'l' ||             (((int)this.jstring[this.index + 2]) & 0xFF) != 's' ||             (((int)this.jstring[this.index + 3]) & 0xFF) != 'e') {             this.RaiseError("Value can't be parsed.");           }           this.index += 4;           nextChar[0] = this.SkipWhitespaceJSON();           return CBORObject.False;         }         case 'n': {           // Parse null           if (this.endPos - this.index <= 2 ||             (((int)this.jstring[this.index]) & 0xFF) != 'u' ||             (((int)this.jstring[this.index + 1]) & 0xFF) != 'l' ||             (((int)this.jstring[this.index + 2]) & 0xFF) != 'l') {             this.RaiseError("Value can't be parsed.");           }           this.index += 3;           nextChar[0] = this.SkipWhitespaceJSON();           return CBORObject.Null;         }         case '-': {           // Parse a negative number           return this.NextJSONNegativeNumber(nextChar);         }         case '0':         case '1':         case '2':         case '3':         case '4':         case '5':         case '6':         case '7':         case '8':         case '9': {           // Parse a nonnegative number           return this.NextJSONNonnegativeNumber(c' nextChar);         }         default:           this.RaiseError("Value can't be parsed.");           break;       }
Magic Number,PeterO.Cbor,CBORJson3,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORJson3.cs,NextJSONValue,The following statement contains a magic number: switch (c) {         case '"': {           // Parse a string           // The tokenizer already checked the string for invalid           // surrogate pairs' so just call the CBORObject           // constructor directly           obj = CBORObject.FromRaw(this.NextJSONString());           nextChar[0] = this.SkipWhitespaceJSON();           return obj;         }         case '{': {           // Parse an object           obj = this.ParseJSONObject(depth + 1);           nextChar[0] = this.SkipWhitespaceJSON();           return obj;         }         case '[': {           // Parse an array           obj = this.ParseJSONArray(depth + 1);           nextChar[0] = this.SkipWhitespaceJSON();           return obj;         }         case 't': {           // Parse true           if (this.endPos - this.index <= 2 ||             (((int)this.jstring[this.index]) & 0xFF) != 'r' ||             (((int)this.jstring[this.index + 1]) & 0xFF) != 'u' ||             (((int)this.jstring[this.index + 2]) & 0xFF) != 'e') {             this.RaiseError("Value can't be parsed.");           }           this.index += 3;           nextChar[0] = this.SkipWhitespaceJSON();           return CBORObject.True;         }         case 'f': {           // Parse false           if (this.endPos - this.index <= 3 ||             (((int)this.jstring[this.index]) & 0xFF) != 'a' ||             (((int)this.jstring[this.index + 1]) & 0xFF) != 'l' ||             (((int)this.jstring[this.index + 2]) & 0xFF) != 's' ||             (((int)this.jstring[this.index + 3]) & 0xFF) != 'e') {             this.RaiseError("Value can't be parsed.");           }           this.index += 4;           nextChar[0] = this.SkipWhitespaceJSON();           return CBORObject.False;         }         case 'n': {           // Parse null           if (this.endPos - this.index <= 2 ||             (((int)this.jstring[this.index]) & 0xFF) != 'u' ||             (((int)this.jstring[this.index + 1]) & 0xFF) != 'l' ||             (((int)this.jstring[this.index + 2]) & 0xFF) != 'l') {             this.RaiseError("Value can't be parsed.");           }           this.index += 3;           nextChar[0] = this.SkipWhitespaceJSON();           return CBORObject.Null;         }         case '-': {           // Parse a negative number           return this.NextJSONNegativeNumber(nextChar);         }         case '0':         case '1':         case '2':         case '3':         case '4':         case '5':         case '6':         case '7':         case '8':         case '9': {           // Parse a nonnegative number           return this.NextJSONNonnegativeNumber(c' nextChar);         }         default:           this.RaiseError("Value can't be parsed.");           break;       }
Magic Number,PeterO.Cbor,CBORJson3,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORJson3.cs,NextJSONValue,The following statement contains a magic number: switch (c) {         case '"': {           // Parse a string           // The tokenizer already checked the string for invalid           // surrogate pairs' so just call the CBORObject           // constructor directly           obj = CBORObject.FromRaw(this.NextJSONString());           nextChar[0] = this.SkipWhitespaceJSON();           return obj;         }         case '{': {           // Parse an object           obj = this.ParseJSONObject(depth + 1);           nextChar[0] = this.SkipWhitespaceJSON();           return obj;         }         case '[': {           // Parse an array           obj = this.ParseJSONArray(depth + 1);           nextChar[0] = this.SkipWhitespaceJSON();           return obj;         }         case 't': {           // Parse true           if (this.endPos - this.index <= 2 ||             (((int)this.jstring[this.index]) & 0xFF) != 'r' ||             (((int)this.jstring[this.index + 1]) & 0xFF) != 'u' ||             (((int)this.jstring[this.index + 2]) & 0xFF) != 'e') {             this.RaiseError("Value can't be parsed.");           }           this.index += 3;           nextChar[0] = this.SkipWhitespaceJSON();           return CBORObject.True;         }         case 'f': {           // Parse false           if (this.endPos - this.index <= 3 ||             (((int)this.jstring[this.index]) & 0xFF) != 'a' ||             (((int)this.jstring[this.index + 1]) & 0xFF) != 'l' ||             (((int)this.jstring[this.index + 2]) & 0xFF) != 's' ||             (((int)this.jstring[this.index + 3]) & 0xFF) != 'e') {             this.RaiseError("Value can't be parsed.");           }           this.index += 4;           nextChar[0] = this.SkipWhitespaceJSON();           return CBORObject.False;         }         case 'n': {           // Parse null           if (this.endPos - this.index <= 2 ||             (((int)this.jstring[this.index]) & 0xFF) != 'u' ||             (((int)this.jstring[this.index + 1]) & 0xFF) != 'l' ||             (((int)this.jstring[this.index + 2]) & 0xFF) != 'l') {             this.RaiseError("Value can't be parsed.");           }           this.index += 3;           nextChar[0] = this.SkipWhitespaceJSON();           return CBORObject.Null;         }         case '-': {           // Parse a negative number           return this.NextJSONNegativeNumber(nextChar);         }         case '0':         case '1':         case '2':         case '3':         case '4':         case '5':         case '6':         case '7':         case '8':         case '9': {           // Parse a nonnegative number           return this.NextJSONNonnegativeNumber(c' nextChar);         }         default:           this.RaiseError("Value can't be parsed.");           break;       }
Magic Number,PeterO.Cbor,CBORJson3,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORJson3.cs,NextJSONValue,The following statement contains a magic number: switch (c) {         case '"': {           // Parse a string           // The tokenizer already checked the string for invalid           // surrogate pairs' so just call the CBORObject           // constructor directly           obj = CBORObject.FromRaw(this.NextJSONString());           nextChar[0] = this.SkipWhitespaceJSON();           return obj;         }         case '{': {           // Parse an object           obj = this.ParseJSONObject(depth + 1);           nextChar[0] = this.SkipWhitespaceJSON();           return obj;         }         case '[': {           // Parse an array           obj = this.ParseJSONArray(depth + 1);           nextChar[0] = this.SkipWhitespaceJSON();           return obj;         }         case 't': {           // Parse true           if (this.endPos - this.index <= 2 ||             (((int)this.jstring[this.index]) & 0xFF) != 'r' ||             (((int)this.jstring[this.index + 1]) & 0xFF) != 'u' ||             (((int)this.jstring[this.index + 2]) & 0xFF) != 'e') {             this.RaiseError("Value can't be parsed.");           }           this.index += 3;           nextChar[0] = this.SkipWhitespaceJSON();           return CBORObject.True;         }         case 'f': {           // Parse false           if (this.endPos - this.index <= 3 ||             (((int)this.jstring[this.index]) & 0xFF) != 'a' ||             (((int)this.jstring[this.index + 1]) & 0xFF) != 'l' ||             (((int)this.jstring[this.index + 2]) & 0xFF) != 's' ||             (((int)this.jstring[this.index + 3]) & 0xFF) != 'e') {             this.RaiseError("Value can't be parsed.");           }           this.index += 4;           nextChar[0] = this.SkipWhitespaceJSON();           return CBORObject.False;         }         case 'n': {           // Parse null           if (this.endPos - this.index <= 2 ||             (((int)this.jstring[this.index]) & 0xFF) != 'u' ||             (((int)this.jstring[this.index + 1]) & 0xFF) != 'l' ||             (((int)this.jstring[this.index + 2]) & 0xFF) != 'l') {             this.RaiseError("Value can't be parsed.");           }           this.index += 3;           nextChar[0] = this.SkipWhitespaceJSON();           return CBORObject.Null;         }         case '-': {           // Parse a negative number           return this.NextJSONNegativeNumber(nextChar);         }         case '0':         case '1':         case '2':         case '3':         case '4':         case '5':         case '6':         case '7':         case '8':         case '9': {           // Parse a nonnegative number           return this.NextJSONNonnegativeNumber(c' nextChar);         }         default:           this.RaiseError("Value can't be parsed.");           break;       }
Magic Number,PeterO.Cbor,CBORJson3,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORJson3.cs,NextJSONValue,The following statement contains a magic number: switch (c) {         case '"': {           // Parse a string           // The tokenizer already checked the string for invalid           // surrogate pairs' so just call the CBORObject           // constructor directly           obj = CBORObject.FromRaw(this.NextJSONString());           nextChar[0] = this.SkipWhitespaceJSON();           return obj;         }         case '{': {           // Parse an object           obj = this.ParseJSONObject(depth + 1);           nextChar[0] = this.SkipWhitespaceJSON();           return obj;         }         case '[': {           // Parse an array           obj = this.ParseJSONArray(depth + 1);           nextChar[0] = this.SkipWhitespaceJSON();           return obj;         }         case 't': {           // Parse true           if (this.endPos - this.index <= 2 ||             (((int)this.jstring[this.index]) & 0xFF) != 'r' ||             (((int)this.jstring[this.index + 1]) & 0xFF) != 'u' ||             (((int)this.jstring[this.index + 2]) & 0xFF) != 'e') {             this.RaiseError("Value can't be parsed.");           }           this.index += 3;           nextChar[0] = this.SkipWhitespaceJSON();           return CBORObject.True;         }         case 'f': {           // Parse false           if (this.endPos - this.index <= 3 ||             (((int)this.jstring[this.index]) & 0xFF) != 'a' ||             (((int)this.jstring[this.index + 1]) & 0xFF) != 'l' ||             (((int)this.jstring[this.index + 2]) & 0xFF) != 's' ||             (((int)this.jstring[this.index + 3]) & 0xFF) != 'e') {             this.RaiseError("Value can't be parsed.");           }           this.index += 4;           nextChar[0] = this.SkipWhitespaceJSON();           return CBORObject.False;         }         case 'n': {           // Parse null           if (this.endPos - this.index <= 2 ||             (((int)this.jstring[this.index]) & 0xFF) != 'u' ||             (((int)this.jstring[this.index + 1]) & 0xFF) != 'l' ||             (((int)this.jstring[this.index + 2]) & 0xFF) != 'l') {             this.RaiseError("Value can't be parsed.");           }           this.index += 3;           nextChar[0] = this.SkipWhitespaceJSON();           return CBORObject.Null;         }         case '-': {           // Parse a negative number           return this.NextJSONNegativeNumber(nextChar);         }         case '0':         case '1':         case '2':         case '3':         case '4':         case '5':         case '6':         case '7':         case '8':         case '9': {           // Parse a nonnegative number           return this.NextJSONNonnegativeNumber(c' nextChar);         }         default:           this.RaiseError("Value can't be parsed.");           break;       }
Magic Number,PeterO.Cbor,CBORJson3,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORJson3.cs,NextJSONValue,The following statement contains a magic number: switch (c) {         case '"': {           // Parse a string           // The tokenizer already checked the string for invalid           // surrogate pairs' so just call the CBORObject           // constructor directly           obj = CBORObject.FromRaw(this.NextJSONString());           nextChar[0] = this.SkipWhitespaceJSON();           return obj;         }         case '{': {           // Parse an object           obj = this.ParseJSONObject(depth + 1);           nextChar[0] = this.SkipWhitespaceJSON();           return obj;         }         case '[': {           // Parse an array           obj = this.ParseJSONArray(depth + 1);           nextChar[0] = this.SkipWhitespaceJSON();           return obj;         }         case 't': {           // Parse true           if (this.endPos - this.index <= 2 ||             (((int)this.jstring[this.index]) & 0xFF) != 'r' ||             (((int)this.jstring[this.index + 1]) & 0xFF) != 'u' ||             (((int)this.jstring[this.index + 2]) & 0xFF) != 'e') {             this.RaiseError("Value can't be parsed.");           }           this.index += 3;           nextChar[0] = this.SkipWhitespaceJSON();           return CBORObject.True;         }         case 'f': {           // Parse false           if (this.endPos - this.index <= 3 ||             (((int)this.jstring[this.index]) & 0xFF) != 'a' ||             (((int)this.jstring[this.index + 1]) & 0xFF) != 'l' ||             (((int)this.jstring[this.index + 2]) & 0xFF) != 's' ||             (((int)this.jstring[this.index + 3]) & 0xFF) != 'e') {             this.RaiseError("Value can't be parsed.");           }           this.index += 4;           nextChar[0] = this.SkipWhitespaceJSON();           return CBORObject.False;         }         case 'n': {           // Parse null           if (this.endPos - this.index <= 2 ||             (((int)this.jstring[this.index]) & 0xFF) != 'u' ||             (((int)this.jstring[this.index + 1]) & 0xFF) != 'l' ||             (((int)this.jstring[this.index + 2]) & 0xFF) != 'l') {             this.RaiseError("Value can't be parsed.");           }           this.index += 3;           nextChar[0] = this.SkipWhitespaceJSON();           return CBORObject.Null;         }         case '-': {           // Parse a negative number           return this.NextJSONNegativeNumber(nextChar);         }         case '0':         case '1':         case '2':         case '3':         case '4':         case '5':         case '6':         case '7':         case '8':         case '9': {           // Parse a nonnegative number           return this.NextJSONNonnegativeNumber(c' nextChar);         }         default:           this.RaiseError("Value can't be parsed.");           break;       }
Magic Number,PeterO.Cbor,CBORJson3,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORJson3.cs,NextJSONValue,The following statement contains a magic number: switch (c) {         case '"': {           // Parse a string           // The tokenizer already checked the string for invalid           // surrogate pairs' so just call the CBORObject           // constructor directly           obj = CBORObject.FromRaw(this.NextJSONString());           nextChar[0] = this.SkipWhitespaceJSON();           return obj;         }         case '{': {           // Parse an object           obj = this.ParseJSONObject(depth + 1);           nextChar[0] = this.SkipWhitespaceJSON();           return obj;         }         case '[': {           // Parse an array           obj = this.ParseJSONArray(depth + 1);           nextChar[0] = this.SkipWhitespaceJSON();           return obj;         }         case 't': {           // Parse true           if (this.endPos - this.index <= 2 ||             (((int)this.jstring[this.index]) & 0xFF) != 'r' ||             (((int)this.jstring[this.index + 1]) & 0xFF) != 'u' ||             (((int)this.jstring[this.index + 2]) & 0xFF) != 'e') {             this.RaiseError("Value can't be parsed.");           }           this.index += 3;           nextChar[0] = this.SkipWhitespaceJSON();           return CBORObject.True;         }         case 'f': {           // Parse false           if (this.endPos - this.index <= 3 ||             (((int)this.jstring[this.index]) & 0xFF) != 'a' ||             (((int)this.jstring[this.index + 1]) & 0xFF) != 'l' ||             (((int)this.jstring[this.index + 2]) & 0xFF) != 's' ||             (((int)this.jstring[this.index + 3]) & 0xFF) != 'e') {             this.RaiseError("Value can't be parsed.");           }           this.index += 4;           nextChar[0] = this.SkipWhitespaceJSON();           return CBORObject.False;         }         case 'n': {           // Parse null           if (this.endPos - this.index <= 2 ||             (((int)this.jstring[this.index]) & 0xFF) != 'u' ||             (((int)this.jstring[this.index + 1]) & 0xFF) != 'l' ||             (((int)this.jstring[this.index + 2]) & 0xFF) != 'l') {             this.RaiseError("Value can't be parsed.");           }           this.index += 3;           nextChar[0] = this.SkipWhitespaceJSON();           return CBORObject.Null;         }         case '-': {           // Parse a negative number           return this.NextJSONNegativeNumber(nextChar);         }         case '0':         case '1':         case '2':         case '3':         case '4':         case '5':         case '6':         case '7':         case '8':         case '9': {           // Parse a nonnegative number           return this.NextJSONNonnegativeNumber(c' nextChar);         }         default:           this.RaiseError("Value can't be parsed.");           break;       }
Magic Number,PeterO.Cbor,CBORJson3,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORJson3.cs,NextJSONValue,The following statement contains a magic number: switch (c) {         case '"': {           // Parse a string           // The tokenizer already checked the string for invalid           // surrogate pairs' so just call the CBORObject           // constructor directly           obj = CBORObject.FromRaw(this.NextJSONString());           nextChar[0] = this.SkipWhitespaceJSON();           return obj;         }         case '{': {           // Parse an object           obj = this.ParseJSONObject(depth + 1);           nextChar[0] = this.SkipWhitespaceJSON();           return obj;         }         case '[': {           // Parse an array           obj = this.ParseJSONArray(depth + 1);           nextChar[0] = this.SkipWhitespaceJSON();           return obj;         }         case 't': {           // Parse true           if (this.endPos - this.index <= 2 ||             (((int)this.jstring[this.index]) & 0xFF) != 'r' ||             (((int)this.jstring[this.index + 1]) & 0xFF) != 'u' ||             (((int)this.jstring[this.index + 2]) & 0xFF) != 'e') {             this.RaiseError("Value can't be parsed.");           }           this.index += 3;           nextChar[0] = this.SkipWhitespaceJSON();           return CBORObject.True;         }         case 'f': {           // Parse false           if (this.endPos - this.index <= 3 ||             (((int)this.jstring[this.index]) & 0xFF) != 'a' ||             (((int)this.jstring[this.index + 1]) & 0xFF) != 'l' ||             (((int)this.jstring[this.index + 2]) & 0xFF) != 's' ||             (((int)this.jstring[this.index + 3]) & 0xFF) != 'e') {             this.RaiseError("Value can't be parsed.");           }           this.index += 4;           nextChar[0] = this.SkipWhitespaceJSON();           return CBORObject.False;         }         case 'n': {           // Parse null           if (this.endPos - this.index <= 2 ||             (((int)this.jstring[this.index]) & 0xFF) != 'u' ||             (((int)this.jstring[this.index + 1]) & 0xFF) != 'l' ||             (((int)this.jstring[this.index + 2]) & 0xFF) != 'l') {             this.RaiseError("Value can't be parsed.");           }           this.index += 3;           nextChar[0] = this.SkipWhitespaceJSON();           return CBORObject.Null;         }         case '-': {           // Parse a negative number           return this.NextJSONNegativeNumber(nextChar);         }         case '0':         case '1':         case '2':         case '3':         case '4':         case '5':         case '6':         case '7':         case '8':         case '9': {           // Parse a nonnegative number           return this.NextJSONNonnegativeNumber(c' nextChar);         }         default:           this.RaiseError("Value can't be parsed.");           break;       }
Magic Number,PeterO.Cbor,CBORJson3,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORJson3.cs,ParseJSONObject,The following statement contains a magic number: depth > 1000
Magic Number,PeterO.Cbor,CBORJson3,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORJson3.cs,ParseJSONArray,The following statement contains a magic number: depth > 1000
Magic Number,PeterO.Cbor,CBORJsonWriter,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORJsonWriter.cs,WriteJSONToInternal,The following statement contains a magic number: switch (obj.Type) {         case CBORType.Integer:         case CBORType.FloatingPoint: {           CBORObject untaggedObj = obj.Untag();           writer.WriteString(             CBORNumber.FromCBORObject(untaggedObj).ToJSONString());           break;         }         case CBORType.Boolean: {           if (obj.IsTrue) {             writer.WriteString("true");             return;           }           if (obj.IsFalse) {             writer.WriteString("false");             return;           }           return;         }         case CBORType.SimpleValue: {           writer.WriteString("null");           return;         }         case CBORType.ByteString: {           byte[] byteArray = obj.GetByteString();           if (byteArray.Length == 0) {             writer.WriteString("\"\"");             return;           }           writer.WriteCodePoint((int)'\"');           if (obj.HasTag(22)) {             // Base64 with padding             Base64.WriteBase64(               writer'               byteArray'               0'               byteArray.Length'               true);           } else if (obj.HasTag(23)) {             // Write as base16             for (int i = 0; i < byteArray.Length; ++i) {               writer.WriteCodePoint((int)Hex16[(byteArray[i] >> 4) & 15]);               writer.WriteCodePoint((int)Hex16[byteArray[i] & 15]);             }           } else {             // Base64url no padding             Base64.WriteBase64URL(               writer'               byteArray'               0'               byteArray.Length'               false);           }           writer.WriteCodePoint((int)'\"');           break;         }         case CBORType.TextString: {           string thisString = obj.AsString();           if (thisString.Length == 0) {             writer.WriteString("\"\"");             return;           }           writer.WriteCodePoint((int)'\"');           WriteJSONStringUnquoted(thisString' writer' options);           writer.WriteCodePoint((int)'\"');           break;         }         case CBORType.Array: {           writer.WriteCodePoint((int)'[');           for (var i = 0; i < obj.Count; ++i) {             if (i > 0) {               writer.WriteCodePoint((int)''');             }             bool pop = CheckCircularRef(stack' obj' obj[i]);             WriteJSONToInternal(obj[i]' writer' options' stack);             PopRefIfNeeded(stack' pop);           }           writer.WriteCodePoint((int)']');           break;         }         case CBORType.Map: {           var first = true;           var hasNonStringKeys = false;           ICollection<KeyValuePair<CBORObject' CBORObject>> entries =             obj.Entries;           foreach (KeyValuePair<CBORObject' CBORObject> entry in entries) {             CBORObject key = entry.Key;             if (key.Type != CBORType.TextString ||               key.IsTagged) {               // treat a non-text-string item or a tagged item               // as having non-string keys               hasNonStringKeys = true;               break;             }           }           if (!hasNonStringKeys) {             writer.WriteCodePoint((int)'{');             foreach (KeyValuePair<CBORObject' CBORObject> entry in entries) {               CBORObject key = entry.Key;               CBORObject value = entry.Value;               if (!first) {                 writer.WriteCodePoint((int)''');               }               writer.WriteCodePoint((int)'\"');               WriteJSONStringUnquoted(key.AsString()' writer' options);               writer.WriteCodePoint((int)'\"');               writer.WriteCodePoint((int)':');               bool pop = CheckCircularRef(stack' obj' value);               WriteJSONToInternal(value' writer' options' stack);               PopRefIfNeeded(stack' pop);               first = false;             }             writer.WriteCodePoint((int)'}');           } else {             // This map has non-string keys             IDictionary<string' CBORObject> stringMap = new             Dictionary<string' CBORObject>();             // Copy to a map with String keys' since             // some keys could be duplicates             // when serialized to strings             foreach (KeyValuePair<CBORObject' CBORObject> entry               in entries) {               CBORObject key = entry.Key;               CBORObject value = entry.Value;               string str = null;               switch (key.Type) {                 case CBORType.TextString:                   str = key.AsString();                   break;                 case CBORType.Array:                 case CBORType.Map: {                   var sb = new StringBuilder();                   var sw = new StringOutput(sb);                   bool pop = CheckCircularRef(stack' obj' key);                   WriteJSONToInternal(key' sw' options' stack);                   PopRefIfNeeded(stack' pop);                   str = sb.ToString();                   break;                 }                 default: str = key.ToJSONString(options);                   break;               }               if (stringMap.ContainsKey(str)) {                 throw new CBORException(                   "Duplicate JSON string equivalents of map" +                   "\u0020keys");               }               stringMap[str] = value;             }             first = true;             writer.WriteCodePoint((int)'{');             foreach (KeyValuePair<string' CBORObject> entry in stringMap) {               string key = entry.Key;               CBORObject value = entry.Value;               if (!first) {                 writer.WriteCodePoint((int)''');               }               writer.WriteCodePoint((int)'\"');               WriteJSONStringUnquoted((string)key' writer' options);               writer.WriteCodePoint((int)'\"');               writer.WriteCodePoint((int)':');               bool pop = CheckCircularRef(stack' obj' value);               WriteJSONToInternal(value' writer' options' stack);               PopRefIfNeeded(stack' pop);               first = false;             }             writer.WriteCodePoint((int)'}');           }           break;         }         default:           throw new InvalidOperationException("Unexpected item" +             "\u0020type");       }
Magic Number,PeterO.Cbor,CBORJsonWriter,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORJsonWriter.cs,WriteJSONToInternal,The following statement contains a magic number: switch (obj.Type) {         case CBORType.Integer:         case CBORType.FloatingPoint: {           CBORObject untaggedObj = obj.Untag();           writer.WriteString(             CBORNumber.FromCBORObject(untaggedObj).ToJSONString());           break;         }         case CBORType.Boolean: {           if (obj.IsTrue) {             writer.WriteString("true");             return;           }           if (obj.IsFalse) {             writer.WriteString("false");             return;           }           return;         }         case CBORType.SimpleValue: {           writer.WriteString("null");           return;         }         case CBORType.ByteString: {           byte[] byteArray = obj.GetByteString();           if (byteArray.Length == 0) {             writer.WriteString("\"\"");             return;           }           writer.WriteCodePoint((int)'\"');           if (obj.HasTag(22)) {             // Base64 with padding             Base64.WriteBase64(               writer'               byteArray'               0'               byteArray.Length'               true);           } else if (obj.HasTag(23)) {             // Write as base16             for (int i = 0; i < byteArray.Length; ++i) {               writer.WriteCodePoint((int)Hex16[(byteArray[i] >> 4) & 15]);               writer.WriteCodePoint((int)Hex16[byteArray[i] & 15]);             }           } else {             // Base64url no padding             Base64.WriteBase64URL(               writer'               byteArray'               0'               byteArray.Length'               false);           }           writer.WriteCodePoint((int)'\"');           break;         }         case CBORType.TextString: {           string thisString = obj.AsString();           if (thisString.Length == 0) {             writer.WriteString("\"\"");             return;           }           writer.WriteCodePoint((int)'\"');           WriteJSONStringUnquoted(thisString' writer' options);           writer.WriteCodePoint((int)'\"');           break;         }         case CBORType.Array: {           writer.WriteCodePoint((int)'[');           for (var i = 0; i < obj.Count; ++i) {             if (i > 0) {               writer.WriteCodePoint((int)''');             }             bool pop = CheckCircularRef(stack' obj' obj[i]);             WriteJSONToInternal(obj[i]' writer' options' stack);             PopRefIfNeeded(stack' pop);           }           writer.WriteCodePoint((int)']');           break;         }         case CBORType.Map: {           var first = true;           var hasNonStringKeys = false;           ICollection<KeyValuePair<CBORObject' CBORObject>> entries =             obj.Entries;           foreach (KeyValuePair<CBORObject' CBORObject> entry in entries) {             CBORObject key = entry.Key;             if (key.Type != CBORType.TextString ||               key.IsTagged) {               // treat a non-text-string item or a tagged item               // as having non-string keys               hasNonStringKeys = true;               break;             }           }           if (!hasNonStringKeys) {             writer.WriteCodePoint((int)'{');             foreach (KeyValuePair<CBORObject' CBORObject> entry in entries) {               CBORObject key = entry.Key;               CBORObject value = entry.Value;               if (!first) {                 writer.WriteCodePoint((int)''');               }               writer.WriteCodePoint((int)'\"');               WriteJSONStringUnquoted(key.AsString()' writer' options);               writer.WriteCodePoint((int)'\"');               writer.WriteCodePoint((int)':');               bool pop = CheckCircularRef(stack' obj' value);               WriteJSONToInternal(value' writer' options' stack);               PopRefIfNeeded(stack' pop);               first = false;             }             writer.WriteCodePoint((int)'}');           } else {             // This map has non-string keys             IDictionary<string' CBORObject> stringMap = new             Dictionary<string' CBORObject>();             // Copy to a map with String keys' since             // some keys could be duplicates             // when serialized to strings             foreach (KeyValuePair<CBORObject' CBORObject> entry               in entries) {               CBORObject key = entry.Key;               CBORObject value = entry.Value;               string str = null;               switch (key.Type) {                 case CBORType.TextString:                   str = key.AsString();                   break;                 case CBORType.Array:                 case CBORType.Map: {                   var sb = new StringBuilder();                   var sw = new StringOutput(sb);                   bool pop = CheckCircularRef(stack' obj' key);                   WriteJSONToInternal(key' sw' options' stack);                   PopRefIfNeeded(stack' pop);                   str = sb.ToString();                   break;                 }                 default: str = key.ToJSONString(options);                   break;               }               if (stringMap.ContainsKey(str)) {                 throw new CBORException(                   "Duplicate JSON string equivalents of map" +                   "\u0020keys");               }               stringMap[str] = value;             }             first = true;             writer.WriteCodePoint((int)'{');             foreach (KeyValuePair<string' CBORObject> entry in stringMap) {               string key = entry.Key;               CBORObject value = entry.Value;               if (!first) {                 writer.WriteCodePoint((int)''');               }               writer.WriteCodePoint((int)'\"');               WriteJSONStringUnquoted((string)key' writer' options);               writer.WriteCodePoint((int)'\"');               writer.WriteCodePoint((int)':');               bool pop = CheckCircularRef(stack' obj' value);               WriteJSONToInternal(value' writer' options' stack);               PopRefIfNeeded(stack' pop);               first = false;             }             writer.WriteCodePoint((int)'}');           }           break;         }         default:           throw new InvalidOperationException("Unexpected item" +             "\u0020type");       }
Magic Number,PeterO.Cbor,CBORJsonWriter,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORJsonWriter.cs,WriteJSONToInternal,The following statement contains a magic number: switch (obj.Type) {         case CBORType.Integer:         case CBORType.FloatingPoint: {           CBORObject untaggedObj = obj.Untag();           writer.WriteString(             CBORNumber.FromCBORObject(untaggedObj).ToJSONString());           break;         }         case CBORType.Boolean: {           if (obj.IsTrue) {             writer.WriteString("true");             return;           }           if (obj.IsFalse) {             writer.WriteString("false");             return;           }           return;         }         case CBORType.SimpleValue: {           writer.WriteString("null");           return;         }         case CBORType.ByteString: {           byte[] byteArray = obj.GetByteString();           if (byteArray.Length == 0) {             writer.WriteString("\"\"");             return;           }           writer.WriteCodePoint((int)'\"');           if (obj.HasTag(22)) {             // Base64 with padding             Base64.WriteBase64(               writer'               byteArray'               0'               byteArray.Length'               true);           } else if (obj.HasTag(23)) {             // Write as base16             for (int i = 0; i < byteArray.Length; ++i) {               writer.WriteCodePoint((int)Hex16[(byteArray[i] >> 4) & 15]);               writer.WriteCodePoint((int)Hex16[byteArray[i] & 15]);             }           } else {             // Base64url no padding             Base64.WriteBase64URL(               writer'               byteArray'               0'               byteArray.Length'               false);           }           writer.WriteCodePoint((int)'\"');           break;         }         case CBORType.TextString: {           string thisString = obj.AsString();           if (thisString.Length == 0) {             writer.WriteString("\"\"");             return;           }           writer.WriteCodePoint((int)'\"');           WriteJSONStringUnquoted(thisString' writer' options);           writer.WriteCodePoint((int)'\"');           break;         }         case CBORType.Array: {           writer.WriteCodePoint((int)'[');           for (var i = 0; i < obj.Count; ++i) {             if (i > 0) {               writer.WriteCodePoint((int)''');             }             bool pop = CheckCircularRef(stack' obj' obj[i]);             WriteJSONToInternal(obj[i]' writer' options' stack);             PopRefIfNeeded(stack' pop);           }           writer.WriteCodePoint((int)']');           break;         }         case CBORType.Map: {           var first = true;           var hasNonStringKeys = false;           ICollection<KeyValuePair<CBORObject' CBORObject>> entries =             obj.Entries;           foreach (KeyValuePair<CBORObject' CBORObject> entry in entries) {             CBORObject key = entry.Key;             if (key.Type != CBORType.TextString ||               key.IsTagged) {               // treat a non-text-string item or a tagged item               // as having non-string keys               hasNonStringKeys = true;               break;             }           }           if (!hasNonStringKeys) {             writer.WriteCodePoint((int)'{');             foreach (KeyValuePair<CBORObject' CBORObject> entry in entries) {               CBORObject key = entry.Key;               CBORObject value = entry.Value;               if (!first) {                 writer.WriteCodePoint((int)''');               }               writer.WriteCodePoint((int)'\"');               WriteJSONStringUnquoted(key.AsString()' writer' options);               writer.WriteCodePoint((int)'\"');               writer.WriteCodePoint((int)':');               bool pop = CheckCircularRef(stack' obj' value);               WriteJSONToInternal(value' writer' options' stack);               PopRefIfNeeded(stack' pop);               first = false;             }             writer.WriteCodePoint((int)'}');           } else {             // This map has non-string keys             IDictionary<string' CBORObject> stringMap = new             Dictionary<string' CBORObject>();             // Copy to a map with String keys' since             // some keys could be duplicates             // when serialized to strings             foreach (KeyValuePair<CBORObject' CBORObject> entry               in entries) {               CBORObject key = entry.Key;               CBORObject value = entry.Value;               string str = null;               switch (key.Type) {                 case CBORType.TextString:                   str = key.AsString();                   break;                 case CBORType.Array:                 case CBORType.Map: {                   var sb = new StringBuilder();                   var sw = new StringOutput(sb);                   bool pop = CheckCircularRef(stack' obj' key);                   WriteJSONToInternal(key' sw' options' stack);                   PopRefIfNeeded(stack' pop);                   str = sb.ToString();                   break;                 }                 default: str = key.ToJSONString(options);                   break;               }               if (stringMap.ContainsKey(str)) {                 throw new CBORException(                   "Duplicate JSON string equivalents of map" +                   "\u0020keys");               }               stringMap[str] = value;             }             first = true;             writer.WriteCodePoint((int)'{');             foreach (KeyValuePair<string' CBORObject> entry in stringMap) {               string key = entry.Key;               CBORObject value = entry.Value;               if (!first) {                 writer.WriteCodePoint((int)''');               }               writer.WriteCodePoint((int)'\"');               WriteJSONStringUnquoted((string)key' writer' options);               writer.WriteCodePoint((int)'\"');               writer.WriteCodePoint((int)':');               bool pop = CheckCircularRef(stack' obj' value);               WriteJSONToInternal(value' writer' options' stack);               PopRefIfNeeded(stack' pop);               first = false;             }             writer.WriteCodePoint((int)'}');           }           break;         }         default:           throw new InvalidOperationException("Unexpected item" +             "\u0020type");       }
Magic Number,PeterO.Cbor,CBORJsonWriter,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORJsonWriter.cs,WriteJSONToInternal,The following statement contains a magic number: switch (obj.Type) {         case CBORType.Integer:         case CBORType.FloatingPoint: {           CBORObject untaggedObj = obj.Untag();           writer.WriteString(             CBORNumber.FromCBORObject(untaggedObj).ToJSONString());           break;         }         case CBORType.Boolean: {           if (obj.IsTrue) {             writer.WriteString("true");             return;           }           if (obj.IsFalse) {             writer.WriteString("false");             return;           }           return;         }         case CBORType.SimpleValue: {           writer.WriteString("null");           return;         }         case CBORType.ByteString: {           byte[] byteArray = obj.GetByteString();           if (byteArray.Length == 0) {             writer.WriteString("\"\"");             return;           }           writer.WriteCodePoint((int)'\"');           if (obj.HasTag(22)) {             // Base64 with padding             Base64.WriteBase64(               writer'               byteArray'               0'               byteArray.Length'               true);           } else if (obj.HasTag(23)) {             // Write as base16             for (int i = 0; i < byteArray.Length; ++i) {               writer.WriteCodePoint((int)Hex16[(byteArray[i] >> 4) & 15]);               writer.WriteCodePoint((int)Hex16[byteArray[i] & 15]);             }           } else {             // Base64url no padding             Base64.WriteBase64URL(               writer'               byteArray'               0'               byteArray.Length'               false);           }           writer.WriteCodePoint((int)'\"');           break;         }         case CBORType.TextString: {           string thisString = obj.AsString();           if (thisString.Length == 0) {             writer.WriteString("\"\"");             return;           }           writer.WriteCodePoint((int)'\"');           WriteJSONStringUnquoted(thisString' writer' options);           writer.WriteCodePoint((int)'\"');           break;         }         case CBORType.Array: {           writer.WriteCodePoint((int)'[');           for (var i = 0; i < obj.Count; ++i) {             if (i > 0) {               writer.WriteCodePoint((int)''');             }             bool pop = CheckCircularRef(stack' obj' obj[i]);             WriteJSONToInternal(obj[i]' writer' options' stack);             PopRefIfNeeded(stack' pop);           }           writer.WriteCodePoint((int)']');           break;         }         case CBORType.Map: {           var first = true;           var hasNonStringKeys = false;           ICollection<KeyValuePair<CBORObject' CBORObject>> entries =             obj.Entries;           foreach (KeyValuePair<CBORObject' CBORObject> entry in entries) {             CBORObject key = entry.Key;             if (key.Type != CBORType.TextString ||               key.IsTagged) {               // treat a non-text-string item or a tagged item               // as having non-string keys               hasNonStringKeys = true;               break;             }           }           if (!hasNonStringKeys) {             writer.WriteCodePoint((int)'{');             foreach (KeyValuePair<CBORObject' CBORObject> entry in entries) {               CBORObject key = entry.Key;               CBORObject value = entry.Value;               if (!first) {                 writer.WriteCodePoint((int)''');               }               writer.WriteCodePoint((int)'\"');               WriteJSONStringUnquoted(key.AsString()' writer' options);               writer.WriteCodePoint((int)'\"');               writer.WriteCodePoint((int)':');               bool pop = CheckCircularRef(stack' obj' value);               WriteJSONToInternal(value' writer' options' stack);               PopRefIfNeeded(stack' pop);               first = false;             }             writer.WriteCodePoint((int)'}');           } else {             // This map has non-string keys             IDictionary<string' CBORObject> stringMap = new             Dictionary<string' CBORObject>();             // Copy to a map with String keys' since             // some keys could be duplicates             // when serialized to strings             foreach (KeyValuePair<CBORObject' CBORObject> entry               in entries) {               CBORObject key = entry.Key;               CBORObject value = entry.Value;               string str = null;               switch (key.Type) {                 case CBORType.TextString:                   str = key.AsString();                   break;                 case CBORType.Array:                 case CBORType.Map: {                   var sb = new StringBuilder();                   var sw = new StringOutput(sb);                   bool pop = CheckCircularRef(stack' obj' key);                   WriteJSONToInternal(key' sw' options' stack);                   PopRefIfNeeded(stack' pop);                   str = sb.ToString();                   break;                 }                 default: str = key.ToJSONString(options);                   break;               }               if (stringMap.ContainsKey(str)) {                 throw new CBORException(                   "Duplicate JSON string equivalents of map" +                   "\u0020keys");               }               stringMap[str] = value;             }             first = true;             writer.WriteCodePoint((int)'{');             foreach (KeyValuePair<string' CBORObject> entry in stringMap) {               string key = entry.Key;               CBORObject value = entry.Value;               if (!first) {                 writer.WriteCodePoint((int)''');               }               writer.WriteCodePoint((int)'\"');               WriteJSONStringUnquoted((string)key' writer' options);               writer.WriteCodePoint((int)'\"');               writer.WriteCodePoint((int)':');               bool pop = CheckCircularRef(stack' obj' value);               WriteJSONToInternal(value' writer' options' stack);               PopRefIfNeeded(stack' pop);               first = false;             }             writer.WriteCodePoint((int)'}');           }           break;         }         default:           throw new InvalidOperationException("Unexpected item" +             "\u0020type");       }
Magic Number,PeterO.Cbor,CBORJsonWriter,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORJsonWriter.cs,WriteJSONToInternal,The following statement contains a magic number: switch (obj.Type) {         case CBORType.Integer:         case CBORType.FloatingPoint: {           CBORObject untaggedObj = obj.Untag();           writer.WriteString(             CBORNumber.FromCBORObject(untaggedObj).ToJSONString());           break;         }         case CBORType.Boolean: {           if (obj.IsTrue) {             writer.WriteString("true");             return;           }           if (obj.IsFalse) {             writer.WriteString("false");             return;           }           return;         }         case CBORType.SimpleValue: {           writer.WriteString("null");           return;         }         case CBORType.ByteString: {           byte[] byteArray = obj.GetByteString();           if (byteArray.Length == 0) {             writer.WriteString("\"\"");             return;           }           writer.WriteCodePoint((int)'\"');           if (obj.HasTag(22)) {             // Base64 with padding             Base64.WriteBase64(               writer'               byteArray'               0'               byteArray.Length'               true);           } else if (obj.HasTag(23)) {             // Write as base16             for (int i = 0; i < byteArray.Length; ++i) {               writer.WriteCodePoint((int)Hex16[(byteArray[i] >> 4) & 15]);               writer.WriteCodePoint((int)Hex16[byteArray[i] & 15]);             }           } else {             // Base64url no padding             Base64.WriteBase64URL(               writer'               byteArray'               0'               byteArray.Length'               false);           }           writer.WriteCodePoint((int)'\"');           break;         }         case CBORType.TextString: {           string thisString = obj.AsString();           if (thisString.Length == 0) {             writer.WriteString("\"\"");             return;           }           writer.WriteCodePoint((int)'\"');           WriteJSONStringUnquoted(thisString' writer' options);           writer.WriteCodePoint((int)'\"');           break;         }         case CBORType.Array: {           writer.WriteCodePoint((int)'[');           for (var i = 0; i < obj.Count; ++i) {             if (i > 0) {               writer.WriteCodePoint((int)''');             }             bool pop = CheckCircularRef(stack' obj' obj[i]);             WriteJSONToInternal(obj[i]' writer' options' stack);             PopRefIfNeeded(stack' pop);           }           writer.WriteCodePoint((int)']');           break;         }         case CBORType.Map: {           var first = true;           var hasNonStringKeys = false;           ICollection<KeyValuePair<CBORObject' CBORObject>> entries =             obj.Entries;           foreach (KeyValuePair<CBORObject' CBORObject> entry in entries) {             CBORObject key = entry.Key;             if (key.Type != CBORType.TextString ||               key.IsTagged) {               // treat a non-text-string item or a tagged item               // as having non-string keys               hasNonStringKeys = true;               break;             }           }           if (!hasNonStringKeys) {             writer.WriteCodePoint((int)'{');             foreach (KeyValuePair<CBORObject' CBORObject> entry in entries) {               CBORObject key = entry.Key;               CBORObject value = entry.Value;               if (!first) {                 writer.WriteCodePoint((int)''');               }               writer.WriteCodePoint((int)'\"');               WriteJSONStringUnquoted(key.AsString()' writer' options);               writer.WriteCodePoint((int)'\"');               writer.WriteCodePoint((int)':');               bool pop = CheckCircularRef(stack' obj' value);               WriteJSONToInternal(value' writer' options' stack);               PopRefIfNeeded(stack' pop);               first = false;             }             writer.WriteCodePoint((int)'}');           } else {             // This map has non-string keys             IDictionary<string' CBORObject> stringMap = new             Dictionary<string' CBORObject>();             // Copy to a map with String keys' since             // some keys could be duplicates             // when serialized to strings             foreach (KeyValuePair<CBORObject' CBORObject> entry               in entries) {               CBORObject key = entry.Key;               CBORObject value = entry.Value;               string str = null;               switch (key.Type) {                 case CBORType.TextString:                   str = key.AsString();                   break;                 case CBORType.Array:                 case CBORType.Map: {                   var sb = new StringBuilder();                   var sw = new StringOutput(sb);                   bool pop = CheckCircularRef(stack' obj' key);                   WriteJSONToInternal(key' sw' options' stack);                   PopRefIfNeeded(stack' pop);                   str = sb.ToString();                   break;                 }                 default: str = key.ToJSONString(options);                   break;               }               if (stringMap.ContainsKey(str)) {                 throw new CBORException(                   "Duplicate JSON string equivalents of map" +                   "\u0020keys");               }               stringMap[str] = value;             }             first = true;             writer.WriteCodePoint((int)'{');             foreach (KeyValuePair<string' CBORObject> entry in stringMap) {               string key = entry.Key;               CBORObject value = entry.Value;               if (!first) {                 writer.WriteCodePoint((int)''');               }               writer.WriteCodePoint((int)'\"');               WriteJSONStringUnquoted((string)key' writer' options);               writer.WriteCodePoint((int)'\"');               writer.WriteCodePoint((int)':');               bool pop = CheckCircularRef(stack' obj' value);               WriteJSONToInternal(value' writer' options' stack);               PopRefIfNeeded(stack' pop);               first = false;             }             writer.WriteCodePoint((int)'}');           }           break;         }         default:           throw new InvalidOperationException("Unexpected item" +             "\u0020type");       }
Magic Number,PeterO.Cbor,CBORNumber,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORNumber.cs,GetNumberInterface,The following statement contains a magic number: switch (kind) {         case NumberKind.Integer:           return NumberInterfaces[0];         case NumberKind.Double:           return NumberInterfaces[1];         case NumberKind.EInteger:           return NumberInterfaces[2];         case NumberKind.EDecimal:           return NumberInterfaces[3];         case NumberKind.EFloat:           return NumberInterfaces[4];         case NumberKind.ERational:           return NumberInterfaces[5];         default:           throw new InvalidOperationException();       }
Magic Number,PeterO.Cbor,CBORNumber,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORNumber.cs,GetNumberInterface,The following statement contains a magic number: switch (kind) {         case NumberKind.Integer:           return NumberInterfaces[0];         case NumberKind.Double:           return NumberInterfaces[1];         case NumberKind.EInteger:           return NumberInterfaces[2];         case NumberKind.EDecimal:           return NumberInterfaces[3];         case NumberKind.EFloat:           return NumberInterfaces[4];         case NumberKind.ERational:           return NumberInterfaces[5];         default:           throw new InvalidOperationException();       }
Magic Number,PeterO.Cbor,CBORNumber,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORNumber.cs,GetNumberInterface,The following statement contains a magic number: switch (kind) {         case NumberKind.Integer:           return NumberInterfaces[0];         case NumberKind.Double:           return NumberInterfaces[1];         case NumberKind.EInteger:           return NumberInterfaces[2];         case NumberKind.EDecimal:           return NumberInterfaces[3];         case NumberKind.EFloat:           return NumberInterfaces[4];         case NumberKind.ERational:           return NumberInterfaces[5];         default:           throw new InvalidOperationException();       }
Magic Number,PeterO.Cbor,CBORNumber,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORNumber.cs,GetNumberInterface,The following statement contains a magic number: switch (kind) {         case NumberKind.Integer:           return NumberInterfaces[0];         case NumberKind.Double:           return NumberInterfaces[1];         case NumberKind.EInteger:           return NumberInterfaces[2];         case NumberKind.EDecimal:           return NumberInterfaces[3];         case NumberKind.EFloat:           return NumberInterfaces[4];         case NumberKind.ERational:           return NumberInterfaces[5];         default:           throw new InvalidOperationException();       }
Magic Number,PeterO.Cbor,CBORNumber,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORNumber.cs,FromCBORObject,The following statement contains a magic number: o.HasOneTag(2) || o.HasOneTag(3)
Magic Number,PeterO.Cbor,CBORNumber,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORNumber.cs,FromCBORObject,The following statement contains a magic number: o.HasOneTag(2) || o.HasOneTag(3)
Magic Number,PeterO.Cbor,CBORNumber,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORNumber.cs,IsUntaggedIntegerOrBignum,The following statement contains a magic number: return IsUntaggedInteger(o) || ((o.HasOneTag(2) || o.HasOneTag(3)) &&           o.Type == CBORType.ByteString);
Magic Number,PeterO.Cbor,CBORNumber,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORNumber.cs,IsUntaggedIntegerOrBignum,The following statement contains a magic number: return IsUntaggedInteger(o) || ((o.HasOneTag(2) || o.HasOneTag(3)) &&           o.Type == CBORType.ByteString);
Magic Number,PeterO.Cbor,CBORNumber,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORNumber.cs,RationalToNumber,The following statement contains a magic number: o.Count != 3
Magic Number,PeterO.Cbor,CBORNumber,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORNumber.cs,RationalToNumber,The following statement contains a magic number: !IsUntaggedInteger(o[2])
Magic Number,PeterO.Cbor,CBORNumber,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORNumber.cs,RationalToNumber,The following statement contains a magic number: tagName == 270
Magic Number,PeterO.Cbor,CBORNumber,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORNumber.cs,RationalToNumber,The following statement contains a magic number: !o[2].CanValueFitInInt32()
Magic Number,PeterO.Cbor,CBORNumber,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORNumber.cs,RationalToNumber,The following statement contains a magic number: int options = o[2].AsInt32Value();
Magic Number,PeterO.Cbor,CBORNumber,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORNumber.cs,RationalToNumber,The following statement contains a magic number: switch (options) {           case 0:             break;           case 1:             erat = erat.Negate();             break;           case 2:             if (!numerator.IsZero || denominator.CompareTo(1) != 0) {               return null; // "invalid values");             }             erat = ERational.PositiveInfinity;             break;           case 3:             if (!numerator.IsZero || denominator.CompareTo(1) != 0) {               return null; // "invalid values");             }             erat = ERational.NegativeInfinity;             break;           case 4:           case 5:           case 6:           case 7:             if (denominator.CompareTo(1) != 0) {               return null; // "invalid values");             }             erat = ERational.CreateNaN(                 numerator'                 options >= 6'                 options == 5 || options == 7);             break;           default: return null; // "Invalid options");         }
Magic Number,PeterO.Cbor,CBORNumber,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORNumber.cs,RationalToNumber,The following statement contains a magic number: switch (options) {           case 0:             break;           case 1:             erat = erat.Negate();             break;           case 2:             if (!numerator.IsZero || denominator.CompareTo(1) != 0) {               return null; // "invalid values");             }             erat = ERational.PositiveInfinity;             break;           case 3:             if (!numerator.IsZero || denominator.CompareTo(1) != 0) {               return null; // "invalid values");             }             erat = ERational.NegativeInfinity;             break;           case 4:           case 5:           case 6:           case 7:             if (denominator.CompareTo(1) != 0) {               return null; // "invalid values");             }             erat = ERational.CreateNaN(                 numerator'                 options >= 6'                 options == 5 || options == 7);             break;           default: return null; // "Invalid options");         }
Magic Number,PeterO.Cbor,CBORNumber,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORNumber.cs,RationalToNumber,The following statement contains a magic number: switch (options) {           case 0:             break;           case 1:             erat = erat.Negate();             break;           case 2:             if (!numerator.IsZero || denominator.CompareTo(1) != 0) {               return null; // "invalid values");             }             erat = ERational.PositiveInfinity;             break;           case 3:             if (!numerator.IsZero || denominator.CompareTo(1) != 0) {               return null; // "invalid values");             }             erat = ERational.NegativeInfinity;             break;           case 4:           case 5:           case 6:           case 7:             if (denominator.CompareTo(1) != 0) {               return null; // "invalid values");             }             erat = ERational.CreateNaN(                 numerator'                 options >= 6'                 options == 5 || options == 7);             break;           default: return null; // "Invalid options");         }
Magic Number,PeterO.Cbor,CBORNumber,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORNumber.cs,RationalToNumber,The following statement contains a magic number: switch (options) {           case 0:             break;           case 1:             erat = erat.Negate();             break;           case 2:             if (!numerator.IsZero || denominator.CompareTo(1) != 0) {               return null; // "invalid values");             }             erat = ERational.PositiveInfinity;             break;           case 3:             if (!numerator.IsZero || denominator.CompareTo(1) != 0) {               return null; // "invalid values");             }             erat = ERational.NegativeInfinity;             break;           case 4:           case 5:           case 6:           case 7:             if (denominator.CompareTo(1) != 0) {               return null; // "invalid values");             }             erat = ERational.CreateNaN(                 numerator'                 options >= 6'                 options == 5 || options == 7);             break;           default: return null; // "Invalid options");         }
Magic Number,PeterO.Cbor,CBORNumber,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORNumber.cs,RationalToNumber,The following statement contains a magic number: switch (options) {           case 0:             break;           case 1:             erat = erat.Negate();             break;           case 2:             if (!numerator.IsZero || denominator.CompareTo(1) != 0) {               return null; // "invalid values");             }             erat = ERational.PositiveInfinity;             break;           case 3:             if (!numerator.IsZero || denominator.CompareTo(1) != 0) {               return null; // "invalid values");             }             erat = ERational.NegativeInfinity;             break;           case 4:           case 5:           case 6:           case 7:             if (denominator.CompareTo(1) != 0) {               return null; // "invalid values");             }             erat = ERational.CreateNaN(                 numerator'                 options >= 6'                 options == 5 || options == 7);             break;           default: return null; // "Invalid options");         }
Magic Number,PeterO.Cbor,CBORNumber,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORNumber.cs,RationalToNumber,The following statement contains a magic number: switch (options) {           case 0:             break;           case 1:             erat = erat.Negate();             break;           case 2:             if (!numerator.IsZero || denominator.CompareTo(1) != 0) {               return null; // "invalid values");             }             erat = ERational.PositiveInfinity;             break;           case 3:             if (!numerator.IsZero || denominator.CompareTo(1) != 0) {               return null; // "invalid values");             }             erat = ERational.NegativeInfinity;             break;           case 4:           case 5:           case 6:           case 7:             if (denominator.CompareTo(1) != 0) {               return null; // "invalid values");             }             erat = ERational.CreateNaN(                 numerator'                 options >= 6'                 options == 5 || options == 7);             break;           default: return null; // "Invalid options");         }
Magic Number,PeterO.Cbor,CBORNumber,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORNumber.cs,RationalToNumber,The following statement contains a magic number: switch (options) {           case 0:             break;           case 1:             erat = erat.Negate();             break;           case 2:             if (!numerator.IsZero || denominator.CompareTo(1) != 0) {               return null; // "invalid values");             }             erat = ERational.PositiveInfinity;             break;           case 3:             if (!numerator.IsZero || denominator.CompareTo(1) != 0) {               return null; // "invalid values");             }             erat = ERational.NegativeInfinity;             break;           case 4:           case 5:           case 6:           case 7:             if (denominator.CompareTo(1) != 0) {               return null; // "invalid values");             }             erat = ERational.CreateNaN(                 numerator'                 options >= 6'                 options == 5 || options == 7);             break;           default: return null; // "Invalid options");         }
Magic Number,PeterO.Cbor,CBORNumber,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORNumber.cs,RationalToNumber,The following statement contains a magic number: switch (options) {           case 0:             break;           case 1:             erat = erat.Negate();             break;           case 2:             if (!numerator.IsZero || denominator.CompareTo(1) != 0) {               return null; // "invalid values");             }             erat = ERational.PositiveInfinity;             break;           case 3:             if (!numerator.IsZero || denominator.CompareTo(1) != 0) {               return null; // "invalid values");             }             erat = ERational.NegativeInfinity;             break;           case 4:           case 5:           case 6:           case 7:             if (denominator.CompareTo(1) != 0) {               return null; // "invalid values");             }             erat = ERational.CreateNaN(                 numerator'                 options >= 6'                 options == 5 || options == 7);             break;           default: return null; // "Invalid options");         }
Magic Number,PeterO.Cbor,CBORNumber,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORNumber.cs,RationalToNumber,The following statement contains a magic number: switch (options) {           case 0:             break;           case 1:             erat = erat.Negate();             break;           case 2:             if (!numerator.IsZero || denominator.CompareTo(1) != 0) {               return null; // "invalid values");             }             erat = ERational.PositiveInfinity;             break;           case 3:             if (!numerator.IsZero || denominator.CompareTo(1) != 0) {               return null; // "invalid values");             }             erat = ERational.NegativeInfinity;             break;           case 4:           case 5:           case 6:           case 7:             if (denominator.CompareTo(1) != 0) {               return null; // "invalid values");             }             erat = ERational.CreateNaN(                 numerator'                 options >= 6'                 options == 5 || options == 7);             break;           default: return null; // "Invalid options");         }
Magic Number,PeterO.Cbor,CBORNumber,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORNumber.cs,RationalToNumber,The following statement contains a magic number: tagName == 270
Magic Number,PeterO.Cbor,CBORNumber,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORNumber.cs,CheckRationalToNumber,The following statement contains a magic number: o.Count != 3
Magic Number,PeterO.Cbor,CBORNumber,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORNumber.cs,CheckRationalToNumber,The following statement contains a magic number: !IsUntaggedInteger(o[2])
Magic Number,PeterO.Cbor,CBORNumber,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORNumber.cs,CheckRationalToNumber,The following statement contains a magic number: tagName == 270
Magic Number,PeterO.Cbor,CBORNumber,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORNumber.cs,CheckRationalToNumber,The following statement contains a magic number: numerator.Sign < 0 || !o[2].CanValueFitInInt32()
Magic Number,PeterO.Cbor,CBORNumber,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORNumber.cs,CheckRationalToNumber,The following statement contains a magic number: int options = o[2].AsInt32Value();
Magic Number,PeterO.Cbor,CBORNumber,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORNumber.cs,CheckRationalToNumber,The following statement contains a magic number: switch (options) {           case 0:           case 1:             return true;           case 2:           case 3:             return numerator.IsZero && denominator.CompareTo(1) == 0;           case 4:           case 5:           case 6:           case 7:             return denominator.CompareTo(1) == 0;           default:             return false;         }
Magic Number,PeterO.Cbor,CBORNumber,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORNumber.cs,CheckRationalToNumber,The following statement contains a magic number: switch (options) {           case 0:           case 1:             return true;           case 2:           case 3:             return numerator.IsZero && denominator.CompareTo(1) == 0;           case 4:           case 5:           case 6:           case 7:             return denominator.CompareTo(1) == 0;           default:             return false;         }
Magic Number,PeterO.Cbor,CBORNumber,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORNumber.cs,CheckRationalToNumber,The following statement contains a magic number: switch (options) {           case 0:           case 1:             return true;           case 2:           case 3:             return numerator.IsZero && denominator.CompareTo(1) == 0;           case 4:           case 5:           case 6:           case 7:             return denominator.CompareTo(1) == 0;           default:             return false;         }
Magic Number,PeterO.Cbor,CBORNumber,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORNumber.cs,CheckRationalToNumber,The following statement contains a magic number: switch (options) {           case 0:           case 1:             return true;           case 2:           case 3:             return numerator.IsZero && denominator.CompareTo(1) == 0;           case 4:           case 5:           case 6:           case 7:             return denominator.CompareTo(1) == 0;           default:             return false;         }
Magic Number,PeterO.Cbor,CBORNumber,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORNumber.cs,CheckRationalToNumber,The following statement contains a magic number: switch (options) {           case 0:           case 1:             return true;           case 2:           case 3:             return numerator.IsZero && denominator.CompareTo(1) == 0;           case 4:           case 5:           case 6:           case 7:             return denominator.CompareTo(1) == 0;           default:             return false;         }
Magic Number,PeterO.Cbor,CBORNumber,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORNumber.cs,CheckRationalToNumber,The following statement contains a magic number: switch (options) {           case 0:           case 1:             return true;           case 2:           case 3:             return numerator.IsZero && denominator.CompareTo(1) == 0;           case 4:           case 5:           case 6:           case 7:             return denominator.CompareTo(1) == 0;           default:             return false;         }
Magic Number,PeterO.Cbor,CBORNumber,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORNumber.cs,CheckRationalToNumber,The following statement contains a magic number: tagName == 270
Magic Number,PeterO.Cbor,CBORNumber,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORNumber.cs,CheckBigFracToNumber,The following statement contains a magic number: o.Count != 3
Magic Number,PeterO.Cbor,CBORNumber,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORNumber.cs,CheckBigFracToNumber,The following statement contains a magic number: !IsUntaggedInteger(o[2])
Magic Number,PeterO.Cbor,CBORNumber,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORNumber.cs,CheckBigFracToNumber,The following statement contains a magic number: tagName == 268 || tagName == 269
Magic Number,PeterO.Cbor,CBORNumber,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORNumber.cs,CheckBigFracToNumber,The following statement contains a magic number: tagName == 268 || tagName == 269
Magic Number,PeterO.Cbor,CBORNumber,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORNumber.cs,CheckBigFracToNumber,The following statement contains a magic number: tagName == 4 || tagName == 5
Magic Number,PeterO.Cbor,CBORNumber,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORNumber.cs,CheckBigFracToNumber,The following statement contains a magic number: tagName == 4 || tagName == 5
Magic Number,PeterO.Cbor,CBORNumber,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORNumber.cs,CheckBigFracToNumber,The following statement contains a magic number: mantissa.Sign < 0 || !o[2].CanValueFitInInt32()
Magic Number,PeterO.Cbor,CBORNumber,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORNumber.cs,CheckBigFracToNumber,The following statement contains a magic number: int options = o[2].AsInt32Value();
Magic Number,PeterO.Cbor,CBORNumber,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORNumber.cs,CheckBigFracToNumber,The following statement contains a magic number: switch (options) {           case 0:           case 1:             return true;           case 2:           case 3:             return exponent.IsZero && mantissa.IsZero;           case 4:           case 5:           case 6:           case 7:             return exponent.IsZero;           default:             return false;         }
Magic Number,PeterO.Cbor,CBORNumber,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORNumber.cs,CheckBigFracToNumber,The following statement contains a magic number: switch (options) {           case 0:           case 1:             return true;           case 2:           case 3:             return exponent.IsZero && mantissa.IsZero;           case 4:           case 5:           case 6:           case 7:             return exponent.IsZero;           default:             return false;         }
Magic Number,PeterO.Cbor,CBORNumber,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORNumber.cs,CheckBigFracToNumber,The following statement contains a magic number: switch (options) {           case 0:           case 1:             return true;           case 2:           case 3:             return exponent.IsZero && mantissa.IsZero;           case 4:           case 5:           case 6:           case 7:             return exponent.IsZero;           default:             return false;         }
Magic Number,PeterO.Cbor,CBORNumber,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORNumber.cs,CheckBigFracToNumber,The following statement contains a magic number: switch (options) {           case 0:           case 1:             return true;           case 2:           case 3:             return exponent.IsZero && mantissa.IsZero;           case 4:           case 5:           case 6:           case 7:             return exponent.IsZero;           default:             return false;         }
Magic Number,PeterO.Cbor,CBORNumber,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORNumber.cs,CheckBigFracToNumber,The following statement contains a magic number: switch (options) {           case 0:           case 1:             return true;           case 2:           case 3:             return exponent.IsZero && mantissa.IsZero;           case 4:           case 5:           case 6:           case 7:             return exponent.IsZero;           default:             return false;         }
Magic Number,PeterO.Cbor,CBORNumber,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORNumber.cs,CheckBigFracToNumber,The following statement contains a magic number: switch (options) {           case 0:           case 1:             return true;           case 2:           case 3:             return exponent.IsZero && mantissa.IsZero;           case 4:           case 5:           case 6:           case 7:             return exponent.IsZero;           default:             return false;         }
Magic Number,PeterO.Cbor,CBORNumber,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORNumber.cs,CheckBigFracToNumber,The following statement contains a magic number: tagName == 268 || tagName == 269
Magic Number,PeterO.Cbor,CBORNumber,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORNumber.cs,CheckBigFracToNumber,The following statement contains a magic number: tagName == 268 || tagName == 269
Magic Number,PeterO.Cbor,CBORNumber,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORNumber.cs,BigFracToNumber,The following statement contains a magic number: o.Count != 3
Magic Number,PeterO.Cbor,CBORNumber,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORNumber.cs,BigFracToNumber,The following statement contains a magic number: !IsUntaggedInteger(o[2])
Magic Number,PeterO.Cbor,CBORNumber,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORNumber.cs,BigFracToNumber,The following statement contains a magic number: tagName == 268 || tagName == 269
Magic Number,PeterO.Cbor,CBORNumber,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORNumber.cs,BigFracToNumber,The following statement contains a magic number: tagName == 268 || tagName == 269
Magic Number,PeterO.Cbor,CBORNumber,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORNumber.cs,BigFracToNumber,The following statement contains a magic number: tagName == 4 || tagName == 5
Magic Number,PeterO.Cbor,CBORNumber,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORNumber.cs,BigFracToNumber,The following statement contains a magic number: tagName == 4 || tagName == 5
Magic Number,PeterO.Cbor,CBORNumber,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORNumber.cs,BigFracToNumber,The following statement contains a magic number: bool isdec = tagName == 4 || tagName == 264 || tagName == 268;
Magic Number,PeterO.Cbor,CBORNumber,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORNumber.cs,BigFracToNumber,The following statement contains a magic number: bool isdec = tagName == 4 || tagName == 264 || tagName == 268;
Magic Number,PeterO.Cbor,CBORNumber,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORNumber.cs,BigFracToNumber,The following statement contains a magic number: bool isdec = tagName == 4 || tagName == 264 || tagName == 268;
Magic Number,PeterO.Cbor,CBORNumber,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORNumber.cs,BigFracToNumber,The following statement contains a magic number: !o[2].CanValueFitInInt32()
Magic Number,PeterO.Cbor,CBORNumber,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORNumber.cs,BigFracToNumber,The following statement contains a magic number: int options = o[2].AsInt32Value();
Magic Number,PeterO.Cbor,CBORNumber,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORNumber.cs,BigFracToNumber,The following statement contains a magic number: switch (options) {           case 0:             break;           case 1:             if (isdec) {               edec = edec.Negate();             } else {               efloat = efloat.Negate();             }             break;           case 2:             if (!exponent.IsZero || !mantissa.IsZero) {               return null; // "invalid values");             }             if (isdec) {               edec = EDecimal.PositiveInfinity;             } else {               efloat = EFloat.PositiveInfinity;             }             break;           case 3:             if (!exponent.IsZero || !mantissa.IsZero) {               return null; // "invalid values");             }             if (isdec) {               edec = EDecimal.NegativeInfinity;             } else {               efloat = EFloat.NegativeInfinity;             }             break;           case 4:           case 5:           case 6:           case 7:             if (!exponent.IsZero) {               return null; // "invalid values");             }             if (isdec) {               edec = EDecimal.CreateNaN(                   mantissa'                   options >= 6'                   options == 5 || options == 7'                   null);             } else {               efloat = EFloat.CreateNaN(                   mantissa'                   options >= 6'                   options == 5 || options == 7'                   null);             }             break;           default:             return null; // "Invalid options");         }
Magic Number,PeterO.Cbor,CBORNumber,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORNumber.cs,BigFracToNumber,The following statement contains a magic number: switch (options) {           case 0:             break;           case 1:             if (isdec) {               edec = edec.Negate();             } else {               efloat = efloat.Negate();             }             break;           case 2:             if (!exponent.IsZero || !mantissa.IsZero) {               return null; // "invalid values");             }             if (isdec) {               edec = EDecimal.PositiveInfinity;             } else {               efloat = EFloat.PositiveInfinity;             }             break;           case 3:             if (!exponent.IsZero || !mantissa.IsZero) {               return null; // "invalid values");             }             if (isdec) {               edec = EDecimal.NegativeInfinity;             } else {               efloat = EFloat.NegativeInfinity;             }             break;           case 4:           case 5:           case 6:           case 7:             if (!exponent.IsZero) {               return null; // "invalid values");             }             if (isdec) {               edec = EDecimal.CreateNaN(                   mantissa'                   options >= 6'                   options == 5 || options == 7'                   null);             } else {               efloat = EFloat.CreateNaN(                   mantissa'                   options >= 6'                   options == 5 || options == 7'                   null);             }             break;           default:             return null; // "Invalid options");         }
Magic Number,PeterO.Cbor,CBORNumber,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORNumber.cs,BigFracToNumber,The following statement contains a magic number: switch (options) {           case 0:             break;           case 1:             if (isdec) {               edec = edec.Negate();             } else {               efloat = efloat.Negate();             }             break;           case 2:             if (!exponent.IsZero || !mantissa.IsZero) {               return null; // "invalid values");             }             if (isdec) {               edec = EDecimal.PositiveInfinity;             } else {               efloat = EFloat.PositiveInfinity;             }             break;           case 3:             if (!exponent.IsZero || !mantissa.IsZero) {               return null; // "invalid values");             }             if (isdec) {               edec = EDecimal.NegativeInfinity;             } else {               efloat = EFloat.NegativeInfinity;             }             break;           case 4:           case 5:           case 6:           case 7:             if (!exponent.IsZero) {               return null; // "invalid values");             }             if (isdec) {               edec = EDecimal.CreateNaN(                   mantissa'                   options >= 6'                   options == 5 || options == 7'                   null);             } else {               efloat = EFloat.CreateNaN(                   mantissa'                   options >= 6'                   options == 5 || options == 7'                   null);             }             break;           default:             return null; // "Invalid options");         }
Magic Number,PeterO.Cbor,CBORNumber,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORNumber.cs,BigFracToNumber,The following statement contains a magic number: switch (options) {           case 0:             break;           case 1:             if (isdec) {               edec = edec.Negate();             } else {               efloat = efloat.Negate();             }             break;           case 2:             if (!exponent.IsZero || !mantissa.IsZero) {               return null; // "invalid values");             }             if (isdec) {               edec = EDecimal.PositiveInfinity;             } else {               efloat = EFloat.PositiveInfinity;             }             break;           case 3:             if (!exponent.IsZero || !mantissa.IsZero) {               return null; // "invalid values");             }             if (isdec) {               edec = EDecimal.NegativeInfinity;             } else {               efloat = EFloat.NegativeInfinity;             }             break;           case 4:           case 5:           case 6:           case 7:             if (!exponent.IsZero) {               return null; // "invalid values");             }             if (isdec) {               edec = EDecimal.CreateNaN(                   mantissa'                   options >= 6'                   options == 5 || options == 7'                   null);             } else {               efloat = EFloat.CreateNaN(                   mantissa'                   options >= 6'                   options == 5 || options == 7'                   null);             }             break;           default:             return null; // "Invalid options");         }
Magic Number,PeterO.Cbor,CBORNumber,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORNumber.cs,BigFracToNumber,The following statement contains a magic number: switch (options) {           case 0:             break;           case 1:             if (isdec) {               edec = edec.Negate();             } else {               efloat = efloat.Negate();             }             break;           case 2:             if (!exponent.IsZero || !mantissa.IsZero) {               return null; // "invalid values");             }             if (isdec) {               edec = EDecimal.PositiveInfinity;             } else {               efloat = EFloat.PositiveInfinity;             }             break;           case 3:             if (!exponent.IsZero || !mantissa.IsZero) {               return null; // "invalid values");             }             if (isdec) {               edec = EDecimal.NegativeInfinity;             } else {               efloat = EFloat.NegativeInfinity;             }             break;           case 4:           case 5:           case 6:           case 7:             if (!exponent.IsZero) {               return null; // "invalid values");             }             if (isdec) {               edec = EDecimal.CreateNaN(                   mantissa'                   options >= 6'                   options == 5 || options == 7'                   null);             } else {               efloat = EFloat.CreateNaN(                   mantissa'                   options >= 6'                   options == 5 || options == 7'                   null);             }             break;           default:             return null; // "Invalid options");         }
Magic Number,PeterO.Cbor,CBORNumber,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORNumber.cs,BigFracToNumber,The following statement contains a magic number: switch (options) {           case 0:             break;           case 1:             if (isdec) {               edec = edec.Negate();             } else {               efloat = efloat.Negate();             }             break;           case 2:             if (!exponent.IsZero || !mantissa.IsZero) {               return null; // "invalid values");             }             if (isdec) {               edec = EDecimal.PositiveInfinity;             } else {               efloat = EFloat.PositiveInfinity;             }             break;           case 3:             if (!exponent.IsZero || !mantissa.IsZero) {               return null; // "invalid values");             }             if (isdec) {               edec = EDecimal.NegativeInfinity;             } else {               efloat = EFloat.NegativeInfinity;             }             break;           case 4:           case 5:           case 6:           case 7:             if (!exponent.IsZero) {               return null; // "invalid values");             }             if (isdec) {               edec = EDecimal.CreateNaN(                   mantissa'                   options >= 6'                   options == 5 || options == 7'                   null);             } else {               efloat = EFloat.CreateNaN(                   mantissa'                   options >= 6'                   options == 5 || options == 7'                   null);             }             break;           default:             return null; // "Invalid options");         }
Magic Number,PeterO.Cbor,CBORNumber,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORNumber.cs,BigFracToNumber,The following statement contains a magic number: switch (options) {           case 0:             break;           case 1:             if (isdec) {               edec = edec.Negate();             } else {               efloat = efloat.Negate();             }             break;           case 2:             if (!exponent.IsZero || !mantissa.IsZero) {               return null; // "invalid values");             }             if (isdec) {               edec = EDecimal.PositiveInfinity;             } else {               efloat = EFloat.PositiveInfinity;             }             break;           case 3:             if (!exponent.IsZero || !mantissa.IsZero) {               return null; // "invalid values");             }             if (isdec) {               edec = EDecimal.NegativeInfinity;             } else {               efloat = EFloat.NegativeInfinity;             }             break;           case 4:           case 5:           case 6:           case 7:             if (!exponent.IsZero) {               return null; // "invalid values");             }             if (isdec) {               edec = EDecimal.CreateNaN(                   mantissa'                   options >= 6'                   options == 5 || options == 7'                   null);             } else {               efloat = EFloat.CreateNaN(                   mantissa'                   options >= 6'                   options == 5 || options == 7'                   null);             }             break;           default:             return null; // "Invalid options");         }
Magic Number,PeterO.Cbor,CBORNumber,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORNumber.cs,BigFracToNumber,The following statement contains a magic number: switch (options) {           case 0:             break;           case 1:             if (isdec) {               edec = edec.Negate();             } else {               efloat = efloat.Negate();             }             break;           case 2:             if (!exponent.IsZero || !mantissa.IsZero) {               return null; // "invalid values");             }             if (isdec) {               edec = EDecimal.PositiveInfinity;             } else {               efloat = EFloat.PositiveInfinity;             }             break;           case 3:             if (!exponent.IsZero || !mantissa.IsZero) {               return null; // "invalid values");             }             if (isdec) {               edec = EDecimal.NegativeInfinity;             } else {               efloat = EFloat.NegativeInfinity;             }             break;           case 4:           case 5:           case 6:           case 7:             if (!exponent.IsZero) {               return null; // "invalid values");             }             if (isdec) {               edec = EDecimal.CreateNaN(                   mantissa'                   options >= 6'                   options == 5 || options == 7'                   null);             } else {               efloat = EFloat.CreateNaN(                   mantissa'                   options >= 6'                   options == 5 || options == 7'                   null);             }             break;           default:             return null; // "Invalid options");         }
Magic Number,PeterO.Cbor,CBORNumber,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORNumber.cs,BigFracToNumber,The following statement contains a magic number: switch (options) {           case 0:             break;           case 1:             if (isdec) {               edec = edec.Negate();             } else {               efloat = efloat.Negate();             }             break;           case 2:             if (!exponent.IsZero || !mantissa.IsZero) {               return null; // "invalid values");             }             if (isdec) {               edec = EDecimal.PositiveInfinity;             } else {               efloat = EFloat.PositiveInfinity;             }             break;           case 3:             if (!exponent.IsZero || !mantissa.IsZero) {               return null; // "invalid values");             }             if (isdec) {               edec = EDecimal.NegativeInfinity;             } else {               efloat = EFloat.NegativeInfinity;             }             break;           case 4:           case 5:           case 6:           case 7:             if (!exponent.IsZero) {               return null; // "invalid values");             }             if (isdec) {               edec = EDecimal.CreateNaN(                   mantissa'                   options >= 6'                   options == 5 || options == 7'                   null);             } else {               efloat = EFloat.CreateNaN(                   mantissa'                   options >= 6'                   options == 5 || options == 7'                   null);             }             break;           default:             return null; // "Invalid options");         }
Magic Number,PeterO.Cbor,CBORNumber,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORNumber.cs,BigFracToNumber,The following statement contains a magic number: switch (options) {           case 0:             break;           case 1:             if (isdec) {               edec = edec.Negate();             } else {               efloat = efloat.Negate();             }             break;           case 2:             if (!exponent.IsZero || !mantissa.IsZero) {               return null; // "invalid values");             }             if (isdec) {               edec = EDecimal.PositiveInfinity;             } else {               efloat = EFloat.PositiveInfinity;             }             break;           case 3:             if (!exponent.IsZero || !mantissa.IsZero) {               return null; // "invalid values");             }             if (isdec) {               edec = EDecimal.NegativeInfinity;             } else {               efloat = EFloat.NegativeInfinity;             }             break;           case 4:           case 5:           case 6:           case 7:             if (!exponent.IsZero) {               return null; // "invalid values");             }             if (isdec) {               edec = EDecimal.CreateNaN(                   mantissa'                   options >= 6'                   options == 5 || options == 7'                   null);             } else {               efloat = EFloat.CreateNaN(                   mantissa'                   options >= 6'                   options == 5 || options == 7'                   null);             }             break;           default:             return null; // "Invalid options");         }
Magic Number,PeterO.Cbor,CBORNumber,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORNumber.cs,BigFracToNumber,The following statement contains a magic number: switch (options) {           case 0:             break;           case 1:             if (isdec) {               edec = edec.Negate();             } else {               efloat = efloat.Negate();             }             break;           case 2:             if (!exponent.IsZero || !mantissa.IsZero) {               return null; // "invalid values");             }             if (isdec) {               edec = EDecimal.PositiveInfinity;             } else {               efloat = EFloat.PositiveInfinity;             }             break;           case 3:             if (!exponent.IsZero || !mantissa.IsZero) {               return null; // "invalid values");             }             if (isdec) {               edec = EDecimal.NegativeInfinity;             } else {               efloat = EFloat.NegativeInfinity;             }             break;           case 4:           case 5:           case 6:           case 7:             if (!exponent.IsZero) {               return null; // "invalid values");             }             if (isdec) {               edec = EDecimal.CreateNaN(                   mantissa'                   options >= 6'                   options == 5 || options == 7'                   null);             } else {               efloat = EFloat.CreateNaN(                   mantissa'                   options >= 6'                   options == 5 || options == 7'                   null);             }             break;           default:             return null; // "Invalid options");         }
Magic Number,PeterO.Cbor,CBORNumber,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORNumber.cs,BigFracToNumber,The following statement contains a magic number: switch (options) {           case 0:             break;           case 1:             if (isdec) {               edec = edec.Negate();             } else {               efloat = efloat.Negate();             }             break;           case 2:             if (!exponent.IsZero || !mantissa.IsZero) {               return null; // "invalid values");             }             if (isdec) {               edec = EDecimal.PositiveInfinity;             } else {               efloat = EFloat.PositiveInfinity;             }             break;           case 3:             if (!exponent.IsZero || !mantissa.IsZero) {               return null; // "invalid values");             }             if (isdec) {               edec = EDecimal.NegativeInfinity;             } else {               efloat = EFloat.NegativeInfinity;             }             break;           case 4:           case 5:           case 6:           case 7:             if (!exponent.IsZero) {               return null; // "invalid values");             }             if (isdec) {               edec = EDecimal.CreateNaN(                   mantissa'                   options >= 6'                   options == 5 || options == 7'                   null);             } else {               efloat = EFloat.CreateNaN(                   mantissa'                   options >= 6'                   options == 5 || options == 7'                   null);             }             break;           default:             return null; // "Invalid options");         }
Magic Number,PeterO.Cbor,CBORNumber,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORNumber.cs,BigFracToNumber,The following statement contains a magic number: tagName == 268 || tagName == 269
Magic Number,PeterO.Cbor,CBORNumber,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORNumber.cs,BigFracToNumber,The following statement contains a magic number: tagName == 268 || tagName == 269
Magic Number,PeterO.Cbor,CBORNumber,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORNumber.cs,BignumToNumber,The following statement contains a magic number: bool negative = o.HasMostInnerTag(3);
Magic Number,PeterO.Cbor,CBORNumber,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORNumber.cs,BignumToNumber,The following statement contains a magic number: x <<= 8;
Magic Number,PeterO.Cbor,CBORNumber,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORNumber.cs,BignumToNumber,The following statement contains a magic number: data.Length <= 7
Magic Number,PeterO.Cbor,CBORNumber,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORNumber.cs,BignumToNumber,The following statement contains a magic number: ((data[0] >> 7) & 1) != 0
Magic Number,PeterO.Cbor,CBORNumber,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORNumber.cs,ToJSONString,The following statement contains a magic number: switch (this.kind) {         case NumberKind.Double: {             var f = (double)this.value;             if (Double.IsNegativeInfinity(f) ||                          Double.IsPositiveInfinity(f) ||                          Double.IsNaN(f)) {               return "null";             }             string dblString = CBORUtilities.DoubleToString(f);             return CBORUtilities.TrimDotZero(dblString);           }         case NumberKind.Integer: {             var longItem = (long)this.value;             return CBORUtilities.LongToString(longItem);           }         case NumberKind.EInteger: {             object eiobj = this.value;             return ((EInteger)eiobj).ToString();           }         case NumberKind.EDecimal: {             var dec = (EDecimal)this.value;             if (dec.IsInfinity() || dec.IsNaN()) {               return "null";             } else {               return dec.ToString();             }           }         case NumberKind.EFloat: {             var flo = (EFloat)this.value;             if (flo.IsInfinity() || flo.IsNaN()) {               return "null";             }             if (flo.IsFinite &&               flo.Exponent.Abs().CompareTo((EInteger)2500) > 0) {               // Too inefficient to convert to a decimal number               // from a bigfloat with a very high exponent'               // so convert to double instead               double f = flo.ToDouble();               if (Double.IsNegativeInfinity(f) ||                              Double.IsPositiveInfinity(f) ||                              Double.IsNaN(f)) {                 return "null";               }               string dblString = CBORUtilities.DoubleToString(f);               return CBORUtilities.TrimDotZero(dblString);             }             return flo.ToString();           }         case NumberKind.ERational: {             var dec = (ERational)this.value;             EDecimal f = dec.ToEDecimalExactIfPossible(                 EContext.Decimal128.WithUnlimitedExponents());             if (!f.IsFinite) {               return "null";             } else {               return f.ToString();             }           }         default: throw new InvalidOperationException();       }
Magic Number,PeterO.Cbor,CBORObject,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORObject.cs,CBORObject,The following statement contains a magic number: (type == CBORObjectTypeEInteger) && ((EInteger)item).GetSignedBitLengthAsEInteger().CompareTo(64) > 0
Magic Number,PeterO.Cbor,CBORObject,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORObject.cs,ToObject,The following statement contains a magic number: depth > 100
Magic Number,PeterO.Cbor,CBORObject,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORObject.cs,ToObject,The following statement contains a magic number: this.HasMostInnerTag(30) && this.Count != 2
Magic Number,PeterO.Cbor,CBORObject,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORObject.cs,ToObject,The following statement contains a magic number: this.HasMostInnerTag(30) && this.Count != 2
Magic Number,PeterO.Cbor,CBORObject,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORObject.cs,FromObject,The following statement contains a magic number: value >= 0L && value < 24L
Magic Number,PeterO.Cbor,CBORObject,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORObject.cs,IntegerByteLength,The following statement contains a magic number: return 5;
Magic Number,PeterO.Cbor,CBORObject,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORObject.cs,IntegerByteLength,The following statement contains a magic number: return 9;
Magic Number,PeterO.Cbor,CBORObject,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORObject.cs,CalcEncodedSize,The following statement contains a magic number: depth > 1000
Magic Number,PeterO.Cbor,CBORObject,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORObject.cs,CalcEncodedSize,The following statement contains a magic number: switch (cbor.Type) {         case CBORType.Integer: {           if (cbor.CanValueFitInInt64()) {             long tag = cbor.AsInt64Value();             size = checked(size + IntegerByteLength(tag));             return size;           } else {             return checked(size + 9);           }         }         case CBORType.FloatingPoint: {           long valueBits = cbor.AsDoubleBits();           int bits = CBORUtilities.DoubleToHalfPrecisionIfSameValue(valueBits);           if (bits != -1) {             return checked(size + 3);           }           return CBORUtilities.DoubleRetainsSameValueInSingle(valueBits) ? checked(size + 5) : checked(size + 9);         }         case CBORType.Array:           size = checked(size + IntegerByteLength(cbor.Count));           for (var i = 0; i < cbor.Count; ++i) {             long newsize = cbor[i].CalcEncodedSize(depth + 1);             size = checked(size + newsize);           }           return size;         case CBORType.Map: {           ICollection<KeyValuePair<CBORObject' CBORObject>> entries =              this.Entries;           size = checked(size + IntegerByteLength(entries.Count));           foreach (KeyValuePair<CBORObject' CBORObject> entry in entries) {             CBORObject key = entry.Key;             CBORObject value = entry.Value;             size = checked(size + key.CalcEncodedSize(depth + 1));             size = checked(size + value.CalcEncodedSize(depth + 1));           }           return size;         }         case CBORType.TextString: {           long ulength = DataUtilities.GetUtf8Length(this.AsString()' false);           size = checked(size + IntegerByteLength(ulength));           return checked(size + ulength);         }         case CBORType.ByteString: {           byte[] bytes = cbor.GetByteString();           size = checked(size + IntegerByteLength(bytes.Length));           return checked(size + bytes.Length);         }         case CBORType.Boolean:           return checked(size + 1);         case CBORType.SimpleValue:           return checked(size + (cbor.SimpleValue >= 24 ? 2 : 1));         default: throw new InvalidOperationException();       }
Magic Number,PeterO.Cbor,CBORObject,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORObject.cs,CalcEncodedSize,The following statement contains a magic number: switch (cbor.Type) {         case CBORType.Integer: {           if (cbor.CanValueFitInInt64()) {             long tag = cbor.AsInt64Value();             size = checked(size + IntegerByteLength(tag));             return size;           } else {             return checked(size + 9);           }         }         case CBORType.FloatingPoint: {           long valueBits = cbor.AsDoubleBits();           int bits = CBORUtilities.DoubleToHalfPrecisionIfSameValue(valueBits);           if (bits != -1) {             return checked(size + 3);           }           return CBORUtilities.DoubleRetainsSameValueInSingle(valueBits) ? checked(size + 5) : checked(size + 9);         }         case CBORType.Array:           size = checked(size + IntegerByteLength(cbor.Count));           for (var i = 0; i < cbor.Count; ++i) {             long newsize = cbor[i].CalcEncodedSize(depth + 1);             size = checked(size + newsize);           }           return size;         case CBORType.Map: {           ICollection<KeyValuePair<CBORObject' CBORObject>> entries =              this.Entries;           size = checked(size + IntegerByteLength(entries.Count));           foreach (KeyValuePair<CBORObject' CBORObject> entry in entries) {             CBORObject key = entry.Key;             CBORObject value = entry.Value;             size = checked(size + key.CalcEncodedSize(depth + 1));             size = checked(size + value.CalcEncodedSize(depth + 1));           }           return size;         }         case CBORType.TextString: {           long ulength = DataUtilities.GetUtf8Length(this.AsString()' false);           size = checked(size + IntegerByteLength(ulength));           return checked(size + ulength);         }         case CBORType.ByteString: {           byte[] bytes = cbor.GetByteString();           size = checked(size + IntegerByteLength(bytes.Length));           return checked(size + bytes.Length);         }         case CBORType.Boolean:           return checked(size + 1);         case CBORType.SimpleValue:           return checked(size + (cbor.SimpleValue >= 24 ? 2 : 1));         default: throw new InvalidOperationException();       }
Magic Number,PeterO.Cbor,CBORObject,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORObject.cs,CalcEncodedSize,The following statement contains a magic number: switch (cbor.Type) {         case CBORType.Integer: {           if (cbor.CanValueFitInInt64()) {             long tag = cbor.AsInt64Value();             size = checked(size + IntegerByteLength(tag));             return size;           } else {             return checked(size + 9);           }         }         case CBORType.FloatingPoint: {           long valueBits = cbor.AsDoubleBits();           int bits = CBORUtilities.DoubleToHalfPrecisionIfSameValue(valueBits);           if (bits != -1) {             return checked(size + 3);           }           return CBORUtilities.DoubleRetainsSameValueInSingle(valueBits) ? checked(size + 5) : checked(size + 9);         }         case CBORType.Array:           size = checked(size + IntegerByteLength(cbor.Count));           for (var i = 0; i < cbor.Count; ++i) {             long newsize = cbor[i].CalcEncodedSize(depth + 1);             size = checked(size + newsize);           }           return size;         case CBORType.Map: {           ICollection<KeyValuePair<CBORObject' CBORObject>> entries =              this.Entries;           size = checked(size + IntegerByteLength(entries.Count));           foreach (KeyValuePair<CBORObject' CBORObject> entry in entries) {             CBORObject key = entry.Key;             CBORObject value = entry.Value;             size = checked(size + key.CalcEncodedSize(depth + 1));             size = checked(size + value.CalcEncodedSize(depth + 1));           }           return size;         }         case CBORType.TextString: {           long ulength = DataUtilities.GetUtf8Length(this.AsString()' false);           size = checked(size + IntegerByteLength(ulength));           return checked(size + ulength);         }         case CBORType.ByteString: {           byte[] bytes = cbor.GetByteString();           size = checked(size + IntegerByteLength(bytes.Length));           return checked(size + bytes.Length);         }         case CBORType.Boolean:           return checked(size + 1);         case CBORType.SimpleValue:           return checked(size + (cbor.SimpleValue >= 24 ? 2 : 1));         default: throw new InvalidOperationException();       }
Magic Number,PeterO.Cbor,CBORObject,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORObject.cs,CalcEncodedSize,The following statement contains a magic number: switch (cbor.Type) {         case CBORType.Integer: {           if (cbor.CanValueFitInInt64()) {             long tag = cbor.AsInt64Value();             size = checked(size + IntegerByteLength(tag));             return size;           } else {             return checked(size + 9);           }         }         case CBORType.FloatingPoint: {           long valueBits = cbor.AsDoubleBits();           int bits = CBORUtilities.DoubleToHalfPrecisionIfSameValue(valueBits);           if (bits != -1) {             return checked(size + 3);           }           return CBORUtilities.DoubleRetainsSameValueInSingle(valueBits) ? checked(size + 5) : checked(size + 9);         }         case CBORType.Array:           size = checked(size + IntegerByteLength(cbor.Count));           for (var i = 0; i < cbor.Count; ++i) {             long newsize = cbor[i].CalcEncodedSize(depth + 1);             size = checked(size + newsize);           }           return size;         case CBORType.Map: {           ICollection<KeyValuePair<CBORObject' CBORObject>> entries =              this.Entries;           size = checked(size + IntegerByteLength(entries.Count));           foreach (KeyValuePair<CBORObject' CBORObject> entry in entries) {             CBORObject key = entry.Key;             CBORObject value = entry.Value;             size = checked(size + key.CalcEncodedSize(depth + 1));             size = checked(size + value.CalcEncodedSize(depth + 1));           }           return size;         }         case CBORType.TextString: {           long ulength = DataUtilities.GetUtf8Length(this.AsString()' false);           size = checked(size + IntegerByteLength(ulength));           return checked(size + ulength);         }         case CBORType.ByteString: {           byte[] bytes = cbor.GetByteString();           size = checked(size + IntegerByteLength(bytes.Length));           return checked(size + bytes.Length);         }         case CBORType.Boolean:           return checked(size + 1);         case CBORType.SimpleValue:           return checked(size + (cbor.SimpleValue >= 24 ? 2 : 1));         default: throw new InvalidOperationException();       }
Magic Number,PeterO.Cbor,CBORObject,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORObject.cs,CalcEncodedSize,The following statement contains a magic number: switch (cbor.Type) {         case CBORType.Integer: {           if (cbor.CanValueFitInInt64()) {             long tag = cbor.AsInt64Value();             size = checked(size + IntegerByteLength(tag));             return size;           } else {             return checked(size + 9);           }         }         case CBORType.FloatingPoint: {           long valueBits = cbor.AsDoubleBits();           int bits = CBORUtilities.DoubleToHalfPrecisionIfSameValue(valueBits);           if (bits != -1) {             return checked(size + 3);           }           return CBORUtilities.DoubleRetainsSameValueInSingle(valueBits) ? checked(size + 5) : checked(size + 9);         }         case CBORType.Array:           size = checked(size + IntegerByteLength(cbor.Count));           for (var i = 0; i < cbor.Count; ++i) {             long newsize = cbor[i].CalcEncodedSize(depth + 1);             size = checked(size + newsize);           }           return size;         case CBORType.Map: {           ICollection<KeyValuePair<CBORObject' CBORObject>> entries =              this.Entries;           size = checked(size + IntegerByteLength(entries.Count));           foreach (KeyValuePair<CBORObject' CBORObject> entry in entries) {             CBORObject key = entry.Key;             CBORObject value = entry.Value;             size = checked(size + key.CalcEncodedSize(depth + 1));             size = checked(size + value.CalcEncodedSize(depth + 1));           }           return size;         }         case CBORType.TextString: {           long ulength = DataUtilities.GetUtf8Length(this.AsString()' false);           size = checked(size + IntegerByteLength(ulength));           return checked(size + ulength);         }         case CBORType.ByteString: {           byte[] bytes = cbor.GetByteString();           size = checked(size + IntegerByteLength(bytes.Length));           return checked(size + bytes.Length);         }         case CBORType.Boolean:           return checked(size + 1);         case CBORType.SimpleValue:           return checked(size + (cbor.SimpleValue >= 24 ? 2 : 1));         default: throw new InvalidOperationException();       }
Magic Number,PeterO.Cbor,CBORObject,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORObject.cs,CalcEncodedSize,The following statement contains a magic number: switch (cbor.Type) {         case CBORType.Integer: {           if (cbor.CanValueFitInInt64()) {             long tag = cbor.AsInt64Value();             size = checked(size + IntegerByteLength(tag));             return size;           } else {             return checked(size + 9);           }         }         case CBORType.FloatingPoint: {           long valueBits = cbor.AsDoubleBits();           int bits = CBORUtilities.DoubleToHalfPrecisionIfSameValue(valueBits);           if (bits != -1) {             return checked(size + 3);           }           return CBORUtilities.DoubleRetainsSameValueInSingle(valueBits) ? checked(size + 5) : checked(size + 9);         }         case CBORType.Array:           size = checked(size + IntegerByteLength(cbor.Count));           for (var i = 0; i < cbor.Count; ++i) {             long newsize = cbor[i].CalcEncodedSize(depth + 1);             size = checked(size + newsize);           }           return size;         case CBORType.Map: {           ICollection<KeyValuePair<CBORObject' CBORObject>> entries =              this.Entries;           size = checked(size + IntegerByteLength(entries.Count));           foreach (KeyValuePair<CBORObject' CBORObject> entry in entries) {             CBORObject key = entry.Key;             CBORObject value = entry.Value;             size = checked(size + key.CalcEncodedSize(depth + 1));             size = checked(size + value.CalcEncodedSize(depth + 1));           }           return size;         }         case CBORType.TextString: {           long ulength = DataUtilities.GetUtf8Length(this.AsString()' false);           size = checked(size + IntegerByteLength(ulength));           return checked(size + ulength);         }         case CBORType.ByteString: {           byte[] bytes = cbor.GetByteString();           size = checked(size + IntegerByteLength(bytes.Length));           return checked(size + bytes.Length);         }         case CBORType.Boolean:           return checked(size + 1);         case CBORType.SimpleValue:           return checked(size + (cbor.SimpleValue >= 24 ? 2 : 1));         default: throw new InvalidOperationException();       }
Magic Number,PeterO.Cbor,CBORObject,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORObject.cs,FromObject,The following statement contains a magic number: options += 2;
Magic Number,PeterO.Cbor,CBORObject,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORObject.cs,FromObject,The following statement contains a magic number: options += 4;
Magic Number,PeterO.Cbor,CBORObject,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORObject.cs,FromObject,The following statement contains a magic number: options += 6;
Magic Number,PeterO.Cbor,CBORObject,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORObject.cs,FromObject,The following statement contains a magic number: tag = 269;
Magic Number,PeterO.Cbor,CBORObject,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORObject.cs,FromObject,The following statement contains a magic number: options += 2;
Magic Number,PeterO.Cbor,CBORObject,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORObject.cs,FromObject,The following statement contains a magic number: options += 4;
Magic Number,PeterO.Cbor,CBORObject,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORObject.cs,FromObject,The following statement contains a magic number: options += 6;
Magic Number,PeterO.Cbor,CBORObject,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORObject.cs,FromObject,The following statement contains a magic number: tag = 270;
Magic Number,PeterO.Cbor,CBORObject,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORObject.cs,FromObject,The following statement contains a magic number: options += 2;
Magic Number,PeterO.Cbor,CBORObject,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORObject.cs,FromObject,The following statement contains a magic number: options += 4;
Magic Number,PeterO.Cbor,CBORObject,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORObject.cs,FromObject,The following statement contains a magic number: options += 6;
Magic Number,PeterO.Cbor,CBORObject,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORObject.cs,FromObject,The following statement contains a magic number: tag = 268;
Magic Number,PeterO.Cbor,CBORObject,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORObject.cs,FromObject,The following statement contains a magic number: value >= 0 && value < 24
Magic Number,PeterO.Cbor,CBORObject,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORObject.cs,FromObject,The following statement contains a magic number: value >= 0 && value < 24
Magic Number,PeterO.Cbor,CBORObject,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORObject.cs,FromObject,The following statement contains a magic number: depth >= 100
Magic Number,PeterO.Cbor,CBORObject,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORObject.cs,FromSimpleValue,The following statement contains a magic number: simpleValue > 255
Magic Number,PeterO.Cbor,CBORObject,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORObject.cs,FromSimpleValue,The following statement contains a magic number: simpleValue >= 24 && simpleValue < 32
Magic Number,PeterO.Cbor,CBORObject,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORObject.cs,FromSimpleValue,The following statement contains a magic number: simpleValue >= 24 && simpleValue < 32
Magic Number,PeterO.Cbor,CBORObject,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORObject.cs,FromSimpleValue,The following statement contains a magic number: simpleValue < 32
Magic Number,PeterO.Cbor,CBORObject,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORObject.cs,NewArray,The following statement contains a magic number: var list = new List<CBORObject>(2);
Magic Number,PeterO.Cbor,CBORObject,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORObject.cs,ReadJSON,The following statement contains a magic number: reader = new CharacterInputWithCount(         new CharacterReader(stream' 2' true));
Magic Number,PeterO.Cbor,CBORObject,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORObject.cs,FromJSONBytes,The following statement contains a magic number: bytes[offset] >= 0x01 && bytes[offset] <= 0x7f && count >= 2 && bytes[offset + 1] != 0
Magic Number,PeterO.Cbor,CBORObject,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORObject.cs,Write,The following statement contains a magic number: value < 24
Magic Number,PeterO.Cbor,CBORObject,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORObject.cs,Write,The following statement contains a magic number: (((int)value) & 0xff) < 24
Magic Number,PeterO.Cbor,CBORObject,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORObject.cs,Write,The following statement contains a magic number: WritePositiveInt(3' data.Length' output);
Magic Number,PeterO.Cbor,CBORObject,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORObject.cs,AsByte,The following statement contains a magic number: return (byte)this.AsInt32(0' 255);
Magic Number,PeterO.Cbor,CBORObject,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORObject.cs,AsByteLegacy,The following statement contains a magic number: return (byte)this.AsInt32(0' 255);
Magic Number,PeterO.Cbor,CBORObject,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORObject.cs,GetDoubleBytes,The following statement contains a magic number: return tagbyte != 0 ? new[] {           (byte)tagbyte' (byte)0xf9'           (byte)((bits >> 8) & 0xff)' (byte)(bits & 0xff)'         } : new[] {    (byte)0xf9' (byte)((bits >> 8) & 0xff)'    (byte)(bits & 0xff)'  };
Magic Number,PeterO.Cbor,CBORObject,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORObject.cs,GetDoubleBytes,The following statement contains a magic number: return tagbyte != 0 ? new[] {           (byte)tagbyte' (byte)0xf9'           (byte)((bits >> 8) & 0xff)' (byte)(bits & 0xff)'         } : new[] {    (byte)0xf9' (byte)((bits >> 8) & 0xff)'    (byte)(bits & 0xff)'  };
Magic Number,PeterO.Cbor,CBORObject,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORObject.cs,GetDoubleBytes,The following statement contains a magic number: return tagbyte != 0 ? new[] {           (byte)tagbyte' (byte)0xfa'           (byte)((bits >> 24) & 0xff)' (byte)((bits >> 16) & 0xff)'           (byte)((bits >> 8) & 0xff)' (byte)(bits & 0xff)'         } : new[] {    (byte)0xfa' (byte)((bits >> 24) & 0xff)'    (byte)((bits >> 16) & 0xff)' (byte)((bits >> 8) & 0xff)'    (byte)(bits & 0xff)'  };
Magic Number,PeterO.Cbor,CBORObject,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORObject.cs,GetDoubleBytes,The following statement contains a magic number: return tagbyte != 0 ? new[] {           (byte)tagbyte' (byte)0xfa'           (byte)((bits >> 24) & 0xff)' (byte)((bits >> 16) & 0xff)'           (byte)((bits >> 8) & 0xff)' (byte)(bits & 0xff)'         } : new[] {    (byte)0xfa' (byte)((bits >> 24) & 0xff)'    (byte)((bits >> 16) & 0xff)' (byte)((bits >> 8) & 0xff)'    (byte)(bits & 0xff)'  };
Magic Number,PeterO.Cbor,CBORObject,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORObject.cs,GetDoubleBytes,The following statement contains a magic number: return tagbyte != 0 ? new[] {           (byte)tagbyte' (byte)0xfa'           (byte)((bits >> 24) & 0xff)' (byte)((bits >> 16) & 0xff)'           (byte)((bits >> 8) & 0xff)' (byte)(bits & 0xff)'         } : new[] {    (byte)0xfa' (byte)((bits >> 24) & 0xff)'    (byte)((bits >> 16) & 0xff)' (byte)((bits >> 8) & 0xff)'    (byte)(bits & 0xff)'  };
Magic Number,PeterO.Cbor,CBORObject,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORObject.cs,GetDoubleBytes,The following statement contains a magic number: return tagbyte != 0 ? new[] {           (byte)tagbyte' (byte)0xfa'           (byte)((bits >> 24) & 0xff)' (byte)((bits >> 16) & 0xff)'           (byte)((bits >> 8) & 0xff)' (byte)(bits & 0xff)'         } : new[] {    (byte)0xfa' (byte)((bits >> 24) & 0xff)'    (byte)((bits >> 16) & 0xff)' (byte)((bits >> 8) & 0xff)'    (byte)(bits & 0xff)'  };
Magic Number,PeterO.Cbor,CBORObject,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORObject.cs,GetDoubleBytes,The following statement contains a magic number: return tagbyte != 0 ? new[] {           (byte)tagbyte' (byte)0xfa'           (byte)((bits >> 24) & 0xff)' (byte)((bits >> 16) & 0xff)'           (byte)((bits >> 8) & 0xff)' (byte)(bits & 0xff)'         } : new[] {    (byte)0xfa' (byte)((bits >> 24) & 0xff)'    (byte)((bits >> 16) & 0xff)' (byte)((bits >> 8) & 0xff)'    (byte)(bits & 0xff)'  };
Magic Number,PeterO.Cbor,CBORObject,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORObject.cs,GetDoubleBytes,The following statement contains a magic number: return tagbyte != 0 ? new[] {           (byte)tagbyte' (byte)0xfa'           (byte)((bits >> 24) & 0xff)' (byte)((bits >> 16) & 0xff)'           (byte)((bits >> 8) & 0xff)' (byte)(bits & 0xff)'         } : new[] {    (byte)0xfa' (byte)((bits >> 24) & 0xff)'    (byte)((bits >> 16) & 0xff)' (byte)((bits >> 8) & 0xff)'    (byte)(bits & 0xff)'  };
Magic Number,PeterO.Cbor,CBORObject,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORObject.cs,GetDoubleBytes,The following statement contains a magic number: return tagbyte != 0 ? new[] {         (byte)tagbyte' (byte)0xfb'         (byte)((valueBits >> 56) & 0xff)' (byte)((valueBits >> 48) & 0xff)'         (byte)((valueBits >> 40) & 0xff)' (byte)((valueBits >> 32) & 0xff)'         (byte)((valueBits >> 24) & 0xff)' (byte)((valueBits >> 16) & 0xff)'         (byte)((valueBits >> 8) & 0xff)' (byte)(valueBits & 0xff)'       } : new[] {    (byte)0xfb' (byte)((valueBits >> 56) & 0xff)'    (byte)((valueBits >> 48) & 0xff)' (byte)((valueBits >> 40) & 0xff)'    (byte)((valueBits >> 32) & 0xff)' (byte)((valueBits >> 24) & 0xff)'    (byte)((valueBits >> 16) & 0xff)' (byte)((valueBits >> 8) & 0xff)'    (byte)(valueBits & 0xff)'  };
Magic Number,PeterO.Cbor,CBORObject,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORObject.cs,GetDoubleBytes,The following statement contains a magic number: return tagbyte != 0 ? new[] {         (byte)tagbyte' (byte)0xfb'         (byte)((valueBits >> 56) & 0xff)' (byte)((valueBits >> 48) & 0xff)'         (byte)((valueBits >> 40) & 0xff)' (byte)((valueBits >> 32) & 0xff)'         (byte)((valueBits >> 24) & 0xff)' (byte)((valueBits >> 16) & 0xff)'         (byte)((valueBits >> 8) & 0xff)' (byte)(valueBits & 0xff)'       } : new[] {    (byte)0xfb' (byte)((valueBits >> 56) & 0xff)'    (byte)((valueBits >> 48) & 0xff)' (byte)((valueBits >> 40) & 0xff)'    (byte)((valueBits >> 32) & 0xff)' (byte)((valueBits >> 24) & 0xff)'    (byte)((valueBits >> 16) & 0xff)' (byte)((valueBits >> 8) & 0xff)'    (byte)(valueBits & 0xff)'  };
Magic Number,PeterO.Cbor,CBORObject,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORObject.cs,GetDoubleBytes,The following statement contains a magic number: return tagbyte != 0 ? new[] {         (byte)tagbyte' (byte)0xfb'         (byte)((valueBits >> 56) & 0xff)' (byte)((valueBits >> 48) & 0xff)'         (byte)((valueBits >> 40) & 0xff)' (byte)((valueBits >> 32) & 0xff)'         (byte)((valueBits >> 24) & 0xff)' (byte)((valueBits >> 16) & 0xff)'         (byte)((valueBits >> 8) & 0xff)' (byte)(valueBits & 0xff)'       } : new[] {    (byte)0xfb' (byte)((valueBits >> 56) & 0xff)'    (byte)((valueBits >> 48) & 0xff)' (byte)((valueBits >> 40) & 0xff)'    (byte)((valueBits >> 32) & 0xff)' (byte)((valueBits >> 24) & 0xff)'    (byte)((valueBits >> 16) & 0xff)' (byte)((valueBits >> 8) & 0xff)'    (byte)(valueBits & 0xff)'  };
Magic Number,PeterO.Cbor,CBORObject,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORObject.cs,GetDoubleBytes,The following statement contains a magic number: return tagbyte != 0 ? new[] {         (byte)tagbyte' (byte)0xfb'         (byte)((valueBits >> 56) & 0xff)' (byte)((valueBits >> 48) & 0xff)'         (byte)((valueBits >> 40) & 0xff)' (byte)((valueBits >> 32) & 0xff)'         (byte)((valueBits >> 24) & 0xff)' (byte)((valueBits >> 16) & 0xff)'         (byte)((valueBits >> 8) & 0xff)' (byte)(valueBits & 0xff)'       } : new[] {    (byte)0xfb' (byte)((valueBits >> 56) & 0xff)'    (byte)((valueBits >> 48) & 0xff)' (byte)((valueBits >> 40) & 0xff)'    (byte)((valueBits >> 32) & 0xff)' (byte)((valueBits >> 24) & 0xff)'    (byte)((valueBits >> 16) & 0xff)' (byte)((valueBits >> 8) & 0xff)'    (byte)(valueBits & 0xff)'  };
Magic Number,PeterO.Cbor,CBORObject,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORObject.cs,GetDoubleBytes,The following statement contains a magic number: return tagbyte != 0 ? new[] {         (byte)tagbyte' (byte)0xfb'         (byte)((valueBits >> 56) & 0xff)' (byte)((valueBits >> 48) & 0xff)'         (byte)((valueBits >> 40) & 0xff)' (byte)((valueBits >> 32) & 0xff)'         (byte)((valueBits >> 24) & 0xff)' (byte)((valueBits >> 16) & 0xff)'         (byte)((valueBits >> 8) & 0xff)' (byte)(valueBits & 0xff)'       } : new[] {    (byte)0xfb' (byte)((valueBits >> 56) & 0xff)'    (byte)((valueBits >> 48) & 0xff)' (byte)((valueBits >> 40) & 0xff)'    (byte)((valueBits >> 32) & 0xff)' (byte)((valueBits >> 24) & 0xff)'    (byte)((valueBits >> 16) & 0xff)' (byte)((valueBits >> 8) & 0xff)'    (byte)(valueBits & 0xff)'  };
Magic Number,PeterO.Cbor,CBORObject,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORObject.cs,GetDoubleBytes,The following statement contains a magic number: return tagbyte != 0 ? new[] {         (byte)tagbyte' (byte)0xfb'         (byte)((valueBits >> 56) & 0xff)' (byte)((valueBits >> 48) & 0xff)'         (byte)((valueBits >> 40) & 0xff)' (byte)((valueBits >> 32) & 0xff)'         (byte)((valueBits >> 24) & 0xff)' (byte)((valueBits >> 16) & 0xff)'         (byte)((valueBits >> 8) & 0xff)' (byte)(valueBits & 0xff)'       } : new[] {    (byte)0xfb' (byte)((valueBits >> 56) & 0xff)'    (byte)((valueBits >> 48) & 0xff)' (byte)((valueBits >> 40) & 0xff)'    (byte)((valueBits >> 32) & 0xff)' (byte)((valueBits >> 24) & 0xff)'    (byte)((valueBits >> 16) & 0xff)' (byte)((valueBits >> 8) & 0xff)'    (byte)(valueBits & 0xff)'  };
Magic Number,PeterO.Cbor,CBORObject,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORObject.cs,GetDoubleBytes,The following statement contains a magic number: return tagbyte != 0 ? new[] {         (byte)tagbyte' (byte)0xfb'         (byte)((valueBits >> 56) & 0xff)' (byte)((valueBits >> 48) & 0xff)'         (byte)((valueBits >> 40) & 0xff)' (byte)((valueBits >> 32) & 0xff)'         (byte)((valueBits >> 24) & 0xff)' (byte)((valueBits >> 16) & 0xff)'         (byte)((valueBits >> 8) & 0xff)' (byte)(valueBits & 0xff)'       } : new[] {    (byte)0xfb' (byte)((valueBits >> 56) & 0xff)'    (byte)((valueBits >> 48) & 0xff)' (byte)((valueBits >> 40) & 0xff)'    (byte)((valueBits >> 32) & 0xff)' (byte)((valueBits >> 24) & 0xff)'    (byte)((valueBits >> 16) & 0xff)' (byte)((valueBits >> 8) & 0xff)'    (byte)(valueBits & 0xff)'  };
Magic Number,PeterO.Cbor,CBORObject,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORObject.cs,GetDoubleBytes,The following statement contains a magic number: return tagbyte != 0 ? new[] {         (byte)tagbyte' (byte)0xfb'         (byte)((valueBits >> 56) & 0xff)' (byte)((valueBits >> 48) & 0xff)'         (byte)((valueBits >> 40) & 0xff)' (byte)((valueBits >> 32) & 0xff)'         (byte)((valueBits >> 24) & 0xff)' (byte)((valueBits >> 16) & 0xff)'         (byte)((valueBits >> 8) & 0xff)' (byte)(valueBits & 0xff)'       } : new[] {    (byte)0xfb' (byte)((valueBits >> 56) & 0xff)'    (byte)((valueBits >> 48) & 0xff)' (byte)((valueBits >> 40) & 0xff)'    (byte)((valueBits >> 32) & 0xff)' (byte)((valueBits >> 24) & 0xff)'    (byte)((valueBits >> 16) & 0xff)' (byte)((valueBits >> 8) & 0xff)'    (byte)(valueBits & 0xff)'  };
Magic Number,PeterO.Cbor,CBORObject,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORObject.cs,GetDoubleBytes,The following statement contains a magic number: return tagbyte != 0 ? new[] {         (byte)tagbyte' (byte)0xfb'         (byte)((valueBits >> 56) & 0xff)' (byte)((valueBits >> 48) & 0xff)'         (byte)((valueBits >> 40) & 0xff)' (byte)((valueBits >> 32) & 0xff)'         (byte)((valueBits >> 24) & 0xff)' (byte)((valueBits >> 16) & 0xff)'         (byte)((valueBits >> 8) & 0xff)' (byte)(valueBits & 0xff)'       } : new[] {    (byte)0xfb' (byte)((valueBits >> 56) & 0xff)'    (byte)((valueBits >> 48) & 0xff)' (byte)((valueBits >> 40) & 0xff)'    (byte)((valueBits >> 32) & 0xff)' (byte)((valueBits >> 24) & 0xff)'    (byte)((valueBits >> 16) & 0xff)' (byte)((valueBits >> 8) & 0xff)'    (byte)(valueBits & 0xff)'  };
Magic Number,PeterO.Cbor,CBORObject,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORObject.cs,GetDoubleBytes,The following statement contains a magic number: return tagbyte != 0 ? new[] {         (byte)tagbyte' (byte)0xfb'         (byte)((valueBits >> 56) & 0xff)' (byte)((valueBits >> 48) & 0xff)'         (byte)((valueBits >> 40) & 0xff)' (byte)((valueBits >> 32) & 0xff)'         (byte)((valueBits >> 24) & 0xff)' (byte)((valueBits >> 16) & 0xff)'         (byte)((valueBits >> 8) & 0xff)' (byte)(valueBits & 0xff)'       } : new[] {    (byte)0xfb' (byte)((valueBits >> 56) & 0xff)'    (byte)((valueBits >> 48) & 0xff)' (byte)((valueBits >> 40) & 0xff)'    (byte)((valueBits >> 32) & 0xff)' (byte)((valueBits >> 24) & 0xff)'    (byte)((valueBits >> 16) & 0xff)' (byte)((valueBits >> 8) & 0xff)'    (byte)(valueBits & 0xff)'  };
Magic Number,PeterO.Cbor,CBORObject,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORObject.cs,GetDoubleBytes,The following statement contains a magic number: return tagbyte != 0 ? new[] {         (byte)tagbyte' (byte)0xfb'         (byte)((valueBits >> 56) & 0xff)' (byte)((valueBits >> 48) & 0xff)'         (byte)((valueBits >> 40) & 0xff)' (byte)((valueBits >> 32) & 0xff)'         (byte)((valueBits >> 24) & 0xff)' (byte)((valueBits >> 16) & 0xff)'         (byte)((valueBits >> 8) & 0xff)' (byte)(valueBits & 0xff)'       } : new[] {    (byte)0xfb' (byte)((valueBits >> 56) & 0xff)'    (byte)((valueBits >> 48) & 0xff)' (byte)((valueBits >> 40) & 0xff)'    (byte)((valueBits >> 32) & 0xff)' (byte)((valueBits >> 24) & 0xff)'    (byte)((valueBits >> 16) & 0xff)' (byte)((valueBits >> 8) & 0xff)'    (byte)(valueBits & 0xff)'  };
Magic Number,PeterO.Cbor,CBORObject,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORObject.cs,GetDoubleBytes,The following statement contains a magic number: return tagbyte != 0 ? new[] {         (byte)tagbyte' (byte)0xfb'         (byte)((valueBits >> 56) & 0xff)' (byte)((valueBits >> 48) & 0xff)'         (byte)((valueBits >> 40) & 0xff)' (byte)((valueBits >> 32) & 0xff)'         (byte)((valueBits >> 24) & 0xff)' (byte)((valueBits >> 16) & 0xff)'         (byte)((valueBits >> 8) & 0xff)' (byte)(valueBits & 0xff)'       } : new[] {    (byte)0xfb' (byte)((valueBits >> 56) & 0xff)'    (byte)((valueBits >> 48) & 0xff)' (byte)((valueBits >> 40) & 0xff)'    (byte)((valueBits >> 32) & 0xff)' (byte)((valueBits >> 24) & 0xff)'    (byte)((valueBits >> 16) & 0xff)' (byte)((valueBits >> 8) & 0xff)'    (byte)(valueBits & 0xff)'  };
Magic Number,PeterO.Cbor,CBORObject,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORObject.cs,GetDoubleBytes,The following statement contains a magic number: return tagbyte != 0 ? new[] {         (byte)tagbyte' (byte)0xfb'         (byte)((valueBits >> 56) & 0xff)' (byte)((valueBits >> 48) & 0xff)'         (byte)((valueBits >> 40) & 0xff)' (byte)((valueBits >> 32) & 0xff)'         (byte)((valueBits >> 24) & 0xff)' (byte)((valueBits >> 16) & 0xff)'         (byte)((valueBits >> 8) & 0xff)' (byte)(valueBits & 0xff)'       } : new[] {    (byte)0xfb' (byte)((valueBits >> 56) & 0xff)'    (byte)((valueBits >> 48) & 0xff)' (byte)((valueBits >> 40) & 0xff)'    (byte)((valueBits >> 32) & 0xff)' (byte)((valueBits >> 24) & 0xff)'    (byte)((valueBits >> 16) & 0xff)' (byte)((valueBits >> 8) & 0xff)'    (byte)(valueBits & 0xff)'  };
Magic Number,PeterO.Cbor,CBORObject,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORObject.cs,GetDoubleBytes,The following statement contains a magic number: return tagbyte != 0 ? new[] {         (byte)tagbyte' (byte)0xfb'         (byte)((valueBits >> 56) & 0xff)' (byte)((valueBits >> 48) & 0xff)'         (byte)((valueBits >> 40) & 0xff)' (byte)((valueBits >> 32) & 0xff)'         (byte)((valueBits >> 24) & 0xff)' (byte)((valueBits >> 16) & 0xff)'         (byte)((valueBits >> 8) & 0xff)' (byte)(valueBits & 0xff)'       } : new[] {    (byte)0xfb' (byte)((valueBits >> 56) & 0xff)'    (byte)((valueBits >> 48) & 0xff)' (byte)((valueBits >> 40) & 0xff)'    (byte)((valueBits >> 32) & 0xff)' (byte)((valueBits >> 24) & 0xff)'    (byte)((valueBits >> 16) & 0xff)' (byte)((valueBits >> 8) & 0xff)'    (byte)(valueBits & 0xff)'  };
Magic Number,PeterO.Cbor,CBORObject,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORObject.cs,GetDoubleBytes,The following statement contains a magic number: return tagbyte != 0 ? new[] {           (byte)tagbyte' (byte)0xf9'           (byte)((bits >> 8) & 0xff)' (byte)(bits & 0xff)'         } : new[] {    (byte)0xf9' (byte)((bits >> 8) & 0xff)'    (byte)(bits & 0xff)'  };
Magic Number,PeterO.Cbor,CBORObject,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORObject.cs,GetDoubleBytes,The following statement contains a magic number: return tagbyte != 0 ? new[] {           (byte)tagbyte' (byte)0xf9'           (byte)((bits >> 8) & 0xff)' (byte)(bits & 0xff)'         } : new[] {    (byte)0xf9' (byte)((bits >> 8) & 0xff)'    (byte)(bits & 0xff)'  };
Magic Number,PeterO.Cbor,CBORObject,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORObject.cs,GetDoubleBytes,The following statement contains a magic number: return tagbyte != 0 ? new[] {         (byte)tagbyte' (byte)0xfa'         (byte)((bits >> 24) & 0xff)' (byte)((bits >> 16) & 0xff)'         (byte)((bits >> 8) & 0xff)' (byte)(bits & 0xff)'       } : new[] {    (byte)0xfa' (byte)((bits >> 24) & 0xff)'    (byte)((bits >> 16) & 0xff)' (byte)((bits >> 8) & 0xff)'    (byte)(bits & 0xff)'  };
Magic Number,PeterO.Cbor,CBORObject,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORObject.cs,GetDoubleBytes,The following statement contains a magic number: return tagbyte != 0 ? new[] {         (byte)tagbyte' (byte)0xfa'         (byte)((bits >> 24) & 0xff)' (byte)((bits >> 16) & 0xff)'         (byte)((bits >> 8) & 0xff)' (byte)(bits & 0xff)'       } : new[] {    (byte)0xfa' (byte)((bits >> 24) & 0xff)'    (byte)((bits >> 16) & 0xff)' (byte)((bits >> 8) & 0xff)'    (byte)(bits & 0xff)'  };
Magic Number,PeterO.Cbor,CBORObject,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORObject.cs,GetDoubleBytes,The following statement contains a magic number: return tagbyte != 0 ? new[] {         (byte)tagbyte' (byte)0xfa'         (byte)((bits >> 24) & 0xff)' (byte)((bits >> 16) & 0xff)'         (byte)((bits >> 8) & 0xff)' (byte)(bits & 0xff)'       } : new[] {    (byte)0xfa' (byte)((bits >> 24) & 0xff)'    (byte)((bits >> 16) & 0xff)' (byte)((bits >> 8) & 0xff)'    (byte)(bits & 0xff)'  };
Magic Number,PeterO.Cbor,CBORObject,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORObject.cs,GetDoubleBytes,The following statement contains a magic number: return tagbyte != 0 ? new[] {         (byte)tagbyte' (byte)0xfa'         (byte)((bits >> 24) & 0xff)' (byte)((bits >> 16) & 0xff)'         (byte)((bits >> 8) & 0xff)' (byte)(bits & 0xff)'       } : new[] {    (byte)0xfa' (byte)((bits >> 24) & 0xff)'    (byte)((bits >> 16) & 0xff)' (byte)((bits >> 8) & 0xff)'    (byte)(bits & 0xff)'  };
Magic Number,PeterO.Cbor,CBORObject,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORObject.cs,GetDoubleBytes,The following statement contains a magic number: return tagbyte != 0 ? new[] {         (byte)tagbyte' (byte)0xfa'         (byte)((bits >> 24) & 0xff)' (byte)((bits >> 16) & 0xff)'         (byte)((bits >> 8) & 0xff)' (byte)(bits & 0xff)'       } : new[] {    (byte)0xfa' (byte)((bits >> 24) & 0xff)'    (byte)((bits >> 16) & 0xff)' (byte)((bits >> 8) & 0xff)'    (byte)(bits & 0xff)'  };
Magic Number,PeterO.Cbor,CBORObject,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORObject.cs,GetDoubleBytes,The following statement contains a magic number: return tagbyte != 0 ? new[] {         (byte)tagbyte' (byte)0xfa'         (byte)((bits >> 24) & 0xff)' (byte)((bits >> 16) & 0xff)'         (byte)((bits >> 8) & 0xff)' (byte)(bits & 0xff)'       } : new[] {    (byte)0xfa' (byte)((bits >> 24) & 0xff)'    (byte)((bits >> 16) & 0xff)' (byte)((bits >> 8) & 0xff)'    (byte)(bits & 0xff)'  };
Magic Number,PeterO.Cbor,CBORObject,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORObject.cs,EncodeToBytes,The following statement contains a magic number: taggedItem.IsTagged || this.tagHigh != 0 ||           (this.tagLow >> 16) != 0 || this.tagLow >= 24
Magic Number,PeterO.Cbor,CBORObject,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORObject.cs,EncodeToBytes,The following statement contains a magic number: taggedItem.IsTagged || this.tagHigh != 0 ||           (this.tagLow >> 16) != 0 || this.tagLow >= 24
Magic Number,PeterO.Cbor,CBORObject,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORObject.cs,GetHashCode,The following statement contains a magic number: var hashCode = 651869431;
Magic Number,PeterO.Cbor,CBORObject,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORObject.cs,GetHashCode,The following statement contains a magic number: switch (this.itemtypeValue) {             case CBORObjectTypeByteString:               itemHashCode =                 CBORUtilities.ByteArrayHashCode(this.GetByteString());               break;             case CBORObjectTypeMap:               itemHashCode = CBORMapHashCode(this.AsMap());               break;             case CBORObjectTypeArray:               itemHashCode = CBORArrayHashCode(this.AsList());               break;             case CBORObjectTypeTextString:               itemHashCode = StringHashCode((string)this.itemValue);               break;             case CBORObjectTypeSimpleValue:               itemHashCode = (int)this.itemValue;               break;             case CBORObjectTypeDouble:               longValue = this.AsDoubleBits();               longValue |= longValue >> 32;               itemHashCode = unchecked((int)longValue);               break;             case CBORObjectTypeInteger:               longValue = (long)this.itemValue;               longValue |= longValue >> 32;               itemHashCode = unchecked((int)longValue);               break;             case CBORObjectTypeTagged:               itemHashCode = unchecked(this.tagLow + this.tagHigh);               itemHashCode += 651869483 * this.itemValue.GetHashCode();               break;             default:               // EInteger' CBORObject               itemHashCode = this.itemValue.GetHashCode();               break;           }
Magic Number,PeterO.Cbor,CBORObject,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORObject.cs,GetHashCode,The following statement contains a magic number: switch (this.itemtypeValue) {             case CBORObjectTypeByteString:               itemHashCode =                 CBORUtilities.ByteArrayHashCode(this.GetByteString());               break;             case CBORObjectTypeMap:               itemHashCode = CBORMapHashCode(this.AsMap());               break;             case CBORObjectTypeArray:               itemHashCode = CBORArrayHashCode(this.AsList());               break;             case CBORObjectTypeTextString:               itemHashCode = StringHashCode((string)this.itemValue);               break;             case CBORObjectTypeSimpleValue:               itemHashCode = (int)this.itemValue;               break;             case CBORObjectTypeDouble:               longValue = this.AsDoubleBits();               longValue |= longValue >> 32;               itemHashCode = unchecked((int)longValue);               break;             case CBORObjectTypeInteger:               longValue = (long)this.itemValue;               longValue |= longValue >> 32;               itemHashCode = unchecked((int)longValue);               break;             case CBORObjectTypeTagged:               itemHashCode = unchecked(this.tagLow + this.tagHigh);               itemHashCode += 651869483 * this.itemValue.GetHashCode();               break;             default:               // EInteger' CBORObject               itemHashCode = this.itemValue.GetHashCode();               break;           }
Magic Number,PeterO.Cbor,CBORObject,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORObject.cs,GetHashCode,The following statement contains a magic number: switch (this.itemtypeValue) {             case CBORObjectTypeByteString:               itemHashCode =                 CBORUtilities.ByteArrayHashCode(this.GetByteString());               break;             case CBORObjectTypeMap:               itemHashCode = CBORMapHashCode(this.AsMap());               break;             case CBORObjectTypeArray:               itemHashCode = CBORArrayHashCode(this.AsList());               break;             case CBORObjectTypeTextString:               itemHashCode = StringHashCode((string)this.itemValue);               break;             case CBORObjectTypeSimpleValue:               itemHashCode = (int)this.itemValue;               break;             case CBORObjectTypeDouble:               longValue = this.AsDoubleBits();               longValue |= longValue >> 32;               itemHashCode = unchecked((int)longValue);               break;             case CBORObjectTypeInteger:               longValue = (long)this.itemValue;               longValue |= longValue >> 32;               itemHashCode = unchecked((int)longValue);               break;             case CBORObjectTypeTagged:               itemHashCode = unchecked(this.tagLow + this.tagHigh);               itemHashCode += 651869483 * this.itemValue.GetHashCode();               break;             default:               // EInteger' CBORObject               itemHashCode = this.itemValue.GetHashCode();               break;           }
Magic Number,PeterO.Cbor,CBORObject,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORObject.cs,GetHashCode,The following statement contains a magic number: hashCode += 651869479 * itemHashCode;
Magic Number,PeterO.Cbor,CBORObject,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORObject.cs,FromFloatingPointBits,The following statement contains a magic number: switch (byteCount) {         case 2:           value = CBORUtilities.HalfToDoublePrecision(               unchecked((int)(floatingBits & 0xffffL)));           return new CBORObject(CBORObjectTypeDouble' value);         case 4:            value = CBORUtilities.SingleToDoublePrecision(               unchecked((int)(floatingBits & 0xffffL)));           return new CBORObject(CBORObjectTypeDouble' value);         case 8:           return new CBORObject(CBORObjectTypeDouble' floatingBits);         default: throw new ArgumentOutOfRangeException(nameof(byteCount));       }
Magic Number,PeterO.Cbor,CBORObject,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORObject.cs,FromFloatingPointBits,The following statement contains a magic number: switch (byteCount) {         case 2:           value = CBORUtilities.HalfToDoublePrecision(               unchecked((int)(floatingBits & 0xffffL)));           return new CBORObject(CBORObjectTypeDouble' value);         case 4:            value = CBORUtilities.SingleToDoublePrecision(               unchecked((int)(floatingBits & 0xffffL)));           return new CBORObject(CBORObjectTypeDouble' value);         case 8:           return new CBORObject(CBORObjectTypeDouble' floatingBits);         default: throw new ArgumentOutOfRangeException(nameof(byteCount));       }
Magic Number,PeterO.Cbor,CBORObject,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORObject.cs,FromFloatingPointBits,The following statement contains a magic number: switch (byteCount) {         case 2:           value = CBORUtilities.HalfToDoublePrecision(               unchecked((int)(floatingBits & 0xffffL)));           return new CBORObject(CBORObjectTypeDouble' value);         case 4:            value = CBORUtilities.SingleToDoublePrecision(               unchecked((int)(floatingBits & 0xffffL)));           return new CBORObject(CBORObjectTypeDouble' value);         case 8:           return new CBORObject(CBORObjectTypeDouble' floatingBits);         default: throw new ArgumentOutOfRangeException(nameof(byteCount));       }
Magic Number,PeterO.Cbor,CBORObject,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORObject.cs,WriteFloatingPointBits,The following statement contains a magic number: switch (byteCount) {         case 2:           bytes = new byte[] {             (byte)0xf9'             (byte)((floatingBits >> 8) & 0xffL)'             (byte)(floatingBits & 0xffL)'           };           outputStream.Write(bytes' 0' 3);           return 3;         case 4:           bytes = new byte[] {             (byte)0xfa'             (byte)((floatingBits >> 24) & 0xffL)'             (byte)((floatingBits >> 16) & 0xffL)'             (byte)((floatingBits >> 8) & 0xffL)'             (byte)(floatingBits & 0xffL)'           };           outputStream.Write(bytes' 0' 5);           return 5;         case 8:           bytes = new byte[] {             (byte)0xfb'             (byte)((floatingBits >> 56) & 0xffL)'             (byte)((floatingBits >> 48) & 0xffL)'             (byte)((floatingBits >> 40) & 0xffL)'             (byte)((floatingBits >> 32) & 0xffL)'             (byte)((floatingBits >> 24) & 0xffL)'             (byte)((floatingBits >> 16) & 0xffL)'             (byte)((floatingBits >> 8) & 0xffL)'             (byte)(floatingBits & 0xffL)'           };           outputStream.Write(bytes' 0' 9);           return 9;         default:           throw new ArgumentOutOfRangeException(nameof(byteCount));       }
Magic Number,PeterO.Cbor,CBORObject,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORObject.cs,WriteFloatingPointBits,The following statement contains a magic number: switch (byteCount) {         case 2:           bytes = new byte[] {             (byte)0xf9'             (byte)((floatingBits >> 8) & 0xffL)'             (byte)(floatingBits & 0xffL)'           };           outputStream.Write(bytes' 0' 3);           return 3;         case 4:           bytes = new byte[] {             (byte)0xfa'             (byte)((floatingBits >> 24) & 0xffL)'             (byte)((floatingBits >> 16) & 0xffL)'             (byte)((floatingBits >> 8) & 0xffL)'             (byte)(floatingBits & 0xffL)'           };           outputStream.Write(bytes' 0' 5);           return 5;         case 8:           bytes = new byte[] {             (byte)0xfb'             (byte)((floatingBits >> 56) & 0xffL)'             (byte)((floatingBits >> 48) & 0xffL)'             (byte)((floatingBits >> 40) & 0xffL)'             (byte)((floatingBits >> 32) & 0xffL)'             (byte)((floatingBits >> 24) & 0xffL)'             (byte)((floatingBits >> 16) & 0xffL)'             (byte)((floatingBits >> 8) & 0xffL)'             (byte)(floatingBits & 0xffL)'           };           outputStream.Write(bytes' 0' 9);           return 9;         default:           throw new ArgumentOutOfRangeException(nameof(byteCount));       }
Magic Number,PeterO.Cbor,CBORObject,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORObject.cs,WriteFloatingPointBits,The following statement contains a magic number: switch (byteCount) {         case 2:           bytes = new byte[] {             (byte)0xf9'             (byte)((floatingBits >> 8) & 0xffL)'             (byte)(floatingBits & 0xffL)'           };           outputStream.Write(bytes' 0' 3);           return 3;         case 4:           bytes = new byte[] {             (byte)0xfa'             (byte)((floatingBits >> 24) & 0xffL)'             (byte)((floatingBits >> 16) & 0xffL)'             (byte)((floatingBits >> 8) & 0xffL)'             (byte)(floatingBits & 0xffL)'           };           outputStream.Write(bytes' 0' 5);           return 5;         case 8:           bytes = new byte[] {             (byte)0xfb'             (byte)((floatingBits >> 56) & 0xffL)'             (byte)((floatingBits >> 48) & 0xffL)'             (byte)((floatingBits >> 40) & 0xffL)'             (byte)((floatingBits >> 32) & 0xffL)'             (byte)((floatingBits >> 24) & 0xffL)'             (byte)((floatingBits >> 16) & 0xffL)'             (byte)((floatingBits >> 8) & 0xffL)'             (byte)(floatingBits & 0xffL)'           };           outputStream.Write(bytes' 0' 9);           return 9;         default:           throw new ArgumentOutOfRangeException(nameof(byteCount));       }
Magic Number,PeterO.Cbor,CBORObject,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORObject.cs,WriteFloatingPointBits,The following statement contains a magic number: switch (byteCount) {         case 2:           bytes = new byte[] {             (byte)0xf9'             (byte)((floatingBits >> 8) & 0xffL)'             (byte)(floatingBits & 0xffL)'           };           outputStream.Write(bytes' 0' 3);           return 3;         case 4:           bytes = new byte[] {             (byte)0xfa'             (byte)((floatingBits >> 24) & 0xffL)'             (byte)((floatingBits >> 16) & 0xffL)'             (byte)((floatingBits >> 8) & 0xffL)'             (byte)(floatingBits & 0xffL)'           };           outputStream.Write(bytes' 0' 5);           return 5;         case 8:           bytes = new byte[] {             (byte)0xfb'             (byte)((floatingBits >> 56) & 0xffL)'             (byte)((floatingBits >> 48) & 0xffL)'             (byte)((floatingBits >> 40) & 0xffL)'             (byte)((floatingBits >> 32) & 0xffL)'             (byte)((floatingBits >> 24) & 0xffL)'             (byte)((floatingBits >> 16) & 0xffL)'             (byte)((floatingBits >> 8) & 0xffL)'             (byte)(floatingBits & 0xffL)'           };           outputStream.Write(bytes' 0' 9);           return 9;         default:           throw new ArgumentOutOfRangeException(nameof(byteCount));       }
Magic Number,PeterO.Cbor,CBORObject,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORObject.cs,WriteFloatingPointBits,The following statement contains a magic number: switch (byteCount) {         case 2:           bytes = new byte[] {             (byte)0xf9'             (byte)((floatingBits >> 8) & 0xffL)'             (byte)(floatingBits & 0xffL)'           };           outputStream.Write(bytes' 0' 3);           return 3;         case 4:           bytes = new byte[] {             (byte)0xfa'             (byte)((floatingBits >> 24) & 0xffL)'             (byte)((floatingBits >> 16) & 0xffL)'             (byte)((floatingBits >> 8) & 0xffL)'             (byte)(floatingBits & 0xffL)'           };           outputStream.Write(bytes' 0' 5);           return 5;         case 8:           bytes = new byte[] {             (byte)0xfb'             (byte)((floatingBits >> 56) & 0xffL)'             (byte)((floatingBits >> 48) & 0xffL)'             (byte)((floatingBits >> 40) & 0xffL)'             (byte)((floatingBits >> 32) & 0xffL)'             (byte)((floatingBits >> 24) & 0xffL)'             (byte)((floatingBits >> 16) & 0xffL)'             (byte)((floatingBits >> 8) & 0xffL)'             (byte)(floatingBits & 0xffL)'           };           outputStream.Write(bytes' 0' 9);           return 9;         default:           throw new ArgumentOutOfRangeException(nameof(byteCount));       }
Magic Number,PeterO.Cbor,CBORObject,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORObject.cs,WriteFloatingPointBits,The following statement contains a magic number: switch (byteCount) {         case 2:           bytes = new byte[] {             (byte)0xf9'             (byte)((floatingBits >> 8) & 0xffL)'             (byte)(floatingBits & 0xffL)'           };           outputStream.Write(bytes' 0' 3);           return 3;         case 4:           bytes = new byte[] {             (byte)0xfa'             (byte)((floatingBits >> 24) & 0xffL)'             (byte)((floatingBits >> 16) & 0xffL)'             (byte)((floatingBits >> 8) & 0xffL)'             (byte)(floatingBits & 0xffL)'           };           outputStream.Write(bytes' 0' 5);           return 5;         case 8:           bytes = new byte[] {             (byte)0xfb'             (byte)((floatingBits >> 56) & 0xffL)'             (byte)((floatingBits >> 48) & 0xffL)'             (byte)((floatingBits >> 40) & 0xffL)'             (byte)((floatingBits >> 32) & 0xffL)'             (byte)((floatingBits >> 24) & 0xffL)'             (byte)((floatingBits >> 16) & 0xffL)'             (byte)((floatingBits >> 8) & 0xffL)'             (byte)(floatingBits & 0xffL)'           };           outputStream.Write(bytes' 0' 9);           return 9;         default:           throw new ArgumentOutOfRangeException(nameof(byteCount));       }
Magic Number,PeterO.Cbor,CBORObject,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORObject.cs,WriteFloatingPointBits,The following statement contains a magic number: switch (byteCount) {         case 2:           bytes = new byte[] {             (byte)0xf9'             (byte)((floatingBits >> 8) & 0xffL)'             (byte)(floatingBits & 0xffL)'           };           outputStream.Write(bytes' 0' 3);           return 3;         case 4:           bytes = new byte[] {             (byte)0xfa'             (byte)((floatingBits >> 24) & 0xffL)'             (byte)((floatingBits >> 16) & 0xffL)'             (byte)((floatingBits >> 8) & 0xffL)'             (byte)(floatingBits & 0xffL)'           };           outputStream.Write(bytes' 0' 5);           return 5;         case 8:           bytes = new byte[] {             (byte)0xfb'             (byte)((floatingBits >> 56) & 0xffL)'             (byte)((floatingBits >> 48) & 0xffL)'             (byte)((floatingBits >> 40) & 0xffL)'             (byte)((floatingBits >> 32) & 0xffL)'             (byte)((floatingBits >> 24) & 0xffL)'             (byte)((floatingBits >> 16) & 0xffL)'             (byte)((floatingBits >> 8) & 0xffL)'             (byte)(floatingBits & 0xffL)'           };           outputStream.Write(bytes' 0' 9);           return 9;         default:           throw new ArgumentOutOfRangeException(nameof(byteCount));       }
Magic Number,PeterO.Cbor,CBORObject,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORObject.cs,WriteFloatingPointBits,The following statement contains a magic number: switch (byteCount) {         case 2:           bytes = new byte[] {             (byte)0xf9'             (byte)((floatingBits >> 8) & 0xffL)'             (byte)(floatingBits & 0xffL)'           };           outputStream.Write(bytes' 0' 3);           return 3;         case 4:           bytes = new byte[] {             (byte)0xfa'             (byte)((floatingBits >> 24) & 0xffL)'             (byte)((floatingBits >> 16) & 0xffL)'             (byte)((floatingBits >> 8) & 0xffL)'             (byte)(floatingBits & 0xffL)'           };           outputStream.Write(bytes' 0' 5);           return 5;         case 8:           bytes = new byte[] {             (byte)0xfb'             (byte)((floatingBits >> 56) & 0xffL)'             (byte)((floatingBits >> 48) & 0xffL)'             (byte)((floatingBits >> 40) & 0xffL)'             (byte)((floatingBits >> 32) & 0xffL)'             (byte)((floatingBits >> 24) & 0xffL)'             (byte)((floatingBits >> 16) & 0xffL)'             (byte)((floatingBits >> 8) & 0xffL)'             (byte)(floatingBits & 0xffL)'           };           outputStream.Write(bytes' 0' 9);           return 9;         default:           throw new ArgumentOutOfRangeException(nameof(byteCount));       }
Magic Number,PeterO.Cbor,CBORObject,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORObject.cs,WriteFloatingPointBits,The following statement contains a magic number: switch (byteCount) {         case 2:           bytes = new byte[] {             (byte)0xf9'             (byte)((floatingBits >> 8) & 0xffL)'             (byte)(floatingBits & 0xffL)'           };           outputStream.Write(bytes' 0' 3);           return 3;         case 4:           bytes = new byte[] {             (byte)0xfa'             (byte)((floatingBits >> 24) & 0xffL)'             (byte)((floatingBits >> 16) & 0xffL)'             (byte)((floatingBits >> 8) & 0xffL)'             (byte)(floatingBits & 0xffL)'           };           outputStream.Write(bytes' 0' 5);           return 5;         case 8:           bytes = new byte[] {             (byte)0xfb'             (byte)((floatingBits >> 56) & 0xffL)'             (byte)((floatingBits >> 48) & 0xffL)'             (byte)((floatingBits >> 40) & 0xffL)'             (byte)((floatingBits >> 32) & 0xffL)'             (byte)((floatingBits >> 24) & 0xffL)'             (byte)((floatingBits >> 16) & 0xffL)'             (byte)((floatingBits >> 8) & 0xffL)'             (byte)(floatingBits & 0xffL)'           };           outputStream.Write(bytes' 0' 9);           return 9;         default:           throw new ArgumentOutOfRangeException(nameof(byteCount));       }
Magic Number,PeterO.Cbor,CBORObject,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORObject.cs,WriteFloatingPointBits,The following statement contains a magic number: switch (byteCount) {         case 2:           bytes = new byte[] {             (byte)0xf9'             (byte)((floatingBits >> 8) & 0xffL)'             (byte)(floatingBits & 0xffL)'           };           outputStream.Write(bytes' 0' 3);           return 3;         case 4:           bytes = new byte[] {             (byte)0xfa'             (byte)((floatingBits >> 24) & 0xffL)'             (byte)((floatingBits >> 16) & 0xffL)'             (byte)((floatingBits >> 8) & 0xffL)'             (byte)(floatingBits & 0xffL)'           };           outputStream.Write(bytes' 0' 5);           return 5;         case 8:           bytes = new byte[] {             (byte)0xfb'             (byte)((floatingBits >> 56) & 0xffL)'             (byte)((floatingBits >> 48) & 0xffL)'             (byte)((floatingBits >> 40) & 0xffL)'             (byte)((floatingBits >> 32) & 0xffL)'             (byte)((floatingBits >> 24) & 0xffL)'             (byte)((floatingBits >> 16) & 0xffL)'             (byte)((floatingBits >> 8) & 0xffL)'             (byte)(floatingBits & 0xffL)'           };           outputStream.Write(bytes' 0' 9);           return 9;         default:           throw new ArgumentOutOfRangeException(nameof(byteCount));       }
Magic Number,PeterO.Cbor,CBORObject,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORObject.cs,WriteFloatingPointBits,The following statement contains a magic number: switch (byteCount) {         case 2:           bytes = new byte[] {             (byte)0xf9'             (byte)((floatingBits >> 8) & 0xffL)'             (byte)(floatingBits & 0xffL)'           };           outputStream.Write(bytes' 0' 3);           return 3;         case 4:           bytes = new byte[] {             (byte)0xfa'             (byte)((floatingBits >> 24) & 0xffL)'             (byte)((floatingBits >> 16) & 0xffL)'             (byte)((floatingBits >> 8) & 0xffL)'             (byte)(floatingBits & 0xffL)'           };           outputStream.Write(bytes' 0' 5);           return 5;         case 8:           bytes = new byte[] {             (byte)0xfb'             (byte)((floatingBits >> 56) & 0xffL)'             (byte)((floatingBits >> 48) & 0xffL)'             (byte)((floatingBits >> 40) & 0xffL)'             (byte)((floatingBits >> 32) & 0xffL)'             (byte)((floatingBits >> 24) & 0xffL)'             (byte)((floatingBits >> 16) & 0xffL)'             (byte)((floatingBits >> 8) & 0xffL)'             (byte)(floatingBits & 0xffL)'           };           outputStream.Write(bytes' 0' 9);           return 9;         default:           throw new ArgumentOutOfRangeException(nameof(byteCount));       }
Magic Number,PeterO.Cbor,CBORObject,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORObject.cs,WriteFloatingPointBits,The following statement contains a magic number: switch (byteCount) {         case 2:           bytes = new byte[] {             (byte)0xf9'             (byte)((floatingBits >> 8) & 0xffL)'             (byte)(floatingBits & 0xffL)'           };           outputStream.Write(bytes' 0' 3);           return 3;         case 4:           bytes = new byte[] {             (byte)0xfa'             (byte)((floatingBits >> 24) & 0xffL)'             (byte)((floatingBits >> 16) & 0xffL)'             (byte)((floatingBits >> 8) & 0xffL)'             (byte)(floatingBits & 0xffL)'           };           outputStream.Write(bytes' 0' 5);           return 5;         case 8:           bytes = new byte[] {             (byte)0xfb'             (byte)((floatingBits >> 56) & 0xffL)'             (byte)((floatingBits >> 48) & 0xffL)'             (byte)((floatingBits >> 40) & 0xffL)'             (byte)((floatingBits >> 32) & 0xffL)'             (byte)((floatingBits >> 24) & 0xffL)'             (byte)((floatingBits >> 16) & 0xffL)'             (byte)((floatingBits >> 8) & 0xffL)'             (byte)(floatingBits & 0xffL)'           };           outputStream.Write(bytes' 0' 9);           return 9;         default:           throw new ArgumentOutOfRangeException(nameof(byteCount));       }
Magic Number,PeterO.Cbor,CBORObject,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORObject.cs,WriteFloatingPointBits,The following statement contains a magic number: switch (byteCount) {         case 2:           bytes = new byte[] {             (byte)0xf9'             (byte)((floatingBits >> 8) & 0xffL)'             (byte)(floatingBits & 0xffL)'           };           outputStream.Write(bytes' 0' 3);           return 3;         case 4:           bytes = new byte[] {             (byte)0xfa'             (byte)((floatingBits >> 24) & 0xffL)'             (byte)((floatingBits >> 16) & 0xffL)'             (byte)((floatingBits >> 8) & 0xffL)'             (byte)(floatingBits & 0xffL)'           };           outputStream.Write(bytes' 0' 5);           return 5;         case 8:           bytes = new byte[] {             (byte)0xfb'             (byte)((floatingBits >> 56) & 0xffL)'             (byte)((floatingBits >> 48) & 0xffL)'             (byte)((floatingBits >> 40) & 0xffL)'             (byte)((floatingBits >> 32) & 0xffL)'             (byte)((floatingBits >> 24) & 0xffL)'             (byte)((floatingBits >> 16) & 0xffL)'             (byte)((floatingBits >> 8) & 0xffL)'             (byte)(floatingBits & 0xffL)'           };           outputStream.Write(bytes' 0' 9);           return 9;         default:           throw new ArgumentOutOfRangeException(nameof(byteCount));       }
Magic Number,PeterO.Cbor,CBORObject,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORObject.cs,WriteFloatingPointBits,The following statement contains a magic number: switch (byteCount) {         case 2:           bytes = new byte[] {             (byte)0xf9'             (byte)((floatingBits >> 8) & 0xffL)'             (byte)(floatingBits & 0xffL)'           };           outputStream.Write(bytes' 0' 3);           return 3;         case 4:           bytes = new byte[] {             (byte)0xfa'             (byte)((floatingBits >> 24) & 0xffL)'             (byte)((floatingBits >> 16) & 0xffL)'             (byte)((floatingBits >> 8) & 0xffL)'             (byte)(floatingBits & 0xffL)'           };           outputStream.Write(bytes' 0' 5);           return 5;         case 8:           bytes = new byte[] {             (byte)0xfb'             (byte)((floatingBits >> 56) & 0xffL)'             (byte)((floatingBits >> 48) & 0xffL)'             (byte)((floatingBits >> 40) & 0xffL)'             (byte)((floatingBits >> 32) & 0xffL)'             (byte)((floatingBits >> 24) & 0xffL)'             (byte)((floatingBits >> 16) & 0xffL)'             (byte)((floatingBits >> 8) & 0xffL)'             (byte)(floatingBits & 0xffL)'           };           outputStream.Write(bytes' 0' 9);           return 9;         default:           throw new ArgumentOutOfRangeException(nameof(byteCount));       }
Magic Number,PeterO.Cbor,CBORObject,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORObject.cs,WriteFloatingPointBits,The following statement contains a magic number: switch (byteCount) {         case 2:           bytes = new byte[] {             (byte)0xf9'             (byte)((floatingBits >> 8) & 0xffL)'             (byte)(floatingBits & 0xffL)'           };           outputStream.Write(bytes' 0' 3);           return 3;         case 4:           bytes = new byte[] {             (byte)0xfa'             (byte)((floatingBits >> 24) & 0xffL)'             (byte)((floatingBits >> 16) & 0xffL)'             (byte)((floatingBits >> 8) & 0xffL)'             (byte)(floatingBits & 0xffL)'           };           outputStream.Write(bytes' 0' 5);           return 5;         case 8:           bytes = new byte[] {             (byte)0xfb'             (byte)((floatingBits >> 56) & 0xffL)'             (byte)((floatingBits >> 48) & 0xffL)'             (byte)((floatingBits >> 40) & 0xffL)'             (byte)((floatingBits >> 32) & 0xffL)'             (byte)((floatingBits >> 24) & 0xffL)'             (byte)((floatingBits >> 16) & 0xffL)'             (byte)((floatingBits >> 8) & 0xffL)'             (byte)(floatingBits & 0xffL)'           };           outputStream.Write(bytes' 0' 9);           return 9;         default:           throw new ArgumentOutOfRangeException(nameof(byteCount));       }
Magic Number,PeterO.Cbor,CBORObject,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORObject.cs,WriteFloatingPointBits,The following statement contains a magic number: switch (byteCount) {         case 2:           bytes = new byte[] {             (byte)0xf9'             (byte)((floatingBits >> 8) & 0xffL)'             (byte)(floatingBits & 0xffL)'           };           outputStream.Write(bytes' 0' 3);           return 3;         case 4:           bytes = new byte[] {             (byte)0xfa'             (byte)((floatingBits >> 24) & 0xffL)'             (byte)((floatingBits >> 16) & 0xffL)'             (byte)((floatingBits >> 8) & 0xffL)'             (byte)(floatingBits & 0xffL)'           };           outputStream.Write(bytes' 0' 5);           return 5;         case 8:           bytes = new byte[] {             (byte)0xfb'             (byte)((floatingBits >> 56) & 0xffL)'             (byte)((floatingBits >> 48) & 0xffL)'             (byte)((floatingBits >> 40) & 0xffL)'             (byte)((floatingBits >> 32) & 0xffL)'             (byte)((floatingBits >> 24) & 0xffL)'             (byte)((floatingBits >> 16) & 0xffL)'             (byte)((floatingBits >> 8) & 0xffL)'             (byte)(floatingBits & 0xffL)'           };           outputStream.Write(bytes' 0' 9);           return 9;         default:           throw new ArgumentOutOfRangeException(nameof(byteCount));       }
Magic Number,PeterO.Cbor,CBORObject,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORObject.cs,WriteFloatingPointBits,The following statement contains a magic number: switch (byteCount) {         case 2:           bytes = new byte[] {             (byte)0xf9'             (byte)((floatingBits >> 8) & 0xffL)'             (byte)(floatingBits & 0xffL)'           };           outputStream.Write(bytes' 0' 3);           return 3;         case 4:           bytes = new byte[] {             (byte)0xfa'             (byte)((floatingBits >> 24) & 0xffL)'             (byte)((floatingBits >> 16) & 0xffL)'             (byte)((floatingBits >> 8) & 0xffL)'             (byte)(floatingBits & 0xffL)'           };           outputStream.Write(bytes' 0' 5);           return 5;         case 8:           bytes = new byte[] {             (byte)0xfb'             (byte)((floatingBits >> 56) & 0xffL)'             (byte)((floatingBits >> 48) & 0xffL)'             (byte)((floatingBits >> 40) & 0xffL)'             (byte)((floatingBits >> 32) & 0xffL)'             (byte)((floatingBits >> 24) & 0xffL)'             (byte)((floatingBits >> 16) & 0xffL)'             (byte)((floatingBits >> 8) & 0xffL)'             (byte)(floatingBits & 0xffL)'           };           outputStream.Write(bytes' 0' 9);           return 9;         default:           throw new ArgumentOutOfRangeException(nameof(byteCount));       }
Magic Number,PeterO.Cbor,CBORObject,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORObject.cs,WriteFloatingPointBits,The following statement contains a magic number: switch (byteCount) {         case 2:           bytes = new byte[] {             (byte)0xf9'             (byte)((floatingBits >> 8) & 0xffL)'             (byte)(floatingBits & 0xffL)'           };           outputStream.Write(bytes' 0' 3);           return 3;         case 4:           bytes = new byte[] {             (byte)0xfa'             (byte)((floatingBits >> 24) & 0xffL)'             (byte)((floatingBits >> 16) & 0xffL)'             (byte)((floatingBits >> 8) & 0xffL)'             (byte)(floatingBits & 0xffL)'           };           outputStream.Write(bytes' 0' 5);           return 5;         case 8:           bytes = new byte[] {             (byte)0xfb'             (byte)((floatingBits >> 56) & 0xffL)'             (byte)((floatingBits >> 48) & 0xffL)'             (byte)((floatingBits >> 40) & 0xffL)'             (byte)((floatingBits >> 32) & 0xffL)'             (byte)((floatingBits >> 24) & 0xffL)'             (byte)((floatingBits >> 16) & 0xffL)'             (byte)((floatingBits >> 8) & 0xffL)'             (byte)(floatingBits & 0xffL)'           };           outputStream.Write(bytes' 0' 9);           return 9;         default:           throw new ArgumentOutOfRangeException(nameof(byteCount));       }
Magic Number,PeterO.Cbor,CBORObject,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORObject.cs,WriteFloatingPointBits,The following statement contains a magic number: switch (byteCount) {         case 2:           bytes = new byte[] {             (byte)0xf9'             (byte)((floatingBits >> 8) & 0xffL)'             (byte)(floatingBits & 0xffL)'           };           outputStream.Write(bytes' 0' 3);           return 3;         case 4:           bytes = new byte[] {             (byte)0xfa'             (byte)((floatingBits >> 24) & 0xffL)'             (byte)((floatingBits >> 16) & 0xffL)'             (byte)((floatingBits >> 8) & 0xffL)'             (byte)(floatingBits & 0xffL)'           };           outputStream.Write(bytes' 0' 5);           return 5;         case 8:           bytes = new byte[] {             (byte)0xfb'             (byte)((floatingBits >> 56) & 0xffL)'             (byte)((floatingBits >> 48) & 0xffL)'             (byte)((floatingBits >> 40) & 0xffL)'             (byte)((floatingBits >> 32) & 0xffL)'             (byte)((floatingBits >> 24) & 0xffL)'             (byte)((floatingBits >> 16) & 0xffL)'             (byte)((floatingBits >> 8) & 0xffL)'             (byte)(floatingBits & 0xffL)'           };           outputStream.Write(bytes' 0' 9);           return 9;         default:           throw new ArgumentOutOfRangeException(nameof(byteCount));       }
Magic Number,PeterO.Cbor,CBORObject,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORObject.cs,WriteFloatingPointBits,The following statement contains a magic number: switch (byteCount) {         case 2:           bytes = new byte[] {             (byte)0xf9'             (byte)((floatingBits >> 8) & 0xffL)'             (byte)(floatingBits & 0xffL)'           };           outputStream.Write(bytes' 0' 3);           return 3;         case 4:           bytes = new byte[] {             (byte)0xfa'             (byte)((floatingBits >> 24) & 0xffL)'             (byte)((floatingBits >> 16) & 0xffL)'             (byte)((floatingBits >> 8) & 0xffL)'             (byte)(floatingBits & 0xffL)'           };           outputStream.Write(bytes' 0' 5);           return 5;         case 8:           bytes = new byte[] {             (byte)0xfb'             (byte)((floatingBits >> 56) & 0xffL)'             (byte)((floatingBits >> 48) & 0xffL)'             (byte)((floatingBits >> 40) & 0xffL)'             (byte)((floatingBits >> 32) & 0xffL)'             (byte)((floatingBits >> 24) & 0xffL)'             (byte)((floatingBits >> 16) & 0xffL)'             (byte)((floatingBits >> 8) & 0xffL)'             (byte)(floatingBits & 0xffL)'           };           outputStream.Write(bytes' 0' 9);           return 9;         default:           throw new ArgumentOutOfRangeException(nameof(byteCount));       }
Magic Number,PeterO.Cbor,CBORObject,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORObject.cs,WriteFloatingPointValue,The following statement contains a magic number: switch (byteCount) {         case 2:           bits = CBORUtilities.DoubleToInt64Bits(doubleVal);           bits = CBORUtilities.DoubleToRoundedHalfPrecision(bits);           bits &= 0xffffL;           return WriteFloatingPointBits(outputStream' bits' 2);         case 4:           bits = CBORUtilities.DoubleToInt64Bits(doubleVal);           bits = CBORUtilities.DoubleToRoundedSinglePrecision(bits);           bits &= 0xffffffffL;           return WriteFloatingPointBits(outputStream' bits' 4);         case 8:           bits = CBORUtilities.DoubleToInt64Bits(doubleVal);           // DebugUtility.Log("dbl " + doubleVal + " -> " + (bits));           return WriteFloatingPointBits(outputStream' bits' 8);         default: throw new ArgumentOutOfRangeException(nameof(byteCount));       }
Magic Number,PeterO.Cbor,CBORObject,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORObject.cs,WriteFloatingPointValue,The following statement contains a magic number: switch (byteCount) {         case 2:           bits = CBORUtilities.DoubleToInt64Bits(doubleVal);           bits = CBORUtilities.DoubleToRoundedHalfPrecision(bits);           bits &= 0xffffL;           return WriteFloatingPointBits(outputStream' bits' 2);         case 4:           bits = CBORUtilities.DoubleToInt64Bits(doubleVal);           bits = CBORUtilities.DoubleToRoundedSinglePrecision(bits);           bits &= 0xffffffffL;           return WriteFloatingPointBits(outputStream' bits' 4);         case 8:           bits = CBORUtilities.DoubleToInt64Bits(doubleVal);           // DebugUtility.Log("dbl " + doubleVal + " -> " + (bits));           return WriteFloatingPointBits(outputStream' bits' 8);         default: throw new ArgumentOutOfRangeException(nameof(byteCount));       }
Magic Number,PeterO.Cbor,CBORObject,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORObject.cs,WriteFloatingPointValue,The following statement contains a magic number: switch (byteCount) {         case 2:           bits = CBORUtilities.DoubleToInt64Bits(doubleVal);           bits = CBORUtilities.DoubleToRoundedHalfPrecision(bits);           bits &= 0xffffL;           return WriteFloatingPointBits(outputStream' bits' 2);         case 4:           bits = CBORUtilities.DoubleToInt64Bits(doubleVal);           bits = CBORUtilities.DoubleToRoundedSinglePrecision(bits);           bits &= 0xffffffffL;           return WriteFloatingPointBits(outputStream' bits' 4);         case 8:           bits = CBORUtilities.DoubleToInt64Bits(doubleVal);           // DebugUtility.Log("dbl " + doubleVal + " -> " + (bits));           return WriteFloatingPointBits(outputStream' bits' 8);         default: throw new ArgumentOutOfRangeException(nameof(byteCount));       }
Magic Number,PeterO.Cbor,CBORObject,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORObject.cs,WriteFloatingPointValue,The following statement contains a magic number: switch (byteCount) {         case 2:           bits = CBORUtilities.DoubleToInt64Bits(doubleVal);           bits = CBORUtilities.DoubleToRoundedHalfPrecision(bits);           bits &= 0xffffL;           return WriteFloatingPointBits(outputStream' bits' 2);         case 4:           bits = CBORUtilities.DoubleToInt64Bits(doubleVal);           bits = CBORUtilities.DoubleToRoundedSinglePrecision(bits);           bits &= 0xffffffffL;           return WriteFloatingPointBits(outputStream' bits' 4);         case 8:           bits = CBORUtilities.DoubleToInt64Bits(doubleVal);           // DebugUtility.Log("dbl " + doubleVal + " -> " + (bits));           return WriteFloatingPointBits(outputStream' bits' 8);         default: throw new ArgumentOutOfRangeException(nameof(byteCount));       }
Magic Number,PeterO.Cbor,CBORObject,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORObject.cs,WriteFloatingPointValue,The following statement contains a magic number: switch (byteCount) {         case 2:           bits = CBORUtilities.DoubleToInt64Bits(doubleVal);           bits = CBORUtilities.DoubleToRoundedHalfPrecision(bits);           bits &= 0xffffL;           return WriteFloatingPointBits(outputStream' bits' 2);         case 4:           bits = CBORUtilities.DoubleToInt64Bits(doubleVal);           bits = CBORUtilities.DoubleToRoundedSinglePrecision(bits);           bits &= 0xffffffffL;           return WriteFloatingPointBits(outputStream' bits' 4);         case 8:           bits = CBORUtilities.DoubleToInt64Bits(doubleVal);           // DebugUtility.Log("dbl " + doubleVal + " -> " + (bits));           return WriteFloatingPointBits(outputStream' bits' 8);         default: throw new ArgumentOutOfRangeException(nameof(byteCount));       }
Magic Number,PeterO.Cbor,CBORObject,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORObject.cs,WriteFloatingPointValue,The following statement contains a magic number: switch (byteCount) {         case 2:           bits = CBORUtilities.DoubleToInt64Bits(doubleVal);           bits = CBORUtilities.DoubleToRoundedHalfPrecision(bits);           bits &= 0xffffL;           return WriteFloatingPointBits(outputStream' bits' 2);         case 4:           bits = CBORUtilities.DoubleToInt64Bits(doubleVal);           bits = CBORUtilities.DoubleToRoundedSinglePrecision(bits);           bits &= 0xffffffffL;           return WriteFloatingPointBits(outputStream' bits' 4);         case 8:           bits = CBORUtilities.DoubleToInt64Bits(doubleVal);           // DebugUtility.Log("dbl " + doubleVal + " -> " + (bits));           return WriteFloatingPointBits(outputStream' bits' 8);         default: throw new ArgumentOutOfRangeException(nameof(byteCount));       }
Magic Number,PeterO.Cbor,CBORObject,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORObject.cs,WriteFloatingPointValue,The following statement contains a magic number: switch (byteCount) {         case 2:           bits = BitConverter.ToInt32(               BitConverter.GetBytes((float)singleVal)'               0);           bits = CBORUtilities.SingleToRoundedHalfPrecision(bits);           bits &= 0xffff;           return WriteFloatingPointBits(outputStream' bits' 2);         case 4:           bits = BitConverter.ToInt32(               BitConverter.GetBytes((float)singleVal)'               0);           longbits = ((long)bits) & 0xffffffffL;           return WriteFloatingPointBits(outputStream' longbits' 4);         case 8:           bits = BitConverter.ToInt32(               BitConverter.GetBytes((float)singleVal)'               0);           longbits = CBORUtilities.SingleToDoublePrecision(bits);           return WriteFloatingPointBits(outputStream' longbits' 8);         default: throw new ArgumentOutOfRangeException(nameof(byteCount));       }
Magic Number,PeterO.Cbor,CBORObject,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORObject.cs,WriteFloatingPointValue,The following statement contains a magic number: switch (byteCount) {         case 2:           bits = BitConverter.ToInt32(               BitConverter.GetBytes((float)singleVal)'               0);           bits = CBORUtilities.SingleToRoundedHalfPrecision(bits);           bits &= 0xffff;           return WriteFloatingPointBits(outputStream' bits' 2);         case 4:           bits = BitConverter.ToInt32(               BitConverter.GetBytes((float)singleVal)'               0);           longbits = ((long)bits) & 0xffffffffL;           return WriteFloatingPointBits(outputStream' longbits' 4);         case 8:           bits = BitConverter.ToInt32(               BitConverter.GetBytes((float)singleVal)'               0);           longbits = CBORUtilities.SingleToDoublePrecision(bits);           return WriteFloatingPointBits(outputStream' longbits' 8);         default: throw new ArgumentOutOfRangeException(nameof(byteCount));       }
Magic Number,PeterO.Cbor,CBORObject,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORObject.cs,WriteFloatingPointValue,The following statement contains a magic number: switch (byteCount) {         case 2:           bits = BitConverter.ToInt32(               BitConverter.GetBytes((float)singleVal)'               0);           bits = CBORUtilities.SingleToRoundedHalfPrecision(bits);           bits &= 0xffff;           return WriteFloatingPointBits(outputStream' bits' 2);         case 4:           bits = BitConverter.ToInt32(               BitConverter.GetBytes((float)singleVal)'               0);           longbits = ((long)bits) & 0xffffffffL;           return WriteFloatingPointBits(outputStream' longbits' 4);         case 8:           bits = BitConverter.ToInt32(               BitConverter.GetBytes((float)singleVal)'               0);           longbits = CBORUtilities.SingleToDoublePrecision(bits);           return WriteFloatingPointBits(outputStream' longbits' 8);         default: throw new ArgumentOutOfRangeException(nameof(byteCount));       }
Magic Number,PeterO.Cbor,CBORObject,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORObject.cs,WriteFloatingPointValue,The following statement contains a magic number: switch (byteCount) {         case 2:           bits = BitConverter.ToInt32(               BitConverter.GetBytes((float)singleVal)'               0);           bits = CBORUtilities.SingleToRoundedHalfPrecision(bits);           bits &= 0xffff;           return WriteFloatingPointBits(outputStream' bits' 2);         case 4:           bits = BitConverter.ToInt32(               BitConverter.GetBytes((float)singleVal)'               0);           longbits = ((long)bits) & 0xffffffffL;           return WriteFloatingPointBits(outputStream' longbits' 4);         case 8:           bits = BitConverter.ToInt32(               BitConverter.GetBytes((float)singleVal)'               0);           longbits = CBORUtilities.SingleToDoublePrecision(bits);           return WriteFloatingPointBits(outputStream' longbits' 8);         default: throw new ArgumentOutOfRangeException(nameof(byteCount));       }
Magic Number,PeterO.Cbor,CBORObject,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORObject.cs,WriteFloatingPointValue,The following statement contains a magic number: switch (byteCount) {         case 2:           bits = BitConverter.ToInt32(               BitConverter.GetBytes((float)singleVal)'               0);           bits = CBORUtilities.SingleToRoundedHalfPrecision(bits);           bits &= 0xffff;           return WriteFloatingPointBits(outputStream' bits' 2);         case 4:           bits = BitConverter.ToInt32(               BitConverter.GetBytes((float)singleVal)'               0);           longbits = ((long)bits) & 0xffffffffL;           return WriteFloatingPointBits(outputStream' longbits' 4);         case 8:           bits = BitConverter.ToInt32(               BitConverter.GetBytes((float)singleVal)'               0);           longbits = CBORUtilities.SingleToDoublePrecision(bits);           return WriteFloatingPointBits(outputStream' longbits' 8);         default: throw new ArgumentOutOfRangeException(nameof(byteCount));       }
Magic Number,PeterO.Cbor,CBORObject,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORObject.cs,WriteFloatingPointValue,The following statement contains a magic number: switch (byteCount) {         case 2:           bits = BitConverter.ToInt32(               BitConverter.GetBytes((float)singleVal)'               0);           bits = CBORUtilities.SingleToRoundedHalfPrecision(bits);           bits &= 0xffff;           return WriteFloatingPointBits(outputStream' bits' 2);         case 4:           bits = BitConverter.ToInt32(               BitConverter.GetBytes((float)singleVal)'               0);           longbits = ((long)bits) & 0xffffffffL;           return WriteFloatingPointBits(outputStream' longbits' 4);         case 8:           bits = BitConverter.ToInt32(               BitConverter.GetBytes((float)singleVal)'               0);           longbits = CBORUtilities.SingleToDoublePrecision(bits);           return WriteFloatingPointBits(outputStream' longbits' 8);         default: throw new ArgumentOutOfRangeException(nameof(byteCount));       }
Magic Number,PeterO.Cbor,CBORObject,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORObject.cs,WriteValue,The following statement contains a magic number: majorType > 7
Magic Number,PeterO.Cbor,CBORObject,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORObject.cs,WriteValue,The following statement contains a magic number: value > 255
Magic Number,PeterO.Cbor,CBORObject,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORObject.cs,WriteValue,The following statement contains a magic number: value <= 23
Magic Number,PeterO.Cbor,CBORObject,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORObject.cs,WriteValue,The following statement contains a magic number: majorType == 7
Magic Number,PeterO.Cbor,CBORObject,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORObject.cs,WriteValue,The following statement contains a magic number: majorType > 7
Magic Number,PeterO.Cbor,CBORObject,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORObject.cs,WriteValue,The following statement contains a magic number: value > 255
Magic Number,PeterO.Cbor,CBORObject,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORObject.cs,WriteValue,The following statement contains a magic number: value <= 23
Magic Number,PeterO.Cbor,CBORObject,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORObject.cs,WriteValue,The following statement contains a magic number: majorType == 7
Magic Number,PeterO.Cbor,CBORObject,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORObject.cs,WriteValue,The following statement contains a magic number: var highbyte = (int)((longVal >> 56) & 0xff);
Magic Number,PeterO.Cbor,CBORObject,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORObject.cs,WriteValue,The following statement contains a magic number: majorType > 7
Magic Number,PeterO.Cbor,CBORObject,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORObject.cs,WriteValue,The following statement contains a magic number: majorType == 7
Magic Number,PeterO.Cbor,CBORObject,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORObject.cs,WriteValue,The following statement contains a magic number: byte[] bytes = new[] {         (byte)(27 | (majorType << 5))' (byte)highbyte'         (byte)((longVal >> 48) & 0xff)' (byte)((longVal >> 40) & 0xff)'         (byte)((longVal >> 32) & 0xff)' (byte)((longVal >> 24) & 0xff)'         (byte)((longVal >> 16) & 0xff)' (byte)((longVal >> 8) & 0xff)'         (byte)(longVal & 0xff)'       };
Magic Number,PeterO.Cbor,CBORObject,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORObject.cs,WriteValue,The following statement contains a magic number: byte[] bytes = new[] {         (byte)(27 | (majorType << 5))' (byte)highbyte'         (byte)((longVal >> 48) & 0xff)' (byte)((longVal >> 40) & 0xff)'         (byte)((longVal >> 32) & 0xff)' (byte)((longVal >> 24) & 0xff)'         (byte)((longVal >> 16) & 0xff)' (byte)((longVal >> 8) & 0xff)'         (byte)(longVal & 0xff)'       };
Magic Number,PeterO.Cbor,CBORObject,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORObject.cs,WriteValue,The following statement contains a magic number: byte[] bytes = new[] {         (byte)(27 | (majorType << 5))' (byte)highbyte'         (byte)((longVal >> 48) & 0xff)' (byte)((longVal >> 40) & 0xff)'         (byte)((longVal >> 32) & 0xff)' (byte)((longVal >> 24) & 0xff)'         (byte)((longVal >> 16) & 0xff)' (byte)((longVal >> 8) & 0xff)'         (byte)(longVal & 0xff)'       };
Magic Number,PeterO.Cbor,CBORObject,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORObject.cs,WriteValue,The following statement contains a magic number: byte[] bytes = new[] {         (byte)(27 | (majorType << 5))' (byte)highbyte'         (byte)((longVal >> 48) & 0xff)' (byte)((longVal >> 40) & 0xff)'         (byte)((longVal >> 32) & 0xff)' (byte)((longVal >> 24) & 0xff)'         (byte)((longVal >> 16) & 0xff)' (byte)((longVal >> 8) & 0xff)'         (byte)(longVal & 0xff)'       };
Magic Number,PeterO.Cbor,CBORObject,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORObject.cs,WriteValue,The following statement contains a magic number: byte[] bytes = new[] {         (byte)(27 | (majorType << 5))' (byte)highbyte'         (byte)((longVal >> 48) & 0xff)' (byte)((longVal >> 40) & 0xff)'         (byte)((longVal >> 32) & 0xff)' (byte)((longVal >> 24) & 0xff)'         (byte)((longVal >> 16) & 0xff)' (byte)((longVal >> 8) & 0xff)'         (byte)(longVal & 0xff)'       };
Magic Number,PeterO.Cbor,CBORObject,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORObject.cs,WriteValue,The following statement contains a magic number: byte[] bytes = new[] {         (byte)(27 | (majorType << 5))' (byte)highbyte'         (byte)((longVal >> 48) & 0xff)' (byte)((longVal >> 40) & 0xff)'         (byte)((longVal >> 32) & 0xff)' (byte)((longVal >> 24) & 0xff)'         (byte)((longVal >> 16) & 0xff)' (byte)((longVal >> 8) & 0xff)'         (byte)(longVal & 0xff)'       };
Magic Number,PeterO.Cbor,CBORObject,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORObject.cs,WriteValue,The following statement contains a magic number: byte[] bytes = new[] {         (byte)(27 | (majorType << 5))' (byte)highbyte'         (byte)((longVal >> 48) & 0xff)' (byte)((longVal >> 40) & 0xff)'         (byte)((longVal >> 32) & 0xff)' (byte)((longVal >> 24) & 0xff)'         (byte)((longVal >> 16) & 0xff)' (byte)((longVal >> 8) & 0xff)'         (byte)(longVal & 0xff)'       };
Magic Number,PeterO.Cbor,CBORObject,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORObject.cs,WriteValue,The following statement contains a magic number: byte[] bytes = new[] {         (byte)(27 | (majorType << 5))' (byte)highbyte'         (byte)((longVal >> 48) & 0xff)' (byte)((longVal >> 40) & 0xff)'         (byte)((longVal >> 32) & 0xff)' (byte)((longVal >> 24) & 0xff)'         (byte)((longVal >> 16) & 0xff)' (byte)((longVal >> 8) & 0xff)'         (byte)(longVal & 0xff)'       };
Magic Number,PeterO.Cbor,CBORObject,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORObject.cs,WriteTo,The following statement contains a magic number: switch (type) {         case CBORObjectTypeInteger: {           Write((long)this.ThisItem' stream);           break;         }         case CBORObjectTypeEInteger: {           Write((EInteger)this.ThisItem' stream);           break;         }         case CBORObjectTypeByteString: {           byte[] arr = this.GetByteString();           WritePositiveInt(             (this.Type == CBORType.ByteString) ? 2 : 3'             arr.Length'             stream);           stream.Write(arr' 0' arr.Length);           break;         }         case CBORObjectTypeTextString: {           Write((string)this.ThisItem' stream' options);           break;         }         case CBORObjectTypeArray: {           WriteObjectArray(this.AsList()' stream' options);           break;         }         case CBORObjectTypeMap: {           WriteObjectMap(this.AsMap()' stream' options);           break;         }         case CBORObjectTypeSimpleValue: {           int value = this.SimpleValue;           if (value < 24) {             stream.WriteByte((byte)(0xe0 + value));           } else {             #if DEBUG             if (value < 32) {               throw new ArgumentException("value(" + value +                 ") is less than " + "32");             }             #endif              stream.WriteByte(0xf8);             stream.WriteByte((byte)value);           }            break;         }         case CBORObjectTypeDouble: {           byte[] data = GetDoubleBytes(this.AsDoubleBits()' 0);           stream.Write(data' 0' data.Length);           break;         }         default: {           throw new ArgumentException("Unexpected data type");         }       }
Magic Number,PeterO.Cbor,CBORObject,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORObject.cs,WriteTo,The following statement contains a magic number: switch (type) {         case CBORObjectTypeInteger: {           Write((long)this.ThisItem' stream);           break;         }         case CBORObjectTypeEInteger: {           Write((EInteger)this.ThisItem' stream);           break;         }         case CBORObjectTypeByteString: {           byte[] arr = this.GetByteString();           WritePositiveInt(             (this.Type == CBORType.ByteString) ? 2 : 3'             arr.Length'             stream);           stream.Write(arr' 0' arr.Length);           break;         }         case CBORObjectTypeTextString: {           Write((string)this.ThisItem' stream' options);           break;         }         case CBORObjectTypeArray: {           WriteObjectArray(this.AsList()' stream' options);           break;         }         case CBORObjectTypeMap: {           WriteObjectMap(this.AsMap()' stream' options);           break;         }         case CBORObjectTypeSimpleValue: {           int value = this.SimpleValue;           if (value < 24) {             stream.WriteByte((byte)(0xe0 + value));           } else {             #if DEBUG             if (value < 32) {               throw new ArgumentException("value(" + value +                 ") is less than " + "32");             }             #endif              stream.WriteByte(0xf8);             stream.WriteByte((byte)value);           }            break;         }         case CBORObjectTypeDouble: {           byte[] data = GetDoubleBytes(this.AsDoubleBits()' 0);           stream.Write(data' 0' data.Length);           break;         }         default: {           throw new ArgumentException("Unexpected data type");         }       }
Magic Number,PeterO.Cbor,CBORObject,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORObject.cs,WriteTo,The following statement contains a magic number: switch (type) {         case CBORObjectTypeInteger: {           Write((long)this.ThisItem' stream);           break;         }         case CBORObjectTypeEInteger: {           Write((EInteger)this.ThisItem' stream);           break;         }         case CBORObjectTypeByteString: {           byte[] arr = this.GetByteString();           WritePositiveInt(             (this.Type == CBORType.ByteString) ? 2 : 3'             arr.Length'             stream);           stream.Write(arr' 0' arr.Length);           break;         }         case CBORObjectTypeTextString: {           Write((string)this.ThisItem' stream' options);           break;         }         case CBORObjectTypeArray: {           WriteObjectArray(this.AsList()' stream' options);           break;         }         case CBORObjectTypeMap: {           WriteObjectMap(this.AsMap()' stream' options);           break;         }         case CBORObjectTypeSimpleValue: {           int value = this.SimpleValue;           if (value < 24) {             stream.WriteByte((byte)(0xe0 + value));           } else {             #if DEBUG             if (value < 32) {               throw new ArgumentException("value(" + value +                 ") is less than " + "32");             }             #endif              stream.WriteByte(0xf8);             stream.WriteByte((byte)value);           }            break;         }         case CBORObjectTypeDouble: {           byte[] data = GetDoubleBytes(this.AsDoubleBits()' 0);           stream.Write(data' 0' data.Length);           break;         }         default: {           throw new ArgumentException("Unexpected data type");         }       }
Magic Number,PeterO.Cbor,CBORObject,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORObject.cs,WriteTo,The following statement contains a magic number: switch (type) {         case CBORObjectTypeInteger: {           Write((long)this.ThisItem' stream);           break;         }         case CBORObjectTypeEInteger: {           Write((EInteger)this.ThisItem' stream);           break;         }         case CBORObjectTypeByteString: {           byte[] arr = this.GetByteString();           WritePositiveInt(             (this.Type == CBORType.ByteString) ? 2 : 3'             arr.Length'             stream);           stream.Write(arr' 0' arr.Length);           break;         }         case CBORObjectTypeTextString: {           Write((string)this.ThisItem' stream' options);           break;         }         case CBORObjectTypeArray: {           WriteObjectArray(this.AsList()' stream' options);           break;         }         case CBORObjectTypeMap: {           WriteObjectMap(this.AsMap()' stream' options);           break;         }         case CBORObjectTypeSimpleValue: {           int value = this.SimpleValue;           if (value < 24) {             stream.WriteByte((byte)(0xe0 + value));           } else {             #if DEBUG             if (value < 32) {               throw new ArgumentException("value(" + value +                 ") is less than " + "32");             }             #endif              stream.WriteByte(0xf8);             stream.WriteByte((byte)value);           }            break;         }         case CBORObjectTypeDouble: {           byte[] data = GetDoubleBytes(this.AsDoubleBits()' 0);           stream.Write(data' 0' data.Length);           break;         }         default: {           throw new ArgumentException("Unexpected data type");         }       }
Magic Number,PeterO.Cbor,CBORObject,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORObject.cs,GetFixedLengthObject,The following statement contains a magic number: int majortype = firstbyte >> 5;
Magic Number,PeterO.Cbor,CBORObject,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORObject.cs,GetFixedLengthObject,The following statement contains a magic number: switch (firstbyte & 0x1f) {           case 24:             uadditional = (int)(data[1] & (int)0xff);             break;           case 25:             uadditional = (data[1] & 0xffL) << 8;             uadditional |= (long)(data[2] & 0xffL);             break;           case 26:             uadditional = (data[1] & 0xffL) << 24;             uadditional |= (data[2] & 0xffL) << 16;             uadditional |= (data[3] & 0xffL) << 8;             uadditional |= (long)(data[4] & 0xffL);             break;           case 27:             uadditional = (data[1] & 0xffL) << 56;             uadditional |= (data[2] & 0xffL) << 48;             uadditional |= (data[3] & 0xffL) << 40;             uadditional |= (data[4] & 0xffL) << 32;             uadditional |= (data[5] & 0xffL) << 24;             uadditional |= (data[6] & 0xffL) << 16;             uadditional |= (data[7] & 0xffL) << 8;             uadditional |= (long)(data[8] & 0xffL);             break;           default:             throw new CBORException("Unexpected data encountered");         }
Magic Number,PeterO.Cbor,CBORObject,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORObject.cs,GetFixedLengthObject,The following statement contains a magic number: switch (firstbyte & 0x1f) {           case 24:             uadditional = (int)(data[1] & (int)0xff);             break;           case 25:             uadditional = (data[1] & 0xffL) << 8;             uadditional |= (long)(data[2] & 0xffL);             break;           case 26:             uadditional = (data[1] & 0xffL) << 24;             uadditional |= (data[2] & 0xffL) << 16;             uadditional |= (data[3] & 0xffL) << 8;             uadditional |= (long)(data[4] & 0xffL);             break;           case 27:             uadditional = (data[1] & 0xffL) << 56;             uadditional |= (data[2] & 0xffL) << 48;             uadditional |= (data[3] & 0xffL) << 40;             uadditional |= (data[4] & 0xffL) << 32;             uadditional |= (data[5] & 0xffL) << 24;             uadditional |= (data[6] & 0xffL) << 16;             uadditional |= (data[7] & 0xffL) << 8;             uadditional |= (long)(data[8] & 0xffL);             break;           default:             throw new CBORException("Unexpected data encountered");         }
Magic Number,PeterO.Cbor,CBORObject,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORObject.cs,GetFixedLengthObject,The following statement contains a magic number: switch (firstbyte & 0x1f) {           case 24:             uadditional = (int)(data[1] & (int)0xff);             break;           case 25:             uadditional = (data[1] & 0xffL) << 8;             uadditional |= (long)(data[2] & 0xffL);             break;           case 26:             uadditional = (data[1] & 0xffL) << 24;             uadditional |= (data[2] & 0xffL) << 16;             uadditional |= (data[3] & 0xffL) << 8;             uadditional |= (long)(data[4] & 0xffL);             break;           case 27:             uadditional = (data[1] & 0xffL) << 56;             uadditional |= (data[2] & 0xffL) << 48;             uadditional |= (data[3] & 0xffL) << 40;             uadditional |= (data[4] & 0xffL) << 32;             uadditional |= (data[5] & 0xffL) << 24;             uadditional |= (data[6] & 0xffL) << 16;             uadditional |= (data[7] & 0xffL) << 8;             uadditional |= (long)(data[8] & 0xffL);             break;           default:             throw new CBORException("Unexpected data encountered");         }
Magic Number,PeterO.Cbor,CBORObject,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORObject.cs,GetFixedLengthObject,The following statement contains a magic number: switch (firstbyte & 0x1f) {           case 24:             uadditional = (int)(data[1] & (int)0xff);             break;           case 25:             uadditional = (data[1] & 0xffL) << 8;             uadditional |= (long)(data[2] & 0xffL);             break;           case 26:             uadditional = (data[1] & 0xffL) << 24;             uadditional |= (data[2] & 0xffL) << 16;             uadditional |= (data[3] & 0xffL) << 8;             uadditional |= (long)(data[4] & 0xffL);             break;           case 27:             uadditional = (data[1] & 0xffL) << 56;             uadditional |= (data[2] & 0xffL) << 48;             uadditional |= (data[3] & 0xffL) << 40;             uadditional |= (data[4] & 0xffL) << 32;             uadditional |= (data[5] & 0xffL) << 24;             uadditional |= (data[6] & 0xffL) << 16;             uadditional |= (data[7] & 0xffL) << 8;             uadditional |= (long)(data[8] & 0xffL);             break;           default:             throw new CBORException("Unexpected data encountered");         }
Magic Number,PeterO.Cbor,CBORObject,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORObject.cs,GetFixedLengthObject,The following statement contains a magic number: switch (firstbyte & 0x1f) {           case 24:             uadditional = (int)(data[1] & (int)0xff);             break;           case 25:             uadditional = (data[1] & 0xffL) << 8;             uadditional |= (long)(data[2] & 0xffL);             break;           case 26:             uadditional = (data[1] & 0xffL) << 24;             uadditional |= (data[2] & 0xffL) << 16;             uadditional |= (data[3] & 0xffL) << 8;             uadditional |= (long)(data[4] & 0xffL);             break;           case 27:             uadditional = (data[1] & 0xffL) << 56;             uadditional |= (data[2] & 0xffL) << 48;             uadditional |= (data[3] & 0xffL) << 40;             uadditional |= (data[4] & 0xffL) << 32;             uadditional |= (data[5] & 0xffL) << 24;             uadditional |= (data[6] & 0xffL) << 16;             uadditional |= (data[7] & 0xffL) << 8;             uadditional |= (long)(data[8] & 0xffL);             break;           default:             throw new CBORException("Unexpected data encountered");         }
Magic Number,PeterO.Cbor,CBORObject,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORObject.cs,GetFixedLengthObject,The following statement contains a magic number: switch (firstbyte & 0x1f) {           case 24:             uadditional = (int)(data[1] & (int)0xff);             break;           case 25:             uadditional = (data[1] & 0xffL) << 8;             uadditional |= (long)(data[2] & 0xffL);             break;           case 26:             uadditional = (data[1] & 0xffL) << 24;             uadditional |= (data[2] & 0xffL) << 16;             uadditional |= (data[3] & 0xffL) << 8;             uadditional |= (long)(data[4] & 0xffL);             break;           case 27:             uadditional = (data[1] & 0xffL) << 56;             uadditional |= (data[2] & 0xffL) << 48;             uadditional |= (data[3] & 0xffL) << 40;             uadditional |= (data[4] & 0xffL) << 32;             uadditional |= (data[5] & 0xffL) << 24;             uadditional |= (data[6] & 0xffL) << 16;             uadditional |= (data[7] & 0xffL) << 8;             uadditional |= (long)(data[8] & 0xffL);             break;           default:             throw new CBORException("Unexpected data encountered");         }
Magic Number,PeterO.Cbor,CBORObject,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORObject.cs,GetFixedLengthObject,The following statement contains a magic number: switch (firstbyte & 0x1f) {           case 24:             uadditional = (int)(data[1] & (int)0xff);             break;           case 25:             uadditional = (data[1] & 0xffL) << 8;             uadditional |= (long)(data[2] & 0xffL);             break;           case 26:             uadditional = (data[1] & 0xffL) << 24;             uadditional |= (data[2] & 0xffL) << 16;             uadditional |= (data[3] & 0xffL) << 8;             uadditional |= (long)(data[4] & 0xffL);             break;           case 27:             uadditional = (data[1] & 0xffL) << 56;             uadditional |= (data[2] & 0xffL) << 48;             uadditional |= (data[3] & 0xffL) << 40;             uadditional |= (data[4] & 0xffL) << 32;             uadditional |= (data[5] & 0xffL) << 24;             uadditional |= (data[6] & 0xffL) << 16;             uadditional |= (data[7] & 0xffL) << 8;             uadditional |= (long)(data[8] & 0xffL);             break;           default:             throw new CBORException("Unexpected data encountered");         }
Magic Number,PeterO.Cbor,CBORObject,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORObject.cs,GetFixedLengthObject,The following statement contains a magic number: switch (firstbyte & 0x1f) {           case 24:             uadditional = (int)(data[1] & (int)0xff);             break;           case 25:             uadditional = (data[1] & 0xffL) << 8;             uadditional |= (long)(data[2] & 0xffL);             break;           case 26:             uadditional = (data[1] & 0xffL) << 24;             uadditional |= (data[2] & 0xffL) << 16;             uadditional |= (data[3] & 0xffL) << 8;             uadditional |= (long)(data[4] & 0xffL);             break;           case 27:             uadditional = (data[1] & 0xffL) << 56;             uadditional |= (data[2] & 0xffL) << 48;             uadditional |= (data[3] & 0xffL) << 40;             uadditional |= (data[4] & 0xffL) << 32;             uadditional |= (data[5] & 0xffL) << 24;             uadditional |= (data[6] & 0xffL) << 16;             uadditional |= (data[7] & 0xffL) << 8;             uadditional |= (long)(data[8] & 0xffL);             break;           default:             throw new CBORException("Unexpected data encountered");         }
Magic Number,PeterO.Cbor,CBORObject,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORObject.cs,GetFixedLengthObject,The following statement contains a magic number: switch (firstbyte & 0x1f) {           case 24:             uadditional = (int)(data[1] & (int)0xff);             break;           case 25:             uadditional = (data[1] & 0xffL) << 8;             uadditional |= (long)(data[2] & 0xffL);             break;           case 26:             uadditional = (data[1] & 0xffL) << 24;             uadditional |= (data[2] & 0xffL) << 16;             uadditional |= (data[3] & 0xffL) << 8;             uadditional |= (long)(data[4] & 0xffL);             break;           case 27:             uadditional = (data[1] & 0xffL) << 56;             uadditional |= (data[2] & 0xffL) << 48;             uadditional |= (data[3] & 0xffL) << 40;             uadditional |= (data[4] & 0xffL) << 32;             uadditional |= (data[5] & 0xffL) << 24;             uadditional |= (data[6] & 0xffL) << 16;             uadditional |= (data[7] & 0xffL) << 8;             uadditional |= (long)(data[8] & 0xffL);             break;           default:             throw new CBORException("Unexpected data encountered");         }
Magic Number,PeterO.Cbor,CBORObject,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORObject.cs,GetFixedLengthObject,The following statement contains a magic number: switch (firstbyte & 0x1f) {           case 24:             uadditional = (int)(data[1] & (int)0xff);             break;           case 25:             uadditional = (data[1] & 0xffL) << 8;             uadditional |= (long)(data[2] & 0xffL);             break;           case 26:             uadditional = (data[1] & 0xffL) << 24;             uadditional |= (data[2] & 0xffL) << 16;             uadditional |= (data[3] & 0xffL) << 8;             uadditional |= (long)(data[4] & 0xffL);             break;           case 27:             uadditional = (data[1] & 0xffL) << 56;             uadditional |= (data[2] & 0xffL) << 48;             uadditional |= (data[3] & 0xffL) << 40;             uadditional |= (data[4] & 0xffL) << 32;             uadditional |= (data[5] & 0xffL) << 24;             uadditional |= (data[6] & 0xffL) << 16;             uadditional |= (data[7] & 0xffL) << 8;             uadditional |= (long)(data[8] & 0xffL);             break;           default:             throw new CBORException("Unexpected data encountered");         }
Magic Number,PeterO.Cbor,CBORObject,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORObject.cs,GetFixedLengthObject,The following statement contains a magic number: switch (firstbyte & 0x1f) {           case 24:             uadditional = (int)(data[1] & (int)0xff);             break;           case 25:             uadditional = (data[1] & 0xffL) << 8;             uadditional |= (long)(data[2] & 0xffL);             break;           case 26:             uadditional = (data[1] & 0xffL) << 24;             uadditional |= (data[2] & 0xffL) << 16;             uadditional |= (data[3] & 0xffL) << 8;             uadditional |= (long)(data[4] & 0xffL);             break;           case 27:             uadditional = (data[1] & 0xffL) << 56;             uadditional |= (data[2] & 0xffL) << 48;             uadditional |= (data[3] & 0xffL) << 40;             uadditional |= (data[4] & 0xffL) << 32;             uadditional |= (data[5] & 0xffL) << 24;             uadditional |= (data[6] & 0xffL) << 16;             uadditional |= (data[7] & 0xffL) << 8;             uadditional |= (long)(data[8] & 0xffL);             break;           default:             throw new CBORException("Unexpected data encountered");         }
Magic Number,PeterO.Cbor,CBORObject,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORObject.cs,GetFixedLengthObject,The following statement contains a magic number: switch (firstbyte & 0x1f) {           case 24:             uadditional = (int)(data[1] & (int)0xff);             break;           case 25:             uadditional = (data[1] & 0xffL) << 8;             uadditional |= (long)(data[2] & 0xffL);             break;           case 26:             uadditional = (data[1] & 0xffL) << 24;             uadditional |= (data[2] & 0xffL) << 16;             uadditional |= (data[3] & 0xffL) << 8;             uadditional |= (long)(data[4] & 0xffL);             break;           case 27:             uadditional = (data[1] & 0xffL) << 56;             uadditional |= (data[2] & 0xffL) << 48;             uadditional |= (data[3] & 0xffL) << 40;             uadditional |= (data[4] & 0xffL) << 32;             uadditional |= (data[5] & 0xffL) << 24;             uadditional |= (data[6] & 0xffL) << 16;             uadditional |= (data[7] & 0xffL) << 8;             uadditional |= (long)(data[8] & 0xffL);             break;           default:             throw new CBORException("Unexpected data encountered");         }
Magic Number,PeterO.Cbor,CBORObject,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORObject.cs,GetFixedLengthObject,The following statement contains a magic number: switch (firstbyte & 0x1f) {           case 24:             uadditional = (int)(data[1] & (int)0xff);             break;           case 25:             uadditional = (data[1] & 0xffL) << 8;             uadditional |= (long)(data[2] & 0xffL);             break;           case 26:             uadditional = (data[1] & 0xffL) << 24;             uadditional |= (data[2] & 0xffL) << 16;             uadditional |= (data[3] & 0xffL) << 8;             uadditional |= (long)(data[4] & 0xffL);             break;           case 27:             uadditional = (data[1] & 0xffL) << 56;             uadditional |= (data[2] & 0xffL) << 48;             uadditional |= (data[3] & 0xffL) << 40;             uadditional |= (data[4] & 0xffL) << 32;             uadditional |= (data[5] & 0xffL) << 24;             uadditional |= (data[6] & 0xffL) << 16;             uadditional |= (data[7] & 0xffL) << 8;             uadditional |= (long)(data[8] & 0xffL);             break;           default:             throw new CBORException("Unexpected data encountered");         }
Magic Number,PeterO.Cbor,CBORObject,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORObject.cs,GetFixedLengthObject,The following statement contains a magic number: switch (firstbyte & 0x1f) {           case 24:             uadditional = (int)(data[1] & (int)0xff);             break;           case 25:             uadditional = (data[1] & 0xffL) << 8;             uadditional |= (long)(data[2] & 0xffL);             break;           case 26:             uadditional = (data[1] & 0xffL) << 24;             uadditional |= (data[2] & 0xffL) << 16;             uadditional |= (data[3] & 0xffL) << 8;             uadditional |= (long)(data[4] & 0xffL);             break;           case 27:             uadditional = (data[1] & 0xffL) << 56;             uadditional |= (data[2] & 0xffL) << 48;             uadditional |= (data[3] & 0xffL) << 40;             uadditional |= (data[4] & 0xffL) << 32;             uadditional |= (data[5] & 0xffL) << 24;             uadditional |= (data[6] & 0xffL) << 16;             uadditional |= (data[7] & 0xffL) << 8;             uadditional |= (long)(data[8] & 0xffL);             break;           default:             throw new CBORException("Unexpected data encountered");         }
Magic Number,PeterO.Cbor,CBORObject,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORObject.cs,GetFixedLengthObject,The following statement contains a magic number: switch (firstbyte & 0x1f) {           case 24:             uadditional = (int)(data[1] & (int)0xff);             break;           case 25:             uadditional = (data[1] & 0xffL) << 8;             uadditional |= (long)(data[2] & 0xffL);             break;           case 26:             uadditional = (data[1] & 0xffL) << 24;             uadditional |= (data[2] & 0xffL) << 16;             uadditional |= (data[3] & 0xffL) << 8;             uadditional |= (long)(data[4] & 0xffL);             break;           case 27:             uadditional = (data[1] & 0xffL) << 56;             uadditional |= (data[2] & 0xffL) << 48;             uadditional |= (data[3] & 0xffL) << 40;             uadditional |= (data[4] & 0xffL) << 32;             uadditional |= (data[5] & 0xffL) << 24;             uadditional |= (data[6] & 0xffL) << 16;             uadditional |= (data[7] & 0xffL) << 8;             uadditional |= (long)(data[8] & 0xffL);             break;           default:             throw new CBORException("Unexpected data encountered");         }
Magic Number,PeterO.Cbor,CBORObject,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORObject.cs,GetFixedLengthObject,The following statement contains a magic number: switch (firstbyte & 0x1f) {           case 24:             uadditional = (int)(data[1] & (int)0xff);             break;           case 25:             uadditional = (data[1] & 0xffL) << 8;             uadditional |= (long)(data[2] & 0xffL);             break;           case 26:             uadditional = (data[1] & 0xffL) << 24;             uadditional |= (data[2] & 0xffL) << 16;             uadditional |= (data[3] & 0xffL) << 8;             uadditional |= (long)(data[4] & 0xffL);             break;           case 27:             uadditional = (data[1] & 0xffL) << 56;             uadditional |= (data[2] & 0xffL) << 48;             uadditional |= (data[3] & 0xffL) << 40;             uadditional |= (data[4] & 0xffL) << 32;             uadditional |= (data[5] & 0xffL) << 24;             uadditional |= (data[6] & 0xffL) << 16;             uadditional |= (data[7] & 0xffL) << 8;             uadditional |= (long)(data[8] & 0xffL);             break;           default:             throw new CBORException("Unexpected data encountered");         }
Magic Number,PeterO.Cbor,CBORObject,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORObject.cs,GetFixedLengthObject,The following statement contains a magic number: switch (firstbyte & 0x1f) {           case 24:             uadditional = (int)(data[1] & (int)0xff);             break;           case 25:             uadditional = (data[1] & 0xffL) << 8;             uadditional |= (long)(data[2] & 0xffL);             break;           case 26:             uadditional = (data[1] & 0xffL) << 24;             uadditional |= (data[2] & 0xffL) << 16;             uadditional |= (data[3] & 0xffL) << 8;             uadditional |= (long)(data[4] & 0xffL);             break;           case 27:             uadditional = (data[1] & 0xffL) << 56;             uadditional |= (data[2] & 0xffL) << 48;             uadditional |= (data[3] & 0xffL) << 40;             uadditional |= (data[4] & 0xffL) << 32;             uadditional |= (data[5] & 0xffL) << 24;             uadditional |= (data[6] & 0xffL) << 16;             uadditional |= (data[7] & 0xffL) << 8;             uadditional |= (long)(data[8] & 0xffL);             break;           default:             throw new CBORException("Unexpected data encountered");         }
Magic Number,PeterO.Cbor,CBORObject,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORObject.cs,GetFixedLengthObject,The following statement contains a magic number: switch (firstbyte & 0x1f) {           case 24:             uadditional = (int)(data[1] & (int)0xff);             break;           case 25:             uadditional = (data[1] & 0xffL) << 8;             uadditional |= (long)(data[2] & 0xffL);             break;           case 26:             uadditional = (data[1] & 0xffL) << 24;             uadditional |= (data[2] & 0xffL) << 16;             uadditional |= (data[3] & 0xffL) << 8;             uadditional |= (long)(data[4] & 0xffL);             break;           case 27:             uadditional = (data[1] & 0xffL) << 56;             uadditional |= (data[2] & 0xffL) << 48;             uadditional |= (data[3] & 0xffL) << 40;             uadditional |= (data[4] & 0xffL) << 32;             uadditional |= (data[5] & 0xffL) << 24;             uadditional |= (data[6] & 0xffL) << 16;             uadditional |= (data[7] & 0xffL) << 8;             uadditional |= (long)(data[8] & 0xffL);             break;           default:             throw new CBORException("Unexpected data encountered");         }
Magic Number,PeterO.Cbor,CBORObject,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORObject.cs,GetFixedLengthObject,The following statement contains a magic number: switch (firstbyte & 0x1f) {           case 24:             uadditional = (int)(data[1] & (int)0xff);             break;           case 25:             uadditional = (data[1] & 0xffL) << 8;             uadditional |= (long)(data[2] & 0xffL);             break;           case 26:             uadditional = (data[1] & 0xffL) << 24;             uadditional |= (data[2] & 0xffL) << 16;             uadditional |= (data[3] & 0xffL) << 8;             uadditional |= (long)(data[4] & 0xffL);             break;           case 27:             uadditional = (data[1] & 0xffL) << 56;             uadditional |= (data[2] & 0xffL) << 48;             uadditional |= (data[3] & 0xffL) << 40;             uadditional |= (data[4] & 0xffL) << 32;             uadditional |= (data[5] & 0xffL) << 24;             uadditional |= (data[6] & 0xffL) << 16;             uadditional |= (data[7] & 0xffL) << 8;             uadditional |= (long)(data[8] & 0xffL);             break;           default:             throw new CBORException("Unexpected data encountered");         }
Magic Number,PeterO.Cbor,CBORObject,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORObject.cs,GetFixedLengthObject,The following statement contains a magic number: switch (firstbyte & 0x1f) {           case 24:             uadditional = (int)(data[1] & (int)0xff);             break;           case 25:             uadditional = (data[1] & 0xffL) << 8;             uadditional |= (long)(data[2] & 0xffL);             break;           case 26:             uadditional = (data[1] & 0xffL) << 24;             uadditional |= (data[2] & 0xffL) << 16;             uadditional |= (data[3] & 0xffL) << 8;             uadditional |= (long)(data[4] & 0xffL);             break;           case 27:             uadditional = (data[1] & 0xffL) << 56;             uadditional |= (data[2] & 0xffL) << 48;             uadditional |= (data[3] & 0xffL) << 40;             uadditional |= (data[4] & 0xffL) << 32;             uadditional |= (data[5] & 0xffL) << 24;             uadditional |= (data[6] & 0xffL) << 16;             uadditional |= (data[7] & 0xffL) << 8;             uadditional |= (long)(data[8] & 0xffL);             break;           default:             throw new CBORException("Unexpected data encountered");         }
Magic Number,PeterO.Cbor,CBORObject,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORObject.cs,GetFixedLengthObject,The following statement contains a magic number: switch (firstbyte & 0x1f) {           case 24:             uadditional = (int)(data[1] & (int)0xff);             break;           case 25:             uadditional = (data[1] & 0xffL) << 8;             uadditional |= (long)(data[2] & 0xffL);             break;           case 26:             uadditional = (data[1] & 0xffL) << 24;             uadditional |= (data[2] & 0xffL) << 16;             uadditional |= (data[3] & 0xffL) << 8;             uadditional |= (long)(data[4] & 0xffL);             break;           case 27:             uadditional = (data[1] & 0xffL) << 56;             uadditional |= (data[2] & 0xffL) << 48;             uadditional |= (data[3] & 0xffL) << 40;             uadditional |= (data[4] & 0xffL) << 32;             uadditional |= (data[5] & 0xffL) << 24;             uadditional |= (data[6] & 0xffL) << 16;             uadditional |= (data[7] & 0xffL) << 8;             uadditional |= (long)(data[8] & 0xffL);             break;           default:             throw new CBORException("Unexpected data encountered");         }
Magic Number,PeterO.Cbor,CBORObject,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORObject.cs,GetFixedLengthObject,The following statement contains a magic number: switch (firstbyte & 0x1f) {           case 24:             uadditional = (int)(data[1] & (int)0xff);             break;           case 25:             uadditional = (data[1] & 0xffL) << 8;             uadditional |= (long)(data[2] & 0xffL);             break;           case 26:             uadditional = (data[1] & 0xffL) << 24;             uadditional |= (data[2] & 0xffL) << 16;             uadditional |= (data[3] & 0xffL) << 8;             uadditional |= (long)(data[4] & 0xffL);             break;           case 27:             uadditional = (data[1] & 0xffL) << 56;             uadditional |= (data[2] & 0xffL) << 48;             uadditional |= (data[3] & 0xffL) << 40;             uadditional |= (data[4] & 0xffL) << 32;             uadditional |= (data[5] & 0xffL) << 24;             uadditional |= (data[6] & 0xffL) << 16;             uadditional |= (data[7] & 0xffL) << 8;             uadditional |= (long)(data[8] & 0xffL);             break;           default:             throw new CBORException("Unexpected data encountered");         }
Magic Number,PeterO.Cbor,CBORObject,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORObject.cs,GetFixedLengthObject,The following statement contains a magic number: switch (firstbyte & 0x1f) {           case 24:             uadditional = (int)(data[1] & (int)0xff);             break;           case 25:             uadditional = (data[1] & 0xffL) << 8;             uadditional |= (long)(data[2] & 0xffL);             break;           case 26:             uadditional = (data[1] & 0xffL) << 24;             uadditional |= (data[2] & 0xffL) << 16;             uadditional |= (data[3] & 0xffL) << 8;             uadditional |= (long)(data[4] & 0xffL);             break;           case 27:             uadditional = (data[1] & 0xffL) << 56;             uadditional |= (data[2] & 0xffL) << 48;             uadditional |= (data[3] & 0xffL) << 40;             uadditional |= (data[4] & 0xffL) << 32;             uadditional |= (data[5] & 0xffL) << 24;             uadditional |= (data[6] & 0xffL) << 16;             uadditional |= (data[7] & 0xffL) << 8;             uadditional |= (long)(data[8] & 0xffL);             break;           default:             throw new CBORException("Unexpected data encountered");         }
Magic Number,PeterO.Cbor,CBORObject,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORObject.cs,GetFixedLengthObject,The following statement contains a magic number: switch (firstbyte & 0x1f) {           case 24:             uadditional = (int)(data[1] & (int)0xff);             break;           case 25:             uadditional = (data[1] & 0xffL) << 8;             uadditional |= (long)(data[2] & 0xffL);             break;           case 26:             uadditional = (data[1] & 0xffL) << 24;             uadditional |= (data[2] & 0xffL) << 16;             uadditional |= (data[3] & 0xffL) << 8;             uadditional |= (long)(data[4] & 0xffL);             break;           case 27:             uadditional = (data[1] & 0xffL) << 56;             uadditional |= (data[2] & 0xffL) << 48;             uadditional |= (data[3] & 0xffL) << 40;             uadditional |= (data[4] & 0xffL) << 32;             uadditional |= (data[5] & 0xffL) << 24;             uadditional |= (data[6] & 0xffL) << 16;             uadditional |= (data[7] & 0xffL) << 8;             uadditional |= (long)(data[8] & 0xffL);             break;           default:             throw new CBORException("Unexpected data encountered");         }
Magic Number,PeterO.Cbor,CBORObject,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORObject.cs,GetFixedLengthObject,The following statement contains a magic number: switch (firstbyte & 0x1f) {           case 24:             uadditional = (int)(data[1] & (int)0xff);             break;           case 25:             uadditional = (data[1] & 0xffL) << 8;             uadditional |= (long)(data[2] & 0xffL);             break;           case 26:             uadditional = (data[1] & 0xffL) << 24;             uadditional |= (data[2] & 0xffL) << 16;             uadditional |= (data[3] & 0xffL) << 8;             uadditional |= (long)(data[4] & 0xffL);             break;           case 27:             uadditional = (data[1] & 0xffL) << 56;             uadditional |= (data[2] & 0xffL) << 48;             uadditional |= (data[3] & 0xffL) << 40;             uadditional |= (data[4] & 0xffL) << 32;             uadditional |= (data[5] & 0xffL) << 24;             uadditional |= (data[6] & 0xffL) << 16;             uadditional |= (data[7] & 0xffL) << 8;             uadditional |= (long)(data[8] & 0xffL);             break;           default:             throw new CBORException("Unexpected data encountered");         }
Magic Number,PeterO.Cbor,CBORObject,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORObject.cs,GetFixedLengthObject,The following statement contains a magic number: switch (firstbyte & 0x1f) {           case 24:             uadditional = (int)(data[1] & (int)0xff);             break;           case 25:             uadditional = (data[1] & 0xffL) << 8;             uadditional |= (long)(data[2] & 0xffL);             break;           case 26:             uadditional = (data[1] & 0xffL) << 24;             uadditional |= (data[2] & 0xffL) << 16;             uadditional |= (data[3] & 0xffL) << 8;             uadditional |= (long)(data[4] & 0xffL);             break;           case 27:             uadditional = (data[1] & 0xffL) << 56;             uadditional |= (data[2] & 0xffL) << 48;             uadditional |= (data[3] & 0xffL) << 40;             uadditional |= (data[4] & 0xffL) << 32;             uadditional |= (data[5] & 0xffL) << 24;             uadditional |= (data[6] & 0xffL) << 16;             uadditional |= (data[7] & 0xffL) << 8;             uadditional |= (long)(data[8] & 0xffL);             break;           default:             throw new CBORException("Unexpected data encountered");         }
Magic Number,PeterO.Cbor,CBORObject,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORObject.cs,GetFixedLengthObject,The following statement contains a magic number: switch (majortype) {           case 0:             if ((uadditional >> 63) == 0) {               // use only if additional's top bit isn't set               // (additional is a signed long)               return new CBORObject(CBORObjectTypeInteger' uadditional);             } else {               int low = unchecked((int)(uadditional & 0xffffffffL));               int high = unchecked((int)((uadditional >> 32) & 0xffffffffL));               return FromObject(LowHighToEInteger(low' high));             }           case 1:             if ((uadditional >> 63) == 0) {               // use only if additional's top bit isn't set               // (additional is a signed long)               return new CBORObject(                   CBORObjectTypeInteger'                   -1 - uadditional);             } else {               int low = unchecked((int)(uadditional & 0xffffffffL));               int high = unchecked((int)((uadditional >> 32) & 0xffffffffL));               EInteger bigintAdditional = LowHighToEInteger(low' high);               EInteger minusOne = -EInteger.One;               bigintAdditional = minusOne - (EInteger)bigintAdditional;               return FromObject(bigintAdditional);             }           case 7:             if (firstbyte >= 0xf9 && firstbyte <= 0xfb) {               var dblbits = (long)uadditional;               if (firstbyte == 0xf9) {                 dblbits = CBORUtilities.HalfToDoublePrecision(                     unchecked((int)uadditional));               } else if (firstbyte == 0xfa) {                 dblbits = CBORUtilities.SingleToDoublePrecision(                     unchecked((int)uadditional));               }               return new CBORObject(                 CBORObjectTypeDouble'                 dblbits);             }             if (firstbyte == 0xf8) {               if ((int)uadditional < 32) {                 throw new CBORException("Invalid overlong simple value");               }               return new CBORObject(                   CBORObjectTypeSimpleValue'                   (int)uadditional);             }             throw new CBORException("Unexpected data encountered");           default: throw new CBORException("Unexpected data encountered");         }
Magic Number,PeterO.Cbor,CBORObject,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORObject.cs,GetFixedLengthObject,The following statement contains a magic number: switch (majortype) {           case 0:             if ((uadditional >> 63) == 0) {               // use only if additional's top bit isn't set               // (additional is a signed long)               return new CBORObject(CBORObjectTypeInteger' uadditional);             } else {               int low = unchecked((int)(uadditional & 0xffffffffL));               int high = unchecked((int)((uadditional >> 32) & 0xffffffffL));               return FromObject(LowHighToEInteger(low' high));             }           case 1:             if ((uadditional >> 63) == 0) {               // use only if additional's top bit isn't set               // (additional is a signed long)               return new CBORObject(                   CBORObjectTypeInteger'                   -1 - uadditional);             } else {               int low = unchecked((int)(uadditional & 0xffffffffL));               int high = unchecked((int)((uadditional >> 32) & 0xffffffffL));               EInteger bigintAdditional = LowHighToEInteger(low' high);               EInteger minusOne = -EInteger.One;               bigintAdditional = minusOne - (EInteger)bigintAdditional;               return FromObject(bigintAdditional);             }           case 7:             if (firstbyte >= 0xf9 && firstbyte <= 0xfb) {               var dblbits = (long)uadditional;               if (firstbyte == 0xf9) {                 dblbits = CBORUtilities.HalfToDoublePrecision(                     unchecked((int)uadditional));               } else if (firstbyte == 0xfa) {                 dblbits = CBORUtilities.SingleToDoublePrecision(                     unchecked((int)uadditional));               }               return new CBORObject(                 CBORObjectTypeDouble'                 dblbits);             }             if (firstbyte == 0xf8) {               if ((int)uadditional < 32) {                 throw new CBORException("Invalid overlong simple value");               }               return new CBORObject(                   CBORObjectTypeSimpleValue'                   (int)uadditional);             }             throw new CBORException("Unexpected data encountered");           default: throw new CBORException("Unexpected data encountered");         }
Magic Number,PeterO.Cbor,CBORObject,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORObject.cs,GetFixedLengthObject,The following statement contains a magic number: switch (majortype) {           case 0:             if ((uadditional >> 63) == 0) {               // use only if additional's top bit isn't set               // (additional is a signed long)               return new CBORObject(CBORObjectTypeInteger' uadditional);             } else {               int low = unchecked((int)(uadditional & 0xffffffffL));               int high = unchecked((int)((uadditional >> 32) & 0xffffffffL));               return FromObject(LowHighToEInteger(low' high));             }           case 1:             if ((uadditional >> 63) == 0) {               // use only if additional's top bit isn't set               // (additional is a signed long)               return new CBORObject(                   CBORObjectTypeInteger'                   -1 - uadditional);             } else {               int low = unchecked((int)(uadditional & 0xffffffffL));               int high = unchecked((int)((uadditional >> 32) & 0xffffffffL));               EInteger bigintAdditional = LowHighToEInteger(low' high);               EInteger minusOne = -EInteger.One;               bigintAdditional = minusOne - (EInteger)bigintAdditional;               return FromObject(bigintAdditional);             }           case 7:             if (firstbyte >= 0xf9 && firstbyte <= 0xfb) {               var dblbits = (long)uadditional;               if (firstbyte == 0xf9) {                 dblbits = CBORUtilities.HalfToDoublePrecision(                     unchecked((int)uadditional));               } else if (firstbyte == 0xfa) {                 dblbits = CBORUtilities.SingleToDoublePrecision(                     unchecked((int)uadditional));               }               return new CBORObject(                 CBORObjectTypeDouble'                 dblbits);             }             if (firstbyte == 0xf8) {               if ((int)uadditional < 32) {                 throw new CBORException("Invalid overlong simple value");               }               return new CBORObject(                   CBORObjectTypeSimpleValue'                   (int)uadditional);             }             throw new CBORException("Unexpected data encountered");           default: throw new CBORException("Unexpected data encountered");         }
Magic Number,PeterO.Cbor,CBORObject,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORObject.cs,GetFixedLengthObject,The following statement contains a magic number: switch (majortype) {           case 0:             if ((uadditional >> 63) == 0) {               // use only if additional's top bit isn't set               // (additional is a signed long)               return new CBORObject(CBORObjectTypeInteger' uadditional);             } else {               int low = unchecked((int)(uadditional & 0xffffffffL));               int high = unchecked((int)((uadditional >> 32) & 0xffffffffL));               return FromObject(LowHighToEInteger(low' high));             }           case 1:             if ((uadditional >> 63) == 0) {               // use only if additional's top bit isn't set               // (additional is a signed long)               return new CBORObject(                   CBORObjectTypeInteger'                   -1 - uadditional);             } else {               int low = unchecked((int)(uadditional & 0xffffffffL));               int high = unchecked((int)((uadditional >> 32) & 0xffffffffL));               EInteger bigintAdditional = LowHighToEInteger(low' high);               EInteger minusOne = -EInteger.One;               bigintAdditional = minusOne - (EInteger)bigintAdditional;               return FromObject(bigintAdditional);             }           case 7:             if (firstbyte >= 0xf9 && firstbyte <= 0xfb) {               var dblbits = (long)uadditional;               if (firstbyte == 0xf9) {                 dblbits = CBORUtilities.HalfToDoublePrecision(                     unchecked((int)uadditional));               } else if (firstbyte == 0xfa) {                 dblbits = CBORUtilities.SingleToDoublePrecision(                     unchecked((int)uadditional));               }               return new CBORObject(                 CBORObjectTypeDouble'                 dblbits);             }             if (firstbyte == 0xf8) {               if ((int)uadditional < 32) {                 throw new CBORException("Invalid overlong simple value");               }               return new CBORObject(                   CBORObjectTypeSimpleValue'                   (int)uadditional);             }             throw new CBORException("Unexpected data encountered");           default: throw new CBORException("Unexpected data encountered");         }
Magic Number,PeterO.Cbor,CBORObject,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORObject.cs,GetFixedLengthObject,The following statement contains a magic number: switch (majortype) {           case 0:             if ((uadditional >> 63) == 0) {               // use only if additional's top bit isn't set               // (additional is a signed long)               return new CBORObject(CBORObjectTypeInteger' uadditional);             } else {               int low = unchecked((int)(uadditional & 0xffffffffL));               int high = unchecked((int)((uadditional >> 32) & 0xffffffffL));               return FromObject(LowHighToEInteger(low' high));             }           case 1:             if ((uadditional >> 63) == 0) {               // use only if additional's top bit isn't set               // (additional is a signed long)               return new CBORObject(                   CBORObjectTypeInteger'                   -1 - uadditional);             } else {               int low = unchecked((int)(uadditional & 0xffffffffL));               int high = unchecked((int)((uadditional >> 32) & 0xffffffffL));               EInteger bigintAdditional = LowHighToEInteger(low' high);               EInteger minusOne = -EInteger.One;               bigintAdditional = minusOne - (EInteger)bigintAdditional;               return FromObject(bigintAdditional);             }           case 7:             if (firstbyte >= 0xf9 && firstbyte <= 0xfb) {               var dblbits = (long)uadditional;               if (firstbyte == 0xf9) {                 dblbits = CBORUtilities.HalfToDoublePrecision(                     unchecked((int)uadditional));               } else if (firstbyte == 0xfa) {                 dblbits = CBORUtilities.SingleToDoublePrecision(                     unchecked((int)uadditional));               }               return new CBORObject(                 CBORObjectTypeDouble'                 dblbits);             }             if (firstbyte == 0xf8) {               if ((int)uadditional < 32) {                 throw new CBORException("Invalid overlong simple value");               }               return new CBORObject(                   CBORObjectTypeSimpleValue'                   (int)uadditional);             }             throw new CBORException("Unexpected data encountered");           default: throw new CBORException("Unexpected data encountered");         }
Magic Number,PeterO.Cbor,CBORObject,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORObject.cs,GetFixedLengthObject,The following statement contains a magic number: switch (majortype) {           case 0:             if ((uadditional >> 63) == 0) {               // use only if additional's top bit isn't set               // (additional is a signed long)               return new CBORObject(CBORObjectTypeInteger' uadditional);             } else {               int low = unchecked((int)(uadditional & 0xffffffffL));               int high = unchecked((int)((uadditional >> 32) & 0xffffffffL));               return FromObject(LowHighToEInteger(low' high));             }           case 1:             if ((uadditional >> 63) == 0) {               // use only if additional's top bit isn't set               // (additional is a signed long)               return new CBORObject(                   CBORObjectTypeInteger'                   -1 - uadditional);             } else {               int low = unchecked((int)(uadditional & 0xffffffffL));               int high = unchecked((int)((uadditional >> 32) & 0xffffffffL));               EInteger bigintAdditional = LowHighToEInteger(low' high);               EInteger minusOne = -EInteger.One;               bigintAdditional = minusOne - (EInteger)bigintAdditional;               return FromObject(bigintAdditional);             }           case 7:             if (firstbyte >= 0xf9 && firstbyte <= 0xfb) {               var dblbits = (long)uadditional;               if (firstbyte == 0xf9) {                 dblbits = CBORUtilities.HalfToDoublePrecision(                     unchecked((int)uadditional));               } else if (firstbyte == 0xfa) {                 dblbits = CBORUtilities.SingleToDoublePrecision(                     unchecked((int)uadditional));               }               return new CBORObject(                 CBORObjectTypeDouble'                 dblbits);             }             if (firstbyte == 0xf8) {               if ((int)uadditional < 32) {                 throw new CBORException("Invalid overlong simple value");               }               return new CBORObject(                   CBORObjectTypeSimpleValue'                   (int)uadditional);             }             throw new CBORException("Unexpected data encountered");           default: throw new CBORException("Unexpected data encountered");         }
Magic Number,PeterO.Cbor,CBORObject,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORObject.cs,GetFixedLengthObject,The following statement contains a magic number: majortype == 2
Magic Number,PeterO.Cbor,CBORObject,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORObject.cs,GetFixedLengthObject,The following statement contains a magic number: majortype == 3
Magic Number,PeterO.Cbor,CBORObject,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORObject.cs,CBORArrayHashCode,The following statement contains a magic number: var ret = 19;
Magic Number,PeterO.Cbor,CBORObject,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORObject.cs,CBORArrayHashCode,The following statement contains a magic number: ret = (ret * 31) + count;
Magic Number,PeterO.Cbor,CBORObject,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORObject.cs,CBORArrayHashCode,The following statement contains a magic number: ret = (ret * 31) + list[i].GetHashCode();
Magic Number,PeterO.Cbor,CBORObject,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORObject.cs,StringHashCode,The following statement contains a magic number: var ret = 19;
Magic Number,PeterO.Cbor,CBORObject,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORObject.cs,StringHashCode,The following statement contains a magic number: ret = (ret * 31) + count;
Magic Number,PeterO.Cbor,CBORObject,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORObject.cs,StringHashCode,The following statement contains a magic number: ret = (ret * 31) + (int)str[i];
Magic Number,PeterO.Cbor,CBORObject,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORObject.cs,CBORMapHashCode,The following statement contains a magic number: return unchecked(a.Count.GetHashCode() * 19);
Magic Number,PeterO.Cbor,CBORObject,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORObject.cs,ExtendedToString,The following statement contains a magic number: ef.IsFinite && (ef.Exponent.CompareTo((EInteger)2500) > 0 ||           ef.Exponent.CompareTo((EInteger)(-2500)) < 0)
Magic Number,PeterO.Cbor,CBORObject,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORObject.cs,ExtendedToString,The following statement contains a magic number: ef.IsFinite && (ef.Exponent.CompareTo((EInteger)2500) > 0 ||           ef.Exponent.CompareTo((EInteger)(-2500)) < 0)
Magic Number,PeterO.Cbor,CBORObject,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORObject.cs,GetOptimizedBytesIfShortAscii,The following statement contains a magic number: int extra = (length < 24) ? 1 : 2;
Magic Number,PeterO.Cbor,CBORObject,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORObject.cs,GetOptimizedBytesIfShortAscii,The following statement contains a magic number: int extra = (length < 24) ? 1 : 2;
Magic Number,PeterO.Cbor,CBORObject,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORObject.cs,GetOptimizedBytesIfShortAscii,The following statement contains a magic number: length < 24
Magic Number,PeterO.Cbor,CBORObject,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORObject.cs,GetOptimizedBytesIfShortAscii,The following statement contains a magic number: str.Length <= 255
Magic Number,PeterO.Cbor,CBORObject,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORObject.cs,GetPositiveInt64Bytes,The following statement contains a magic number: return new[] { (byte)((byte)value | (byte)(type << 5)) };
Magic Number,PeterO.Cbor,CBORObject,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORObject.cs,GetPositiveInt64Bytes,The following statement contains a magic number: value < 24
Magic Number,PeterO.Cbor,CBORObject,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORObject.cs,GetPositiveInt64Bytes,The following statement contains a magic number: return new[] {           (byte)(24 | (type << 5))' (byte)(value & 0xff)'         };
Magic Number,PeterO.Cbor,CBORObject,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORObject.cs,GetPositiveInt64Bytes,The following statement contains a magic number: return new[] {           (byte)(24 | (type << 5))' (byte)(value & 0xff)'         };
Magic Number,PeterO.Cbor,CBORObject,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORObject.cs,GetPositiveInt64Bytes,The following statement contains a magic number: return new[] {           (byte)(25 | (type << 5))'           (byte)((value >> 8) & 0xff)' (byte)(value & 0xff)'         };
Magic Number,PeterO.Cbor,CBORObject,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORObject.cs,GetPositiveInt64Bytes,The following statement contains a magic number: return new[] {           (byte)(25 | (type << 5))'           (byte)((value >> 8) & 0xff)' (byte)(value & 0xff)'         };
Magic Number,PeterO.Cbor,CBORObject,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORObject.cs,GetPositiveInt64Bytes,The following statement contains a magic number: return new[] {           (byte)(25 | (type << 5))'           (byte)((value >> 8) & 0xff)' (byte)(value & 0xff)'         };
Magic Number,PeterO.Cbor,CBORObject,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORObject.cs,GetPositiveInt64Bytes,The following statement contains a magic number: return new[] {           (byte)(26 | (type << 5))'           (byte)((value >> 24) & 0xff)' (byte)((value >> 16) & 0xff)'           (byte)((value >> 8) & 0xff)' (byte)(value & 0xff)'         };
Magic Number,PeterO.Cbor,CBORObject,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORObject.cs,GetPositiveInt64Bytes,The following statement contains a magic number: return new[] {           (byte)(26 | (type << 5))'           (byte)((value >> 24) & 0xff)' (byte)((value >> 16) & 0xff)'           (byte)((value >> 8) & 0xff)' (byte)(value & 0xff)'         };
Magic Number,PeterO.Cbor,CBORObject,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORObject.cs,GetPositiveInt64Bytes,The following statement contains a magic number: return new[] {           (byte)(26 | (type << 5))'           (byte)((value >> 24) & 0xff)' (byte)((value >> 16) & 0xff)'           (byte)((value >> 8) & 0xff)' (byte)(value & 0xff)'         };
Magic Number,PeterO.Cbor,CBORObject,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORObject.cs,GetPositiveInt64Bytes,The following statement contains a magic number: return new[] {           (byte)(26 | (type << 5))'           (byte)((value >> 24) & 0xff)' (byte)((value >> 16) & 0xff)'           (byte)((value >> 8) & 0xff)' (byte)(value & 0xff)'         };
Magic Number,PeterO.Cbor,CBORObject,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORObject.cs,GetPositiveInt64Bytes,The following statement contains a magic number: return new[] {           (byte)(26 | (type << 5))'           (byte)((value >> 24) & 0xff)' (byte)((value >> 16) & 0xff)'           (byte)((value >> 8) & 0xff)' (byte)(value & 0xff)'         };
Magic Number,PeterO.Cbor,CBORObject,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORObject.cs,GetPositiveInt64Bytes,The following statement contains a magic number: return new[] {         (byte)(27 | (type << 5))' (byte)((value >> 56) & 0xff)'         (byte)((value >> 48) & 0xff)' (byte)((value >> 40) & 0xff)'         (byte)((value >> 32) & 0xff)' (byte)((value >> 24) & 0xff)'         (byte)((value >> 16) & 0xff)' (byte)((value >> 8) & 0xff)'         (byte)(value & 0xff)'       };
Magic Number,PeterO.Cbor,CBORObject,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORObject.cs,GetPositiveInt64Bytes,The following statement contains a magic number: return new[] {         (byte)(27 | (type << 5))' (byte)((value >> 56) & 0xff)'         (byte)((value >> 48) & 0xff)' (byte)((value >> 40) & 0xff)'         (byte)((value >> 32) & 0xff)' (byte)((value >> 24) & 0xff)'         (byte)((value >> 16) & 0xff)' (byte)((value >> 8) & 0xff)'         (byte)(value & 0xff)'       };
Magic Number,PeterO.Cbor,CBORObject,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORObject.cs,GetPositiveInt64Bytes,The following statement contains a magic number: return new[] {         (byte)(27 | (type << 5))' (byte)((value >> 56) & 0xff)'         (byte)((value >> 48) & 0xff)' (byte)((value >> 40) & 0xff)'         (byte)((value >> 32) & 0xff)' (byte)((value >> 24) & 0xff)'         (byte)((value >> 16) & 0xff)' (byte)((value >> 8) & 0xff)'         (byte)(value & 0xff)'       };
Magic Number,PeterO.Cbor,CBORObject,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORObject.cs,GetPositiveInt64Bytes,The following statement contains a magic number: return new[] {         (byte)(27 | (type << 5))' (byte)((value >> 56) & 0xff)'         (byte)((value >> 48) & 0xff)' (byte)((value >> 40) & 0xff)'         (byte)((value >> 32) & 0xff)' (byte)((value >> 24) & 0xff)'         (byte)((value >> 16) & 0xff)' (byte)((value >> 8) & 0xff)'         (byte)(value & 0xff)'       };
Magic Number,PeterO.Cbor,CBORObject,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORObject.cs,GetPositiveInt64Bytes,The following statement contains a magic number: return new[] {         (byte)(27 | (type << 5))' (byte)((value >> 56) & 0xff)'         (byte)((value >> 48) & 0xff)' (byte)((value >> 40) & 0xff)'         (byte)((value >> 32) & 0xff)' (byte)((value >> 24) & 0xff)'         (byte)((value >> 16) & 0xff)' (byte)((value >> 8) & 0xff)'         (byte)(value & 0xff)'       };
Magic Number,PeterO.Cbor,CBORObject,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORObject.cs,GetPositiveInt64Bytes,The following statement contains a magic number: return new[] {         (byte)(27 | (type << 5))' (byte)((value >> 56) & 0xff)'         (byte)((value >> 48) & 0xff)' (byte)((value >> 40) & 0xff)'         (byte)((value >> 32) & 0xff)' (byte)((value >> 24) & 0xff)'         (byte)((value >> 16) & 0xff)' (byte)((value >> 8) & 0xff)'         (byte)(value & 0xff)'       };
Magic Number,PeterO.Cbor,CBORObject,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORObject.cs,GetPositiveInt64Bytes,The following statement contains a magic number: return new[] {         (byte)(27 | (type << 5))' (byte)((value >> 56) & 0xff)'         (byte)((value >> 48) & 0xff)' (byte)((value >> 40) & 0xff)'         (byte)((value >> 32) & 0xff)' (byte)((value >> 24) & 0xff)'         (byte)((value >> 16) & 0xff)' (byte)((value >> 8) & 0xff)'         (byte)(value & 0xff)'       };
Magic Number,PeterO.Cbor,CBORObject,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORObject.cs,GetPositiveInt64Bytes,The following statement contains a magic number: return new[] {         (byte)(27 | (type << 5))' (byte)((value >> 56) & 0xff)'         (byte)((value >> 48) & 0xff)' (byte)((value >> 40) & 0xff)'         (byte)((value >> 32) & 0xff)' (byte)((value >> 24) & 0xff)'         (byte)((value >> 16) & 0xff)' (byte)((value >> 8) & 0xff)'         (byte)(value & 0xff)'       };
Magic Number,PeterO.Cbor,CBORObject,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORObject.cs,GetPositiveInt64Bytes,The following statement contains a magic number: return new[] {         (byte)(27 | (type << 5))' (byte)((value >> 56) & 0xff)'         (byte)((value >> 48) & 0xff)' (byte)((value >> 40) & 0xff)'         (byte)((value >> 32) & 0xff)' (byte)((value >> 24) & 0xff)'         (byte)((value >> 16) & 0xff)' (byte)((value >> 8) & 0xff)'         (byte)(value & 0xff)'       };
Magic Number,PeterO.Cbor,CBORObject,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORObject.cs,GetPositiveIntBytes,The following statement contains a magic number: return new[] { (byte)((byte)value | (byte)(type << 5)) };
Magic Number,PeterO.Cbor,CBORObject,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORObject.cs,GetPositiveIntBytes,The following statement contains a magic number: value < 24
Magic Number,PeterO.Cbor,CBORObject,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORObject.cs,GetPositiveIntBytes,The following statement contains a magic number: return new[] {           (byte)(24 | (type << 5))' (byte)(value & 0xff)'         };
Magic Number,PeterO.Cbor,CBORObject,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORObject.cs,GetPositiveIntBytes,The following statement contains a magic number: return new[] {           (byte)(24 | (type << 5))' (byte)(value & 0xff)'         };
Magic Number,PeterO.Cbor,CBORObject,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORObject.cs,GetPositiveIntBytes,The following statement contains a magic number: return new[] {           (byte)(25 | (type << 5))'           (byte)((value >> 8) & 0xff)' (byte)(value & 0xff)'         };
Magic Number,PeterO.Cbor,CBORObject,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORObject.cs,GetPositiveIntBytes,The following statement contains a magic number: return new[] {           (byte)(25 | (type << 5))'           (byte)((value >> 8) & 0xff)' (byte)(value & 0xff)'         };
Magic Number,PeterO.Cbor,CBORObject,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORObject.cs,GetPositiveIntBytes,The following statement contains a magic number: return new[] {           (byte)(25 | (type << 5))'           (byte)((value >> 8) & 0xff)' (byte)(value & 0xff)'         };
Magic Number,PeterO.Cbor,CBORObject,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORObject.cs,GetPositiveIntBytes,The following statement contains a magic number: return new[] {         (byte)(26 | (type << 5))' (byte)((value >> 24) & 0xff)'         (byte)((value >> 16) & 0xff)' (byte)((value >> 8) & 0xff)'         (byte)(value & 0xff)'       };
Magic Number,PeterO.Cbor,CBORObject,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORObject.cs,GetPositiveIntBytes,The following statement contains a magic number: return new[] {         (byte)(26 | (type << 5))' (byte)((value >> 24) & 0xff)'         (byte)((value >> 16) & 0xff)' (byte)((value >> 8) & 0xff)'         (byte)(value & 0xff)'       };
Magic Number,PeterO.Cbor,CBORObject,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORObject.cs,GetPositiveIntBytes,The following statement contains a magic number: return new[] {         (byte)(26 | (type << 5))' (byte)((value >> 24) & 0xff)'         (byte)((value >> 16) & 0xff)' (byte)((value >> 8) & 0xff)'         (byte)(value & 0xff)'       };
Magic Number,PeterO.Cbor,CBORObject,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORObject.cs,GetPositiveIntBytes,The following statement contains a magic number: return new[] {         (byte)(26 | (type << 5))' (byte)((value >> 24) & 0xff)'         (byte)((value >> 16) & 0xff)' (byte)((value >> 8) & 0xff)'         (byte)(value & 0xff)'       };
Magic Number,PeterO.Cbor,CBORObject,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORObject.cs,GetPositiveIntBytes,The following statement contains a magic number: return new[] {         (byte)(26 | (type << 5))' (byte)((value >> 24) & 0xff)'         (byte)((value >> 16) & 0xff)' (byte)((value >> 8) & 0xff)'         (byte)(value & 0xff)'       };
Magic Number,PeterO.Cbor,CBORObject,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORObject.cs,InitializeFixedObjects,The following statement contains a magic number: var fixedObjects = new CBORObject[256];
Magic Number,PeterO.Cbor,CBORObject,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORObject.cs,LowHighToEInteger,The following statement contains a magic number: uabytes = new byte[9];
Magic Number,PeterO.Cbor,CBORObject,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORObject.cs,LowHighToEInteger,The following statement contains a magic number: uabytes[7] = (byte)((tagHigh >> 24) & 0xff);
Magic Number,PeterO.Cbor,CBORObject,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORObject.cs,LowHighToEInteger,The following statement contains a magic number: uabytes[7] = (byte)((tagHigh >> 24) & 0xff);
Magic Number,PeterO.Cbor,CBORObject,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORObject.cs,LowHighToEInteger,The following statement contains a magic number: uabytes[6] = (byte)((tagHigh >> 16) & 0xff);
Magic Number,PeterO.Cbor,CBORObject,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORObject.cs,LowHighToEInteger,The following statement contains a magic number: uabytes[6] = (byte)((tagHigh >> 16) & 0xff);
Magic Number,PeterO.Cbor,CBORObject,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORObject.cs,LowHighToEInteger,The following statement contains a magic number: uabytes[5] = (byte)((tagHigh >> 8) & 0xff);
Magic Number,PeterO.Cbor,CBORObject,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORObject.cs,LowHighToEInteger,The following statement contains a magic number: uabytes[5] = (byte)((tagHigh >> 8) & 0xff);
Magic Number,PeterO.Cbor,CBORObject,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORObject.cs,LowHighToEInteger,The following statement contains a magic number: uabytes[4] = (byte)(tagHigh & 0xff);
Magic Number,PeterO.Cbor,CBORObject,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORObject.cs,LowHighToEInteger,The following statement contains a magic number: uabytes[3] = (byte)((tagLow >> 24) & 0xff);
Magic Number,PeterO.Cbor,CBORObject,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORObject.cs,LowHighToEInteger,The following statement contains a magic number: uabytes[3] = (byte)((tagLow >> 24) & 0xff);
Magic Number,PeterO.Cbor,CBORObject,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORObject.cs,LowHighToEInteger,The following statement contains a magic number: uabytes[2] = (byte)((tagLow >> 16) & 0xff);
Magic Number,PeterO.Cbor,CBORObject,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORObject.cs,LowHighToEInteger,The following statement contains a magic number: uabytes[2] = (byte)((tagLow >> 16) & 0xff);
Magic Number,PeterO.Cbor,CBORObject,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORObject.cs,LowHighToEInteger,The following statement contains a magic number: uabytes[1] = (byte)((tagLow >> 8) & 0xff);
Magic Number,PeterO.Cbor,CBORObject,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORObject.cs,LowHighToEInteger,The following statement contains a magic number: uabytes[8] = 0;
Magic Number,PeterO.Cbor,CBORObject,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORObject.cs,LowHighToEInteger,The following statement contains a magic number: uabytes = new byte[5];
Magic Number,PeterO.Cbor,CBORObject,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORObject.cs,LowHighToEInteger,The following statement contains a magic number: uabytes[3] = (byte)((tagLow >> 24) & 0xff);
Magic Number,PeterO.Cbor,CBORObject,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORObject.cs,LowHighToEInteger,The following statement contains a magic number: uabytes[3] = (byte)((tagLow >> 24) & 0xff);
Magic Number,PeterO.Cbor,CBORObject,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORObject.cs,LowHighToEInteger,The following statement contains a magic number: uabytes[2] = (byte)((tagLow >> 16) & 0xff);
Magic Number,PeterO.Cbor,CBORObject,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORObject.cs,LowHighToEInteger,The following statement contains a magic number: uabytes[2] = (byte)((tagLow >> 16) & 0xff);
Magic Number,PeterO.Cbor,CBORObject,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORObject.cs,LowHighToEInteger,The following statement contains a magic number: uabytes[1] = (byte)((tagLow >> 8) & 0xff);
Magic Number,PeterO.Cbor,CBORObject,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORObject.cs,LowHighToEInteger,The following statement contains a magic number: uabytes[4] = 0;
Magic Number,PeterO.Cbor,CBORObject,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORObject.cs,WriteObjectArray,The following statement contains a magic number: WritePositiveInt(4' list.Count' outputStream);
Magic Number,PeterO.Cbor,CBORObject,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORObject.cs,WriteObjectMap,The following statement contains a magic number: WritePositiveInt(5' map.Count' outputStream);
Magic Number,PeterO.Cbor,CBORObject,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORObject.cs,WriteStreamedString,The following statement contains a magic number: bufferLength = Math.Min(           StreamedStringBufferLength'           bufferLength * 3);
Magic Number,PeterO.Cbor,CBORObject,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORObject.cs,WriteStreamedString,The following statement contains a magic number: WritePositiveInt(3' byteIndex' stream);
Magic Number,PeterO.Cbor,CBORObject,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORObject.cs,WriteStreamedString,The following statement contains a magic number: WritePositiveInt(3' byteIndex' stream);
Magic Number,PeterO.Cbor,CBORObject,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORObject.cs,WriteTags,The following statement contains a magic number: WritePositiveInt(6' low' s);
Magic Number,PeterO.Cbor,CBORObject,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORObject.cs,WriteTags,The following statement contains a magic number: high == 0 && (low >> 16) == 0
Magic Number,PeterO.Cbor,CBORObject,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORObject.cs,AsDecimal,The following statement contains a magic number: return (this.ItemType == CBORObjectTypeInteger) ? ((decimal)(long)this.ThisItem) : ((this.HasOneTag(30) ||              this.HasOneTag(270)) ? (decimal)this.ToObject<ERational>() :           (decimal)this.ToObject<EDecimal>());
Magic Number,PeterO.Cbor,CBORObject,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORObject.cs,AsDecimal,The following statement contains a magic number: return (this.ItemType == CBORObjectTypeInteger) ? ((decimal)(long)this.ThisItem) : ((this.HasOneTag(30) ||              this.HasOneTag(270)) ? (decimal)this.ToObject<ERational>() :           (decimal)this.ToObject<EDecimal>());
Magic Number,PeterO.Cbor,CBORObject,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORObject.cs,AsUInt64Legacy,The following statement contains a magic number: bigint.Sign < 0 ||         bigint.GetUnsignedBitLengthAsEInteger().CompareTo(64) > 0
Magic Number,PeterO.Cbor,CBORObject,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORObject.cs,UInt64ToEInteger,The following statement contains a magic number: var data = new byte[9];
Magic Number,PeterO.Cbor,CBORObject,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORObject.cs,UInt64ToEInteger,The following statement contains a magic number: data[1] = (byte)((uvalue >> 8) & 0xff);
Magic Number,PeterO.Cbor,CBORObject,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORObject.cs,UInt64ToEInteger,The following statement contains a magic number: data[2] = (byte)((uvalue >> 16) & 0xff);
Magic Number,PeterO.Cbor,CBORObject,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORObject.cs,UInt64ToEInteger,The following statement contains a magic number: data[2] = (byte)((uvalue >> 16) & 0xff);
Magic Number,PeterO.Cbor,CBORObject,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORObject.cs,UInt64ToEInteger,The following statement contains a magic number: data[3] = (byte)((uvalue >> 24) & 0xff);
Magic Number,PeterO.Cbor,CBORObject,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORObject.cs,UInt64ToEInteger,The following statement contains a magic number: data[3] = (byte)((uvalue >> 24) & 0xff);
Magic Number,PeterO.Cbor,CBORObject,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORObject.cs,UInt64ToEInteger,The following statement contains a magic number: data[4] = (byte)((uvalue >> 32) & 0xff);
Magic Number,PeterO.Cbor,CBORObject,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORObject.cs,UInt64ToEInteger,The following statement contains a magic number: data[4] = (byte)((uvalue >> 32) & 0xff);
Magic Number,PeterO.Cbor,CBORObject,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORObject.cs,UInt64ToEInteger,The following statement contains a magic number: data[5] = (byte)((uvalue >> 40) & 0xff);
Magic Number,PeterO.Cbor,CBORObject,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORObject.cs,UInt64ToEInteger,The following statement contains a magic number: data[5] = (byte)((uvalue >> 40) & 0xff);
Magic Number,PeterO.Cbor,CBORObject,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORObject.cs,UInt64ToEInteger,The following statement contains a magic number: data[6] = (byte)((uvalue >> 48) & 0xff);
Magic Number,PeterO.Cbor,CBORObject,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORObject.cs,UInt64ToEInteger,The following statement contains a magic number: data[6] = (byte)((uvalue >> 48) & 0xff);
Magic Number,PeterO.Cbor,CBORObject,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORObject.cs,UInt64ToEInteger,The following statement contains a magic number: data[7] = (byte)((uvalue >> 56) & 0xff);
Magic Number,PeterO.Cbor,CBORObject,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORObject.cs,UInt64ToEInteger,The following statement contains a magic number: data[7] = (byte)((uvalue >> 56) & 0xff);
Magic Number,PeterO.Cbor,CBORObject,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORObject.cs,UInt64ToEInteger,The following statement contains a magic number: data[8] = (byte)0;
Magic Number,PeterO.Cbor,CBORReader,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORReader.cs,ToUnsignedEInteger,The following statement contains a magic number: var lval = (EInteger)(val & ~(1L << 63));
Magic Number,PeterO.Cbor,CBORReader,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORReader.cs,ToUnsignedEInteger,The following statement contains a magic number: EInteger bigintAdd = EInteger.One << 63;
Magic Number,PeterO.Cbor,CBORReader,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORReader.cs,ToUnsignedEInteger,The following statement contains a magic number: (val >> 63) != 0
Magic Number,PeterO.Cbor,CBORReader,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORReader.cs,HandleItemTag,The following statement contains a magic number: int uad = uadditional >= 257 ? 257 : (uadditional < 0 ? 0 :           (int)uadditional);
Magic Number,PeterO.Cbor,CBORReader,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORReader.cs,HandleItemTag,The following statement contains a magic number: int uad = uadditional >= 257 ? 257 : (uadditional < 0 ? 0 :           (int)uadditional);
Magic Number,PeterO.Cbor,CBORReader,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORReader.cs,HandleItemTag,The following statement contains a magic number: switch (uad) {         case 256:           // Tag 256: String namespace           this.stringRefs = this.stringRefs ?? new StringRefs();           this.stringRefs.Push();           break;         case 25:           // String reference           if (this.stringRefs == null) {             throw new CBORException("No stringref namespace");           }           break;         case 28:         case 29:           this.hasSharableObjects = true;           break;       }
Magic Number,PeterO.Cbor,CBORReader,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORReader.cs,HandleItemTag,The following statement contains a magic number: switch (uad) {         case 256:           // Tag 256: String namespace           this.stringRefs = this.stringRefs ?? new StringRefs();           this.stringRefs.Push();           break;         case 25:           // String reference           if (this.stringRefs == null) {             throw new CBORException("No stringref namespace");           }           break;         case 28:         case 29:           this.hasSharableObjects = true;           break;       }
Magic Number,PeterO.Cbor,CBORReader,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORReader.cs,HandleItemTag,The following statement contains a magic number: switch (uad) {         case 256:           // Tag 256: String namespace           this.stringRefs = this.stringRefs ?? new StringRefs();           this.stringRefs.Push();           break;         case 25:           // String reference           if (this.stringRefs == null) {             throw new CBORException("No stringref namespace");           }           break;         case 28:         case 29:           this.hasSharableObjects = true;           break;       }
Magic Number,PeterO.Cbor,CBORReader,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORReader.cs,HandleItemTag,The following statement contains a magic number: switch (uad) {         case 256:           // Tag 256: String namespace           this.stringRefs = this.stringRefs ?? new StringRefs();           this.stringRefs.Push();           break;         case 25:           // String reference           if (this.stringRefs == null) {             throw new CBORException("No stringref namespace");           }           break;         case 28:         case 29:           this.hasSharableObjects = true;           break;       }
Magic Number,PeterO.Cbor,CBORReader,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORReader.cs,ResolveSharedRefs,The following statement contains a magic number: bool hasTag = obj.HasMostOuterTag(29);
Magic Number,PeterO.Cbor,CBORReader,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORReader.cs,ResolveSharedRefs,The following statement contains a magic number: hasTag = obj.HasMostOuterTag(28);
Magic Number,PeterO.Cbor,CBORReader,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORReader.cs,ReadInternalOrEOF,The following statement contains a magic number: this.depth > 500
Magic Number,PeterO.Cbor,CBORReader,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORReader.cs,ReadInternal,The following statement contains a magic number: this.depth > 500
Magic Number,PeterO.Cbor,CBORReader,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORReader.cs,ReadStringArrayMap,The following statement contains a magic number: (uadditional >> 31) != 0
Magic Number,PeterO.Cbor,CBORReader,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORReader.cs,ReadStringArrayMap,The following statement contains a magic number: int hint = (uadditional > Int32.MaxValue ||             (uadditional >> 63) != 0) ? Int32.MaxValue : (int)uadditional;
Magic Number,PeterO.Cbor,CBORReader,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORReader.cs,ReadStringArrayMap,The following statement contains a magic number: type == 2
Magic Number,PeterO.Cbor,CBORReader,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORReader.cs,ReadStringArrayMap,The following statement contains a magic number: (uadditional >> 31) != 0
Magic Number,PeterO.Cbor,CBORReader,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORReader.cs,ReadStringArrayMap,The following statement contains a magic number: switch (           DataUtilities.ReadUtf8 (             this.stream'             (int)uadditional'             builder'             false)) {           case -1:             throw new CBORException("Invalid UTF-8");           case -2:             throw new CBORException("Premature end of data");         }
Magic Number,PeterO.Cbor,CBORReader,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORReader.cs,ReadStringArrayMap,The following statement contains a magic number: int hint = (uadditional > Int32.MaxValue || (uadditional >> 63) !=               0) ? Int32.MaxValue : (int)uadditional;
Magic Number,PeterO.Cbor,CBORReader,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORReader.cs,ReadStringArrayMap,The following statement contains a magic number: type == 3
Magic Number,PeterO.Cbor,CBORReader,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORReader.cs,ReadStringArrayMap,The following statement contains a magic number: this.options.Ctap2Canonical && this.depth >= 4
Magic Number,PeterO.Cbor,CBORReader,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORReader.cs,ReadStringArrayMap,The following statement contains a magic number: (uadditional >> 31) != 0
Magic Number,PeterO.Cbor,CBORReader,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORReader.cs,ReadStringArrayMap,The following statement contains a magic number: type == 4
Magic Number,PeterO.Cbor,CBORReader,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORReader.cs,ReadStringArrayMap,The following statement contains a magic number: this.options.Ctap2Canonical && this.depth >= 4
Magic Number,PeterO.Cbor,CBORReader,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORReader.cs,ReadStringArrayMap,The following statement contains a magic number: (uadditional >> 31) != 0
Magic Number,PeterO.Cbor,CBORReader,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORReader.cs,ReadStringArrayMap,The following statement contains a magic number: type == 5
Magic Number,PeterO.Cbor,CBORReader,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORReader.cs,ReadForFirstByte,The following statement contains a magic number: this.depth > 500
Magic Number,PeterO.Cbor,CBORReader,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORReader.cs,ReadForFirstByte,The following statement contains a magic number: int type = (firstbyte >> 5) & 0x07;
Magic Number,PeterO.Cbor,CBORReader,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORReader.cs,ReadForFirstByte,The following statement contains a magic number: type == 6
Magic Number,PeterO.Cbor,CBORReader,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORReader.cs,ReadForFirstByte,The following statement contains a magic number: uadditional = ReadDataLength(           this.stream'           firstbyte'           type'           type == 7);
Magic Number,PeterO.Cbor,CBORReader,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORReader.cs,ReadForFirstByte,The following statement contains a magic number: return (uadditional >> 63) != 0 ?             CBORObject.FromObject(ToUnsignedEInteger(uadditional)) :             CBORObject.FromObject(uadditional);
Magic Number,PeterO.Cbor,CBORReader,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORReader.cs,ReadForFirstByte,The following statement contains a magic number: this.stringRefs != null && (type == 2 || type == 3)
Magic Number,PeterO.Cbor,CBORReader,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORReader.cs,ReadForFirstByte,The following statement contains a magic number: this.stringRefs != null && (type == 2 || type == 3)
Magic Number,PeterO.Cbor,CBORReader,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORReader.cs,ReadForFirstByte,The following statement contains a magic number: switch (type) {           case 2: {             // Streaming byte string             using (var ms = new MemoryStream()) {               // Requires same type as this one               while (true) {                 int nextByte = this.stream.ReadByte();                 if (nextByte == 0xff) {                   // break if the "break" code was read                   break;                 }                 long len = ReadDataLength(this.stream' nextByte' 2);                 if ((len >> 63) != 0 || len > Int32.MaxValue) {                   throw new CBORException("Length" + ToUnsignedEInteger(len) +                     " is bigger than supported ");                 }                 if (nextByte != 0x40) {                   // NOTE: 0x40 means the empty byte string                   ReadByteData(this.stream' len' ms);                 }               }               if (ms.Position > Int32.MaxValue) {                 throw new                 CBORException("Length of bytes to be streamed is bigger" + "\u0020than supported ");               }               data = ms.ToArray();               return CBORObject.FromRaw(data);             }           }           case 3: {             // Streaming text string             var builder = new StringBuilder();             while (true) {               int nextByte = this.stream.ReadByte();               if (nextByte == 0xff) {                 // break if the "break" code was read                 break;               }               long len = ReadDataLength(this.stream' nextByte' 3);               if ((len >> 63) != 0 || len > Int32.MaxValue) {                 throw new CBORException("Length" + ToUnsignedEInteger(len) +                   " is bigger than supported");               }               if (nextByte != 0x60) {                 // NOTE: 0x60 means the empty string                 if (PropertyMap.ExceedsKnownLength(this.stream' len)) {                   throw new CBORException("Premature end of data");                 }                 switch (                   DataUtilities.ReadUtf8 (                     this.stream'                     (int)len'                     builder'                     false)) {                   case -1:                     throw new CBORException("Invalid UTF-8");                   case -2:                     throw new CBORException("Premature end of data");                 }               }             }             return CBORObject.FromRaw(builder.ToString());           }           case 4: {             CBORObject cbor = CBORObject.NewArray();             var vtindex = 0;             // Indefinite-length array             while (true) {               int headByte = this.stream.ReadByte();               if (headByte < 0) {                 throw new CBORException("Premature end of data");               }               if (headByte == 0xff) {                 // Break code was read                 break;               }               ++this.depth;               CBORObject o = this.ReadForFirstByte (                   headByte);               --this.depth;               cbor.Add(o);               ++vtindex;             }             return cbor;           }           case 5: {             CBORObject cbor = CBORObject.NewMap();             // Indefinite-length map             while (true) {               int headByte = this.stream.ReadByte();               if (headByte < 0) {                 throw new CBORException("Premature end of data");               }               if (headByte == 0xff) {                 // Break code was read                 break;               }               ++this.depth;               CBORObject key = this.ReadForFirstByte(headByte);               CBORObject value = this.ReadInternal();               --this.depth;               if (!this.options.AllowDuplicateKeys) {                 if (cbor.ContainsKey(key)) {                   throw new CBORException("Duplicate key already exists");                 }               }               cbor[key] = value;             }             return cbor;           }           default: throw new CBORException("Unexpected data encountered");         }
Magic Number,PeterO.Cbor,CBORReader,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORReader.cs,ReadForFirstByte,The following statement contains a magic number: switch (type) {           case 2: {             // Streaming byte string             using (var ms = new MemoryStream()) {               // Requires same type as this one               while (true) {                 int nextByte = this.stream.ReadByte();                 if (nextByte == 0xff) {                   // break if the "break" code was read                   break;                 }                 long len = ReadDataLength(this.stream' nextByte' 2);                 if ((len >> 63) != 0 || len > Int32.MaxValue) {                   throw new CBORException("Length" + ToUnsignedEInteger(len) +                     " is bigger than supported ");                 }                 if (nextByte != 0x40) {                   // NOTE: 0x40 means the empty byte string                   ReadByteData(this.stream' len' ms);                 }               }               if (ms.Position > Int32.MaxValue) {                 throw new                 CBORException("Length of bytes to be streamed is bigger" + "\u0020than supported ");               }               data = ms.ToArray();               return CBORObject.FromRaw(data);             }           }           case 3: {             // Streaming text string             var builder = new StringBuilder();             while (true) {               int nextByte = this.stream.ReadByte();               if (nextByte == 0xff) {                 // break if the "break" code was read                 break;               }               long len = ReadDataLength(this.stream' nextByte' 3);               if ((len >> 63) != 0 || len > Int32.MaxValue) {                 throw new CBORException("Length" + ToUnsignedEInteger(len) +                   " is bigger than supported");               }               if (nextByte != 0x60) {                 // NOTE: 0x60 means the empty string                 if (PropertyMap.ExceedsKnownLength(this.stream' len)) {                   throw new CBORException("Premature end of data");                 }                 switch (                   DataUtilities.ReadUtf8 (                     this.stream'                     (int)len'                     builder'                     false)) {                   case -1:                     throw new CBORException("Invalid UTF-8");                   case -2:                     throw new CBORException("Premature end of data");                 }               }             }             return CBORObject.FromRaw(builder.ToString());           }           case 4: {             CBORObject cbor = CBORObject.NewArray();             var vtindex = 0;             // Indefinite-length array             while (true) {               int headByte = this.stream.ReadByte();               if (headByte < 0) {                 throw new CBORException("Premature end of data");               }               if (headByte == 0xff) {                 // Break code was read                 break;               }               ++this.depth;               CBORObject o = this.ReadForFirstByte (                   headByte);               --this.depth;               cbor.Add(o);               ++vtindex;             }             return cbor;           }           case 5: {             CBORObject cbor = CBORObject.NewMap();             // Indefinite-length map             while (true) {               int headByte = this.stream.ReadByte();               if (headByte < 0) {                 throw new CBORException("Premature end of data");               }               if (headByte == 0xff) {                 // Break code was read                 break;               }               ++this.depth;               CBORObject key = this.ReadForFirstByte(headByte);               CBORObject value = this.ReadInternal();               --this.depth;               if (!this.options.AllowDuplicateKeys) {                 if (cbor.ContainsKey(key)) {                   throw new CBORException("Duplicate key already exists");                 }               }               cbor[key] = value;             }             return cbor;           }           default: throw new CBORException("Unexpected data encountered");         }
Magic Number,PeterO.Cbor,CBORReader,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORReader.cs,ReadForFirstByte,The following statement contains a magic number: switch (type) {           case 2: {             // Streaming byte string             using (var ms = new MemoryStream()) {               // Requires same type as this one               while (true) {                 int nextByte = this.stream.ReadByte();                 if (nextByte == 0xff) {                   // break if the "break" code was read                   break;                 }                 long len = ReadDataLength(this.stream' nextByte' 2);                 if ((len >> 63) != 0 || len > Int32.MaxValue) {                   throw new CBORException("Length" + ToUnsignedEInteger(len) +                     " is bigger than supported ");                 }                 if (nextByte != 0x40) {                   // NOTE: 0x40 means the empty byte string                   ReadByteData(this.stream' len' ms);                 }               }               if (ms.Position > Int32.MaxValue) {                 throw new                 CBORException("Length of bytes to be streamed is bigger" + "\u0020than supported ");               }               data = ms.ToArray();               return CBORObject.FromRaw(data);             }           }           case 3: {             // Streaming text string             var builder = new StringBuilder();             while (true) {               int nextByte = this.stream.ReadByte();               if (nextByte == 0xff) {                 // break if the "break" code was read                 break;               }               long len = ReadDataLength(this.stream' nextByte' 3);               if ((len >> 63) != 0 || len > Int32.MaxValue) {                 throw new CBORException("Length" + ToUnsignedEInteger(len) +                   " is bigger than supported");               }               if (nextByte != 0x60) {                 // NOTE: 0x60 means the empty string                 if (PropertyMap.ExceedsKnownLength(this.stream' len)) {                   throw new CBORException("Premature end of data");                 }                 switch (                   DataUtilities.ReadUtf8 (                     this.stream'                     (int)len'                     builder'                     false)) {                   case -1:                     throw new CBORException("Invalid UTF-8");                   case -2:                     throw new CBORException("Premature end of data");                 }               }             }             return CBORObject.FromRaw(builder.ToString());           }           case 4: {             CBORObject cbor = CBORObject.NewArray();             var vtindex = 0;             // Indefinite-length array             while (true) {               int headByte = this.stream.ReadByte();               if (headByte < 0) {                 throw new CBORException("Premature end of data");               }               if (headByte == 0xff) {                 // Break code was read                 break;               }               ++this.depth;               CBORObject o = this.ReadForFirstByte (                   headByte);               --this.depth;               cbor.Add(o);               ++vtindex;             }             return cbor;           }           case 5: {             CBORObject cbor = CBORObject.NewMap();             // Indefinite-length map             while (true) {               int headByte = this.stream.ReadByte();               if (headByte < 0) {                 throw new CBORException("Premature end of data");               }               if (headByte == 0xff) {                 // Break code was read                 break;               }               ++this.depth;               CBORObject key = this.ReadForFirstByte(headByte);               CBORObject value = this.ReadInternal();               --this.depth;               if (!this.options.AllowDuplicateKeys) {                 if (cbor.ContainsKey(key)) {                   throw new CBORException("Duplicate key already exists");                 }               }               cbor[key] = value;             }             return cbor;           }           default: throw new CBORException("Unexpected data encountered");         }
Magic Number,PeterO.Cbor,CBORReader,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORReader.cs,ReadForFirstByte,The following statement contains a magic number: switch (type) {           case 2: {             // Streaming byte string             using (var ms = new MemoryStream()) {               // Requires same type as this one               while (true) {                 int nextByte = this.stream.ReadByte();                 if (nextByte == 0xff) {                   // break if the "break" code was read                   break;                 }                 long len = ReadDataLength(this.stream' nextByte' 2);                 if ((len >> 63) != 0 || len > Int32.MaxValue) {                   throw new CBORException("Length" + ToUnsignedEInteger(len) +                     " is bigger than supported ");                 }                 if (nextByte != 0x40) {                   // NOTE: 0x40 means the empty byte string                   ReadByteData(this.stream' len' ms);                 }               }               if (ms.Position > Int32.MaxValue) {                 throw new                 CBORException("Length of bytes to be streamed is bigger" + "\u0020than supported ");               }               data = ms.ToArray();               return CBORObject.FromRaw(data);             }           }           case 3: {             // Streaming text string             var builder = new StringBuilder();             while (true) {               int nextByte = this.stream.ReadByte();               if (nextByte == 0xff) {                 // break if the "break" code was read                 break;               }               long len = ReadDataLength(this.stream' nextByte' 3);               if ((len >> 63) != 0 || len > Int32.MaxValue) {                 throw new CBORException("Length" + ToUnsignedEInteger(len) +                   " is bigger than supported");               }               if (nextByte != 0x60) {                 // NOTE: 0x60 means the empty string                 if (PropertyMap.ExceedsKnownLength(this.stream' len)) {                   throw new CBORException("Premature end of data");                 }                 switch (                   DataUtilities.ReadUtf8 (                     this.stream'                     (int)len'                     builder'                     false)) {                   case -1:                     throw new CBORException("Invalid UTF-8");                   case -2:                     throw new CBORException("Premature end of data");                 }               }             }             return CBORObject.FromRaw(builder.ToString());           }           case 4: {             CBORObject cbor = CBORObject.NewArray();             var vtindex = 0;             // Indefinite-length array             while (true) {               int headByte = this.stream.ReadByte();               if (headByte < 0) {                 throw new CBORException("Premature end of data");               }               if (headByte == 0xff) {                 // Break code was read                 break;               }               ++this.depth;               CBORObject o = this.ReadForFirstByte (                   headByte);               --this.depth;               cbor.Add(o);               ++vtindex;             }             return cbor;           }           case 5: {             CBORObject cbor = CBORObject.NewMap();             // Indefinite-length map             while (true) {               int headByte = this.stream.ReadByte();               if (headByte < 0) {                 throw new CBORException("Premature end of data");               }               if (headByte == 0xff) {                 // Break code was read                 break;               }               ++this.depth;               CBORObject key = this.ReadForFirstByte(headByte);               CBORObject value = this.ReadInternal();               --this.depth;               if (!this.options.AllowDuplicateKeys) {                 if (cbor.ContainsKey(key)) {                   throw new CBORException("Duplicate key already exists");                 }               }               cbor[key] = value;             }             return cbor;           }           default: throw new CBORException("Unexpected data encountered");         }
Magic Number,PeterO.Cbor,CBORReader,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORReader.cs,ReadForFirstByte,The following statement contains a magic number: switch (type) {           case 2: {             // Streaming byte string             using (var ms = new MemoryStream()) {               // Requires same type as this one               while (true) {                 int nextByte = this.stream.ReadByte();                 if (nextByte == 0xff) {                   // break if the "break" code was read                   break;                 }                 long len = ReadDataLength(this.stream' nextByte' 2);                 if ((len >> 63) != 0 || len > Int32.MaxValue) {                   throw new CBORException("Length" + ToUnsignedEInteger(len) +                     " is bigger than supported ");                 }                 if (nextByte != 0x40) {                   // NOTE: 0x40 means the empty byte string                   ReadByteData(this.stream' len' ms);                 }               }               if (ms.Position > Int32.MaxValue) {                 throw new                 CBORException("Length of bytes to be streamed is bigger" + "\u0020than supported ");               }               data = ms.ToArray();               return CBORObject.FromRaw(data);             }           }           case 3: {             // Streaming text string             var builder = new StringBuilder();             while (true) {               int nextByte = this.stream.ReadByte();               if (nextByte == 0xff) {                 // break if the "break" code was read                 break;               }               long len = ReadDataLength(this.stream' nextByte' 3);               if ((len >> 63) != 0 || len > Int32.MaxValue) {                 throw new CBORException("Length" + ToUnsignedEInteger(len) +                   " is bigger than supported");               }               if (nextByte != 0x60) {                 // NOTE: 0x60 means the empty string                 if (PropertyMap.ExceedsKnownLength(this.stream' len)) {                   throw new CBORException("Premature end of data");                 }                 switch (                   DataUtilities.ReadUtf8 (                     this.stream'                     (int)len'                     builder'                     false)) {                   case -1:                     throw new CBORException("Invalid UTF-8");                   case -2:                     throw new CBORException("Premature end of data");                 }               }             }             return CBORObject.FromRaw(builder.ToString());           }           case 4: {             CBORObject cbor = CBORObject.NewArray();             var vtindex = 0;             // Indefinite-length array             while (true) {               int headByte = this.stream.ReadByte();               if (headByte < 0) {                 throw new CBORException("Premature end of data");               }               if (headByte == 0xff) {                 // Break code was read                 break;               }               ++this.depth;               CBORObject o = this.ReadForFirstByte (                   headByte);               --this.depth;               cbor.Add(o);               ++vtindex;             }             return cbor;           }           case 5: {             CBORObject cbor = CBORObject.NewMap();             // Indefinite-length map             while (true) {               int headByte = this.stream.ReadByte();               if (headByte < 0) {                 throw new CBORException("Premature end of data");               }               if (headByte == 0xff) {                 // Break code was read                 break;               }               ++this.depth;               CBORObject key = this.ReadForFirstByte(headByte);               CBORObject value = this.ReadInternal();               --this.depth;               if (!this.options.AllowDuplicateKeys) {                 if (cbor.ContainsKey(key)) {                   throw new CBORException("Duplicate key already exists");                 }               }               cbor[key] = value;             }             return cbor;           }           default: throw new CBORException("Unexpected data encountered");         }
Magic Number,PeterO.Cbor,CBORReader,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORReader.cs,ReadForFirstByte,The following statement contains a magic number: switch (type) {           case 2: {             // Streaming byte string             using (var ms = new MemoryStream()) {               // Requires same type as this one               while (true) {                 int nextByte = this.stream.ReadByte();                 if (nextByte == 0xff) {                   // break if the "break" code was read                   break;                 }                 long len = ReadDataLength(this.stream' nextByte' 2);                 if ((len >> 63) != 0 || len > Int32.MaxValue) {                   throw new CBORException("Length" + ToUnsignedEInteger(len) +                     " is bigger than supported ");                 }                 if (nextByte != 0x40) {                   // NOTE: 0x40 means the empty byte string                   ReadByteData(this.stream' len' ms);                 }               }               if (ms.Position > Int32.MaxValue) {                 throw new                 CBORException("Length of bytes to be streamed is bigger" + "\u0020than supported ");               }               data = ms.ToArray();               return CBORObject.FromRaw(data);             }           }           case 3: {             // Streaming text string             var builder = new StringBuilder();             while (true) {               int nextByte = this.stream.ReadByte();               if (nextByte == 0xff) {                 // break if the "break" code was read                 break;               }               long len = ReadDataLength(this.stream' nextByte' 3);               if ((len >> 63) != 0 || len > Int32.MaxValue) {                 throw new CBORException("Length" + ToUnsignedEInteger(len) +                   " is bigger than supported");               }               if (nextByte != 0x60) {                 // NOTE: 0x60 means the empty string                 if (PropertyMap.ExceedsKnownLength(this.stream' len)) {                   throw new CBORException("Premature end of data");                 }                 switch (                   DataUtilities.ReadUtf8 (                     this.stream'                     (int)len'                     builder'                     false)) {                   case -1:                     throw new CBORException("Invalid UTF-8");                   case -2:                     throw new CBORException("Premature end of data");                 }               }             }             return CBORObject.FromRaw(builder.ToString());           }           case 4: {             CBORObject cbor = CBORObject.NewArray();             var vtindex = 0;             // Indefinite-length array             while (true) {               int headByte = this.stream.ReadByte();               if (headByte < 0) {                 throw new CBORException("Premature end of data");               }               if (headByte == 0xff) {                 // Break code was read                 break;               }               ++this.depth;               CBORObject o = this.ReadForFirstByte (                   headByte);               --this.depth;               cbor.Add(o);               ++vtindex;             }             return cbor;           }           case 5: {             CBORObject cbor = CBORObject.NewMap();             // Indefinite-length map             while (true) {               int headByte = this.stream.ReadByte();               if (headByte < 0) {                 throw new CBORException("Premature end of data");               }               if (headByte == 0xff) {                 // Break code was read                 break;               }               ++this.depth;               CBORObject key = this.ReadForFirstByte(headByte);               CBORObject value = this.ReadInternal();               --this.depth;               if (!this.options.AllowDuplicateKeys) {                 if (cbor.ContainsKey(key)) {                   throw new CBORException("Duplicate key already exists");                 }               }               cbor[key] = value;             }             return cbor;           }           default: throw new CBORException("Unexpected data encountered");         }
Magic Number,PeterO.Cbor,CBORReader,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORReader.cs,ReadForFirstByte,The following statement contains a magic number: switch (type) {           case 2: {             // Streaming byte string             using (var ms = new MemoryStream()) {               // Requires same type as this one               while (true) {                 int nextByte = this.stream.ReadByte();                 if (nextByte == 0xff) {                   // break if the "break" code was read                   break;                 }                 long len = ReadDataLength(this.stream' nextByte' 2);                 if ((len >> 63) != 0 || len > Int32.MaxValue) {                   throw new CBORException("Length" + ToUnsignedEInteger(len) +                     " is bigger than supported ");                 }                 if (nextByte != 0x40) {                   // NOTE: 0x40 means the empty byte string                   ReadByteData(this.stream' len' ms);                 }               }               if (ms.Position > Int32.MaxValue) {                 throw new                 CBORException("Length of bytes to be streamed is bigger" + "\u0020than supported ");               }               data = ms.ToArray();               return CBORObject.FromRaw(data);             }           }           case 3: {             // Streaming text string             var builder = new StringBuilder();             while (true) {               int nextByte = this.stream.ReadByte();               if (nextByte == 0xff) {                 // break if the "break" code was read                 break;               }               long len = ReadDataLength(this.stream' nextByte' 3);               if ((len >> 63) != 0 || len > Int32.MaxValue) {                 throw new CBORException("Length" + ToUnsignedEInteger(len) +                   " is bigger than supported");               }               if (nextByte != 0x60) {                 // NOTE: 0x60 means the empty string                 if (PropertyMap.ExceedsKnownLength(this.stream' len)) {                   throw new CBORException("Premature end of data");                 }                 switch (                   DataUtilities.ReadUtf8 (                     this.stream'                     (int)len'                     builder'                     false)) {                   case -1:                     throw new CBORException("Invalid UTF-8");                   case -2:                     throw new CBORException("Premature end of data");                 }               }             }             return CBORObject.FromRaw(builder.ToString());           }           case 4: {             CBORObject cbor = CBORObject.NewArray();             var vtindex = 0;             // Indefinite-length array             while (true) {               int headByte = this.stream.ReadByte();               if (headByte < 0) {                 throw new CBORException("Premature end of data");               }               if (headByte == 0xff) {                 // Break code was read                 break;               }               ++this.depth;               CBORObject o = this.ReadForFirstByte (                   headByte);               --this.depth;               cbor.Add(o);               ++vtindex;             }             return cbor;           }           case 5: {             CBORObject cbor = CBORObject.NewMap();             // Indefinite-length map             while (true) {               int headByte = this.stream.ReadByte();               if (headByte < 0) {                 throw new CBORException("Premature end of data");               }               if (headByte == 0xff) {                 // Break code was read                 break;               }               ++this.depth;               CBORObject key = this.ReadForFirstByte(headByte);               CBORObject value = this.ReadInternal();               --this.depth;               if (!this.options.AllowDuplicateKeys) {                 if (cbor.ContainsKey(key)) {                   throw new CBORException("Duplicate key already exists");                 }               }               cbor[key] = value;             }             return cbor;           }           default: throw new CBORException("Unexpected data encountered");         }
Magic Number,PeterO.Cbor,CBORReader,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORReader.cs,ReadForFirstByte,The following statement contains a magic number: switch (type) {           case 2: {             // Streaming byte string             using (var ms = new MemoryStream()) {               // Requires same type as this one               while (true) {                 int nextByte = this.stream.ReadByte();                 if (nextByte == 0xff) {                   // break if the "break" code was read                   break;                 }                 long len = ReadDataLength(this.stream' nextByte' 2);                 if ((len >> 63) != 0 || len > Int32.MaxValue) {                   throw new CBORException("Length" + ToUnsignedEInteger(len) +                     " is bigger than supported ");                 }                 if (nextByte != 0x40) {                   // NOTE: 0x40 means the empty byte string                   ReadByteData(this.stream' len' ms);                 }               }               if (ms.Position > Int32.MaxValue) {                 throw new                 CBORException("Length of bytes to be streamed is bigger" + "\u0020than supported ");               }               data = ms.ToArray();               return CBORObject.FromRaw(data);             }           }           case 3: {             // Streaming text string             var builder = new StringBuilder();             while (true) {               int nextByte = this.stream.ReadByte();               if (nextByte == 0xff) {                 // break if the "break" code was read                 break;               }               long len = ReadDataLength(this.stream' nextByte' 3);               if ((len >> 63) != 0 || len > Int32.MaxValue) {                 throw new CBORException("Length" + ToUnsignedEInteger(len) +                   " is bigger than supported");               }               if (nextByte != 0x60) {                 // NOTE: 0x60 means the empty string                 if (PropertyMap.ExceedsKnownLength(this.stream' len)) {                   throw new CBORException("Premature end of data");                 }                 switch (                   DataUtilities.ReadUtf8 (                     this.stream'                     (int)len'                     builder'                     false)) {                   case -1:                     throw new CBORException("Invalid UTF-8");                   case -2:                     throw new CBORException("Premature end of data");                 }               }             }             return CBORObject.FromRaw(builder.ToString());           }           case 4: {             CBORObject cbor = CBORObject.NewArray();             var vtindex = 0;             // Indefinite-length array             while (true) {               int headByte = this.stream.ReadByte();               if (headByte < 0) {                 throw new CBORException("Premature end of data");               }               if (headByte == 0xff) {                 // Break code was read                 break;               }               ++this.depth;               CBORObject o = this.ReadForFirstByte (                   headByte);               --this.depth;               cbor.Add(o);               ++vtindex;             }             return cbor;           }           case 5: {             CBORObject cbor = CBORObject.NewMap();             // Indefinite-length map             while (true) {               int headByte = this.stream.ReadByte();               if (headByte < 0) {                 throw new CBORException("Premature end of data");               }               if (headByte == 0xff) {                 // Break code was read                 break;               }               ++this.depth;               CBORObject key = this.ReadForFirstByte(headByte);               CBORObject value = this.ReadInternal();               --this.depth;               if (!this.options.AllowDuplicateKeys) {                 if (cbor.ContainsKey(key)) {                   throw new CBORException("Duplicate key already exists");                 }               }               cbor[key] = value;             }             return cbor;           }           default: throw new CBORException("Unexpected data encountered");         }
Magic Number,PeterO.Cbor,CBORReader,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORReader.cs,ReadForFirstByte,The following statement contains a magic number: switch (type) {           case 2: {             // Streaming byte string             using (var ms = new MemoryStream()) {               // Requires same type as this one               while (true) {                 int nextByte = this.stream.ReadByte();                 if (nextByte == 0xff) {                   // break if the "break" code was read                   break;                 }                 long len = ReadDataLength(this.stream' nextByte' 2);                 if ((len >> 63) != 0 || len > Int32.MaxValue) {                   throw new CBORException("Length" + ToUnsignedEInteger(len) +                     " is bigger than supported ");                 }                 if (nextByte != 0x40) {                   // NOTE: 0x40 means the empty byte string                   ReadByteData(this.stream' len' ms);                 }               }               if (ms.Position > Int32.MaxValue) {                 throw new                 CBORException("Length of bytes to be streamed is bigger" + "\u0020than supported ");               }               data = ms.ToArray();               return CBORObject.FromRaw(data);             }           }           case 3: {             // Streaming text string             var builder = new StringBuilder();             while (true) {               int nextByte = this.stream.ReadByte();               if (nextByte == 0xff) {                 // break if the "break" code was read                 break;               }               long len = ReadDataLength(this.stream' nextByte' 3);               if ((len >> 63) != 0 || len > Int32.MaxValue) {                 throw new CBORException("Length" + ToUnsignedEInteger(len) +                   " is bigger than supported");               }               if (nextByte != 0x60) {                 // NOTE: 0x60 means the empty string                 if (PropertyMap.ExceedsKnownLength(this.stream' len)) {                   throw new CBORException("Premature end of data");                 }                 switch (                   DataUtilities.ReadUtf8 (                     this.stream'                     (int)len'                     builder'                     false)) {                   case -1:                     throw new CBORException("Invalid UTF-8");                   case -2:                     throw new CBORException("Premature end of data");                 }               }             }             return CBORObject.FromRaw(builder.ToString());           }           case 4: {             CBORObject cbor = CBORObject.NewArray();             var vtindex = 0;             // Indefinite-length array             while (true) {               int headByte = this.stream.ReadByte();               if (headByte < 0) {                 throw new CBORException("Premature end of data");               }               if (headByte == 0xff) {                 // Break code was read                 break;               }               ++this.depth;               CBORObject o = this.ReadForFirstByte (                   headByte);               --this.depth;               cbor.Add(o);               ++vtindex;             }             return cbor;           }           case 5: {             CBORObject cbor = CBORObject.NewMap();             // Indefinite-length map             while (true) {               int headByte = this.stream.ReadByte();               if (headByte < 0) {                 throw new CBORException("Premature end of data");               }               if (headByte == 0xff) {                 // Break code was read                 break;               }               ++this.depth;               CBORObject key = this.ReadForFirstByte(headByte);               CBORObject value = this.ReadInternal();               --this.depth;               if (!this.options.AllowDuplicateKeys) {                 if (cbor.ContainsKey(key)) {                   throw new CBORException("Duplicate key already exists");                 }               }               cbor[key] = value;             }             return cbor;           }           default: throw new CBORException("Unexpected data encountered");         }
Magic Number,PeterO.Cbor,CBORReader,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORReader.cs,ReadForFirstByte,The following statement contains a magic number: additional == 31
Magic Number,PeterO.Cbor,CBORReader,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORReader.cs,ReadForFirstByte,The following statement contains a magic number: type >= 2 && type <= 5
Magic Number,PeterO.Cbor,CBORReader,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORReader.cs,ReadForFirstByte,The following statement contains a magic number: type >= 2 && type <= 5
Magic Number,PeterO.Cbor,CBORReader,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORReader.cs,ReadForFirstByte,The following statement contains a magic number: this.options.ResolveReferences && (uadditional >> 32) == 0
Magic Number,PeterO.Cbor,CBORReader,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORReader.cs,ReadForFirstByte,The following statement contains a magic number: (uadditional >> 63) != 0
Magic Number,PeterO.Cbor,CBORReader,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORReader.cs,ReadForFirstByte,The following statement contains a magic number: int uaddl = uadditional >= 257 ? 257 : (uadditional < 0 ? 0 :                 (int)uadditional);
Magic Number,PeterO.Cbor,CBORReader,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORReader.cs,ReadForFirstByte,The following statement contains a magic number: int uaddl = uadditional >= 257 ? 257 : (uadditional < 0 ? 0 :                 (int)uadditional);
Magic Number,PeterO.Cbor,CBORReader,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORReader.cs,ReadForFirstByte,The following statement contains a magic number: switch (uaddl) {               case 256:                 // string tag                 this.stringRefs.Pop();                 break;               case 25:                 // stringref tag                 if (o.IsTagged || o.Type != CBORType.Integer) {                   throw new CBORException("stringref must be an unsigned" +                     "\u0020integer");                 }                 return this.stringRefs.GetString(o.AsEIntegerValue());             }
Magic Number,PeterO.Cbor,CBORReader,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORReader.cs,ReadForFirstByte,The following statement contains a magic number: switch (uaddl) {               case 256:                 // string tag                 this.stringRefs.Pop();                 break;               case 25:                 // stringref tag                 if (o.IsTagged || o.Type != CBORType.Integer) {                   throw new CBORException("stringref must be an unsigned" +                     "\u0020integer");                 }                 return this.stringRefs.GetString(o.AsEIntegerValue());             }
Magic Number,PeterO.Cbor,CBORReader,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORReader.cs,ReadForFirstByte,The following statement contains a magic number: uadditional < 65536
Magic Number,PeterO.Cbor,CBORReader,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORReader.cs,ReadForFirstByte,The following statement contains a magic number: type == 6
Magic Number,PeterO.Cbor,CBORReader,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORReader.cs,ReadByteData,The following statement contains a magic number: (uadditional >> 63) != 0 || uadditional > Int32.MaxValue
Magic Number,PeterO.Cbor,CBORReader,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORReader.cs,ReadDataLength,The following statement contains a magic number: ((headByte >> 5) & 0x07) != expectedType
Magic Number,PeterO.Cbor,CBORReader,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORReader.cs,ReadDataLength,The following statement contains a magic number: headByte < 24
Magic Number,PeterO.Cbor,CBORReader,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORReader.cs,ReadDataLength,The following statement contains a magic number: var data = new byte[8];
Magic Number,PeterO.Cbor,CBORReader,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORReader.cs,ReadDataLength,The following statement contains a magic number: switch (headByte) {         case 24: {           int tmp = stream.ReadByte();           if (tmp < 0) {             throw new CBORException("Premature end of data");           }           if (!allowNonShortest && tmp < 24) {             throw new CBORException("Non-shortest CBOR form");           }           return tmp;         }         case 25: {           if (stream.Read(data' 0' 2) != 2) {             throw new CBORException("Premature end of data");           }           int lowAdditional = ((int)(data[0] & (int)0xff)) << 8;           lowAdditional |= (int)(data[1] & (int)0xff);           if (!allowNonShortest && lowAdditional < 256) {             throw new CBORException("Non-shortest CBOR form");           }           return lowAdditional;         }         case 26: {           if (stream.Read(data' 0' 4) != 4) {             throw new CBORException("Premature end of data");           }           long uadditional = ((long)(data[0] & 0xffL)) << 24;           uadditional |= ((long)(data[1] & 0xffL)) << 16;           uadditional |= ((long)(data[2] & 0xffL)) << 8;           uadditional |= (long)(data[3] & 0xffL);           if (!allowNonShortest && (uadditional >> 16) == 0) {             throw new CBORException("Non-shortest CBOR form");           }           return uadditional;         }         case 27: {           if (stream.Read(data' 0' 8) != 8) {             throw new CBORException("Premature end of data");           }           // Treat return value as an unsigned integer           long uadditional = ((long)(data[0] & 0xffL)) << 56;           uadditional |= ((long)(data[1] & 0xffL)) << 48;           uadditional |= ((long)(data[2] & 0xffL)) << 40;           uadditional |= ((long)(data[3] & 0xffL)) << 32;           uadditional |= ((long)(data[4] & 0xffL)) << 24;           uadditional |= ((long)(data[5] & 0xffL)) << 16;           uadditional |= ((long)(data[6] & 0xffL)) << 8;           uadditional |= (long)(data[7] & 0xffL);           if (!allowNonShortest && (uadditional >> 32) == 0) {             throw new CBORException("Non-shortest CBOR form");           }           return uadditional;         }         case 28:         case 29:         case 30:           throw new CBORException("Unexpected data encountered");         case 31:           throw new CBORException("Indefinite-length data not allowed" + "\u0020here");         default: return headByte;       }
Magic Number,PeterO.Cbor,CBORReader,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORReader.cs,ReadDataLength,The following statement contains a magic number: switch (headByte) {         case 24: {           int tmp = stream.ReadByte();           if (tmp < 0) {             throw new CBORException("Premature end of data");           }           if (!allowNonShortest && tmp < 24) {             throw new CBORException("Non-shortest CBOR form");           }           return tmp;         }         case 25: {           if (stream.Read(data' 0' 2) != 2) {             throw new CBORException("Premature end of data");           }           int lowAdditional = ((int)(data[0] & (int)0xff)) << 8;           lowAdditional |= (int)(data[1] & (int)0xff);           if (!allowNonShortest && lowAdditional < 256) {             throw new CBORException("Non-shortest CBOR form");           }           return lowAdditional;         }         case 26: {           if (stream.Read(data' 0' 4) != 4) {             throw new CBORException("Premature end of data");           }           long uadditional = ((long)(data[0] & 0xffL)) << 24;           uadditional |= ((long)(data[1] & 0xffL)) << 16;           uadditional |= ((long)(data[2] & 0xffL)) << 8;           uadditional |= (long)(data[3] & 0xffL);           if (!allowNonShortest && (uadditional >> 16) == 0) {             throw new CBORException("Non-shortest CBOR form");           }           return uadditional;         }         case 27: {           if (stream.Read(data' 0' 8) != 8) {             throw new CBORException("Premature end of data");           }           // Treat return value as an unsigned integer           long uadditional = ((long)(data[0] & 0xffL)) << 56;           uadditional |= ((long)(data[1] & 0xffL)) << 48;           uadditional |= ((long)(data[2] & 0xffL)) << 40;           uadditional |= ((long)(data[3] & 0xffL)) << 32;           uadditional |= ((long)(data[4] & 0xffL)) << 24;           uadditional |= ((long)(data[5] & 0xffL)) << 16;           uadditional |= ((long)(data[6] & 0xffL)) << 8;           uadditional |= (long)(data[7] & 0xffL);           if (!allowNonShortest && (uadditional >> 32) == 0) {             throw new CBORException("Non-shortest CBOR form");           }           return uadditional;         }         case 28:         case 29:         case 30:           throw new CBORException("Unexpected data encountered");         case 31:           throw new CBORException("Indefinite-length data not allowed" + "\u0020here");         default: return headByte;       }
Magic Number,PeterO.Cbor,CBORReader,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORReader.cs,ReadDataLength,The following statement contains a magic number: switch (headByte) {         case 24: {           int tmp = stream.ReadByte();           if (tmp < 0) {             throw new CBORException("Premature end of data");           }           if (!allowNonShortest && tmp < 24) {             throw new CBORException("Non-shortest CBOR form");           }           return tmp;         }         case 25: {           if (stream.Read(data' 0' 2) != 2) {             throw new CBORException("Premature end of data");           }           int lowAdditional = ((int)(data[0] & (int)0xff)) << 8;           lowAdditional |= (int)(data[1] & (int)0xff);           if (!allowNonShortest && lowAdditional < 256) {             throw new CBORException("Non-shortest CBOR form");           }           return lowAdditional;         }         case 26: {           if (stream.Read(data' 0' 4) != 4) {             throw new CBORException("Premature end of data");           }           long uadditional = ((long)(data[0] & 0xffL)) << 24;           uadditional |= ((long)(data[1] & 0xffL)) << 16;           uadditional |= ((long)(data[2] & 0xffL)) << 8;           uadditional |= (long)(data[3] & 0xffL);           if (!allowNonShortest && (uadditional >> 16) == 0) {             throw new CBORException("Non-shortest CBOR form");           }           return uadditional;         }         case 27: {           if (stream.Read(data' 0' 8) != 8) {             throw new CBORException("Premature end of data");           }           // Treat return value as an unsigned integer           long uadditional = ((long)(data[0] & 0xffL)) << 56;           uadditional |= ((long)(data[1] & 0xffL)) << 48;           uadditional |= ((long)(data[2] & 0xffL)) << 40;           uadditional |= ((long)(data[3] & 0xffL)) << 32;           uadditional |= ((long)(data[4] & 0xffL)) << 24;           uadditional |= ((long)(data[5] & 0xffL)) << 16;           uadditional |= ((long)(data[6] & 0xffL)) << 8;           uadditional |= (long)(data[7] & 0xffL);           if (!allowNonShortest && (uadditional >> 32) == 0) {             throw new CBORException("Non-shortest CBOR form");           }           return uadditional;         }         case 28:         case 29:         case 30:           throw new CBORException("Unexpected data encountered");         case 31:           throw new CBORException("Indefinite-length data not allowed" + "\u0020here");         default: return headByte;       }
Magic Number,PeterO.Cbor,CBORReader,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORReader.cs,ReadDataLength,The following statement contains a magic number: switch (headByte) {         case 24: {           int tmp = stream.ReadByte();           if (tmp < 0) {             throw new CBORException("Premature end of data");           }           if (!allowNonShortest && tmp < 24) {             throw new CBORException("Non-shortest CBOR form");           }           return tmp;         }         case 25: {           if (stream.Read(data' 0' 2) != 2) {             throw new CBORException("Premature end of data");           }           int lowAdditional = ((int)(data[0] & (int)0xff)) << 8;           lowAdditional |= (int)(data[1] & (int)0xff);           if (!allowNonShortest && lowAdditional < 256) {             throw new CBORException("Non-shortest CBOR form");           }           return lowAdditional;         }         case 26: {           if (stream.Read(data' 0' 4) != 4) {             throw new CBORException("Premature end of data");           }           long uadditional = ((long)(data[0] & 0xffL)) << 24;           uadditional |= ((long)(data[1] & 0xffL)) << 16;           uadditional |= ((long)(data[2] & 0xffL)) << 8;           uadditional |= (long)(data[3] & 0xffL);           if (!allowNonShortest && (uadditional >> 16) == 0) {             throw new CBORException("Non-shortest CBOR form");           }           return uadditional;         }         case 27: {           if (stream.Read(data' 0' 8) != 8) {             throw new CBORException("Premature end of data");           }           // Treat return value as an unsigned integer           long uadditional = ((long)(data[0] & 0xffL)) << 56;           uadditional |= ((long)(data[1] & 0xffL)) << 48;           uadditional |= ((long)(data[2] & 0xffL)) << 40;           uadditional |= ((long)(data[3] & 0xffL)) << 32;           uadditional |= ((long)(data[4] & 0xffL)) << 24;           uadditional |= ((long)(data[5] & 0xffL)) << 16;           uadditional |= ((long)(data[6] & 0xffL)) << 8;           uadditional |= (long)(data[7] & 0xffL);           if (!allowNonShortest && (uadditional >> 32) == 0) {             throw new CBORException("Non-shortest CBOR form");           }           return uadditional;         }         case 28:         case 29:         case 30:           throw new CBORException("Unexpected data encountered");         case 31:           throw new CBORException("Indefinite-length data not allowed" + "\u0020here");         default: return headByte;       }
Magic Number,PeterO.Cbor,CBORReader,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORReader.cs,ReadDataLength,The following statement contains a magic number: switch (headByte) {         case 24: {           int tmp = stream.ReadByte();           if (tmp < 0) {             throw new CBORException("Premature end of data");           }           if (!allowNonShortest && tmp < 24) {             throw new CBORException("Non-shortest CBOR form");           }           return tmp;         }         case 25: {           if (stream.Read(data' 0' 2) != 2) {             throw new CBORException("Premature end of data");           }           int lowAdditional = ((int)(data[0] & (int)0xff)) << 8;           lowAdditional |= (int)(data[1] & (int)0xff);           if (!allowNonShortest && lowAdditional < 256) {             throw new CBORException("Non-shortest CBOR form");           }           return lowAdditional;         }         case 26: {           if (stream.Read(data' 0' 4) != 4) {             throw new CBORException("Premature end of data");           }           long uadditional = ((long)(data[0] & 0xffL)) << 24;           uadditional |= ((long)(data[1] & 0xffL)) << 16;           uadditional |= ((long)(data[2] & 0xffL)) << 8;           uadditional |= (long)(data[3] & 0xffL);           if (!allowNonShortest && (uadditional >> 16) == 0) {             throw new CBORException("Non-shortest CBOR form");           }           return uadditional;         }         case 27: {           if (stream.Read(data' 0' 8) != 8) {             throw new CBORException("Premature end of data");           }           // Treat return value as an unsigned integer           long uadditional = ((long)(data[0] & 0xffL)) << 56;           uadditional |= ((long)(data[1] & 0xffL)) << 48;           uadditional |= ((long)(data[2] & 0xffL)) << 40;           uadditional |= ((long)(data[3] & 0xffL)) << 32;           uadditional |= ((long)(data[4] & 0xffL)) << 24;           uadditional |= ((long)(data[5] & 0xffL)) << 16;           uadditional |= ((long)(data[6] & 0xffL)) << 8;           uadditional |= (long)(data[7] & 0xffL);           if (!allowNonShortest && (uadditional >> 32) == 0) {             throw new CBORException("Non-shortest CBOR form");           }           return uadditional;         }         case 28:         case 29:         case 30:           throw new CBORException("Unexpected data encountered");         case 31:           throw new CBORException("Indefinite-length data not allowed" + "\u0020here");         default: return headByte;       }
Magic Number,PeterO.Cbor,CBORReader,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORReader.cs,ReadDataLength,The following statement contains a magic number: switch (headByte) {         case 24: {           int tmp = stream.ReadByte();           if (tmp < 0) {             throw new CBORException("Premature end of data");           }           if (!allowNonShortest && tmp < 24) {             throw new CBORException("Non-shortest CBOR form");           }           return tmp;         }         case 25: {           if (stream.Read(data' 0' 2) != 2) {             throw new CBORException("Premature end of data");           }           int lowAdditional = ((int)(data[0] & (int)0xff)) << 8;           lowAdditional |= (int)(data[1] & (int)0xff);           if (!allowNonShortest && lowAdditional < 256) {             throw new CBORException("Non-shortest CBOR form");           }           return lowAdditional;         }         case 26: {           if (stream.Read(data' 0' 4) != 4) {             throw new CBORException("Premature end of data");           }           long uadditional = ((long)(data[0] & 0xffL)) << 24;           uadditional |= ((long)(data[1] & 0xffL)) << 16;           uadditional |= ((long)(data[2] & 0xffL)) << 8;           uadditional |= (long)(data[3] & 0xffL);           if (!allowNonShortest && (uadditional >> 16) == 0) {             throw new CBORException("Non-shortest CBOR form");           }           return uadditional;         }         case 27: {           if (stream.Read(data' 0' 8) != 8) {             throw new CBORException("Premature end of data");           }           // Treat return value as an unsigned integer           long uadditional = ((long)(data[0] & 0xffL)) << 56;           uadditional |= ((long)(data[1] & 0xffL)) << 48;           uadditional |= ((long)(data[2] & 0xffL)) << 40;           uadditional |= ((long)(data[3] & 0xffL)) << 32;           uadditional |= ((long)(data[4] & 0xffL)) << 24;           uadditional |= ((long)(data[5] & 0xffL)) << 16;           uadditional |= ((long)(data[6] & 0xffL)) << 8;           uadditional |= (long)(data[7] & 0xffL);           if (!allowNonShortest && (uadditional >> 32) == 0) {             throw new CBORException("Non-shortest CBOR form");           }           return uadditional;         }         case 28:         case 29:         case 30:           throw new CBORException("Unexpected data encountered");         case 31:           throw new CBORException("Indefinite-length data not allowed" + "\u0020here");         default: return headByte;       }
Magic Number,PeterO.Cbor,CBORReader,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORReader.cs,ReadDataLength,The following statement contains a magic number: switch (headByte) {         case 24: {           int tmp = stream.ReadByte();           if (tmp < 0) {             throw new CBORException("Premature end of data");           }           if (!allowNonShortest && tmp < 24) {             throw new CBORException("Non-shortest CBOR form");           }           return tmp;         }         case 25: {           if (stream.Read(data' 0' 2) != 2) {             throw new CBORException("Premature end of data");           }           int lowAdditional = ((int)(data[0] & (int)0xff)) << 8;           lowAdditional |= (int)(data[1] & (int)0xff);           if (!allowNonShortest && lowAdditional < 256) {             throw new CBORException("Non-shortest CBOR form");           }           return lowAdditional;         }         case 26: {           if (stream.Read(data' 0' 4) != 4) {             throw new CBORException("Premature end of data");           }           long uadditional = ((long)(data[0] & 0xffL)) << 24;           uadditional |= ((long)(data[1] & 0xffL)) << 16;           uadditional |= ((long)(data[2] & 0xffL)) << 8;           uadditional |= (long)(data[3] & 0xffL);           if (!allowNonShortest && (uadditional >> 16) == 0) {             throw new CBORException("Non-shortest CBOR form");           }           return uadditional;         }         case 27: {           if (stream.Read(data' 0' 8) != 8) {             throw new CBORException("Premature end of data");           }           // Treat return value as an unsigned integer           long uadditional = ((long)(data[0] & 0xffL)) << 56;           uadditional |= ((long)(data[1] & 0xffL)) << 48;           uadditional |= ((long)(data[2] & 0xffL)) << 40;           uadditional |= ((long)(data[3] & 0xffL)) << 32;           uadditional |= ((long)(data[4] & 0xffL)) << 24;           uadditional |= ((long)(data[5] & 0xffL)) << 16;           uadditional |= ((long)(data[6] & 0xffL)) << 8;           uadditional |= (long)(data[7] & 0xffL);           if (!allowNonShortest && (uadditional >> 32) == 0) {             throw new CBORException("Non-shortest CBOR form");           }           return uadditional;         }         case 28:         case 29:         case 30:           throw new CBORException("Unexpected data encountered");         case 31:           throw new CBORException("Indefinite-length data not allowed" + "\u0020here");         default: return headByte;       }
Magic Number,PeterO.Cbor,CBORReader,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORReader.cs,ReadDataLength,The following statement contains a magic number: switch (headByte) {         case 24: {           int tmp = stream.ReadByte();           if (tmp < 0) {             throw new CBORException("Premature end of data");           }           if (!allowNonShortest && tmp < 24) {             throw new CBORException("Non-shortest CBOR form");           }           return tmp;         }         case 25: {           if (stream.Read(data' 0' 2) != 2) {             throw new CBORException("Premature end of data");           }           int lowAdditional = ((int)(data[0] & (int)0xff)) << 8;           lowAdditional |= (int)(data[1] & (int)0xff);           if (!allowNonShortest && lowAdditional < 256) {             throw new CBORException("Non-shortest CBOR form");           }           return lowAdditional;         }         case 26: {           if (stream.Read(data' 0' 4) != 4) {             throw new CBORException("Premature end of data");           }           long uadditional = ((long)(data[0] & 0xffL)) << 24;           uadditional |= ((long)(data[1] & 0xffL)) << 16;           uadditional |= ((long)(data[2] & 0xffL)) << 8;           uadditional |= (long)(data[3] & 0xffL);           if (!allowNonShortest && (uadditional >> 16) == 0) {             throw new CBORException("Non-shortest CBOR form");           }           return uadditional;         }         case 27: {           if (stream.Read(data' 0' 8) != 8) {             throw new CBORException("Premature end of data");           }           // Treat return value as an unsigned integer           long uadditional = ((long)(data[0] & 0xffL)) << 56;           uadditional |= ((long)(data[1] & 0xffL)) << 48;           uadditional |= ((long)(data[2] & 0xffL)) << 40;           uadditional |= ((long)(data[3] & 0xffL)) << 32;           uadditional |= ((long)(data[4] & 0xffL)) << 24;           uadditional |= ((long)(data[5] & 0xffL)) << 16;           uadditional |= ((long)(data[6] & 0xffL)) << 8;           uadditional |= (long)(data[7] & 0xffL);           if (!allowNonShortest && (uadditional >> 32) == 0) {             throw new CBORException("Non-shortest CBOR form");           }           return uadditional;         }         case 28:         case 29:         case 30:           throw new CBORException("Unexpected data encountered");         case 31:           throw new CBORException("Indefinite-length data not allowed" + "\u0020here");         default: return headByte;       }
Magic Number,PeterO.Cbor,CBORReader,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORReader.cs,ReadDataLength,The following statement contains a magic number: switch (headByte) {         case 24: {           int tmp = stream.ReadByte();           if (tmp < 0) {             throw new CBORException("Premature end of data");           }           if (!allowNonShortest && tmp < 24) {             throw new CBORException("Non-shortest CBOR form");           }           return tmp;         }         case 25: {           if (stream.Read(data' 0' 2) != 2) {             throw new CBORException("Premature end of data");           }           int lowAdditional = ((int)(data[0] & (int)0xff)) << 8;           lowAdditional |= (int)(data[1] & (int)0xff);           if (!allowNonShortest && lowAdditional < 256) {             throw new CBORException("Non-shortest CBOR form");           }           return lowAdditional;         }         case 26: {           if (stream.Read(data' 0' 4) != 4) {             throw new CBORException("Premature end of data");           }           long uadditional = ((long)(data[0] & 0xffL)) << 24;           uadditional |= ((long)(data[1] & 0xffL)) << 16;           uadditional |= ((long)(data[2] & 0xffL)) << 8;           uadditional |= (long)(data[3] & 0xffL);           if (!allowNonShortest && (uadditional >> 16) == 0) {             throw new CBORException("Non-shortest CBOR form");           }           return uadditional;         }         case 27: {           if (stream.Read(data' 0' 8) != 8) {             throw new CBORException("Premature end of data");           }           // Treat return value as an unsigned integer           long uadditional = ((long)(data[0] & 0xffL)) << 56;           uadditional |= ((long)(data[1] & 0xffL)) << 48;           uadditional |= ((long)(data[2] & 0xffL)) << 40;           uadditional |= ((long)(data[3] & 0xffL)) << 32;           uadditional |= ((long)(data[4] & 0xffL)) << 24;           uadditional |= ((long)(data[5] & 0xffL)) << 16;           uadditional |= ((long)(data[6] & 0xffL)) << 8;           uadditional |= (long)(data[7] & 0xffL);           if (!allowNonShortest && (uadditional >> 32) == 0) {             throw new CBORException("Non-shortest CBOR form");           }           return uadditional;         }         case 28:         case 29:         case 30:           throw new CBORException("Unexpected data encountered");         case 31:           throw new CBORException("Indefinite-length data not allowed" + "\u0020here");         default: return headByte;       }
Magic Number,PeterO.Cbor,CBORReader,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORReader.cs,ReadDataLength,The following statement contains a magic number: switch (headByte) {         case 24: {           int tmp = stream.ReadByte();           if (tmp < 0) {             throw new CBORException("Premature end of data");           }           if (!allowNonShortest && tmp < 24) {             throw new CBORException("Non-shortest CBOR form");           }           return tmp;         }         case 25: {           if (stream.Read(data' 0' 2) != 2) {             throw new CBORException("Premature end of data");           }           int lowAdditional = ((int)(data[0] & (int)0xff)) << 8;           lowAdditional |= (int)(data[1] & (int)0xff);           if (!allowNonShortest && lowAdditional < 256) {             throw new CBORException("Non-shortest CBOR form");           }           return lowAdditional;         }         case 26: {           if (stream.Read(data' 0' 4) != 4) {             throw new CBORException("Premature end of data");           }           long uadditional = ((long)(data[0] & 0xffL)) << 24;           uadditional |= ((long)(data[1] & 0xffL)) << 16;           uadditional |= ((long)(data[2] & 0xffL)) << 8;           uadditional |= (long)(data[3] & 0xffL);           if (!allowNonShortest && (uadditional >> 16) == 0) {             throw new CBORException("Non-shortest CBOR form");           }           return uadditional;         }         case 27: {           if (stream.Read(data' 0' 8) != 8) {             throw new CBORException("Premature end of data");           }           // Treat return value as an unsigned integer           long uadditional = ((long)(data[0] & 0xffL)) << 56;           uadditional |= ((long)(data[1] & 0xffL)) << 48;           uadditional |= ((long)(data[2] & 0xffL)) << 40;           uadditional |= ((long)(data[3] & 0xffL)) << 32;           uadditional |= ((long)(data[4] & 0xffL)) << 24;           uadditional |= ((long)(data[5] & 0xffL)) << 16;           uadditional |= ((long)(data[6] & 0xffL)) << 8;           uadditional |= (long)(data[7] & 0xffL);           if (!allowNonShortest && (uadditional >> 32) == 0) {             throw new CBORException("Non-shortest CBOR form");           }           return uadditional;         }         case 28:         case 29:         case 30:           throw new CBORException("Unexpected data encountered");         case 31:           throw new CBORException("Indefinite-length data not allowed" + "\u0020here");         default: return headByte;       }
Magic Number,PeterO.Cbor,CBORReader,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORReader.cs,ReadDataLength,The following statement contains a magic number: switch (headByte) {         case 24: {           int tmp = stream.ReadByte();           if (tmp < 0) {             throw new CBORException("Premature end of data");           }           if (!allowNonShortest && tmp < 24) {             throw new CBORException("Non-shortest CBOR form");           }           return tmp;         }         case 25: {           if (stream.Read(data' 0' 2) != 2) {             throw new CBORException("Premature end of data");           }           int lowAdditional = ((int)(data[0] & (int)0xff)) << 8;           lowAdditional |= (int)(data[1] & (int)0xff);           if (!allowNonShortest && lowAdditional < 256) {             throw new CBORException("Non-shortest CBOR form");           }           return lowAdditional;         }         case 26: {           if (stream.Read(data' 0' 4) != 4) {             throw new CBORException("Premature end of data");           }           long uadditional = ((long)(data[0] & 0xffL)) << 24;           uadditional |= ((long)(data[1] & 0xffL)) << 16;           uadditional |= ((long)(data[2] & 0xffL)) << 8;           uadditional |= (long)(data[3] & 0xffL);           if (!allowNonShortest && (uadditional >> 16) == 0) {             throw new CBORException("Non-shortest CBOR form");           }           return uadditional;         }         case 27: {           if (stream.Read(data' 0' 8) != 8) {             throw new CBORException("Premature end of data");           }           // Treat return value as an unsigned integer           long uadditional = ((long)(data[0] & 0xffL)) << 56;           uadditional |= ((long)(data[1] & 0xffL)) << 48;           uadditional |= ((long)(data[2] & 0xffL)) << 40;           uadditional |= ((long)(data[3] & 0xffL)) << 32;           uadditional |= ((long)(data[4] & 0xffL)) << 24;           uadditional |= ((long)(data[5] & 0xffL)) << 16;           uadditional |= ((long)(data[6] & 0xffL)) << 8;           uadditional |= (long)(data[7] & 0xffL);           if (!allowNonShortest && (uadditional >> 32) == 0) {             throw new CBORException("Non-shortest CBOR form");           }           return uadditional;         }         case 28:         case 29:         case 30:           throw new CBORException("Unexpected data encountered");         case 31:           throw new CBORException("Indefinite-length data not allowed" + "\u0020here");         default: return headByte;       }
Magic Number,PeterO.Cbor,CBORReader,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORReader.cs,ReadDataLength,The following statement contains a magic number: switch (headByte) {         case 24: {           int tmp = stream.ReadByte();           if (tmp < 0) {             throw new CBORException("Premature end of data");           }           if (!allowNonShortest && tmp < 24) {             throw new CBORException("Non-shortest CBOR form");           }           return tmp;         }         case 25: {           if (stream.Read(data' 0' 2) != 2) {             throw new CBORException("Premature end of data");           }           int lowAdditional = ((int)(data[0] & (int)0xff)) << 8;           lowAdditional |= (int)(data[1] & (int)0xff);           if (!allowNonShortest && lowAdditional < 256) {             throw new CBORException("Non-shortest CBOR form");           }           return lowAdditional;         }         case 26: {           if (stream.Read(data' 0' 4) != 4) {             throw new CBORException("Premature end of data");           }           long uadditional = ((long)(data[0] & 0xffL)) << 24;           uadditional |= ((long)(data[1] & 0xffL)) << 16;           uadditional |= ((long)(data[2] & 0xffL)) << 8;           uadditional |= (long)(data[3] & 0xffL);           if (!allowNonShortest && (uadditional >> 16) == 0) {             throw new CBORException("Non-shortest CBOR form");           }           return uadditional;         }         case 27: {           if (stream.Read(data' 0' 8) != 8) {             throw new CBORException("Premature end of data");           }           // Treat return value as an unsigned integer           long uadditional = ((long)(data[0] & 0xffL)) << 56;           uadditional |= ((long)(data[1] & 0xffL)) << 48;           uadditional |= ((long)(data[2] & 0xffL)) << 40;           uadditional |= ((long)(data[3] & 0xffL)) << 32;           uadditional |= ((long)(data[4] & 0xffL)) << 24;           uadditional |= ((long)(data[5] & 0xffL)) << 16;           uadditional |= ((long)(data[6] & 0xffL)) << 8;           uadditional |= (long)(data[7] & 0xffL);           if (!allowNonShortest && (uadditional >> 32) == 0) {             throw new CBORException("Non-shortest CBOR form");           }           return uadditional;         }         case 28:         case 29:         case 30:           throw new CBORException("Unexpected data encountered");         case 31:           throw new CBORException("Indefinite-length data not allowed" + "\u0020here");         default: return headByte;       }
Magic Number,PeterO.Cbor,CBORReader,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORReader.cs,ReadDataLength,The following statement contains a magic number: switch (headByte) {         case 24: {           int tmp = stream.ReadByte();           if (tmp < 0) {             throw new CBORException("Premature end of data");           }           if (!allowNonShortest && tmp < 24) {             throw new CBORException("Non-shortest CBOR form");           }           return tmp;         }         case 25: {           if (stream.Read(data' 0' 2) != 2) {             throw new CBORException("Premature end of data");           }           int lowAdditional = ((int)(data[0] & (int)0xff)) << 8;           lowAdditional |= (int)(data[1] & (int)0xff);           if (!allowNonShortest && lowAdditional < 256) {             throw new CBORException("Non-shortest CBOR form");           }           return lowAdditional;         }         case 26: {           if (stream.Read(data' 0' 4) != 4) {             throw new CBORException("Premature end of data");           }           long uadditional = ((long)(data[0] & 0xffL)) << 24;           uadditional |= ((long)(data[1] & 0xffL)) << 16;           uadditional |= ((long)(data[2] & 0xffL)) << 8;           uadditional |= (long)(data[3] & 0xffL);           if (!allowNonShortest && (uadditional >> 16) == 0) {             throw new CBORException("Non-shortest CBOR form");           }           return uadditional;         }         case 27: {           if (stream.Read(data' 0' 8) != 8) {             throw new CBORException("Premature end of data");           }           // Treat return value as an unsigned integer           long uadditional = ((long)(data[0] & 0xffL)) << 56;           uadditional |= ((long)(data[1] & 0xffL)) << 48;           uadditional |= ((long)(data[2] & 0xffL)) << 40;           uadditional |= ((long)(data[3] & 0xffL)) << 32;           uadditional |= ((long)(data[4] & 0xffL)) << 24;           uadditional |= ((long)(data[5] & 0xffL)) << 16;           uadditional |= ((long)(data[6] & 0xffL)) << 8;           uadditional |= (long)(data[7] & 0xffL);           if (!allowNonShortest && (uadditional >> 32) == 0) {             throw new CBORException("Non-shortest CBOR form");           }           return uadditional;         }         case 28:         case 29:         case 30:           throw new CBORException("Unexpected data encountered");         case 31:           throw new CBORException("Indefinite-length data not allowed" + "\u0020here");         default: return headByte;       }
Magic Number,PeterO.Cbor,CBORReader,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORReader.cs,ReadDataLength,The following statement contains a magic number: switch (headByte) {         case 24: {           int tmp = stream.ReadByte();           if (tmp < 0) {             throw new CBORException("Premature end of data");           }           if (!allowNonShortest && tmp < 24) {             throw new CBORException("Non-shortest CBOR form");           }           return tmp;         }         case 25: {           if (stream.Read(data' 0' 2) != 2) {             throw new CBORException("Premature end of data");           }           int lowAdditional = ((int)(data[0] & (int)0xff)) << 8;           lowAdditional |= (int)(data[1] & (int)0xff);           if (!allowNonShortest && lowAdditional < 256) {             throw new CBORException("Non-shortest CBOR form");           }           return lowAdditional;         }         case 26: {           if (stream.Read(data' 0' 4) != 4) {             throw new CBORException("Premature end of data");           }           long uadditional = ((long)(data[0] & 0xffL)) << 24;           uadditional |= ((long)(data[1] & 0xffL)) << 16;           uadditional |= ((long)(data[2] & 0xffL)) << 8;           uadditional |= (long)(data[3] & 0xffL);           if (!allowNonShortest && (uadditional >> 16) == 0) {             throw new CBORException("Non-shortest CBOR form");           }           return uadditional;         }         case 27: {           if (stream.Read(data' 0' 8) != 8) {             throw new CBORException("Premature end of data");           }           // Treat return value as an unsigned integer           long uadditional = ((long)(data[0] & 0xffL)) << 56;           uadditional |= ((long)(data[1] & 0xffL)) << 48;           uadditional |= ((long)(data[2] & 0xffL)) << 40;           uadditional |= ((long)(data[3] & 0xffL)) << 32;           uadditional |= ((long)(data[4] & 0xffL)) << 24;           uadditional |= ((long)(data[5] & 0xffL)) << 16;           uadditional |= ((long)(data[6] & 0xffL)) << 8;           uadditional |= (long)(data[7] & 0xffL);           if (!allowNonShortest && (uadditional >> 32) == 0) {             throw new CBORException("Non-shortest CBOR form");           }           return uadditional;         }         case 28:         case 29:         case 30:           throw new CBORException("Unexpected data encountered");         case 31:           throw new CBORException("Indefinite-length data not allowed" + "\u0020here");         default: return headByte;       }
Magic Number,PeterO.Cbor,CBORReader,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORReader.cs,ReadDataLength,The following statement contains a magic number: switch (headByte) {         case 24: {           int tmp = stream.ReadByte();           if (tmp < 0) {             throw new CBORException("Premature end of data");           }           if (!allowNonShortest && tmp < 24) {             throw new CBORException("Non-shortest CBOR form");           }           return tmp;         }         case 25: {           if (stream.Read(data' 0' 2) != 2) {             throw new CBORException("Premature end of data");           }           int lowAdditional = ((int)(data[0] & (int)0xff)) << 8;           lowAdditional |= (int)(data[1] & (int)0xff);           if (!allowNonShortest && lowAdditional < 256) {             throw new CBORException("Non-shortest CBOR form");           }           return lowAdditional;         }         case 26: {           if (stream.Read(data' 0' 4) != 4) {             throw new CBORException("Premature end of data");           }           long uadditional = ((long)(data[0] & 0xffL)) << 24;           uadditional |= ((long)(data[1] & 0xffL)) << 16;           uadditional |= ((long)(data[2] & 0xffL)) << 8;           uadditional |= (long)(data[3] & 0xffL);           if (!allowNonShortest && (uadditional >> 16) == 0) {             throw new CBORException("Non-shortest CBOR form");           }           return uadditional;         }         case 27: {           if (stream.Read(data' 0' 8) != 8) {             throw new CBORException("Premature end of data");           }           // Treat return value as an unsigned integer           long uadditional = ((long)(data[0] & 0xffL)) << 56;           uadditional |= ((long)(data[1] & 0xffL)) << 48;           uadditional |= ((long)(data[2] & 0xffL)) << 40;           uadditional |= ((long)(data[3] & 0xffL)) << 32;           uadditional |= ((long)(data[4] & 0xffL)) << 24;           uadditional |= ((long)(data[5] & 0xffL)) << 16;           uadditional |= ((long)(data[6] & 0xffL)) << 8;           uadditional |= (long)(data[7] & 0xffL);           if (!allowNonShortest && (uadditional >> 32) == 0) {             throw new CBORException("Non-shortest CBOR form");           }           return uadditional;         }         case 28:         case 29:         case 30:           throw new CBORException("Unexpected data encountered");         case 31:           throw new CBORException("Indefinite-length data not allowed" + "\u0020here");         default: return headByte;       }
Magic Number,PeterO.Cbor,CBORReader,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORReader.cs,ReadDataLength,The following statement contains a magic number: switch (headByte) {         case 24: {           int tmp = stream.ReadByte();           if (tmp < 0) {             throw new CBORException("Premature end of data");           }           if (!allowNonShortest && tmp < 24) {             throw new CBORException("Non-shortest CBOR form");           }           return tmp;         }         case 25: {           if (stream.Read(data' 0' 2) != 2) {             throw new CBORException("Premature end of data");           }           int lowAdditional = ((int)(data[0] & (int)0xff)) << 8;           lowAdditional |= (int)(data[1] & (int)0xff);           if (!allowNonShortest && lowAdditional < 256) {             throw new CBORException("Non-shortest CBOR form");           }           return lowAdditional;         }         case 26: {           if (stream.Read(data' 0' 4) != 4) {             throw new CBORException("Premature end of data");           }           long uadditional = ((long)(data[0] & 0xffL)) << 24;           uadditional |= ((long)(data[1] & 0xffL)) << 16;           uadditional |= ((long)(data[2] & 0xffL)) << 8;           uadditional |= (long)(data[3] & 0xffL);           if (!allowNonShortest && (uadditional >> 16) == 0) {             throw new CBORException("Non-shortest CBOR form");           }           return uadditional;         }         case 27: {           if (stream.Read(data' 0' 8) != 8) {             throw new CBORException("Premature end of data");           }           // Treat return value as an unsigned integer           long uadditional = ((long)(data[0] & 0xffL)) << 56;           uadditional |= ((long)(data[1] & 0xffL)) << 48;           uadditional |= ((long)(data[2] & 0xffL)) << 40;           uadditional |= ((long)(data[3] & 0xffL)) << 32;           uadditional |= ((long)(data[4] & 0xffL)) << 24;           uadditional |= ((long)(data[5] & 0xffL)) << 16;           uadditional |= ((long)(data[6] & 0xffL)) << 8;           uadditional |= (long)(data[7] & 0xffL);           if (!allowNonShortest && (uadditional >> 32) == 0) {             throw new CBORException("Non-shortest CBOR form");           }           return uadditional;         }         case 28:         case 29:         case 30:           throw new CBORException("Unexpected data encountered");         case 31:           throw new CBORException("Indefinite-length data not allowed" + "\u0020here");         default: return headByte;       }
Magic Number,PeterO.Cbor,CBORReader,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORReader.cs,ReadDataLength,The following statement contains a magic number: switch (headByte) {         case 24: {           int tmp = stream.ReadByte();           if (tmp < 0) {             throw new CBORException("Premature end of data");           }           if (!allowNonShortest && tmp < 24) {             throw new CBORException("Non-shortest CBOR form");           }           return tmp;         }         case 25: {           if (stream.Read(data' 0' 2) != 2) {             throw new CBORException("Premature end of data");           }           int lowAdditional = ((int)(data[0] & (int)0xff)) << 8;           lowAdditional |= (int)(data[1] & (int)0xff);           if (!allowNonShortest && lowAdditional < 256) {             throw new CBORException("Non-shortest CBOR form");           }           return lowAdditional;         }         case 26: {           if (stream.Read(data' 0' 4) != 4) {             throw new CBORException("Premature end of data");           }           long uadditional = ((long)(data[0] & 0xffL)) << 24;           uadditional |= ((long)(data[1] & 0xffL)) << 16;           uadditional |= ((long)(data[2] & 0xffL)) << 8;           uadditional |= (long)(data[3] & 0xffL);           if (!allowNonShortest && (uadditional >> 16) == 0) {             throw new CBORException("Non-shortest CBOR form");           }           return uadditional;         }         case 27: {           if (stream.Read(data' 0' 8) != 8) {             throw new CBORException("Premature end of data");           }           // Treat return value as an unsigned integer           long uadditional = ((long)(data[0] & 0xffL)) << 56;           uadditional |= ((long)(data[1] & 0xffL)) << 48;           uadditional |= ((long)(data[2] & 0xffL)) << 40;           uadditional |= ((long)(data[3] & 0xffL)) << 32;           uadditional |= ((long)(data[4] & 0xffL)) << 24;           uadditional |= ((long)(data[5] & 0xffL)) << 16;           uadditional |= ((long)(data[6] & 0xffL)) << 8;           uadditional |= (long)(data[7] & 0xffL);           if (!allowNonShortest && (uadditional >> 32) == 0) {             throw new CBORException("Non-shortest CBOR form");           }           return uadditional;         }         case 28:         case 29:         case 30:           throw new CBORException("Unexpected data encountered");         case 31:           throw new CBORException("Indefinite-length data not allowed" + "\u0020here");         default: return headByte;       }
Magic Number,PeterO.Cbor,CBORReader,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORReader.cs,ReadDataLength,The following statement contains a magic number: switch (headByte) {         case 24: {           int tmp = stream.ReadByte();           if (tmp < 0) {             throw new CBORException("Premature end of data");           }           if (!allowNonShortest && tmp < 24) {             throw new CBORException("Non-shortest CBOR form");           }           return tmp;         }         case 25: {           if (stream.Read(data' 0' 2) != 2) {             throw new CBORException("Premature end of data");           }           int lowAdditional = ((int)(data[0] & (int)0xff)) << 8;           lowAdditional |= (int)(data[1] & (int)0xff);           if (!allowNonShortest && lowAdditional < 256) {             throw new CBORException("Non-shortest CBOR form");           }           return lowAdditional;         }         case 26: {           if (stream.Read(data' 0' 4) != 4) {             throw new CBORException("Premature end of data");           }           long uadditional = ((long)(data[0] & 0xffL)) << 24;           uadditional |= ((long)(data[1] & 0xffL)) << 16;           uadditional |= ((long)(data[2] & 0xffL)) << 8;           uadditional |= (long)(data[3] & 0xffL);           if (!allowNonShortest && (uadditional >> 16) == 0) {             throw new CBORException("Non-shortest CBOR form");           }           return uadditional;         }         case 27: {           if (stream.Read(data' 0' 8) != 8) {             throw new CBORException("Premature end of data");           }           // Treat return value as an unsigned integer           long uadditional = ((long)(data[0] & 0xffL)) << 56;           uadditional |= ((long)(data[1] & 0xffL)) << 48;           uadditional |= ((long)(data[2] & 0xffL)) << 40;           uadditional |= ((long)(data[3] & 0xffL)) << 32;           uadditional |= ((long)(data[4] & 0xffL)) << 24;           uadditional |= ((long)(data[5] & 0xffL)) << 16;           uadditional |= ((long)(data[6] & 0xffL)) << 8;           uadditional |= (long)(data[7] & 0xffL);           if (!allowNonShortest && (uadditional >> 32) == 0) {             throw new CBORException("Non-shortest CBOR form");           }           return uadditional;         }         case 28:         case 29:         case 30:           throw new CBORException("Unexpected data encountered");         case 31:           throw new CBORException("Indefinite-length data not allowed" + "\u0020here");         default: return headByte;       }
Magic Number,PeterO.Cbor,CBORReader,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORReader.cs,ReadDataLength,The following statement contains a magic number: switch (headByte) {         case 24: {           int tmp = stream.ReadByte();           if (tmp < 0) {             throw new CBORException("Premature end of data");           }           if (!allowNonShortest && tmp < 24) {             throw new CBORException("Non-shortest CBOR form");           }           return tmp;         }         case 25: {           if (stream.Read(data' 0' 2) != 2) {             throw new CBORException("Premature end of data");           }           int lowAdditional = ((int)(data[0] & (int)0xff)) << 8;           lowAdditional |= (int)(data[1] & (int)0xff);           if (!allowNonShortest && lowAdditional < 256) {             throw new CBORException("Non-shortest CBOR form");           }           return lowAdditional;         }         case 26: {           if (stream.Read(data' 0' 4) != 4) {             throw new CBORException("Premature end of data");           }           long uadditional = ((long)(data[0] & 0xffL)) << 24;           uadditional |= ((long)(data[1] & 0xffL)) << 16;           uadditional |= ((long)(data[2] & 0xffL)) << 8;           uadditional |= (long)(data[3] & 0xffL);           if (!allowNonShortest && (uadditional >> 16) == 0) {             throw new CBORException("Non-shortest CBOR form");           }           return uadditional;         }         case 27: {           if (stream.Read(data' 0' 8) != 8) {             throw new CBORException("Premature end of data");           }           // Treat return value as an unsigned integer           long uadditional = ((long)(data[0] & 0xffL)) << 56;           uadditional |= ((long)(data[1] & 0xffL)) << 48;           uadditional |= ((long)(data[2] & 0xffL)) << 40;           uadditional |= ((long)(data[3] & 0xffL)) << 32;           uadditional |= ((long)(data[4] & 0xffL)) << 24;           uadditional |= ((long)(data[5] & 0xffL)) << 16;           uadditional |= ((long)(data[6] & 0xffL)) << 8;           uadditional |= (long)(data[7] & 0xffL);           if (!allowNonShortest && (uadditional >> 32) == 0) {             throw new CBORException("Non-shortest CBOR form");           }           return uadditional;         }         case 28:         case 29:         case 30:           throw new CBORException("Unexpected data encountered");         case 31:           throw new CBORException("Indefinite-length data not allowed" + "\u0020here");         default: return headByte;       }
Magic Number,PeterO.Cbor,CBORReader,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORReader.cs,ReadDataLength,The following statement contains a magic number: switch (headByte) {         case 24: {           int tmp = stream.ReadByte();           if (tmp < 0) {             throw new CBORException("Premature end of data");           }           if (!allowNonShortest && tmp < 24) {             throw new CBORException("Non-shortest CBOR form");           }           return tmp;         }         case 25: {           if (stream.Read(data' 0' 2) != 2) {             throw new CBORException("Premature end of data");           }           int lowAdditional = ((int)(data[0] & (int)0xff)) << 8;           lowAdditional |= (int)(data[1] & (int)0xff);           if (!allowNonShortest && lowAdditional < 256) {             throw new CBORException("Non-shortest CBOR form");           }           return lowAdditional;         }         case 26: {           if (stream.Read(data' 0' 4) != 4) {             throw new CBORException("Premature end of data");           }           long uadditional = ((long)(data[0] & 0xffL)) << 24;           uadditional |= ((long)(data[1] & 0xffL)) << 16;           uadditional |= ((long)(data[2] & 0xffL)) << 8;           uadditional |= (long)(data[3] & 0xffL);           if (!allowNonShortest && (uadditional >> 16) == 0) {             throw new CBORException("Non-shortest CBOR form");           }           return uadditional;         }         case 27: {           if (stream.Read(data' 0' 8) != 8) {             throw new CBORException("Premature end of data");           }           // Treat return value as an unsigned integer           long uadditional = ((long)(data[0] & 0xffL)) << 56;           uadditional |= ((long)(data[1] & 0xffL)) << 48;           uadditional |= ((long)(data[2] & 0xffL)) << 40;           uadditional |= ((long)(data[3] & 0xffL)) << 32;           uadditional |= ((long)(data[4] & 0xffL)) << 24;           uadditional |= ((long)(data[5] & 0xffL)) << 16;           uadditional |= ((long)(data[6] & 0xffL)) << 8;           uadditional |= (long)(data[7] & 0xffL);           if (!allowNonShortest && (uadditional >> 32) == 0) {             throw new CBORException("Non-shortest CBOR form");           }           return uadditional;         }         case 28:         case 29:         case 30:           throw new CBORException("Unexpected data encountered");         case 31:           throw new CBORException("Indefinite-length data not allowed" + "\u0020here");         default: return headByte;       }
Magic Number,PeterO.Cbor,CBORReader,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORReader.cs,ReadDataLength,The following statement contains a magic number: switch (headByte) {         case 24: {           int tmp = stream.ReadByte();           if (tmp < 0) {             throw new CBORException("Premature end of data");           }           if (!allowNonShortest && tmp < 24) {             throw new CBORException("Non-shortest CBOR form");           }           return tmp;         }         case 25: {           if (stream.Read(data' 0' 2) != 2) {             throw new CBORException("Premature end of data");           }           int lowAdditional = ((int)(data[0] & (int)0xff)) << 8;           lowAdditional |= (int)(data[1] & (int)0xff);           if (!allowNonShortest && lowAdditional < 256) {             throw new CBORException("Non-shortest CBOR form");           }           return lowAdditional;         }         case 26: {           if (stream.Read(data' 0' 4) != 4) {             throw new CBORException("Premature end of data");           }           long uadditional = ((long)(data[0] & 0xffL)) << 24;           uadditional |= ((long)(data[1] & 0xffL)) << 16;           uadditional |= ((long)(data[2] & 0xffL)) << 8;           uadditional |= (long)(data[3] & 0xffL);           if (!allowNonShortest && (uadditional >> 16) == 0) {             throw new CBORException("Non-shortest CBOR form");           }           return uadditional;         }         case 27: {           if (stream.Read(data' 0' 8) != 8) {             throw new CBORException("Premature end of data");           }           // Treat return value as an unsigned integer           long uadditional = ((long)(data[0] & 0xffL)) << 56;           uadditional |= ((long)(data[1] & 0xffL)) << 48;           uadditional |= ((long)(data[2] & 0xffL)) << 40;           uadditional |= ((long)(data[3] & 0xffL)) << 32;           uadditional |= ((long)(data[4] & 0xffL)) << 24;           uadditional |= ((long)(data[5] & 0xffL)) << 16;           uadditional |= ((long)(data[6] & 0xffL)) << 8;           uadditional |= (long)(data[7] & 0xffL);           if (!allowNonShortest && (uadditional >> 32) == 0) {             throw new CBORException("Non-shortest CBOR form");           }           return uadditional;         }         case 28:         case 29:         case 30:           throw new CBORException("Unexpected data encountered");         case 31:           throw new CBORException("Indefinite-length data not allowed" + "\u0020here");         default: return headByte;       }
Magic Number,PeterO.Cbor,CBORReader,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORReader.cs,ReadDataLength,The following statement contains a magic number: switch (headByte) {         case 24: {           int tmp = stream.ReadByte();           if (tmp < 0) {             throw new CBORException("Premature end of data");           }           if (!allowNonShortest && tmp < 24) {             throw new CBORException("Non-shortest CBOR form");           }           return tmp;         }         case 25: {           if (stream.Read(data' 0' 2) != 2) {             throw new CBORException("Premature end of data");           }           int lowAdditional = ((int)(data[0] & (int)0xff)) << 8;           lowAdditional |= (int)(data[1] & (int)0xff);           if (!allowNonShortest && lowAdditional < 256) {             throw new CBORException("Non-shortest CBOR form");           }           return lowAdditional;         }         case 26: {           if (stream.Read(data' 0' 4) != 4) {             throw new CBORException("Premature end of data");           }           long uadditional = ((long)(data[0] & 0xffL)) << 24;           uadditional |= ((long)(data[1] & 0xffL)) << 16;           uadditional |= ((long)(data[2] & 0xffL)) << 8;           uadditional |= (long)(data[3] & 0xffL);           if (!allowNonShortest && (uadditional >> 16) == 0) {             throw new CBORException("Non-shortest CBOR form");           }           return uadditional;         }         case 27: {           if (stream.Read(data' 0' 8) != 8) {             throw new CBORException("Premature end of data");           }           // Treat return value as an unsigned integer           long uadditional = ((long)(data[0] & 0xffL)) << 56;           uadditional |= ((long)(data[1] & 0xffL)) << 48;           uadditional |= ((long)(data[2] & 0xffL)) << 40;           uadditional |= ((long)(data[3] & 0xffL)) << 32;           uadditional |= ((long)(data[4] & 0xffL)) << 24;           uadditional |= ((long)(data[5] & 0xffL)) << 16;           uadditional |= ((long)(data[6] & 0xffL)) << 8;           uadditional |= (long)(data[7] & 0xffL);           if (!allowNonShortest && (uadditional >> 32) == 0) {             throw new CBORException("Non-shortest CBOR form");           }           return uadditional;         }         case 28:         case 29:         case 30:           throw new CBORException("Unexpected data encountered");         case 31:           throw new CBORException("Indefinite-length data not allowed" + "\u0020here");         default: return headByte;       }
Magic Number,PeterO.Cbor,CBORReader,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORReader.cs,ReadDataLength,The following statement contains a magic number: switch (headByte) {         case 24: {           int tmp = stream.ReadByte();           if (tmp < 0) {             throw new CBORException("Premature end of data");           }           if (!allowNonShortest && tmp < 24) {             throw new CBORException("Non-shortest CBOR form");           }           return tmp;         }         case 25: {           if (stream.Read(data' 0' 2) != 2) {             throw new CBORException("Premature end of data");           }           int lowAdditional = ((int)(data[0] & (int)0xff)) << 8;           lowAdditional |= (int)(data[1] & (int)0xff);           if (!allowNonShortest && lowAdditional < 256) {             throw new CBORException("Non-shortest CBOR form");           }           return lowAdditional;         }         case 26: {           if (stream.Read(data' 0' 4) != 4) {             throw new CBORException("Premature end of data");           }           long uadditional = ((long)(data[0] & 0xffL)) << 24;           uadditional |= ((long)(data[1] & 0xffL)) << 16;           uadditional |= ((long)(data[2] & 0xffL)) << 8;           uadditional |= (long)(data[3] & 0xffL);           if (!allowNonShortest && (uadditional >> 16) == 0) {             throw new CBORException("Non-shortest CBOR form");           }           return uadditional;         }         case 27: {           if (stream.Read(data' 0' 8) != 8) {             throw new CBORException("Premature end of data");           }           // Treat return value as an unsigned integer           long uadditional = ((long)(data[0] & 0xffL)) << 56;           uadditional |= ((long)(data[1] & 0xffL)) << 48;           uadditional |= ((long)(data[2] & 0xffL)) << 40;           uadditional |= ((long)(data[3] & 0xffL)) << 32;           uadditional |= ((long)(data[4] & 0xffL)) << 24;           uadditional |= ((long)(data[5] & 0xffL)) << 16;           uadditional |= ((long)(data[6] & 0xffL)) << 8;           uadditional |= (long)(data[7] & 0xffL);           if (!allowNonShortest && (uadditional >> 32) == 0) {             throw new CBORException("Non-shortest CBOR form");           }           return uadditional;         }         case 28:         case 29:         case 30:           throw new CBORException("Unexpected data encountered");         case 31:           throw new CBORException("Indefinite-length data not allowed" + "\u0020here");         default: return headByte;       }
Magic Number,PeterO.Cbor,CBORReader,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORReader.cs,ReadDataLength,The following statement contains a magic number: switch (headByte) {         case 24: {           int tmp = stream.ReadByte();           if (tmp < 0) {             throw new CBORException("Premature end of data");           }           if (!allowNonShortest && tmp < 24) {             throw new CBORException("Non-shortest CBOR form");           }           return tmp;         }         case 25: {           if (stream.Read(data' 0' 2) != 2) {             throw new CBORException("Premature end of data");           }           int lowAdditional = ((int)(data[0] & (int)0xff)) << 8;           lowAdditional |= (int)(data[1] & (int)0xff);           if (!allowNonShortest && lowAdditional < 256) {             throw new CBORException("Non-shortest CBOR form");           }           return lowAdditional;         }         case 26: {           if (stream.Read(data' 0' 4) != 4) {             throw new CBORException("Premature end of data");           }           long uadditional = ((long)(data[0] & 0xffL)) << 24;           uadditional |= ((long)(data[1] & 0xffL)) << 16;           uadditional |= ((long)(data[2] & 0xffL)) << 8;           uadditional |= (long)(data[3] & 0xffL);           if (!allowNonShortest && (uadditional >> 16) == 0) {             throw new CBORException("Non-shortest CBOR form");           }           return uadditional;         }         case 27: {           if (stream.Read(data' 0' 8) != 8) {             throw new CBORException("Premature end of data");           }           // Treat return value as an unsigned integer           long uadditional = ((long)(data[0] & 0xffL)) << 56;           uadditional |= ((long)(data[1] & 0xffL)) << 48;           uadditional |= ((long)(data[2] & 0xffL)) << 40;           uadditional |= ((long)(data[3] & 0xffL)) << 32;           uadditional |= ((long)(data[4] & 0xffL)) << 24;           uadditional |= ((long)(data[5] & 0xffL)) << 16;           uadditional |= ((long)(data[6] & 0xffL)) << 8;           uadditional |= (long)(data[7] & 0xffL);           if (!allowNonShortest && (uadditional >> 32) == 0) {             throw new CBORException("Non-shortest CBOR form");           }           return uadditional;         }         case 28:         case 29:         case 30:           throw new CBORException("Unexpected data encountered");         case 31:           throw new CBORException("Indefinite-length data not allowed" + "\u0020here");         default: return headByte;       }
Magic Number,PeterO.Cbor,CBORReader,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORReader.cs,ReadDataLength,The following statement contains a magic number: switch (headByte) {         case 24: {           int tmp = stream.ReadByte();           if (tmp < 0) {             throw new CBORException("Premature end of data");           }           if (!allowNonShortest && tmp < 24) {             throw new CBORException("Non-shortest CBOR form");           }           return tmp;         }         case 25: {           if (stream.Read(data' 0' 2) != 2) {             throw new CBORException("Premature end of data");           }           int lowAdditional = ((int)(data[0] & (int)0xff)) << 8;           lowAdditional |= (int)(data[1] & (int)0xff);           if (!allowNonShortest && lowAdditional < 256) {             throw new CBORException("Non-shortest CBOR form");           }           return lowAdditional;         }         case 26: {           if (stream.Read(data' 0' 4) != 4) {             throw new CBORException("Premature end of data");           }           long uadditional = ((long)(data[0] & 0xffL)) << 24;           uadditional |= ((long)(data[1] & 0xffL)) << 16;           uadditional |= ((long)(data[2] & 0xffL)) << 8;           uadditional |= (long)(data[3] & 0xffL);           if (!allowNonShortest && (uadditional >> 16) == 0) {             throw new CBORException("Non-shortest CBOR form");           }           return uadditional;         }         case 27: {           if (stream.Read(data' 0' 8) != 8) {             throw new CBORException("Premature end of data");           }           // Treat return value as an unsigned integer           long uadditional = ((long)(data[0] & 0xffL)) << 56;           uadditional |= ((long)(data[1] & 0xffL)) << 48;           uadditional |= ((long)(data[2] & 0xffL)) << 40;           uadditional |= ((long)(data[3] & 0xffL)) << 32;           uadditional |= ((long)(data[4] & 0xffL)) << 24;           uadditional |= ((long)(data[5] & 0xffL)) << 16;           uadditional |= ((long)(data[6] & 0xffL)) << 8;           uadditional |= (long)(data[7] & 0xffL);           if (!allowNonShortest && (uadditional >> 32) == 0) {             throw new CBORException("Non-shortest CBOR form");           }           return uadditional;         }         case 28:         case 29:         case 30:           throw new CBORException("Unexpected data encountered");         case 31:           throw new CBORException("Indefinite-length data not allowed" + "\u0020here");         default: return headByte;       }
Magic Number,PeterO.Cbor,CBORReader,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORReader.cs,ReadDataLength,The following statement contains a magic number: switch (headByte) {         case 24: {           int tmp = stream.ReadByte();           if (tmp < 0) {             throw new CBORException("Premature end of data");           }           if (!allowNonShortest && tmp < 24) {             throw new CBORException("Non-shortest CBOR form");           }           return tmp;         }         case 25: {           if (stream.Read(data' 0' 2) != 2) {             throw new CBORException("Premature end of data");           }           int lowAdditional = ((int)(data[0] & (int)0xff)) << 8;           lowAdditional |= (int)(data[1] & (int)0xff);           if (!allowNonShortest && lowAdditional < 256) {             throw new CBORException("Non-shortest CBOR form");           }           return lowAdditional;         }         case 26: {           if (stream.Read(data' 0' 4) != 4) {             throw new CBORException("Premature end of data");           }           long uadditional = ((long)(data[0] & 0xffL)) << 24;           uadditional |= ((long)(data[1] & 0xffL)) << 16;           uadditional |= ((long)(data[2] & 0xffL)) << 8;           uadditional |= (long)(data[3] & 0xffL);           if (!allowNonShortest && (uadditional >> 16) == 0) {             throw new CBORException("Non-shortest CBOR form");           }           return uadditional;         }         case 27: {           if (stream.Read(data' 0' 8) != 8) {             throw new CBORException("Premature end of data");           }           // Treat return value as an unsigned integer           long uadditional = ((long)(data[0] & 0xffL)) << 56;           uadditional |= ((long)(data[1] & 0xffL)) << 48;           uadditional |= ((long)(data[2] & 0xffL)) << 40;           uadditional |= ((long)(data[3] & 0xffL)) << 32;           uadditional |= ((long)(data[4] & 0xffL)) << 24;           uadditional |= ((long)(data[5] & 0xffL)) << 16;           uadditional |= ((long)(data[6] & 0xffL)) << 8;           uadditional |= (long)(data[7] & 0xffL);           if (!allowNonShortest && (uadditional >> 32) == 0) {             throw new CBORException("Non-shortest CBOR form");           }           return uadditional;         }         case 28:         case 29:         case 30:           throw new CBORException("Unexpected data encountered");         case 31:           throw new CBORException("Indefinite-length data not allowed" + "\u0020here");         default: return headByte;       }
Magic Number,PeterO.Cbor,CBORReader,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORReader.cs,ReadDataLength,The following statement contains a magic number: switch (headByte) {         case 24: {           int tmp = stream.ReadByte();           if (tmp < 0) {             throw new CBORException("Premature end of data");           }           if (!allowNonShortest && tmp < 24) {             throw new CBORException("Non-shortest CBOR form");           }           return tmp;         }         case 25: {           if (stream.Read(data' 0' 2) != 2) {             throw new CBORException("Premature end of data");           }           int lowAdditional = ((int)(data[0] & (int)0xff)) << 8;           lowAdditional |= (int)(data[1] & (int)0xff);           if (!allowNonShortest && lowAdditional < 256) {             throw new CBORException("Non-shortest CBOR form");           }           return lowAdditional;         }         case 26: {           if (stream.Read(data' 0' 4) != 4) {             throw new CBORException("Premature end of data");           }           long uadditional = ((long)(data[0] & 0xffL)) << 24;           uadditional |= ((long)(data[1] & 0xffL)) << 16;           uadditional |= ((long)(data[2] & 0xffL)) << 8;           uadditional |= (long)(data[3] & 0xffL);           if (!allowNonShortest && (uadditional >> 16) == 0) {             throw new CBORException("Non-shortest CBOR form");           }           return uadditional;         }         case 27: {           if (stream.Read(data' 0' 8) != 8) {             throw new CBORException("Premature end of data");           }           // Treat return value as an unsigned integer           long uadditional = ((long)(data[0] & 0xffL)) << 56;           uadditional |= ((long)(data[1] & 0xffL)) << 48;           uadditional |= ((long)(data[2] & 0xffL)) << 40;           uadditional |= ((long)(data[3] & 0xffL)) << 32;           uadditional |= ((long)(data[4] & 0xffL)) << 24;           uadditional |= ((long)(data[5] & 0xffL)) << 16;           uadditional |= ((long)(data[6] & 0xffL)) << 8;           uadditional |= (long)(data[7] & 0xffL);           if (!allowNonShortest && (uadditional >> 32) == 0) {             throw new CBORException("Non-shortest CBOR form");           }           return uadditional;         }         case 28:         case 29:         case 30:           throw new CBORException("Unexpected data encountered");         case 31:           throw new CBORException("Indefinite-length data not allowed" + "\u0020here");         default: return headByte;       }
Magic Number,PeterO.Cbor,CBORReader,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORReader.cs,ReadDataLength,The following statement contains a magic number: switch (headByte) {         case 24: {           int tmp = stream.ReadByte();           if (tmp < 0) {             throw new CBORException("Premature end of data");           }           if (!allowNonShortest && tmp < 24) {             throw new CBORException("Non-shortest CBOR form");           }           return tmp;         }         case 25: {           if (stream.Read(data' 0' 2) != 2) {             throw new CBORException("Premature end of data");           }           int lowAdditional = ((int)(data[0] & (int)0xff)) << 8;           lowAdditional |= (int)(data[1] & (int)0xff);           if (!allowNonShortest && lowAdditional < 256) {             throw new CBORException("Non-shortest CBOR form");           }           return lowAdditional;         }         case 26: {           if (stream.Read(data' 0' 4) != 4) {             throw new CBORException("Premature end of data");           }           long uadditional = ((long)(data[0] & 0xffL)) << 24;           uadditional |= ((long)(data[1] & 0xffL)) << 16;           uadditional |= ((long)(data[2] & 0xffL)) << 8;           uadditional |= (long)(data[3] & 0xffL);           if (!allowNonShortest && (uadditional >> 16) == 0) {             throw new CBORException("Non-shortest CBOR form");           }           return uadditional;         }         case 27: {           if (stream.Read(data' 0' 8) != 8) {             throw new CBORException("Premature end of data");           }           // Treat return value as an unsigned integer           long uadditional = ((long)(data[0] & 0xffL)) << 56;           uadditional |= ((long)(data[1] & 0xffL)) << 48;           uadditional |= ((long)(data[2] & 0xffL)) << 40;           uadditional |= ((long)(data[3] & 0xffL)) << 32;           uadditional |= ((long)(data[4] & 0xffL)) << 24;           uadditional |= ((long)(data[5] & 0xffL)) << 16;           uadditional |= ((long)(data[6] & 0xffL)) << 8;           uadditional |= (long)(data[7] & 0xffL);           if (!allowNonShortest && (uadditional >> 32) == 0) {             throw new CBORException("Non-shortest CBOR form");           }           return uadditional;         }         case 28:         case 29:         case 30:           throw new CBORException("Unexpected data encountered");         case 31:           throw new CBORException("Indefinite-length data not allowed" + "\u0020here");         default: return headByte;       }
Magic Number,PeterO.Cbor,CBORReader,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORReader.cs,ReadDataLength,The following statement contains a magic number: switch (headByte) {         case 24: {           int tmp = stream.ReadByte();           if (tmp < 0) {             throw new CBORException("Premature end of data");           }           if (!allowNonShortest && tmp < 24) {             throw new CBORException("Non-shortest CBOR form");           }           return tmp;         }         case 25: {           if (stream.Read(data' 0' 2) != 2) {             throw new CBORException("Premature end of data");           }           int lowAdditional = ((int)(data[0] & (int)0xff)) << 8;           lowAdditional |= (int)(data[1] & (int)0xff);           if (!allowNonShortest && lowAdditional < 256) {             throw new CBORException("Non-shortest CBOR form");           }           return lowAdditional;         }         case 26: {           if (stream.Read(data' 0' 4) != 4) {             throw new CBORException("Premature end of data");           }           long uadditional = ((long)(data[0] & 0xffL)) << 24;           uadditional |= ((long)(data[1] & 0xffL)) << 16;           uadditional |= ((long)(data[2] & 0xffL)) << 8;           uadditional |= (long)(data[3] & 0xffL);           if (!allowNonShortest && (uadditional >> 16) == 0) {             throw new CBORException("Non-shortest CBOR form");           }           return uadditional;         }         case 27: {           if (stream.Read(data' 0' 8) != 8) {             throw new CBORException("Premature end of data");           }           // Treat return value as an unsigned integer           long uadditional = ((long)(data[0] & 0xffL)) << 56;           uadditional |= ((long)(data[1] & 0xffL)) << 48;           uadditional |= ((long)(data[2] & 0xffL)) << 40;           uadditional |= ((long)(data[3] & 0xffL)) << 32;           uadditional |= ((long)(data[4] & 0xffL)) << 24;           uadditional |= ((long)(data[5] & 0xffL)) << 16;           uadditional |= ((long)(data[6] & 0xffL)) << 8;           uadditional |= (long)(data[7] & 0xffL);           if (!allowNonShortest && (uadditional >> 32) == 0) {             throw new CBORException("Non-shortest CBOR form");           }           return uadditional;         }         case 28:         case 29:         case 30:           throw new CBORException("Unexpected data encountered");         case 31:           throw new CBORException("Indefinite-length data not allowed" + "\u0020here");         default: return headByte;       }
Magic Number,PeterO.Cbor,CBORReader,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORReader.cs,ReadDataLength,The following statement contains a magic number: switch (headByte) {         case 24: {           int tmp = stream.ReadByte();           if (tmp < 0) {             throw new CBORException("Premature end of data");           }           if (!allowNonShortest && tmp < 24) {             throw new CBORException("Non-shortest CBOR form");           }           return tmp;         }         case 25: {           if (stream.Read(data' 0' 2) != 2) {             throw new CBORException("Premature end of data");           }           int lowAdditional = ((int)(data[0] & (int)0xff)) << 8;           lowAdditional |= (int)(data[1] & (int)0xff);           if (!allowNonShortest && lowAdditional < 256) {             throw new CBORException("Non-shortest CBOR form");           }           return lowAdditional;         }         case 26: {           if (stream.Read(data' 0' 4) != 4) {             throw new CBORException("Premature end of data");           }           long uadditional = ((long)(data[0] & 0xffL)) << 24;           uadditional |= ((long)(data[1] & 0xffL)) << 16;           uadditional |= ((long)(data[2] & 0xffL)) << 8;           uadditional |= (long)(data[3] & 0xffL);           if (!allowNonShortest && (uadditional >> 16) == 0) {             throw new CBORException("Non-shortest CBOR form");           }           return uadditional;         }         case 27: {           if (stream.Read(data' 0' 8) != 8) {             throw new CBORException("Premature end of data");           }           // Treat return value as an unsigned integer           long uadditional = ((long)(data[0] & 0xffL)) << 56;           uadditional |= ((long)(data[1] & 0xffL)) << 48;           uadditional |= ((long)(data[2] & 0xffL)) << 40;           uadditional |= ((long)(data[3] & 0xffL)) << 32;           uadditional |= ((long)(data[4] & 0xffL)) << 24;           uadditional |= ((long)(data[5] & 0xffL)) << 16;           uadditional |= ((long)(data[6] & 0xffL)) << 8;           uadditional |= (long)(data[7] & 0xffL);           if (!allowNonShortest && (uadditional >> 32) == 0) {             throw new CBORException("Non-shortest CBOR form");           }           return uadditional;         }         case 28:         case 29:         case 30:           throw new CBORException("Unexpected data encountered");         case 31:           throw new CBORException("Indefinite-length data not allowed" + "\u0020here");         default: return headByte;       }
Magic Number,PeterO.Cbor,CBORReader,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORReader.cs,ReadDataLength,The following statement contains a magic number: switch (headByte) {         case 24: {           int tmp = stream.ReadByte();           if (tmp < 0) {             throw new CBORException("Premature end of data");           }           if (!allowNonShortest && tmp < 24) {             throw new CBORException("Non-shortest CBOR form");           }           return tmp;         }         case 25: {           if (stream.Read(data' 0' 2) != 2) {             throw new CBORException("Premature end of data");           }           int lowAdditional = ((int)(data[0] & (int)0xff)) << 8;           lowAdditional |= (int)(data[1] & (int)0xff);           if (!allowNonShortest && lowAdditional < 256) {             throw new CBORException("Non-shortest CBOR form");           }           return lowAdditional;         }         case 26: {           if (stream.Read(data' 0' 4) != 4) {             throw new CBORException("Premature end of data");           }           long uadditional = ((long)(data[0] & 0xffL)) << 24;           uadditional |= ((long)(data[1] & 0xffL)) << 16;           uadditional |= ((long)(data[2] & 0xffL)) << 8;           uadditional |= (long)(data[3] & 0xffL);           if (!allowNonShortest && (uadditional >> 16) == 0) {             throw new CBORException("Non-shortest CBOR form");           }           return uadditional;         }         case 27: {           if (stream.Read(data' 0' 8) != 8) {             throw new CBORException("Premature end of data");           }           // Treat return value as an unsigned integer           long uadditional = ((long)(data[0] & 0xffL)) << 56;           uadditional |= ((long)(data[1] & 0xffL)) << 48;           uadditional |= ((long)(data[2] & 0xffL)) << 40;           uadditional |= ((long)(data[3] & 0xffL)) << 32;           uadditional |= ((long)(data[4] & 0xffL)) << 24;           uadditional |= ((long)(data[5] & 0xffL)) << 16;           uadditional |= ((long)(data[6] & 0xffL)) << 8;           uadditional |= (long)(data[7] & 0xffL);           if (!allowNonShortest && (uadditional >> 32) == 0) {             throw new CBORException("Non-shortest CBOR form");           }           return uadditional;         }         case 28:         case 29:         case 30:           throw new CBORException("Unexpected data encountered");         case 31:           throw new CBORException("Indefinite-length data not allowed" + "\u0020here");         default: return headByte;       }
Magic Number,PeterO.Cbor,CBORReader,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORReader.cs,ReadDataLength,The following statement contains a magic number: switch (headByte) {         case 24: {           int tmp = stream.ReadByte();           if (tmp < 0) {             throw new CBORException("Premature end of data");           }           if (!allowNonShortest && tmp < 24) {             throw new CBORException("Non-shortest CBOR form");           }           return tmp;         }         case 25: {           if (stream.Read(data' 0' 2) != 2) {             throw new CBORException("Premature end of data");           }           int lowAdditional = ((int)(data[0] & (int)0xff)) << 8;           lowAdditional |= (int)(data[1] & (int)0xff);           if (!allowNonShortest && lowAdditional < 256) {             throw new CBORException("Non-shortest CBOR form");           }           return lowAdditional;         }         case 26: {           if (stream.Read(data' 0' 4) != 4) {             throw new CBORException("Premature end of data");           }           long uadditional = ((long)(data[0] & 0xffL)) << 24;           uadditional |= ((long)(data[1] & 0xffL)) << 16;           uadditional |= ((long)(data[2] & 0xffL)) << 8;           uadditional |= (long)(data[3] & 0xffL);           if (!allowNonShortest && (uadditional >> 16) == 0) {             throw new CBORException("Non-shortest CBOR form");           }           return uadditional;         }         case 27: {           if (stream.Read(data' 0' 8) != 8) {             throw new CBORException("Premature end of data");           }           // Treat return value as an unsigned integer           long uadditional = ((long)(data[0] & 0xffL)) << 56;           uadditional |= ((long)(data[1] & 0xffL)) << 48;           uadditional |= ((long)(data[2] & 0xffL)) << 40;           uadditional |= ((long)(data[3] & 0xffL)) << 32;           uadditional |= ((long)(data[4] & 0xffL)) << 24;           uadditional |= ((long)(data[5] & 0xffL)) << 16;           uadditional |= ((long)(data[6] & 0xffL)) << 8;           uadditional |= (long)(data[7] & 0xffL);           if (!allowNonShortest && (uadditional >> 32) == 0) {             throw new CBORException("Non-shortest CBOR form");           }           return uadditional;         }         case 28:         case 29:         case 30:           throw new CBORException("Unexpected data encountered");         case 31:           throw new CBORException("Indefinite-length data not allowed" + "\u0020here");         default: return headByte;       }
Magic Number,PeterO.Cbor,CBORReader,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORReader.cs,ReadDataLength,The following statement contains a magic number: switch (headByte) {         case 24: {           int tmp = stream.ReadByte();           if (tmp < 0) {             throw new CBORException("Premature end of data");           }           if (!allowNonShortest && tmp < 24) {             throw new CBORException("Non-shortest CBOR form");           }           return tmp;         }         case 25: {           if (stream.Read(data' 0' 2) != 2) {             throw new CBORException("Premature end of data");           }           int lowAdditional = ((int)(data[0] & (int)0xff)) << 8;           lowAdditional |= (int)(data[1] & (int)0xff);           if (!allowNonShortest && lowAdditional < 256) {             throw new CBORException("Non-shortest CBOR form");           }           return lowAdditional;         }         case 26: {           if (stream.Read(data' 0' 4) != 4) {             throw new CBORException("Premature end of data");           }           long uadditional = ((long)(data[0] & 0xffL)) << 24;           uadditional |= ((long)(data[1] & 0xffL)) << 16;           uadditional |= ((long)(data[2] & 0xffL)) << 8;           uadditional |= (long)(data[3] & 0xffL);           if (!allowNonShortest && (uadditional >> 16) == 0) {             throw new CBORException("Non-shortest CBOR form");           }           return uadditional;         }         case 27: {           if (stream.Read(data' 0' 8) != 8) {             throw new CBORException("Premature end of data");           }           // Treat return value as an unsigned integer           long uadditional = ((long)(data[0] & 0xffL)) << 56;           uadditional |= ((long)(data[1] & 0xffL)) << 48;           uadditional |= ((long)(data[2] & 0xffL)) << 40;           uadditional |= ((long)(data[3] & 0xffL)) << 32;           uadditional |= ((long)(data[4] & 0xffL)) << 24;           uadditional |= ((long)(data[5] & 0xffL)) << 16;           uadditional |= ((long)(data[6] & 0xffL)) << 8;           uadditional |= (long)(data[7] & 0xffL);           if (!allowNonShortest && (uadditional >> 32) == 0) {             throw new CBORException("Non-shortest CBOR form");           }           return uadditional;         }         case 28:         case 29:         case 30:           throw new CBORException("Unexpected data encountered");         case 31:           throw new CBORException("Indefinite-length data not allowed" + "\u0020here");         default: return headByte;       }
Magic Number,PeterO.Cbor,CBORReader,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORReader.cs,ReadDataLength,The following statement contains a magic number: switch (headByte) {         case 24: {           int tmp = stream.ReadByte();           if (tmp < 0) {             throw new CBORException("Premature end of data");           }           if (!allowNonShortest && tmp < 24) {             throw new CBORException("Non-shortest CBOR form");           }           return tmp;         }         case 25: {           if (stream.Read(data' 0' 2) != 2) {             throw new CBORException("Premature end of data");           }           int lowAdditional = ((int)(data[0] & (int)0xff)) << 8;           lowAdditional |= (int)(data[1] & (int)0xff);           if (!allowNonShortest && lowAdditional < 256) {             throw new CBORException("Non-shortest CBOR form");           }           return lowAdditional;         }         case 26: {           if (stream.Read(data' 0' 4) != 4) {             throw new CBORException("Premature end of data");           }           long uadditional = ((long)(data[0] & 0xffL)) << 24;           uadditional |= ((long)(data[1] & 0xffL)) << 16;           uadditional |= ((long)(data[2] & 0xffL)) << 8;           uadditional |= (long)(data[3] & 0xffL);           if (!allowNonShortest && (uadditional >> 16) == 0) {             throw new CBORException("Non-shortest CBOR form");           }           return uadditional;         }         case 27: {           if (stream.Read(data' 0' 8) != 8) {             throw new CBORException("Premature end of data");           }           // Treat return value as an unsigned integer           long uadditional = ((long)(data[0] & 0xffL)) << 56;           uadditional |= ((long)(data[1] & 0xffL)) << 48;           uadditional |= ((long)(data[2] & 0xffL)) << 40;           uadditional |= ((long)(data[3] & 0xffL)) << 32;           uadditional |= ((long)(data[4] & 0xffL)) << 24;           uadditional |= ((long)(data[5] & 0xffL)) << 16;           uadditional |= ((long)(data[6] & 0xffL)) << 8;           uadditional |= (long)(data[7] & 0xffL);           if (!allowNonShortest && (uadditional >> 32) == 0) {             throw new CBORException("Non-shortest CBOR form");           }           return uadditional;         }         case 28:         case 29:         case 30:           throw new CBORException("Unexpected data encountered");         case 31:           throw new CBORException("Indefinite-length data not allowed" + "\u0020here");         default: return headByte;       }
Magic Number,PeterO.Cbor,CBORReader,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORReader.cs,ReadDataLength,The following statement contains a magic number: switch (headByte) {         case 24: {           int tmp = stream.ReadByte();           if (tmp < 0) {             throw new CBORException("Premature end of data");           }           if (!allowNonShortest && tmp < 24) {             throw new CBORException("Non-shortest CBOR form");           }           return tmp;         }         case 25: {           if (stream.Read(data' 0' 2) != 2) {             throw new CBORException("Premature end of data");           }           int lowAdditional = ((int)(data[0] & (int)0xff)) << 8;           lowAdditional |= (int)(data[1] & (int)0xff);           if (!allowNonShortest && lowAdditional < 256) {             throw new CBORException("Non-shortest CBOR form");           }           return lowAdditional;         }         case 26: {           if (stream.Read(data' 0' 4) != 4) {             throw new CBORException("Premature end of data");           }           long uadditional = ((long)(data[0] & 0xffL)) << 24;           uadditional |= ((long)(data[1] & 0xffL)) << 16;           uadditional |= ((long)(data[2] & 0xffL)) << 8;           uadditional |= (long)(data[3] & 0xffL);           if (!allowNonShortest && (uadditional >> 16) == 0) {             throw new CBORException("Non-shortest CBOR form");           }           return uadditional;         }         case 27: {           if (stream.Read(data' 0' 8) != 8) {             throw new CBORException("Premature end of data");           }           // Treat return value as an unsigned integer           long uadditional = ((long)(data[0] & 0xffL)) << 56;           uadditional |= ((long)(data[1] & 0xffL)) << 48;           uadditional |= ((long)(data[2] & 0xffL)) << 40;           uadditional |= ((long)(data[3] & 0xffL)) << 32;           uadditional |= ((long)(data[4] & 0xffL)) << 24;           uadditional |= ((long)(data[5] & 0xffL)) << 16;           uadditional |= ((long)(data[6] & 0xffL)) << 8;           uadditional |= (long)(data[7] & 0xffL);           if (!allowNonShortest && (uadditional >> 32) == 0) {             throw new CBORException("Non-shortest CBOR form");           }           return uadditional;         }         case 28:         case 29:         case 30:           throw new CBORException("Unexpected data encountered");         case 31:           throw new CBORException("Indefinite-length data not allowed" + "\u0020here");         default: return headByte;       }
Magic Number,PeterO.Cbor,CBORReader,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORReader.cs,ReadDataLength,The following statement contains a magic number: switch (headByte) {         case 24: {           int tmp = stream.ReadByte();           if (tmp < 0) {             throw new CBORException("Premature end of data");           }           if (!allowNonShortest && tmp < 24) {             throw new CBORException("Non-shortest CBOR form");           }           return tmp;         }         case 25: {           if (stream.Read(data' 0' 2) != 2) {             throw new CBORException("Premature end of data");           }           int lowAdditional = ((int)(data[0] & (int)0xff)) << 8;           lowAdditional |= (int)(data[1] & (int)0xff);           if (!allowNonShortest && lowAdditional < 256) {             throw new CBORException("Non-shortest CBOR form");           }           return lowAdditional;         }         case 26: {           if (stream.Read(data' 0' 4) != 4) {             throw new CBORException("Premature end of data");           }           long uadditional = ((long)(data[0] & 0xffL)) << 24;           uadditional |= ((long)(data[1] & 0xffL)) << 16;           uadditional |= ((long)(data[2] & 0xffL)) << 8;           uadditional |= (long)(data[3] & 0xffL);           if (!allowNonShortest && (uadditional >> 16) == 0) {             throw new CBORException("Non-shortest CBOR form");           }           return uadditional;         }         case 27: {           if (stream.Read(data' 0' 8) != 8) {             throw new CBORException("Premature end of data");           }           // Treat return value as an unsigned integer           long uadditional = ((long)(data[0] & 0xffL)) << 56;           uadditional |= ((long)(data[1] & 0xffL)) << 48;           uadditional |= ((long)(data[2] & 0xffL)) << 40;           uadditional |= ((long)(data[3] & 0xffL)) << 32;           uadditional |= ((long)(data[4] & 0xffL)) << 24;           uadditional |= ((long)(data[5] & 0xffL)) << 16;           uadditional |= ((long)(data[6] & 0xffL)) << 8;           uadditional |= (long)(data[7] & 0xffL);           if (!allowNonShortest && (uadditional >> 32) == 0) {             throw new CBORException("Non-shortest CBOR form");           }           return uadditional;         }         case 28:         case 29:         case 30:           throw new CBORException("Unexpected data encountered");         case 31:           throw new CBORException("Indefinite-length data not allowed" + "\u0020here");         default: return headByte;       }
Magic Number,PeterO.Cbor,CBORReader,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORReader.cs,ReadDataLength,The following statement contains a magic number: switch (headByte) {         case 24: {           int tmp = stream.ReadByte();           if (tmp < 0) {             throw new CBORException("Premature end of data");           }           if (!allowNonShortest && tmp < 24) {             throw new CBORException("Non-shortest CBOR form");           }           return tmp;         }         case 25: {           if (stream.Read(data' 0' 2) != 2) {             throw new CBORException("Premature end of data");           }           int lowAdditional = ((int)(data[0] & (int)0xff)) << 8;           lowAdditional |= (int)(data[1] & (int)0xff);           if (!allowNonShortest && lowAdditional < 256) {             throw new CBORException("Non-shortest CBOR form");           }           return lowAdditional;         }         case 26: {           if (stream.Read(data' 0' 4) != 4) {             throw new CBORException("Premature end of data");           }           long uadditional = ((long)(data[0] & 0xffL)) << 24;           uadditional |= ((long)(data[1] & 0xffL)) << 16;           uadditional |= ((long)(data[2] & 0xffL)) << 8;           uadditional |= (long)(data[3] & 0xffL);           if (!allowNonShortest && (uadditional >> 16) == 0) {             throw new CBORException("Non-shortest CBOR form");           }           return uadditional;         }         case 27: {           if (stream.Read(data' 0' 8) != 8) {             throw new CBORException("Premature end of data");           }           // Treat return value as an unsigned integer           long uadditional = ((long)(data[0] & 0xffL)) << 56;           uadditional |= ((long)(data[1] & 0xffL)) << 48;           uadditional |= ((long)(data[2] & 0xffL)) << 40;           uadditional |= ((long)(data[3] & 0xffL)) << 32;           uadditional |= ((long)(data[4] & 0xffL)) << 24;           uadditional |= ((long)(data[5] & 0xffL)) << 16;           uadditional |= ((long)(data[6] & 0xffL)) << 8;           uadditional |= (long)(data[7] & 0xffL);           if (!allowNonShortest && (uadditional >> 32) == 0) {             throw new CBORException("Non-shortest CBOR form");           }           return uadditional;         }         case 28:         case 29:         case 30:           throw new CBORException("Unexpected data encountered");         case 31:           throw new CBORException("Indefinite-length data not allowed" + "\u0020here");         default: return headByte;       }
Magic Number,PeterO.Cbor,CBORUriConverter,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORUriConverter.cs,ValidateObject,The following statement contains a magic number: bool isiri = obj.HasMostOuterTag(266);
Magic Number,PeterO.Cbor,CBORUriConverter,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORUriConverter.cs,ValidateObject,The following statement contains a magic number: bool isiriref = obj.HasMostOuterTag(267);
Magic Number,PeterO.Cbor,CBORUriConverter,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORUriConverter.cs,FromCBORObject,The following statement contains a magic number: obj.HasMostOuterTag(32) ||              obj.HasMostOuterTag(266) ||              obj.HasMostOuterTag(267)
Magic Number,PeterO.Cbor,CBORUriConverter,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORUriConverter.cs,FromCBORObject,The following statement contains a magic number: obj.HasMostOuterTag(32) ||              obj.HasMostOuterTag(266) ||              obj.HasMostOuterTag(267)
Magic Number,PeterO.Cbor,CBORUriConverter,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORUriConverter.cs,FromCBORObject,The following statement contains a magic number: obj.HasMostOuterTag(32) ||              obj.HasMostOuterTag(266) ||              obj.HasMostOuterTag(267)
Magic Number,PeterO.Cbor,CBORUriConverter,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORUriConverter.cs,ToCBORObject,The following statement contains a magic number: int tag = nonascii ? 266 : 32;
Magic Number,PeterO.Cbor,CBORUriConverter,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORUriConverter.cs,ToCBORObject,The following statement contains a magic number: int tag = nonascii ? 266 : 32;
Magic Number,PeterO.Cbor,CBORUriConverter,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORUriConverter.cs,ToCBORObject,The following statement contains a magic number: tag = 267;
Magic Number,PeterO.Cbor,CBORUtilities,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORUtilities.cs,FastPathStringCompare,The following statement contains a magic number: return -2;
Magic Number,PeterO.Cbor,CBORUtilities,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORUtilities.cs,FastPathStringCompare,The following statement contains a magic number: return -2;
Magic Number,PeterO.Cbor,CBORUtilities,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORUtilities.cs,FastPathStringCompare,The following statement contains a magic number: strA.Length < 64 && strB.Length < 64
Magic Number,PeterO.Cbor,CBORUtilities,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORUtilities.cs,FastPathStringCompare,The following statement contains a magic number: strA.Length < 64 && strB.Length < 64
Magic Number,PeterO.Cbor,CBORUtilities,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORUtilities.cs,FastPathStringCompare,The following statement contains a magic number: return -2;
Magic Number,PeterO.Cbor,CBORUtilities,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORUtilities.cs,ByteArrayHashCode,The following statement contains a magic number: var ret = 19;
Magic Number,PeterO.Cbor,CBORUtilities,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORUtilities.cs,ByteArrayHashCode,The following statement contains a magic number: ret = (ret * 31) + a.Length;
Magic Number,PeterO.Cbor,CBORUtilities,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORUtilities.cs,ByteArrayHashCode,The following statement contains a magic number: ret = (ret * 31) + a[i];
Magic Number,PeterO.Cbor,CBORUtilities,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORUtilities.cs,TrimDotZero,The following statement contains a magic number: return (str.Length > 2 && str[str.Length - 1] == '0' && str[str.Length             - 2] == '.') ? str.Substring(0' str.Length - 2) :         str;
Magic Number,PeterO.Cbor,CBORUtilities,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORUtilities.cs,TrimDotZero,The following statement contains a magic number: return (str.Length > 2 && str[str.Length - 1] == '0' && str[str.Length             - 2] == '.') ? str.Substring(0' str.Length - 2) :         str;
Magic Number,PeterO.Cbor,CBORUtilities,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORUtilities.cs,TrimDotZero,The following statement contains a magic number: return (str.Length > 2 && str[str.Length - 1] == '0' && str[str.Length             - 2] == '.') ? str.Substring(0' str.Length - 2) :         str;
Magic Number,PeterO.Cbor,CBORUtilities,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORUtilities.cs,LongToString,The following statement contains a magic number: chars = new char[12];
Magic Number,PeterO.Cbor,CBORUtilities,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORUtilities.cs,LongToString,The following statement contains a magic number: count = 11;
Magic Number,PeterO.Cbor,CBORUtilities,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORUtilities.cs,LongToString,The following statement contains a magic number: int intdivValue = intlongValue / 10;
Magic Number,PeterO.Cbor,CBORUtilities,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORUtilities.cs,LongToString,The following statement contains a magic number: char digit = HexAlphabet[(int)(intlongValue - (intdivValue *                   10))];
Magic Number,PeterO.Cbor,CBORUtilities,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORUtilities.cs,LongToString,The following statement contains a magic number: intlongValue > 43698
Magic Number,PeterO.Cbor,CBORUtilities,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORUtilities.cs,LongToString,The following statement contains a magic number: int intdivValue = (intlongValue * 26215) >> 18;
Magic Number,PeterO.Cbor,CBORUtilities,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORUtilities.cs,LongToString,The following statement contains a magic number: int intdivValue = (intlongValue * 26215) >> 18;
Magic Number,PeterO.Cbor,CBORUtilities,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORUtilities.cs,LongToString,The following statement contains a magic number: char digit = HexAlphabet[(int)(intlongValue - (intdivValue *                   10))];
Magic Number,PeterO.Cbor,CBORUtilities,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORUtilities.cs,LongToString,The following statement contains a magic number: intlongValue > 9
Magic Number,PeterO.Cbor,CBORUtilities,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORUtilities.cs,LongToString,The following statement contains a magic number: return new String(chars' count' 12 - count);
Magic Number,PeterO.Cbor,CBORUtilities,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORUtilities.cs,GetNormalizedPartProlepticGregorian,The following statement contains a magic number: month <= 0 || month > 12
Magic Number,PeterO.Cbor,CBORUtilities,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORUtilities.cs,GetNormalizedPartProlepticGregorian,The following statement contains a magic number: int[] dayArray = (year.Remainder(4).Sign != 0 || (             year.Remainder(100).Sign == 0 && year.Remainder(400).Sign != 0)) ?         ValueNormalDays : ValueLeapDays;
Magic Number,PeterO.Cbor,CBORUtilities,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORUtilities.cs,GetNormalizedPartProlepticGregorian,The following statement contains a magic number: int[] dayArray = (year.Remainder(4).Sign != 0 || (             year.Remainder(100).Sign == 0 && year.Remainder(400).Sign != 0)) ?         ValueNormalDays : ValueLeapDays;
Magic Number,PeterO.Cbor,CBORUtilities,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORUtilities.cs,GetNormalizedPartProlepticGregorian,The following statement contains a magic number: int[] dayArray = (year.Remainder(4).Sign != 0 || (             year.Remainder(100).Sign == 0 && year.Remainder(400).Sign != 0)) ?         ValueNormalDays : ValueLeapDays;
Magic Number,PeterO.Cbor,CBORUtilities,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORUtilities.cs,GetNormalizedPartProlepticGregorian,The following statement contains a magic number: EInteger count = day.Subtract(100).Divide(146097);
Magic Number,PeterO.Cbor,CBORUtilities,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORUtilities.cs,GetNormalizedPartProlepticGregorian,The following statement contains a magic number: EInteger count = day.Subtract(100).Divide(146097);
Magic Number,PeterO.Cbor,CBORUtilities,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORUtilities.cs,GetNormalizedPartProlepticGregorian,The following statement contains a magic number: day = day.Subtract(count.Multiply(146097));
Magic Number,PeterO.Cbor,CBORUtilities,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORUtilities.cs,GetNormalizedPartProlepticGregorian,The following statement contains a magic number: year = year.Add(count.Multiply(400));
Magic Number,PeterO.Cbor,CBORUtilities,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORUtilities.cs,GetNormalizedPartProlepticGregorian,The following statement contains a magic number: day.CompareTo(101) > 0
Magic Number,PeterO.Cbor,CBORUtilities,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORUtilities.cs,GetNormalizedPartProlepticGregorian,The following statement contains a magic number: dayArray = (year.Remainder(4).Sign != 0 || (                   year.Remainder(100).Sign == 0 &&                   year.Remainder(400).Sign != 0)) ? ValueNormalDays :               ValueLeapDays;
Magic Number,PeterO.Cbor,CBORUtilities,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORUtilities.cs,GetNormalizedPartProlepticGregorian,The following statement contains a magic number: dayArray = (year.Remainder(4).Sign != 0 || (                   year.Remainder(100).Sign == 0 &&                   year.Remainder(400).Sign != 0)) ? ValueNormalDays :               ValueLeapDays;
Magic Number,PeterO.Cbor,CBORUtilities,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORUtilities.cs,GetNormalizedPartProlepticGregorian,The following statement contains a magic number: dayArray = (year.Remainder(4).Sign != 0 || (                   year.Remainder(100).Sign == 0 &&                   year.Remainder(400).Sign != 0)) ? ValueNormalDays :               ValueLeapDays;
Magic Number,PeterO.Cbor,CBORUtilities,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORUtilities.cs,GetNormalizedPartProlepticGregorian,The following statement contains a magic number: month == 12
Magic Number,PeterO.Cbor,CBORUtilities,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORUtilities.cs,GetNormalizedPartProlepticGregorian,The following statement contains a magic number: month = 12;
Magic Number,PeterO.Cbor,CBORUtilities,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORUtilities.cs,GetNormalizedPartProlepticGregorian,The following statement contains a magic number: dayArray = (year.Remainder(4).Sign != 0 || (                 year.Remainder(100).Sign == 0 &&                 year.Remainder(400).Sign != 0)) ? ValueNormalDays :             ValueLeapDays;
Magic Number,PeterO.Cbor,CBORUtilities,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORUtilities.cs,GetNormalizedPartProlepticGregorian,The following statement contains a magic number: dayArray = (year.Remainder(4).Sign != 0 || (                 year.Remainder(100).Sign == 0 &&                 year.Remainder(400).Sign != 0)) ? ValueNormalDays :             ValueLeapDays;
Magic Number,PeterO.Cbor,CBORUtilities,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORUtilities.cs,GetNormalizedPartProlepticGregorian,The following statement contains a magic number: dayArray = (year.Remainder(4).Sign != 0 || (                 year.Remainder(100).Sign == 0 &&                 year.Remainder(400).Sign != 0)) ? ValueNormalDays :             ValueLeapDays;
Magic Number,PeterO.Cbor,CBORUtilities,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORUtilities.cs,GetNormalizedPartProlepticGregorian,The following statement contains a magic number: dest[2] = day;
Magic Number,PeterO.Cbor,CBORUtilities,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORUtilities.cs,GetNumberOfDaysProlepticGregorian,The following statement contains a magic number: month <= 0 || month > 12
Magic Number,PeterO.Cbor,CBORUtilities,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORUtilities.cs,GetNumberOfDaysProlepticGregorian,The following statement contains a magic number: mday <= 0 || mday > 31
Magic Number,PeterO.Cbor,CBORUtilities,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORUtilities.cs,GetNumberOfDaysProlepticGregorian,The following statement contains a magic number: var startYear = 1970;
Magic Number,PeterO.Cbor,CBORUtilities,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORUtilities.cs,GetNumberOfDaysProlepticGregorian,The following statement contains a magic number: EInteger blocks = diff.Subtract(401).Divide(400);
Magic Number,PeterO.Cbor,CBORUtilities,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORUtilities.cs,GetNumberOfDaysProlepticGregorian,The following statement contains a magic number: EInteger blocks = diff.Subtract(401).Divide(400);
Magic Number,PeterO.Cbor,CBORUtilities,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORUtilities.cs,GetNumberOfDaysProlepticGregorian,The following statement contains a magic number: numDays = numDays.Subtract(blocks.Multiply(146097));
Magic Number,PeterO.Cbor,CBORUtilities,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORUtilities.cs,GetNumberOfDaysProlepticGregorian,The following statement contains a magic number: diff = diff.Subtract(blocks.Multiply(400));
Magic Number,PeterO.Cbor,CBORUtilities,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORUtilities.cs,GetNumberOfDaysProlepticGregorian,The following statement contains a magic number: ei = ei.Subtract(blocks.Multiply(400));
Magic Number,PeterO.Cbor,CBORUtilities,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORUtilities.cs,GetNumberOfDaysProlepticGregorian,The following statement contains a magic number: diff.CompareTo(401) > 0
Magic Number,PeterO.Cbor,CBORUtilities,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORUtilities.cs,GetNumberOfDaysProlepticGregorian,The following statement contains a magic number: numDays = numDays.Subtract(diff.Multiply(365));
Magic Number,PeterO.Cbor,CBORUtilities,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORUtilities.cs,GetNumberOfDaysProlepticGregorian,The following statement contains a magic number: decrement = 4;
Magic Number,PeterO.Cbor,CBORUtilities,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORUtilities.cs,GetNumberOfDaysProlepticGregorian,The following statement contains a magic number: decrement == 1 && ei.Remainder(4).Sign == 0
Magic Number,PeterO.Cbor,CBORUtilities,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORUtilities.cs,GetNumberOfDaysProlepticGregorian,The following statement contains a magic number: !(ei.Remainder(4).Sign != 0 || (                 ei.Remainder(100).Sign == 0 && ei.Remainder(400).Sign !=                 0))
Magic Number,PeterO.Cbor,CBORUtilities,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORUtilities.cs,GetNumberOfDaysProlepticGregorian,The following statement contains a magic number: !(ei.Remainder(4).Sign != 0 || (                 ei.Remainder(100).Sign == 0 && ei.Remainder(400).Sign !=                 0))
Magic Number,PeterO.Cbor,CBORUtilities,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORUtilities.cs,GetNumberOfDaysProlepticGregorian,The following statement contains a magic number: !(ei.Remainder(4).Sign != 0 || (                 ei.Remainder(100).Sign == 0 && ei.Remainder(400).Sign !=                 0))
Magic Number,PeterO.Cbor,CBORUtilities,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORUtilities.cs,GetNumberOfDaysProlepticGregorian,The following statement contains a magic number: numDays = numDays.Subtract(365 - ValueNormalToMonth[month])             .Subtract(ValueNormalDays[month] - mday + 1);
Magic Number,PeterO.Cbor,CBORUtilities,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORUtilities.cs,GetNumberOfDaysProlepticGregorian,The following statement contains a magic number: year.Remainder(4).Sign != 0 || (             year.Remainder(100).Sign == 0 && year.Remainder(400).Sign != 0)
Magic Number,PeterO.Cbor,CBORUtilities,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORUtilities.cs,GetNumberOfDaysProlepticGregorian,The following statement contains a magic number: year.Remainder(4).Sign != 0 || (             year.Remainder(100).Sign == 0 && year.Remainder(400).Sign != 0)
Magic Number,PeterO.Cbor,CBORUtilities,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORUtilities.cs,GetNumberOfDaysProlepticGregorian,The following statement contains a magic number: year.Remainder(4).Sign != 0 || (             year.Remainder(100).Sign == 0 && year.Remainder(400).Sign != 0)
Magic Number,PeterO.Cbor,CBORUtilities,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORUtilities.cs,BreakDownSecondsSinceEpoch,The following statement contains a magic number: int nanoseconds = fractionalPart.Multiply(1000000000)         .ToInt32Checked();
Magic Number,PeterO.Cbor,CBORUtilities,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORUtilities.cs,BreakDownSecondsSinceEpoch,The following statement contains a magic number: var normPart = new EInteger[3];
Magic Number,PeterO.Cbor,CBORUtilities,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORUtilities.cs,BreakDownSecondsSinceEpoch,The following statement contains a magic number: EInteger days = FloorDiv(           integerPart'           EInteger.FromInt32(86400)).Add(1);
Magic Number,PeterO.Cbor,CBORUtilities,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORUtilities.cs,BreakDownSecondsSinceEpoch,The following statement contains a magic number: int secondsInDay = FloorMod(           integerPart'           EInteger.FromInt32(86400)).ToInt32Checked();
Magic Number,PeterO.Cbor,CBORUtilities,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORUtilities.cs,BreakDownSecondsSinceEpoch,The following statement contains a magic number: GetNormalizedPartProlepticGregorian(         EInteger.FromInt32(1970)'         1'         days'         normPart);
Magic Number,PeterO.Cbor,CBORUtilities,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORUtilities.cs,BreakDownSecondsSinceEpoch,The following statement contains a magic number: lesserFields[1] = normPart[2].ToInt32Checked();
Magic Number,PeterO.Cbor,CBORUtilities,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORUtilities.cs,BreakDownSecondsSinceEpoch,The following statement contains a magic number: lesserFields[2] = secondsInDay / 3600;
Magic Number,PeterO.Cbor,CBORUtilities,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORUtilities.cs,BreakDownSecondsSinceEpoch,The following statement contains a magic number: lesserFields[2] = secondsInDay / 3600;
Magic Number,PeterO.Cbor,CBORUtilities,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORUtilities.cs,BreakDownSecondsSinceEpoch,The following statement contains a magic number: lesserFields[3] = (secondsInDay % 3600) / 60;
Magic Number,PeterO.Cbor,CBORUtilities,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORUtilities.cs,BreakDownSecondsSinceEpoch,The following statement contains a magic number: lesserFields[3] = (secondsInDay % 3600) / 60;
Magic Number,PeterO.Cbor,CBORUtilities,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORUtilities.cs,BreakDownSecondsSinceEpoch,The following statement contains a magic number: lesserFields[3] = (secondsInDay % 3600) / 60;
Magic Number,PeterO.Cbor,CBORUtilities,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORUtilities.cs,BreakDownSecondsSinceEpoch,The following statement contains a magic number: lesserFields[4] = secondsInDay % 60;
Magic Number,PeterO.Cbor,CBORUtilities,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORUtilities.cs,BreakDownSecondsSinceEpoch,The following statement contains a magic number: lesserFields[4] = secondsInDay % 60;
Magic Number,PeterO.Cbor,CBORUtilities,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORUtilities.cs,BreakDownSecondsSinceEpoch,The following statement contains a magic number: lesserFields[5] = nanoseconds / 100;
Magic Number,PeterO.Cbor,CBORUtilities,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORUtilities.cs,BreakDownSecondsSinceEpoch,The following statement contains a magic number: lesserFields[5] = nanoseconds / 100;
Magic Number,PeterO.Cbor,CBORUtilities,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORUtilities.cs,BreakDownSecondsSinceEpoch,The following statement contains a magic number: lesserFields[6] = 0;
Magic Number,PeterO.Cbor,CBORUtilities,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORUtilities.cs,IsValidDateTime,The following statement contains a magic number: dateTime == null || dateTime.Length < 8
Magic Number,PeterO.Cbor,CBORUtilities,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORUtilities.cs,IsValidDateTime,The following statement contains a magic number: dateTime[1] < 1 || dateTime[1] > 12 || dateTime[2] < 1
Magic Number,PeterO.Cbor,CBORUtilities,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORUtilities.cs,IsValidDateTime,The following statement contains a magic number: dateTime[1] < 1 || dateTime[1] > 12 || dateTime[2] < 1
Magic Number,PeterO.Cbor,CBORUtilities,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORUtilities.cs,IsValidDateTime,The following statement contains a magic number: dateTime[2] > 30
Magic Number,PeterO.Cbor,CBORUtilities,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORUtilities.cs,IsValidDateTime,The following statement contains a magic number: dateTime[2] > 30
Magic Number,PeterO.Cbor,CBORUtilities,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORUtilities.cs,IsValidDateTime,The following statement contains a magic number: dateTime[1] == 4 || dateTime[1] == 6 || dateTime[1] == 9 ||         dateTime[1] == 11
Magic Number,PeterO.Cbor,CBORUtilities,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORUtilities.cs,IsValidDateTime,The following statement contains a magic number: dateTime[1] == 4 || dateTime[1] == 6 || dateTime[1] == 9 ||         dateTime[1] == 11
Magic Number,PeterO.Cbor,CBORUtilities,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORUtilities.cs,IsValidDateTime,The following statement contains a magic number: dateTime[1] == 4 || dateTime[1] == 6 || dateTime[1] == 9 ||         dateTime[1] == 11
Magic Number,PeterO.Cbor,CBORUtilities,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORUtilities.cs,IsValidDateTime,The following statement contains a magic number: dateTime[1] == 4 || dateTime[1] == 6 || dateTime[1] == 9 ||         dateTime[1] == 11
Magic Number,PeterO.Cbor,CBORUtilities,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORUtilities.cs,IsValidDateTime,The following statement contains a magic number: return !(dateTime[3] < 0 || dateTime[4] < 0 || dateTime[5] < 0 ||           dateTime[3] >= 24 || dateTime[4] >= 60 || dateTime[5] >= 61 ||           dateTime[6] < 0 ||           dateTime[6] >= 1000000000 || dateTime[7] <= -1440 ||           dateTime[7] >= 1440);
Magic Number,PeterO.Cbor,CBORUtilities,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORUtilities.cs,IsValidDateTime,The following statement contains a magic number: return !(dateTime[3] < 0 || dateTime[4] < 0 || dateTime[5] < 0 ||           dateTime[3] >= 24 || dateTime[4] >= 60 || dateTime[5] >= 61 ||           dateTime[6] < 0 ||           dateTime[6] >= 1000000000 || dateTime[7] <= -1440 ||           dateTime[7] >= 1440);
Magic Number,PeterO.Cbor,CBORUtilities,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORUtilities.cs,IsValidDateTime,The following statement contains a magic number: return !(dateTime[3] < 0 || dateTime[4] < 0 || dateTime[5] < 0 ||           dateTime[3] >= 24 || dateTime[4] >= 60 || dateTime[5] >= 61 ||           dateTime[6] < 0 ||           dateTime[6] >= 1000000000 || dateTime[7] <= -1440 ||           dateTime[7] >= 1440);
Magic Number,PeterO.Cbor,CBORUtilities,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORUtilities.cs,IsValidDateTime,The following statement contains a magic number: return !(dateTime[3] < 0 || dateTime[4] < 0 || dateTime[5] < 0 ||           dateTime[3] >= 24 || dateTime[4] >= 60 || dateTime[5] >= 61 ||           dateTime[6] < 0 ||           dateTime[6] >= 1000000000 || dateTime[7] <= -1440 ||           dateTime[7] >= 1440);
Magic Number,PeterO.Cbor,CBORUtilities,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORUtilities.cs,IsValidDateTime,The following statement contains a magic number: return !(dateTime[3] < 0 || dateTime[4] < 0 || dateTime[5] < 0 ||           dateTime[3] >= 24 || dateTime[4] >= 60 || dateTime[5] >= 61 ||           dateTime[6] < 0 ||           dateTime[6] >= 1000000000 || dateTime[7] <= -1440 ||           dateTime[7] >= 1440);
Magic Number,PeterO.Cbor,CBORUtilities,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORUtilities.cs,IsValidDateTime,The following statement contains a magic number: return !(dateTime[3] < 0 || dateTime[4] < 0 || dateTime[5] < 0 ||           dateTime[3] >= 24 || dateTime[4] >= 60 || dateTime[5] >= 61 ||           dateTime[6] < 0 ||           dateTime[6] >= 1000000000 || dateTime[7] <= -1440 ||           dateTime[7] >= 1440);
Magic Number,PeterO.Cbor,CBORUtilities,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORUtilities.cs,IsValidDateTime,The following statement contains a magic number: return !(dateTime[3] < 0 || dateTime[4] < 0 || dateTime[5] < 0 ||           dateTime[3] >= 24 || dateTime[4] >= 60 || dateTime[5] >= 61 ||           dateTime[6] < 0 ||           dateTime[6] >= 1000000000 || dateTime[7] <= -1440 ||           dateTime[7] >= 1440);
Magic Number,PeterO.Cbor,CBORUtilities,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORUtilities.cs,IsValidDateTime,The following statement contains a magic number: return !(dateTime[3] < 0 || dateTime[4] < 0 || dateTime[5] < 0 ||           dateTime[3] >= 24 || dateTime[4] >= 60 || dateTime[5] >= 61 ||           dateTime[6] < 0 ||           dateTime[6] >= 1000000000 || dateTime[7] <= -1440 ||           dateTime[7] >= 1440);
Magic Number,PeterO.Cbor,CBORUtilities,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORUtilities.cs,IsValidDateTime,The following statement contains a magic number: return !(dateTime[3] < 0 || dateTime[4] < 0 || dateTime[5] < 0 ||           dateTime[3] >= 24 || dateTime[4] >= 60 || dateTime[5] >= 61 ||           dateTime[6] < 0 ||           dateTime[6] >= 1000000000 || dateTime[7] <= -1440 ||           dateTime[7] >= 1440);
Magic Number,PeterO.Cbor,CBORUtilities,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORUtilities.cs,IsValidDateTime,The following statement contains a magic number: return !(dateTime[3] < 0 || dateTime[4] < 0 || dateTime[5] < 0 ||           dateTime[3] >= 24 || dateTime[4] >= 60 || dateTime[5] >= 61 ||           dateTime[6] < 0 ||           dateTime[6] >= 1000000000 || dateTime[7] <= -1440 ||           dateTime[7] >= 1440);
Magic Number,PeterO.Cbor,CBORUtilities,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORUtilities.cs,IsValidDateTime,The following statement contains a magic number: return !(dateTime[3] < 0 || dateTime[4] < 0 || dateTime[5] < 0 ||           dateTime[3] >= 24 || dateTime[4] >= 60 || dateTime[5] >= 61 ||           dateTime[6] < 0 ||           dateTime[6] >= 1000000000 || dateTime[7] <= -1440 ||           dateTime[7] >= 1440);
Magic Number,PeterO.Cbor,CBORUtilities,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORUtilities.cs,IsValidDateTime,The following statement contains a magic number: return !(dateTime[3] < 0 || dateTime[4] < 0 || dateTime[5] < 0 ||           dateTime[3] >= 24 || dateTime[4] >= 60 || dateTime[5] >= 61 ||           dateTime[6] < 0 ||           dateTime[6] >= 1000000000 || dateTime[7] <= -1440 ||           dateTime[7] >= 1440);
Magic Number,PeterO.Cbor,CBORUtilities,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORUtilities.cs,IsValidDateTime,The following statement contains a magic number: return !(dateTime[3] < 0 || dateTime[4] < 0 || dateTime[5] < 0 ||           dateTime[3] >= 24 || dateTime[4] >= 60 || dateTime[5] >= 61 ||           dateTime[6] < 0 ||           dateTime[6] >= 1000000000 || dateTime[7] <= -1440 ||           dateTime[7] >= 1440);
Magic Number,PeterO.Cbor,CBORUtilities,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORUtilities.cs,IsValidDateTime,The following statement contains a magic number: return !(dateTime[3] < 0 || dateTime[4] < 0 || dateTime[5] < 0 ||           dateTime[3] >= 24 || dateTime[4] >= 60 || dateTime[5] >= 61 ||           dateTime[6] < 0 ||           dateTime[6] >= 1000000000 || dateTime[7] <= -1440 ||           dateTime[7] >= 1440);
Magic Number,PeterO.Cbor,CBORUtilities,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORUtilities.cs,IsValidDateTime,The following statement contains a magic number: return !(dateTime[3] < 0 || dateTime[4] < 0 || dateTime[5] < 0 ||           dateTime[3] >= 24 || dateTime[4] >= 60 || dateTime[5] >= 61 ||           dateTime[6] < 0 ||           dateTime[6] >= 1000000000 || dateTime[7] <= -1440 ||           dateTime[7] >= 1440);
Magic Number,PeterO.Cbor,CBORUtilities,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORUtilities.cs,IsValidDateTime,The following statement contains a magic number: return !(dateTime[3] < 0 || dateTime[4] < 0 || dateTime[5] < 0 ||           dateTime[3] >= 24 || dateTime[4] >= 60 || dateTime[5] >= 61 ||           dateTime[6] < 0 ||           dateTime[6] >= 1000000000 || dateTime[7] <= -1440 ||           dateTime[7] >= 1440);
Magic Number,PeterO.Cbor,CBORUtilities,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORUtilities.cs,IsLeapYear,The following statement contains a magic number: yr %= 400;
Magic Number,PeterO.Cbor,CBORUtilities,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORUtilities.cs,IsLeapYear,The following statement contains a magic number: yr += 400;
Magic Number,PeterO.Cbor,CBORUtilities,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORUtilities.cs,IsLeapYear,The following statement contains a magic number: return (((yr % 4) == 0) && ((yr % 100) != 0)) || ((yr % 400) == 0);
Magic Number,PeterO.Cbor,CBORUtilities,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORUtilities.cs,IsLeapYear,The following statement contains a magic number: return (((yr % 4) == 0) && ((yr % 100) != 0)) || ((yr % 400) == 0);
Magic Number,PeterO.Cbor,CBORUtilities,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORUtilities.cs,IsLeapYear,The following statement contains a magic number: return (((yr % 4) == 0) && ((yr % 100) != 0)) || ((yr % 400) == 0);
Magic Number,PeterO.Cbor,CBORUtilities,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORUtilities.cs,ParseAtomDateTimeString,The following statement contains a magic number: Array.Copy(d' 1' lf' 0' 7);
Magic Number,PeterO.Cbor,CBORUtilities,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORUtilities.cs,ParseAtomDateTimeString,The following statement contains a magic number: str.Length < 19
Magic Number,PeterO.Cbor,CBORUtilities,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORUtilities.cs,ParseAtomDateTimeString,The following statement contains a magic number: i == 4 || i == 7
Magic Number,PeterO.Cbor,CBORUtilities,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORUtilities.cs,ParseAtomDateTimeString,The following statement contains a magic number: i == 4 || i == 7
Magic Number,PeterO.Cbor,CBORUtilities,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORUtilities.cs,ParseAtomDateTimeString,The following statement contains a magic number: i < 19 && !bad
Magic Number,PeterO.Cbor,CBORUtilities,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORUtilities.cs,ParseAtomDateTimeString,The following statement contains a magic number: int year = ((str[0] - '0') * 1000) + ((str[1] - '0') * 100) +         ((str[2] - '0') * 10) + (str[3] - '0');
Magic Number,PeterO.Cbor,CBORUtilities,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORUtilities.cs,ParseAtomDateTimeString,The following statement contains a magic number: int year = ((str[0] - '0') * 1000) + ((str[1] - '0') * 100) +         ((str[2] - '0') * 10) + (str[3] - '0');
Magic Number,PeterO.Cbor,CBORUtilities,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORUtilities.cs,ParseAtomDateTimeString,The following statement contains a magic number: int year = ((str[0] - '0') * 1000) + ((str[1] - '0') * 100) +         ((str[2] - '0') * 10) + (str[3] - '0');
Magic Number,PeterO.Cbor,CBORUtilities,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORUtilities.cs,ParseAtomDateTimeString,The following statement contains a magic number: int year = ((str[0] - '0') * 1000) + ((str[1] - '0') * 100) +         ((str[2] - '0') * 10) + (str[3] - '0');
Magic Number,PeterO.Cbor,CBORUtilities,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORUtilities.cs,ParseAtomDateTimeString,The following statement contains a magic number: int year = ((str[0] - '0') * 1000) + ((str[1] - '0') * 100) +         ((str[2] - '0') * 10) + (str[3] - '0');
Magic Number,PeterO.Cbor,CBORUtilities,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORUtilities.cs,ParseAtomDateTimeString,The following statement contains a magic number: int month = ((str[5] - '0') * 10) + (str[6] - '0');
Magic Number,PeterO.Cbor,CBORUtilities,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORUtilities.cs,ParseAtomDateTimeString,The following statement contains a magic number: int month = ((str[5] - '0') * 10) + (str[6] - '0');
Magic Number,PeterO.Cbor,CBORUtilities,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORUtilities.cs,ParseAtomDateTimeString,The following statement contains a magic number: int month = ((str[5] - '0') * 10) + (str[6] - '0');
Magic Number,PeterO.Cbor,CBORUtilities,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORUtilities.cs,ParseAtomDateTimeString,The following statement contains a magic number: int day = ((str[8] - '0') * 10) + (str[9] - '0');
Magic Number,PeterO.Cbor,CBORUtilities,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORUtilities.cs,ParseAtomDateTimeString,The following statement contains a magic number: int day = ((str[8] - '0') * 10) + (str[9] - '0');
Magic Number,PeterO.Cbor,CBORUtilities,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORUtilities.cs,ParseAtomDateTimeString,The following statement contains a magic number: int day = ((str[8] - '0') * 10) + (str[9] - '0');
Magic Number,PeterO.Cbor,CBORUtilities,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORUtilities.cs,ParseAtomDateTimeString,The following statement contains a magic number: int hour = ((str[11] - '0') * 10) + (str[12] - '0');
Magic Number,PeterO.Cbor,CBORUtilities,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORUtilities.cs,ParseAtomDateTimeString,The following statement contains a magic number: int hour = ((str[11] - '0') * 10) + (str[12] - '0');
Magic Number,PeterO.Cbor,CBORUtilities,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORUtilities.cs,ParseAtomDateTimeString,The following statement contains a magic number: int hour = ((str[11] - '0') * 10) + (str[12] - '0');
Magic Number,PeterO.Cbor,CBORUtilities,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORUtilities.cs,ParseAtomDateTimeString,The following statement contains a magic number: int minute = ((str[14] - '0') * 10) + (str[15] - '0');
Magic Number,PeterO.Cbor,CBORUtilities,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORUtilities.cs,ParseAtomDateTimeString,The following statement contains a magic number: int minute = ((str[14] - '0') * 10) + (str[15] - '0');
Magic Number,PeterO.Cbor,CBORUtilities,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORUtilities.cs,ParseAtomDateTimeString,The following statement contains a magic number: int minute = ((str[14] - '0') * 10) + (str[15] - '0');
Magic Number,PeterO.Cbor,CBORUtilities,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORUtilities.cs,ParseAtomDateTimeString,The following statement contains a magic number: int second = ((str[17] - '0') * 10) + (str[18] - '0');
Magic Number,PeterO.Cbor,CBORUtilities,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORUtilities.cs,ParseAtomDateTimeString,The following statement contains a magic number: int second = ((str[17] - '0') * 10) + (str[18] - '0');
Magic Number,PeterO.Cbor,CBORUtilities,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORUtilities.cs,ParseAtomDateTimeString,The following statement contains a magic number: int second = ((str[17] - '0') * 10) + (str[18] - '0');
Magic Number,PeterO.Cbor,CBORUtilities,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORUtilities.cs,ParseAtomDateTimeString,The following statement contains a magic number: var index = 19;
Magic Number,PeterO.Cbor,CBORUtilities,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORUtilities.cs,ParseAtomDateTimeString,The following statement contains a magic number: nanoSeconds = (nanoSeconds * 10) + (str[index] - '0');
Magic Number,PeterO.Cbor,CBORUtilities,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORUtilities.cs,ParseAtomDateTimeString,The following statement contains a magic number: icount < 9
Magic Number,PeterO.Cbor,CBORUtilities,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORUtilities.cs,ParseAtomDateTimeString,The following statement contains a magic number: nanoSeconds *= 10;
Magic Number,PeterO.Cbor,CBORUtilities,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORUtilities.cs,ParseAtomDateTimeString,The following statement contains a magic number: icount < 9
Magic Number,PeterO.Cbor,CBORUtilities,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORUtilities.cs,ToAtomDateTimeString,The following statement contains a magic number: lesserFields[6] != 0
Magic Number,PeterO.Cbor,CBORUtilities,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORUtilities.cs,ToAtomDateTimeString,The following statement contains a magic number: smallYear > 9999
Magic Number,PeterO.Cbor,CBORUtilities,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORUtilities.cs,ToAtomDateTimeString,The following statement contains a magic number: int hour = lesserFields[2];
Magic Number,PeterO.Cbor,CBORUtilities,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORUtilities.cs,ToAtomDateTimeString,The following statement contains a magic number: int minute = lesserFields[3];
Magic Number,PeterO.Cbor,CBORUtilities,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORUtilities.cs,ToAtomDateTimeString,The following statement contains a magic number: int second = lesserFields[4];
Magic Number,PeterO.Cbor,CBORUtilities,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORUtilities.cs,ToAtomDateTimeString,The following statement contains a magic number: int fracSeconds = lesserFields[5];
Magic Number,PeterO.Cbor,CBORUtilities,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORUtilities.cs,ToAtomDateTimeString,The following statement contains a magic number: var charbuf = new char[32];
Magic Number,PeterO.Cbor,CBORUtilities,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORUtilities.cs,ToAtomDateTimeString,The following statement contains a magic number: charbuf[0] = (char)('0' + ((smallYear / 1000) % 10));
Magic Number,PeterO.Cbor,CBORUtilities,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORUtilities.cs,ToAtomDateTimeString,The following statement contains a magic number: charbuf[0] = (char)('0' + ((smallYear / 1000) % 10));
Magic Number,PeterO.Cbor,CBORUtilities,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORUtilities.cs,ToAtomDateTimeString,The following statement contains a magic number: charbuf[1] = (char)('0' + ((smallYear / 100) % 10));
Magic Number,PeterO.Cbor,CBORUtilities,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORUtilities.cs,ToAtomDateTimeString,The following statement contains a magic number: charbuf[1] = (char)('0' + ((smallYear / 100) % 10));
Magic Number,PeterO.Cbor,CBORUtilities,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORUtilities.cs,ToAtomDateTimeString,The following statement contains a magic number: charbuf[2] = (char)('0' + ((smallYear / 10) % 10));
Magic Number,PeterO.Cbor,CBORUtilities,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORUtilities.cs,ToAtomDateTimeString,The following statement contains a magic number: charbuf[2] = (char)('0' + ((smallYear / 10) % 10));
Magic Number,PeterO.Cbor,CBORUtilities,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORUtilities.cs,ToAtomDateTimeString,The following statement contains a magic number: charbuf[2] = (char)('0' + ((smallYear / 10) % 10));
Magic Number,PeterO.Cbor,CBORUtilities,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORUtilities.cs,ToAtomDateTimeString,The following statement contains a magic number: charbuf[3] = (char)('0' + (smallYear % 10));
Magic Number,PeterO.Cbor,CBORUtilities,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORUtilities.cs,ToAtomDateTimeString,The following statement contains a magic number: charbuf[3] = (char)('0' + (smallYear % 10));
Magic Number,PeterO.Cbor,CBORUtilities,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORUtilities.cs,ToAtomDateTimeString,The following statement contains a magic number: charbuf[4] = '-';
Magic Number,PeterO.Cbor,CBORUtilities,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORUtilities.cs,ToAtomDateTimeString,The following statement contains a magic number: charbuf[5] = (char)('0' + ((month / 10) % 10));
Magic Number,PeterO.Cbor,CBORUtilities,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORUtilities.cs,ToAtomDateTimeString,The following statement contains a magic number: charbuf[5] = (char)('0' + ((month / 10) % 10));
Magic Number,PeterO.Cbor,CBORUtilities,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORUtilities.cs,ToAtomDateTimeString,The following statement contains a magic number: charbuf[5] = (char)('0' + ((month / 10) % 10));
Magic Number,PeterO.Cbor,CBORUtilities,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORUtilities.cs,ToAtomDateTimeString,The following statement contains a magic number: charbuf[6] = (char)('0' + (month % 10));
Magic Number,PeterO.Cbor,CBORUtilities,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORUtilities.cs,ToAtomDateTimeString,The following statement contains a magic number: charbuf[6] = (char)('0' + (month % 10));
Magic Number,PeterO.Cbor,CBORUtilities,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORUtilities.cs,ToAtomDateTimeString,The following statement contains a magic number: charbuf[7] = '-';
Magic Number,PeterO.Cbor,CBORUtilities,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORUtilities.cs,ToAtomDateTimeString,The following statement contains a magic number: charbuf[8] = (char)('0' + ((day / 10) % 10));
Magic Number,PeterO.Cbor,CBORUtilities,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORUtilities.cs,ToAtomDateTimeString,The following statement contains a magic number: charbuf[8] = (char)('0' + ((day / 10) % 10));
Magic Number,PeterO.Cbor,CBORUtilities,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORUtilities.cs,ToAtomDateTimeString,The following statement contains a magic number: charbuf[8] = (char)('0' + ((day / 10) % 10));
Magic Number,PeterO.Cbor,CBORUtilities,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORUtilities.cs,ToAtomDateTimeString,The following statement contains a magic number: charbuf[9] = (char)('0' + (day % 10));
Magic Number,PeterO.Cbor,CBORUtilities,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORUtilities.cs,ToAtomDateTimeString,The following statement contains a magic number: charbuf[9] = (char)('0' + (day % 10));
Magic Number,PeterO.Cbor,CBORUtilities,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORUtilities.cs,ToAtomDateTimeString,The following statement contains a magic number: charbuf[10] = 'T';
Magic Number,PeterO.Cbor,CBORUtilities,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORUtilities.cs,ToAtomDateTimeString,The following statement contains a magic number: charbuf[11] = (char)('0' + ((hour / 10) % 10));
Magic Number,PeterO.Cbor,CBORUtilities,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORUtilities.cs,ToAtomDateTimeString,The following statement contains a magic number: charbuf[11] = (char)('0' + ((hour / 10) % 10));
Magic Number,PeterO.Cbor,CBORUtilities,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORUtilities.cs,ToAtomDateTimeString,The following statement contains a magic number: charbuf[11] = (char)('0' + ((hour / 10) % 10));
Magic Number,PeterO.Cbor,CBORUtilities,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORUtilities.cs,ToAtomDateTimeString,The following statement contains a magic number: charbuf[12] = (char)('0' + (hour % 10));
Magic Number,PeterO.Cbor,CBORUtilities,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORUtilities.cs,ToAtomDateTimeString,The following statement contains a magic number: charbuf[12] = (char)('0' + (hour % 10));
Magic Number,PeterO.Cbor,CBORUtilities,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORUtilities.cs,ToAtomDateTimeString,The following statement contains a magic number: charbuf[13] = ':';
Magic Number,PeterO.Cbor,CBORUtilities,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORUtilities.cs,ToAtomDateTimeString,The following statement contains a magic number: charbuf[14] = (char)('0' + ((minute / 10) % 10));
Magic Number,PeterO.Cbor,CBORUtilities,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORUtilities.cs,ToAtomDateTimeString,The following statement contains a magic number: charbuf[14] = (char)('0' + ((minute / 10) % 10));
Magic Number,PeterO.Cbor,CBORUtilities,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORUtilities.cs,ToAtomDateTimeString,The following statement contains a magic number: charbuf[14] = (char)('0' + ((minute / 10) % 10));
Magic Number,PeterO.Cbor,CBORUtilities,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORUtilities.cs,ToAtomDateTimeString,The following statement contains a magic number: charbuf[15] = (char)('0' + (minute % 10));
Magic Number,PeterO.Cbor,CBORUtilities,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORUtilities.cs,ToAtomDateTimeString,The following statement contains a magic number: charbuf[15] = (char)('0' + (minute % 10));
Magic Number,PeterO.Cbor,CBORUtilities,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORUtilities.cs,ToAtomDateTimeString,The following statement contains a magic number: charbuf[16] = ':';
Magic Number,PeterO.Cbor,CBORUtilities,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORUtilities.cs,ToAtomDateTimeString,The following statement contains a magic number: charbuf[17] = (char)('0' + ((second / 10) % 10));
Magic Number,PeterO.Cbor,CBORUtilities,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORUtilities.cs,ToAtomDateTimeString,The following statement contains a magic number: charbuf[17] = (char)('0' + ((second / 10) % 10));
Magic Number,PeterO.Cbor,CBORUtilities,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORUtilities.cs,ToAtomDateTimeString,The following statement contains a magic number: charbuf[17] = (char)('0' + ((second / 10) % 10));
Magic Number,PeterO.Cbor,CBORUtilities,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORUtilities.cs,ToAtomDateTimeString,The following statement contains a magic number: charbuf[18] = (char)('0' + (second % 10));
Magic Number,PeterO.Cbor,CBORUtilities,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORUtilities.cs,ToAtomDateTimeString,The following statement contains a magic number: charbuf[18] = (char)('0' + (second % 10));
Magic Number,PeterO.Cbor,CBORUtilities,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORUtilities.cs,ToAtomDateTimeString,The following statement contains a magic number: var charbufLength = 19;
Magic Number,PeterO.Cbor,CBORUtilities,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORUtilities.cs,ToAtomDateTimeString,The following statement contains a magic number: charbuf[19] = '.';
Magic Number,PeterO.Cbor,CBORUtilities,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORUtilities.cs,ToAtomDateTimeString,The following statement contains a magic number: var digitdiv = 100000000;
Magic Number,PeterO.Cbor,CBORUtilities,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORUtilities.cs,ToAtomDateTimeString,The following statement contains a magic number: var index = 20;
Magic Number,PeterO.Cbor,CBORUtilities,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORUtilities.cs,ToAtomDateTimeString,The following statement contains a magic number: int digit = (fracSeconds / digitdiv) % 10;
Magic Number,PeterO.Cbor,CBORUtilities,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORUtilities.cs,ToAtomDateTimeString,The following statement contains a magic number: digitdiv /= 10;
Magic Number,PeterO.Cbor,CBORUtilities,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORUtilities.cs,BigIntegerFromDouble,The following statement contains a magic number: int value1 = unchecked((int)((lvalue >> 32) & 0xffffffffL));
Magic Number,PeterO.Cbor,CBORUtilities,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORUtilities.cs,BigIntegerFromDouble,The following statement contains a magic number: var floatExponent = (int)((value1 >> 20) & 0x7ff);
Magic Number,PeterO.Cbor,CBORUtilities,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORUtilities.cs,BigIntegerFromDouble,The following statement contains a magic number: bool neg = (value1 >> 31) != 0;
Magic Number,PeterO.Cbor,CBORUtilities,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORUtilities.cs,BigIntegerFromDouble,The following statement contains a magic number: floatExponent == 2047
Magic Number,PeterO.Cbor,CBORUtilities,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORUtilities.cs,BigIntegerFromDouble,The following statement contains a magic number: value0 = unchecked(value0 | (value1 << 31));
Magic Number,PeterO.Cbor,CBORUtilities,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORUtilities.cs,BigIntegerFromDouble,The following statement contains a magic number: floatExponent -= 1075;
Magic Number,PeterO.Cbor,CBORUtilities,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORUtilities.cs,BigIntegerFromDouble,The following statement contains a magic number: var bytes = new byte[9];
Magic Number,PeterO.Cbor,CBORUtilities,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORUtilities.cs,BigIntegerFromDouble,The following statement contains a magic number: bytes[1] = (byte)((value0 >> 8) & 0xff);
Magic Number,PeterO.Cbor,CBORUtilities,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORUtilities.cs,BigIntegerFromDouble,The following statement contains a magic number: bytes[2] = (byte)((value0 >> 16) & 0xff);
Magic Number,PeterO.Cbor,CBORUtilities,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORUtilities.cs,BigIntegerFromDouble,The following statement contains a magic number: bytes[2] = (byte)((value0 >> 16) & 0xff);
Magic Number,PeterO.Cbor,CBORUtilities,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORUtilities.cs,BigIntegerFromDouble,The following statement contains a magic number: bytes[3] = (byte)((value0 >> 24) & 0xff);
Magic Number,PeterO.Cbor,CBORUtilities,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORUtilities.cs,BigIntegerFromDouble,The following statement contains a magic number: bytes[3] = (byte)((value0 >> 24) & 0xff);
Magic Number,PeterO.Cbor,CBORUtilities,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORUtilities.cs,BigIntegerFromDouble,The following statement contains a magic number: bytes[4] = (byte)(value1 & 0xff);
Magic Number,PeterO.Cbor,CBORUtilities,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORUtilities.cs,BigIntegerFromDouble,The following statement contains a magic number: bytes[5] = (byte)((value1 >> 8) & 0xff);
Magic Number,PeterO.Cbor,CBORUtilities,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORUtilities.cs,BigIntegerFromDouble,The following statement contains a magic number: bytes[5] = (byte)((value1 >> 8) & 0xff);
Magic Number,PeterO.Cbor,CBORUtilities,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORUtilities.cs,BigIntegerFromDouble,The following statement contains a magic number: bytes[6] = (byte)((value1 >> 16) & 0xff);
Magic Number,PeterO.Cbor,CBORUtilities,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORUtilities.cs,BigIntegerFromDouble,The following statement contains a magic number: bytes[6] = (byte)((value1 >> 16) & 0xff);
Magic Number,PeterO.Cbor,CBORUtilities,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORUtilities.cs,BigIntegerFromDouble,The following statement contains a magic number: bytes[7] = (byte)((value1 >> 24) & 0xff);
Magic Number,PeterO.Cbor,CBORUtilities,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORUtilities.cs,BigIntegerFromDouble,The following statement contains a magic number: bytes[7] = (byte)((value1 >> 24) & 0xff);
Magic Number,PeterO.Cbor,CBORUtilities,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORUtilities.cs,BigIntegerFromDouble,The following statement contains a magic number: bytes[8] = (byte)0;
Magic Number,PeterO.Cbor,CBORUtilities,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORUtilities.cs,DoubleToHalfPrecisionIfSameValue,The following statement contains a magic number: int exp = unchecked((int)((bits >> 52) & 0x7ffL));
Magic Number,PeterO.Cbor,CBORUtilities,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORUtilities.cs,DoubleToHalfPrecisionIfSameValue,The following statement contains a magic number: int sign = unchecked((int)(bits >> 48)) & (1 << 15);
Magic Number,PeterO.Cbor,CBORUtilities,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORUtilities.cs,DoubleToHalfPrecisionIfSameValue,The following statement contains a magic number: int sign = unchecked((int)(bits >> 48)) & (1 << 15);
Magic Number,PeterO.Cbor,CBORUtilities,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORUtilities.cs,DoubleToHalfPrecisionIfSameValue,The following statement contains a magic number: int sexp = exp - 1008;
Magic Number,PeterO.Cbor,CBORUtilities,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORUtilities.cs,DoubleToHalfPrecisionIfSameValue,The following statement contains a magic number: int newmant = unchecked((int)(mant >> 42));
Magic Number,PeterO.Cbor,CBORUtilities,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORUtilities.cs,DoubleToHalfPrecisionIfSameValue,The following statement contains a magic number: return ((mant & ((1L << 42) - 1)) == 0) ? (sign | 0x7c00 | newmant) :           -1;
Magic Number,PeterO.Cbor,CBORUtilities,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORUtilities.cs,DoubleToHalfPrecisionIfSameValue,The following statement contains a magic number: exp == 2047
Magic Number,PeterO.Cbor,CBORUtilities,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORUtilities.cs,DoubleRetainsSameValueInSingle,The following statement contains a magic number: int exp = unchecked((int)((bits >> 52) & 0x7ffL));
Magic Number,PeterO.Cbor,CBORUtilities,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORUtilities.cs,DoubleRetainsSameValueInSingle,The following statement contains a magic number: int sexp = exp - 896;
Magic Number,PeterO.Cbor,CBORUtilities,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORUtilities.cs,DoubleRetainsSameValueInSingle,The following statement contains a magic number: return (mant & ((1L << 29) - 1)) == 0;
Magic Number,PeterO.Cbor,CBORUtilities,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORUtilities.cs,DoubleRetainsSameValueInSingle,The following statement contains a magic number: exp == 2047
Magic Number,PeterO.Cbor,CBORUtilities,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORUtilities.cs,SingleToRoundedHalfPrecision,The following statement contains a magic number: int exp = unchecked((int)((bits >> 23) & 0xff));
Magic Number,PeterO.Cbor,CBORUtilities,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORUtilities.cs,SingleToRoundedHalfPrecision,The following statement contains a magic number: int sign = (bits >> 16) & (1 << 15);
Magic Number,PeterO.Cbor,CBORUtilities,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORUtilities.cs,SingleToRoundedHalfPrecision,The following statement contains a magic number: int sign = (bits >> 16) & (1 << 15);
Magic Number,PeterO.Cbor,CBORUtilities,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORUtilities.cs,SingleToRoundedHalfPrecision,The following statement contains a magic number: int sexp = exp - 112;
Magic Number,PeterO.Cbor,CBORUtilities,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORUtilities.cs,SingleToRoundedHalfPrecision,The following statement contains a magic number: int newmant = unchecked((int)(mant >> 13));
Magic Number,PeterO.Cbor,CBORUtilities,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORUtilities.cs,SingleToRoundedHalfPrecision,The following statement contains a magic number: exp == 255
Magic Number,PeterO.Cbor,CBORUtilities,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORUtilities.cs,DoubleToRoundedHalfPrecision,The following statement contains a magic number: int exp = unchecked((int)((bits >> 52) & 0x7ffL));
Magic Number,PeterO.Cbor,CBORUtilities,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORUtilities.cs,DoubleToRoundedHalfPrecision,The following statement contains a magic number: int sign = unchecked((int)(bits >> 48)) & (1 << 15);
Magic Number,PeterO.Cbor,CBORUtilities,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORUtilities.cs,DoubleToRoundedHalfPrecision,The following statement contains a magic number: int sign = unchecked((int)(bits >> 48)) & (1 << 15);
Magic Number,PeterO.Cbor,CBORUtilities,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORUtilities.cs,DoubleToRoundedHalfPrecision,The following statement contains a magic number: int sexp = exp - 1008;
Magic Number,PeterO.Cbor,CBORUtilities,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORUtilities.cs,DoubleToRoundedHalfPrecision,The following statement contains a magic number: int newmant = unchecked((int)(mant >> 42));
Magic Number,PeterO.Cbor,CBORUtilities,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORUtilities.cs,DoubleToRoundedHalfPrecision,The following statement contains a magic number: exp == 2047
Magic Number,PeterO.Cbor,CBORUtilities,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORUtilities.cs,DoubleToRoundedSinglePrecision,The following statement contains a magic number: int exp = unchecked((int)((bits >> 52) & 0x7ffL));
Magic Number,PeterO.Cbor,CBORUtilities,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORUtilities.cs,DoubleToRoundedSinglePrecision,The following statement contains a magic number: int sign = unchecked((int)(bits >> 32)) & (1 << 31);
Magic Number,PeterO.Cbor,CBORUtilities,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORUtilities.cs,DoubleToRoundedSinglePrecision,The following statement contains a magic number: int sign = unchecked((int)(bits >> 32)) & (1 << 31);
Magic Number,PeterO.Cbor,CBORUtilities,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORUtilities.cs,DoubleToRoundedSinglePrecision,The following statement contains a magic number: int sexp = exp - 896;
Magic Number,PeterO.Cbor,CBORUtilities,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORUtilities.cs,DoubleToRoundedSinglePrecision,The following statement contains a magic number: int newmant = unchecked((int)(mant >> 29));
Magic Number,PeterO.Cbor,CBORUtilities,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORUtilities.cs,DoubleToRoundedSinglePrecision,The following statement contains a magic number: exp == 2047
Magic Number,PeterO.Cbor,CBORUtilities,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORUtilities.cs,SingleToHalfPrecisionIfSameValue,The following statement contains a magic number: int exp = (bits >> 23) & 0xff;
Magic Number,PeterO.Cbor,CBORUtilities,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORUtilities.cs,SingleToHalfPrecisionIfSameValue,The following statement contains a magic number: int sign = (bits >> 16) & 0x8000;
Magic Number,PeterO.Cbor,CBORUtilities,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORUtilities.cs,SingleToHalfPrecisionIfSameValue,The following statement contains a magic number: return (bits & 0x1fff) == 0 ? sign + 0x7c00 + (mant >> 13) : -1;
Magic Number,PeterO.Cbor,CBORUtilities,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORUtilities.cs,SingleToHalfPrecisionIfSameValue,The following statement contains a magic number: exp == 255
Magic Number,PeterO.Cbor,CBORUtilities,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORUtilities.cs,SingleToHalfPrecisionIfSameValue,The following statement contains a magic number: exp <= 102 || exp >= 143
Magic Number,PeterO.Cbor,CBORUtilities,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORUtilities.cs,SingleToHalfPrecisionIfSameValue,The following statement contains a magic number: exp <= 102 || exp >= 143
Magic Number,PeterO.Cbor,CBORUtilities,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORUtilities.cs,SingleToDoublePrecision,The following statement contains a magic number: var negvalue = (long)((bits >> 31) & 1) << 63;
Magic Number,PeterO.Cbor,CBORUtilities,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORUtilities.cs,SingleToDoublePrecision,The following statement contains a magic number: var negvalue = (long)((bits >> 31) & 1) << 63;
Magic Number,PeterO.Cbor,CBORUtilities,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORUtilities.cs,SingleToDoublePrecision,The following statement contains a magic number: int exp = (bits >> 23) & 0xff;
Magic Number,PeterO.Cbor,CBORUtilities,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORUtilities.cs,SingleToDoublePrecision,The following statement contains a magic number: value = 0x7ff0000000000000L | ((long)mant << 29) | negvalue;
Magic Number,PeterO.Cbor,CBORUtilities,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORUtilities.cs,SingleToDoublePrecision,The following statement contains a magic number: exp == 255
Magic Number,PeterO.Cbor,CBORUtilities,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORUtilities.cs,HalfToDoublePrecision,The following statement contains a magic number: var negvalue = (long)(bits & 0x8000) << 48;
Magic Number,PeterO.Cbor,CBORUtilities,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORUtilities.cs,HalfToDoublePrecision,The following statement contains a magic number: int exp = (bits >> 10) & 31;
Magic Number,PeterO.Cbor,CBORUtilities,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORUtilities.cs,HalfToDoublePrecision,The following statement contains a magic number: int exp = (bits >> 10) & 31;
Magic Number,PeterO.Cbor,CBORUtilities,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORUtilities.cs,HalfToDoublePrecision,The following statement contains a magic number: value = 0x7ff0000000000000L | ((long)mant << 42) | negvalue;
Magic Number,PeterO.Cbor,CBORUtilities,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORUtilities.cs,HalfToDoublePrecision,The following statement contains a magic number: exp == 31
Magic Number,PeterO.Cbor,CBORUuidConverter,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORUuidConverter.cs,ValidateObject,The following statement contains a magic number: bytes.Length != 16
Magic Number,PeterO.Cbor,CBORUuidConverter,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORUuidConverter.cs,ToCBORObject,The following statement contains a magic number: return CBORObject.FromObjectAndTag(bytes' (int)37);
Magic Number,PeterO.Cbor,CBORUuidConverter,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORUuidConverter.cs,FromCBORObject,The following statement contains a magic number: !obj.HasMostOuterTag(37)
Magic Number,PeterO.Cbor,CBORUuidConverter,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORUuidConverter.cs,FromCBORObject,The following statement contains a magic number: var guidChars = new char[36];
Magic Number,PeterO.Cbor,CBORUuidConverter,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORUuidConverter.cs,FromCBORObject,The following statement contains a magic number: i == 4 || i == 6 || i == 8 || i == 10
Magic Number,PeterO.Cbor,CBORUuidConverter,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORUuidConverter.cs,FromCBORObject,The following statement contains a magic number: i == 4 || i == 6 || i == 8 || i == 10
Magic Number,PeterO.Cbor,CBORUuidConverter,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORUuidConverter.cs,FromCBORObject,The following statement contains a magic number: i == 4 || i == 6 || i == 8 || i == 10
Magic Number,PeterO.Cbor,CBORUuidConverter,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORUuidConverter.cs,FromCBORObject,The following statement contains a magic number: i == 4 || i == 6 || i == 8 || i == 10
Magic Number,PeterO.Cbor,CBORUuidConverter,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORUuidConverter.cs,FromCBORObject,The following statement contains a magic number: guidChars[index++] = hex[(int)(bytes[i] >> 4) & 15];
Magic Number,PeterO.Cbor,CBORUuidConverter,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORUuidConverter.cs,FromCBORObject,The following statement contains a magic number: guidChars[index++] = hex[(int)(bytes[i] >> 4) & 15];
Magic Number,PeterO.Cbor,CBORUuidConverter,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORUuidConverter.cs,FromCBORObject,The following statement contains a magic number: guidChars[index++] = hex[(int)bytes[i] & 15];
Magic Number,PeterO.Cbor,CBORUuidConverter,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORUuidConverter.cs,FromCBORObject,The following statement contains a magic number: i < 16
Magic Number,PeterO.Cbor,CharacterReader,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CharacterReader.cs,DetectUtf8Or16Or32,The following statement contains a magic number: return -2;
Magic Number,PeterO.Cbor,CharacterReader,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CharacterReader.cs,DetectUtf8OrUtf16,The following statement contains a magic number: return -2;
Magic Number,PeterO.Cbor,CharacterReader,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CharacterReader.cs,DetectUnicodeEncoding,The following statement contains a magic number: switch (mode) {         case 0:           // UTF-8 only           utf8reader = new Utf8Reader(this.stream' this.errorThrow);           this.reader = utf8reader;           utf8reader.Unget(c1);           c1 = utf8reader.ReadChar();           if (c1 == 0xfeff && !this.dontSkipUtf8Bom) {             // Skip BOM             c1 = utf8reader.ReadChar();           }           return c1;         case 1:         case 3:           c2 = this.DetectUtf8OrUtf16(c1);           if (c2 >= -1) {             return c2;           }           break;         case 2:         case 4:           // UTF-8' UTF-16' or UTF-32           c2 = this.DetectUtf8Or16Or32(c1);           if (c2 >= -1) {             return c2;           }           break;       }
Magic Number,PeterO.Cbor,CharacterReader,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CharacterReader.cs,DetectUnicodeEncoding,The following statement contains a magic number: switch (mode) {         case 0:           // UTF-8 only           utf8reader = new Utf8Reader(this.stream' this.errorThrow);           this.reader = utf8reader;           utf8reader.Unget(c1);           c1 = utf8reader.ReadChar();           if (c1 == 0xfeff && !this.dontSkipUtf8Bom) {             // Skip BOM             c1 = utf8reader.ReadChar();           }           return c1;         case 1:         case 3:           c2 = this.DetectUtf8OrUtf16(c1);           if (c2 >= -1) {             return c2;           }           break;         case 2:         case 4:           // UTF-8' UTF-16' or UTF-32           c2 = this.DetectUtf8Or16Or32(c1);           if (c2 >= -1) {             return c2;           }           break;       }
Magic Number,PeterO.Cbor,CharacterReader,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CharacterReader.cs,DetectUnicodeEncoding,The following statement contains a magic number: switch (mode) {         case 0:           // UTF-8 only           utf8reader = new Utf8Reader(this.stream' this.errorThrow);           this.reader = utf8reader;           utf8reader.Unget(c1);           c1 = utf8reader.ReadChar();           if (c1 == 0xfeff && !this.dontSkipUtf8Bom) {             // Skip BOM             c1 = utf8reader.ReadChar();           }           return c1;         case 1:         case 3:           c2 = this.DetectUtf8OrUtf16(c1);           if (c2 >= -1) {             return c2;           }           break;         case 2:         case 4:           // UTF-8' UTF-16' or UTF-32           c2 = this.DetectUtf8Or16Or32(c1);           if (c2 >= -1) {             return c2;           }           break;       }
Magic Number,PeterO.Cbor,SavedState,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CharacterReader.cs,Ensure,The following statement contains a magic number: var newsaved = new int[this.savedLength + size + 4];
Magic Number,PeterO.Cbor,SavedState,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CharacterReader.cs,AddTwo,The following statement contains a magic number: this.Ensure(2);
Magic Number,PeterO.Cbor,SavedState,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CharacterReader.cs,AddTwo,The following statement contains a magic number: this.savedLength += 2;
Magic Number,PeterO.Cbor,SavedState,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CharacterReader.cs,AddThree,The following statement contains a magic number: this.Ensure(3);
Magic Number,PeterO.Cbor,SavedState,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CharacterReader.cs,AddThree,The following statement contains a magic number: this.saved[this.savedLength + 2] = a;
Magic Number,PeterO.Cbor,SavedState,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CharacterReader.cs,AddThree,The following statement contains a magic number: this.savedLength += 3;
Magic Number,PeterO.Cbor,Utf16Reader,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CharacterReader.cs,ReadChar,The following statement contains a magic number: c1 = this.bigEndian ? ((c1 << 8) | c2) : ((c2 << 8) | c1);
Magic Number,PeterO.Cbor,Utf16Reader,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CharacterReader.cs,ReadChar,The following statement contains a magic number: c1 = this.bigEndian ? ((c1 << 8) | c2) : ((c2 << 8) | c1);
Magic Number,PeterO.Cbor,Utf16Reader,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CharacterReader.cs,ReadChar,The following statement contains a magic number: int unit2 = this.bigEndian ? ((c1 << 8) | c2) : ((c2 << 8) | c1);
Magic Number,PeterO.Cbor,Utf16Reader,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CharacterReader.cs,ReadChar,The following statement contains a magic number: int unit2 = this.bigEndian ? ((c1 << 8) | c2) : ((c2 << 8) | c1);
Magic Number,PeterO.Cbor,Utf16Reader,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CharacterReader.cs,ReadChar,The following statement contains a magic number: return 0x10000 + ((surr & 0x3ff) << 10) + (unit2 & 0x3ff);
Magic Number,PeterO.Cbor,Utf32Reader,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CharacterReader.cs,ReadChar,The following statement contains a magic number: c1 = this.bigEndian ? ((c1 << 24) | (c2 << 16) | (c3 << 8) | c4) :           ((c4 << 24) | (c3 << 16) | (c2 << 8) | c1);
Magic Number,PeterO.Cbor,Utf32Reader,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CharacterReader.cs,ReadChar,The following statement contains a magic number: c1 = this.bigEndian ? ((c1 << 24) | (c2 << 16) | (c3 << 8) | c4) :           ((c4 << 24) | (c3 << 16) | (c2 << 8) | c1);
Magic Number,PeterO.Cbor,Utf32Reader,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CharacterReader.cs,ReadChar,The following statement contains a magic number: c1 = this.bigEndian ? ((c1 << 24) | (c2 << 16) | (c3 << 8) | c4) :           ((c4 << 24) | (c3 << 16) | (c2 << 8) | c1);
Magic Number,PeterO.Cbor,Utf32Reader,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CharacterReader.cs,ReadChar,The following statement contains a magic number: c1 = this.bigEndian ? ((c1 << 24) | (c2 << 16) | (c3 << 8) | c4) :           ((c4 << 24) | (c3 << 16) | (c2 << 8) | c1);
Magic Number,PeterO.Cbor,Utf32Reader,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CharacterReader.cs,ReadChar,The following statement contains a magic number: c1 = this.bigEndian ? ((c1 << 24) | (c2 << 16) | (c3 << 8) | c4) :           ((c4 << 24) | (c3 << 16) | (c2 << 8) | c1);
Magic Number,PeterO.Cbor,Utf32Reader,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CharacterReader.cs,ReadChar,The following statement contains a magic number: c1 = this.bigEndian ? ((c1 << 24) | (c2 << 16) | (c3 << 8) | c4) :           ((c4 << 24) | (c3 << 16) | (c2 << 8) | c1);
Magic Number,PeterO.Cbor,Utf8Reader,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CharacterReader.cs,ReadChar,The following statement contains a magic number: cp = (b - 0xc0) << 6;
Magic Number,PeterO.Cbor,Utf8Reader,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CharacterReader.cs,ReadChar,The following statement contains a magic number: cp += (b - 0x80) << (6 * (bytesNeeded - bytesSeen));
Magic Number,PeterO.Cbor,PropertyMap,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\PropertyMap.cs,RemoveIsPrefix,The following statement contains a magic number: return CBORUtilities.NameStartsWithWord(pn' "Is") ? pn.Substring(2) :         pn;
Magic Number,PeterO.Cbor,PropertyMap,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\PropertyMap.cs,UUIDToBytes,The following statement contains a magic number: var bytes2 = new byte[16];
Magic Number,PeterO.Cbor,PropertyMap,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\PropertyMap.cs,UUIDToBytes,The following statement contains a magic number: Array.Copy(bytes' bytes2' 16);
Magic Number,PeterO.Cbor,PropertyMap,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\PropertyMap.cs,UUIDToBytes,The following statement contains a magic number: bytes2[0] = bytes[3];
Magic Number,PeterO.Cbor,PropertyMap,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\PropertyMap.cs,UUIDToBytes,The following statement contains a magic number: bytes2[1] = bytes[2];
Magic Number,PeterO.Cbor,PropertyMap,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\PropertyMap.cs,UUIDToBytes,The following statement contains a magic number: bytes2[2] = bytes[1];
Magic Number,PeterO.Cbor,PropertyMap,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\PropertyMap.cs,UUIDToBytes,The following statement contains a magic number: bytes2[3] = bytes[0];
Magic Number,PeterO.Cbor,PropertyMap,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\PropertyMap.cs,UUIDToBytes,The following statement contains a magic number: bytes2[4] = bytes[5];
Magic Number,PeterO.Cbor,PropertyMap,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\PropertyMap.cs,UUIDToBytes,The following statement contains a magic number: bytes2[4] = bytes[5];
Magic Number,PeterO.Cbor,PropertyMap,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\PropertyMap.cs,UUIDToBytes,The following statement contains a magic number: bytes2[5] = bytes[4];
Magic Number,PeterO.Cbor,PropertyMap,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\PropertyMap.cs,UUIDToBytes,The following statement contains a magic number: bytes2[5] = bytes[4];
Magic Number,PeterO.Cbor,PropertyMap,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\PropertyMap.cs,UUIDToBytes,The following statement contains a magic number: bytes2[6] = bytes[7];
Magic Number,PeterO.Cbor,PropertyMap,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\PropertyMap.cs,UUIDToBytes,The following statement contains a magic number: bytes2[6] = bytes[7];
Magic Number,PeterO.Cbor,PropertyMap,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\PropertyMap.cs,UUIDToBytes,The following statement contains a magic number: bytes2[7] = bytes[6];
Magic Number,PeterO.Cbor,PropertyMap,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\PropertyMap.cs,UUIDToBytes,The following statement contains a magic number: bytes2[7] = bytes[6];
Magic Number,PeterO.Cbor,PropertyMap,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\PropertyMap.cs,TypeToObject,The following statement contains a magic number: isDict = isDict && t.GenericTypeArguments.Length == 2;
Magic Number,PeterO.Cbor,PropertyMap,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\PropertyMap.cs,BreakDownDateTime,The following statement contains a magic number: lf[2] = dt.Hour;
Magic Number,PeterO.Cbor,PropertyMap,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\PropertyMap.cs,BreakDownDateTime,The following statement contains a magic number: lf[3] = dt.Minute;
Magic Number,PeterO.Cbor,PropertyMap,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\PropertyMap.cs,BreakDownDateTime,The following statement contains a magic number: lf[4] = dt.Second;
Magic Number,PeterO.Cbor,PropertyMap,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\PropertyMap.cs,BreakDownDateTime,The following statement contains a magic number: lf[5] = (int)(dt.Ticks % 10000000L) * 100;
Magic Number,PeterO.Cbor,PropertyMap,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\PropertyMap.cs,BreakDownDateTime,The following statement contains a magic number: lf[5] = (int)(dt.Ticks % 10000000L) * 100;
Magic Number,PeterO.Cbor,PropertyMap,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\PropertyMap.cs,BreakDownDateTime,The following statement contains a magic number: lf[5] = (int)(dt.Ticks % 10000000L) * 100;
Magic Number,PeterO.Cbor,PropertyMap,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\PropertyMap.cs,BuildUpDateTime,The following statement contains a magic number: return new DateTime(           year.ToInt32Checked()'           dt[0]'           dt[1]'           dt[2]'           dt[3]'           dt[4]'           DateTimeKind.Utc)         .AddMinutes(-dt[6]).AddTicks((long)(dt[5] / 100));
Magic Number,PeterO.Cbor,PropertyMap,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\PropertyMap.cs,BuildUpDateTime,The following statement contains a magic number: return new DateTime(           year.ToInt32Checked()'           dt[0]'           dt[1]'           dt[2]'           dt[3]'           dt[4]'           DateTimeKind.Utc)         .AddMinutes(-dt[6]).AddTicks((long)(dt[5] / 100));
Magic Number,PeterO.Cbor,PropertyMap,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\PropertyMap.cs,BuildUpDateTime,The following statement contains a magic number: return new DateTime(           year.ToInt32Checked()'           dt[0]'           dt[1]'           dt[2]'           dt[3]'           dt[4]'           DateTimeKind.Utc)         .AddMinutes(-dt[6]).AddTicks((long)(dt[5] / 100));
Magic Number,PeterO.Cbor,PropertyMap,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\PropertyMap.cs,BuildUpDateTime,The following statement contains a magic number: return new DateTime(           year.ToInt32Checked()'           dt[0]'           dt[1]'           dt[2]'           dt[3]'           dt[4]'           DateTimeKind.Utc)         .AddMinutes(-dt[6]).AddTicks((long)(dt[5] / 100));
Magic Number,PeterO.Cbor,PropertyMap,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\PropertyMap.cs,BuildUpDateTime,The following statement contains a magic number: return new DateTime(           year.ToInt32Checked()'           dt[0]'           dt[1]'           dt[2]'           dt[3]'           dt[4]'           DateTimeKind.Utc)         .AddMinutes(-dt[6]).AddTicks((long)(dt[5] / 100));
Magic Number,PeterO.Cbor,PropertyMap,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\PropertyMap.cs,BuildUpDateTime,The following statement contains a magic number: return new DateTime(           year.ToInt32Checked()'           dt[0]'           dt[1]'           dt[2]'           dt[3]'           dt[4]'           DateTimeKind.Utc)         .AddMinutes(-dt[6]).AddTicks((long)(dt[5] / 100));
Magic Number,PeterO.Cbor,PropertyData,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\PropertyMap.cs,GetAdjustedName,The following statement contains a magic number: thisName = thisName.Substring(2);
Magic Number,PeterO.Cbor,StringRefs,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\StringRefs.cs,AddStringIfNeeded,The following statement contains a magic number: addStr |= lengthHint >= 3;
Magic Number,PeterO.Cbor,StringRefs,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\StringRefs.cs,AddStringIfNeeded,The following statement contains a magic number: lastList.Count < 24
Magic Number,PeterO,DataUtilities,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\DataUtilities.cs,CodePointLength,The following statement contains a magic number: i += (c >= 0x10000) ? 2 : 1;
Magic Number,PeterO,DataUtilities,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\DataUtilities.cs,CodePointBefore,The following statement contains a magic number: return 0x10000 + ((str[index - 2] & 0x3ff) << 10) + (c & 0x3ff);
Magic Number,PeterO,DataUtilities,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\DataUtilities.cs,CodePointBefore,The following statement contains a magic number: return 0x10000 + ((str[index - 2] & 0x3ff) << 10) + (c & 0x3ff);
Magic Number,PeterO,DataUtilities,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\DataUtilities.cs,CodePointBefore,The following statement contains a magic number: (c & 0xfc00) == 0xdc00 && index - 2 >= 0 &&         (str[index - 2] & 0xfc00) == 0xd800
Magic Number,PeterO,DataUtilities,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\DataUtilities.cs,CodePointBefore,The following statement contains a magic number: (c & 0xfc00) == 0xdc00 && index - 2 >= 0 &&         (str[index - 2] & 0xfc00) == 0xd800
Magic Number,PeterO,DataUtilities,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\DataUtilities.cs,CodePointAt,The following statement contains a magic number: c = 0x10000 + ((c & 0x3ff) << 10) + (str[index + 1] & 0x3ff);
Magic Number,PeterO,DataUtilities,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\DataUtilities.cs,CodePointCompare,The following statement contains a magic number: ca = 0x10000 + ((ca & 0x3ff) << 10) + (strA[i + 1] & 0x3ff);
Magic Number,PeterO,DataUtilities,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\DataUtilities.cs,CodePointCompare,The following statement contains a magic number: cb = 0x10000 + ((cb & 0x3ff) << 10) + (strB[i + 1] & 0x3ff);
Magic Number,PeterO,DataUtilities,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\DataUtilities.cs,WriteUtf8,The following statement contains a magic number: bufferLength = Math.Min(           StreamedStringBufferLength'           bufferLength * 3);
Magic Number,PeterO,DataUtilities,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\DataUtilities.cs,WriteUtf8,The following statement contains a magic number: byteIndex + 2 > StreamedStringBufferLength
Magic Number,PeterO,DataUtilities,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\DataUtilities.cs,WriteUtf8,The following statement contains a magic number: byteIndex + 2 > StreamedStringBufferLength
Magic Number,PeterO,DataUtilities,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\DataUtilities.cs,ReadUtf8,The following statement contains a magic number: return -2;
Magic Number,PeterO,DataUtilities,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\DataUtilities.cs,ReadUtf8,The following statement contains a magic number: return -2;
Missing Default,PeterO.Cbor,CBORObject,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORObject.cs,EncodeToBytes,The following switch statement is missing a default case: switch (this.ItemType) {           case CBORObjectTypeTextString: {             byte[] ret = GetOptimizedBytesIfShortAscii(                 this.AsString()' tagged ? (((int)tagbyte) & 0xff) : -1);             if (ret != null) {               return ret;             }             break;           }           case CBORObjectTypeSimpleValue: {             if (tagged) {               var simpleBytes = new byte[] { tagbyte' (byte)0xf4 };               if (this.IsFalse) {                 simpleBytes[1] = (byte)0xf4;                 return simpleBytes;               }               if (this.IsTrue) {                 simpleBytes[1] = (byte)0xf5;                 return simpleBytes;               }               if (this.IsNull) {                 simpleBytes[1] = (byte)0xf6;                 return simpleBytes;               }               if (this.IsUndefined) {                 simpleBytes[1] = (byte)0xf7;                 return simpleBytes;               }             } else {               if (this.IsFalse) {                 return new[] { (byte)0xf4 };               }               if (this.IsTrue) {                 return new[] { (byte)0xf5 };               }               if (this.IsNull) {                 return new[] { (byte)0xf6 };               }               if (this.IsUndefined) {                 return new[] { (byte)0xf7 };               }             }             break;           }           case CBORObjectTypeInteger: {             var value = (long)this.ThisItem;             byte[] intBytes = null;             if (value >= 0) {               intBytes = GetPositiveInt64Bytes(0' value);             } else {               ++value;               value = -value; // Will never overflow               intBytes = GetPositiveInt64Bytes(1' value);             }             if (!tagged) {               return intBytes;             }             var ret2 = new byte[intBytes.Length + 1];             Array.Copy(intBytes' 0' ret2' 1' intBytes.Length);             ret2[0] = tagbyte;             return ret2;           }           case CBORObjectTypeDouble: {             return GetDoubleBytes(                 this.AsDoubleBits()'                 ((int)tagbyte) & 0xff);           }         }
Missing Default,PeterO.Cbor,CBORReader,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORReader.cs,HandleItemTag,The following switch statement is missing a default case: switch (uad) {         case 256:           // Tag 256: String namespace           this.stringRefs = this.stringRefs ?? new StringRefs();           this.stringRefs.Push();           break;         case 25:           // String reference           if (this.stringRefs == null) {             throw new CBORException("No stringref namespace");           }           break;         case 28:         case 29:           this.hasSharableObjects = true;           break;       }
Missing Default,PeterO.Cbor,CBORReader,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORReader.cs,ReadStringArrayMap,The following switch statement is missing a default case: switch (           DataUtilities.ReadUtf8 (             this.stream'             (int)uadditional'             builder'             false)) {           case -1:             throw new CBORException("Invalid UTF-8");           case -2:             throw new CBORException("Premature end of data");         }
Missing Default,PeterO.Cbor,CBORReader,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORReader.cs,ReadForFirstByte,The following switch statement is missing a default case: switch (                   DataUtilities.ReadUtf8 (                     this.stream'                     (int)len'                     builder'                     false)) {                   case -1:                     throw new CBORException("Invalid UTF-8");                   case -2:                     throw new CBORException("Premature end of data");                 }
Missing Default,PeterO.Cbor,CBORReader,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CBORReader.cs,ReadForFirstByte,The following switch statement is missing a default case: switch (uaddl) {               case 256:                 // string tag                 this.stringRefs.Pop();                 break;               case 25:                 // stringref tag                 if (o.IsTagged || o.Type != CBORType.Integer) {                   throw new CBORException("stringref must be an unsigned" +                     "\u0020integer");                 }                 return this.stringRefs.GetString(o.AsEIntegerValue());             }
Missing Default,PeterO.Cbor,CharacterReader,C:\research\architectureSmells\repos\peteroupc_CBOR\CBOR\PeterO\Cbor\CharacterReader.cs,DetectUnicodeEncoding,The following switch statement is missing a default case: switch (mode) {         case 0:           // UTF-8 only           utf8reader = new Utf8Reader(this.stream' this.errorThrow);           this.reader = utf8reader;           utf8reader.Unget(c1);           c1 = utf8reader.ReadChar();           if (c1 == 0xfeff && !this.dontSkipUtf8Bom) {             // Skip BOM             c1 = utf8reader.ReadChar();           }           return c1;         case 1:         case 3:           c2 = this.DetectUtf8OrUtf16(c1);           if (c2 >= -1) {             return c2;           }           break;         case 2:         case 4:           // UTF-8' UTF-16' or UTF-32           c2 = this.DetectUtf8Or16Or32(c1);           if (c2 >= -1) {             return c2;           }           break;       }
