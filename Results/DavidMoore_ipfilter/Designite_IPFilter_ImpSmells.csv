Implementation smell,Namespace,Class,File,Method,Description
Long Method,IPFilter.ListProviders,BlocklistMirrorProvider,F:\newReposMay17\DavidMoore_ipfilter\Code\IPFilter\ListProviders\BlocklistMirrorProvider.cs,GetMirrors,The method has 338 lines of code.
Complex Method,IPFilter.Services.Deployment,RemoveRegistryKeys,F:\newReposMay17\DavidMoore_ipfilter\Code\IPFilter\Services\Deployment\RemoveRegistryKeys.cs,Prepare,Cyclomatic complexity of the method is 8
Complex Method,IPFilter.ViewModels,MainWindowViewModel,F:\newReposMay17\DavidMoore_ipfilter\Code\IPFilter\ViewModels\MainWindowViewModel.cs,Start,Cyclomatic complexity of the method is 11
Complex Method,IPFilter.ViewModels,MainWindowViewModel,F:\newReposMay17\DavidMoore_ipfilter\Code\IPFilter\ViewModels\MainWindowViewModel.cs,StartAsync,Cyclomatic complexity of the method is 10
Complex Method,IPFilter.ViewModels,OptionsViewModel,F:\newReposMay17\DavidMoore_ipfilter\Code\IPFilter\ViewModels\OptionsViewModel.cs,SaveSettings,Cyclomatic complexity of the method is 9
Complex Method,IPFilter.Services,FilterDownloader,F:\newReposMay17\DavidMoore_ipfilter\Code\IPFilter\Services\FilterDownloader.cs,DownloadFilter,Cyclomatic complexity of the method is 17
Complex Method,IPFilter.Services,FilterDownloader,F:\newReposMay17\DavidMoore_ipfilter\Code\IPFilter\Services\FilterDownloader.cs,Decompress,Cyclomatic complexity of the method is 11
Complex Method,IPFilter.Services,FilterDownloader,F:\newReposMay17\DavidMoore_ipfilter\Code\IPFilter\Services\FilterDownloader.cs,DetectCompressionFormat,Cyclomatic complexity of the method is 15
Long Parameter List,IPFilter.Native,ProcessManager,F:\newReposMay17\DavidMoore_ipfilter\Code\IPFilter\Native\ProcessManager.cs,CreateProcess,The method has 10 parameters.
Long Parameter List,IPFilter.ViewModels,MessageBoxHelper,F:\newReposMay17\DavidMoore_ipfilter\Code\IPFilter\ViewModels\MessageBoxHelper.cs,Show,The method has 7 parameters.
Long Parameter List,IPFilter.Services,DeploymentHelper,F:\newReposMay17\DavidMoore_ipfilter\Code\IPFilter\Services\DeploymentHelper.cs,CorLaunchApplication,The method has 7 parameters.
Long Statement,IPFilter.Services.Deployment,RemoveFiles,F:\newReposMay17\DavidMoore_ipfilter\Code\IPFilter\Services\Deployment\RemoveFiles.cs,GetApps20Folder,The length of the statement  "	return IsWindowsXp () ? Path.Combine (Environment.GetFolderPath (Environment.SpecialFolder.LocalApplicationData)' @"..\Apps\2.0") : Path.Combine (Environment.GetFolderPath (Environment.SpecialFolder.LocalApplicationData)' @"Apps\2.0"); " is 235.
Long Statement,IPFilter.Services.Deployment,UninstallInfo,F:\newReposMay17\DavidMoore_ipfilter\Code\IPFilter\Services\Deployment\UninstallInfo.cs,GetPublicKeyToken,The length of the statement  "	var token = UninstallString.Split (''').First (s => s.Trim ().StartsWith ("PublicKeyToken="' StringComparison.Ordinal)).Substring (16); " is 135.
Long Statement,IPFilter.ViewModels,MessageBoxHelper,F:\newReposMay17\DavidMoore_ipfilter\Code\IPFilter\ViewModels\MessageBoxHelper.cs,Show,The length of the statement  "	var formattedMessage = args == null || args.Length == 0 ? message : string.Format (CultureInfo.CurrentCulture' message' args); " is 126.
Long Statement,IPFilter.ViewModels,MessageBoxHelper,F:\newReposMay17\DavidMoore_ipfilter\Code\IPFilter\ViewModels\MessageBoxHelper.cs,Show,The length of the statement  "	var options = CultureInfo.CurrentCulture.TextInfo.IsRightToLeft ? MessageBoxOptions.RightAlign | MessageBoxOptions.RtlReading : 0; " is 130.
Long Statement,IPFilter.ViewModels,MainWindowViewModel,F:\newReposMay17\DavidMoore_ipfilter\Code\IPFilter\ViewModels\MainWindowViewModel.cs,Start,The length of the statement  "		Task.Factory.StartNew (StartAsync' CancellationToken.None' TaskCreationOptions.None' TaskScheduler.FromCurrentSynchronizationContext ()); " is 137.
Long Statement,IPFilter.ViewModels,MainWindowViewModel,F:\newReposMay17\DavidMoore_ipfilter\Code\IPFilter\ViewModels\MainWindowViewModel.cs,StartAsync,The length of the statement  "				progress.Report (new ProgressModel (UpdateState.Cancelled' "Problem when downloading: " + filter.Exception.Message' 0)); " is 120.
Long Statement,IPFilter.ViewModels,MainWindowViewModel,F:\newReposMay17\DavidMoore_ipfilter\Code\IPFilter\ViewModels\MainWindowViewModel.cs,Initialize,The length of the statement  "		Trace.TraceInformation ("Found app {0} version {1} at {2}"' result.Description' result.Version' result.InstallLocation); " is 120.
Long Statement,IPFilter.Services,CryptoHelper,F:\newReposMay17\DavidMoore_ipfilter\Code\IPFilter\Services\CryptoHelper.cs,EncryptString,The length of the statement  "	byte[] encryptedData = ProtectedData.Protect (Encoding.Unicode.GetBytes (ToInsecureString (input))' entropy' DataProtectionScope.CurrentUser); " is 142.
Long Statement,IPFilter.Services,CryptoHelper,F:\newReposMay17\DavidMoore_ipfilter\Code\IPFilter\Services\CryptoHelper.cs,DecryptString,The length of the statement  "		byte[] decryptedData = ProtectedData.Unprotect (Convert.FromBase64String (encryptedData)' entropy' DataProtectionScope.CurrentUser); " is 132.
Long Statement,IPFilter.Services,DestinationPathsProvider,F:\newReposMay17\DavidMoore_ipfilter\Code\IPFilter\Services\DestinationPathsProvider.cs,GetDestinations,The length of the statement  "	return values.Select (Environment.ExpandEnvironmentVariables).Select (TrimSeparatorsAndWhitespace).Distinct (StringComparer.OrdinalIgnoreCase); " is 143.
Long Statement,IPFilter.Services,FilterDownloader,F:\newReposMay17\DavidMoore_ipfilter\Code\IPFilter\Services\FilterDownloader.cs,DownloadFilter,The length of the statement  "								var status = string.Format (CultureInfo.CurrentUICulture' "Downloaded {0:F2} MB of {1:F2} MB"' downloadedMegs' lengthInMb); " is 123.
Long Statement,IPFilter.Services,FilterDownloader,F:\newReposMay17\DavidMoore_ipfilter\Code\IPFilter\Services\FilterDownloader.cs,Decompress,The length of the statement  "					throw new IOException ("There is more than one file in the zip file. This application will need to be updated to support this."); " is 129.
Long Statement,IPFilter.Apps,BitTorrentApplication,F:\newReposMay17\DavidMoore_ipfilter\Code\IPFilter\Apps\BitTorrentApplication.cs,UpdateFilterAsync,The length of the statement  "	var roamingPath = Environment.GetFolderPath (Environment.SpecialFolder.ApplicationData' Environment.SpecialFolderOption.Create); " is 128.
Long Statement,IPFilter.Apps,QBitTorrent,F:\newReposMay17\DavidMoore_ipfilter\Code\IPFilter\Apps\QBitTorrent.cs,UpdateFilterAsync,The length of the statement  "	var qBittorrentIniPath = Path.Combine (Environment.GetFolderPath (Environment.SpecialFolder.ApplicationData)' "qBittorrent"' "qBittorrent.ini"); " is 144.
Long Statement,IPFilter.ListProviders,BlocklistMirrorProvider,F:\newReposMay17\DavidMoore_ipfilter\Code\IPFilter\ListProviders\BlocklistMirrorProvider.cs,GetUrlForMirror,The length of the statement  "	return string.Format (CultureInfo.CurrentCulture' "http://list.iblocklist.com/?fileformat=dat&archiveformat=gz&list={0}"' mirror.Id); " is 133.
Long Statement,IPFilter.ListProviders,SourceForgeMirrorProvider,F:\newReposMay17\DavidMoore_ipfilter\Code\IPFilter\ListProviders\SourceForgeMirrorProvider.cs,GetUrlForMirror,The length of the statement  "	return string.Format (CultureInfo.CurrentCulture' "https://downloads.sourceforge.net/sourceforge/emulepawcio/ipfilter.zip?use_mirror={0}"' mirror.Id); " is 150.
Empty Catch Block,IPFilter.Services.Deployment,RemoveFiles,F:\newReposMay17\DavidMoore_ipfilter\Code\IPFilter\Services\Deployment\RemoveFiles.cs,Execute,The method has an empty catch block.
Empty Catch Block,IPFilter.Services.Deployment,RemoveStartMenuEntry,F:\newReposMay17\DavidMoore_ipfilter\Code\IPFilter\Services\Deployment\RemoveStartMenuEntry.cs,Execute,The method has an empty catch block.
Magic Number,IPFilter.Services.Deployment,ClickOnceRegistry,F:\newReposMay17\DavidMoore_ipfilter\Code\IPFilter\Services\Deployment\ClickOnceRegistry.cs,ReadMarks,The following statement contains a magic number: foreach (var keyName in marks.GetSubKeyNames ()) {  	var markKey = marks.OpenSubKey (keyName);  	if (markKey == null)  		continue;  	var mark = new Mark {  		Key = keyName  	};  	Marks.Add (mark);  	var appid = markKey.GetValue ("appid") as byte[];  	if (appid != null)  		mark.AppId = Encoding.ASCII.GetString (appid);  	var identity = markKey.GetValue ("identity") as byte[];  	if (identity != null)  		mark.Identity = Encoding.ASCII.GetString (identity);  	mark.Implications = new List<Implication> ();  	var implications = markKey.GetValueNames ().Where (n => n.StartsWith ("implication"));  	foreach (var implicationName in implications) {  		var implication = markKey.GetValue (implicationName) as byte[];  		if (implication != null)  			mark.Implications.Add (new Implication {  				Key = implicationName'  				Name = implicationName.Substring (12)'  				Value = Encoding.ASCII.GetString (implication)  			});  	}  }  
Magic Number,IPFilter.Services.Deployment,ClickOnceRegistry,F:\newReposMay17\DavidMoore_ipfilter\Code\IPFilter\Services\Deployment\ClickOnceRegistry.cs,ReadMarks,The following statement contains a magic number: foreach (var implicationName in implications) {  	var implication = markKey.GetValue (implicationName) as byte[];  	if (implication != null)  		mark.Implications.Add (new Implication {  			Key = implicationName'  			Name = implicationName.Substring (12)'  			Value = Encoding.ASCII.GetString (implication)  		});  }  
Magic Number,IPFilter.Services.Deployment,ClickOnceRegistry,F:\newReposMay17\DavidMoore_ipfilter\Code\IPFilter\Services\Deployment\ClickOnceRegistry.cs,ReadMarks,The following statement contains a magic number: if (implication != null)  	mark.Implications.Add (new Implication {  		Key = implicationName'  		Name = implicationName.Substring (12)'  		Value = Encoding.ASCII.GetString (implication)  	});  
Magic Number,IPFilter.Services.Deployment,ClickOnceRegistry,F:\newReposMay17\DavidMoore_ipfilter\Code\IPFilter\Services\Deployment\ClickOnceRegistry.cs,ReadMarks,The following statement contains a magic number: mark.Implications.Add (new Implication {  	Key = implicationName'  	Name = implicationName.Substring (12)'  	Value = Encoding.ASCII.GetString (implication)  });  
Magic Number,IPFilter.Services.Deployment,RemoveFiles,F:\newReposMay17\DavidMoore_ipfilter\Code\IPFilter\Services\Deployment\RemoveFiles.cs,IsWindowsXp,The following statement contains a magic number: return Environment.OSVersion.Version.Major == 5;  
Magic Number,IPFilter.Services.Deployment,RemoveFiles,F:\newReposMay17\DavidMoore_ipfilter\Code\IPFilter\Services\Deployment\RemoveFiles.cs,DescendIntoSubfolders,The following statement contains a magic number: foreach (var subFolder in Directory.GetDirectories (baseFolder)) {  	if ((Path.GetFileName (subFolder) ?? string.Empty).Length == 12) {  		foreach (var subSubFolder in Directory.GetDirectories (subFolder)) {  			if ((Path.GetFileName (subSubFolder) ?? string.Empty).Length == 12) {  				return subSubFolder;  			}  		}  	}  }  
Magic Number,IPFilter.Services.Deployment,RemoveFiles,F:\newReposMay17\DavidMoore_ipfilter\Code\IPFilter\Services\Deployment\RemoveFiles.cs,DescendIntoSubfolders,The following statement contains a magic number: foreach (var subFolder in Directory.GetDirectories (baseFolder)) {  	if ((Path.GetFileName (subFolder) ?? string.Empty).Length == 12) {  		foreach (var subSubFolder in Directory.GetDirectories (subFolder)) {  			if ((Path.GetFileName (subSubFolder) ?? string.Empty).Length == 12) {  				return subSubFolder;  			}  		}  	}  }  
Magic Number,IPFilter.Services.Deployment,RemoveFiles,F:\newReposMay17\DavidMoore_ipfilter\Code\IPFilter\Services\Deployment\RemoveFiles.cs,DescendIntoSubfolders,The following statement contains a magic number: if ((Path.GetFileName (subFolder) ?? string.Empty).Length == 12) {  	foreach (var subSubFolder in Directory.GetDirectories (subFolder)) {  		if ((Path.GetFileName (subSubFolder) ?? string.Empty).Length == 12) {  			return subSubFolder;  		}  	}  }  
Magic Number,IPFilter.Services.Deployment,RemoveFiles,F:\newReposMay17\DavidMoore_ipfilter\Code\IPFilter\Services\Deployment\RemoveFiles.cs,DescendIntoSubfolders,The following statement contains a magic number: if ((Path.GetFileName (subFolder) ?? string.Empty).Length == 12) {  	foreach (var subSubFolder in Directory.GetDirectories (subFolder)) {  		if ((Path.GetFileName (subSubFolder) ?? string.Empty).Length == 12) {  			return subSubFolder;  		}  	}  }  
Magic Number,IPFilter.Services.Deployment,RemoveFiles,F:\newReposMay17\DavidMoore_ipfilter\Code\IPFilter\Services\Deployment\RemoveFiles.cs,DescendIntoSubfolders,The following statement contains a magic number: foreach (var subSubFolder in Directory.GetDirectories (subFolder)) {  	if ((Path.GetFileName (subSubFolder) ?? string.Empty).Length == 12) {  		return subSubFolder;  	}  }  
Magic Number,IPFilter.Services.Deployment,RemoveFiles,F:\newReposMay17\DavidMoore_ipfilter\Code\IPFilter\Services\Deployment\RemoveFiles.cs,DescendIntoSubfolders,The following statement contains a magic number: if ((Path.GetFileName (subSubFolder) ?? string.Empty).Length == 12) {  	return subSubFolder;  }  
Magic Number,IPFilter.Services.Deployment,UninstallInfo,F:\newReposMay17\DavidMoore_ipfilter\Code\IPFilter\Services\Deployment\UninstallInfo.cs,GetPublicKeyToken,The following statement contains a magic number: if (token.Length != 16)  	throw new ArgumentException ();  
Magic Number,IPFilter.ViewModels,MainWindowViewModel,F:\newReposMay17\DavidMoore_ipfilter\Code\IPFilter\ViewModels\MainWindowViewModel.cs,MainWindowViewModel,The following statement contains a magic number: ProgressMax = 100;  
Magic Number,IPFilter.ViewModels,MainWindowViewModel,F:\newReposMay17\DavidMoore_ipfilter\Code\IPFilter\ViewModels\MainWindowViewModel.cs,StartAsync,The following statement contains a magic number: try {  	var uri = SelectedMirrorProvider.GetUrlForMirror (SelectedFileMirror);  	using (var filter = await downloader.DownloadFilter (new Uri (uri)' cancellationToken.Token' progress)) {  		cancellationToken.Token.ThrowIfCancellationRequested ();  		if (filter == null) {  			progress.Report (new ProgressModel (UpdateState.Cancelled' "A filter wasn't downloaded successfully."' 0));  		} else if (filter.Exception != null) {  			if (filter.Exception is OperationCanceledException)  				throw filter.Exception;  			Trace.TraceError ("Problem when downloading: " + filter.Exception);  			progress.Report (new ProgressModel (UpdateState.Cancelled' "Problem when downloading: " + filter.Exception.Message' 0));  			return;  		} else {  			foreach (var application in apps) {  				Trace.TraceInformation ("Updating app {0} {1}"' application.Description' application.Version);  				await application.Application.UpdateFilterAsync (filter' cancellationToken.Token' progress);  			}  		}  		if (filter != null && filter.FilterTimestamp != null) {  			var message;  			Trace.TraceInformation (message);  			progress.Report (new ProgressModel (UpdateState.Done' message' 100));  		} else {  			Trace.TraceInformation ("Done.");  			progress.Report (new ProgressModel (UpdateState.Done' "Done"' 100));  		}  	}  } catch (OperationCanceledException) {  	Trace.TraceWarning ("Update was cancelled.");  	progress.Report (new ProgressModel (UpdateState.Cancelled' "Update was cancelled."' 0));  } catch (Exception ex) {  	Trace.TraceError ("Problem when updating: " + ex);  	progress.Report (new ProgressModel (UpdateState.Cancelled' "Problem when updating: " + ex.Message' 0));  }  
Magic Number,IPFilter.ViewModels,MainWindowViewModel,F:\newReposMay17\DavidMoore_ipfilter\Code\IPFilter\ViewModels\MainWindowViewModel.cs,StartAsync,The following statement contains a magic number: try {  	var uri = SelectedMirrorProvider.GetUrlForMirror (SelectedFileMirror);  	using (var filter = await downloader.DownloadFilter (new Uri (uri)' cancellationToken.Token' progress)) {  		cancellationToken.Token.ThrowIfCancellationRequested ();  		if (filter == null) {  			progress.Report (new ProgressModel (UpdateState.Cancelled' "A filter wasn't downloaded successfully."' 0));  		} else if (filter.Exception != null) {  			if (filter.Exception is OperationCanceledException)  				throw filter.Exception;  			Trace.TraceError ("Problem when downloading: " + filter.Exception);  			progress.Report (new ProgressModel (UpdateState.Cancelled' "Problem when downloading: " + filter.Exception.Message' 0));  			return;  		} else {  			foreach (var application in apps) {  				Trace.TraceInformation ("Updating app {0} {1}"' application.Description' application.Version);  				await application.Application.UpdateFilterAsync (filter' cancellationToken.Token' progress);  			}  		}  		if (filter != null && filter.FilterTimestamp != null) {  			var message;  			Trace.TraceInformation (message);  			progress.Report (new ProgressModel (UpdateState.Done' message' 100));  		} else {  			Trace.TraceInformation ("Done.");  			progress.Report (new ProgressModel (UpdateState.Done' "Done"' 100));  		}  	}  } catch (OperationCanceledException) {  	Trace.TraceWarning ("Update was cancelled.");  	progress.Report (new ProgressModel (UpdateState.Cancelled' "Update was cancelled."' 0));  } catch (Exception ex) {  	Trace.TraceError ("Problem when updating: " + ex);  	progress.Report (new ProgressModel (UpdateState.Cancelled' "Problem when updating: " + ex.Message' 0));  }  
Magic Number,IPFilter.ViewModels,MainWindowViewModel,F:\newReposMay17\DavidMoore_ipfilter\Code\IPFilter\ViewModels\MainWindowViewModel.cs,StartAsync,The following statement contains a magic number: using (var filter = await downloader.DownloadFilter (new Uri (uri)' cancellationToken.Token' progress)) {  	cancellationToken.Token.ThrowIfCancellationRequested ();  	if (filter == null) {  		progress.Report (new ProgressModel (UpdateState.Cancelled' "A filter wasn't downloaded successfully."' 0));  	} else if (filter.Exception != null) {  		if (filter.Exception is OperationCanceledException)  			throw filter.Exception;  		Trace.TraceError ("Problem when downloading: " + filter.Exception);  		progress.Report (new ProgressModel (UpdateState.Cancelled' "Problem when downloading: " + filter.Exception.Message' 0));  		return;  	} else {  		foreach (var application in apps) {  			Trace.TraceInformation ("Updating app {0} {1}"' application.Description' application.Version);  			await application.Application.UpdateFilterAsync (filter' cancellationToken.Token' progress);  		}  	}  	if (filter != null && filter.FilterTimestamp != null) {  		var message;  		Trace.TraceInformation (message);  		progress.Report (new ProgressModel (UpdateState.Done' message' 100));  	} else {  		Trace.TraceInformation ("Done.");  		progress.Report (new ProgressModel (UpdateState.Done' "Done"' 100));  	}  }  
Magic Number,IPFilter.ViewModels,MainWindowViewModel,F:\newReposMay17\DavidMoore_ipfilter\Code\IPFilter\ViewModels\MainWindowViewModel.cs,StartAsync,The following statement contains a magic number: using (var filter = await downloader.DownloadFilter (new Uri (uri)' cancellationToken.Token' progress)) {  	cancellationToken.Token.ThrowIfCancellationRequested ();  	if (filter == null) {  		progress.Report (new ProgressModel (UpdateState.Cancelled' "A filter wasn't downloaded successfully."' 0));  	} else if (filter.Exception != null) {  		if (filter.Exception is OperationCanceledException)  			throw filter.Exception;  		Trace.TraceError ("Problem when downloading: " + filter.Exception);  		progress.Report (new ProgressModel (UpdateState.Cancelled' "Problem when downloading: " + filter.Exception.Message' 0));  		return;  	} else {  		foreach (var application in apps) {  			Trace.TraceInformation ("Updating app {0} {1}"' application.Description' application.Version);  			await application.Application.UpdateFilterAsync (filter' cancellationToken.Token' progress);  		}  	}  	if (filter != null && filter.FilterTimestamp != null) {  		var message;  		Trace.TraceInformation (message);  		progress.Report (new ProgressModel (UpdateState.Done' message' 100));  	} else {  		Trace.TraceInformation ("Done.");  		progress.Report (new ProgressModel (UpdateState.Done' "Done"' 100));  	}  }  
Magic Number,IPFilter.ViewModels,MainWindowViewModel,F:\newReposMay17\DavidMoore_ipfilter\Code\IPFilter\ViewModels\MainWindowViewModel.cs,StartAsync,The following statement contains a magic number: if (filter != null && filter.FilterTimestamp != null) {  	var message;  	Trace.TraceInformation (message);  	progress.Report (new ProgressModel (UpdateState.Done' message' 100));  } else {  	Trace.TraceInformation ("Done.");  	progress.Report (new ProgressModel (UpdateState.Done' "Done"' 100));  }  
Magic Number,IPFilter.ViewModels,MainWindowViewModel,F:\newReposMay17\DavidMoore_ipfilter\Code\IPFilter\ViewModels\MainWindowViewModel.cs,StartAsync,The following statement contains a magic number: if (filter != null && filter.FilterTimestamp != null) {  	var message;  	Trace.TraceInformation (message);  	progress.Report (new ProgressModel (UpdateState.Done' message' 100));  } else {  	Trace.TraceInformation ("Done.");  	progress.Report (new ProgressModel (UpdateState.Done' "Done"' 100));  }  
Magic Number,IPFilter.ViewModels,MainWindowViewModel,F:\newReposMay17\DavidMoore_ipfilter\Code\IPFilter\ViewModels\MainWindowViewModel.cs,StartAsync,The following statement contains a magic number: progress.Report (new ProgressModel (UpdateState.Done' message' 100));  
Magic Number,IPFilter.ViewModels,MainWindowViewModel,F:\newReposMay17\DavidMoore_ipfilter\Code\IPFilter\ViewModels\MainWindowViewModel.cs,StartAsync,The following statement contains a magic number: progress.Report (new ProgressModel (UpdateState.Done' "Done"' 100));  
Magic Number,IPFilter.ViewModels,OptionsViewModel,F:\newReposMay17\DavidMoore_ipfilter\Code\IPFilter\ViewModels\OptionsViewModel.cs,SaveSettings,The following statement contains a magic number: try {  	Trace.TraceInformation ("Updating schedule settings...");  	const string taskPath = "IPFilter";  	// Get the service on the local machine  	using (var service = new TaskService ()) {  		if (!IsScheduleEnabled) {  			// If we're disabling the scheduling' then delete the task if it exists.  			Trace.TraceInformation ("Schedule is disabled. Removing any existing scheduled task.");  			service.RootFolder.DeleteTask (taskPath' false);  			Trace.TraceInformation ("Finished updating schedule settings.");  			return;  		}  		var identity = WindowsIdentity.GetCurrent ();  		Trace.TraceInformation ("Setting up the automatic schedule...");  		using (var task = service.NewTask ()) {  			task.RegistrationInfo.Description = "Updates the IP Filter for bit torrent clients";  			task.Triggers.Clear ();  			// Schedule for midnight' then check every x hours (6 by default).  			var trigger = new TimeTrigger (new DateTime (DateTime.Now.Year' DateTime.Now.Month' DateTime.Now.Day' 0' 0' 0));  			trigger.Repetition.Interval = TimeSpan.FromHours (ScheduleHours ?? 6);  			task.Triggers.Add (trigger);  			task.Actions.Add (new ExecAction (Process.GetCurrentProcess ().MainModule.FileName' "/silent"));  			task.Settings.RunOnlyIfNetworkAvailable = true;  			task.Settings.StartWhenAvailable = true;  			task.Settings.WakeToRun = false;  			task.Principal.RunLevel = TaskRunLevel.LUA;  			task.Principal.Id = identity.Name;  			task.Principal.LogonType = TaskLogonType.S4U;  			//task.Principal.UserId = identity.Name;  			service.RootFolder.RegisterTaskDefinition (taskPath' task' TaskCreation.CreateOrUpdate' identity.Name);  		}  		Trace.TraceInformation ("Finished scheduling automatic update.");  	}  } catch (UnauthorizedAccessException) {  	Trace.TraceError ("Can't schedule automated update' as IPFilter isn't being run as an administrator.");  	ErrorMessage = "You must be an administrator and run IPFilter elevated to schedule a task.";  } catch (Exception ex) {  	Trace.TraceError ("Couldn't schedule automated update: " + ex);  	ErrorMessage = "Couldn't schedule automated update: " + ex.Message;  }  
Magic Number,IPFilter.ViewModels,OptionsViewModel,F:\newReposMay17\DavidMoore_ipfilter\Code\IPFilter\ViewModels\OptionsViewModel.cs,SaveSettings,The following statement contains a magic number: using (var service = new TaskService ()) {  	if (!IsScheduleEnabled) {  		// If we're disabling the scheduling' then delete the task if it exists.  		Trace.TraceInformation ("Schedule is disabled. Removing any existing scheduled task.");  		service.RootFolder.DeleteTask (taskPath' false);  		Trace.TraceInformation ("Finished updating schedule settings.");  		return;  	}  	var identity = WindowsIdentity.GetCurrent ();  	Trace.TraceInformation ("Setting up the automatic schedule...");  	using (var task = service.NewTask ()) {  		task.RegistrationInfo.Description = "Updates the IP Filter for bit torrent clients";  		task.Triggers.Clear ();  		// Schedule for midnight' then check every x hours (6 by default).  		var trigger = new TimeTrigger (new DateTime (DateTime.Now.Year' DateTime.Now.Month' DateTime.Now.Day' 0' 0' 0));  		trigger.Repetition.Interval = TimeSpan.FromHours (ScheduleHours ?? 6);  		task.Triggers.Add (trigger);  		task.Actions.Add (new ExecAction (Process.GetCurrentProcess ().MainModule.FileName' "/silent"));  		task.Settings.RunOnlyIfNetworkAvailable = true;  		task.Settings.StartWhenAvailable = true;  		task.Settings.WakeToRun = false;  		task.Principal.RunLevel = TaskRunLevel.LUA;  		task.Principal.Id = identity.Name;  		task.Principal.LogonType = TaskLogonType.S4U;  		//task.Principal.UserId = identity.Name;  		service.RootFolder.RegisterTaskDefinition (taskPath' task' TaskCreation.CreateOrUpdate' identity.Name);  	}  	Trace.TraceInformation ("Finished scheduling automatic update.");  }  
Magic Number,IPFilter.ViewModels,OptionsViewModel,F:\newReposMay17\DavidMoore_ipfilter\Code\IPFilter\ViewModels\OptionsViewModel.cs,SaveSettings,The following statement contains a magic number: using (var task = service.NewTask ()) {  	task.RegistrationInfo.Description = "Updates the IP Filter for bit torrent clients";  	task.Triggers.Clear ();  	// Schedule for midnight' then check every x hours (6 by default).  	var trigger = new TimeTrigger (new DateTime (DateTime.Now.Year' DateTime.Now.Month' DateTime.Now.Day' 0' 0' 0));  	trigger.Repetition.Interval = TimeSpan.FromHours (ScheduleHours ?? 6);  	task.Triggers.Add (trigger);  	task.Actions.Add (new ExecAction (Process.GetCurrentProcess ().MainModule.FileName' "/silent"));  	task.Settings.RunOnlyIfNetworkAvailable = true;  	task.Settings.StartWhenAvailable = true;  	task.Settings.WakeToRun = false;  	task.Principal.RunLevel = TaskRunLevel.LUA;  	task.Principal.Id = identity.Name;  	task.Principal.LogonType = TaskLogonType.S4U;  	//task.Principal.UserId = identity.Name;  	service.RootFolder.RegisterTaskDefinition (taskPath' task' TaskCreation.CreateOrUpdate' identity.Name);  }  
Magic Number,IPFilter.ViewModels,OptionsViewModel,F:\newReposMay17\DavidMoore_ipfilter\Code\IPFilter\ViewModels\OptionsViewModel.cs,SaveSettings,The following statement contains a magic number: trigger.Repetition.Interval = TimeSpan.FromHours (ScheduleHours ?? 6);  
Magic Number,IPFilter.Services,DeploymentHelper,F:\newReposMay17\DavidMoore_ipfilter\Code\IPFilter\Services\DeploymentHelper.cs,Restart,The following statement contains a magic number: if (ApplicationDeployment.IsNetworkDeployed) {  	var applicationFullName = ApplicationDeployment.CurrentDeployment.UpdatedApplicationFullName;  	// TODO: Auto-detect host type  	var hostType = HostType.CorFlag;  	Application.Current.Shutdown ();  	CorLaunchApplication (hostType' applicationFullName' 0' null' 0' null' new ProcessInformation ());  } else {  	var commandLineArgs = Environment.GetCommandLineArgs ();  	var stringBuilder = new StringBuilder ((commandLineArgs.Length - 1) * 16);  	for (var index = 1; index < commandLineArgs.Length - 1; ++index) {  		stringBuilder.Append ('"');  		stringBuilder.Append (commandLineArgs [index]);  		stringBuilder.Append ("\" ");  	}  	if (commandLineArgs.Length > 1) {  		stringBuilder.Append ('"');  		stringBuilder.Append (commandLineArgs [commandLineArgs.Length - 1]);  		stringBuilder.Append ('"');  	}  	var startInfo = Process.GetCurrentProcess ().StartInfo;  	if (stringBuilder.Length > 0)  		startInfo.Arguments = stringBuilder.ToString ();  	Application.Current.Shutdown ();  	Process.Start (startInfo);  }  
Magic Number,IPFilter.Services,FilterDownloader,F:\newReposMay17\DavidMoore_ipfilter\Code\IPFilter\Services\FilterDownloader.cs,DownloadFilter,The following statement contains a magic number: try {  	if (uri == null) {  		var provider = Mirrors.First ();  		var mirror = provider.GetMirrors ().First ();  		uri = new Uri (provider.GetUrlForMirror (mirror));  	}  	result.Uri = uri.ToString ();  	using (var handler = new WebRequestHandler ()) {  		handler.AutomaticDecompression = DecompressionMethods.GZip | DecompressionMethods.Deflate;  		Trace.TraceInformation ("Downloading filter from " + result.Uri);  		using (var httpClient = new HttpClient (handler))  			using (var response = await httpClient.GetAsync (uri' HttpCompletionOption.ResponseHeadersRead' cancellationToken)) {  				if (cancellationToken.IsCancellationRequested)  					return null;  				result.FilterTimestamp = response.Content.Headers.LastModified ?? response.Headers.Date;  				result.Etag = response.Headers.ETag;  				Trace.TraceInformation ("Online filter's timestamp is " + result.FilterTimestamp);  				Trace.TraceInformation ("ETag: '{0}'"' result.Etag);  				// Check if the cached filter is already up to date.  				if (cache != null && !Settings.Default.DisableCache) {  					var cacheResult = await cache.GetAsync (result);  					if (cacheResult != null && cacheResult.Length > 0) {  						Trace.TraceInformation ("Found cached ipfilter with timestamp of " + cacheResult.FilterTimestamp);  						if (cacheResult.FilterTimestamp >= result.FilterTimestamp) {  							Trace.TraceInformation ("Using the cached ipfilter as it's the same or newer than the online filter.");  							return cacheResult;  						}  					}  				}  				result.Length = response.Content.Headers.ContentLength;  				double lengthInMb = !result.Length.HasValue ? -1 : (double)result.Length.Value / 1024 / 1024;  				double bytesDownloaded = 0;  				using (var stream = await response.Content.ReadAsStreamAsync ()) {  					var buffer = new byte[65535 * 4];  					result.Stream = new MemoryStream ((int)(result.Length ?? buffer.Length));  					int bytesRead = await stream.ReadAsync (buffer' 0' buffer.Length' cancellationToken);  					result.CompressionFormat = DetectCompressionFormat (buffer' response.Content.Headers.ContentType);  					while (bytesRead != 0) {  						await result.Stream.WriteAsync (buffer' 0' bytesRead' cancellationToken);  						bytesDownloaded += bytesRead;  						if (result.Length.HasValue) {  							double downloadedMegs = bytesDownloaded / 1024 / 1024;  							var percent = (int)Math.Floor ((bytesDownloaded / result.Length.Value) * 100);  							var status = string.Format (CultureInfo.CurrentUICulture' "Downloaded {0:F2} MB of {1:F2} MB"' downloadedMegs' lengthInMb);  							progress.Report (new ProgressModel (UpdateState.Downloading' status' percent));  						}  						if (cancellationToken.IsCancellationRequested)  							return null;  						bytesRead = await stream.ReadAsync (buffer' 0' buffer.Length' cancellationToken);  					}  				}  			}  	}  	// Decompress if necessary  	if (result.CompressionFormat != CompressionFormat.None) {  		result.Stream = await Decompress (result' cancellationToken' progress);  	}  } catch (Exception ex) {  	result.Exception = ex;  	return result;  }  
Magic Number,IPFilter.Services,FilterDownloader,F:\newReposMay17\DavidMoore_ipfilter\Code\IPFilter\Services\FilterDownloader.cs,DownloadFilter,The following statement contains a magic number: try {  	if (uri == null) {  		var provider = Mirrors.First ();  		var mirror = provider.GetMirrors ().First ();  		uri = new Uri (provider.GetUrlForMirror (mirror));  	}  	result.Uri = uri.ToString ();  	using (var handler = new WebRequestHandler ()) {  		handler.AutomaticDecompression = DecompressionMethods.GZip | DecompressionMethods.Deflate;  		Trace.TraceInformation ("Downloading filter from " + result.Uri);  		using (var httpClient = new HttpClient (handler))  			using (var response = await httpClient.GetAsync (uri' HttpCompletionOption.ResponseHeadersRead' cancellationToken)) {  				if (cancellationToken.IsCancellationRequested)  					return null;  				result.FilterTimestamp = response.Content.Headers.LastModified ?? response.Headers.Date;  				result.Etag = response.Headers.ETag;  				Trace.TraceInformation ("Online filter's timestamp is " + result.FilterTimestamp);  				Trace.TraceInformation ("ETag: '{0}'"' result.Etag);  				// Check if the cached filter is already up to date.  				if (cache != null && !Settings.Default.DisableCache) {  					var cacheResult = await cache.GetAsync (result);  					if (cacheResult != null && cacheResult.Length > 0) {  						Trace.TraceInformation ("Found cached ipfilter with timestamp of " + cacheResult.FilterTimestamp);  						if (cacheResult.FilterTimestamp >= result.FilterTimestamp) {  							Trace.TraceInformation ("Using the cached ipfilter as it's the same or newer than the online filter.");  							return cacheResult;  						}  					}  				}  				result.Length = response.Content.Headers.ContentLength;  				double lengthInMb = !result.Length.HasValue ? -1 : (double)result.Length.Value / 1024 / 1024;  				double bytesDownloaded = 0;  				using (var stream = await response.Content.ReadAsStreamAsync ()) {  					var buffer = new byte[65535 * 4];  					result.Stream = new MemoryStream ((int)(result.Length ?? buffer.Length));  					int bytesRead = await stream.ReadAsync (buffer' 0' buffer.Length' cancellationToken);  					result.CompressionFormat = DetectCompressionFormat (buffer' response.Content.Headers.ContentType);  					while (bytesRead != 0) {  						await result.Stream.WriteAsync (buffer' 0' bytesRead' cancellationToken);  						bytesDownloaded += bytesRead;  						if (result.Length.HasValue) {  							double downloadedMegs = bytesDownloaded / 1024 / 1024;  							var percent = (int)Math.Floor ((bytesDownloaded / result.Length.Value) * 100);  							var status = string.Format (CultureInfo.CurrentUICulture' "Downloaded {0:F2} MB of {1:F2} MB"' downloadedMegs' lengthInMb);  							progress.Report (new ProgressModel (UpdateState.Downloading' status' percent));  						}  						if (cancellationToken.IsCancellationRequested)  							return null;  						bytesRead = await stream.ReadAsync (buffer' 0' buffer.Length' cancellationToken);  					}  				}  			}  	}  	// Decompress if necessary  	if (result.CompressionFormat != CompressionFormat.None) {  		result.Stream = await Decompress (result' cancellationToken' progress);  	}  } catch (Exception ex) {  	result.Exception = ex;  	return result;  }  
Magic Number,IPFilter.Services,FilterDownloader,F:\newReposMay17\DavidMoore_ipfilter\Code\IPFilter\Services\FilterDownloader.cs,DownloadFilter,The following statement contains a magic number: try {  	if (uri == null) {  		var provider = Mirrors.First ();  		var mirror = provider.GetMirrors ().First ();  		uri = new Uri (provider.GetUrlForMirror (mirror));  	}  	result.Uri = uri.ToString ();  	using (var handler = new WebRequestHandler ()) {  		handler.AutomaticDecompression = DecompressionMethods.GZip | DecompressionMethods.Deflate;  		Trace.TraceInformation ("Downloading filter from " + result.Uri);  		using (var httpClient = new HttpClient (handler))  			using (var response = await httpClient.GetAsync (uri' HttpCompletionOption.ResponseHeadersRead' cancellationToken)) {  				if (cancellationToken.IsCancellationRequested)  					return null;  				result.FilterTimestamp = response.Content.Headers.LastModified ?? response.Headers.Date;  				result.Etag = response.Headers.ETag;  				Trace.TraceInformation ("Online filter's timestamp is " + result.FilterTimestamp);  				Trace.TraceInformation ("ETag: '{0}'"' result.Etag);  				// Check if the cached filter is already up to date.  				if (cache != null && !Settings.Default.DisableCache) {  					var cacheResult = await cache.GetAsync (result);  					if (cacheResult != null && cacheResult.Length > 0) {  						Trace.TraceInformation ("Found cached ipfilter with timestamp of " + cacheResult.FilterTimestamp);  						if (cacheResult.FilterTimestamp >= result.FilterTimestamp) {  							Trace.TraceInformation ("Using the cached ipfilter as it's the same or newer than the online filter.");  							return cacheResult;  						}  					}  				}  				result.Length = response.Content.Headers.ContentLength;  				double lengthInMb = !result.Length.HasValue ? -1 : (double)result.Length.Value / 1024 / 1024;  				double bytesDownloaded = 0;  				using (var stream = await response.Content.ReadAsStreamAsync ()) {  					var buffer = new byte[65535 * 4];  					result.Stream = new MemoryStream ((int)(result.Length ?? buffer.Length));  					int bytesRead = await stream.ReadAsync (buffer' 0' buffer.Length' cancellationToken);  					result.CompressionFormat = DetectCompressionFormat (buffer' response.Content.Headers.ContentType);  					while (bytesRead != 0) {  						await result.Stream.WriteAsync (buffer' 0' bytesRead' cancellationToken);  						bytesDownloaded += bytesRead;  						if (result.Length.HasValue) {  							double downloadedMegs = bytesDownloaded / 1024 / 1024;  							var percent = (int)Math.Floor ((bytesDownloaded / result.Length.Value) * 100);  							var status = string.Format (CultureInfo.CurrentUICulture' "Downloaded {0:F2} MB of {1:F2} MB"' downloadedMegs' lengthInMb);  							progress.Report (new ProgressModel (UpdateState.Downloading' status' percent));  						}  						if (cancellationToken.IsCancellationRequested)  							return null;  						bytesRead = await stream.ReadAsync (buffer' 0' buffer.Length' cancellationToken);  					}  				}  			}  	}  	// Decompress if necessary  	if (result.CompressionFormat != CompressionFormat.None) {  		result.Stream = await Decompress (result' cancellationToken' progress);  	}  } catch (Exception ex) {  	result.Exception = ex;  	return result;  }  
Magic Number,IPFilter.Services,FilterDownloader,F:\newReposMay17\DavidMoore_ipfilter\Code\IPFilter\Services\FilterDownloader.cs,DownloadFilter,The following statement contains a magic number: try {  	if (uri == null) {  		var provider = Mirrors.First ();  		var mirror = provider.GetMirrors ().First ();  		uri = new Uri (provider.GetUrlForMirror (mirror));  	}  	result.Uri = uri.ToString ();  	using (var handler = new WebRequestHandler ()) {  		handler.AutomaticDecompression = DecompressionMethods.GZip | DecompressionMethods.Deflate;  		Trace.TraceInformation ("Downloading filter from " + result.Uri);  		using (var httpClient = new HttpClient (handler))  			using (var response = await httpClient.GetAsync (uri' HttpCompletionOption.ResponseHeadersRead' cancellationToken)) {  				if (cancellationToken.IsCancellationRequested)  					return null;  				result.FilterTimestamp = response.Content.Headers.LastModified ?? response.Headers.Date;  				result.Etag = response.Headers.ETag;  				Trace.TraceInformation ("Online filter's timestamp is " + result.FilterTimestamp);  				Trace.TraceInformation ("ETag: '{0}'"' result.Etag);  				// Check if the cached filter is already up to date.  				if (cache != null && !Settings.Default.DisableCache) {  					var cacheResult = await cache.GetAsync (result);  					if (cacheResult != null && cacheResult.Length > 0) {  						Trace.TraceInformation ("Found cached ipfilter with timestamp of " + cacheResult.FilterTimestamp);  						if (cacheResult.FilterTimestamp >= result.FilterTimestamp) {  							Trace.TraceInformation ("Using the cached ipfilter as it's the same or newer than the online filter.");  							return cacheResult;  						}  					}  				}  				result.Length = response.Content.Headers.ContentLength;  				double lengthInMb = !result.Length.HasValue ? -1 : (double)result.Length.Value / 1024 / 1024;  				double bytesDownloaded = 0;  				using (var stream = await response.Content.ReadAsStreamAsync ()) {  					var buffer = new byte[65535 * 4];  					result.Stream = new MemoryStream ((int)(result.Length ?? buffer.Length));  					int bytesRead = await stream.ReadAsync (buffer' 0' buffer.Length' cancellationToken);  					result.CompressionFormat = DetectCompressionFormat (buffer' response.Content.Headers.ContentType);  					while (bytesRead != 0) {  						await result.Stream.WriteAsync (buffer' 0' bytesRead' cancellationToken);  						bytesDownloaded += bytesRead;  						if (result.Length.HasValue) {  							double downloadedMegs = bytesDownloaded / 1024 / 1024;  							var percent = (int)Math.Floor ((bytesDownloaded / result.Length.Value) * 100);  							var status = string.Format (CultureInfo.CurrentUICulture' "Downloaded {0:F2} MB of {1:F2} MB"' downloadedMegs' lengthInMb);  							progress.Report (new ProgressModel (UpdateState.Downloading' status' percent));  						}  						if (cancellationToken.IsCancellationRequested)  							return null;  						bytesRead = await stream.ReadAsync (buffer' 0' buffer.Length' cancellationToken);  					}  				}  			}  	}  	// Decompress if necessary  	if (result.CompressionFormat != CompressionFormat.None) {  		result.Stream = await Decompress (result' cancellationToken' progress);  	}  } catch (Exception ex) {  	result.Exception = ex;  	return result;  }  
Magic Number,IPFilter.Services,FilterDownloader,F:\newReposMay17\DavidMoore_ipfilter\Code\IPFilter\Services\FilterDownloader.cs,DownloadFilter,The following statement contains a magic number: try {  	if (uri == null) {  		var provider = Mirrors.First ();  		var mirror = provider.GetMirrors ().First ();  		uri = new Uri (provider.GetUrlForMirror (mirror));  	}  	result.Uri = uri.ToString ();  	using (var handler = new WebRequestHandler ()) {  		handler.AutomaticDecompression = DecompressionMethods.GZip | DecompressionMethods.Deflate;  		Trace.TraceInformation ("Downloading filter from " + result.Uri);  		using (var httpClient = new HttpClient (handler))  			using (var response = await httpClient.GetAsync (uri' HttpCompletionOption.ResponseHeadersRead' cancellationToken)) {  				if (cancellationToken.IsCancellationRequested)  					return null;  				result.FilterTimestamp = response.Content.Headers.LastModified ?? response.Headers.Date;  				result.Etag = response.Headers.ETag;  				Trace.TraceInformation ("Online filter's timestamp is " + result.FilterTimestamp);  				Trace.TraceInformation ("ETag: '{0}'"' result.Etag);  				// Check if the cached filter is already up to date.  				if (cache != null && !Settings.Default.DisableCache) {  					var cacheResult = await cache.GetAsync (result);  					if (cacheResult != null && cacheResult.Length > 0) {  						Trace.TraceInformation ("Found cached ipfilter with timestamp of " + cacheResult.FilterTimestamp);  						if (cacheResult.FilterTimestamp >= result.FilterTimestamp) {  							Trace.TraceInformation ("Using the cached ipfilter as it's the same or newer than the online filter.");  							return cacheResult;  						}  					}  				}  				result.Length = response.Content.Headers.ContentLength;  				double lengthInMb = !result.Length.HasValue ? -1 : (double)result.Length.Value / 1024 / 1024;  				double bytesDownloaded = 0;  				using (var stream = await response.Content.ReadAsStreamAsync ()) {  					var buffer = new byte[65535 * 4];  					result.Stream = new MemoryStream ((int)(result.Length ?? buffer.Length));  					int bytesRead = await stream.ReadAsync (buffer' 0' buffer.Length' cancellationToken);  					result.CompressionFormat = DetectCompressionFormat (buffer' response.Content.Headers.ContentType);  					while (bytesRead != 0) {  						await result.Stream.WriteAsync (buffer' 0' bytesRead' cancellationToken);  						bytesDownloaded += bytesRead;  						if (result.Length.HasValue) {  							double downloadedMegs = bytesDownloaded / 1024 / 1024;  							var percent = (int)Math.Floor ((bytesDownloaded / result.Length.Value) * 100);  							var status = string.Format (CultureInfo.CurrentUICulture' "Downloaded {0:F2} MB of {1:F2} MB"' downloadedMegs' lengthInMb);  							progress.Report (new ProgressModel (UpdateState.Downloading' status' percent));  						}  						if (cancellationToken.IsCancellationRequested)  							return null;  						bytesRead = await stream.ReadAsync (buffer' 0' buffer.Length' cancellationToken);  					}  				}  			}  	}  	// Decompress if necessary  	if (result.CompressionFormat != CompressionFormat.None) {  		result.Stream = await Decompress (result' cancellationToken' progress);  	}  } catch (Exception ex) {  	result.Exception = ex;  	return result;  }  
Magic Number,IPFilter.Services,FilterDownloader,F:\newReposMay17\DavidMoore_ipfilter\Code\IPFilter\Services\FilterDownloader.cs,DownloadFilter,The following statement contains a magic number: try {  	if (uri == null) {  		var provider = Mirrors.First ();  		var mirror = provider.GetMirrors ().First ();  		uri = new Uri (provider.GetUrlForMirror (mirror));  	}  	result.Uri = uri.ToString ();  	using (var handler = new WebRequestHandler ()) {  		handler.AutomaticDecompression = DecompressionMethods.GZip | DecompressionMethods.Deflate;  		Trace.TraceInformation ("Downloading filter from " + result.Uri);  		using (var httpClient = new HttpClient (handler))  			using (var response = await httpClient.GetAsync (uri' HttpCompletionOption.ResponseHeadersRead' cancellationToken)) {  				if (cancellationToken.IsCancellationRequested)  					return null;  				result.FilterTimestamp = response.Content.Headers.LastModified ?? response.Headers.Date;  				result.Etag = response.Headers.ETag;  				Trace.TraceInformation ("Online filter's timestamp is " + result.FilterTimestamp);  				Trace.TraceInformation ("ETag: '{0}'"' result.Etag);  				// Check if the cached filter is already up to date.  				if (cache != null && !Settings.Default.DisableCache) {  					var cacheResult = await cache.GetAsync (result);  					if (cacheResult != null && cacheResult.Length > 0) {  						Trace.TraceInformation ("Found cached ipfilter with timestamp of " + cacheResult.FilterTimestamp);  						if (cacheResult.FilterTimestamp >= result.FilterTimestamp) {  							Trace.TraceInformation ("Using the cached ipfilter as it's the same or newer than the online filter.");  							return cacheResult;  						}  					}  				}  				result.Length = response.Content.Headers.ContentLength;  				double lengthInMb = !result.Length.HasValue ? -1 : (double)result.Length.Value / 1024 / 1024;  				double bytesDownloaded = 0;  				using (var stream = await response.Content.ReadAsStreamAsync ()) {  					var buffer = new byte[65535 * 4];  					result.Stream = new MemoryStream ((int)(result.Length ?? buffer.Length));  					int bytesRead = await stream.ReadAsync (buffer' 0' buffer.Length' cancellationToken);  					result.CompressionFormat = DetectCompressionFormat (buffer' response.Content.Headers.ContentType);  					while (bytesRead != 0) {  						await result.Stream.WriteAsync (buffer' 0' bytesRead' cancellationToken);  						bytesDownloaded += bytesRead;  						if (result.Length.HasValue) {  							double downloadedMegs = bytesDownloaded / 1024 / 1024;  							var percent = (int)Math.Floor ((bytesDownloaded / result.Length.Value) * 100);  							var status = string.Format (CultureInfo.CurrentUICulture' "Downloaded {0:F2} MB of {1:F2} MB"' downloadedMegs' lengthInMb);  							progress.Report (new ProgressModel (UpdateState.Downloading' status' percent));  						}  						if (cancellationToken.IsCancellationRequested)  							return null;  						bytesRead = await stream.ReadAsync (buffer' 0' buffer.Length' cancellationToken);  					}  				}  			}  	}  	// Decompress if necessary  	if (result.CompressionFormat != CompressionFormat.None) {  		result.Stream = await Decompress (result' cancellationToken' progress);  	}  } catch (Exception ex) {  	result.Exception = ex;  	return result;  }  
Magic Number,IPFilter.Services,FilterDownloader,F:\newReposMay17\DavidMoore_ipfilter\Code\IPFilter\Services\FilterDownloader.cs,DownloadFilter,The following statement contains a magic number: try {  	if (uri == null) {  		var provider = Mirrors.First ();  		var mirror = provider.GetMirrors ().First ();  		uri = new Uri (provider.GetUrlForMirror (mirror));  	}  	result.Uri = uri.ToString ();  	using (var handler = new WebRequestHandler ()) {  		handler.AutomaticDecompression = DecompressionMethods.GZip | DecompressionMethods.Deflate;  		Trace.TraceInformation ("Downloading filter from " + result.Uri);  		using (var httpClient = new HttpClient (handler))  			using (var response = await httpClient.GetAsync (uri' HttpCompletionOption.ResponseHeadersRead' cancellationToken)) {  				if (cancellationToken.IsCancellationRequested)  					return null;  				result.FilterTimestamp = response.Content.Headers.LastModified ?? response.Headers.Date;  				result.Etag = response.Headers.ETag;  				Trace.TraceInformation ("Online filter's timestamp is " + result.FilterTimestamp);  				Trace.TraceInformation ("ETag: '{0}'"' result.Etag);  				// Check if the cached filter is already up to date.  				if (cache != null && !Settings.Default.DisableCache) {  					var cacheResult = await cache.GetAsync (result);  					if (cacheResult != null && cacheResult.Length > 0) {  						Trace.TraceInformation ("Found cached ipfilter with timestamp of " + cacheResult.FilterTimestamp);  						if (cacheResult.FilterTimestamp >= result.FilterTimestamp) {  							Trace.TraceInformation ("Using the cached ipfilter as it's the same or newer than the online filter.");  							return cacheResult;  						}  					}  				}  				result.Length = response.Content.Headers.ContentLength;  				double lengthInMb = !result.Length.HasValue ? -1 : (double)result.Length.Value / 1024 / 1024;  				double bytesDownloaded = 0;  				using (var stream = await response.Content.ReadAsStreamAsync ()) {  					var buffer = new byte[65535 * 4];  					result.Stream = new MemoryStream ((int)(result.Length ?? buffer.Length));  					int bytesRead = await stream.ReadAsync (buffer' 0' buffer.Length' cancellationToken);  					result.CompressionFormat = DetectCompressionFormat (buffer' response.Content.Headers.ContentType);  					while (bytesRead != 0) {  						await result.Stream.WriteAsync (buffer' 0' bytesRead' cancellationToken);  						bytesDownloaded += bytesRead;  						if (result.Length.HasValue) {  							double downloadedMegs = bytesDownloaded / 1024 / 1024;  							var percent = (int)Math.Floor ((bytesDownloaded / result.Length.Value) * 100);  							var status = string.Format (CultureInfo.CurrentUICulture' "Downloaded {0:F2} MB of {1:F2} MB"' downloadedMegs' lengthInMb);  							progress.Report (new ProgressModel (UpdateState.Downloading' status' percent));  						}  						if (cancellationToken.IsCancellationRequested)  							return null;  						bytesRead = await stream.ReadAsync (buffer' 0' buffer.Length' cancellationToken);  					}  				}  			}  	}  	// Decompress if necessary  	if (result.CompressionFormat != CompressionFormat.None) {  		result.Stream = await Decompress (result' cancellationToken' progress);  	}  } catch (Exception ex) {  	result.Exception = ex;  	return result;  }  
Magic Number,IPFilter.Services,FilterDownloader,F:\newReposMay17\DavidMoore_ipfilter\Code\IPFilter\Services\FilterDownloader.cs,DownloadFilter,The following statement contains a magic number: using (var handler = new WebRequestHandler ()) {  	handler.AutomaticDecompression = DecompressionMethods.GZip | DecompressionMethods.Deflate;  	Trace.TraceInformation ("Downloading filter from " + result.Uri);  	using (var httpClient = new HttpClient (handler))  		using (var response = await httpClient.GetAsync (uri' HttpCompletionOption.ResponseHeadersRead' cancellationToken)) {  			if (cancellationToken.IsCancellationRequested)  				return null;  			result.FilterTimestamp = response.Content.Headers.LastModified ?? response.Headers.Date;  			result.Etag = response.Headers.ETag;  			Trace.TraceInformation ("Online filter's timestamp is " + result.FilterTimestamp);  			Trace.TraceInformation ("ETag: '{0}'"' result.Etag);  			// Check if the cached filter is already up to date.  			if (cache != null && !Settings.Default.DisableCache) {  				var cacheResult = await cache.GetAsync (result);  				if (cacheResult != null && cacheResult.Length > 0) {  					Trace.TraceInformation ("Found cached ipfilter with timestamp of " + cacheResult.FilterTimestamp);  					if (cacheResult.FilterTimestamp >= result.FilterTimestamp) {  						Trace.TraceInformation ("Using the cached ipfilter as it's the same or newer than the online filter.");  						return cacheResult;  					}  				}  			}  			result.Length = response.Content.Headers.ContentLength;  			double lengthInMb = !result.Length.HasValue ? -1 : (double)result.Length.Value / 1024 / 1024;  			double bytesDownloaded = 0;  			using (var stream = await response.Content.ReadAsStreamAsync ()) {  				var buffer = new byte[65535 * 4];  				result.Stream = new MemoryStream ((int)(result.Length ?? buffer.Length));  				int bytesRead = await stream.ReadAsync (buffer' 0' buffer.Length' cancellationToken);  				result.CompressionFormat = DetectCompressionFormat (buffer' response.Content.Headers.ContentType);  				while (bytesRead != 0) {  					await result.Stream.WriteAsync (buffer' 0' bytesRead' cancellationToken);  					bytesDownloaded += bytesRead;  					if (result.Length.HasValue) {  						double downloadedMegs = bytesDownloaded / 1024 / 1024;  						var percent = (int)Math.Floor ((bytesDownloaded / result.Length.Value) * 100);  						var status = string.Format (CultureInfo.CurrentUICulture' "Downloaded {0:F2} MB of {1:F2} MB"' downloadedMegs' lengthInMb);  						progress.Report (new ProgressModel (UpdateState.Downloading' status' percent));  					}  					if (cancellationToken.IsCancellationRequested)  						return null;  					bytesRead = await stream.ReadAsync (buffer' 0' buffer.Length' cancellationToken);  				}  			}  		}  }  
Magic Number,IPFilter.Services,FilterDownloader,F:\newReposMay17\DavidMoore_ipfilter\Code\IPFilter\Services\FilterDownloader.cs,DownloadFilter,The following statement contains a magic number: using (var handler = new WebRequestHandler ()) {  	handler.AutomaticDecompression = DecompressionMethods.GZip | DecompressionMethods.Deflate;  	Trace.TraceInformation ("Downloading filter from " + result.Uri);  	using (var httpClient = new HttpClient (handler))  		using (var response = await httpClient.GetAsync (uri' HttpCompletionOption.ResponseHeadersRead' cancellationToken)) {  			if (cancellationToken.IsCancellationRequested)  				return null;  			result.FilterTimestamp = response.Content.Headers.LastModified ?? response.Headers.Date;  			result.Etag = response.Headers.ETag;  			Trace.TraceInformation ("Online filter's timestamp is " + result.FilterTimestamp);  			Trace.TraceInformation ("ETag: '{0}'"' result.Etag);  			// Check if the cached filter is already up to date.  			if (cache != null && !Settings.Default.DisableCache) {  				var cacheResult = await cache.GetAsync (result);  				if (cacheResult != null && cacheResult.Length > 0) {  					Trace.TraceInformation ("Found cached ipfilter with timestamp of " + cacheResult.FilterTimestamp);  					if (cacheResult.FilterTimestamp >= result.FilterTimestamp) {  						Trace.TraceInformation ("Using the cached ipfilter as it's the same or newer than the online filter.");  						return cacheResult;  					}  				}  			}  			result.Length = response.Content.Headers.ContentLength;  			double lengthInMb = !result.Length.HasValue ? -1 : (double)result.Length.Value / 1024 / 1024;  			double bytesDownloaded = 0;  			using (var stream = await response.Content.ReadAsStreamAsync ()) {  				var buffer = new byte[65535 * 4];  				result.Stream = new MemoryStream ((int)(result.Length ?? buffer.Length));  				int bytesRead = await stream.ReadAsync (buffer' 0' buffer.Length' cancellationToken);  				result.CompressionFormat = DetectCompressionFormat (buffer' response.Content.Headers.ContentType);  				while (bytesRead != 0) {  					await result.Stream.WriteAsync (buffer' 0' bytesRead' cancellationToken);  					bytesDownloaded += bytesRead;  					if (result.Length.HasValue) {  						double downloadedMegs = bytesDownloaded / 1024 / 1024;  						var percent = (int)Math.Floor ((bytesDownloaded / result.Length.Value) * 100);  						var status = string.Format (CultureInfo.CurrentUICulture' "Downloaded {0:F2} MB of {1:F2} MB"' downloadedMegs' lengthInMb);  						progress.Report (new ProgressModel (UpdateState.Downloading' status' percent));  					}  					if (cancellationToken.IsCancellationRequested)  						return null;  					bytesRead = await stream.ReadAsync (buffer' 0' buffer.Length' cancellationToken);  				}  			}  		}  }  
Magic Number,IPFilter.Services,FilterDownloader,F:\newReposMay17\DavidMoore_ipfilter\Code\IPFilter\Services\FilterDownloader.cs,DownloadFilter,The following statement contains a magic number: using (var handler = new WebRequestHandler ()) {  	handler.AutomaticDecompression = DecompressionMethods.GZip | DecompressionMethods.Deflate;  	Trace.TraceInformation ("Downloading filter from " + result.Uri);  	using (var httpClient = new HttpClient (handler))  		using (var response = await httpClient.GetAsync (uri' HttpCompletionOption.ResponseHeadersRead' cancellationToken)) {  			if (cancellationToken.IsCancellationRequested)  				return null;  			result.FilterTimestamp = response.Content.Headers.LastModified ?? response.Headers.Date;  			result.Etag = response.Headers.ETag;  			Trace.TraceInformation ("Online filter's timestamp is " + result.FilterTimestamp);  			Trace.TraceInformation ("ETag: '{0}'"' result.Etag);  			// Check if the cached filter is already up to date.  			if (cache != null && !Settings.Default.DisableCache) {  				var cacheResult = await cache.GetAsync (result);  				if (cacheResult != null && cacheResult.Length > 0) {  					Trace.TraceInformation ("Found cached ipfilter with timestamp of " + cacheResult.FilterTimestamp);  					if (cacheResult.FilterTimestamp >= result.FilterTimestamp) {  						Trace.TraceInformation ("Using the cached ipfilter as it's the same or newer than the online filter.");  						return cacheResult;  					}  				}  			}  			result.Length = response.Content.Headers.ContentLength;  			double lengthInMb = !result.Length.HasValue ? -1 : (double)result.Length.Value / 1024 / 1024;  			double bytesDownloaded = 0;  			using (var stream = await response.Content.ReadAsStreamAsync ()) {  				var buffer = new byte[65535 * 4];  				result.Stream = new MemoryStream ((int)(result.Length ?? buffer.Length));  				int bytesRead = await stream.ReadAsync (buffer' 0' buffer.Length' cancellationToken);  				result.CompressionFormat = DetectCompressionFormat (buffer' response.Content.Headers.ContentType);  				while (bytesRead != 0) {  					await result.Stream.WriteAsync (buffer' 0' bytesRead' cancellationToken);  					bytesDownloaded += bytesRead;  					if (result.Length.HasValue) {  						double downloadedMegs = bytesDownloaded / 1024 / 1024;  						var percent = (int)Math.Floor ((bytesDownloaded / result.Length.Value) * 100);  						var status = string.Format (CultureInfo.CurrentUICulture' "Downloaded {0:F2} MB of {1:F2} MB"' downloadedMegs' lengthInMb);  						progress.Report (new ProgressModel (UpdateState.Downloading' status' percent));  					}  					if (cancellationToken.IsCancellationRequested)  						return null;  					bytesRead = await stream.ReadAsync (buffer' 0' buffer.Length' cancellationToken);  				}  			}  		}  }  
Magic Number,IPFilter.Services,FilterDownloader,F:\newReposMay17\DavidMoore_ipfilter\Code\IPFilter\Services\FilterDownloader.cs,DownloadFilter,The following statement contains a magic number: using (var handler = new WebRequestHandler ()) {  	handler.AutomaticDecompression = DecompressionMethods.GZip | DecompressionMethods.Deflate;  	Trace.TraceInformation ("Downloading filter from " + result.Uri);  	using (var httpClient = new HttpClient (handler))  		using (var response = await httpClient.GetAsync (uri' HttpCompletionOption.ResponseHeadersRead' cancellationToken)) {  			if (cancellationToken.IsCancellationRequested)  				return null;  			result.FilterTimestamp = response.Content.Headers.LastModified ?? response.Headers.Date;  			result.Etag = response.Headers.ETag;  			Trace.TraceInformation ("Online filter's timestamp is " + result.FilterTimestamp);  			Trace.TraceInformation ("ETag: '{0}'"' result.Etag);  			// Check if the cached filter is already up to date.  			if (cache != null && !Settings.Default.DisableCache) {  				var cacheResult = await cache.GetAsync (result);  				if (cacheResult != null && cacheResult.Length > 0) {  					Trace.TraceInformation ("Found cached ipfilter with timestamp of " + cacheResult.FilterTimestamp);  					if (cacheResult.FilterTimestamp >= result.FilterTimestamp) {  						Trace.TraceInformation ("Using the cached ipfilter as it's the same or newer than the online filter.");  						return cacheResult;  					}  				}  			}  			result.Length = response.Content.Headers.ContentLength;  			double lengthInMb = !result.Length.HasValue ? -1 : (double)result.Length.Value / 1024 / 1024;  			double bytesDownloaded = 0;  			using (var stream = await response.Content.ReadAsStreamAsync ()) {  				var buffer = new byte[65535 * 4];  				result.Stream = new MemoryStream ((int)(result.Length ?? buffer.Length));  				int bytesRead = await stream.ReadAsync (buffer' 0' buffer.Length' cancellationToken);  				result.CompressionFormat = DetectCompressionFormat (buffer' response.Content.Headers.ContentType);  				while (bytesRead != 0) {  					await result.Stream.WriteAsync (buffer' 0' bytesRead' cancellationToken);  					bytesDownloaded += bytesRead;  					if (result.Length.HasValue) {  						double downloadedMegs = bytesDownloaded / 1024 / 1024;  						var percent = (int)Math.Floor ((bytesDownloaded / result.Length.Value) * 100);  						var status = string.Format (CultureInfo.CurrentUICulture' "Downloaded {0:F2} MB of {1:F2} MB"' downloadedMegs' lengthInMb);  						progress.Report (new ProgressModel (UpdateState.Downloading' status' percent));  					}  					if (cancellationToken.IsCancellationRequested)  						return null;  					bytesRead = await stream.ReadAsync (buffer' 0' buffer.Length' cancellationToken);  				}  			}  		}  }  
Magic Number,IPFilter.Services,FilterDownloader,F:\newReposMay17\DavidMoore_ipfilter\Code\IPFilter\Services\FilterDownloader.cs,DownloadFilter,The following statement contains a magic number: using (var handler = new WebRequestHandler ()) {  	handler.AutomaticDecompression = DecompressionMethods.GZip | DecompressionMethods.Deflate;  	Trace.TraceInformation ("Downloading filter from " + result.Uri);  	using (var httpClient = new HttpClient (handler))  		using (var response = await httpClient.GetAsync (uri' HttpCompletionOption.ResponseHeadersRead' cancellationToken)) {  			if (cancellationToken.IsCancellationRequested)  				return null;  			result.FilterTimestamp = response.Content.Headers.LastModified ?? response.Headers.Date;  			result.Etag = response.Headers.ETag;  			Trace.TraceInformation ("Online filter's timestamp is " + result.FilterTimestamp);  			Trace.TraceInformation ("ETag: '{0}'"' result.Etag);  			// Check if the cached filter is already up to date.  			if (cache != null && !Settings.Default.DisableCache) {  				var cacheResult = await cache.GetAsync (result);  				if (cacheResult != null && cacheResult.Length > 0) {  					Trace.TraceInformation ("Found cached ipfilter with timestamp of " + cacheResult.FilterTimestamp);  					if (cacheResult.FilterTimestamp >= result.FilterTimestamp) {  						Trace.TraceInformation ("Using the cached ipfilter as it's the same or newer than the online filter.");  						return cacheResult;  					}  				}  			}  			result.Length = response.Content.Headers.ContentLength;  			double lengthInMb = !result.Length.HasValue ? -1 : (double)result.Length.Value / 1024 / 1024;  			double bytesDownloaded = 0;  			using (var stream = await response.Content.ReadAsStreamAsync ()) {  				var buffer = new byte[65535 * 4];  				result.Stream = new MemoryStream ((int)(result.Length ?? buffer.Length));  				int bytesRead = await stream.ReadAsync (buffer' 0' buffer.Length' cancellationToken);  				result.CompressionFormat = DetectCompressionFormat (buffer' response.Content.Headers.ContentType);  				while (bytesRead != 0) {  					await result.Stream.WriteAsync (buffer' 0' bytesRead' cancellationToken);  					bytesDownloaded += bytesRead;  					if (result.Length.HasValue) {  						double downloadedMegs = bytesDownloaded / 1024 / 1024;  						var percent = (int)Math.Floor ((bytesDownloaded / result.Length.Value) * 100);  						var status = string.Format (CultureInfo.CurrentUICulture' "Downloaded {0:F2} MB of {1:F2} MB"' downloadedMegs' lengthInMb);  						progress.Report (new ProgressModel (UpdateState.Downloading' status' percent));  					}  					if (cancellationToken.IsCancellationRequested)  						return null;  					bytesRead = await stream.ReadAsync (buffer' 0' buffer.Length' cancellationToken);  				}  			}  		}  }  
Magic Number,IPFilter.Services,FilterDownloader,F:\newReposMay17\DavidMoore_ipfilter\Code\IPFilter\Services\FilterDownloader.cs,DownloadFilter,The following statement contains a magic number: using (var handler = new WebRequestHandler ()) {  	handler.AutomaticDecompression = DecompressionMethods.GZip | DecompressionMethods.Deflate;  	Trace.TraceInformation ("Downloading filter from " + result.Uri);  	using (var httpClient = new HttpClient (handler))  		using (var response = await httpClient.GetAsync (uri' HttpCompletionOption.ResponseHeadersRead' cancellationToken)) {  			if (cancellationToken.IsCancellationRequested)  				return null;  			result.FilterTimestamp = response.Content.Headers.LastModified ?? response.Headers.Date;  			result.Etag = response.Headers.ETag;  			Trace.TraceInformation ("Online filter's timestamp is " + result.FilterTimestamp);  			Trace.TraceInformation ("ETag: '{0}'"' result.Etag);  			// Check if the cached filter is already up to date.  			if (cache != null && !Settings.Default.DisableCache) {  				var cacheResult = await cache.GetAsync (result);  				if (cacheResult != null && cacheResult.Length > 0) {  					Trace.TraceInformation ("Found cached ipfilter with timestamp of " + cacheResult.FilterTimestamp);  					if (cacheResult.FilterTimestamp >= result.FilterTimestamp) {  						Trace.TraceInformation ("Using the cached ipfilter as it's the same or newer than the online filter.");  						return cacheResult;  					}  				}  			}  			result.Length = response.Content.Headers.ContentLength;  			double lengthInMb = !result.Length.HasValue ? -1 : (double)result.Length.Value / 1024 / 1024;  			double bytesDownloaded = 0;  			using (var stream = await response.Content.ReadAsStreamAsync ()) {  				var buffer = new byte[65535 * 4];  				result.Stream = new MemoryStream ((int)(result.Length ?? buffer.Length));  				int bytesRead = await stream.ReadAsync (buffer' 0' buffer.Length' cancellationToken);  				result.CompressionFormat = DetectCompressionFormat (buffer' response.Content.Headers.ContentType);  				while (bytesRead != 0) {  					await result.Stream.WriteAsync (buffer' 0' bytesRead' cancellationToken);  					bytesDownloaded += bytesRead;  					if (result.Length.HasValue) {  						double downloadedMegs = bytesDownloaded / 1024 / 1024;  						var percent = (int)Math.Floor ((bytesDownloaded / result.Length.Value) * 100);  						var status = string.Format (CultureInfo.CurrentUICulture' "Downloaded {0:F2} MB of {1:F2} MB"' downloadedMegs' lengthInMb);  						progress.Report (new ProgressModel (UpdateState.Downloading' status' percent));  					}  					if (cancellationToken.IsCancellationRequested)  						return null;  					bytesRead = await stream.ReadAsync (buffer' 0' buffer.Length' cancellationToken);  				}  			}  		}  }  
Magic Number,IPFilter.Services,FilterDownloader,F:\newReposMay17\DavidMoore_ipfilter\Code\IPFilter\Services\FilterDownloader.cs,DownloadFilter,The following statement contains a magic number: using (var handler = new WebRequestHandler ()) {  	handler.AutomaticDecompression = DecompressionMethods.GZip | DecompressionMethods.Deflate;  	Trace.TraceInformation ("Downloading filter from " + result.Uri);  	using (var httpClient = new HttpClient (handler))  		using (var response = await httpClient.GetAsync (uri' HttpCompletionOption.ResponseHeadersRead' cancellationToken)) {  			if (cancellationToken.IsCancellationRequested)  				return null;  			result.FilterTimestamp = response.Content.Headers.LastModified ?? response.Headers.Date;  			result.Etag = response.Headers.ETag;  			Trace.TraceInformation ("Online filter's timestamp is " + result.FilterTimestamp);  			Trace.TraceInformation ("ETag: '{0}'"' result.Etag);  			// Check if the cached filter is already up to date.  			if (cache != null && !Settings.Default.DisableCache) {  				var cacheResult = await cache.GetAsync (result);  				if (cacheResult != null && cacheResult.Length > 0) {  					Trace.TraceInformation ("Found cached ipfilter with timestamp of " + cacheResult.FilterTimestamp);  					if (cacheResult.FilterTimestamp >= result.FilterTimestamp) {  						Trace.TraceInformation ("Using the cached ipfilter as it's the same or newer than the online filter.");  						return cacheResult;  					}  				}  			}  			result.Length = response.Content.Headers.ContentLength;  			double lengthInMb = !result.Length.HasValue ? -1 : (double)result.Length.Value / 1024 / 1024;  			double bytesDownloaded = 0;  			using (var stream = await response.Content.ReadAsStreamAsync ()) {  				var buffer = new byte[65535 * 4];  				result.Stream = new MemoryStream ((int)(result.Length ?? buffer.Length));  				int bytesRead = await stream.ReadAsync (buffer' 0' buffer.Length' cancellationToken);  				result.CompressionFormat = DetectCompressionFormat (buffer' response.Content.Headers.ContentType);  				while (bytesRead != 0) {  					await result.Stream.WriteAsync (buffer' 0' bytesRead' cancellationToken);  					bytesDownloaded += bytesRead;  					if (result.Length.HasValue) {  						double downloadedMegs = bytesDownloaded / 1024 / 1024;  						var percent = (int)Math.Floor ((bytesDownloaded / result.Length.Value) * 100);  						var status = string.Format (CultureInfo.CurrentUICulture' "Downloaded {0:F2} MB of {1:F2} MB"' downloadedMegs' lengthInMb);  						progress.Report (new ProgressModel (UpdateState.Downloading' status' percent));  					}  					if (cancellationToken.IsCancellationRequested)  						return null;  					bytesRead = await stream.ReadAsync (buffer' 0' buffer.Length' cancellationToken);  				}  			}  		}  }  
Magic Number,IPFilter.Services,FilterDownloader,F:\newReposMay17\DavidMoore_ipfilter\Code\IPFilter\Services\FilterDownloader.cs,DownloadFilter,The following statement contains a magic number: using (var httpClient = new HttpClient (handler))  	using (var response = await httpClient.GetAsync (uri' HttpCompletionOption.ResponseHeadersRead' cancellationToken)) {  		if (cancellationToken.IsCancellationRequested)  			return null;  		result.FilterTimestamp = response.Content.Headers.LastModified ?? response.Headers.Date;  		result.Etag = response.Headers.ETag;  		Trace.TraceInformation ("Online filter's timestamp is " + result.FilterTimestamp);  		Trace.TraceInformation ("ETag: '{0}'"' result.Etag);  		// Check if the cached filter is already up to date.  		if (cache != null && !Settings.Default.DisableCache) {  			var cacheResult = await cache.GetAsync (result);  			if (cacheResult != null && cacheResult.Length > 0) {  				Trace.TraceInformation ("Found cached ipfilter with timestamp of " + cacheResult.FilterTimestamp);  				if (cacheResult.FilterTimestamp >= result.FilterTimestamp) {  					Trace.TraceInformation ("Using the cached ipfilter as it's the same or newer than the online filter.");  					return cacheResult;  				}  			}  		}  		result.Length = response.Content.Headers.ContentLength;  		double lengthInMb = !result.Length.HasValue ? -1 : (double)result.Length.Value / 1024 / 1024;  		double bytesDownloaded = 0;  		using (var stream = await response.Content.ReadAsStreamAsync ()) {  			var buffer = new byte[65535 * 4];  			result.Stream = new MemoryStream ((int)(result.Length ?? buffer.Length));  			int bytesRead = await stream.ReadAsync (buffer' 0' buffer.Length' cancellationToken);  			result.CompressionFormat = DetectCompressionFormat (buffer' response.Content.Headers.ContentType);  			while (bytesRead != 0) {  				await result.Stream.WriteAsync (buffer' 0' bytesRead' cancellationToken);  				bytesDownloaded += bytesRead;  				if (result.Length.HasValue) {  					double downloadedMegs = bytesDownloaded / 1024 / 1024;  					var percent = (int)Math.Floor ((bytesDownloaded / result.Length.Value) * 100);  					var status = string.Format (CultureInfo.CurrentUICulture' "Downloaded {0:F2} MB of {1:F2} MB"' downloadedMegs' lengthInMb);  					progress.Report (new ProgressModel (UpdateState.Downloading' status' percent));  				}  				if (cancellationToken.IsCancellationRequested)  					return null;  				bytesRead = await stream.ReadAsync (buffer' 0' buffer.Length' cancellationToken);  			}  		}  	}  
Magic Number,IPFilter.Services,FilterDownloader,F:\newReposMay17\DavidMoore_ipfilter\Code\IPFilter\Services\FilterDownloader.cs,DownloadFilter,The following statement contains a magic number: using (var httpClient = new HttpClient (handler))  	using (var response = await httpClient.GetAsync (uri' HttpCompletionOption.ResponseHeadersRead' cancellationToken)) {  		if (cancellationToken.IsCancellationRequested)  			return null;  		result.FilterTimestamp = response.Content.Headers.LastModified ?? response.Headers.Date;  		result.Etag = response.Headers.ETag;  		Trace.TraceInformation ("Online filter's timestamp is " + result.FilterTimestamp);  		Trace.TraceInformation ("ETag: '{0}'"' result.Etag);  		// Check if the cached filter is already up to date.  		if (cache != null && !Settings.Default.DisableCache) {  			var cacheResult = await cache.GetAsync (result);  			if (cacheResult != null && cacheResult.Length > 0) {  				Trace.TraceInformation ("Found cached ipfilter with timestamp of " + cacheResult.FilterTimestamp);  				if (cacheResult.FilterTimestamp >= result.FilterTimestamp) {  					Trace.TraceInformation ("Using the cached ipfilter as it's the same or newer than the online filter.");  					return cacheResult;  				}  			}  		}  		result.Length = response.Content.Headers.ContentLength;  		double lengthInMb = !result.Length.HasValue ? -1 : (double)result.Length.Value / 1024 / 1024;  		double bytesDownloaded = 0;  		using (var stream = await response.Content.ReadAsStreamAsync ()) {  			var buffer = new byte[65535 * 4];  			result.Stream = new MemoryStream ((int)(result.Length ?? buffer.Length));  			int bytesRead = await stream.ReadAsync (buffer' 0' buffer.Length' cancellationToken);  			result.CompressionFormat = DetectCompressionFormat (buffer' response.Content.Headers.ContentType);  			while (bytesRead != 0) {  				await result.Stream.WriteAsync (buffer' 0' bytesRead' cancellationToken);  				bytesDownloaded += bytesRead;  				if (result.Length.HasValue) {  					double downloadedMegs = bytesDownloaded / 1024 / 1024;  					var percent = (int)Math.Floor ((bytesDownloaded / result.Length.Value) * 100);  					var status = string.Format (CultureInfo.CurrentUICulture' "Downloaded {0:F2} MB of {1:F2} MB"' downloadedMegs' lengthInMb);  					progress.Report (new ProgressModel (UpdateState.Downloading' status' percent));  				}  				if (cancellationToken.IsCancellationRequested)  					return null;  				bytesRead = await stream.ReadAsync (buffer' 0' buffer.Length' cancellationToken);  			}  		}  	}  
Magic Number,IPFilter.Services,FilterDownloader,F:\newReposMay17\DavidMoore_ipfilter\Code\IPFilter\Services\FilterDownloader.cs,DownloadFilter,The following statement contains a magic number: using (var httpClient = new HttpClient (handler))  	using (var response = await httpClient.GetAsync (uri' HttpCompletionOption.ResponseHeadersRead' cancellationToken)) {  		if (cancellationToken.IsCancellationRequested)  			return null;  		result.FilterTimestamp = response.Content.Headers.LastModified ?? response.Headers.Date;  		result.Etag = response.Headers.ETag;  		Trace.TraceInformation ("Online filter's timestamp is " + result.FilterTimestamp);  		Trace.TraceInformation ("ETag: '{0}'"' result.Etag);  		// Check if the cached filter is already up to date.  		if (cache != null && !Settings.Default.DisableCache) {  			var cacheResult = await cache.GetAsync (result);  			if (cacheResult != null && cacheResult.Length > 0) {  				Trace.TraceInformation ("Found cached ipfilter with timestamp of " + cacheResult.FilterTimestamp);  				if (cacheResult.FilterTimestamp >= result.FilterTimestamp) {  					Trace.TraceInformation ("Using the cached ipfilter as it's the same or newer than the online filter.");  					return cacheResult;  				}  			}  		}  		result.Length = response.Content.Headers.ContentLength;  		double lengthInMb = !result.Length.HasValue ? -1 : (double)result.Length.Value / 1024 / 1024;  		double bytesDownloaded = 0;  		using (var stream = await response.Content.ReadAsStreamAsync ()) {  			var buffer = new byte[65535 * 4];  			result.Stream = new MemoryStream ((int)(result.Length ?? buffer.Length));  			int bytesRead = await stream.ReadAsync (buffer' 0' buffer.Length' cancellationToken);  			result.CompressionFormat = DetectCompressionFormat (buffer' response.Content.Headers.ContentType);  			while (bytesRead != 0) {  				await result.Stream.WriteAsync (buffer' 0' bytesRead' cancellationToken);  				bytesDownloaded += bytesRead;  				if (result.Length.HasValue) {  					double downloadedMegs = bytesDownloaded / 1024 / 1024;  					var percent = (int)Math.Floor ((bytesDownloaded / result.Length.Value) * 100);  					var status = string.Format (CultureInfo.CurrentUICulture' "Downloaded {0:F2} MB of {1:F2} MB"' downloadedMegs' lengthInMb);  					progress.Report (new ProgressModel (UpdateState.Downloading' status' percent));  				}  				if (cancellationToken.IsCancellationRequested)  					return null;  				bytesRead = await stream.ReadAsync (buffer' 0' buffer.Length' cancellationToken);  			}  		}  	}  
Magic Number,IPFilter.Services,FilterDownloader,F:\newReposMay17\DavidMoore_ipfilter\Code\IPFilter\Services\FilterDownloader.cs,DownloadFilter,The following statement contains a magic number: using (var httpClient = new HttpClient (handler))  	using (var response = await httpClient.GetAsync (uri' HttpCompletionOption.ResponseHeadersRead' cancellationToken)) {  		if (cancellationToken.IsCancellationRequested)  			return null;  		result.FilterTimestamp = response.Content.Headers.LastModified ?? response.Headers.Date;  		result.Etag = response.Headers.ETag;  		Trace.TraceInformation ("Online filter's timestamp is " + result.FilterTimestamp);  		Trace.TraceInformation ("ETag: '{0}'"' result.Etag);  		// Check if the cached filter is already up to date.  		if (cache != null && !Settings.Default.DisableCache) {  			var cacheResult = await cache.GetAsync (result);  			if (cacheResult != null && cacheResult.Length > 0) {  				Trace.TraceInformation ("Found cached ipfilter with timestamp of " + cacheResult.FilterTimestamp);  				if (cacheResult.FilterTimestamp >= result.FilterTimestamp) {  					Trace.TraceInformation ("Using the cached ipfilter as it's the same or newer than the online filter.");  					return cacheResult;  				}  			}  		}  		result.Length = response.Content.Headers.ContentLength;  		double lengthInMb = !result.Length.HasValue ? -1 : (double)result.Length.Value / 1024 / 1024;  		double bytesDownloaded = 0;  		using (var stream = await response.Content.ReadAsStreamAsync ()) {  			var buffer = new byte[65535 * 4];  			result.Stream = new MemoryStream ((int)(result.Length ?? buffer.Length));  			int bytesRead = await stream.ReadAsync (buffer' 0' buffer.Length' cancellationToken);  			result.CompressionFormat = DetectCompressionFormat (buffer' response.Content.Headers.ContentType);  			while (bytesRead != 0) {  				await result.Stream.WriteAsync (buffer' 0' bytesRead' cancellationToken);  				bytesDownloaded += bytesRead;  				if (result.Length.HasValue) {  					double downloadedMegs = bytesDownloaded / 1024 / 1024;  					var percent = (int)Math.Floor ((bytesDownloaded / result.Length.Value) * 100);  					var status = string.Format (CultureInfo.CurrentUICulture' "Downloaded {0:F2} MB of {1:F2} MB"' downloadedMegs' lengthInMb);  					progress.Report (new ProgressModel (UpdateState.Downloading' status' percent));  				}  				if (cancellationToken.IsCancellationRequested)  					return null;  				bytesRead = await stream.ReadAsync (buffer' 0' buffer.Length' cancellationToken);  			}  		}  	}  
Magic Number,IPFilter.Services,FilterDownloader,F:\newReposMay17\DavidMoore_ipfilter\Code\IPFilter\Services\FilterDownloader.cs,DownloadFilter,The following statement contains a magic number: using (var httpClient = new HttpClient (handler))  	using (var response = await httpClient.GetAsync (uri' HttpCompletionOption.ResponseHeadersRead' cancellationToken)) {  		if (cancellationToken.IsCancellationRequested)  			return null;  		result.FilterTimestamp = response.Content.Headers.LastModified ?? response.Headers.Date;  		result.Etag = response.Headers.ETag;  		Trace.TraceInformation ("Online filter's timestamp is " + result.FilterTimestamp);  		Trace.TraceInformation ("ETag: '{0}'"' result.Etag);  		// Check if the cached filter is already up to date.  		if (cache != null && !Settings.Default.DisableCache) {  			var cacheResult = await cache.GetAsync (result);  			if (cacheResult != null && cacheResult.Length > 0) {  				Trace.TraceInformation ("Found cached ipfilter with timestamp of " + cacheResult.FilterTimestamp);  				if (cacheResult.FilterTimestamp >= result.FilterTimestamp) {  					Trace.TraceInformation ("Using the cached ipfilter as it's the same or newer than the online filter.");  					return cacheResult;  				}  			}  		}  		result.Length = response.Content.Headers.ContentLength;  		double lengthInMb = !result.Length.HasValue ? -1 : (double)result.Length.Value / 1024 / 1024;  		double bytesDownloaded = 0;  		using (var stream = await response.Content.ReadAsStreamAsync ()) {  			var buffer = new byte[65535 * 4];  			result.Stream = new MemoryStream ((int)(result.Length ?? buffer.Length));  			int bytesRead = await stream.ReadAsync (buffer' 0' buffer.Length' cancellationToken);  			result.CompressionFormat = DetectCompressionFormat (buffer' response.Content.Headers.ContentType);  			while (bytesRead != 0) {  				await result.Stream.WriteAsync (buffer' 0' bytesRead' cancellationToken);  				bytesDownloaded += bytesRead;  				if (result.Length.HasValue) {  					double downloadedMegs = bytesDownloaded / 1024 / 1024;  					var percent = (int)Math.Floor ((bytesDownloaded / result.Length.Value) * 100);  					var status = string.Format (CultureInfo.CurrentUICulture' "Downloaded {0:F2} MB of {1:F2} MB"' downloadedMegs' lengthInMb);  					progress.Report (new ProgressModel (UpdateState.Downloading' status' percent));  				}  				if (cancellationToken.IsCancellationRequested)  					return null;  				bytesRead = await stream.ReadAsync (buffer' 0' buffer.Length' cancellationToken);  			}  		}  	}  
Magic Number,IPFilter.Services,FilterDownloader,F:\newReposMay17\DavidMoore_ipfilter\Code\IPFilter\Services\FilterDownloader.cs,DownloadFilter,The following statement contains a magic number: using (var httpClient = new HttpClient (handler))  	using (var response = await httpClient.GetAsync (uri' HttpCompletionOption.ResponseHeadersRead' cancellationToken)) {  		if (cancellationToken.IsCancellationRequested)  			return null;  		result.FilterTimestamp = response.Content.Headers.LastModified ?? response.Headers.Date;  		result.Etag = response.Headers.ETag;  		Trace.TraceInformation ("Online filter's timestamp is " + result.FilterTimestamp);  		Trace.TraceInformation ("ETag: '{0}'"' result.Etag);  		// Check if the cached filter is already up to date.  		if (cache != null && !Settings.Default.DisableCache) {  			var cacheResult = await cache.GetAsync (result);  			if (cacheResult != null && cacheResult.Length > 0) {  				Trace.TraceInformation ("Found cached ipfilter with timestamp of " + cacheResult.FilterTimestamp);  				if (cacheResult.FilterTimestamp >= result.FilterTimestamp) {  					Trace.TraceInformation ("Using the cached ipfilter as it's the same or newer than the online filter.");  					return cacheResult;  				}  			}  		}  		result.Length = response.Content.Headers.ContentLength;  		double lengthInMb = !result.Length.HasValue ? -1 : (double)result.Length.Value / 1024 / 1024;  		double bytesDownloaded = 0;  		using (var stream = await response.Content.ReadAsStreamAsync ()) {  			var buffer = new byte[65535 * 4];  			result.Stream = new MemoryStream ((int)(result.Length ?? buffer.Length));  			int bytesRead = await stream.ReadAsync (buffer' 0' buffer.Length' cancellationToken);  			result.CompressionFormat = DetectCompressionFormat (buffer' response.Content.Headers.ContentType);  			while (bytesRead != 0) {  				await result.Stream.WriteAsync (buffer' 0' bytesRead' cancellationToken);  				bytesDownloaded += bytesRead;  				if (result.Length.HasValue) {  					double downloadedMegs = bytesDownloaded / 1024 / 1024;  					var percent = (int)Math.Floor ((bytesDownloaded / result.Length.Value) * 100);  					var status = string.Format (CultureInfo.CurrentUICulture' "Downloaded {0:F2} MB of {1:F2} MB"' downloadedMegs' lengthInMb);  					progress.Report (new ProgressModel (UpdateState.Downloading' status' percent));  				}  				if (cancellationToken.IsCancellationRequested)  					return null;  				bytesRead = await stream.ReadAsync (buffer' 0' buffer.Length' cancellationToken);  			}  		}  	}  
Magic Number,IPFilter.Services,FilterDownloader,F:\newReposMay17\DavidMoore_ipfilter\Code\IPFilter\Services\FilterDownloader.cs,DownloadFilter,The following statement contains a magic number: using (var httpClient = new HttpClient (handler))  	using (var response = await httpClient.GetAsync (uri' HttpCompletionOption.ResponseHeadersRead' cancellationToken)) {  		if (cancellationToken.IsCancellationRequested)  			return null;  		result.FilterTimestamp = response.Content.Headers.LastModified ?? response.Headers.Date;  		result.Etag = response.Headers.ETag;  		Trace.TraceInformation ("Online filter's timestamp is " + result.FilterTimestamp);  		Trace.TraceInformation ("ETag: '{0}'"' result.Etag);  		// Check if the cached filter is already up to date.  		if (cache != null && !Settings.Default.DisableCache) {  			var cacheResult = await cache.GetAsync (result);  			if (cacheResult != null && cacheResult.Length > 0) {  				Trace.TraceInformation ("Found cached ipfilter with timestamp of " + cacheResult.FilterTimestamp);  				if (cacheResult.FilterTimestamp >= result.FilterTimestamp) {  					Trace.TraceInformation ("Using the cached ipfilter as it's the same or newer than the online filter.");  					return cacheResult;  				}  			}  		}  		result.Length = response.Content.Headers.ContentLength;  		double lengthInMb = !result.Length.HasValue ? -1 : (double)result.Length.Value / 1024 / 1024;  		double bytesDownloaded = 0;  		using (var stream = await response.Content.ReadAsStreamAsync ()) {  			var buffer = new byte[65535 * 4];  			result.Stream = new MemoryStream ((int)(result.Length ?? buffer.Length));  			int bytesRead = await stream.ReadAsync (buffer' 0' buffer.Length' cancellationToken);  			result.CompressionFormat = DetectCompressionFormat (buffer' response.Content.Headers.ContentType);  			while (bytesRead != 0) {  				await result.Stream.WriteAsync (buffer' 0' bytesRead' cancellationToken);  				bytesDownloaded += bytesRead;  				if (result.Length.HasValue) {  					double downloadedMegs = bytesDownloaded / 1024 / 1024;  					var percent = (int)Math.Floor ((bytesDownloaded / result.Length.Value) * 100);  					var status = string.Format (CultureInfo.CurrentUICulture' "Downloaded {0:F2} MB of {1:F2} MB"' downloadedMegs' lengthInMb);  					progress.Report (new ProgressModel (UpdateState.Downloading' status' percent));  				}  				if (cancellationToken.IsCancellationRequested)  					return null;  				bytesRead = await stream.ReadAsync (buffer' 0' buffer.Length' cancellationToken);  			}  		}  	}  
Magic Number,IPFilter.Services,FilterDownloader,F:\newReposMay17\DavidMoore_ipfilter\Code\IPFilter\Services\FilterDownloader.cs,DownloadFilter,The following statement contains a magic number: using (var response = await httpClient.GetAsync (uri' HttpCompletionOption.ResponseHeadersRead' cancellationToken)) {  	if (cancellationToken.IsCancellationRequested)  		return null;  	result.FilterTimestamp = response.Content.Headers.LastModified ?? response.Headers.Date;  	result.Etag = response.Headers.ETag;  	Trace.TraceInformation ("Online filter's timestamp is " + result.FilterTimestamp);  	Trace.TraceInformation ("ETag: '{0}'"' result.Etag);  	// Check if the cached filter is already up to date.  	if (cache != null && !Settings.Default.DisableCache) {  		var cacheResult = await cache.GetAsync (result);  		if (cacheResult != null && cacheResult.Length > 0) {  			Trace.TraceInformation ("Found cached ipfilter with timestamp of " + cacheResult.FilterTimestamp);  			if (cacheResult.FilterTimestamp >= result.FilterTimestamp) {  				Trace.TraceInformation ("Using the cached ipfilter as it's the same or newer than the online filter.");  				return cacheResult;  			}  		}  	}  	result.Length = response.Content.Headers.ContentLength;  	double lengthInMb = !result.Length.HasValue ? -1 : (double)result.Length.Value / 1024 / 1024;  	double bytesDownloaded = 0;  	using (var stream = await response.Content.ReadAsStreamAsync ()) {  		var buffer = new byte[65535 * 4];  		result.Stream = new MemoryStream ((int)(result.Length ?? buffer.Length));  		int bytesRead = await stream.ReadAsync (buffer' 0' buffer.Length' cancellationToken);  		result.CompressionFormat = DetectCompressionFormat (buffer' response.Content.Headers.ContentType);  		while (bytesRead != 0) {  			await result.Stream.WriteAsync (buffer' 0' bytesRead' cancellationToken);  			bytesDownloaded += bytesRead;  			if (result.Length.HasValue) {  				double downloadedMegs = bytesDownloaded / 1024 / 1024;  				var percent = (int)Math.Floor ((bytesDownloaded / result.Length.Value) * 100);  				var status = string.Format (CultureInfo.CurrentUICulture' "Downloaded {0:F2} MB of {1:F2} MB"' downloadedMegs' lengthInMb);  				progress.Report (new ProgressModel (UpdateState.Downloading' status' percent));  			}  			if (cancellationToken.IsCancellationRequested)  				return null;  			bytesRead = await stream.ReadAsync (buffer' 0' buffer.Length' cancellationToken);  		}  	}  }  
Magic Number,IPFilter.Services,FilterDownloader,F:\newReposMay17\DavidMoore_ipfilter\Code\IPFilter\Services\FilterDownloader.cs,DownloadFilter,The following statement contains a magic number: using (var response = await httpClient.GetAsync (uri' HttpCompletionOption.ResponseHeadersRead' cancellationToken)) {  	if (cancellationToken.IsCancellationRequested)  		return null;  	result.FilterTimestamp = response.Content.Headers.LastModified ?? response.Headers.Date;  	result.Etag = response.Headers.ETag;  	Trace.TraceInformation ("Online filter's timestamp is " + result.FilterTimestamp);  	Trace.TraceInformation ("ETag: '{0}'"' result.Etag);  	// Check if the cached filter is already up to date.  	if (cache != null && !Settings.Default.DisableCache) {  		var cacheResult = await cache.GetAsync (result);  		if (cacheResult != null && cacheResult.Length > 0) {  			Trace.TraceInformation ("Found cached ipfilter with timestamp of " + cacheResult.FilterTimestamp);  			if (cacheResult.FilterTimestamp >= result.FilterTimestamp) {  				Trace.TraceInformation ("Using the cached ipfilter as it's the same or newer than the online filter.");  				return cacheResult;  			}  		}  	}  	result.Length = response.Content.Headers.ContentLength;  	double lengthInMb = !result.Length.HasValue ? -1 : (double)result.Length.Value / 1024 / 1024;  	double bytesDownloaded = 0;  	using (var stream = await response.Content.ReadAsStreamAsync ()) {  		var buffer = new byte[65535 * 4];  		result.Stream = new MemoryStream ((int)(result.Length ?? buffer.Length));  		int bytesRead = await stream.ReadAsync (buffer' 0' buffer.Length' cancellationToken);  		result.CompressionFormat = DetectCompressionFormat (buffer' response.Content.Headers.ContentType);  		while (bytesRead != 0) {  			await result.Stream.WriteAsync (buffer' 0' bytesRead' cancellationToken);  			bytesDownloaded += bytesRead;  			if (result.Length.HasValue) {  				double downloadedMegs = bytesDownloaded / 1024 / 1024;  				var percent = (int)Math.Floor ((bytesDownloaded / result.Length.Value) * 100);  				var status = string.Format (CultureInfo.CurrentUICulture' "Downloaded {0:F2} MB of {1:F2} MB"' downloadedMegs' lengthInMb);  				progress.Report (new ProgressModel (UpdateState.Downloading' status' percent));  			}  			if (cancellationToken.IsCancellationRequested)  				return null;  			bytesRead = await stream.ReadAsync (buffer' 0' buffer.Length' cancellationToken);  		}  	}  }  
Magic Number,IPFilter.Services,FilterDownloader,F:\newReposMay17\DavidMoore_ipfilter\Code\IPFilter\Services\FilterDownloader.cs,DownloadFilter,The following statement contains a magic number: using (var response = await httpClient.GetAsync (uri' HttpCompletionOption.ResponseHeadersRead' cancellationToken)) {  	if (cancellationToken.IsCancellationRequested)  		return null;  	result.FilterTimestamp = response.Content.Headers.LastModified ?? response.Headers.Date;  	result.Etag = response.Headers.ETag;  	Trace.TraceInformation ("Online filter's timestamp is " + result.FilterTimestamp);  	Trace.TraceInformation ("ETag: '{0}'"' result.Etag);  	// Check if the cached filter is already up to date.  	if (cache != null && !Settings.Default.DisableCache) {  		var cacheResult = await cache.GetAsync (result);  		if (cacheResult != null && cacheResult.Length > 0) {  			Trace.TraceInformation ("Found cached ipfilter with timestamp of " + cacheResult.FilterTimestamp);  			if (cacheResult.FilterTimestamp >= result.FilterTimestamp) {  				Trace.TraceInformation ("Using the cached ipfilter as it's the same or newer than the online filter.");  				return cacheResult;  			}  		}  	}  	result.Length = response.Content.Headers.ContentLength;  	double lengthInMb = !result.Length.HasValue ? -1 : (double)result.Length.Value / 1024 / 1024;  	double bytesDownloaded = 0;  	using (var stream = await response.Content.ReadAsStreamAsync ()) {  		var buffer = new byte[65535 * 4];  		result.Stream = new MemoryStream ((int)(result.Length ?? buffer.Length));  		int bytesRead = await stream.ReadAsync (buffer' 0' buffer.Length' cancellationToken);  		result.CompressionFormat = DetectCompressionFormat (buffer' response.Content.Headers.ContentType);  		while (bytesRead != 0) {  			await result.Stream.WriteAsync (buffer' 0' bytesRead' cancellationToken);  			bytesDownloaded += bytesRead;  			if (result.Length.HasValue) {  				double downloadedMegs = bytesDownloaded / 1024 / 1024;  				var percent = (int)Math.Floor ((bytesDownloaded / result.Length.Value) * 100);  				var status = string.Format (CultureInfo.CurrentUICulture' "Downloaded {0:F2} MB of {1:F2} MB"' downloadedMegs' lengthInMb);  				progress.Report (new ProgressModel (UpdateState.Downloading' status' percent));  			}  			if (cancellationToken.IsCancellationRequested)  				return null;  			bytesRead = await stream.ReadAsync (buffer' 0' buffer.Length' cancellationToken);  		}  	}  }  
Magic Number,IPFilter.Services,FilterDownloader,F:\newReposMay17\DavidMoore_ipfilter\Code\IPFilter\Services\FilterDownloader.cs,DownloadFilter,The following statement contains a magic number: using (var response = await httpClient.GetAsync (uri' HttpCompletionOption.ResponseHeadersRead' cancellationToken)) {  	if (cancellationToken.IsCancellationRequested)  		return null;  	result.FilterTimestamp = response.Content.Headers.LastModified ?? response.Headers.Date;  	result.Etag = response.Headers.ETag;  	Trace.TraceInformation ("Online filter's timestamp is " + result.FilterTimestamp);  	Trace.TraceInformation ("ETag: '{0}'"' result.Etag);  	// Check if the cached filter is already up to date.  	if (cache != null && !Settings.Default.DisableCache) {  		var cacheResult = await cache.GetAsync (result);  		if (cacheResult != null && cacheResult.Length > 0) {  			Trace.TraceInformation ("Found cached ipfilter with timestamp of " + cacheResult.FilterTimestamp);  			if (cacheResult.FilterTimestamp >= result.FilterTimestamp) {  				Trace.TraceInformation ("Using the cached ipfilter as it's the same or newer than the online filter.");  				return cacheResult;  			}  		}  	}  	result.Length = response.Content.Headers.ContentLength;  	double lengthInMb = !result.Length.HasValue ? -1 : (double)result.Length.Value / 1024 / 1024;  	double bytesDownloaded = 0;  	using (var stream = await response.Content.ReadAsStreamAsync ()) {  		var buffer = new byte[65535 * 4];  		result.Stream = new MemoryStream ((int)(result.Length ?? buffer.Length));  		int bytesRead = await stream.ReadAsync (buffer' 0' buffer.Length' cancellationToken);  		result.CompressionFormat = DetectCompressionFormat (buffer' response.Content.Headers.ContentType);  		while (bytesRead != 0) {  			await result.Stream.WriteAsync (buffer' 0' bytesRead' cancellationToken);  			bytesDownloaded += bytesRead;  			if (result.Length.HasValue) {  				double downloadedMegs = bytesDownloaded / 1024 / 1024;  				var percent = (int)Math.Floor ((bytesDownloaded / result.Length.Value) * 100);  				var status = string.Format (CultureInfo.CurrentUICulture' "Downloaded {0:F2} MB of {1:F2} MB"' downloadedMegs' lengthInMb);  				progress.Report (new ProgressModel (UpdateState.Downloading' status' percent));  			}  			if (cancellationToken.IsCancellationRequested)  				return null;  			bytesRead = await stream.ReadAsync (buffer' 0' buffer.Length' cancellationToken);  		}  	}  }  
Magic Number,IPFilter.Services,FilterDownloader,F:\newReposMay17\DavidMoore_ipfilter\Code\IPFilter\Services\FilterDownloader.cs,DownloadFilter,The following statement contains a magic number: using (var response = await httpClient.GetAsync (uri' HttpCompletionOption.ResponseHeadersRead' cancellationToken)) {  	if (cancellationToken.IsCancellationRequested)  		return null;  	result.FilterTimestamp = response.Content.Headers.LastModified ?? response.Headers.Date;  	result.Etag = response.Headers.ETag;  	Trace.TraceInformation ("Online filter's timestamp is " + result.FilterTimestamp);  	Trace.TraceInformation ("ETag: '{0}'"' result.Etag);  	// Check if the cached filter is already up to date.  	if (cache != null && !Settings.Default.DisableCache) {  		var cacheResult = await cache.GetAsync (result);  		if (cacheResult != null && cacheResult.Length > 0) {  			Trace.TraceInformation ("Found cached ipfilter with timestamp of " + cacheResult.FilterTimestamp);  			if (cacheResult.FilterTimestamp >= result.FilterTimestamp) {  				Trace.TraceInformation ("Using the cached ipfilter as it's the same or newer than the online filter.");  				return cacheResult;  			}  		}  	}  	result.Length = response.Content.Headers.ContentLength;  	double lengthInMb = !result.Length.HasValue ? -1 : (double)result.Length.Value / 1024 / 1024;  	double bytesDownloaded = 0;  	using (var stream = await response.Content.ReadAsStreamAsync ()) {  		var buffer = new byte[65535 * 4];  		result.Stream = new MemoryStream ((int)(result.Length ?? buffer.Length));  		int bytesRead = await stream.ReadAsync (buffer' 0' buffer.Length' cancellationToken);  		result.CompressionFormat = DetectCompressionFormat (buffer' response.Content.Headers.ContentType);  		while (bytesRead != 0) {  			await result.Stream.WriteAsync (buffer' 0' bytesRead' cancellationToken);  			bytesDownloaded += bytesRead;  			if (result.Length.HasValue) {  				double downloadedMegs = bytesDownloaded / 1024 / 1024;  				var percent = (int)Math.Floor ((bytesDownloaded / result.Length.Value) * 100);  				var status = string.Format (CultureInfo.CurrentUICulture' "Downloaded {0:F2} MB of {1:F2} MB"' downloadedMegs' lengthInMb);  				progress.Report (new ProgressModel (UpdateState.Downloading' status' percent));  			}  			if (cancellationToken.IsCancellationRequested)  				return null;  			bytesRead = await stream.ReadAsync (buffer' 0' buffer.Length' cancellationToken);  		}  	}  }  
Magic Number,IPFilter.Services,FilterDownloader,F:\newReposMay17\DavidMoore_ipfilter\Code\IPFilter\Services\FilterDownloader.cs,DownloadFilter,The following statement contains a magic number: using (var response = await httpClient.GetAsync (uri' HttpCompletionOption.ResponseHeadersRead' cancellationToken)) {  	if (cancellationToken.IsCancellationRequested)  		return null;  	result.FilterTimestamp = response.Content.Headers.LastModified ?? response.Headers.Date;  	result.Etag = response.Headers.ETag;  	Trace.TraceInformation ("Online filter's timestamp is " + result.FilterTimestamp);  	Trace.TraceInformation ("ETag: '{0}'"' result.Etag);  	// Check if the cached filter is already up to date.  	if (cache != null && !Settings.Default.DisableCache) {  		var cacheResult = await cache.GetAsync (result);  		if (cacheResult != null && cacheResult.Length > 0) {  			Trace.TraceInformation ("Found cached ipfilter with timestamp of " + cacheResult.FilterTimestamp);  			if (cacheResult.FilterTimestamp >= result.FilterTimestamp) {  				Trace.TraceInformation ("Using the cached ipfilter as it's the same or newer than the online filter.");  				return cacheResult;  			}  		}  	}  	result.Length = response.Content.Headers.ContentLength;  	double lengthInMb = !result.Length.HasValue ? -1 : (double)result.Length.Value / 1024 / 1024;  	double bytesDownloaded = 0;  	using (var stream = await response.Content.ReadAsStreamAsync ()) {  		var buffer = new byte[65535 * 4];  		result.Stream = new MemoryStream ((int)(result.Length ?? buffer.Length));  		int bytesRead = await stream.ReadAsync (buffer' 0' buffer.Length' cancellationToken);  		result.CompressionFormat = DetectCompressionFormat (buffer' response.Content.Headers.ContentType);  		while (bytesRead != 0) {  			await result.Stream.WriteAsync (buffer' 0' bytesRead' cancellationToken);  			bytesDownloaded += bytesRead;  			if (result.Length.HasValue) {  				double downloadedMegs = bytesDownloaded / 1024 / 1024;  				var percent = (int)Math.Floor ((bytesDownloaded / result.Length.Value) * 100);  				var status = string.Format (CultureInfo.CurrentUICulture' "Downloaded {0:F2} MB of {1:F2} MB"' downloadedMegs' lengthInMb);  				progress.Report (new ProgressModel (UpdateState.Downloading' status' percent));  			}  			if (cancellationToken.IsCancellationRequested)  				return null;  			bytesRead = await stream.ReadAsync (buffer' 0' buffer.Length' cancellationToken);  		}  	}  }  
Magic Number,IPFilter.Services,FilterDownloader,F:\newReposMay17\DavidMoore_ipfilter\Code\IPFilter\Services\FilterDownloader.cs,DownloadFilter,The following statement contains a magic number: using (var response = await httpClient.GetAsync (uri' HttpCompletionOption.ResponseHeadersRead' cancellationToken)) {  	if (cancellationToken.IsCancellationRequested)  		return null;  	result.FilterTimestamp = response.Content.Headers.LastModified ?? response.Headers.Date;  	result.Etag = response.Headers.ETag;  	Trace.TraceInformation ("Online filter's timestamp is " + result.FilterTimestamp);  	Trace.TraceInformation ("ETag: '{0}'"' result.Etag);  	// Check if the cached filter is already up to date.  	if (cache != null && !Settings.Default.DisableCache) {  		var cacheResult = await cache.GetAsync (result);  		if (cacheResult != null && cacheResult.Length > 0) {  			Trace.TraceInformation ("Found cached ipfilter with timestamp of " + cacheResult.FilterTimestamp);  			if (cacheResult.FilterTimestamp >= result.FilterTimestamp) {  				Trace.TraceInformation ("Using the cached ipfilter as it's the same or newer than the online filter.");  				return cacheResult;  			}  		}  	}  	result.Length = response.Content.Headers.ContentLength;  	double lengthInMb = !result.Length.HasValue ? -1 : (double)result.Length.Value / 1024 / 1024;  	double bytesDownloaded = 0;  	using (var stream = await response.Content.ReadAsStreamAsync ()) {  		var buffer = new byte[65535 * 4];  		result.Stream = new MemoryStream ((int)(result.Length ?? buffer.Length));  		int bytesRead = await stream.ReadAsync (buffer' 0' buffer.Length' cancellationToken);  		result.CompressionFormat = DetectCompressionFormat (buffer' response.Content.Headers.ContentType);  		while (bytesRead != 0) {  			await result.Stream.WriteAsync (buffer' 0' bytesRead' cancellationToken);  			bytesDownloaded += bytesRead;  			if (result.Length.HasValue) {  				double downloadedMegs = bytesDownloaded / 1024 / 1024;  				var percent = (int)Math.Floor ((bytesDownloaded / result.Length.Value) * 100);  				var status = string.Format (CultureInfo.CurrentUICulture' "Downloaded {0:F2} MB of {1:F2} MB"' downloadedMegs' lengthInMb);  				progress.Report (new ProgressModel (UpdateState.Downloading' status' percent));  			}  			if (cancellationToken.IsCancellationRequested)  				return null;  			bytesRead = await stream.ReadAsync (buffer' 0' buffer.Length' cancellationToken);  		}  	}  }  
Magic Number,IPFilter.Services,FilterDownloader,F:\newReposMay17\DavidMoore_ipfilter\Code\IPFilter\Services\FilterDownloader.cs,DownloadFilter,The following statement contains a magic number: using (var stream = await response.Content.ReadAsStreamAsync ()) {  	var buffer = new byte[65535 * 4];  	result.Stream = new MemoryStream ((int)(result.Length ?? buffer.Length));  	int bytesRead = await stream.ReadAsync (buffer' 0' buffer.Length' cancellationToken);  	result.CompressionFormat = DetectCompressionFormat (buffer' response.Content.Headers.ContentType);  	while (bytesRead != 0) {  		await result.Stream.WriteAsync (buffer' 0' bytesRead' cancellationToken);  		bytesDownloaded += bytesRead;  		if (result.Length.HasValue) {  			double downloadedMegs = bytesDownloaded / 1024 / 1024;  			var percent = (int)Math.Floor ((bytesDownloaded / result.Length.Value) * 100);  			var status = string.Format (CultureInfo.CurrentUICulture' "Downloaded {0:F2} MB of {1:F2} MB"' downloadedMegs' lengthInMb);  			progress.Report (new ProgressModel (UpdateState.Downloading' status' percent));  		}  		if (cancellationToken.IsCancellationRequested)  			return null;  		bytesRead = await stream.ReadAsync (buffer' 0' buffer.Length' cancellationToken);  	}  }  
Magic Number,IPFilter.Services,FilterDownloader,F:\newReposMay17\DavidMoore_ipfilter\Code\IPFilter\Services\FilterDownloader.cs,DownloadFilter,The following statement contains a magic number: using (var stream = await response.Content.ReadAsStreamAsync ()) {  	var buffer = new byte[65535 * 4];  	result.Stream = new MemoryStream ((int)(result.Length ?? buffer.Length));  	int bytesRead = await stream.ReadAsync (buffer' 0' buffer.Length' cancellationToken);  	result.CompressionFormat = DetectCompressionFormat (buffer' response.Content.Headers.ContentType);  	while (bytesRead != 0) {  		await result.Stream.WriteAsync (buffer' 0' bytesRead' cancellationToken);  		bytesDownloaded += bytesRead;  		if (result.Length.HasValue) {  			double downloadedMegs = bytesDownloaded / 1024 / 1024;  			var percent = (int)Math.Floor ((bytesDownloaded / result.Length.Value) * 100);  			var status = string.Format (CultureInfo.CurrentUICulture' "Downloaded {0:F2} MB of {1:F2} MB"' downloadedMegs' lengthInMb);  			progress.Report (new ProgressModel (UpdateState.Downloading' status' percent));  		}  		if (cancellationToken.IsCancellationRequested)  			return null;  		bytesRead = await stream.ReadAsync (buffer' 0' buffer.Length' cancellationToken);  	}  }  
Magic Number,IPFilter.Services,FilterDownloader,F:\newReposMay17\DavidMoore_ipfilter\Code\IPFilter\Services\FilterDownloader.cs,DownloadFilter,The following statement contains a magic number: using (var stream = await response.Content.ReadAsStreamAsync ()) {  	var buffer = new byte[65535 * 4];  	result.Stream = new MemoryStream ((int)(result.Length ?? buffer.Length));  	int bytesRead = await stream.ReadAsync (buffer' 0' buffer.Length' cancellationToken);  	result.CompressionFormat = DetectCompressionFormat (buffer' response.Content.Headers.ContentType);  	while (bytesRead != 0) {  		await result.Stream.WriteAsync (buffer' 0' bytesRead' cancellationToken);  		bytesDownloaded += bytesRead;  		if (result.Length.HasValue) {  			double downloadedMegs = bytesDownloaded / 1024 / 1024;  			var percent = (int)Math.Floor ((bytesDownloaded / result.Length.Value) * 100);  			var status = string.Format (CultureInfo.CurrentUICulture' "Downloaded {0:F2} MB of {1:F2} MB"' downloadedMegs' lengthInMb);  			progress.Report (new ProgressModel (UpdateState.Downloading' status' percent));  		}  		if (cancellationToken.IsCancellationRequested)  			return null;  		bytesRead = await stream.ReadAsync (buffer' 0' buffer.Length' cancellationToken);  	}  }  
Magic Number,IPFilter.Services,FilterDownloader,F:\newReposMay17\DavidMoore_ipfilter\Code\IPFilter\Services\FilterDownloader.cs,DownloadFilter,The following statement contains a magic number: using (var stream = await response.Content.ReadAsStreamAsync ()) {  	var buffer = new byte[65535 * 4];  	result.Stream = new MemoryStream ((int)(result.Length ?? buffer.Length));  	int bytesRead = await stream.ReadAsync (buffer' 0' buffer.Length' cancellationToken);  	result.CompressionFormat = DetectCompressionFormat (buffer' response.Content.Headers.ContentType);  	while (bytesRead != 0) {  		await result.Stream.WriteAsync (buffer' 0' bytesRead' cancellationToken);  		bytesDownloaded += bytesRead;  		if (result.Length.HasValue) {  			double downloadedMegs = bytesDownloaded / 1024 / 1024;  			var percent = (int)Math.Floor ((bytesDownloaded / result.Length.Value) * 100);  			var status = string.Format (CultureInfo.CurrentUICulture' "Downloaded {0:F2} MB of {1:F2} MB"' downloadedMegs' lengthInMb);  			progress.Report (new ProgressModel (UpdateState.Downloading' status' percent));  		}  		if (cancellationToken.IsCancellationRequested)  			return null;  		bytesRead = await stream.ReadAsync (buffer' 0' buffer.Length' cancellationToken);  	}  }  
Magic Number,IPFilter.Services,FilterDownloader,F:\newReposMay17\DavidMoore_ipfilter\Code\IPFilter\Services\FilterDownloader.cs,DownloadFilter,The following statement contains a magic number: using (var stream = await response.Content.ReadAsStreamAsync ()) {  	var buffer = new byte[65535 * 4];  	result.Stream = new MemoryStream ((int)(result.Length ?? buffer.Length));  	int bytesRead = await stream.ReadAsync (buffer' 0' buffer.Length' cancellationToken);  	result.CompressionFormat = DetectCompressionFormat (buffer' response.Content.Headers.ContentType);  	while (bytesRead != 0) {  		await result.Stream.WriteAsync (buffer' 0' bytesRead' cancellationToken);  		bytesDownloaded += bytesRead;  		if (result.Length.HasValue) {  			double downloadedMegs = bytesDownloaded / 1024 / 1024;  			var percent = (int)Math.Floor ((bytesDownloaded / result.Length.Value) * 100);  			var status = string.Format (CultureInfo.CurrentUICulture' "Downloaded {0:F2} MB of {1:F2} MB"' downloadedMegs' lengthInMb);  			progress.Report (new ProgressModel (UpdateState.Downloading' status' percent));  		}  		if (cancellationToken.IsCancellationRequested)  			return null;  		bytesRead = await stream.ReadAsync (buffer' 0' buffer.Length' cancellationToken);  	}  }  
Magic Number,IPFilter.Services,FilterDownloader,F:\newReposMay17\DavidMoore_ipfilter\Code\IPFilter\Services\FilterDownloader.cs,DownloadFilter,The following statement contains a magic number: while (bytesRead != 0) {  	await result.Stream.WriteAsync (buffer' 0' bytesRead' cancellationToken);  	bytesDownloaded += bytesRead;  	if (result.Length.HasValue) {  		double downloadedMegs = bytesDownloaded / 1024 / 1024;  		var percent = (int)Math.Floor ((bytesDownloaded / result.Length.Value) * 100);  		var status = string.Format (CultureInfo.CurrentUICulture' "Downloaded {0:F2} MB of {1:F2} MB"' downloadedMegs' lengthInMb);  		progress.Report (new ProgressModel (UpdateState.Downloading' status' percent));  	}  	if (cancellationToken.IsCancellationRequested)  		return null;  	bytesRead = await stream.ReadAsync (buffer' 0' buffer.Length' cancellationToken);  }  
Magic Number,IPFilter.Services,FilterDownloader,F:\newReposMay17\DavidMoore_ipfilter\Code\IPFilter\Services\FilterDownloader.cs,DownloadFilter,The following statement contains a magic number: while (bytesRead != 0) {  	await result.Stream.WriteAsync (buffer' 0' bytesRead' cancellationToken);  	bytesDownloaded += bytesRead;  	if (result.Length.HasValue) {  		double downloadedMegs = bytesDownloaded / 1024 / 1024;  		var percent = (int)Math.Floor ((bytesDownloaded / result.Length.Value) * 100);  		var status = string.Format (CultureInfo.CurrentUICulture' "Downloaded {0:F2} MB of {1:F2} MB"' downloadedMegs' lengthInMb);  		progress.Report (new ProgressModel (UpdateState.Downloading' status' percent));  	}  	if (cancellationToken.IsCancellationRequested)  		return null;  	bytesRead = await stream.ReadAsync (buffer' 0' buffer.Length' cancellationToken);  }  
Magic Number,IPFilter.Services,FilterDownloader,F:\newReposMay17\DavidMoore_ipfilter\Code\IPFilter\Services\FilterDownloader.cs,DownloadFilter,The following statement contains a magic number: while (bytesRead != 0) {  	await result.Stream.WriteAsync (buffer' 0' bytesRead' cancellationToken);  	bytesDownloaded += bytesRead;  	if (result.Length.HasValue) {  		double downloadedMegs = bytesDownloaded / 1024 / 1024;  		var percent = (int)Math.Floor ((bytesDownloaded / result.Length.Value) * 100);  		var status = string.Format (CultureInfo.CurrentUICulture' "Downloaded {0:F2} MB of {1:F2} MB"' downloadedMegs' lengthInMb);  		progress.Report (new ProgressModel (UpdateState.Downloading' status' percent));  	}  	if (cancellationToken.IsCancellationRequested)  		return null;  	bytesRead = await stream.ReadAsync (buffer' 0' buffer.Length' cancellationToken);  }  
Magic Number,IPFilter.Services,FilterDownloader,F:\newReposMay17\DavidMoore_ipfilter\Code\IPFilter\Services\FilterDownloader.cs,DownloadFilter,The following statement contains a magic number: if (result.Length.HasValue) {  	double downloadedMegs = bytesDownloaded / 1024 / 1024;  	var percent = (int)Math.Floor ((bytesDownloaded / result.Length.Value) * 100);  	var status = string.Format (CultureInfo.CurrentUICulture' "Downloaded {0:F2} MB of {1:F2} MB"' downloadedMegs' lengthInMb);  	progress.Report (new ProgressModel (UpdateState.Downloading' status' percent));  }  
Magic Number,IPFilter.Services,FilterDownloader,F:\newReposMay17\DavidMoore_ipfilter\Code\IPFilter\Services\FilterDownloader.cs,DownloadFilter,The following statement contains a magic number: if (result.Length.HasValue) {  	double downloadedMegs = bytesDownloaded / 1024 / 1024;  	var percent = (int)Math.Floor ((bytesDownloaded / result.Length.Value) * 100);  	var status = string.Format (CultureInfo.CurrentUICulture' "Downloaded {0:F2} MB of {1:F2} MB"' downloadedMegs' lengthInMb);  	progress.Report (new ProgressModel (UpdateState.Downloading' status' percent));  }  
Magic Number,IPFilter.Services,FilterDownloader,F:\newReposMay17\DavidMoore_ipfilter\Code\IPFilter\Services\FilterDownloader.cs,DownloadFilter,The following statement contains a magic number: if (result.Length.HasValue) {  	double downloadedMegs = bytesDownloaded / 1024 / 1024;  	var percent = (int)Math.Floor ((bytesDownloaded / result.Length.Value) * 100);  	var status = string.Format (CultureInfo.CurrentUICulture' "Downloaded {0:F2} MB of {1:F2} MB"' downloadedMegs' lengthInMb);  	progress.Report (new ProgressModel (UpdateState.Downloading' status' percent));  }  
Magic Number,IPFilter.Services,FilterDownloader,F:\newReposMay17\DavidMoore_ipfilter\Code\IPFilter\Services\FilterDownloader.cs,Decompress,The following statement contains a magic number: using (var stream = filter.Stream) {  	var result = new MemoryStream ();  	stream.Seek (0' SeekOrigin.Begin);  	cancellationToken.ThrowIfCancellationRequested ();  	switch (filter.CompressionFormat) {  	case CompressionFormat.GZip:  		using (var gzipFile = new GZipStream (stream' CompressionMode.Decompress)) {  			var buffer = new byte[1024 * 64];  			int bytesRead;  			while ((bytesRead = await gzipFile.ReadAsync (buffer' 0' buffer.Length' cancellationToken)) > 0) {  				cancellationToken.ThrowIfCancellationRequested ();  				result.Write (buffer' 0' bytesRead);  				progress.Report (new ProgressModel (UpdateState.Decompressing' "Decompressing..."' -1));  			}  		}  		break;  	case CompressionFormat.Zip:  		using (var zipFile = new ZipArchive (stream' ZipArchiveMode.Read)) {  			progress.Report (new ProgressModel (UpdateState.Decompressing' "Decompressing..."' -1));  			if (zipFile.Entries.Count == 0)  				throw new IOException ("There are no entries in the zip file.");  			if (zipFile.Entries.Count > 1)  				throw new IOException ("There is more than one file in the zip file. This application will need to be updated to support this.");  			var entry = zipFile.Entries.First ();  			using (var entryStream = entry.Open ()) {  				cancellationToken.ThrowIfCancellationRequested ();  				await entryStream.CopyToAsync (result);  			}  		}  		break;  	default:  		await stream.CopyToAsync (result);  		break;  	}  	return result;  }  
Magic Number,IPFilter.Services,FilterDownloader,F:\newReposMay17\DavidMoore_ipfilter\Code\IPFilter\Services\FilterDownloader.cs,Decompress,The following statement contains a magic number: using (var stream = filter.Stream) {  	var result = new MemoryStream ();  	stream.Seek (0' SeekOrigin.Begin);  	cancellationToken.ThrowIfCancellationRequested ();  	switch (filter.CompressionFormat) {  	case CompressionFormat.GZip:  		using (var gzipFile = new GZipStream (stream' CompressionMode.Decompress)) {  			var buffer = new byte[1024 * 64];  			int bytesRead;  			while ((bytesRead = await gzipFile.ReadAsync (buffer' 0' buffer.Length' cancellationToken)) > 0) {  				cancellationToken.ThrowIfCancellationRequested ();  				result.Write (buffer' 0' bytesRead);  				progress.Report (new ProgressModel (UpdateState.Decompressing' "Decompressing..."' -1));  			}  		}  		break;  	case CompressionFormat.Zip:  		using (var zipFile = new ZipArchive (stream' ZipArchiveMode.Read)) {  			progress.Report (new ProgressModel (UpdateState.Decompressing' "Decompressing..."' -1));  			if (zipFile.Entries.Count == 0)  				throw new IOException ("There are no entries in the zip file.");  			if (zipFile.Entries.Count > 1)  				throw new IOException ("There is more than one file in the zip file. This application will need to be updated to support this.");  			var entry = zipFile.Entries.First ();  			using (var entryStream = entry.Open ()) {  				cancellationToken.ThrowIfCancellationRequested ();  				await entryStream.CopyToAsync (result);  			}  		}  		break;  	default:  		await stream.CopyToAsync (result);  		break;  	}  	return result;  }  
Magic Number,IPFilter.Services,FilterDownloader,F:\newReposMay17\DavidMoore_ipfilter\Code\IPFilter\Services\FilterDownloader.cs,Decompress,The following statement contains a magic number: switch (filter.CompressionFormat) {  case CompressionFormat.GZip:  	using (var gzipFile = new GZipStream (stream' CompressionMode.Decompress)) {  		var buffer = new byte[1024 * 64];  		int bytesRead;  		while ((bytesRead = await gzipFile.ReadAsync (buffer' 0' buffer.Length' cancellationToken)) > 0) {  			cancellationToken.ThrowIfCancellationRequested ();  			result.Write (buffer' 0' bytesRead);  			progress.Report (new ProgressModel (UpdateState.Decompressing' "Decompressing..."' -1));  		}  	}  	break;  case CompressionFormat.Zip:  	using (var zipFile = new ZipArchive (stream' ZipArchiveMode.Read)) {  		progress.Report (new ProgressModel (UpdateState.Decompressing' "Decompressing..."' -1));  		if (zipFile.Entries.Count == 0)  			throw new IOException ("There are no entries in the zip file.");  		if (zipFile.Entries.Count > 1)  			throw new IOException ("There is more than one file in the zip file. This application will need to be updated to support this.");  		var entry = zipFile.Entries.First ();  		using (var entryStream = entry.Open ()) {  			cancellationToken.ThrowIfCancellationRequested ();  			await entryStream.CopyToAsync (result);  		}  	}  	break;  default:  	await stream.CopyToAsync (result);  	break;  }  
Magic Number,IPFilter.Services,FilterDownloader,F:\newReposMay17\DavidMoore_ipfilter\Code\IPFilter\Services\FilterDownloader.cs,Decompress,The following statement contains a magic number: switch (filter.CompressionFormat) {  case CompressionFormat.GZip:  	using (var gzipFile = new GZipStream (stream' CompressionMode.Decompress)) {  		var buffer = new byte[1024 * 64];  		int bytesRead;  		while ((bytesRead = await gzipFile.ReadAsync (buffer' 0' buffer.Length' cancellationToken)) > 0) {  			cancellationToken.ThrowIfCancellationRequested ();  			result.Write (buffer' 0' bytesRead);  			progress.Report (new ProgressModel (UpdateState.Decompressing' "Decompressing..."' -1));  		}  	}  	break;  case CompressionFormat.Zip:  	using (var zipFile = new ZipArchive (stream' ZipArchiveMode.Read)) {  		progress.Report (new ProgressModel (UpdateState.Decompressing' "Decompressing..."' -1));  		if (zipFile.Entries.Count == 0)  			throw new IOException ("There are no entries in the zip file.");  		if (zipFile.Entries.Count > 1)  			throw new IOException ("There is more than one file in the zip file. This application will need to be updated to support this.");  		var entry = zipFile.Entries.First ();  		using (var entryStream = entry.Open ()) {  			cancellationToken.ThrowIfCancellationRequested ();  			await entryStream.CopyToAsync (result);  		}  	}  	break;  default:  	await stream.CopyToAsync (result);  	break;  }  
Magic Number,IPFilter.Services,FilterDownloader,F:\newReposMay17\DavidMoore_ipfilter\Code\IPFilter\Services\FilterDownloader.cs,Decompress,The following statement contains a magic number: using (var gzipFile = new GZipStream (stream' CompressionMode.Decompress)) {  	var buffer = new byte[1024 * 64];  	int bytesRead;  	while ((bytesRead = await gzipFile.ReadAsync (buffer' 0' buffer.Length' cancellationToken)) > 0) {  		cancellationToken.ThrowIfCancellationRequested ();  		result.Write (buffer' 0' bytesRead);  		progress.Report (new ProgressModel (UpdateState.Decompressing' "Decompressing..."' -1));  	}  }  
Magic Number,IPFilter.Services,FilterDownloader,F:\newReposMay17\DavidMoore_ipfilter\Code\IPFilter\Services\FilterDownloader.cs,Decompress,The following statement contains a magic number: using (var gzipFile = new GZipStream (stream' CompressionMode.Decompress)) {  	var buffer = new byte[1024 * 64];  	int bytesRead;  	while ((bytesRead = await gzipFile.ReadAsync (buffer' 0' buffer.Length' cancellationToken)) > 0) {  		cancellationToken.ThrowIfCancellationRequested ();  		result.Write (buffer' 0' bytesRead);  		progress.Report (new ProgressModel (UpdateState.Decompressing' "Decompressing..."' -1));  	}  }  
Magic Number,IPFilter.Services,FilterDownloader,F:\newReposMay17\DavidMoore_ipfilter\Code\IPFilter\Services\FilterDownloader.cs,DetectCompressionFormat,The following statement contains a magic number: switch (contentType.MediaType) {  case "application/gzip":  case "application/x-gzip":  case "application/x-gunzip":  case "application/gzipped":  case "application/gzip-compressed":  case "gzip/document":  	return CompressionFormat.GZip;  case "application/zip":  case "application/x-zip":  case "application/x-zip-compressed":  case "multipart/x-zip":  	return CompressionFormat.Zip;  //                case "application/x-compressed":  //                case "application/octet-stream":  //                case "text/plain":  default:  	{  		// Look for the GZip header bytes  		if (buffer [0] == 31 && buffer [1] == 139) {  			return CompressionFormat.GZip;  		}  		// Look for the ZIP header bytes.  		var zipHeaderNumber = BitConverter.ToInt32 (buffer' 0);  		if (zipHeaderNumber == 0x4034b50) {  			return CompressionFormat.Zip;  		}  	}  	break;  }  
Magic Number,IPFilter.Services,FilterDownloader,F:\newReposMay17\DavidMoore_ipfilter\Code\IPFilter\Services\FilterDownloader.cs,DetectCompressionFormat,The following statement contains a magic number: switch (contentType.MediaType) {  case "application/gzip":  case "application/x-gzip":  case "application/x-gunzip":  case "application/gzipped":  case "application/gzip-compressed":  case "gzip/document":  	return CompressionFormat.GZip;  case "application/zip":  case "application/x-zip":  case "application/x-zip-compressed":  case "multipart/x-zip":  	return CompressionFormat.Zip;  //                case "application/x-compressed":  //                case "application/octet-stream":  //                case "text/plain":  default:  	{  		// Look for the GZip header bytes  		if (buffer [0] == 31 && buffer [1] == 139) {  			return CompressionFormat.GZip;  		}  		// Look for the ZIP header bytes.  		var zipHeaderNumber = BitConverter.ToInt32 (buffer' 0);  		if (zipHeaderNumber == 0x4034b50) {  			return CompressionFormat.Zip;  		}  	}  	break;  }  
Magic Number,IPFilter.Services,FilterDownloader,F:\newReposMay17\DavidMoore_ipfilter\Code\IPFilter\Services\FilterDownloader.cs,DetectCompressionFormat,The following statement contains a magic number: if (buffer [0] == 31 && buffer [1] == 139) {  	return CompressionFormat.GZip;  }  
Magic Number,IPFilter.Services,FilterDownloader,F:\newReposMay17\DavidMoore_ipfilter\Code\IPFilter\Services\FilterDownloader.cs,DetectCompressionFormat,The following statement contains a magic number: if (buffer [0] == 31 && buffer [1] == 139) {  	return CompressionFormat.GZip;  }  
Magic Number,IPFilter.ListProviders,SourceForgeMirrorParser,F:\newReposMay17\DavidMoore_ipfilter\Code\IPFilter\ListProviders\SourceForgeMirrorParser.cs,ParseMirrors,The following statement contains a magic number: return from Match match in regex.Matches (mirrorsHtml)  let name = match.Groups [2].Value.Trim () + " " + match.Groups [3].Value.Trim ()  select new FileMirror (match.Groups [1].Value' name);  
Magic Number,IPFilter.ListProviders,SourceForgeMirrorParser,F:\newReposMay17\DavidMoore_ipfilter\Code\IPFilter\ListProviders\SourceForgeMirrorParser.cs,ParseMirrors,The following statement contains a magic number: return from Match match in regex.Matches (mirrorsHtml)  let name = match.Groups [2].Value.Trim () + " " + match.Groups [3].Value.Trim ()  select new FileMirror (match.Groups [1].Value' name);  
Magic Number,IPFilter.Views,MainWindow,F:\newReposMay17\DavidMoore_ipfilter\Code\IPFilter\Views\MainWindow.xaml.cs,MainWindow,The following statement contains a magic number: ViewModel.ShowNotification = (title' message' icon) => notifyIcon.ShowBalloonTip (3000' title' message' icon);  
Missing Default,IPFilter.ViewModels,MainWindowViewModel,F:\newReposMay17\DavidMoore_ipfilter\Code\IPFilter\ViewModels\MainWindowViewModel.cs,Start,The following switch statement is missing a default case: switch (State) {  case UpdateState.Done:  case UpdateState.Ready:  case UpdateState.Cancelled:  	cancellationToken.Dispose ();  	cancellationToken = new CancellationTokenSource ();  	Task.Factory.StartNew (StartAsync' CancellationToken.None' TaskCreationOptions.None' TaskScheduler.FromCurrentSynchronizationContext ());  	break;  case UpdateState.Downloading:  case UpdateState.Decompressing:  	cancellationToken.Cancel ();  	break;  }  
