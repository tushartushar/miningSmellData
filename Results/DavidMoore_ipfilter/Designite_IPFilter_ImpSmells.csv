Implementation smell,Namespace,Class,File,Method,Description
Long Method,IPFilter.ViewModels,MainWindowViewModel,C:\repos\DavidMoore_ipfilter\Code\IPFilter\ViewModels\MainWindowViewModel.cs,CheckForUpdates,The method has 158 lines of code.
Long Method,IPFilter.ListProviders,BlocklistMirrorProvider,C:\repos\DavidMoore_ipfilter\Code\IPFilter\ListProviders\BlocklistMirrorProvider.cs,GetMirrors,The method has 321 lines of code.
Complex Method,IPFilter.Services.Deployment,ClickOnceRegistry,C:\repos\DavidMoore_ipfilter\Code\IPFilter\Services\Deployment\ClickOnceRegistry.cs,ReadMarks,Cyclomatic complexity of the method is 8
Long Parameter List,IPFilter.Native,ProcessManager,C:\repos\DavidMoore_ipfilter\Code\IPFilter\Native\ProcessManager.cs,CreateProcess,The method has 10 parameters. Parameters: applicationName' commandLine' processAttributes' threadAttributes' inheritHandles' creationFlags' environment' currentDirectory' startupInfo' processInformation
Long Parameter List,IPFilter.ViewModels,MessageBoxHelper,C:\repos\DavidMoore_ipfilter\Code\IPFilter\ViewModels\MessageBoxHelper.cs,Show,The method has 7 parameters. Parameters: parent' title' buttons' image' defaultButton' message' args
Long Parameter List,IPFilter.Services,DeploymentHelper,C:\repos\DavidMoore_ipfilter\Code\IPFilter\Services\DeploymentHelper.cs,CorLaunchApplication,The method has 7 parameters. Parameters: hostType' applicationFullName' manifestPathsCount' manifestPaths' activationDataCount' activationData' processInformation
Long Statement,IPFilter.ViewModels,MessageBoxHelper,C:\repos\DavidMoore_ipfilter\Code\IPFilter\ViewModels\MessageBoxHelper.cs,Show,The length of the statement  "            var formattedMessage = args == null || args.Length == 0 ? message : string.Format(CultureInfo.CurrentCulture' message' args); " is 125.
Long Statement,IPFilter.ViewModels,MessageBoxHelper,C:\repos\DavidMoore_ipfilter\Code\IPFilter\ViewModels\MessageBoxHelper.cs,Show,The length of the statement  "            var options = CultureInfo.CurrentCulture.TextInfo.IsRightToLeft ? MessageBoxOptions.RightAlign | MessageBoxOptions.RtlReading : 0; " is 130.
Long Statement,IPFilter.ViewModels,MainWindowViewModel,C:\repos\DavidMoore_ipfilter\Code\IPFilter\ViewModels\MainWindowViewModel.cs,Start,The length of the statement  "                    Task.Factory.StartNew(StartAsync' CancellationToken.None' TaskCreationOptions.None' TaskScheduler.FromCurrentSynchronizationContext()); " is 135.
Long Statement,IPFilter.ViewModels,MainWindowViewModel,C:\repos\DavidMoore_ipfilter\Code\IPFilter\ViewModels\MainWindowViewModel.cs,CheckForUpdates,The length of the statement  "                if (MessageBoxHelper.Show(dispatcher' "Update Available"' MessageBoxButton.YesNo' MessageBoxImage.Question' MessageBoxResult.Yes' " is 129.
Long Statement,IPFilter.ViewModels,MainWindowViewModel,C:\repos\DavidMoore_ipfilter\Code\IPFilter\ViewModels\MainWindowViewModel.cs,CheckForUpdates,The length of the statement  "                    "An update to version {0} is available. Would you like to update now?"' Update.AvailableVersion) != MessageBoxResult.Yes) " is 121.
Long Statement,IPFilter.ViewModels,MainWindowViewModel,C:\repos\DavidMoore_ipfilter\Code\IPFilter\ViewModels\MainWindowViewModel.cs,CheckForUpdates,The length of the statement  "                    using (var response = await httpClient.GetAsync(uri' HttpCompletionOption.ResponseHeadersRead' cancellationToken.Token)) " is 120.
Long Statement,IPFilter.ViewModels,MainWindowViewModel,C:\repos\DavidMoore_ipfilter\Code\IPFilter\ViewModels\MainWindowViewModel.cs,CheckForUpdates,The length of the statement  "                                    var status = string.Format(CultureInfo.CurrentUICulture' "Downloaded {0:F2} MB of {1:F2} MB"' downloadedMegs' lengthInMb); " is 122.
Long Statement,IPFilter.Services,CryptoHelper,C:\repos\DavidMoore_ipfilter\Code\IPFilter\Services\CryptoHelper.cs,EncryptString,The length of the statement  "            byte[] encryptedData = ProtectedData.Protect(Encoding.Unicode.GetBytes(ToInsecureString(input))' entropy' DataProtectionScope.CurrentUser); " is 139.
Long Statement,IPFilter.Services,CryptoHelper,C:\repos\DavidMoore_ipfilter\Code\IPFilter\Services\CryptoHelper.cs,DecryptString,The length of the statement  "                byte[] decryptedData = ProtectedData.Unprotect(Convert.FromBase64String(encryptedData)' entropy' DataProtectionScope.CurrentUser); " is 130.
Long Statement,IPFilter.Services,FilterDownloader,C:\repos\DavidMoore_ipfilter\Code\IPFilter\Services\FilterDownloader.cs,DownloadFilter,The length of the statement  "                                    var status = string.Format(CultureInfo.CurrentUICulture' "Downloaded {0:F2} MB of {1:F2} MB"' downloadedMegs' lengthInMb); " is 122.
Long Statement,IPFilter.Services,FilterDownloader,C:\repos\DavidMoore_ipfilter\Code\IPFilter\Services\FilterDownloader.cs,Decompress,The length of the statement  "                            if (zipFile.Entries.Count > 1) throw new IOException("There is more than one file in the zip file. This application will need to be updated to support this."); " is 159.
Long Statement,IPFilter.Apps,BitTorrentApplication,C:\repos\DavidMoore_ipfilter\Code\IPFilter\Apps\BitTorrentApplication.cs,UpdateFilterAsync,The length of the statement  "            var roamingPath = Environment.GetFolderPath(Environment.SpecialFolder.ApplicationData' Environment.SpecialFolderOption.Create); " is 127.
Long Statement,IPFilter.Apps,BitTorrentApplication,C:\repos\DavidMoore_ipfilter\Code\IPFilter\Apps\BitTorrentApplication.cs,UpdateFilterAsync,The length of the statement  "//                MessageBox.Show("You haven't enabled IP Filtering in ÂµTorrent! Go to http://ipfilter.codeplex.com/ for help."' "IP filtering not enabled"' MessageBoxButton.OK); " is 178.
Long Statement,IPFilter.Apps,QBitTorrent,C:\repos\DavidMoore_ipfilter\Code\IPFilter\Apps\QBitTorrent.cs,UpdateFilterAsync,The length of the statement  "            var qBittorrentIniPath = Path.Combine(Environment.GetFolderPath(Environment.SpecialFolder.ApplicationData)' "qBittorrent"' "qBittorrent.ini"); " is 142.
Long Statement,IPFilter.ListProviders,BlocklistMirrorProvider,C:\repos\DavidMoore_ipfilter\Code\IPFilter\ListProviders\BlocklistMirrorProvider.cs,GetUrlForMirror,The length of the statement  "            return string.Format(CultureInfo.CurrentCulture' "http://list.iblocklist.com/?fileformat=dat&archiveformat=gz&list={0}"' mirror.Id); " is 132.
Long Statement,IPFilter.ListProviders,SourceForgeMirrorProvider,C:\repos\DavidMoore_ipfilter\Code\IPFilter\ListProviders\SourceForgeMirrorProvider.cs,GetUrlForMirror,The length of the statement  "            return string.Format(CultureInfo.CurrentCulture' "https://downloads.sourceforge.net/sourceforge/emulepawcio/ipfilter.zip?use_mirror={0}"' mirror.Id); " is 149.
Empty Catch Block,IPFilter.Services.Deployment,RemoveFiles,C:\repos\DavidMoore_ipfilter\Code\IPFilter\Services\Deployment\RemoveFiles.cs,Execute,The method has an empty catch block.
Empty Catch Block,IPFilter.Services.Deployment,RemoveStartMenuEntry,C:\repos\DavidMoore_ipfilter\Code\IPFilter\Services\Deployment\RemoveStartMenuEntry.cs,Execute,The method has an empty catch block.
Magic Number,IPFilter.Services.Deployment,ClickOnceRegistry,C:\repos\DavidMoore_ipfilter\Code\IPFilter\Services\Deployment\ClickOnceRegistry.cs,ReadMarks,The following statement contains a magic number: foreach (var keyName in marks.GetSubKeyNames())              {                  var markKey = marks.OpenSubKey(keyName);                  if (markKey == null) continue;                    var mark = new Mark { Key = keyName };                  Marks.Add(mark);                    var appid = markKey.GetValue("appid") as byte[];                  if (appid != null) mark.AppId = Encoding.ASCII.GetString(appid);                    var identity = markKey.GetValue("identity") as byte[];                  if (identity != null) mark.Identity = Encoding.ASCII.GetString(identity);                    mark.Implications = new List<Implication>();                  var implications = markKey.GetValueNames().Where(n => n.StartsWith("implication"));                  foreach (var implicationName in implications)                  {                      var implication = markKey.GetValue(implicationName) as byte[];                      if (implication != null)                          mark.Implications.Add(new Implication                                                    {                                                        Key = implicationName'                                                        Name = implicationName.Substring(12)'                                                        Value = Encoding.ASCII.GetString(implication)                                                    });                  }              }
Magic Number,IPFilter.Services.Deployment,RemoveFiles,C:\repos\DavidMoore_ipfilter\Code\IPFilter\Services\Deployment\RemoveFiles.cs,IsWindowsXp,The following statement contains a magic number: return Environment.OSVersion.Version.Major == 5;
Magic Number,IPFilter.Services.Deployment,RemoveFiles,C:\repos\DavidMoore_ipfilter\Code\IPFilter\Services\Deployment\RemoveFiles.cs,DescendIntoSubfolders,The following statement contains a magic number: foreach (var subFolder in Directory.GetDirectories(baseFolder))              {                  if ((Path.GetFileName(subFolder) ?? string.Empty).Length == 12)                  {                      foreach (var subSubFolder in Directory.GetDirectories(subFolder))                      {                          if ((Path.GetFileName(subSubFolder) ?? string.Empty).Length == 12)                          {                              return subSubFolder;                          }                      }                  }              }
Magic Number,IPFilter.Services.Deployment,RemoveFiles,C:\repos\DavidMoore_ipfilter\Code\IPFilter\Services\Deployment\RemoveFiles.cs,DescendIntoSubfolders,The following statement contains a magic number: foreach (var subFolder in Directory.GetDirectories(baseFolder))              {                  if ((Path.GetFileName(subFolder) ?? string.Empty).Length == 12)                  {                      foreach (var subSubFolder in Directory.GetDirectories(subFolder))                      {                          if ((Path.GetFileName(subSubFolder) ?? string.Empty).Length == 12)                          {                              return subSubFolder;                          }                      }                  }              }
Magic Number,IPFilter.Services.Deployment,UninstallInfo,C:\repos\DavidMoore_ipfilter\Code\IPFilter\Services\Deployment\UninstallInfo.cs,GetPublicKeyToken,The following statement contains a magic number: var token = UninstallString.Split(''')                  .First(s => s.Trim().StartsWith("PublicKeyToken="' StringComparison.Ordinal)).Substring(16);
Magic Number,IPFilter.Services.Deployment,UninstallInfo,C:\repos\DavidMoore_ipfilter\Code\IPFilter\Services\Deployment\UninstallInfo.cs,GetPublicKeyToken,The following statement contains a magic number: if (token.Length != 16) throw new ArgumentException();
Magic Number,IPFilter.ViewModels,MainWindowViewModel,C:\repos\DavidMoore_ipfilter\Code\IPFilter\ViewModels\MainWindowViewModel.cs,MainWindowViewModel,The following statement contains a magic number: ProgressMax = 100;
Magic Number,IPFilter.ViewModels,MainWindowViewModel,C:\repos\DavidMoore_ipfilter\Code\IPFilter\ViewModels\MainWindowViewModel.cs,StartAsync,The following statement contains a magic number: try              {                  var uri = SelectedMirrorProvider.GetUrlForMirror(SelectedFileMirror);                    using (var filter = await downloader.DownloadFilter(new Uri(uri)' cancellationToken.Token' progress))                  {                      cancellationToken.Token.ThrowIfCancellationRequested();                        if (filter == null)                      {                          progress.Report(new ProgressModel(UpdateState.Cancelled' "A filter wasn't downloaded successfully."' 0));                      }                      else if (filter.Exception != null)                      {                          if (filter.Exception is OperationCanceledException) throw filter.Exception;                          Trace.TraceError("Problem when downloading: " + filter.Exception);                          progress.Report(new ProgressModel(UpdateState.Cancelled' "Problem when downloading: " + filter.Exception.Message' 0));                          return;                      }                      else                      {                          foreach (var application in apps)                          {                              Trace.TraceInformation("Updating app {0} {1}"' application.Description' application.Version);                              await application.Application.UpdateFilterAsync(filter' cancellationToken.Token' progress);                          }                      }                        if (filter != null && filter.FilterTimestamp != null)                      {                          var message = $"Done. List timestamp: {filter.FilterTimestamp.Value.ToLocalTime()}";                          Trace.TraceInformation(message);                          progress.Report(new ProgressModel(UpdateState.Done' message' 100));                      }                      else                      {                          Trace.TraceInformation("Done.");                          progress.Report(new ProgressModel(UpdateState.Done' "Done"' 100));                      }                  }              }              catch (OperationCanceledException)              {                  Trace.TraceWarning("Update was cancelled.");                  progress.Report(new ProgressModel(UpdateState.Cancelled' "Update was cancelled."' 0));              }              catch (Exception ex)              {                  Trace.TraceError("Problem when updating: " + ex);                  progress.Report(new ProgressModel(UpdateState.Cancelled' "Problem when updating: " + ex.Message' 0));              }
Magic Number,IPFilter.ViewModels,MainWindowViewModel,C:\repos\DavidMoore_ipfilter\Code\IPFilter\ViewModels\MainWindowViewModel.cs,StartAsync,The following statement contains a magic number: try              {                  var uri = SelectedMirrorProvider.GetUrlForMirror(SelectedFileMirror);                    using (var filter = await downloader.DownloadFilter(new Uri(uri)' cancellationToken.Token' progress))                  {                      cancellationToken.Token.ThrowIfCancellationRequested();                        if (filter == null)                      {                          progress.Report(new ProgressModel(UpdateState.Cancelled' "A filter wasn't downloaded successfully."' 0));                      }                      else if (filter.Exception != null)                      {                          if (filter.Exception is OperationCanceledException) throw filter.Exception;                          Trace.TraceError("Problem when downloading: " + filter.Exception);                          progress.Report(new ProgressModel(UpdateState.Cancelled' "Problem when downloading: " + filter.Exception.Message' 0));                          return;                      }                      else                      {                          foreach (var application in apps)                          {                              Trace.TraceInformation("Updating app {0} {1}"' application.Description' application.Version);                              await application.Application.UpdateFilterAsync(filter' cancellationToken.Token' progress);                          }                      }                        if (filter != null && filter.FilterTimestamp != null)                      {                          var message = $"Done. List timestamp: {filter.FilterTimestamp.Value.ToLocalTime()}";                          Trace.TraceInformation(message);                          progress.Report(new ProgressModel(UpdateState.Done' message' 100));                      }                      else                      {                          Trace.TraceInformation("Done.");                          progress.Report(new ProgressModel(UpdateState.Done' "Done"' 100));                      }                  }              }              catch (OperationCanceledException)              {                  Trace.TraceWarning("Update was cancelled.");                  progress.Report(new ProgressModel(UpdateState.Cancelled' "Update was cancelled."' 0));              }              catch (Exception ex)              {                  Trace.TraceError("Problem when updating: " + ex);                  progress.Report(new ProgressModel(UpdateState.Cancelled' "Problem when updating: " + ex.Message' 0));              }
Magic Number,IPFilter.ViewModels,MainWindowViewModel,C:\repos\DavidMoore_ipfilter\Code\IPFilter\ViewModels\MainWindowViewModel.cs,CheckForUpdates,The following statement contains a magic number: try              {                  // Remove any old ClickOnce installs                  try                  {                      var uninstallInfo = UninstallInfo.Find("IPFilter Updater");                      if (uninstallInfo != null)                      {                          Trace.TraceWarning("Old ClickOnce app installed! Trying to remove...");                              var uninstaller = new Uninstaller();                              uninstaller.Uninstall(uninstallInfo);                              Trace.TraceInformation("Successfully removed ClickOnce app");                      }                  }                  catch (Exception ex)                  {                      Trace.TraceError("Failed to remove old ClickOnce app: " + ex);                      telemetryClient?.TrackException(ex);                  }                    Trace.TraceInformation("Checking for software updates...");                  progress.Report(new ProgressModel(UpdateState.Downloading' "Checking for software updates..."' -1));                    var updater = new Updater();                    var result = await updater.CheckForUpdateAsync();                    var currentVersion = new Version(Process.GetCurrentProcess().MainModule.FileVersionInfo.FileVersion);                    var latestVersion = new Version(result.Version);                                    Update.IsUpdateAvailable = latestVersion > currentVersion;                    if (Update.IsUpdateAvailable)                  {                      Update.AvailableVersion = latestVersion;                      Update.IsUpdateRequired = true;                      Update.MinimumRequiredVersion = latestVersion;                      Update.UpdateSizeBytes = 2000000;                  }                    Trace.TraceInformation("Current version: {0}"' Update.CurrentVersion);                  Trace.TraceInformation("Available version: {0}"' Update.AvailableVersion?.ToString() ?? "<no updates>");                    if (!Update.IsUpdateAvailable ) return;                                    if (MessageBoxHelper.Show(dispatcher' "Update Available"' MessageBoxButton.YesNo' MessageBoxImage.Question' MessageBoxResult.Yes'                      "An update to version {0} is available. Would you like to update now?"' Update.AvailableVersion) != MessageBoxResult.Yes)                  {                      return;                  }                                    Trace.TraceInformation("Starting application update...");                    // If we're not "installed"' then don't check for updates. This is so the                  // executable can be stand-alone. Stand-alone self-update to come later.                  using (var key = Registry.CurrentUser.OpenSubKey("SOFTWARE\\IPFilter"))                  {                      var installPath = (string) key?.GetValue("InstallPath");                      if (installPath == null)                      {                          using (var process = new Process())                          {                              process.StartInfo = new ProcessStartInfo("https://davidmoore.github.io/ipfilter/")                              {                                  UseShellExecute = true                              };                                process.Start();                              return;                          }                      }                  }                    var msiPath = Path.Combine(Path.GetTempPath()' "IPFilter.msi");                    // Download the installer                  using (var handler = new WebRequestHandler())                  {                      handler.AutomaticDecompression = DecompressionMethods.GZip | DecompressionMethods.Deflate;                        var uri = new Uri($"{result.Uri}?{DateTime.Now.ToString("yyyyMMddHHmmss")}");                        using (var httpClient = new HttpClient(handler))                      using (var response = await httpClient.GetAsync(uri' HttpCompletionOption.ResponseHeadersRead' cancellationToken.Token))                      {                          if (cancellationToken.IsCancellationRequested)                          {                              progress.Report(new ProgressModel(UpdateState.Ready' "Update cancelled. Ready."' 100));                              Update.IsUpdating = false;                              return;                          }                            var length = response.Content.Headers.ContentLength;                          double lengthInMb = !length.HasValue ? -1 : (double)length.Value / 1024 / 1024;                          double bytesDownloaded = 0;                            using(var stream = await response.Content.ReadAsStreamAsync())                          using(var msi = File.Open( msiPath' FileMode.Create' FileAccess.Write' FileShare.Read))                          {                              var buffer = new byte[65535 * 4];                                int bytesRead = await stream.ReadAsync(buffer' 0' buffer.Length' cancellationToken.Token);                              while (bytesRead != 0)                              {                                  await msi.WriteAsync(buffer' 0' bytesRead' cancellationToken.Token);                                  bytesDownloaded += bytesRead;                                    if (length.HasValue)                                  {                                      double downloadedMegs = bytesDownloaded / 1024 / 1024;                                      var percent = (int)Math.Floor((bytesDownloaded / length.Value) * 100);                                        var status = string.Format(CultureInfo.CurrentUICulture' "Downloaded {0:F2} MB of {1:F2} MB"' downloadedMegs' lengthInMb);                                        Update.IsUpdating = true;                                      Update.DownloadPercentage = percent;                                      progress.Report(new ProgressModel(UpdateState.Downloading' status' percent));                                  }                                    if (cancellationToken.IsCancellationRequested)                                  {                                      progress.Report(new ProgressModel(UpdateState.Ready' "Update cancelled. Ready."' 100));                                      Update.IsUpdating = false;                                      return;                                  }                                    bytesRead = await stream.ReadAsync(buffer' 0' buffer.Length' cancellationToken.Token);                              }                          }                      }                  }                    progress.Report(new ProgressModel(UpdateState.Ready' "Launching update..."' 100));                  Update.IsUpdating = false;                                    // Now run the installer                  var sb = new StringBuilder("msiexec.exe ");                    // Enable logging for the installer                  sb.AppendFormat(" /l*v \"{0}\""' Path.Combine(Path.GetTempPath()' "IPFilter.log"));                                    sb.AppendFormat(" /i \"{0}\""' msiPath);                    //sb.Append(" /passive");                    ProcessInformation processInformation = new ProcessInformation();                  StartupInfo startupInfo = new StartupInfo();                  SecurityAttributes processSecurity = new SecurityAttributes();                  SecurityAttributes threadSecurity = new SecurityAttributes();                  processSecurity.nLength = Marshal.SizeOf(processSecurity);                  threadSecurity.nLength = Marshal.SizeOf(threadSecurity);                    const int NormalPriorityClass = 0x0020;                    if (!ProcessManager.CreateProcess(null' sb' processSecurity'                      threadSecurity' false' NormalPriorityClass'                      IntPtr.Zero' null' startupInfo' processInformation))                  {                      throw Marshal.GetExceptionForHR(Marshal.GetHRForLastWin32Error());                  }                                    try                  {                      //dispatcher.Invoke(DispatcherPriority.Normal' new Action(Application.Current.Shutdown));                      Application.Current.Shutdown();                  }                  catch (Exception ex)                  {                      Trace.TraceError("Exception when shutting down app for update: " + ex);                      Update.ErrorMessage = "Couldn't shutdown the app to apply update.";                      telemetryClient?.TrackException(ex);                  }              }              catch (Exception ex)              {                  Trace.TraceWarning("Application update check failed: " + ex);                  telemetryClient?.TrackException(ex);                  telemetryClient?.Flush();              }              finally              {                  progress.Report(new ProgressModel(UpdateState.Ready' "Ready"' 0));              }
Magic Number,IPFilter.ViewModels,MainWindowViewModel,C:\repos\DavidMoore_ipfilter\Code\IPFilter\ViewModels\MainWindowViewModel.cs,CheckForUpdates,The following statement contains a magic number: try              {                  // Remove any old ClickOnce installs                  try                  {                      var uninstallInfo = UninstallInfo.Find("IPFilter Updater");                      if (uninstallInfo != null)                      {                          Trace.TraceWarning("Old ClickOnce app installed! Trying to remove...");                              var uninstaller = new Uninstaller();                              uninstaller.Uninstall(uninstallInfo);                              Trace.TraceInformation("Successfully removed ClickOnce app");                      }                  }                  catch (Exception ex)                  {                      Trace.TraceError("Failed to remove old ClickOnce app: " + ex);                      telemetryClient?.TrackException(ex);                  }                    Trace.TraceInformation("Checking for software updates...");                  progress.Report(new ProgressModel(UpdateState.Downloading' "Checking for software updates..."' -1));                    var updater = new Updater();                    var result = await updater.CheckForUpdateAsync();                    var currentVersion = new Version(Process.GetCurrentProcess().MainModule.FileVersionInfo.FileVersion);                    var latestVersion = new Version(result.Version);                                    Update.IsUpdateAvailable = latestVersion > currentVersion;                    if (Update.IsUpdateAvailable)                  {                      Update.AvailableVersion = latestVersion;                      Update.IsUpdateRequired = true;                      Update.MinimumRequiredVersion = latestVersion;                      Update.UpdateSizeBytes = 2000000;                  }                    Trace.TraceInformation("Current version: {0}"' Update.CurrentVersion);                  Trace.TraceInformation("Available version: {0}"' Update.AvailableVersion?.ToString() ?? "<no updates>");                    if (!Update.IsUpdateAvailable ) return;                                    if (MessageBoxHelper.Show(dispatcher' "Update Available"' MessageBoxButton.YesNo' MessageBoxImage.Question' MessageBoxResult.Yes'                      "An update to version {0} is available. Would you like to update now?"' Update.AvailableVersion) != MessageBoxResult.Yes)                  {                      return;                  }                                    Trace.TraceInformation("Starting application update...");                    // If we're not "installed"' then don't check for updates. This is so the                  // executable can be stand-alone. Stand-alone self-update to come later.                  using (var key = Registry.CurrentUser.OpenSubKey("SOFTWARE\\IPFilter"))                  {                      var installPath = (string) key?.GetValue("InstallPath");                      if (installPath == null)                      {                          using (var process = new Process())                          {                              process.StartInfo = new ProcessStartInfo("https://davidmoore.github.io/ipfilter/")                              {                                  UseShellExecute = true                              };                                process.Start();                              return;                          }                      }                  }                    var msiPath = Path.Combine(Path.GetTempPath()' "IPFilter.msi");                    // Download the installer                  using (var handler = new WebRequestHandler())                  {                      handler.AutomaticDecompression = DecompressionMethods.GZip | DecompressionMethods.Deflate;                        var uri = new Uri($"{result.Uri}?{DateTime.Now.ToString("yyyyMMddHHmmss")}");                        using (var httpClient = new HttpClient(handler))                      using (var response = await httpClient.GetAsync(uri' HttpCompletionOption.ResponseHeadersRead' cancellationToken.Token))                      {                          if (cancellationToken.IsCancellationRequested)                          {                              progress.Report(new ProgressModel(UpdateState.Ready' "Update cancelled. Ready."' 100));                              Update.IsUpdating = false;                              return;                          }                            var length = response.Content.Headers.ContentLength;                          double lengthInMb = !length.HasValue ? -1 : (double)length.Value / 1024 / 1024;                          double bytesDownloaded = 0;                            using(var stream = await response.Content.ReadAsStreamAsync())                          using(var msi = File.Open( msiPath' FileMode.Create' FileAccess.Write' FileShare.Read))                          {                              var buffer = new byte[65535 * 4];                                int bytesRead = await stream.ReadAsync(buffer' 0' buffer.Length' cancellationToken.Token);                              while (bytesRead != 0)                              {                                  await msi.WriteAsync(buffer' 0' bytesRead' cancellationToken.Token);                                  bytesDownloaded += bytesRead;                                    if (length.HasValue)                                  {                                      double downloadedMegs = bytesDownloaded / 1024 / 1024;                                      var percent = (int)Math.Floor((bytesDownloaded / length.Value) * 100);                                        var status = string.Format(CultureInfo.CurrentUICulture' "Downloaded {0:F2} MB of {1:F2} MB"' downloadedMegs' lengthInMb);                                        Update.IsUpdating = true;                                      Update.DownloadPercentage = percent;                                      progress.Report(new ProgressModel(UpdateState.Downloading' status' percent));                                  }                                    if (cancellationToken.IsCancellationRequested)                                  {                                      progress.Report(new ProgressModel(UpdateState.Ready' "Update cancelled. Ready."' 100));                                      Update.IsUpdating = false;                                      return;                                  }                                    bytesRead = await stream.ReadAsync(buffer' 0' buffer.Length' cancellationToken.Token);                              }                          }                      }                  }                    progress.Report(new ProgressModel(UpdateState.Ready' "Launching update..."' 100));                  Update.IsUpdating = false;                                    // Now run the installer                  var sb = new StringBuilder("msiexec.exe ");                    // Enable logging for the installer                  sb.AppendFormat(" /l*v \"{0}\""' Path.Combine(Path.GetTempPath()' "IPFilter.log"));                                    sb.AppendFormat(" /i \"{0}\""' msiPath);                    //sb.Append(" /passive");                    ProcessInformation processInformation = new ProcessInformation();                  StartupInfo startupInfo = new StartupInfo();                  SecurityAttributes processSecurity = new SecurityAttributes();                  SecurityAttributes threadSecurity = new SecurityAttributes();                  processSecurity.nLength = Marshal.SizeOf(processSecurity);                  threadSecurity.nLength = Marshal.SizeOf(threadSecurity);                    const int NormalPriorityClass = 0x0020;                    if (!ProcessManager.CreateProcess(null' sb' processSecurity'                      threadSecurity' false' NormalPriorityClass'                      IntPtr.Zero' null' startupInfo' processInformation))                  {                      throw Marshal.GetExceptionForHR(Marshal.GetHRForLastWin32Error());                  }                                    try                  {                      //dispatcher.Invoke(DispatcherPriority.Normal' new Action(Application.Current.Shutdown));                      Application.Current.Shutdown();                  }                  catch (Exception ex)                  {                      Trace.TraceError("Exception when shutting down app for update: " + ex);                      Update.ErrorMessage = "Couldn't shutdown the app to apply update.";                      telemetryClient?.TrackException(ex);                  }              }              catch (Exception ex)              {                  Trace.TraceWarning("Application update check failed: " + ex);                  telemetryClient?.TrackException(ex);                  telemetryClient?.Flush();              }              finally              {                  progress.Report(new ProgressModel(UpdateState.Ready' "Ready"' 0));              }
Magic Number,IPFilter.ViewModels,MainWindowViewModel,C:\repos\DavidMoore_ipfilter\Code\IPFilter\ViewModels\MainWindowViewModel.cs,CheckForUpdates,The following statement contains a magic number: try              {                  // Remove any old ClickOnce installs                  try                  {                      var uninstallInfo = UninstallInfo.Find("IPFilter Updater");                      if (uninstallInfo != null)                      {                          Trace.TraceWarning("Old ClickOnce app installed! Trying to remove...");                              var uninstaller = new Uninstaller();                              uninstaller.Uninstall(uninstallInfo);                              Trace.TraceInformation("Successfully removed ClickOnce app");                      }                  }                  catch (Exception ex)                  {                      Trace.TraceError("Failed to remove old ClickOnce app: " + ex);                      telemetryClient?.TrackException(ex);                  }                    Trace.TraceInformation("Checking for software updates...");                  progress.Report(new ProgressModel(UpdateState.Downloading' "Checking for software updates..."' -1));                    var updater = new Updater();                    var result = await updater.CheckForUpdateAsync();                    var currentVersion = new Version(Process.GetCurrentProcess().MainModule.FileVersionInfo.FileVersion);                    var latestVersion = new Version(result.Version);                                    Update.IsUpdateAvailable = latestVersion > currentVersion;                    if (Update.IsUpdateAvailable)                  {                      Update.AvailableVersion = latestVersion;                      Update.IsUpdateRequired = true;                      Update.MinimumRequiredVersion = latestVersion;                      Update.UpdateSizeBytes = 2000000;                  }                    Trace.TraceInformation("Current version: {0}"' Update.CurrentVersion);                  Trace.TraceInformation("Available version: {0}"' Update.AvailableVersion?.ToString() ?? "<no updates>");                    if (!Update.IsUpdateAvailable ) return;                                    if (MessageBoxHelper.Show(dispatcher' "Update Available"' MessageBoxButton.YesNo' MessageBoxImage.Question' MessageBoxResult.Yes'                      "An update to version {0} is available. Would you like to update now?"' Update.AvailableVersion) != MessageBoxResult.Yes)                  {                      return;                  }                                    Trace.TraceInformation("Starting application update...");                    // If we're not "installed"' then don't check for updates. This is so the                  // executable can be stand-alone. Stand-alone self-update to come later.                  using (var key = Registry.CurrentUser.OpenSubKey("SOFTWARE\\IPFilter"))                  {                      var installPath = (string) key?.GetValue("InstallPath");                      if (installPath == null)                      {                          using (var process = new Process())                          {                              process.StartInfo = new ProcessStartInfo("https://davidmoore.github.io/ipfilter/")                              {                                  UseShellExecute = true                              };                                process.Start();                              return;                          }                      }                  }                    var msiPath = Path.Combine(Path.GetTempPath()' "IPFilter.msi");                    // Download the installer                  using (var handler = new WebRequestHandler())                  {                      handler.AutomaticDecompression = DecompressionMethods.GZip | DecompressionMethods.Deflate;                        var uri = new Uri($"{result.Uri}?{DateTime.Now.ToString("yyyyMMddHHmmss")}");                        using (var httpClient = new HttpClient(handler))                      using (var response = await httpClient.GetAsync(uri' HttpCompletionOption.ResponseHeadersRead' cancellationToken.Token))                      {                          if (cancellationToken.IsCancellationRequested)                          {                              progress.Report(new ProgressModel(UpdateState.Ready' "Update cancelled. Ready."' 100));                              Update.IsUpdating = false;                              return;                          }                            var length = response.Content.Headers.ContentLength;                          double lengthInMb = !length.HasValue ? -1 : (double)length.Value / 1024 / 1024;                          double bytesDownloaded = 0;                            using(var stream = await response.Content.ReadAsStreamAsync())                          using(var msi = File.Open( msiPath' FileMode.Create' FileAccess.Write' FileShare.Read))                          {                              var buffer = new byte[65535 * 4];                                int bytesRead = await stream.ReadAsync(buffer' 0' buffer.Length' cancellationToken.Token);                              while (bytesRead != 0)                              {                                  await msi.WriteAsync(buffer' 0' bytesRead' cancellationToken.Token);                                  bytesDownloaded += bytesRead;                                    if (length.HasValue)                                  {                                      double downloadedMegs = bytesDownloaded / 1024 / 1024;                                      var percent = (int)Math.Floor((bytesDownloaded / length.Value) * 100);                                        var status = string.Format(CultureInfo.CurrentUICulture' "Downloaded {0:F2} MB of {1:F2} MB"' downloadedMegs' lengthInMb);                                        Update.IsUpdating = true;                                      Update.DownloadPercentage = percent;                                      progress.Report(new ProgressModel(UpdateState.Downloading' status' percent));                                  }                                    if (cancellationToken.IsCancellationRequested)                                  {                                      progress.Report(new ProgressModel(UpdateState.Ready' "Update cancelled. Ready."' 100));                                      Update.IsUpdating = false;                                      return;                                  }                                    bytesRead = await stream.ReadAsync(buffer' 0' buffer.Length' cancellationToken.Token);                              }                          }                      }                  }                    progress.Report(new ProgressModel(UpdateState.Ready' "Launching update..."' 100));                  Update.IsUpdating = false;                                    // Now run the installer                  var sb = new StringBuilder("msiexec.exe ");                    // Enable logging for the installer                  sb.AppendFormat(" /l*v \"{0}\""' Path.Combine(Path.GetTempPath()' "IPFilter.log"));                                    sb.AppendFormat(" /i \"{0}\""' msiPath);                    //sb.Append(" /passive");                    ProcessInformation processInformation = new ProcessInformation();                  StartupInfo startupInfo = new StartupInfo();                  SecurityAttributes processSecurity = new SecurityAttributes();                  SecurityAttributes threadSecurity = new SecurityAttributes();                  processSecurity.nLength = Marshal.SizeOf(processSecurity);                  threadSecurity.nLength = Marshal.SizeOf(threadSecurity);                    const int NormalPriorityClass = 0x0020;                    if (!ProcessManager.CreateProcess(null' sb' processSecurity'                      threadSecurity' false' NormalPriorityClass'                      IntPtr.Zero' null' startupInfo' processInformation))                  {                      throw Marshal.GetExceptionForHR(Marshal.GetHRForLastWin32Error());                  }                                    try                  {                      //dispatcher.Invoke(DispatcherPriority.Normal' new Action(Application.Current.Shutdown));                      Application.Current.Shutdown();                  }                  catch (Exception ex)                  {                      Trace.TraceError("Exception when shutting down app for update: " + ex);                      Update.ErrorMessage = "Couldn't shutdown the app to apply update.";                      telemetryClient?.TrackException(ex);                  }              }              catch (Exception ex)              {                  Trace.TraceWarning("Application update check failed: " + ex);                  telemetryClient?.TrackException(ex);                  telemetryClient?.Flush();              }              finally              {                  progress.Report(new ProgressModel(UpdateState.Ready' "Ready"' 0));              }
Magic Number,IPFilter.ViewModels,MainWindowViewModel,C:\repos\DavidMoore_ipfilter\Code\IPFilter\ViewModels\MainWindowViewModel.cs,CheckForUpdates,The following statement contains a magic number: try              {                  // Remove any old ClickOnce installs                  try                  {                      var uninstallInfo = UninstallInfo.Find("IPFilter Updater");                      if (uninstallInfo != null)                      {                          Trace.TraceWarning("Old ClickOnce app installed! Trying to remove...");                              var uninstaller = new Uninstaller();                              uninstaller.Uninstall(uninstallInfo);                              Trace.TraceInformation("Successfully removed ClickOnce app");                      }                  }                  catch (Exception ex)                  {                      Trace.TraceError("Failed to remove old ClickOnce app: " + ex);                      telemetryClient?.TrackException(ex);                  }                    Trace.TraceInformation("Checking for software updates...");                  progress.Report(new ProgressModel(UpdateState.Downloading' "Checking for software updates..."' -1));                    var updater = new Updater();                    var result = await updater.CheckForUpdateAsync();                    var currentVersion = new Version(Process.GetCurrentProcess().MainModule.FileVersionInfo.FileVersion);                    var latestVersion = new Version(result.Version);                                    Update.IsUpdateAvailable = latestVersion > currentVersion;                    if (Update.IsUpdateAvailable)                  {                      Update.AvailableVersion = latestVersion;                      Update.IsUpdateRequired = true;                      Update.MinimumRequiredVersion = latestVersion;                      Update.UpdateSizeBytes = 2000000;                  }                    Trace.TraceInformation("Current version: {0}"' Update.CurrentVersion);                  Trace.TraceInformation("Available version: {0}"' Update.AvailableVersion?.ToString() ?? "<no updates>");                    if (!Update.IsUpdateAvailable ) return;                                    if (MessageBoxHelper.Show(dispatcher' "Update Available"' MessageBoxButton.YesNo' MessageBoxImage.Question' MessageBoxResult.Yes'                      "An update to version {0} is available. Would you like to update now?"' Update.AvailableVersion) != MessageBoxResult.Yes)                  {                      return;                  }                                    Trace.TraceInformation("Starting application update...");                    // If we're not "installed"' then don't check for updates. This is so the                  // executable can be stand-alone. Stand-alone self-update to come later.                  using (var key = Registry.CurrentUser.OpenSubKey("SOFTWARE\\IPFilter"))                  {                      var installPath = (string) key?.GetValue("InstallPath");                      if (installPath == null)                      {                          using (var process = new Process())                          {                              process.StartInfo = new ProcessStartInfo("https://davidmoore.github.io/ipfilter/")                              {                                  UseShellExecute = true                              };                                process.Start();                              return;                          }                      }                  }                    var msiPath = Path.Combine(Path.GetTempPath()' "IPFilter.msi");                    // Download the installer                  using (var handler = new WebRequestHandler())                  {                      handler.AutomaticDecompression = DecompressionMethods.GZip | DecompressionMethods.Deflate;                        var uri = new Uri($"{result.Uri}?{DateTime.Now.ToString("yyyyMMddHHmmss")}");                        using (var httpClient = new HttpClient(handler))                      using (var response = await httpClient.GetAsync(uri' HttpCompletionOption.ResponseHeadersRead' cancellationToken.Token))                      {                          if (cancellationToken.IsCancellationRequested)                          {                              progress.Report(new ProgressModel(UpdateState.Ready' "Update cancelled. Ready."' 100));                              Update.IsUpdating = false;                              return;                          }                            var length = response.Content.Headers.ContentLength;                          double lengthInMb = !length.HasValue ? -1 : (double)length.Value / 1024 / 1024;                          double bytesDownloaded = 0;                            using(var stream = await response.Content.ReadAsStreamAsync())                          using(var msi = File.Open( msiPath' FileMode.Create' FileAccess.Write' FileShare.Read))                          {                              var buffer = new byte[65535 * 4];                                int bytesRead = await stream.ReadAsync(buffer' 0' buffer.Length' cancellationToken.Token);                              while (bytesRead != 0)                              {                                  await msi.WriteAsync(buffer' 0' bytesRead' cancellationToken.Token);                                  bytesDownloaded += bytesRead;                                    if (length.HasValue)                                  {                                      double downloadedMegs = bytesDownloaded / 1024 / 1024;                                      var percent = (int)Math.Floor((bytesDownloaded / length.Value) * 100);                                        var status = string.Format(CultureInfo.CurrentUICulture' "Downloaded {0:F2} MB of {1:F2} MB"' downloadedMegs' lengthInMb);                                        Update.IsUpdating = true;                                      Update.DownloadPercentage = percent;                                      progress.Report(new ProgressModel(UpdateState.Downloading' status' percent));                                  }                                    if (cancellationToken.IsCancellationRequested)                                  {                                      progress.Report(new ProgressModel(UpdateState.Ready' "Update cancelled. Ready."' 100));                                      Update.IsUpdating = false;                                      return;                                  }                                    bytesRead = await stream.ReadAsync(buffer' 0' buffer.Length' cancellationToken.Token);                              }                          }                      }                  }                    progress.Report(new ProgressModel(UpdateState.Ready' "Launching update..."' 100));                  Update.IsUpdating = false;                                    // Now run the installer                  var sb = new StringBuilder("msiexec.exe ");                    // Enable logging for the installer                  sb.AppendFormat(" /l*v \"{0}\""' Path.Combine(Path.GetTempPath()' "IPFilter.log"));                                    sb.AppendFormat(" /i \"{0}\""' msiPath);                    //sb.Append(" /passive");                    ProcessInformation processInformation = new ProcessInformation();                  StartupInfo startupInfo = new StartupInfo();                  SecurityAttributes processSecurity = new SecurityAttributes();                  SecurityAttributes threadSecurity = new SecurityAttributes();                  processSecurity.nLength = Marshal.SizeOf(processSecurity);                  threadSecurity.nLength = Marshal.SizeOf(threadSecurity);                    const int NormalPriorityClass = 0x0020;                    if (!ProcessManager.CreateProcess(null' sb' processSecurity'                      threadSecurity' false' NormalPriorityClass'                      IntPtr.Zero' null' startupInfo' processInformation))                  {                      throw Marshal.GetExceptionForHR(Marshal.GetHRForLastWin32Error());                  }                                    try                  {                      //dispatcher.Invoke(DispatcherPriority.Normal' new Action(Application.Current.Shutdown));                      Application.Current.Shutdown();                  }                  catch (Exception ex)                  {                      Trace.TraceError("Exception when shutting down app for update: " + ex);                      Update.ErrorMessage = "Couldn't shutdown the app to apply update.";                      telemetryClient?.TrackException(ex);                  }              }              catch (Exception ex)              {                  Trace.TraceWarning("Application update check failed: " + ex);                  telemetryClient?.TrackException(ex);                  telemetryClient?.Flush();              }              finally              {                  progress.Report(new ProgressModel(UpdateState.Ready' "Ready"' 0));              }
Magic Number,IPFilter.ViewModels,MainWindowViewModel,C:\repos\DavidMoore_ipfilter\Code\IPFilter\ViewModels\MainWindowViewModel.cs,CheckForUpdates,The following statement contains a magic number: try              {                  // Remove any old ClickOnce installs                  try                  {                      var uninstallInfo = UninstallInfo.Find("IPFilter Updater");                      if (uninstallInfo != null)                      {                          Trace.TraceWarning("Old ClickOnce app installed! Trying to remove...");                              var uninstaller = new Uninstaller();                              uninstaller.Uninstall(uninstallInfo);                              Trace.TraceInformation("Successfully removed ClickOnce app");                      }                  }                  catch (Exception ex)                  {                      Trace.TraceError("Failed to remove old ClickOnce app: " + ex);                      telemetryClient?.TrackException(ex);                  }                    Trace.TraceInformation("Checking for software updates...");                  progress.Report(new ProgressModel(UpdateState.Downloading' "Checking for software updates..."' -1));                    var updater = new Updater();                    var result = await updater.CheckForUpdateAsync();                    var currentVersion = new Version(Process.GetCurrentProcess().MainModule.FileVersionInfo.FileVersion);                    var latestVersion = new Version(result.Version);                                    Update.IsUpdateAvailable = latestVersion > currentVersion;                    if (Update.IsUpdateAvailable)                  {                      Update.AvailableVersion = latestVersion;                      Update.IsUpdateRequired = true;                      Update.MinimumRequiredVersion = latestVersion;                      Update.UpdateSizeBytes = 2000000;                  }                    Trace.TraceInformation("Current version: {0}"' Update.CurrentVersion);                  Trace.TraceInformation("Available version: {0}"' Update.AvailableVersion?.ToString() ?? "<no updates>");                    if (!Update.IsUpdateAvailable ) return;                                    if (MessageBoxHelper.Show(dispatcher' "Update Available"' MessageBoxButton.YesNo' MessageBoxImage.Question' MessageBoxResult.Yes'                      "An update to version {0} is available. Would you like to update now?"' Update.AvailableVersion) != MessageBoxResult.Yes)                  {                      return;                  }                                    Trace.TraceInformation("Starting application update...");                    // If we're not "installed"' then don't check for updates. This is so the                  // executable can be stand-alone. Stand-alone self-update to come later.                  using (var key = Registry.CurrentUser.OpenSubKey("SOFTWARE\\IPFilter"))                  {                      var installPath = (string) key?.GetValue("InstallPath");                      if (installPath == null)                      {                          using (var process = new Process())                          {                              process.StartInfo = new ProcessStartInfo("https://davidmoore.github.io/ipfilter/")                              {                                  UseShellExecute = true                              };                                process.Start();                              return;                          }                      }                  }                    var msiPath = Path.Combine(Path.GetTempPath()' "IPFilter.msi");                    // Download the installer                  using (var handler = new WebRequestHandler())                  {                      handler.AutomaticDecompression = DecompressionMethods.GZip | DecompressionMethods.Deflate;                        var uri = new Uri($"{result.Uri}?{DateTime.Now.ToString("yyyyMMddHHmmss")}");                        using (var httpClient = new HttpClient(handler))                      using (var response = await httpClient.GetAsync(uri' HttpCompletionOption.ResponseHeadersRead' cancellationToken.Token))                      {                          if (cancellationToken.IsCancellationRequested)                          {                              progress.Report(new ProgressModel(UpdateState.Ready' "Update cancelled. Ready."' 100));                              Update.IsUpdating = false;                              return;                          }                            var length = response.Content.Headers.ContentLength;                          double lengthInMb = !length.HasValue ? -1 : (double)length.Value / 1024 / 1024;                          double bytesDownloaded = 0;                            using(var stream = await response.Content.ReadAsStreamAsync())                          using(var msi = File.Open( msiPath' FileMode.Create' FileAccess.Write' FileShare.Read))                          {                              var buffer = new byte[65535 * 4];                                int bytesRead = await stream.ReadAsync(buffer' 0' buffer.Length' cancellationToken.Token);                              while (bytesRead != 0)                              {                                  await msi.WriteAsync(buffer' 0' bytesRead' cancellationToken.Token);                                  bytesDownloaded += bytesRead;                                    if (length.HasValue)                                  {                                      double downloadedMegs = bytesDownloaded / 1024 / 1024;                                      var percent = (int)Math.Floor((bytesDownloaded / length.Value) * 100);                                        var status = string.Format(CultureInfo.CurrentUICulture' "Downloaded {0:F2} MB of {1:F2} MB"' downloadedMegs' lengthInMb);                                        Update.IsUpdating = true;                                      Update.DownloadPercentage = percent;                                      progress.Report(new ProgressModel(UpdateState.Downloading' status' percent));                                  }                                    if (cancellationToken.IsCancellationRequested)                                  {                                      progress.Report(new ProgressModel(UpdateState.Ready' "Update cancelled. Ready."' 100));                                      Update.IsUpdating = false;                                      return;                                  }                                    bytesRead = await stream.ReadAsync(buffer' 0' buffer.Length' cancellationToken.Token);                              }                          }                      }                  }                    progress.Report(new ProgressModel(UpdateState.Ready' "Launching update..."' 100));                  Update.IsUpdating = false;                                    // Now run the installer                  var sb = new StringBuilder("msiexec.exe ");                    // Enable logging for the installer                  sb.AppendFormat(" /l*v \"{0}\""' Path.Combine(Path.GetTempPath()' "IPFilter.log"));                                    sb.AppendFormat(" /i \"{0}\""' msiPath);                    //sb.Append(" /passive");                    ProcessInformation processInformation = new ProcessInformation();                  StartupInfo startupInfo = new StartupInfo();                  SecurityAttributes processSecurity = new SecurityAttributes();                  SecurityAttributes threadSecurity = new SecurityAttributes();                  processSecurity.nLength = Marshal.SizeOf(processSecurity);                  threadSecurity.nLength = Marshal.SizeOf(threadSecurity);                    const int NormalPriorityClass = 0x0020;                    if (!ProcessManager.CreateProcess(null' sb' processSecurity'                      threadSecurity' false' NormalPriorityClass'                      IntPtr.Zero' null' startupInfo' processInformation))                  {                      throw Marshal.GetExceptionForHR(Marshal.GetHRForLastWin32Error());                  }                                    try                  {                      //dispatcher.Invoke(DispatcherPriority.Normal' new Action(Application.Current.Shutdown));                      Application.Current.Shutdown();                  }                  catch (Exception ex)                  {                      Trace.TraceError("Exception when shutting down app for update: " + ex);                      Update.ErrorMessage = "Couldn't shutdown the app to apply update.";                      telemetryClient?.TrackException(ex);                  }              }              catch (Exception ex)              {                  Trace.TraceWarning("Application update check failed: " + ex);                  telemetryClient?.TrackException(ex);                  telemetryClient?.Flush();              }              finally              {                  progress.Report(new ProgressModel(UpdateState.Ready' "Ready"' 0));              }
Magic Number,IPFilter.ViewModels,MainWindowViewModel,C:\repos\DavidMoore_ipfilter\Code\IPFilter\ViewModels\MainWindowViewModel.cs,CheckForUpdates,The following statement contains a magic number: try              {                  // Remove any old ClickOnce installs                  try                  {                      var uninstallInfo = UninstallInfo.Find("IPFilter Updater");                      if (uninstallInfo != null)                      {                          Trace.TraceWarning("Old ClickOnce app installed! Trying to remove...");                              var uninstaller = new Uninstaller();                              uninstaller.Uninstall(uninstallInfo);                              Trace.TraceInformation("Successfully removed ClickOnce app");                      }                  }                  catch (Exception ex)                  {                      Trace.TraceError("Failed to remove old ClickOnce app: " + ex);                      telemetryClient?.TrackException(ex);                  }                    Trace.TraceInformation("Checking for software updates...");                  progress.Report(new ProgressModel(UpdateState.Downloading' "Checking for software updates..."' -1));                    var updater = new Updater();                    var result = await updater.CheckForUpdateAsync();                    var currentVersion = new Version(Process.GetCurrentProcess().MainModule.FileVersionInfo.FileVersion);                    var latestVersion = new Version(result.Version);                                    Update.IsUpdateAvailable = latestVersion > currentVersion;                    if (Update.IsUpdateAvailable)                  {                      Update.AvailableVersion = latestVersion;                      Update.IsUpdateRequired = true;                      Update.MinimumRequiredVersion = latestVersion;                      Update.UpdateSizeBytes = 2000000;                  }                    Trace.TraceInformation("Current version: {0}"' Update.CurrentVersion);                  Trace.TraceInformation("Available version: {0}"' Update.AvailableVersion?.ToString() ?? "<no updates>");                    if (!Update.IsUpdateAvailable ) return;                                    if (MessageBoxHelper.Show(dispatcher' "Update Available"' MessageBoxButton.YesNo' MessageBoxImage.Question' MessageBoxResult.Yes'                      "An update to version {0} is available. Would you like to update now?"' Update.AvailableVersion) != MessageBoxResult.Yes)                  {                      return;                  }                                    Trace.TraceInformation("Starting application update...");                    // If we're not "installed"' then don't check for updates. This is so the                  // executable can be stand-alone. Stand-alone self-update to come later.                  using (var key = Registry.CurrentUser.OpenSubKey("SOFTWARE\\IPFilter"))                  {                      var installPath = (string) key?.GetValue("InstallPath");                      if (installPath == null)                      {                          using (var process = new Process())                          {                              process.StartInfo = new ProcessStartInfo("https://davidmoore.github.io/ipfilter/")                              {                                  UseShellExecute = true                              };                                process.Start();                              return;                          }                      }                  }                    var msiPath = Path.Combine(Path.GetTempPath()' "IPFilter.msi");                    // Download the installer                  using (var handler = new WebRequestHandler())                  {                      handler.AutomaticDecompression = DecompressionMethods.GZip | DecompressionMethods.Deflate;                        var uri = new Uri($"{result.Uri}?{DateTime.Now.ToString("yyyyMMddHHmmss")}");                        using (var httpClient = new HttpClient(handler))                      using (var response = await httpClient.GetAsync(uri' HttpCompletionOption.ResponseHeadersRead' cancellationToken.Token))                      {                          if (cancellationToken.IsCancellationRequested)                          {                              progress.Report(new ProgressModel(UpdateState.Ready' "Update cancelled. Ready."' 100));                              Update.IsUpdating = false;                              return;                          }                            var length = response.Content.Headers.ContentLength;                          double lengthInMb = !length.HasValue ? -1 : (double)length.Value / 1024 / 1024;                          double bytesDownloaded = 0;                            using(var stream = await response.Content.ReadAsStreamAsync())                          using(var msi = File.Open( msiPath' FileMode.Create' FileAccess.Write' FileShare.Read))                          {                              var buffer = new byte[65535 * 4];                                int bytesRead = await stream.ReadAsync(buffer' 0' buffer.Length' cancellationToken.Token);                              while (bytesRead != 0)                              {                                  await msi.WriteAsync(buffer' 0' bytesRead' cancellationToken.Token);                                  bytesDownloaded += bytesRead;                                    if (length.HasValue)                                  {                                      double downloadedMegs = bytesDownloaded / 1024 / 1024;                                      var percent = (int)Math.Floor((bytesDownloaded / length.Value) * 100);                                        var status = string.Format(CultureInfo.CurrentUICulture' "Downloaded {0:F2} MB of {1:F2} MB"' downloadedMegs' lengthInMb);                                        Update.IsUpdating = true;                                      Update.DownloadPercentage = percent;                                      progress.Report(new ProgressModel(UpdateState.Downloading' status' percent));                                  }                                    if (cancellationToken.IsCancellationRequested)                                  {                                      progress.Report(new ProgressModel(UpdateState.Ready' "Update cancelled. Ready."' 100));                                      Update.IsUpdating = false;                                      return;                                  }                                    bytesRead = await stream.ReadAsync(buffer' 0' buffer.Length' cancellationToken.Token);                              }                          }                      }                  }                    progress.Report(new ProgressModel(UpdateState.Ready' "Launching update..."' 100));                  Update.IsUpdating = false;                                    // Now run the installer                  var sb = new StringBuilder("msiexec.exe ");                    // Enable logging for the installer                  sb.AppendFormat(" /l*v \"{0}\""' Path.Combine(Path.GetTempPath()' "IPFilter.log"));                                    sb.AppendFormat(" /i \"{0}\""' msiPath);                    //sb.Append(" /passive");                    ProcessInformation processInformation = new ProcessInformation();                  StartupInfo startupInfo = new StartupInfo();                  SecurityAttributes processSecurity = new SecurityAttributes();                  SecurityAttributes threadSecurity = new SecurityAttributes();                  processSecurity.nLength = Marshal.SizeOf(processSecurity);                  threadSecurity.nLength = Marshal.SizeOf(threadSecurity);                    const int NormalPriorityClass = 0x0020;                    if (!ProcessManager.CreateProcess(null' sb' processSecurity'                      threadSecurity' false' NormalPriorityClass'                      IntPtr.Zero' null' startupInfo' processInformation))                  {                      throw Marshal.GetExceptionForHR(Marshal.GetHRForLastWin32Error());                  }                                    try                  {                      //dispatcher.Invoke(DispatcherPriority.Normal' new Action(Application.Current.Shutdown));                      Application.Current.Shutdown();                  }                  catch (Exception ex)                  {                      Trace.TraceError("Exception when shutting down app for update: " + ex);                      Update.ErrorMessage = "Couldn't shutdown the app to apply update.";                      telemetryClient?.TrackException(ex);                  }              }              catch (Exception ex)              {                  Trace.TraceWarning("Application update check failed: " + ex);                  telemetryClient?.TrackException(ex);                  telemetryClient?.Flush();              }              finally              {                  progress.Report(new ProgressModel(UpdateState.Ready' "Ready"' 0));              }
Magic Number,IPFilter.ViewModels,MainWindowViewModel,C:\repos\DavidMoore_ipfilter\Code\IPFilter\ViewModels\MainWindowViewModel.cs,CheckForUpdates,The following statement contains a magic number: try              {                  // Remove any old ClickOnce installs                  try                  {                      var uninstallInfo = UninstallInfo.Find("IPFilter Updater");                      if (uninstallInfo != null)                      {                          Trace.TraceWarning("Old ClickOnce app installed! Trying to remove...");                              var uninstaller = new Uninstaller();                              uninstaller.Uninstall(uninstallInfo);                              Trace.TraceInformation("Successfully removed ClickOnce app");                      }                  }                  catch (Exception ex)                  {                      Trace.TraceError("Failed to remove old ClickOnce app: " + ex);                      telemetryClient?.TrackException(ex);                  }                    Trace.TraceInformation("Checking for software updates...");                  progress.Report(new ProgressModel(UpdateState.Downloading' "Checking for software updates..."' -1));                    var updater = new Updater();                    var result = await updater.CheckForUpdateAsync();                    var currentVersion = new Version(Process.GetCurrentProcess().MainModule.FileVersionInfo.FileVersion);                    var latestVersion = new Version(result.Version);                                    Update.IsUpdateAvailable = latestVersion > currentVersion;                    if (Update.IsUpdateAvailable)                  {                      Update.AvailableVersion = latestVersion;                      Update.IsUpdateRequired = true;                      Update.MinimumRequiredVersion = latestVersion;                      Update.UpdateSizeBytes = 2000000;                  }                    Trace.TraceInformation("Current version: {0}"' Update.CurrentVersion);                  Trace.TraceInformation("Available version: {0}"' Update.AvailableVersion?.ToString() ?? "<no updates>");                    if (!Update.IsUpdateAvailable ) return;                                    if (MessageBoxHelper.Show(dispatcher' "Update Available"' MessageBoxButton.YesNo' MessageBoxImage.Question' MessageBoxResult.Yes'                      "An update to version {0} is available. Would you like to update now?"' Update.AvailableVersion) != MessageBoxResult.Yes)                  {                      return;                  }                                    Trace.TraceInformation("Starting application update...");                    // If we're not "installed"' then don't check for updates. This is so the                  // executable can be stand-alone. Stand-alone self-update to come later.                  using (var key = Registry.CurrentUser.OpenSubKey("SOFTWARE\\IPFilter"))                  {                      var installPath = (string) key?.GetValue("InstallPath");                      if (installPath == null)                      {                          using (var process = new Process())                          {                              process.StartInfo = new ProcessStartInfo("https://davidmoore.github.io/ipfilter/")                              {                                  UseShellExecute = true                              };                                process.Start();                              return;                          }                      }                  }                    var msiPath = Path.Combine(Path.GetTempPath()' "IPFilter.msi");                    // Download the installer                  using (var handler = new WebRequestHandler())                  {                      handler.AutomaticDecompression = DecompressionMethods.GZip | DecompressionMethods.Deflate;                        var uri = new Uri($"{result.Uri}?{DateTime.Now.ToString("yyyyMMddHHmmss")}");                        using (var httpClient = new HttpClient(handler))                      using (var response = await httpClient.GetAsync(uri' HttpCompletionOption.ResponseHeadersRead' cancellationToken.Token))                      {                          if (cancellationToken.IsCancellationRequested)                          {                              progress.Report(new ProgressModel(UpdateState.Ready' "Update cancelled. Ready."' 100));                              Update.IsUpdating = false;                              return;                          }                            var length = response.Content.Headers.ContentLength;                          double lengthInMb = !length.HasValue ? -1 : (double)length.Value / 1024 / 1024;                          double bytesDownloaded = 0;                            using(var stream = await response.Content.ReadAsStreamAsync())                          using(var msi = File.Open( msiPath' FileMode.Create' FileAccess.Write' FileShare.Read))                          {                              var buffer = new byte[65535 * 4];                                int bytesRead = await stream.ReadAsync(buffer' 0' buffer.Length' cancellationToken.Token);                              while (bytesRead != 0)                              {                                  await msi.WriteAsync(buffer' 0' bytesRead' cancellationToken.Token);                                  bytesDownloaded += bytesRead;                                    if (length.HasValue)                                  {                                      double downloadedMegs = bytesDownloaded / 1024 / 1024;                                      var percent = (int)Math.Floor((bytesDownloaded / length.Value) * 100);                                        var status = string.Format(CultureInfo.CurrentUICulture' "Downloaded {0:F2} MB of {1:F2} MB"' downloadedMegs' lengthInMb);                                        Update.IsUpdating = true;                                      Update.DownloadPercentage = percent;                                      progress.Report(new ProgressModel(UpdateState.Downloading' status' percent));                                  }                                    if (cancellationToken.IsCancellationRequested)                                  {                                      progress.Report(new ProgressModel(UpdateState.Ready' "Update cancelled. Ready."' 100));                                      Update.IsUpdating = false;                                      return;                                  }                                    bytesRead = await stream.ReadAsync(buffer' 0' buffer.Length' cancellationToken.Token);                              }                          }                      }                  }                    progress.Report(new ProgressModel(UpdateState.Ready' "Launching update..."' 100));                  Update.IsUpdating = false;                                    // Now run the installer                  var sb = new StringBuilder("msiexec.exe ");                    // Enable logging for the installer                  sb.AppendFormat(" /l*v \"{0}\""' Path.Combine(Path.GetTempPath()' "IPFilter.log"));                                    sb.AppendFormat(" /i \"{0}\""' msiPath);                    //sb.Append(" /passive");                    ProcessInformation processInformation = new ProcessInformation();                  StartupInfo startupInfo = new StartupInfo();                  SecurityAttributes processSecurity = new SecurityAttributes();                  SecurityAttributes threadSecurity = new SecurityAttributes();                  processSecurity.nLength = Marshal.SizeOf(processSecurity);                  threadSecurity.nLength = Marshal.SizeOf(threadSecurity);                    const int NormalPriorityClass = 0x0020;                    if (!ProcessManager.CreateProcess(null' sb' processSecurity'                      threadSecurity' false' NormalPriorityClass'                      IntPtr.Zero' null' startupInfo' processInformation))                  {                      throw Marshal.GetExceptionForHR(Marshal.GetHRForLastWin32Error());                  }                                    try                  {                      //dispatcher.Invoke(DispatcherPriority.Normal' new Action(Application.Current.Shutdown));                      Application.Current.Shutdown();                  }                  catch (Exception ex)                  {                      Trace.TraceError("Exception when shutting down app for update: " + ex);                      Update.ErrorMessage = "Couldn't shutdown the app to apply update.";                      telemetryClient?.TrackException(ex);                  }              }              catch (Exception ex)              {                  Trace.TraceWarning("Application update check failed: " + ex);                  telemetryClient?.TrackException(ex);                  telemetryClient?.Flush();              }              finally              {                  progress.Report(new ProgressModel(UpdateState.Ready' "Ready"' 0));              }
Magic Number,IPFilter.ViewModels,MainWindowViewModel,C:\repos\DavidMoore_ipfilter\Code\IPFilter\ViewModels\MainWindowViewModel.cs,CheckForUpdates,The following statement contains a magic number: try              {                  // Remove any old ClickOnce installs                  try                  {                      var uninstallInfo = UninstallInfo.Find("IPFilter Updater");                      if (uninstallInfo != null)                      {                          Trace.TraceWarning("Old ClickOnce app installed! Trying to remove...");                              var uninstaller = new Uninstaller();                              uninstaller.Uninstall(uninstallInfo);                              Trace.TraceInformation("Successfully removed ClickOnce app");                      }                  }                  catch (Exception ex)                  {                      Trace.TraceError("Failed to remove old ClickOnce app: " + ex);                      telemetryClient?.TrackException(ex);                  }                    Trace.TraceInformation("Checking for software updates...");                  progress.Report(new ProgressModel(UpdateState.Downloading' "Checking for software updates..."' -1));                    var updater = new Updater();                    var result = await updater.CheckForUpdateAsync();                    var currentVersion = new Version(Process.GetCurrentProcess().MainModule.FileVersionInfo.FileVersion);                    var latestVersion = new Version(result.Version);                                    Update.IsUpdateAvailable = latestVersion > currentVersion;                    if (Update.IsUpdateAvailable)                  {                      Update.AvailableVersion = latestVersion;                      Update.IsUpdateRequired = true;                      Update.MinimumRequiredVersion = latestVersion;                      Update.UpdateSizeBytes = 2000000;                  }                    Trace.TraceInformation("Current version: {0}"' Update.CurrentVersion);                  Trace.TraceInformation("Available version: {0}"' Update.AvailableVersion?.ToString() ?? "<no updates>");                    if (!Update.IsUpdateAvailable ) return;                                    if (MessageBoxHelper.Show(dispatcher' "Update Available"' MessageBoxButton.YesNo' MessageBoxImage.Question' MessageBoxResult.Yes'                      "An update to version {0} is available. Would you like to update now?"' Update.AvailableVersion) != MessageBoxResult.Yes)                  {                      return;                  }                                    Trace.TraceInformation("Starting application update...");                    // If we're not "installed"' then don't check for updates. This is so the                  // executable can be stand-alone. Stand-alone self-update to come later.                  using (var key = Registry.CurrentUser.OpenSubKey("SOFTWARE\\IPFilter"))                  {                      var installPath = (string) key?.GetValue("InstallPath");                      if (installPath == null)                      {                          using (var process = new Process())                          {                              process.StartInfo = new ProcessStartInfo("https://davidmoore.github.io/ipfilter/")                              {                                  UseShellExecute = true                              };                                process.Start();                              return;                          }                      }                  }                    var msiPath = Path.Combine(Path.GetTempPath()' "IPFilter.msi");                    // Download the installer                  using (var handler = new WebRequestHandler())                  {                      handler.AutomaticDecompression = DecompressionMethods.GZip | DecompressionMethods.Deflate;                        var uri = new Uri($"{result.Uri}?{DateTime.Now.ToString("yyyyMMddHHmmss")}");                        using (var httpClient = new HttpClient(handler))                      using (var response = await httpClient.GetAsync(uri' HttpCompletionOption.ResponseHeadersRead' cancellationToken.Token))                      {                          if (cancellationToken.IsCancellationRequested)                          {                              progress.Report(new ProgressModel(UpdateState.Ready' "Update cancelled. Ready."' 100));                              Update.IsUpdating = false;                              return;                          }                            var length = response.Content.Headers.ContentLength;                          double lengthInMb = !length.HasValue ? -1 : (double)length.Value / 1024 / 1024;                          double bytesDownloaded = 0;                            using(var stream = await response.Content.ReadAsStreamAsync())                          using(var msi = File.Open( msiPath' FileMode.Create' FileAccess.Write' FileShare.Read))                          {                              var buffer = new byte[65535 * 4];                                int bytesRead = await stream.ReadAsync(buffer' 0' buffer.Length' cancellationToken.Token);                              while (bytesRead != 0)                              {                                  await msi.WriteAsync(buffer' 0' bytesRead' cancellationToken.Token);                                  bytesDownloaded += bytesRead;                                    if (length.HasValue)                                  {                                      double downloadedMegs = bytesDownloaded / 1024 / 1024;                                      var percent = (int)Math.Floor((bytesDownloaded / length.Value) * 100);                                        var status = string.Format(CultureInfo.CurrentUICulture' "Downloaded {0:F2} MB of {1:F2} MB"' downloadedMegs' lengthInMb);                                        Update.IsUpdating = true;                                      Update.DownloadPercentage = percent;                                      progress.Report(new ProgressModel(UpdateState.Downloading' status' percent));                                  }                                    if (cancellationToken.IsCancellationRequested)                                  {                                      progress.Report(new ProgressModel(UpdateState.Ready' "Update cancelled. Ready."' 100));                                      Update.IsUpdating = false;                                      return;                                  }                                    bytesRead = await stream.ReadAsync(buffer' 0' buffer.Length' cancellationToken.Token);                              }                          }                      }                  }                    progress.Report(new ProgressModel(UpdateState.Ready' "Launching update..."' 100));                  Update.IsUpdating = false;                                    // Now run the installer                  var sb = new StringBuilder("msiexec.exe ");                    // Enable logging for the installer                  sb.AppendFormat(" /l*v \"{0}\""' Path.Combine(Path.GetTempPath()' "IPFilter.log"));                                    sb.AppendFormat(" /i \"{0}\""' msiPath);                    //sb.Append(" /passive");                    ProcessInformation processInformation = new ProcessInformation();                  StartupInfo startupInfo = new StartupInfo();                  SecurityAttributes processSecurity = new SecurityAttributes();                  SecurityAttributes threadSecurity = new SecurityAttributes();                  processSecurity.nLength = Marshal.SizeOf(processSecurity);                  threadSecurity.nLength = Marshal.SizeOf(threadSecurity);                    const int NormalPriorityClass = 0x0020;                    if (!ProcessManager.CreateProcess(null' sb' processSecurity'                      threadSecurity' false' NormalPriorityClass'                      IntPtr.Zero' null' startupInfo' processInformation))                  {                      throw Marshal.GetExceptionForHR(Marshal.GetHRForLastWin32Error());                  }                                    try                  {                      //dispatcher.Invoke(DispatcherPriority.Normal' new Action(Application.Current.Shutdown));                      Application.Current.Shutdown();                  }                  catch (Exception ex)                  {                      Trace.TraceError("Exception when shutting down app for update: " + ex);                      Update.ErrorMessage = "Couldn't shutdown the app to apply update.";                      telemetryClient?.TrackException(ex);                  }              }              catch (Exception ex)              {                  Trace.TraceWarning("Application update check failed: " + ex);                  telemetryClient?.TrackException(ex);                  telemetryClient?.Flush();              }              finally              {                  progress.Report(new ProgressModel(UpdateState.Ready' "Ready"' 0));              }
Magic Number,IPFilter.ViewModels,MainWindowViewModel,C:\repos\DavidMoore_ipfilter\Code\IPFilter\ViewModels\MainWindowViewModel.cs,CheckForUpdates,The following statement contains a magic number: try              {                  // Remove any old ClickOnce installs                  try                  {                      var uninstallInfo = UninstallInfo.Find("IPFilter Updater");                      if (uninstallInfo != null)                      {                          Trace.TraceWarning("Old ClickOnce app installed! Trying to remove...");                              var uninstaller = new Uninstaller();                              uninstaller.Uninstall(uninstallInfo);                              Trace.TraceInformation("Successfully removed ClickOnce app");                      }                  }                  catch (Exception ex)                  {                      Trace.TraceError("Failed to remove old ClickOnce app: " + ex);                      telemetryClient?.TrackException(ex);                  }                    Trace.TraceInformation("Checking for software updates...");                  progress.Report(new ProgressModel(UpdateState.Downloading' "Checking for software updates..."' -1));                    var updater = new Updater();                    var result = await updater.CheckForUpdateAsync();                    var currentVersion = new Version(Process.GetCurrentProcess().MainModule.FileVersionInfo.FileVersion);                    var latestVersion = new Version(result.Version);                                    Update.IsUpdateAvailable = latestVersion > currentVersion;                    if (Update.IsUpdateAvailable)                  {                      Update.AvailableVersion = latestVersion;                      Update.IsUpdateRequired = true;                      Update.MinimumRequiredVersion = latestVersion;                      Update.UpdateSizeBytes = 2000000;                  }                    Trace.TraceInformation("Current version: {0}"' Update.CurrentVersion);                  Trace.TraceInformation("Available version: {0}"' Update.AvailableVersion?.ToString() ?? "<no updates>");                    if (!Update.IsUpdateAvailable ) return;                                    if (MessageBoxHelper.Show(dispatcher' "Update Available"' MessageBoxButton.YesNo' MessageBoxImage.Question' MessageBoxResult.Yes'                      "An update to version {0} is available. Would you like to update now?"' Update.AvailableVersion) != MessageBoxResult.Yes)                  {                      return;                  }                                    Trace.TraceInformation("Starting application update...");                    // If we're not "installed"' then don't check for updates. This is so the                  // executable can be stand-alone. Stand-alone self-update to come later.                  using (var key = Registry.CurrentUser.OpenSubKey("SOFTWARE\\IPFilter"))                  {                      var installPath = (string) key?.GetValue("InstallPath");                      if (installPath == null)                      {                          using (var process = new Process())                          {                              process.StartInfo = new ProcessStartInfo("https://davidmoore.github.io/ipfilter/")                              {                                  UseShellExecute = true                              };                                process.Start();                              return;                          }                      }                  }                    var msiPath = Path.Combine(Path.GetTempPath()' "IPFilter.msi");                    // Download the installer                  using (var handler = new WebRequestHandler())                  {                      handler.AutomaticDecompression = DecompressionMethods.GZip | DecompressionMethods.Deflate;                        var uri = new Uri($"{result.Uri}?{DateTime.Now.ToString("yyyyMMddHHmmss")}");                        using (var httpClient = new HttpClient(handler))                      using (var response = await httpClient.GetAsync(uri' HttpCompletionOption.ResponseHeadersRead' cancellationToken.Token))                      {                          if (cancellationToken.IsCancellationRequested)                          {                              progress.Report(new ProgressModel(UpdateState.Ready' "Update cancelled. Ready."' 100));                              Update.IsUpdating = false;                              return;                          }                            var length = response.Content.Headers.ContentLength;                          double lengthInMb = !length.HasValue ? -1 : (double)length.Value / 1024 / 1024;                          double bytesDownloaded = 0;                            using(var stream = await response.Content.ReadAsStreamAsync())                          using(var msi = File.Open( msiPath' FileMode.Create' FileAccess.Write' FileShare.Read))                          {                              var buffer = new byte[65535 * 4];                                int bytesRead = await stream.ReadAsync(buffer' 0' buffer.Length' cancellationToken.Token);                              while (bytesRead != 0)                              {                                  await msi.WriteAsync(buffer' 0' bytesRead' cancellationToken.Token);                                  bytesDownloaded += bytesRead;                                    if (length.HasValue)                                  {                                      double downloadedMegs = bytesDownloaded / 1024 / 1024;                                      var percent = (int)Math.Floor((bytesDownloaded / length.Value) * 100);                                        var status = string.Format(CultureInfo.CurrentUICulture' "Downloaded {0:F2} MB of {1:F2} MB"' downloadedMegs' lengthInMb);                                        Update.IsUpdating = true;                                      Update.DownloadPercentage = percent;                                      progress.Report(new ProgressModel(UpdateState.Downloading' status' percent));                                  }                                    if (cancellationToken.IsCancellationRequested)                                  {                                      progress.Report(new ProgressModel(UpdateState.Ready' "Update cancelled. Ready."' 100));                                      Update.IsUpdating = false;                                      return;                                  }                                    bytesRead = await stream.ReadAsync(buffer' 0' buffer.Length' cancellationToken.Token);                              }                          }                      }                  }                    progress.Report(new ProgressModel(UpdateState.Ready' "Launching update..."' 100));                  Update.IsUpdating = false;                                    // Now run the installer                  var sb = new StringBuilder("msiexec.exe ");                    // Enable logging for the installer                  sb.AppendFormat(" /l*v \"{0}\""' Path.Combine(Path.GetTempPath()' "IPFilter.log"));                                    sb.AppendFormat(" /i \"{0}\""' msiPath);                    //sb.Append(" /passive");                    ProcessInformation processInformation = new ProcessInformation();                  StartupInfo startupInfo = new StartupInfo();                  SecurityAttributes processSecurity = new SecurityAttributes();                  SecurityAttributes threadSecurity = new SecurityAttributes();                  processSecurity.nLength = Marshal.SizeOf(processSecurity);                  threadSecurity.nLength = Marshal.SizeOf(threadSecurity);                    const int NormalPriorityClass = 0x0020;                    if (!ProcessManager.CreateProcess(null' sb' processSecurity'                      threadSecurity' false' NormalPriorityClass'                      IntPtr.Zero' null' startupInfo' processInformation))                  {                      throw Marshal.GetExceptionForHR(Marshal.GetHRForLastWin32Error());                  }                                    try                  {                      //dispatcher.Invoke(DispatcherPriority.Normal' new Action(Application.Current.Shutdown));                      Application.Current.Shutdown();                  }                  catch (Exception ex)                  {                      Trace.TraceError("Exception when shutting down app for update: " + ex);                      Update.ErrorMessage = "Couldn't shutdown the app to apply update.";                      telemetryClient?.TrackException(ex);                  }              }              catch (Exception ex)              {                  Trace.TraceWarning("Application update check failed: " + ex);                  telemetryClient?.TrackException(ex);                  telemetryClient?.Flush();              }              finally              {                  progress.Report(new ProgressModel(UpdateState.Ready' "Ready"' 0));              }
Magic Number,IPFilter.ViewModels,MainWindowViewModel,C:\repos\DavidMoore_ipfilter\Code\IPFilter\ViewModels\MainWindowViewModel.cs,CheckForUpdates,The following statement contains a magic number: try              {                  // Remove any old ClickOnce installs                  try                  {                      var uninstallInfo = UninstallInfo.Find("IPFilter Updater");                      if (uninstallInfo != null)                      {                          Trace.TraceWarning("Old ClickOnce app installed! Trying to remove...");                              var uninstaller = new Uninstaller();                              uninstaller.Uninstall(uninstallInfo);                              Trace.TraceInformation("Successfully removed ClickOnce app");                      }                  }                  catch (Exception ex)                  {                      Trace.TraceError("Failed to remove old ClickOnce app: " + ex);                      telemetryClient?.TrackException(ex);                  }                    Trace.TraceInformation("Checking for software updates...");                  progress.Report(new ProgressModel(UpdateState.Downloading' "Checking for software updates..."' -1));                    var updater = new Updater();                    var result = await updater.CheckForUpdateAsync();                    var currentVersion = new Version(Process.GetCurrentProcess().MainModule.FileVersionInfo.FileVersion);                    var latestVersion = new Version(result.Version);                                    Update.IsUpdateAvailable = latestVersion > currentVersion;                    if (Update.IsUpdateAvailable)                  {                      Update.AvailableVersion = latestVersion;                      Update.IsUpdateRequired = true;                      Update.MinimumRequiredVersion = latestVersion;                      Update.UpdateSizeBytes = 2000000;                  }                    Trace.TraceInformation("Current version: {0}"' Update.CurrentVersion);                  Trace.TraceInformation("Available version: {0}"' Update.AvailableVersion?.ToString() ?? "<no updates>");                    if (!Update.IsUpdateAvailable ) return;                                    if (MessageBoxHelper.Show(dispatcher' "Update Available"' MessageBoxButton.YesNo' MessageBoxImage.Question' MessageBoxResult.Yes'                      "An update to version {0} is available. Would you like to update now?"' Update.AvailableVersion) != MessageBoxResult.Yes)                  {                      return;                  }                                    Trace.TraceInformation("Starting application update...");                    // If we're not "installed"' then don't check for updates. This is so the                  // executable can be stand-alone. Stand-alone self-update to come later.                  using (var key = Registry.CurrentUser.OpenSubKey("SOFTWARE\\IPFilter"))                  {                      var installPath = (string) key?.GetValue("InstallPath");                      if (installPath == null)                      {                          using (var process = new Process())                          {                              process.StartInfo = new ProcessStartInfo("https://davidmoore.github.io/ipfilter/")                              {                                  UseShellExecute = true                              };                                process.Start();                              return;                          }                      }                  }                    var msiPath = Path.Combine(Path.GetTempPath()' "IPFilter.msi");                    // Download the installer                  using (var handler = new WebRequestHandler())                  {                      handler.AutomaticDecompression = DecompressionMethods.GZip | DecompressionMethods.Deflate;                        var uri = new Uri($"{result.Uri}?{DateTime.Now.ToString("yyyyMMddHHmmss")}");                        using (var httpClient = new HttpClient(handler))                      using (var response = await httpClient.GetAsync(uri' HttpCompletionOption.ResponseHeadersRead' cancellationToken.Token))                      {                          if (cancellationToken.IsCancellationRequested)                          {                              progress.Report(new ProgressModel(UpdateState.Ready' "Update cancelled. Ready."' 100));                              Update.IsUpdating = false;                              return;                          }                            var length = response.Content.Headers.ContentLength;                          double lengthInMb = !length.HasValue ? -1 : (double)length.Value / 1024 / 1024;                          double bytesDownloaded = 0;                            using(var stream = await response.Content.ReadAsStreamAsync())                          using(var msi = File.Open( msiPath' FileMode.Create' FileAccess.Write' FileShare.Read))                          {                              var buffer = new byte[65535 * 4];                                int bytesRead = await stream.ReadAsync(buffer' 0' buffer.Length' cancellationToken.Token);                              while (bytesRead != 0)                              {                                  await msi.WriteAsync(buffer' 0' bytesRead' cancellationToken.Token);                                  bytesDownloaded += bytesRead;                                    if (length.HasValue)                                  {                                      double downloadedMegs = bytesDownloaded / 1024 / 1024;                                      var percent = (int)Math.Floor((bytesDownloaded / length.Value) * 100);                                        var status = string.Format(CultureInfo.CurrentUICulture' "Downloaded {0:F2} MB of {1:F2} MB"' downloadedMegs' lengthInMb);                                        Update.IsUpdating = true;                                      Update.DownloadPercentage = percent;                                      progress.Report(new ProgressModel(UpdateState.Downloading' status' percent));                                  }                                    if (cancellationToken.IsCancellationRequested)                                  {                                      progress.Report(new ProgressModel(UpdateState.Ready' "Update cancelled. Ready."' 100));                                      Update.IsUpdating = false;                                      return;                                  }                                    bytesRead = await stream.ReadAsync(buffer' 0' buffer.Length' cancellationToken.Token);                              }                          }                      }                  }                    progress.Report(new ProgressModel(UpdateState.Ready' "Launching update..."' 100));                  Update.IsUpdating = false;                                    // Now run the installer                  var sb = new StringBuilder("msiexec.exe ");                    // Enable logging for the installer                  sb.AppendFormat(" /l*v \"{0}\""' Path.Combine(Path.GetTempPath()' "IPFilter.log"));                                    sb.AppendFormat(" /i \"{0}\""' msiPath);                    //sb.Append(" /passive");                    ProcessInformation processInformation = new ProcessInformation();                  StartupInfo startupInfo = new StartupInfo();                  SecurityAttributes processSecurity = new SecurityAttributes();                  SecurityAttributes threadSecurity = new SecurityAttributes();                  processSecurity.nLength = Marshal.SizeOf(processSecurity);                  threadSecurity.nLength = Marshal.SizeOf(threadSecurity);                    const int NormalPriorityClass = 0x0020;                    if (!ProcessManager.CreateProcess(null' sb' processSecurity'                      threadSecurity' false' NormalPriorityClass'                      IntPtr.Zero' null' startupInfo' processInformation))                  {                      throw Marshal.GetExceptionForHR(Marshal.GetHRForLastWin32Error());                  }                                    try                  {                      //dispatcher.Invoke(DispatcherPriority.Normal' new Action(Application.Current.Shutdown));                      Application.Current.Shutdown();                  }                  catch (Exception ex)                  {                      Trace.TraceError("Exception when shutting down app for update: " + ex);                      Update.ErrorMessage = "Couldn't shutdown the app to apply update.";                      telemetryClient?.TrackException(ex);                  }              }              catch (Exception ex)              {                  Trace.TraceWarning("Application update check failed: " + ex);                  telemetryClient?.TrackException(ex);                  telemetryClient?.Flush();              }              finally              {                  progress.Report(new ProgressModel(UpdateState.Ready' "Ready"' 0));              }
Magic Number,IPFilter.ViewModels,MainWindowViewModel,C:\repos\DavidMoore_ipfilter\Code\IPFilter\ViewModels\MainWindowViewModel.cs,CheckForUpdates,The following statement contains a magic number: try              {                  // Remove any old ClickOnce installs                  try                  {                      var uninstallInfo = UninstallInfo.Find("IPFilter Updater");                      if (uninstallInfo != null)                      {                          Trace.TraceWarning("Old ClickOnce app installed! Trying to remove...");                              var uninstaller = new Uninstaller();                              uninstaller.Uninstall(uninstallInfo);                              Trace.TraceInformation("Successfully removed ClickOnce app");                      }                  }                  catch (Exception ex)                  {                      Trace.TraceError("Failed to remove old ClickOnce app: " + ex);                      telemetryClient?.TrackException(ex);                  }                    Trace.TraceInformation("Checking for software updates...");                  progress.Report(new ProgressModel(UpdateState.Downloading' "Checking for software updates..."' -1));                    var updater = new Updater();                    var result = await updater.CheckForUpdateAsync();                    var currentVersion = new Version(Process.GetCurrentProcess().MainModule.FileVersionInfo.FileVersion);                    var latestVersion = new Version(result.Version);                                    Update.IsUpdateAvailable = latestVersion > currentVersion;                    if (Update.IsUpdateAvailable)                  {                      Update.AvailableVersion = latestVersion;                      Update.IsUpdateRequired = true;                      Update.MinimumRequiredVersion = latestVersion;                      Update.UpdateSizeBytes = 2000000;                  }                    Trace.TraceInformation("Current version: {0}"' Update.CurrentVersion);                  Trace.TraceInformation("Available version: {0}"' Update.AvailableVersion?.ToString() ?? "<no updates>");                    if (!Update.IsUpdateAvailable ) return;                                    if (MessageBoxHelper.Show(dispatcher' "Update Available"' MessageBoxButton.YesNo' MessageBoxImage.Question' MessageBoxResult.Yes'                      "An update to version {0} is available. Would you like to update now?"' Update.AvailableVersion) != MessageBoxResult.Yes)                  {                      return;                  }                                    Trace.TraceInformation("Starting application update...");                    // If we're not "installed"' then don't check for updates. This is so the                  // executable can be stand-alone. Stand-alone self-update to come later.                  using (var key = Registry.CurrentUser.OpenSubKey("SOFTWARE\\IPFilter"))                  {                      var installPath = (string) key?.GetValue("InstallPath");                      if (installPath == null)                      {                          using (var process = new Process())                          {                              process.StartInfo = new ProcessStartInfo("https://davidmoore.github.io/ipfilter/")                              {                                  UseShellExecute = true                              };                                process.Start();                              return;                          }                      }                  }                    var msiPath = Path.Combine(Path.GetTempPath()' "IPFilter.msi");                    // Download the installer                  using (var handler = new WebRequestHandler())                  {                      handler.AutomaticDecompression = DecompressionMethods.GZip | DecompressionMethods.Deflate;                        var uri = new Uri($"{result.Uri}?{DateTime.Now.ToString("yyyyMMddHHmmss")}");                        using (var httpClient = new HttpClient(handler))                      using (var response = await httpClient.GetAsync(uri' HttpCompletionOption.ResponseHeadersRead' cancellationToken.Token))                      {                          if (cancellationToken.IsCancellationRequested)                          {                              progress.Report(new ProgressModel(UpdateState.Ready' "Update cancelled. Ready."' 100));                              Update.IsUpdating = false;                              return;                          }                            var length = response.Content.Headers.ContentLength;                          double lengthInMb = !length.HasValue ? -1 : (double)length.Value / 1024 / 1024;                          double bytesDownloaded = 0;                            using(var stream = await response.Content.ReadAsStreamAsync())                          using(var msi = File.Open( msiPath' FileMode.Create' FileAccess.Write' FileShare.Read))                          {                              var buffer = new byte[65535 * 4];                                int bytesRead = await stream.ReadAsync(buffer' 0' buffer.Length' cancellationToken.Token);                              while (bytesRead != 0)                              {                                  await msi.WriteAsync(buffer' 0' bytesRead' cancellationToken.Token);                                  bytesDownloaded += bytesRead;                                    if (length.HasValue)                                  {                                      double downloadedMegs = bytesDownloaded / 1024 / 1024;                                      var percent = (int)Math.Floor((bytesDownloaded / length.Value) * 100);                                        var status = string.Format(CultureInfo.CurrentUICulture' "Downloaded {0:F2} MB of {1:F2} MB"' downloadedMegs' lengthInMb);                                        Update.IsUpdating = true;                                      Update.DownloadPercentage = percent;                                      progress.Report(new ProgressModel(UpdateState.Downloading' status' percent));                                  }                                    if (cancellationToken.IsCancellationRequested)                                  {                                      progress.Report(new ProgressModel(UpdateState.Ready' "Update cancelled. Ready."' 100));                                      Update.IsUpdating = false;                                      return;                                  }                                    bytesRead = await stream.ReadAsync(buffer' 0' buffer.Length' cancellationToken.Token);                              }                          }                      }                  }                    progress.Report(new ProgressModel(UpdateState.Ready' "Launching update..."' 100));                  Update.IsUpdating = false;                                    // Now run the installer                  var sb = new StringBuilder("msiexec.exe ");                    // Enable logging for the installer                  sb.AppendFormat(" /l*v \"{0}\""' Path.Combine(Path.GetTempPath()' "IPFilter.log"));                                    sb.AppendFormat(" /i \"{0}\""' msiPath);                    //sb.Append(" /passive");                    ProcessInformation processInformation = new ProcessInformation();                  StartupInfo startupInfo = new StartupInfo();                  SecurityAttributes processSecurity = new SecurityAttributes();                  SecurityAttributes threadSecurity = new SecurityAttributes();                  processSecurity.nLength = Marshal.SizeOf(processSecurity);                  threadSecurity.nLength = Marshal.SizeOf(threadSecurity);                    const int NormalPriorityClass = 0x0020;                    if (!ProcessManager.CreateProcess(null' sb' processSecurity'                      threadSecurity' false' NormalPriorityClass'                      IntPtr.Zero' null' startupInfo' processInformation))                  {                      throw Marshal.GetExceptionForHR(Marshal.GetHRForLastWin32Error());                  }                                    try                  {                      //dispatcher.Invoke(DispatcherPriority.Normal' new Action(Application.Current.Shutdown));                      Application.Current.Shutdown();                  }                  catch (Exception ex)                  {                      Trace.TraceError("Exception when shutting down app for update: " + ex);                      Update.ErrorMessage = "Couldn't shutdown the app to apply update.";                      telemetryClient?.TrackException(ex);                  }              }              catch (Exception ex)              {                  Trace.TraceWarning("Application update check failed: " + ex);                  telemetryClient?.TrackException(ex);                  telemetryClient?.Flush();              }              finally              {                  progress.Report(new ProgressModel(UpdateState.Ready' "Ready"' 0));              }
Magic Number,IPFilter.ViewModels,OptionsViewModel,C:\repos\DavidMoore_ipfilter\Code\IPFilter\ViewModels\OptionsViewModel.cs,SaveSettings,The following statement contains a magic number: try              {                  Trace.TraceInformation("Updating schedule settings...");                    const string taskPath = "IPFilter";                    // Get the service on the local machine                  using (var service = new TaskService())                  {                      if (!IsScheduleEnabled)                      {                          // If we're disabling the scheduling' then delete the task if it exists.                          Trace.TraceInformation("Schedule is disabled. Removing any existing scheduled task.");                          service.RootFolder.DeleteTask(taskPath' false);                          Trace.TraceInformation("Finished updating schedule settings.");                          return;                      }                        var identity = WindowsIdentity.GetCurrent();                        Trace.TraceInformation("Setting up the automatic schedule...");                      using (var task = service.NewTask())                      {                          task.RegistrationInfo.Description = "Updates the IP Filter for bit torrent clients";                            task.Triggers.Clear();                            // Schedule for midnight' then check every x hours (6 by default).                          var trigger = new TimeTrigger(new DateTime(DateTime.Now.Year' DateTime.Now.Month' DateTime.Now.Day' 0' 0' 0));                          trigger.Repetition.Interval = TimeSpan.FromHours(ScheduleHours ?? 6);                          task.Triggers.Add(trigger);                            task.Actions.Add(new ExecAction(Process.GetCurrentProcess().MainModule.FileName' "/silent"));                            task.Settings.RunOnlyIfNetworkAvailable = true;                          task.Settings.StartWhenAvailable = true;                          task.Settings.WakeToRun = false;                          task.Principal.RunLevel = TaskRunLevel.LUA;                          task.Principal.Id = identity.Name;                          task.Principal.LogonType = TaskLogonType.S4U;                            //task.Principal.UserId = identity.Name;                          service.RootFolder.RegisterTaskDefinition(taskPath' task' TaskCreation.CreateOrUpdate' identity.Name);                      }                        Trace.TraceInformation("Finished scheduling automatic update.");                  }              }              catch (UnauthorizedAccessException)              {                  Trace.TraceError("Can't schedule automated update' as IPFilter isn't being run as an administrator.");                  ErrorMessage = "You must be an administrator and run IPFilter elevated to schedule a task.";              }              catch (Exception ex)              {                  Trace.TraceError("Couldn't schedule automated update: " + ex);                  ErrorMessage = "Couldn't schedule automated update: " + ex.Message;              }
Magic Number,IPFilter.Services,DeploymentHelper,C:\repos\DavidMoore_ipfilter\Code\IPFilter\Services\DeploymentHelper.cs,Restart,The following statement contains a magic number: if (ApplicationDeployment.IsNetworkDeployed)              {                  var applicationFullName = ApplicationDeployment.CurrentDeployment.UpdatedApplicationFullName;                    // TODO: Auto-detect host type                  var hostType = HostType.CorFlag;                    Application.Current.Shutdown();                  CorLaunchApplication(hostType' applicationFullName' 0' null' 0' null' new ProcessInformation());              }              else              {                  var commandLineArgs = Environment.GetCommandLineArgs();                  var stringBuilder = new StringBuilder((commandLineArgs.Length - 1)*16);                  for (var index = 1; index < commandLineArgs.Length - 1; ++index)                  {                      stringBuilder.Append('"');                      stringBuilder.Append(commandLineArgs[index]);                      stringBuilder.Append("\" ");                  }                  if (commandLineArgs.Length > 1)                  {                      stringBuilder.Append('"');                      stringBuilder.Append(commandLineArgs[commandLineArgs.Length - 1]);                      stringBuilder.Append('"');                  }                  var startInfo = Process.GetCurrentProcess().StartInfo;                    if (stringBuilder.Length > 0) startInfo.Arguments = stringBuilder.ToString();                    Application.Current.Shutdown();                    Process.Start(startInfo);              }
Magic Number,IPFilter.Services,FilterDownloader,C:\repos\DavidMoore_ipfilter\Code\IPFilter\Services\FilterDownloader.cs,DownloadFilter,The following statement contains a magic number: try              {                                    if (uri == null)                  {                      var provider = Mirrors.First();                      var mirror = provider.GetMirrors().First();                      uri = new Uri(provider.GetUrlForMirror(mirror));                  }                    result.Uri = uri.ToString();                    using (var handler = new WebRequestHandler())                  {                      handler.AutomaticDecompression = DecompressionMethods.GZip | DecompressionMethods.Deflate;                        Trace.TraceInformation("Downloading filter from " + result.Uri);                        using (var httpClient = new HttpClient(handler))                      using (var response = await httpClient.GetAsync(uri' HttpCompletionOption.ResponseHeadersRead' cancellationToken))                      {                          if (cancellationToken.IsCancellationRequested) return null;                            result.FilterTimestamp = response.Content.Headers.LastModified ?? response.Headers.Date;                          result.Etag = response.Headers.ETag;                            Trace.TraceInformation("Online filter's timestamp is " + result.FilterTimestamp);                          Trace.TraceInformation("ETag: '{0}'"' result.Etag);                              // Check if the cached filter is already up to date.                          if (cache != null && !Settings.Default.DisableCache)                          {                              var cacheResult = await cache.GetAsync(result);                                if (cacheResult != null && cacheResult.Length > 0)                              {                                  Trace.TraceInformation("Found cached ipfilter with timestamp of " + cacheResult.FilterTimestamp);                                  if (cacheResult.FilterTimestamp >= result.FilterTimestamp)                                  {                                      Trace.TraceInformation("Using the cached ipfilter as it's the same or newer than the online filter.");                                      return cacheResult;                                  }                              }                          }                                                    result.Length = response.Content.Headers.ContentLength;                            double lengthInMb = !result.Length.HasValue ? -1 : (double) result.Length.Value / 1024 / 1024;                            double bytesDownloaded = 0;                            using (var stream = await response.Content.ReadAsStreamAsync())                          {                              var buffer = new byte[65535 * 4];                                result.Stream = new MemoryStream((int) (result.Length ?? buffer.Length));                                int bytesRead = await stream.ReadAsync(buffer' 0' buffer.Length' cancellationToken);                                result.CompressionFormat = DetectCompressionFormat(buffer' response.Content.Headers.ContentType);                                while (bytesRead != 0)                              {                                  await result.Stream.WriteAsync(buffer' 0' bytesRead' cancellationToken);                                  bytesDownloaded += bytesRead;                                    if (result.Length.HasValue)                                  {                                      double downloadedMegs = bytesDownloaded / 1024 / 1024;                                      var percent = (int)Math.Floor((bytesDownloaded / result.Length.Value) * 100);                                                                            var status = string.Format(CultureInfo.CurrentUICulture' "Downloaded {0:F2} MB of {1:F2} MB"' downloadedMegs' lengthInMb);                                        progress.Report(new ProgressModel(UpdateState.Downloading' status' percent));                                  }                                    if (cancellationToken.IsCancellationRequested) return null;                                    bytesRead = await stream.ReadAsync(buffer' 0' buffer.Length' cancellationToken);                              }                          }                      }                  }                    // Decompress if necessary                  if (result.CompressionFormat != CompressionFormat.None)                  {                      result.Stream = await Decompress(result' cancellationToken' progress);                  }              }              catch (Exception ex)              {                  result.Exception = ex;                  return result;              }
Magic Number,IPFilter.Services,FilterDownloader,C:\repos\DavidMoore_ipfilter\Code\IPFilter\Services\FilterDownloader.cs,DownloadFilter,The following statement contains a magic number: try              {                                    if (uri == null)                  {                      var provider = Mirrors.First();                      var mirror = provider.GetMirrors().First();                      uri = new Uri(provider.GetUrlForMirror(mirror));                  }                    result.Uri = uri.ToString();                    using (var handler = new WebRequestHandler())                  {                      handler.AutomaticDecompression = DecompressionMethods.GZip | DecompressionMethods.Deflate;                        Trace.TraceInformation("Downloading filter from " + result.Uri);                        using (var httpClient = new HttpClient(handler))                      using (var response = await httpClient.GetAsync(uri' HttpCompletionOption.ResponseHeadersRead' cancellationToken))                      {                          if (cancellationToken.IsCancellationRequested) return null;                            result.FilterTimestamp = response.Content.Headers.LastModified ?? response.Headers.Date;                          result.Etag = response.Headers.ETag;                            Trace.TraceInformation("Online filter's timestamp is " + result.FilterTimestamp);                          Trace.TraceInformation("ETag: '{0}'"' result.Etag);                              // Check if the cached filter is already up to date.                          if (cache != null && !Settings.Default.DisableCache)                          {                              var cacheResult = await cache.GetAsync(result);                                if (cacheResult != null && cacheResult.Length > 0)                              {                                  Trace.TraceInformation("Found cached ipfilter with timestamp of " + cacheResult.FilterTimestamp);                                  if (cacheResult.FilterTimestamp >= result.FilterTimestamp)                                  {                                      Trace.TraceInformation("Using the cached ipfilter as it's the same or newer than the online filter.");                                      return cacheResult;                                  }                              }                          }                                                    result.Length = response.Content.Headers.ContentLength;                            double lengthInMb = !result.Length.HasValue ? -1 : (double) result.Length.Value / 1024 / 1024;                            double bytesDownloaded = 0;                            using (var stream = await response.Content.ReadAsStreamAsync())                          {                              var buffer = new byte[65535 * 4];                                result.Stream = new MemoryStream((int) (result.Length ?? buffer.Length));                                int bytesRead = await stream.ReadAsync(buffer' 0' buffer.Length' cancellationToken);                                result.CompressionFormat = DetectCompressionFormat(buffer' response.Content.Headers.ContentType);                                while (bytesRead != 0)                              {                                  await result.Stream.WriteAsync(buffer' 0' bytesRead' cancellationToken);                                  bytesDownloaded += bytesRead;                                    if (result.Length.HasValue)                                  {                                      double downloadedMegs = bytesDownloaded / 1024 / 1024;                                      var percent = (int)Math.Floor((bytesDownloaded / result.Length.Value) * 100);                                                                            var status = string.Format(CultureInfo.CurrentUICulture' "Downloaded {0:F2} MB of {1:F2} MB"' downloadedMegs' lengthInMb);                                        progress.Report(new ProgressModel(UpdateState.Downloading' status' percent));                                  }                                    if (cancellationToken.IsCancellationRequested) return null;                                    bytesRead = await stream.ReadAsync(buffer' 0' buffer.Length' cancellationToken);                              }                          }                      }                  }                    // Decompress if necessary                  if (result.CompressionFormat != CompressionFormat.None)                  {                      result.Stream = await Decompress(result' cancellationToken' progress);                  }              }              catch (Exception ex)              {                  result.Exception = ex;                  return result;              }
Magic Number,IPFilter.Services,FilterDownloader,C:\repos\DavidMoore_ipfilter\Code\IPFilter\Services\FilterDownloader.cs,DownloadFilter,The following statement contains a magic number: try              {                                    if (uri == null)                  {                      var provider = Mirrors.First();                      var mirror = provider.GetMirrors().First();                      uri = new Uri(provider.GetUrlForMirror(mirror));                  }                    result.Uri = uri.ToString();                    using (var handler = new WebRequestHandler())                  {                      handler.AutomaticDecompression = DecompressionMethods.GZip | DecompressionMethods.Deflate;                        Trace.TraceInformation("Downloading filter from " + result.Uri);                        using (var httpClient = new HttpClient(handler))                      using (var response = await httpClient.GetAsync(uri' HttpCompletionOption.ResponseHeadersRead' cancellationToken))                      {                          if (cancellationToken.IsCancellationRequested) return null;                            result.FilterTimestamp = response.Content.Headers.LastModified ?? response.Headers.Date;                          result.Etag = response.Headers.ETag;                            Trace.TraceInformation("Online filter's timestamp is " + result.FilterTimestamp);                          Trace.TraceInformation("ETag: '{0}'"' result.Etag);                              // Check if the cached filter is already up to date.                          if (cache != null && !Settings.Default.DisableCache)                          {                              var cacheResult = await cache.GetAsync(result);                                if (cacheResult != null && cacheResult.Length > 0)                              {                                  Trace.TraceInformation("Found cached ipfilter with timestamp of " + cacheResult.FilterTimestamp);                                  if (cacheResult.FilterTimestamp >= result.FilterTimestamp)                                  {                                      Trace.TraceInformation("Using the cached ipfilter as it's the same or newer than the online filter.");                                      return cacheResult;                                  }                              }                          }                                                    result.Length = response.Content.Headers.ContentLength;                            double lengthInMb = !result.Length.HasValue ? -1 : (double) result.Length.Value / 1024 / 1024;                            double bytesDownloaded = 0;                            using (var stream = await response.Content.ReadAsStreamAsync())                          {                              var buffer = new byte[65535 * 4];                                result.Stream = new MemoryStream((int) (result.Length ?? buffer.Length));                                int bytesRead = await stream.ReadAsync(buffer' 0' buffer.Length' cancellationToken);                                result.CompressionFormat = DetectCompressionFormat(buffer' response.Content.Headers.ContentType);                                while (bytesRead != 0)                              {                                  await result.Stream.WriteAsync(buffer' 0' bytesRead' cancellationToken);                                  bytesDownloaded += bytesRead;                                    if (result.Length.HasValue)                                  {                                      double downloadedMegs = bytesDownloaded / 1024 / 1024;                                      var percent = (int)Math.Floor((bytesDownloaded / result.Length.Value) * 100);                                                                            var status = string.Format(CultureInfo.CurrentUICulture' "Downloaded {0:F2} MB of {1:F2} MB"' downloadedMegs' lengthInMb);                                        progress.Report(new ProgressModel(UpdateState.Downloading' status' percent));                                  }                                    if (cancellationToken.IsCancellationRequested) return null;                                    bytesRead = await stream.ReadAsync(buffer' 0' buffer.Length' cancellationToken);                              }                          }                      }                  }                    // Decompress if necessary                  if (result.CompressionFormat != CompressionFormat.None)                  {                      result.Stream = await Decompress(result' cancellationToken' progress);                  }              }              catch (Exception ex)              {                  result.Exception = ex;                  return result;              }
Magic Number,IPFilter.Services,FilterDownloader,C:\repos\DavidMoore_ipfilter\Code\IPFilter\Services\FilterDownloader.cs,DownloadFilter,The following statement contains a magic number: try              {                                    if (uri == null)                  {                      var provider = Mirrors.First();                      var mirror = provider.GetMirrors().First();                      uri = new Uri(provider.GetUrlForMirror(mirror));                  }                    result.Uri = uri.ToString();                    using (var handler = new WebRequestHandler())                  {                      handler.AutomaticDecompression = DecompressionMethods.GZip | DecompressionMethods.Deflate;                        Trace.TraceInformation("Downloading filter from " + result.Uri);                        using (var httpClient = new HttpClient(handler))                      using (var response = await httpClient.GetAsync(uri' HttpCompletionOption.ResponseHeadersRead' cancellationToken))                      {                          if (cancellationToken.IsCancellationRequested) return null;                            result.FilterTimestamp = response.Content.Headers.LastModified ?? response.Headers.Date;                          result.Etag = response.Headers.ETag;                            Trace.TraceInformation("Online filter's timestamp is " + result.FilterTimestamp);                          Trace.TraceInformation("ETag: '{0}'"' result.Etag);                              // Check if the cached filter is already up to date.                          if (cache != null && !Settings.Default.DisableCache)                          {                              var cacheResult = await cache.GetAsync(result);                                if (cacheResult != null && cacheResult.Length > 0)                              {                                  Trace.TraceInformation("Found cached ipfilter with timestamp of " + cacheResult.FilterTimestamp);                                  if (cacheResult.FilterTimestamp >= result.FilterTimestamp)                                  {                                      Trace.TraceInformation("Using the cached ipfilter as it's the same or newer than the online filter.");                                      return cacheResult;                                  }                              }                          }                                                    result.Length = response.Content.Headers.ContentLength;                            double lengthInMb = !result.Length.HasValue ? -1 : (double) result.Length.Value / 1024 / 1024;                            double bytesDownloaded = 0;                            using (var stream = await response.Content.ReadAsStreamAsync())                          {                              var buffer = new byte[65535 * 4];                                result.Stream = new MemoryStream((int) (result.Length ?? buffer.Length));                                int bytesRead = await stream.ReadAsync(buffer' 0' buffer.Length' cancellationToken);                                result.CompressionFormat = DetectCompressionFormat(buffer' response.Content.Headers.ContentType);                                while (bytesRead != 0)                              {                                  await result.Stream.WriteAsync(buffer' 0' bytesRead' cancellationToken);                                  bytesDownloaded += bytesRead;                                    if (result.Length.HasValue)                                  {                                      double downloadedMegs = bytesDownloaded / 1024 / 1024;                                      var percent = (int)Math.Floor((bytesDownloaded / result.Length.Value) * 100);                                                                            var status = string.Format(CultureInfo.CurrentUICulture' "Downloaded {0:F2} MB of {1:F2} MB"' downloadedMegs' lengthInMb);                                        progress.Report(new ProgressModel(UpdateState.Downloading' status' percent));                                  }                                    if (cancellationToken.IsCancellationRequested) return null;                                    bytesRead = await stream.ReadAsync(buffer' 0' buffer.Length' cancellationToken);                              }                          }                      }                  }                    // Decompress if necessary                  if (result.CompressionFormat != CompressionFormat.None)                  {                      result.Stream = await Decompress(result' cancellationToken' progress);                  }              }              catch (Exception ex)              {                  result.Exception = ex;                  return result;              }
Magic Number,IPFilter.Services,FilterDownloader,C:\repos\DavidMoore_ipfilter\Code\IPFilter\Services\FilterDownloader.cs,DownloadFilter,The following statement contains a magic number: try              {                                    if (uri == null)                  {                      var provider = Mirrors.First();                      var mirror = provider.GetMirrors().First();                      uri = new Uri(provider.GetUrlForMirror(mirror));                  }                    result.Uri = uri.ToString();                    using (var handler = new WebRequestHandler())                  {                      handler.AutomaticDecompression = DecompressionMethods.GZip | DecompressionMethods.Deflate;                        Trace.TraceInformation("Downloading filter from " + result.Uri);                        using (var httpClient = new HttpClient(handler))                      using (var response = await httpClient.GetAsync(uri' HttpCompletionOption.ResponseHeadersRead' cancellationToken))                      {                          if (cancellationToken.IsCancellationRequested) return null;                            result.FilterTimestamp = response.Content.Headers.LastModified ?? response.Headers.Date;                          result.Etag = response.Headers.ETag;                            Trace.TraceInformation("Online filter's timestamp is " + result.FilterTimestamp);                          Trace.TraceInformation("ETag: '{0}'"' result.Etag);                              // Check if the cached filter is already up to date.                          if (cache != null && !Settings.Default.DisableCache)                          {                              var cacheResult = await cache.GetAsync(result);                                if (cacheResult != null && cacheResult.Length > 0)                              {                                  Trace.TraceInformation("Found cached ipfilter with timestamp of " + cacheResult.FilterTimestamp);                                  if (cacheResult.FilterTimestamp >= result.FilterTimestamp)                                  {                                      Trace.TraceInformation("Using the cached ipfilter as it's the same or newer than the online filter.");                                      return cacheResult;                                  }                              }                          }                                                    result.Length = response.Content.Headers.ContentLength;                            double lengthInMb = !result.Length.HasValue ? -1 : (double) result.Length.Value / 1024 / 1024;                            double bytesDownloaded = 0;                            using (var stream = await response.Content.ReadAsStreamAsync())                          {                              var buffer = new byte[65535 * 4];                                result.Stream = new MemoryStream((int) (result.Length ?? buffer.Length));                                int bytesRead = await stream.ReadAsync(buffer' 0' buffer.Length' cancellationToken);                                result.CompressionFormat = DetectCompressionFormat(buffer' response.Content.Headers.ContentType);                                while (bytesRead != 0)                              {                                  await result.Stream.WriteAsync(buffer' 0' bytesRead' cancellationToken);                                  bytesDownloaded += bytesRead;                                    if (result.Length.HasValue)                                  {                                      double downloadedMegs = bytesDownloaded / 1024 / 1024;                                      var percent = (int)Math.Floor((bytesDownloaded / result.Length.Value) * 100);                                                                            var status = string.Format(CultureInfo.CurrentUICulture' "Downloaded {0:F2} MB of {1:F2} MB"' downloadedMegs' lengthInMb);                                        progress.Report(new ProgressModel(UpdateState.Downloading' status' percent));                                  }                                    if (cancellationToken.IsCancellationRequested) return null;                                    bytesRead = await stream.ReadAsync(buffer' 0' buffer.Length' cancellationToken);                              }                          }                      }                  }                    // Decompress if necessary                  if (result.CompressionFormat != CompressionFormat.None)                  {                      result.Stream = await Decompress(result' cancellationToken' progress);                  }              }              catch (Exception ex)              {                  result.Exception = ex;                  return result;              }
Magic Number,IPFilter.Services,FilterDownloader,C:\repos\DavidMoore_ipfilter\Code\IPFilter\Services\FilterDownloader.cs,DownloadFilter,The following statement contains a magic number: try              {                                    if (uri == null)                  {                      var provider = Mirrors.First();                      var mirror = provider.GetMirrors().First();                      uri = new Uri(provider.GetUrlForMirror(mirror));                  }                    result.Uri = uri.ToString();                    using (var handler = new WebRequestHandler())                  {                      handler.AutomaticDecompression = DecompressionMethods.GZip | DecompressionMethods.Deflate;                        Trace.TraceInformation("Downloading filter from " + result.Uri);                        using (var httpClient = new HttpClient(handler))                      using (var response = await httpClient.GetAsync(uri' HttpCompletionOption.ResponseHeadersRead' cancellationToken))                      {                          if (cancellationToken.IsCancellationRequested) return null;                            result.FilterTimestamp = response.Content.Headers.LastModified ?? response.Headers.Date;                          result.Etag = response.Headers.ETag;                            Trace.TraceInformation("Online filter's timestamp is " + result.FilterTimestamp);                          Trace.TraceInformation("ETag: '{0}'"' result.Etag);                              // Check if the cached filter is already up to date.                          if (cache != null && !Settings.Default.DisableCache)                          {                              var cacheResult = await cache.GetAsync(result);                                if (cacheResult != null && cacheResult.Length > 0)                              {                                  Trace.TraceInformation("Found cached ipfilter with timestamp of " + cacheResult.FilterTimestamp);                                  if (cacheResult.FilterTimestamp >= result.FilterTimestamp)                                  {                                      Trace.TraceInformation("Using the cached ipfilter as it's the same or newer than the online filter.");                                      return cacheResult;                                  }                              }                          }                                                    result.Length = response.Content.Headers.ContentLength;                            double lengthInMb = !result.Length.HasValue ? -1 : (double) result.Length.Value / 1024 / 1024;                            double bytesDownloaded = 0;                            using (var stream = await response.Content.ReadAsStreamAsync())                          {                              var buffer = new byte[65535 * 4];                                result.Stream = new MemoryStream((int) (result.Length ?? buffer.Length));                                int bytesRead = await stream.ReadAsync(buffer' 0' buffer.Length' cancellationToken);                                result.CompressionFormat = DetectCompressionFormat(buffer' response.Content.Headers.ContentType);                                while (bytesRead != 0)                              {                                  await result.Stream.WriteAsync(buffer' 0' bytesRead' cancellationToken);                                  bytesDownloaded += bytesRead;                                    if (result.Length.HasValue)                                  {                                      double downloadedMegs = bytesDownloaded / 1024 / 1024;                                      var percent = (int)Math.Floor((bytesDownloaded / result.Length.Value) * 100);                                                                            var status = string.Format(CultureInfo.CurrentUICulture' "Downloaded {0:F2} MB of {1:F2} MB"' downloadedMegs' lengthInMb);                                        progress.Report(new ProgressModel(UpdateState.Downloading' status' percent));                                  }                                    if (cancellationToken.IsCancellationRequested) return null;                                    bytesRead = await stream.ReadAsync(buffer' 0' buffer.Length' cancellationToken);                              }                          }                      }                  }                    // Decompress if necessary                  if (result.CompressionFormat != CompressionFormat.None)                  {                      result.Stream = await Decompress(result' cancellationToken' progress);                  }              }              catch (Exception ex)              {                  result.Exception = ex;                  return result;              }
Magic Number,IPFilter.Services,FilterDownloader,C:\repos\DavidMoore_ipfilter\Code\IPFilter\Services\FilterDownloader.cs,DownloadFilter,The following statement contains a magic number: try              {                                    if (uri == null)                  {                      var provider = Mirrors.First();                      var mirror = provider.GetMirrors().First();                      uri = new Uri(provider.GetUrlForMirror(mirror));                  }                    result.Uri = uri.ToString();                    using (var handler = new WebRequestHandler())                  {                      handler.AutomaticDecompression = DecompressionMethods.GZip | DecompressionMethods.Deflate;                        Trace.TraceInformation("Downloading filter from " + result.Uri);                        using (var httpClient = new HttpClient(handler))                      using (var response = await httpClient.GetAsync(uri' HttpCompletionOption.ResponseHeadersRead' cancellationToken))                      {                          if (cancellationToken.IsCancellationRequested) return null;                            result.FilterTimestamp = response.Content.Headers.LastModified ?? response.Headers.Date;                          result.Etag = response.Headers.ETag;                            Trace.TraceInformation("Online filter's timestamp is " + result.FilterTimestamp);                          Trace.TraceInformation("ETag: '{0}'"' result.Etag);                              // Check if the cached filter is already up to date.                          if (cache != null && !Settings.Default.DisableCache)                          {                              var cacheResult = await cache.GetAsync(result);                                if (cacheResult != null && cacheResult.Length > 0)                              {                                  Trace.TraceInformation("Found cached ipfilter with timestamp of " + cacheResult.FilterTimestamp);                                  if (cacheResult.FilterTimestamp >= result.FilterTimestamp)                                  {                                      Trace.TraceInformation("Using the cached ipfilter as it's the same or newer than the online filter.");                                      return cacheResult;                                  }                              }                          }                                                    result.Length = response.Content.Headers.ContentLength;                            double lengthInMb = !result.Length.HasValue ? -1 : (double) result.Length.Value / 1024 / 1024;                            double bytesDownloaded = 0;                            using (var stream = await response.Content.ReadAsStreamAsync())                          {                              var buffer = new byte[65535 * 4];                                result.Stream = new MemoryStream((int) (result.Length ?? buffer.Length));                                int bytesRead = await stream.ReadAsync(buffer' 0' buffer.Length' cancellationToken);                                result.CompressionFormat = DetectCompressionFormat(buffer' response.Content.Headers.ContentType);                                while (bytesRead != 0)                              {                                  await result.Stream.WriteAsync(buffer' 0' bytesRead' cancellationToken);                                  bytesDownloaded += bytesRead;                                    if (result.Length.HasValue)                                  {                                      double downloadedMegs = bytesDownloaded / 1024 / 1024;                                      var percent = (int)Math.Floor((bytesDownloaded / result.Length.Value) * 100);                                                                            var status = string.Format(CultureInfo.CurrentUICulture' "Downloaded {0:F2} MB of {1:F2} MB"' downloadedMegs' lengthInMb);                                        progress.Report(new ProgressModel(UpdateState.Downloading' status' percent));                                  }                                    if (cancellationToken.IsCancellationRequested) return null;                                    bytesRead = await stream.ReadAsync(buffer' 0' buffer.Length' cancellationToken);                              }                          }                      }                  }                    // Decompress if necessary                  if (result.CompressionFormat != CompressionFormat.None)                  {                      result.Stream = await Decompress(result' cancellationToken' progress);                  }              }              catch (Exception ex)              {                  result.Exception = ex;                  return result;              }
Magic Number,IPFilter.Services,FilterDownloader,C:\repos\DavidMoore_ipfilter\Code\IPFilter\Services\FilterDownloader.cs,Decompress,The following statement contains a magic number: using (var stream = filter.Stream)              {                  var result = new MemoryStream();                    stream.Seek(0' SeekOrigin.Begin);                    cancellationToken.ThrowIfCancellationRequested();                    switch (filter.CompressionFormat)                  {                      case CompressionFormat.GZip:                          using(var gzipFile = new GZipStream(stream' CompressionMode.Decompress))                          {                              var buffer = new byte[1024 * 64];                              int bytesRead;                              while ((bytesRead = await gzipFile.ReadAsync(buffer' 0' buffer.Length' cancellationToken)) > 0)                              {                                  cancellationToken.ThrowIfCancellationRequested();                                  result.Write(buffer' 0' bytesRead);                                  progress.Report(new ProgressModel(UpdateState.Decompressing' "Decompressing..."' -1));                              }                          }                          break;                        case CompressionFormat.Zip:                            using (var zipFile = new ZipArchive(stream'ZipArchiveMode.Read))                          {                              progress.Report(new ProgressModel(UpdateState.Decompressing' "Decompressing..."' -1));                                                            if (zipFile.Entries.Count == 0) throw new IOException("There are no entries in the zip file.");                              if (zipFile.Entries.Count > 1) throw new IOException("There is more than one file in the zip file. This application will need to be updated to support this.");                                var entry = zipFile.Entries.First();                                using (var entryStream = entry.Open())                              {                                  cancellationToken.ThrowIfCancellationRequested();                                  await entryStream.CopyToAsync(result);                              }                          }                          break;                        default:                          await stream.CopyToAsync(result);                          break;                  }                    return result;              }
Magic Number,IPFilter.Services,FilterDownloader,C:\repos\DavidMoore_ipfilter\Code\IPFilter\Services\FilterDownloader.cs,Decompress,The following statement contains a magic number: using (var stream = filter.Stream)              {                  var result = new MemoryStream();                    stream.Seek(0' SeekOrigin.Begin);                    cancellationToken.ThrowIfCancellationRequested();                    switch (filter.CompressionFormat)                  {                      case CompressionFormat.GZip:                          using(var gzipFile = new GZipStream(stream' CompressionMode.Decompress))                          {                              var buffer = new byte[1024 * 64];                              int bytesRead;                              while ((bytesRead = await gzipFile.ReadAsync(buffer' 0' buffer.Length' cancellationToken)) > 0)                              {                                  cancellationToken.ThrowIfCancellationRequested();                                  result.Write(buffer' 0' bytesRead);                                  progress.Report(new ProgressModel(UpdateState.Decompressing' "Decompressing..."' -1));                              }                          }                          break;                        case CompressionFormat.Zip:                            using (var zipFile = new ZipArchive(stream'ZipArchiveMode.Read))                          {                              progress.Report(new ProgressModel(UpdateState.Decompressing' "Decompressing..."' -1));                                                            if (zipFile.Entries.Count == 0) throw new IOException("There are no entries in the zip file.");                              if (zipFile.Entries.Count > 1) throw new IOException("There is more than one file in the zip file. This application will need to be updated to support this.");                                var entry = zipFile.Entries.First();                                using (var entryStream = entry.Open())                              {                                  cancellationToken.ThrowIfCancellationRequested();                                  await entryStream.CopyToAsync(result);                              }                          }                          break;                        default:                          await stream.CopyToAsync(result);                          break;                  }                    return result;              }
Magic Number,IPFilter.Services,FilterDownloader,C:\repos\DavidMoore_ipfilter\Code\IPFilter\Services\FilterDownloader.cs,DetectCompressionFormat,The following statement contains a magic number: switch (contentType.MediaType)              {                  case "application/gzip":                  case "application/x-gzip":                  case "application/x-gunzip":                  case "application/gzipped":                  case "application/gzip-compressed":                  case "gzip/document":                      return CompressionFormat.GZip;                    case "application/zip":                  case "application/x-zip":                  case "application/x-zip-compressed":                  case "multipart/x-zip":                      return CompressionFormat.Zip;    //                case "application/x-compressed":  //                case "application/octet-stream":  //                case "text/plain":                  default:                      {                          // Look for the GZip header bytes                          if (buffer[0] == 31 && buffer[1] == 139)                          {                              return CompressionFormat.GZip;                          }                            // Look for the ZIP header bytes.                          var zipHeaderNumber = BitConverter.ToInt32(buffer' 0);                          if (zipHeaderNumber == 0x4034b50)                          {                              return CompressionFormat.Zip;                          }                      }                      break;              }
Magic Number,IPFilter.Services,FilterDownloader,C:\repos\DavidMoore_ipfilter\Code\IPFilter\Services\FilterDownloader.cs,DetectCompressionFormat,The following statement contains a magic number: switch (contentType.MediaType)              {                  case "application/gzip":                  case "application/x-gzip":                  case "application/x-gunzip":                  case "application/gzipped":                  case "application/gzip-compressed":                  case "gzip/document":                      return CompressionFormat.GZip;                    case "application/zip":                  case "application/x-zip":                  case "application/x-zip-compressed":                  case "multipart/x-zip":                      return CompressionFormat.Zip;    //                case "application/x-compressed":  //                case "application/octet-stream":  //                case "text/plain":                  default:                      {                          // Look for the GZip header bytes                          if (buffer[0] == 31 && buffer[1] == 139)                          {                              return CompressionFormat.GZip;                          }                            // Look for the ZIP header bytes.                          var zipHeaderNumber = BitConverter.ToInt32(buffer' 0);                          if (zipHeaderNumber == 0x4034b50)                          {                              return CompressionFormat.Zip;                          }                      }                      break;              }
Magic Number,IPFilter.ListProviders,SourceForgeMirrorParser,C:\repos\DavidMoore_ipfilter\Code\IPFilter\ListProviders\SourceForgeMirrorParser.cs,ParseMirrors,The following statement contains a magic number: return from Match match in regex.Matches(mirrorsHtml)                     let name = match.Groups[2].Value.Trim() + " " + match.Groups[3].Value.Trim()                     select new FileMirror(match.Groups[1].Value' name);
Magic Number,IPFilter.ListProviders,SourceForgeMirrorParser,C:\repos\DavidMoore_ipfilter\Code\IPFilter\ListProviders\SourceForgeMirrorParser.cs,ParseMirrors,The following statement contains a magic number: return from Match match in regex.Matches(mirrorsHtml)                     let name = match.Groups[2].Value.Trim() + " " + match.Groups[3].Value.Trim()                     select new FileMirror(match.Groups[1].Value' name);
Magic Number,IPFilter.Views,MainWindow,C:\repos\DavidMoore_ipfilter\Code\IPFilter\Views\MainWindow.xaml.cs,MainWindow,The following statement contains a magic number: ViewModel.ShowNotification = (title' message' icon) => notifyIcon.ShowBalloonTip(3000' title' message' icon);
Missing Default,IPFilter.ViewModels,MainWindowViewModel,C:\repos\DavidMoore_ipfilter\Code\IPFilter\ViewModels\MainWindowViewModel.cs,Start,The following switch statement is missing a default case: switch (State)              {                  case UpdateState.Done:                  case UpdateState.Ready:                  case UpdateState.Cancelled:                      cancellationToken.Dispose();                      cancellationToken = new CancellationTokenSource();                      Task.Factory.StartNew(StartAsync' CancellationToken.None' TaskCreationOptions.None' TaskScheduler.FromCurrentSynchronizationContext());                      break;                                        case UpdateState.Downloading:                  case UpdateState.Decompressing:                      cancellationToken.Cancel();                      break;              }
