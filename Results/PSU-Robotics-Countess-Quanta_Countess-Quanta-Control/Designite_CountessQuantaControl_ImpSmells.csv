Implementation smell,Namespace,Class,File,Method,Description
Long Method,CountessQuantaControl,KinectManager,C:\repos\PSU-Robotics-Countess-Quanta_Countess-Quanta-Control\Src\CountessQuantaControl\KinectManager.cs,SpeechRecognized,The method has 103 lines of code.
Complex Method,CountessQuantaControl,AriaManager,C:\repos\PSU-Robotics-Countess-Quanta_Countess-Quanta-Control\Src\CountessQuantaControl\AriaManager.cs,InitializeAriaHardware,Cyclomatic complexity of the method is 9
Complex Method,CountessQuantaControl,SequenceProcessor,C:\repos\PSU-Robotics-Countess-Quanta_Countess-Quanta-Control\Src\CountessQuantaControl\SequenceProcessor.cs,RunSequenceThread,Cyclomatic complexity of the method is 18
Complex Method,CountessQuantaControl,ServoManager,C:\repos\PSU-Robotics-Countess-Quanta_Countess-Quanta-Control\Src\CountessQuantaControl\ServoManager.cs,UpdateServoValues,Cyclomatic complexity of the method is 9
Complex Method,CountessQuantaControl,ServoManager,C:\repos\PSU-Robotics-Countess-Quanta_Countess-Quanta-Control\Src\CountessQuantaControl\ServoManager.cs,WaitForMoveComplete,Cyclomatic complexity of the method is 9
Complex Method,CountessQuantaControl,SkeletonViewer,C:\repos\PSU-Robotics-Countess-Quanta_Countess-Quanta-Control\Src\CountessQuantaControl\SkeletonViewer.xaml.cs,SensorSkeletonFrameReady,Cyclomatic complexity of the method is 10
Complex Method,CountessQuantaControl,KinectManager,C:\repos\PSU-Robotics-Countess-Quanta_Countess-Quanta-Control\Src\CountessQuantaControl\KinectManager.cs,InitializeKinect,Cyclomatic complexity of the method is 8
Complex Method,CountessQuantaControl,KinectManager,C:\repos\PSU-Robotics-Countess-Quanta_Countess-Quanta-Control\Src\CountessQuantaControl\KinectManager.cs,SpeechRecognized,Cyclomatic complexity of the method is 73
Complex Method,CountessQuantaControl,KinectManager,C:\repos\PSU-Robotics-Countess-Quanta_Countess-Quanta-Control\Src\CountessQuantaControl\KinectManager.cs,SensorSkeletonFrameReady,Cyclomatic complexity of the method is 14
Long Parameter List,CountessQuantaControl,SequenceProcessor,C:\repos\PSU-Robotics-Countess-Quanta_Countess-Quanta-Control\Src\CountessQuantaControl\SequenceProcessor.cs,SequenceProcessor,The method has 5 parameters.
Long Parameter List,CountessQuantaControl,ServoManager,C:\repos\PSU-Robotics-Countess-Quanta_Countess-Quanta-Control\Src\CountessQuantaControl\ServoManager.cs,MoveServos,The method has 5 parameters.
Long Identifier,CountessQuantaControl,PersonTracking,C:\repos\PSU-Robotics-Countess-Quanta_Countess-Quanta-Control\Src\CountessQuantaControl\PersonTracking.cs,UpdatePosition,The length of the parameter servoCenterPostion_HeadHorizontal is 33.
Long Identifier,CountessQuantaControl,PersonTracking,C:\repos\PSU-Robotics-Countess-Quanta_Countess-Quanta-Control\Src\CountessQuantaControl\PersonTracking.cs,UpdatePosition,The length of the parameter servoCenterPostion_HeadVertical is 31.
Long Identifier,CountessQuantaControl,PersonTracking,C:\repos\PSU-Robotics-Countess-Quanta_Countess-Quanta-Control\Src\CountessQuantaControl\PersonTracking.cs,UpdatePosition,The length of the parameter servoIncrementsPerRadian_HeadHorizontal is 39.
Long Identifier,CountessQuantaControl,PersonTracking,C:\repos\PSU-Robotics-Countess-Quanta_Countess-Quanta-Control\Src\CountessQuantaControl\PersonTracking.cs,UpdatePosition,The length of the parameter servoIncrementsPerRadian_HeadVertical is 37.
Long Identifier,CountessQuantaControl,PersonTracking,C:\repos\PSU-Robotics-Countess-Quanta_Countess-Quanta-Control\Src\CountessQuantaControl\PersonTracking.cs,UpdatePosition,The length of the parameter newServoPosition_HeadHorizontal is 31.
Long Statement,CountessQuantaControl,AriaManager,C:\repos\PSU-Robotics-Countess-Quanta_Countess-Quanta-Control\Src\CountessQuantaControl\AriaManager.cs,InitializeAriaHardware,The length of the statement  "		ErrorLogging.AddMessage (ErrorLogging.LoggingLevel.Info' "InitializeAria() succeeded' connected to robot base control."); " is 121.
Long Statement,CountessQuantaControl,AriaManager,C:\repos\PSU-Robotics-Countess-Quanta_Countess-Quanta-Control\Src\CountessQuantaControl\AriaManager.cs,SetVelocity,The length of the statement  "	ErrorLogging.AddMessage (ErrorLogging.LoggingLevel.Debug' "Setting wheel translation velocity to " + velocity.ToString ()); " is 123.
Long Statement,CountessQuantaControl,AriaManager,C:\repos\PSU-Robotics-Countess-Quanta_Countess-Quanta-Control\Src\CountessQuantaControl\AriaManager.cs,SetRotationVelocity,The length of the statement  "	ErrorLogging.AddMessage (ErrorLogging.LoggingLevel.Debug' "Setting wheel rotation velocity to " + velocity.ToString ()); " is 120.
Long Statement,CountessQuantaControl,AriaManager,C:\repos\PSU-Robotics-Countess-Quanta_Countess-Quanta-Control\Src\CountessQuantaControl\AriaManager.cs,SetWheelVelocity,The length of the statement  "	ErrorLogging.AddMessage (ErrorLogging.LoggingLevel.Debug' "Setting left wheel velocity to " + leftWheelVelocity.ToString () + " and right wheel velocity to " + rightWheelVelocity.ToString ()); " is 192.
Long Statement,CountessQuantaControl,PersonTracking,C:\repos\PSU-Robotics-Countess-Quanta_Countess-Quanta-Control\Src\CountessQuantaControl\PersonTracking.cs,UpdatePosition,The length of the statement  "	//double currentAngle_HeadHorizontal = (servoCenterPostion_HeadHorizontal - currentPosition_HeadHorizontal) / servoIncrementsPerRadian_HeadHorizontal; " is 150.
Long Statement,CountessQuantaControl,PersonTracking,C:\repos\PSU-Robotics-Countess-Quanta_Countess-Quanta-Control\Src\CountessQuantaControl\PersonTracking.cs,UpdatePosition,The length of the statement  "	double newServoPosition_HeadHorizontal = servoCenterPostion_HeadHorizontal - targetAngle_Horizontal * servoIncrementsPerRadian_HeadHorizontal; " is 142.
Long Statement,CountessQuantaControl,PersonTracking,C:\repos\PSU-Robotics-Countess-Quanta_Countess-Quanta-Control\Src\CountessQuantaControl\PersonTracking.cs,UpdatePosition,The length of the statement  "	double newServoPosition_HeadVertical = servoCenterPostion_HeadVertical + servoOffset_HeadVertical - targetAngle_Vertical * servoIncrementsPerRadian_HeadVertical; " is 161.
Long Statement,CountessQuantaControl,PersonTracking,C:\repos\PSU-Robotics-Countess-Quanta_Countess-Quanta-Control\Src\CountessQuantaControl\PersonTracking.cs,UpdatePosition,The length of the statement  "	//double newServoPosition_Eyes = servoCenterPostion_Eyes + (targetAngle_Horizontal - currentAngle_HeadHorizontal) * servoIncrementsPerRadian_Eyes; " is 146.
Long Statement,CountessQuantaControl,PersonTracking,C:\repos\PSU-Robotics-Countess-Quanta_Countess-Quanta-Control\Src\CountessQuantaControl\PersonTracking.cs,UpdatePosition,The length of the statement  "	//ErrorLogging.AddMessage(ErrorLogging.LoggingLevel.Warning' "PersonTrackingUpdate: targetAngle_Horizontal = " + targetAngle_Horizontal + "' newServoPosition_HeadHorizontal = " + newServoPosition_HeadHorizontal + "' newServoPosition_Eyes = " + newServoPosition_Eyes); " is 267.
Long Statement,CountessQuantaControl,RobotEyes,C:\repos\PSU-Robotics-Countess-Quanta_Countess-Quanta-Control\Src\CountessQuantaControl\RobotEyes.cs,SetEyeState,The length of the statement  "	ErrorLogging.AddMessage (ErrorLogging.LoggingLevel.Info' "SetEyeState setting left eye " + (leftEyeOpen ? "Open" : "Closed") + " and right eye " + (rightEyeOpen ? "Open" : "Closed") + "."); " is 189.
Long Statement,CountessQuantaControl,RobotEyes,C:\repos\PSU-Robotics-Countess-Quanta_Countess-Quanta-Control\Src\CountessQuantaControl\RobotEyes.cs,SetHardwareState,The length of the statement  "	//ErrorLogging.AddMessage(ErrorLogging.LoggingLevel.Debug' "SetHardwareState set left eye " + (leftEyeOpen ? "Open" : "Closed") + " and right eye " + (rightEyeOpen ? "Open" : "Closed") + "."); " is 192.
Long Statement,CountessQuantaControl,RobotEyes,C:\repos\PSU-Robotics-Countess-Quanta_Countess-Quanta-Control\Src\CountessQuantaControl\RobotEyes.cs,Blinking,The length of the statement  "		int randomTimeUntilNextBlink = blinkTimer.Next ((int)(minSecondsBetweenBlinks * 1000)' (int)(maxSecondsBetweenBlinks * 1000)); " is 126.
Long Statement,CountessQuantaControl,RobotEyes,C:\repos\PSU-Robotics-Countess-Quanta_Countess-Quanta-Control\Src\CountessQuantaControl\RobotEyes.cs,Blinking,The length of the statement  "		//ErrorLogging.AddMessage(ErrorLogging.LoggingLevel.Debug' "Blinking() triggered after " + randomTimeUntilNextBlink.ToString() + "ms' blinking the eyes..."); " is 157.
Long Statement,CountessQuantaControl,SequenceProcessor,C:\repos\PSU-Robotics-Countess-Quanta_Countess-Quanta-Control\Src\CountessQuantaControl\SequenceProcessor.cs,RunSequence,The length of the statement  "			ErrorLogging.AddMessage (ErrorLogging.LoggingLevel.Warning' "RunSequence() failed to run sequence '" + sequenceName + "'' another sequence is already running."); " is 161.
Long Statement,CountessQuantaControl,SequenceProcessor,C:\repos\PSU-Robotics-Countess-Quanta_Countess-Quanta-Control\Src\CountessQuantaControl\SequenceProcessor.cs,RunSequenceThread,The length of the statement  "		ErrorLogging.AddMessage (ErrorLogging.LoggingLevel.Warning' "Servo hardware is disconnected' running servos in simulation mode for sequence '" + runningSequence.name + "'."); " is 174.
Long Statement,CountessQuantaControl,SequenceProcessor,C:\repos\PSU-Robotics-Countess-Quanta_Countess-Quanta-Control\Src\CountessQuantaControl\SequenceProcessor.cs,RunSequenceThread,The length of the statement  "		ErrorLogging.AddMessage (ErrorLogging.LoggingLevel.Warning' "Robot base hardware is disconnected' running robot base in simulation mode for sequence '" + runningSequence.name + "'."); " is 183.
Long Statement,CountessQuantaControl,SequenceProcessor,C:\repos\PSU-Robotics-Countess-Quanta_Countess-Quanta-Control\Src\CountessQuantaControl\SequenceProcessor.cs,RunSequenceThread,The length of the statement  "	ErrorLogging.AddMessage (ErrorLogging.LoggingLevel.Info' "RunSequenceThread(): sequence '" + runningSequence.name + "' started."); " is 130.
Long Statement,CountessQuantaControl,SequenceProcessor,C:\repos\PSU-Robotics-Countess-Quanta_Countess-Quanta-Control\Src\CountessQuantaControl\SequenceProcessor.cs,RunSequenceThread,The length of the statement  "	ErrorLogging.AddMessage (ErrorLogging.LoggingLevel.Info' "RunSequenceThread(): sequence '" + runningSequence.name + "' completed."); " is 132.
Long Statement,CountessQuantaControl,SequenceProcessor,C:\repos\PSU-Robotics-Countess-Quanta_Countess-Quanta-Control\Src\CountessQuantaControl\SequenceProcessor.cs,MoveWheels,The length of the statement  "	// so we prioritize the translation/rotation moves and ignore individual wheel moves' if translation/rotation is specified. " is 123.
Long Statement,CountessQuantaControl,ServoManager,C:\repos\PSU-Robotics-Countess-Quanta_Countess-Quanta-Control\Src\CountessQuantaControl\ServoManager.cs,ConnectToHardware,The length of the statement  "			ErrorLogging.AddMessage (ErrorLogging.LoggingLevel.Info' "ConnectToHardware() succeeded' connected to servo hardware."); " is 120.
Long Statement,CountessQuantaControl,ServoManager,C:\repos\PSU-Robotics-Countess-Quanta_Countess-Quanta-Control\Src\CountessQuantaControl\ServoManager.cs,DisconnectFromHardware,The length of the statement  "			ErrorLogging.AddMessage (ErrorLogging.LoggingLevel.Error' "DisconnectFromHardware failed to cleaning disconnect the servo hardware: " + ex.Message); " is 148.
Long Statement,CountessQuantaControl,ServoManager,C:\repos\PSU-Robotics-Countess-Quanta_Countess-Quanta-Control\Src\CountessQuantaControl\ServoManager.cs,InitializeHardware,The length of the statement  "		ErrorLogging.AddMessage (ErrorLogging.LoggingLevel.Error' "InitializeHardware() failed' not connected to servo hardware."); " is 123.
Long Statement,CountessQuantaControl,ServoManager,C:\repos\PSU-Robotics-Countess-Quanta_Countess-Quanta-Control\Src\CountessQuantaControl\ServoManager.cs,InitializeHardware,The length of the statement  "	ErrorLogging.AddMessage (ErrorLogging.LoggingLevel.Info' "InitializeHardware() succeeded' servo hardware was initialized."); " is 124.
Long Statement,CountessQuantaControl,ServoManager,C:\repos\PSU-Robotics-Countess-Quanta_Countess-Quanta-Control\Src\CountessQuantaControl\ServoManager.cs,LoadServoConfiguration,The length of the statement  "		ErrorLogging.AddMessage (ErrorLogging.LoggingLevel.Debug' "Loaded Servo " + servo.index + ": Name = " + servo.name + "' PosMin = " + servo.positionLimitMin + "' PosMax = " + servo.positionLimitMax + "' SpeedMin = " + servo.speedLimitMin + "' SpeedMax = " + servo.speedLimitMax); " is 278.
Long Statement,CountessQuantaControl,ServoManager,C:\repos\PSU-Robotics-Countess-Quanta_Countess-Quanta-Control\Src\CountessQuantaControl\ServoManager.cs,UpdateServoValues,The length of the statement  "		ErrorLogging.AddMessage (ErrorLogging.LoggingLevel.Error' "UpdateServoValues() failed' not connected to servo hardware."); " is 122.
Long Statement,CountessQuantaControl,ServoManager,C:\repos\PSU-Robotics-Countess-Quanta_Countess-Quanta-Control\Src\CountessQuantaControl\ServoManager.cs,UpdateServoValues,The length of the statement  "				ErrorLogging.AddMessage (ErrorLogging.LoggingLevel.Error' "UpdateServoValues() failed' servo index out of range. Servo index = " + servo.index.ToString ()); " is 156.
Long Statement,CountessQuantaControl,ServoManager,C:\repos\PSU-Robotics-Countess-Quanta_Countess-Quanta-Control\Src\CountessQuantaControl\ServoManager.cs,UpdateServoValues,The length of the statement  "				ErrorLogging.AddMessage (ErrorLogging.LoggingLevel.Debug' "Servo " + servo.index.ToString () + ": Target = " + servo.polledTarget.ToString () + "' Position = " + servo.polledPosition.ToString () + "' Speed = " + servo.polledSpeed.ToString () + "' Acceleration = " + servo.polledAcceleration.ToString ()); " is 304.
Long Statement,CountessQuantaControl,ServoManager,C:\repos\PSU-Robotics-Countess-Quanta_Countess-Quanta-Control\Src\CountessQuantaControl\ServoManager.cs,UpdateServoValues,The length of the statement  "					ErrorLogging.AddMessage (ErrorLogging.LoggingLevel.Debug' "Servo " + servo.index + " has started moving from " + servo.polledPosition.ToString () + " to " + servo.polledTarget.ToString ()); " is 189.
Long Statement,CountessQuantaControl,ServoManager,C:\repos\PSU-Robotics-Countess-Quanta_Countess-Quanta-Control\Src\CountessQuantaControl\ServoManager.cs,UpdateServoValues,The length of the statement  "					ErrorLogging.AddMessage (ErrorLogging.LoggingLevel.Debug' "Servo " + servo.index + " has stopped moving at " + servo.polledPosition.ToString ()); " is 145.
Long Statement,CountessQuantaControl,ServoManager,C:\repos\PSU-Robotics-Countess-Quanta_Countess-Quanta-Control\Src\CountessQuantaControl\ServoManager.cs,UpdateServoValues,The length of the statement  "					ErrorLogging.AddMessage (ErrorLogging.LoggingLevel.Debug' "Servo " + servo.index + " is at position " + servo.polledPosition.ToString ()); " is 138.
Long Statement,CountessQuantaControl,ServoManager,C:\repos\PSU-Robotics-Countess-Quanta_Countess-Quanta-Control\Src\CountessQuantaControl\ServoManager.cs,SetServoPosition,The length of the statement  "		ErrorLogging.AddMessage (ErrorLogging.LoggingLevel.Warning' "Requested servo " + servo.index.ToString () + " position " + position.ToString () + " bound to minimum limit " + servo.positionLimitMin.ToString ()); " is 210.
Long Statement,CountessQuantaControl,ServoManager,C:\repos\PSU-Robotics-Countess-Quanta_Countess-Quanta-Control\Src\CountessQuantaControl\ServoManager.cs,SetServoPosition,The length of the statement  "		ErrorLogging.AddMessage (ErrorLogging.LoggingLevel.Warning' "Requested servo " + servo.index.ToString () + " position " + position.ToString () + " bound to maximum limit " + servo.positionLimitMax.ToString ()); " is 210.
Long Statement,CountessQuantaControl,ServoManager,C:\repos\PSU-Robotics-Countess-Quanta_Countess-Quanta-Control\Src\CountessQuantaControl\ServoManager.cs,SetServoPosition,The length of the statement  "	ErrorLogging.AddMessage (ErrorLogging.LoggingLevel.Debug' "Setting servo " + servo.index.ToString () + " position to " + position.ToString ()); " is 143.
Long Statement,CountessQuantaControl,ServoManager,C:\repos\PSU-Robotics-Countess-Quanta_Countess-Quanta-Control\Src\CountessQuantaControl\ServoManager.cs,SetServoSpeed,The length of the statement  "		ErrorLogging.AddMessage (ErrorLogging.LoggingLevel.Warning' "Requested servo " + servo.index.ToString () + " speed " + speed.ToString () + " bound to minimum limit " + servo.speedLimitMin.ToString ()); " is 201.
Long Statement,CountessQuantaControl,ServoManager,C:\repos\PSU-Robotics-Countess-Quanta_Countess-Quanta-Control\Src\CountessQuantaControl\ServoManager.cs,SetServoSpeed,The length of the statement  "		ErrorLogging.AddMessage (ErrorLogging.LoggingLevel.Warning' "Requested servo " + servo.index.ToString () + " speed " + speed.ToString () + " bound to maximum limit " + servo.speedLimitMax.ToString ()); " is 201.
Long Statement,CountessQuantaControl,ServoManager,C:\repos\PSU-Robotics-Countess-Quanta_Countess-Quanta-Control\Src\CountessQuantaControl\ServoManager.cs,SetServoSpeed,The length of the statement  "	ErrorLogging.AddMessage (ErrorLogging.LoggingLevel.Debug' "Setting servo " + servo.index.ToString () + " speed to " + speed.ToString ()); " is 137.
Long Statement,CountessQuantaControl,ServoManager,C:\repos\PSU-Robotics-Countess-Quanta_Countess-Quanta-Control\Src\CountessQuantaControl\ServoManager.cs,SetServoAcceleration,The length of the statement  "	ErrorLogging.AddMessage (ErrorLogging.LoggingLevel.Debug' "Setting servo " + servo.index.ToString () + " acceleration to " + acceleration.ToString ()); " is 151.
Long Statement,CountessQuantaControl,ServoManager,C:\repos\PSU-Robotics-Countess-Quanta_Countess-Quanta-Control\Src\CountessQuantaControl\ServoManager.cs,StartTimedMove,The length of the statement  "		ErrorLogging.AddMessage (ErrorLogging.LoggingLevel.Error' "StartTimedMove failed' servo " + servoPosition.index.ToString () + " not found."); " is 141.
Long Statement,CountessQuantaControl,ServoManager,C:\repos\PSU-Robotics-Countess-Quanta_Countess-Quanta-Control\Src\CountessQuantaControl\ServoManager.cs,WaitForMoveComplete,The length of the statement  "			ErrorLogging.AddMessage (ErrorLogging.LoggingLevel.Error' "WaitForMoveComplete failed' servo " + servoPosition.index.ToString () + " not found."); " is 146.
Long Statement,CountessQuantaControl,ServoManager,C:\repos\PSU-Robotics-Countess-Quanta_Countess-Quanta-Control\Src\CountessQuantaControl\ServoManager.cs,WaitForMoveComplete,The length of the statement  "			ErrorLogging.AddMessage (ErrorLogging.LoggingLevel.Warning' "WaitForMoveComplete timeout' servos failed to reach destination in " + pollTimeout.ToString () + " seconds."); " is 171.
Long Statement,CountessQuantaControl,ServoManager,C:\repos\PSU-Robotics-Countess-Quanta_Countess-Quanta-Control\Src\CountessQuantaControl\ServoManager.cs,WaitForMoveComplete,The length of the statement  "			ErrorLogging.AddMessage (ErrorLogging.LoggingLevel.Debug' "WaitForMoveComplete succeeded' all servos reached destinations."); " is 125.
Long Statement,CountessQuantaControl,ServoManager,C:\repos\PSU-Robotics-Countess-Quanta_Countess-Quanta-Control\Src\CountessQuantaControl\ServoManager.cs,MoveServos,The length of the statement  "	ErrorLogging.AddMessage (ErrorLogging.LoggingLevel.Debug' "MoveServos moving servos over " + timeToDestination + " seconds."); " is 126.
Long Statement,CountessQuantaControl,ServoManager,C:\repos\PSU-Robotics-Countess-Quanta_Countess-Quanta-Control\Src\CountessQuantaControl\ServoManager.cs,MoveServos,The length of the statement  "			ErrorLogging.AddMessage (ErrorLogging.LoggingLevel.Debug' "MoveServos set isRunningHighPriorityMove for servo " + servo.index.ToString () + "."); " is 145.
Long Statement,CountessQuantaControl,ServoManager,C:\repos\PSU-Robotics-Countess-Quanta_Countess-Quanta-Control\Src\CountessQuantaControl\ServoManager.cs,MoveServos,The length of the statement  "				ErrorLogging.AddMessage (ErrorLogging.LoggingLevel.Debug' "MoveServos cleared isRunningHighPriorityMove for servo " + servo.index.ToString () + "."); " is 149.
Long Statement,CountessQuantaControl,ServoManager,C:\repos\PSU-Robotics-Countess-Quanta_Countess-Quanta-Control\Src\CountessQuantaControl\ServoManager.cs,MoveServos,The length of the statement  "			ErrorLogging.AddMessage (ErrorLogging.LoggingLevel.Debug' "MoveServos cleared isRunningHighPriorityMove for servo " + servo.index.ToString () + "."); " is 149.
Long Statement,CountessQuantaControl,ServoManager,C:\repos\PSU-Robotics-Countess-Quanta_Countess-Quanta-Control\Src\CountessQuantaControl\ServoManager.cs,StartSpeedMove,The length of the statement  "	ErrorLogging.AddMessage (ErrorLogging.LoggingLevel.Debug' "StartSpeedMove moving servo " + servoPosition.index.ToString () + " to position " + servoPosition.position.ToString () + " at speed " + servoSpeed.ToString () + "."); " is 225.
Long Statement,CountessQuantaControl,ServoManager,C:\repos\PSU-Robotics-Countess-Quanta_Countess-Quanta-Control\Src\CountessQuantaControl\ServoManager.cs,StartSpeedMove,The length of the statement  "			ErrorLogging.AddMessage (ErrorLogging.LoggingLevel.Debug' "StartSpeedMove' isRunningHighPriorityMove is set for servo " + servo.index.ToString () + ". Aborting move."); " is 168.
Long Statement,CountessQuantaControl,SkeletonViewer,C:\repos\PSU-Robotics-Countess-Quanta_Countess-Quanta-Control\Src\CountessQuantaControl\SkeletonViewer.xaml.cs,RenderClippedEdges,The length of the statement  "		drawingContext.DrawRectangle (Brushes.Red' null' new Rect (0' RenderHeight - ClipBoundsThickness' RenderWidth' ClipBoundsThickness)); " is 133.
Long Statement,CountessQuantaControl,SkeletonViewer,C:\repos\PSU-Robotics-Countess-Quanta_Countess-Quanta-Control\Src\CountessQuantaControl\SkeletonViewer.xaml.cs,RenderClippedEdges,The length of the statement  "		drawingContext.DrawRectangle (Brushes.Red' null' new Rect (RenderWidth - ClipBoundsThickness' 0' ClipBoundsThickness' RenderHeight)); " is 133.
Long Statement,CountessQuantaControl,SkeletonViewer,C:\repos\PSU-Robotics-Countess-Quanta_Countess-Quanta-Control\Src\CountessQuantaControl\SkeletonViewer.xaml.cs,SensorSkeletonFrameReady,The length of the statement  "					dc.DrawEllipse (this.centerPointBrush' null' this.SkeletonPointToScreen (skel.Position)' BodyCenterThickness' BodyCenterThickness); " is 131.
Long Statement,CountessQuantaControl,SkeletonViewer,C:\repos\PSU-Robotics-Countess-Quanta_Countess-Quanta-Control\Src\CountessQuantaControl\SkeletonViewer.xaml.cs,DrawBonesAndJoints,The length of the statement  "			drawingContext.DrawEllipse (drawBrush' null' this.SkeletonPointToScreen (joint.Position)' JointThickness' JointThickness); " is 122.
Long Statement,CountessQuantaControl,SkeletonViewer,C:\repos\PSU-Robotics-Countess-Quanta_Countess-Quanta-Control\Src\CountessQuantaControl\SkeletonViewer.xaml.cs,SkeletonPointToScreen,The length of the statement  "	//DepthImagePoint depthPoint = this.sensor.CoordinateMapper.MapSkeletonPointToDepthPoint(skelpoint' DepthImageFormat.Resolution640x480Fps30); " is 141.
Long Statement,CountessQuantaControl,SkeletonViewer,C:\repos\PSU-Robotics-Countess-Quanta_Countess-Quanta-Control\Src\CountessQuantaControl\SkeletonViewer.xaml.cs,SkeletonPointToScreen,The length of the statement  "	DepthImagePoint depthPoint = kinectManager.MapSkeletonPointToDepthPoint (skelpoint' DepthImageFormat.Resolution640x480Fps30); " is 125.
Long Statement,CountessQuantaControl,SkeletonViewer,C:\repos\PSU-Robotics-Countess-Quanta_Countess-Quanta-Control\Src\CountessQuantaControl\SkeletonViewer.xaml.cs,DrawBone,The length of the statement  "	drawingContext.DrawLine (drawPen' this.SkeletonPointToScreen (joint0.Position)' this.SkeletonPointToScreen (joint1.Position)); " is 126.
Long Statement,CountessQuantaControl,KinectManager,C:\repos\PSU-Robotics-Countess-Quanta_Countess-Quanta-Control\Src\CountessQuantaControl\KinectManager.cs,InitializeKinect,The length of the statement  "	// it is recommended to use KinectSensorChooser provided in Microsoft.Kinect.Toolkit (See components in Toolkit Browser). " is 121.
Long Statement,CountessQuantaControl,KinectManager,C:\repos\PSU-Robotics-Countess-Quanta_Countess-Quanta-Control\Src\CountessQuantaControl\KinectManager.cs,InitializeKinect,The length of the statement  "		ErrorLogging.AddMessage (ErrorLogging.LoggingLevel.Error' "InitializeKinect() failed' not connected to Kinect sensor."); " is 120.
Long Statement,CountessQuantaControl,KinectManager,C:\repos\PSU-Robotics-Countess-Quanta_Countess-Quanta-Control\Src\CountessQuantaControl\KinectManager.cs,InitializeKinect,The length of the statement  "		// For long recognition sessions (a few hours or more)' it may be beneficial to turn off adaptation of the acoustic model.  " is 122.
Long Statement,CountessQuantaControl,KinectManager,C:\repos\PSU-Robotics-Countess-Quanta_Countess-Quanta-Control\Src\CountessQuantaControl\KinectManager.cs,InitializeKinect,The length of the statement  "		speechEngine.SetInputToAudioStream (sensor.AudioSource.Start ()' new SpeechAudioFormatInfo (EncodingFormat.Pcm' 16000' 16' 1' 32000' 2' null)); " is 143.
Long Statement,CountessQuantaControl,KinectManager,C:\repos\PSU-Robotics-Countess-Quanta_Countess-Quanta-Control\Src\CountessQuantaControl\KinectManager.cs,GetKinectRecognizer,The length of the statement  "		if ("True".Equals (value' StringComparison.OrdinalIgnoreCase) && "en-US".Equals (recognizer.Culture.Name' StringComparison.OrdinalIgnoreCase)) { " is 144.
Long Statement,CountessQuantaControl,KinectManager,C:\repos\PSU-Robotics-Countess-Quanta_Countess-Quanta-Control\Src\CountessQuantaControl\KinectManager.cs,SpeechRecognized,The length of the statement  "			ErrorLogging.AddMessage (ErrorLogging.LoggingLevel.Warning' "SpeechRecognized: Ignored word '" + e.Result.Text + "'' since synthesizer is speaking."); " is 150.
Long Statement,CountessQuantaControl,KinectManager,C:\repos\PSU-Robotics-Countess-Quanta_Countess-Quanta-Control\Src\CountessQuantaControl\KinectManager.cs,SpeechRecognized,The length of the statement  "	ErrorLogging.AddMessage (ErrorLogging.LoggingLevel.Info' "SpeechRecognized: Detected word '" + e.Result.Text + "' with confidence " + e.Result.Confidence.ToString ()); " is 167.
Long Statement,CountessQuantaControl,KinectManager,C:\repos\PSU-Robotics-Countess-Quanta_Countess-Quanta-Control\Src\CountessQuantaControl\KinectManager.cs,SensorSkeletonFrameReady,The length of the statement  "				else if (skeletonIdClosestToCenter == 0 || Math.Abs (skel.Joints [JointType.ShoulderCenter].Position.X) < shortestDistanceFromCenter) { " is 135.
Long Statement,CountessQuantaControl,KinectManager,C:\repos\PSU-Robotics-Countess-Quanta_Countess-Quanta-Control\Src\CountessQuantaControl\KinectManager.cs,SensorSkeletonFrameReady,The length of the statement  "		// If the skeleton frame does not contain the one we were tracking' then track the skeleton that is closest to the center of the image (x-axis). " is 144.
Long Statement,CountessQuantaControl,KinectManager,C:\repos\PSU-Robotics-Countess-Quanta_Countess-Quanta-Control\Src\CountessQuantaControl\KinectManager.cs,SensorSkeletonFrameReady,The length of the statement  "			ErrorLogging.AddMessage (ErrorLogging.LoggingLevel.Debug' "SensorSkeletonFrameReady() now tracking skeleton ID " + trackedSkeletonId.ToString () + "."); " is 152.
Long Statement,CountessQuantaControl,KinectManager,C:\repos\PSU-Robotics-Countess-Quanta_Countess-Quanta-Control\Src\CountessQuantaControl\KinectManager.cs,SensorSkeletonFrameReady,The length of the statement  "				// This should help prevent detecting false gestures' due to the skeleton being scrambled as it leaves the viewing area. " is 120.
Long Statement,CountessQuantaControl,KinectManager,C:\repos\PSU-Robotics-Countess-Quanta_Countess-Quanta-Control\Src\CountessQuantaControl\KinectManager.cs,SensorSkeletonFrameReady,The length of the statement  "						//leftHandGesture.Evaluate(sequenceProcessor' skel.Joints[JointType.HandLeft].Position.Y > skel.Joints[JointType.ElbowLeft].Position.Y' "Left Hand Raised"); " is 156.
Long Statement,CountessQuantaControl,KinectManager,C:\repos\PSU-Robotics-Countess-Quanta_Countess-Quanta-Control\Src\CountessQuantaControl\KinectManager.cs,SensorSkeletonFrameReady,The length of the statement  "						//rightHandGesture.Evaluate(sequenceProcessor' skel.Joints[JointType.HandRight].Position.Y > skel.Joints[JointType.ElbowRight].Position.Y' "Right Hand Raised"); " is 160.
Long Statement,CountessQuantaControl,KinectManager,C:\repos\PSU-Robotics-Countess-Quanta_Countess-Quanta-Control\Src\CountessQuantaControl\KinectManager.cs,SensorSkeletonFrameReady,The length of the statement  "						RightHandAboveHead.Evaluate (sequenceProcessor' skel.Joints [JointType.HandRight].Position.Y > skel.Joints [JointType.Head].Position.Y' "Hello"); " is 145.
Long Statement,CountessQuantaControl,KinectManager,C:\repos\PSU-Robotics-Countess-Quanta_Countess-Quanta-Control\Src\CountessQuantaControl\KinectManager.cs,SensorSkeletonFrameReady,The length of the statement  "						RightHandBetweenSpineAndShoulderCenter.Evaluate (sequenceProcessor' skel.Joints [JointType.HandRight].Position.Y > skel.Joints [JointType.Spine].Position.Y && skel.Joints [JointType.HandRight].Position.Y < skel.Joints [JointType.ShoulderCenter].Position.Y && skel.Joints [JointType.HandRight].Position.X < (skel.Joints [JointType.Spine].Position.X + 0.1)' "PLAYMUSIC"); " is 369.
Long Statement,CountessQuantaControl,KinectManager,C:\repos\PSU-Robotics-Countess-Quanta_Countess-Quanta-Control\Src\CountessQuantaControl\KinectManager.cs,SensorSkeletonFrameReady,The length of the statement  "						LeftElbowAboveLeftShoulder.Evaluate (sequenceProcessor' skel.Joints [JointType.ElbowLeft].Position.Y > skel.Joints [JointType.ShoulderLeft].Position.Y' "NeckRotate"); " is 166.
Long Statement,CountessQuantaControl,KinectManager,C:\repos\PSU-Robotics-Countess-Quanta_Countess-Quanta-Control\Src\CountessQuantaControl\KinectManager.cs,SensorSkeletonFrameReady,The length of the statement  "					ErrorLogging.AddMessage (ErrorLogging.LoggingLevel.Debug' "SensorSkeletonFrameReady() skipped update due to skeleton being outside of view."); " is 142.
Long Statement,CountessQuantaControl,ControlWindow,C:\repos\PSU-Robotics-Countess-Quanta_Countess-Quanta-Control\Src\CountessQuantaControl\ControlWindow.xaml.cs,TestSpeech_Click,The length of the statement  "	speechSynthesizer.SelectVoice (speechSynthesizer.GetInstalledVoices ().Where (i => i.Enabled && i.VoiceInfo.Gender == VoiceGender.Female).First ().VoiceInfo.Name); " is 163.
Magic Number,CountessQuantaControl,AriaManager,C:\repos\PSU-Robotics-Countess-Quanta_Countess-Quanta-Control\Src\CountessQuantaControl\AriaManager.cs,InitializeAriaHardware,The following statement contains a magic number: switch (hr) {  case 0:  	ErrorLogging.AddMessage (ErrorLogging.LoggingLevel.Info' "InitializeAria() succeeded' connected to robot base control.");  	break;  case 1:  	ErrorLogging.AddMessage (ErrorLogging.LoggingLevel.Error' "InitializeAria() failed' could not parse arguments.");  	break;  case 2:  	ErrorLogging.AddMessage (ErrorLogging.LoggingLevel.Error' "InitializeAria() failed' could not connect to robot base.");  	break;  }  
Magic Number,CountessQuantaControl,AriaManager,C:\repos\PSU-Robotics-Countess-Quanta_Countess-Quanta-Control\Src\CountessQuantaControl\AriaManager.cs,StartTimer,The following statement contains a magic number: stopWheelsTimer.Interval = timeToDestination * 1000;  
Magic Number,CountessQuantaControl,AriaManager,C:\repos\PSU-Robotics-Countess-Quanta_Countess-Quanta-Control\Src\CountessQuantaControl\AriaManager.cs,StopTimer,The following statement contains a magic number: while (true) {  	lock (stopTimerLock) {  		if (!isStopping) {  			// Not in the middle of event' so just return.  			return;  		}  	}  	// Event is being processed' so wait and check again.  	Thread.Sleep (10);  }  
Magic Number,CountessQuantaControl,AriaManager,C:\repos\PSU-Robotics-Countess-Quanta_Countess-Quanta-Control\Src\CountessQuantaControl\AriaManager.cs,StopTimer,The following statement contains a magic number: Thread.Sleep (10);  
Magic Number,CountessQuantaControl,PersonTracking,C:\repos\PSU-Robotics-Countess-Quanta_Countess-Quanta-Control\Src\CountessQuantaControl\PersonTracking.cs,Enable,The following statement contains a magic number: while (!updateIsComplete) {  	Thread.Sleep (10);  	lock (personTrackingLock) {  		updateIsComplete = !isAlreadyUpdatingTracking;  	}  }  
Magic Number,CountessQuantaControl,PersonTracking,C:\repos\PSU-Robotics-Countess-Quanta_Countess-Quanta-Control\Src\CountessQuantaControl\PersonTracking.cs,Enable,The following statement contains a magic number: Thread.Sleep (10);  
Magic Number,CountessQuantaControl,RobotEyes,C:\repos\PSU-Robotics-Countess-Quanta_Countess-Quanta-Control\Src\CountessQuantaControl\RobotEyes.cs,Blinking,The following statement contains a magic number: while (true) {  	int randomTimeUntilNextBlink = blinkTimer.Next ((int)(minSecondsBetweenBlinks * 1000)' (int)(maxSecondsBetweenBlinks * 1000));  	Thread.Sleep (randomTimeUntilNextBlink);  	//ErrorLogging.AddMessage(ErrorLogging.LoggingLevel.Debug' "Blinking() triggered after " + randomTimeUntilNextBlink.ToString() + "ms' blinking the eyes...");  	lock (eyeStateLock) {  		blinkInProgress = true;  	}  	// Close eyes.  	SetHardwareState (false' false);  	Thread.Sleep (100);  	lock (eyeStateLock) {  		// Restore previous state.  		SetHardwareState (leftEyeOpenState' rightEyeOpenState);  		blinkInProgress = false;  	}  }  
Magic Number,CountessQuantaControl,RobotEyes,C:\repos\PSU-Robotics-Countess-Quanta_Countess-Quanta-Control\Src\CountessQuantaControl\RobotEyes.cs,Blinking,The following statement contains a magic number: while (true) {  	int randomTimeUntilNextBlink = blinkTimer.Next ((int)(minSecondsBetweenBlinks * 1000)' (int)(maxSecondsBetweenBlinks * 1000));  	Thread.Sleep (randomTimeUntilNextBlink);  	//ErrorLogging.AddMessage(ErrorLogging.LoggingLevel.Debug' "Blinking() triggered after " + randomTimeUntilNextBlink.ToString() + "ms' blinking the eyes...");  	lock (eyeStateLock) {  		blinkInProgress = true;  	}  	// Close eyes.  	SetHardwareState (false' false);  	Thread.Sleep (100);  	lock (eyeStateLock) {  		// Restore previous state.  		SetHardwareState (leftEyeOpenState' rightEyeOpenState);  		blinkInProgress = false;  	}  }  
Magic Number,CountessQuantaControl,RobotEyes,C:\repos\PSU-Robotics-Countess-Quanta_Countess-Quanta-Control\Src\CountessQuantaControl\RobotEyes.cs,Blinking,The following statement contains a magic number: while (true) {  	int randomTimeUntilNextBlink = blinkTimer.Next ((int)(minSecondsBetweenBlinks * 1000)' (int)(maxSecondsBetweenBlinks * 1000));  	Thread.Sleep (randomTimeUntilNextBlink);  	//ErrorLogging.AddMessage(ErrorLogging.LoggingLevel.Debug' "Blinking() triggered after " + randomTimeUntilNextBlink.ToString() + "ms' blinking the eyes...");  	lock (eyeStateLock) {  		blinkInProgress = true;  	}  	// Close eyes.  	SetHardwareState (false' false);  	Thread.Sleep (100);  	lock (eyeStateLock) {  		// Restore previous state.  		SetHardwareState (leftEyeOpenState' rightEyeOpenState);  		blinkInProgress = false;  	}  }  
Magic Number,CountessQuantaControl,RobotEyes,C:\repos\PSU-Robotics-Countess-Quanta_Countess-Quanta-Control\Src\CountessQuantaControl\RobotEyes.cs,Blinking,The following statement contains a magic number: Thread.Sleep (100);  
Magic Number,CountessQuantaControl,RobotSpeech,C:\repos\PSU-Robotics-Countess-Quanta_Countess-Quanta-Control\Src\CountessQuantaControl\RobotSpeech.cs,SpeechAnimationThread,The following statement contains a magic number: while (true) {  	bool speaking = false;  	lock (isSpeakingLock) {  		speaking = isSpeaking;  	}  	if (!speaking) {  		// Pause the animation.  		waitHandle.WaitOne ();  	}  	// Perform the speech animation.  	const double mouthOpenPosition = 1200;  	const double mouthClosePosition = 700;  	const int minOpenPosition = (int)((mouthClosePosition + mouthOpenPosition) / 2);  	const double mouthMoveSpeedScaling = 0.1;  	const int mouthMoveDuration = 200;  	if (mouthServoIndex >= 0) {  		// Prepare to open the mouth to a random position.  		int randomOpenPosition = randomGenerator.Next (minOpenPosition' (int)mouthOpenPosition);  		// Scale the speed based on the move distance.  		long mouthMoveSpeed = (long)(((double)randomOpenPosition - mouthClosePosition) * mouthMoveSpeedScaling);  		// Perform the mouth open and mouth close motions.  		servoManager.StartSpeedMove (new ServoPosition (mouthServoIndex' randomOpenPosition)' mouthMoveSpeed);  		Thread.Sleep (mouthMoveDuration);  		servoManager.StartSpeedMove (new ServoPosition (mouthServoIndex' mouthClosePosition)' mouthMoveSpeed);  		Thread.Sleep (mouthMoveDuration);  	}  }  
Magic Number,CountessQuantaControl,RobotSpeech,C:\repos\PSU-Robotics-Countess-Quanta_Countess-Quanta-Control\Src\CountessQuantaControl\RobotSpeech.cs,SpeechAnimationThread,The following statement contains a magic number: while (true) {  	bool speaking = false;  	lock (isSpeakingLock) {  		speaking = isSpeaking;  	}  	if (!speaking) {  		// Pause the animation.  		waitHandle.WaitOne ();  	}  	// Perform the speech animation.  	const double mouthOpenPosition = 1200;  	const double mouthClosePosition = 700;  	const int minOpenPosition = (int)((mouthClosePosition + mouthOpenPosition) / 2);  	const double mouthMoveSpeedScaling = 0.1;  	const int mouthMoveDuration = 200;  	if (mouthServoIndex >= 0) {  		// Prepare to open the mouth to a random position.  		int randomOpenPosition = randomGenerator.Next (minOpenPosition' (int)mouthOpenPosition);  		// Scale the speed based on the move distance.  		long mouthMoveSpeed = (long)(((double)randomOpenPosition - mouthClosePosition) * mouthMoveSpeedScaling);  		// Perform the mouth open and mouth close motions.  		servoManager.StartSpeedMove (new ServoPosition (mouthServoIndex' randomOpenPosition)' mouthMoveSpeed);  		Thread.Sleep (mouthMoveDuration);  		servoManager.StartSpeedMove (new ServoPosition (mouthServoIndex' mouthClosePosition)' mouthMoveSpeed);  		Thread.Sleep (mouthMoveDuration);  	}  }  
Magic Number,CountessQuantaControl,RobotSpeech,C:\repos\PSU-Robotics-Countess-Quanta_Countess-Quanta-Control\Src\CountessQuantaControl\RobotSpeech.cs,SpeechAnimationThread,The following statement contains a magic number: while (true) {  	bool speaking = false;  	lock (isSpeakingLock) {  		speaking = isSpeaking;  	}  	if (!speaking) {  		// Pause the animation.  		waitHandle.WaitOne ();  	}  	// Perform the speech animation.  	const double mouthOpenPosition = 1200;  	const double mouthClosePosition = 700;  	const int minOpenPosition = (int)((mouthClosePosition + mouthOpenPosition) / 2);  	const double mouthMoveSpeedScaling = 0.1;  	const int mouthMoveDuration = 200;  	if (mouthServoIndex >= 0) {  		// Prepare to open the mouth to a random position.  		int randomOpenPosition = randomGenerator.Next (minOpenPosition' (int)mouthOpenPosition);  		// Scale the speed based on the move distance.  		long mouthMoveSpeed = (long)(((double)randomOpenPosition - mouthClosePosition) * mouthMoveSpeedScaling);  		// Perform the mouth open and mouth close motions.  		servoManager.StartSpeedMove (new ServoPosition (mouthServoIndex' randomOpenPosition)' mouthMoveSpeed);  		Thread.Sleep (mouthMoveDuration);  		servoManager.StartSpeedMove (new ServoPosition (mouthServoIndex' mouthClosePosition)' mouthMoveSpeed);  		Thread.Sleep (mouthMoveDuration);  	}  }  
Magic Number,CountessQuantaControl,RobotSpeech,C:\repos\PSU-Robotics-Countess-Quanta_Countess-Quanta-Control\Src\CountessQuantaControl\RobotSpeech.cs,SpeechAnimationThread,The following statement contains a magic number: while (true) {  	bool speaking = false;  	lock (isSpeakingLock) {  		speaking = isSpeaking;  	}  	if (!speaking) {  		// Pause the animation.  		waitHandle.WaitOne ();  	}  	// Perform the speech animation.  	const double mouthOpenPosition = 1200;  	const double mouthClosePosition = 700;  	const int minOpenPosition = (int)((mouthClosePosition + mouthOpenPosition) / 2);  	const double mouthMoveSpeedScaling = 0.1;  	const int mouthMoveDuration = 200;  	if (mouthServoIndex >= 0) {  		// Prepare to open the mouth to a random position.  		int randomOpenPosition = randomGenerator.Next (minOpenPosition' (int)mouthOpenPosition);  		// Scale the speed based on the move distance.  		long mouthMoveSpeed = (long)(((double)randomOpenPosition - mouthClosePosition) * mouthMoveSpeedScaling);  		// Perform the mouth open and mouth close motions.  		servoManager.StartSpeedMove (new ServoPosition (mouthServoIndex' randomOpenPosition)' mouthMoveSpeed);  		Thread.Sleep (mouthMoveDuration);  		servoManager.StartSpeedMove (new ServoPosition (mouthServoIndex' mouthClosePosition)' mouthMoveSpeed);  		Thread.Sleep (mouthMoveDuration);  	}  }  
Magic Number,CountessQuantaControl,RobotSpeech,C:\repos\PSU-Robotics-Countess-Quanta_Countess-Quanta-Control\Src\CountessQuantaControl\RobotSpeech.cs,SpeechAnimationThread,The following statement contains a magic number: while (true) {  	bool speaking = false;  	lock (isSpeakingLock) {  		speaking = isSpeaking;  	}  	if (!speaking) {  		// Pause the animation.  		waitHandle.WaitOne ();  	}  	// Perform the speech animation.  	const double mouthOpenPosition = 1200;  	const double mouthClosePosition = 700;  	const int minOpenPosition = (int)((mouthClosePosition + mouthOpenPosition) / 2);  	const double mouthMoveSpeedScaling = 0.1;  	const int mouthMoveDuration = 200;  	if (mouthServoIndex >= 0) {  		// Prepare to open the mouth to a random position.  		int randomOpenPosition = randomGenerator.Next (minOpenPosition' (int)mouthOpenPosition);  		// Scale the speed based on the move distance.  		long mouthMoveSpeed = (long)(((double)randomOpenPosition - mouthClosePosition) * mouthMoveSpeedScaling);  		// Perform the mouth open and mouth close motions.  		servoManager.StartSpeedMove (new ServoPosition (mouthServoIndex' randomOpenPosition)' mouthMoveSpeed);  		Thread.Sleep (mouthMoveDuration);  		servoManager.StartSpeedMove (new ServoPosition (mouthServoIndex' mouthClosePosition)' mouthMoveSpeed);  		Thread.Sleep (mouthMoveDuration);  	}  }  
Magic Number,CountessQuantaControl,SequenceProcessor,C:\repos\PSU-Robotics-Countess-Quanta_Countess-Quanta-Control\Src\CountessQuantaControl\SequenceProcessor.cs,RunSequenceThread,The following statement contains a magic number: foreach (Frame frame in runningSequence.GetFrames ()) {  	// Run the speech synthesizer asynchronously. Speaks while continuing to   	// perform moves in this and subsequent frames.  	if (frame.speechString != null) {  		robotSpeech.Speak (frame.speechString);  	}  	// Set the state of the LED eyes.  	if (frame.eyeState != null) {  		switch (frame.eyeState) {  		case "Open":  			robotEyes.SetEyeState (true' true);  			break;  		case "Closed":  			robotEyes.SetEyeState (false' false);  			break;  		case "LeftClosed":  			robotEyes.SetEyeState (false' true);  			break;  		case "RightClosed":  			robotEyes.SetEyeState (true' false);  			break;  		}  	}  	// Wait for the specified amount of time.  	if (frame.delay > 0) {  		Thread.Sleep ((int)(frame.delay * 1000));  	}  	// Servo motion and wheel motion are performed simultaneously by creating two separate threads and   	// waiting until both threads have completed their motion.  	ManualResetEvent[] manualEvents = new ManualResetEvent[] {  		new ManualResetEvent (false)'  		new ManualResetEvent (false)  	};  	// Start servo motion thread.  	Thread servoThread = new Thread (new ParameterizedThreadStart (MoveServos));  	servoThread.Start (new SequenceThreadData (frame' manualEvents [0]));  	// Start wheel motion thread.  	Thread wheelsThread = new Thread (new ParameterizedThreadStart (MoveWheels));  	wheelsThread.Start (new SequenceThreadData (frame' manualEvents [1]));  	// Wait until both servo motion and wheel motion has completed.  	WaitHandle.WaitAll (manualEvents);  }  
Magic Number,CountessQuantaControl,SequenceProcessor,C:\repos\PSU-Robotics-Countess-Quanta_Countess-Quanta-Control\Src\CountessQuantaControl\SequenceProcessor.cs,RunSequenceThread,The following statement contains a magic number: if (frame.delay > 0) {  	Thread.Sleep ((int)(frame.delay * 1000));  }  
Magic Number,CountessQuantaControl,SequenceProcessor,C:\repos\PSU-Robotics-Countess-Quanta_Countess-Quanta-Control\Src\CountessQuantaControl\SequenceProcessor.cs,RunSequenceThread,The following statement contains a magic number: Thread.Sleep ((int)(frame.delay * 1000));  
Magic Number,CountessQuantaControl,ServoManager,C:\repos\PSU-Robotics-Countess-Quanta_Countess-Quanta-Control\Src\CountessQuantaControl\ServoManager.cs,SetServoPosition,The following statement contains a magic number: try {  	lock (uscLock) {  		if (!isEnabled) {  			return;  		}  		if (uscDevice == null) {  			throw new System.Exception ("uscDevice is null");  		}  		// Send this value to the hardware.  		// Note that the servo position values are handled in this class in units of μs'   		// to match the convention used by Pololu's Maestro Control Center application.   		// However' the servo controller hardware expects the position represented as an   		// integer value in 0.25 μs. The local value must be multiplied by 4 to convert   		// to these units.  		uscDevice.setTarget ((byte)servo.index' (ushort)(position * 4));  	}  }  catch (System.Exception ex) {  	ErrorLogging.AddMessage (ErrorLogging.LoggingLevel.Error' "Caught exception in SetServoPosition(): " + ex.Message);  }  
Magic Number,CountessQuantaControl,ServoManager,C:\repos\PSU-Robotics-Countess-Quanta_Countess-Quanta-Control\Src\CountessQuantaControl\ServoManager.cs,SetServoPosition,The following statement contains a magic number: lock (uscLock) {  	if (!isEnabled) {  		return;  	}  	if (uscDevice == null) {  		throw new System.Exception ("uscDevice is null");  	}  	// Send this value to the hardware.  	// Note that the servo position values are handled in this class in units of μs'   	// to match the convention used by Pololu's Maestro Control Center application.   	// However' the servo controller hardware expects the position represented as an   	// integer value in 0.25 μs. The local value must be multiplied by 4 to convert   	// to these units.  	uscDevice.setTarget ((byte)servo.index' (ushort)(position * 4));  }  
Magic Number,CountessQuantaControl,ServoManager,C:\repos\PSU-Robotics-Countess-Quanta_Countess-Quanta-Control\Src\CountessQuantaControl\ServoManager.cs,SetServoPosition,The following statement contains a magic number: uscDevice.setTarget ((byte)servo.index' (ushort)(position * 4));  
Magic Number,CountessQuantaControl,ServoManager,C:\repos\PSU-Robotics-Countess-Quanta_Countess-Quanta-Control\Src\CountessQuantaControl\ServoManager.cs,StartTimedMove,The following statement contains a magic number: if (servo.polledPosition == 0) {  	// If the servo position is 0' then the servo is off and we have no information about its actual position.  	// We don't know the actual move distance' so just use the default servo speed.  	servoSpeed = (ushort)servo.defaultSpeed;  }  else {  	// Convert current position to μs (the hardware uses 0.25 μs increments).  	double currentPosition = ((double)servo.polledPosition) / 4;  	// Position difference in μs.  	double positionDifference = Math.Abs (servoPosition.position - currentPosition);  	// Required speed in (μs/second).  	double calculatedSpeed;  	if (timeToDestination != 0) {  		calculatedSpeed = positionDifference / timeToDestination;  	}  	else {  		// If the desired move time is instantaneous' use the max allowed servo speed.  		calculatedSpeed = servo.speedLimitMax;  	}  	// Convert speed from (1 μs / second) to (0.25 μs / 10 ms)' used by the hardware.  	servoSpeed = (ushort)(calculatedSpeed * (4.0 / 100.0));  }  
Magic Number,CountessQuantaControl,ServoManager,C:\repos\PSU-Robotics-Countess-Quanta_Countess-Quanta-Control\Src\CountessQuantaControl\ServoManager.cs,StartTimedMove,The following statement contains a magic number: if (servo.polledPosition == 0) {  	// If the servo position is 0' then the servo is off and we have no information about its actual position.  	// We don't know the actual move distance' so just use the default servo speed.  	servoSpeed = (ushort)servo.defaultSpeed;  }  else {  	// Convert current position to μs (the hardware uses 0.25 μs increments).  	double currentPosition = ((double)servo.polledPosition) / 4;  	// Position difference in μs.  	double positionDifference = Math.Abs (servoPosition.position - currentPosition);  	// Required speed in (μs/second).  	double calculatedSpeed;  	if (timeToDestination != 0) {  		calculatedSpeed = positionDifference / timeToDestination;  	}  	else {  		// If the desired move time is instantaneous' use the max allowed servo speed.  		calculatedSpeed = servo.speedLimitMax;  	}  	// Convert speed from (1 μs / second) to (0.25 μs / 10 ms)' used by the hardware.  	servoSpeed = (ushort)(calculatedSpeed * (4.0 / 100.0));  }  
Magic Number,CountessQuantaControl,ServoManager,C:\repos\PSU-Robotics-Countess-Quanta_Countess-Quanta-Control\Src\CountessQuantaControl\ServoManager.cs,StartTimedMove,The following statement contains a magic number: if (servo.polledPosition == 0) {  	// If the servo position is 0' then the servo is off and we have no information about its actual position.  	// We don't know the actual move distance' so just use the default servo speed.  	servoSpeed = (ushort)servo.defaultSpeed;  }  else {  	// Convert current position to μs (the hardware uses 0.25 μs increments).  	double currentPosition = ((double)servo.polledPosition) / 4;  	// Position difference in μs.  	double positionDifference = Math.Abs (servoPosition.position - currentPosition);  	// Required speed in (μs/second).  	double calculatedSpeed;  	if (timeToDestination != 0) {  		calculatedSpeed = positionDifference / timeToDestination;  	}  	else {  		// If the desired move time is instantaneous' use the max allowed servo speed.  		calculatedSpeed = servo.speedLimitMax;  	}  	// Convert speed from (1 μs / second) to (0.25 μs / 10 ms)' used by the hardware.  	servoSpeed = (ushort)(calculatedSpeed * (4.0 / 100.0));  }  
Magic Number,CountessQuantaControl,ServoManager,C:\repos\PSU-Robotics-Countess-Quanta_Countess-Quanta-Control\Src\CountessQuantaControl\ServoManager.cs,StartTimedMove,The following statement contains a magic number: servoSpeed = (ushort)(calculatedSpeed * (4.0 / 100.0));  
Magic Number,CountessQuantaControl,ServoManager,C:\repos\PSU-Robotics-Countess-Quanta_Countess-Quanta-Control\Src\CountessQuantaControl\ServoManager.cs,StartTimedMove,The following statement contains a magic number: servoSpeed = (ushort)(calculatedSpeed * (4.0 / 100.0));  
Magic Number,CountessQuantaControl,ServoManager,C:\repos\PSU-Robotics-Countess-Quanta_Countess-Quanta-Control\Src\CountessQuantaControl\ServoManager.cs,MoveServos,The following statement contains a magic number: if (!IsConnected ()) {  	// Simulate the move.  	Thread.Sleep ((int)(timeToDestination * 1000));  	foreach (ServoPosition servoPosition in servoPositionList) {  		Servo servo = servoList.Find (x => x.index == servoPosition.index);  		lock (servo.movePriorityLock) {  			ErrorLogging.AddMessage (ErrorLogging.LoggingLevel.Debug' "MoveServos cleared isRunningHighPriorityMove for servo " + servo.index.ToString () + ".");  			servo.isRunningHighPriorityMove = false;  		}  	}  	return;  }  
Magic Number,CountessQuantaControl,ServoManager,C:\repos\PSU-Robotics-Countess-Quanta_Countess-Quanta-Control\Src\CountessQuantaControl\ServoManager.cs,MoveServos,The following statement contains a magic number: Thread.Sleep ((int)(timeToDestination * 1000));  
Magic Number,CountessQuantaControl,KinectManager,C:\repos\PSU-Robotics-Countess-Quanta_Countess-Quanta-Control\Src\CountessQuantaControl\KinectManager.cs,InitializeKinect,The following statement contains a magic number: if (null != ri) {  	this.speechEngine = new SpeechRecognitionEngine (ri.Id);  	/****************************************************************                 *                  * Use this code to create grammar programmatically rather than from                 * a grammar file.                 *                  * var directions = new Choices();                 * directions.Add(new SemanticResultValue("forward"' "FORWARD"));                 * directions.Add(new SemanticResultValue("forwards"' "FORWARD"));                 * directions.Add(new SemanticResultValue("straight"' "FORWARD"));                 * directions.Add(new SemanticResultValue("backward"' "BACKWARD"));                 * directions.Add(new SemanticResultValue("backwards"' "BACKWARD"));                 * directions.Add(new SemanticResultValue("back"' "BACKWARD"));                 * directions.Add(new SemanticResultValue("turn left"' "LEFT"));                 * directions.Add(new SemanticResultValue("turn right"' "RIGHT"));                 *                 * var gb = new GrammarBuilder { Culture = ri.Culture };                 * gb.Append(directions);                 *                 * var g = new Grammar(gb);                 *                  ****************************************************************/// Create a grammar from grammar definition XML file.  	using (var memoryStream = new MemoryStream (Encoding.ASCII.GetBytes (Properties.Resources.SpeechGrammar))) {  		var g = new Grammar (memoryStream);  		speechEngine.LoadGrammar (g);  	}  	speechEngine.SpeechRecognized += SpeechRecognized;  	speechEngine.SpeechRecognitionRejected += SpeechRejected;  	robotSpeech.SpeakStarted += SpeakStarted;  	robotSpeech.SpeakCompleted += SpeakCompleted;  	// For long recognition sessions (a few hours or more)' it may be beneficial to turn off adaptation of the acoustic model.   	// This will prevent recognition accuracy from degrading over time.  	////speechEngine.UpdateRecognizerSetting("AdaptationOn"' 0);  	speechEngine.SetInputToAudioStream (sensor.AudioSource.Start ()' new SpeechAudioFormatInfo (EncodingFormat.Pcm' 16000' 16' 1' 32000' 2' null));  	speechEngine.RecognizeAsync (RecognizeMode.Multiple);  }  else {  	ErrorLogging.AddMessage (ErrorLogging.LoggingLevel.Error' "InitializeKinect() failed' no speech recognizer.");  }  
Magic Number,CountessQuantaControl,KinectManager,C:\repos\PSU-Robotics-Countess-Quanta_Countess-Quanta-Control\Src\CountessQuantaControl\KinectManager.cs,InitializeKinect,The following statement contains a magic number: if (null != ri) {  	this.speechEngine = new SpeechRecognitionEngine (ri.Id);  	/****************************************************************                 *                  * Use this code to create grammar programmatically rather than from                 * a grammar file.                 *                  * var directions = new Choices();                 * directions.Add(new SemanticResultValue("forward"' "FORWARD"));                 * directions.Add(new SemanticResultValue("forwards"' "FORWARD"));                 * directions.Add(new SemanticResultValue("straight"' "FORWARD"));                 * directions.Add(new SemanticResultValue("backward"' "BACKWARD"));                 * directions.Add(new SemanticResultValue("backwards"' "BACKWARD"));                 * directions.Add(new SemanticResultValue("back"' "BACKWARD"));                 * directions.Add(new SemanticResultValue("turn left"' "LEFT"));                 * directions.Add(new SemanticResultValue("turn right"' "RIGHT"));                 *                 * var gb = new GrammarBuilder { Culture = ri.Culture };                 * gb.Append(directions);                 *                 * var g = new Grammar(gb);                 *                  ****************************************************************/// Create a grammar from grammar definition XML file.  	using (var memoryStream = new MemoryStream (Encoding.ASCII.GetBytes (Properties.Resources.SpeechGrammar))) {  		var g = new Grammar (memoryStream);  		speechEngine.LoadGrammar (g);  	}  	speechEngine.SpeechRecognized += SpeechRecognized;  	speechEngine.SpeechRecognitionRejected += SpeechRejected;  	robotSpeech.SpeakStarted += SpeakStarted;  	robotSpeech.SpeakCompleted += SpeakCompleted;  	// For long recognition sessions (a few hours or more)' it may be beneficial to turn off adaptation of the acoustic model.   	// This will prevent recognition accuracy from degrading over time.  	////speechEngine.UpdateRecognizerSetting("AdaptationOn"' 0);  	speechEngine.SetInputToAudioStream (sensor.AudioSource.Start ()' new SpeechAudioFormatInfo (EncodingFormat.Pcm' 16000' 16' 1' 32000' 2' null));  	speechEngine.RecognizeAsync (RecognizeMode.Multiple);  }  else {  	ErrorLogging.AddMessage (ErrorLogging.LoggingLevel.Error' "InitializeKinect() failed' no speech recognizer.");  }  
Magic Number,CountessQuantaControl,KinectManager,C:\repos\PSU-Robotics-Countess-Quanta_Countess-Quanta-Control\Src\CountessQuantaControl\KinectManager.cs,InitializeKinect,The following statement contains a magic number: if (null != ri) {  	this.speechEngine = new SpeechRecognitionEngine (ri.Id);  	/****************************************************************                 *                  * Use this code to create grammar programmatically rather than from                 * a grammar file.                 *                  * var directions = new Choices();                 * directions.Add(new SemanticResultValue("forward"' "FORWARD"));                 * directions.Add(new SemanticResultValue("forwards"' "FORWARD"));                 * directions.Add(new SemanticResultValue("straight"' "FORWARD"));                 * directions.Add(new SemanticResultValue("backward"' "BACKWARD"));                 * directions.Add(new SemanticResultValue("backwards"' "BACKWARD"));                 * directions.Add(new SemanticResultValue("back"' "BACKWARD"));                 * directions.Add(new SemanticResultValue("turn left"' "LEFT"));                 * directions.Add(new SemanticResultValue("turn right"' "RIGHT"));                 *                 * var gb = new GrammarBuilder { Culture = ri.Culture };                 * gb.Append(directions);                 *                 * var g = new Grammar(gb);                 *                  ****************************************************************/// Create a grammar from grammar definition XML file.  	using (var memoryStream = new MemoryStream (Encoding.ASCII.GetBytes (Properties.Resources.SpeechGrammar))) {  		var g = new Grammar (memoryStream);  		speechEngine.LoadGrammar (g);  	}  	speechEngine.SpeechRecognized += SpeechRecognized;  	speechEngine.SpeechRecognitionRejected += SpeechRejected;  	robotSpeech.SpeakStarted += SpeakStarted;  	robotSpeech.SpeakCompleted += SpeakCompleted;  	// For long recognition sessions (a few hours or more)' it may be beneficial to turn off adaptation of the acoustic model.   	// This will prevent recognition accuracy from degrading over time.  	////speechEngine.UpdateRecognizerSetting("AdaptationOn"' 0);  	speechEngine.SetInputToAudioStream (sensor.AudioSource.Start ()' new SpeechAudioFormatInfo (EncodingFormat.Pcm' 16000' 16' 1' 32000' 2' null));  	speechEngine.RecognizeAsync (RecognizeMode.Multiple);  }  else {  	ErrorLogging.AddMessage (ErrorLogging.LoggingLevel.Error' "InitializeKinect() failed' no speech recognizer.");  }  
Magic Number,CountessQuantaControl,KinectManager,C:\repos\PSU-Robotics-Countess-Quanta_Countess-Quanta-Control\Src\CountessQuantaControl\KinectManager.cs,InitializeKinect,The following statement contains a magic number: if (null != ri) {  	this.speechEngine = new SpeechRecognitionEngine (ri.Id);  	/****************************************************************                 *                  * Use this code to create grammar programmatically rather than from                 * a grammar file.                 *                  * var directions = new Choices();                 * directions.Add(new SemanticResultValue("forward"' "FORWARD"));                 * directions.Add(new SemanticResultValue("forwards"' "FORWARD"));                 * directions.Add(new SemanticResultValue("straight"' "FORWARD"));                 * directions.Add(new SemanticResultValue("backward"' "BACKWARD"));                 * directions.Add(new SemanticResultValue("backwards"' "BACKWARD"));                 * directions.Add(new SemanticResultValue("back"' "BACKWARD"));                 * directions.Add(new SemanticResultValue("turn left"' "LEFT"));                 * directions.Add(new SemanticResultValue("turn right"' "RIGHT"));                 *                 * var gb = new GrammarBuilder { Culture = ri.Culture };                 * gb.Append(directions);                 *                 * var g = new Grammar(gb);                 *                  ****************************************************************/// Create a grammar from grammar definition XML file.  	using (var memoryStream = new MemoryStream (Encoding.ASCII.GetBytes (Properties.Resources.SpeechGrammar))) {  		var g = new Grammar (memoryStream);  		speechEngine.LoadGrammar (g);  	}  	speechEngine.SpeechRecognized += SpeechRecognized;  	speechEngine.SpeechRecognitionRejected += SpeechRejected;  	robotSpeech.SpeakStarted += SpeakStarted;  	robotSpeech.SpeakCompleted += SpeakCompleted;  	// For long recognition sessions (a few hours or more)' it may be beneficial to turn off adaptation of the acoustic model.   	// This will prevent recognition accuracy from degrading over time.  	////speechEngine.UpdateRecognizerSetting("AdaptationOn"' 0);  	speechEngine.SetInputToAudioStream (sensor.AudioSource.Start ()' new SpeechAudioFormatInfo (EncodingFormat.Pcm' 16000' 16' 1' 32000' 2' null));  	speechEngine.RecognizeAsync (RecognizeMode.Multiple);  }  else {  	ErrorLogging.AddMessage (ErrorLogging.LoggingLevel.Error' "InitializeKinect() failed' no speech recognizer.");  }  
Magic Number,CountessQuantaControl,KinectManager,C:\repos\PSU-Robotics-Countess-Quanta_Countess-Quanta-Control\Src\CountessQuantaControl\KinectManager.cs,InitializeKinect,The following statement contains a magic number: speechEngine.SetInputToAudioStream (sensor.AudioSource.Start ()' new SpeechAudioFormatInfo (EncodingFormat.Pcm' 16000' 16' 1' 32000' 2' null));  
Magic Number,CountessQuantaControl,KinectManager,C:\repos\PSU-Robotics-Countess-Quanta_Countess-Quanta-Control\Src\CountessQuantaControl\KinectManager.cs,InitializeKinect,The following statement contains a magic number: speechEngine.SetInputToAudioStream (sensor.AudioSource.Start ()' new SpeechAudioFormatInfo (EncodingFormat.Pcm' 16000' 16' 1' 32000' 2' null));  
Magic Number,CountessQuantaControl,KinectManager,C:\repos\PSU-Robotics-Countess-Quanta_Countess-Quanta-Control\Src\CountessQuantaControl\KinectManager.cs,InitializeKinect,The following statement contains a magic number: speechEngine.SetInputToAudioStream (sensor.AudioSource.Start ()' new SpeechAudioFormatInfo (EncodingFormat.Pcm' 16000' 16' 1' 32000' 2' null));  
Magic Number,CountessQuantaControl,KinectManager,C:\repos\PSU-Robotics-Countess-Quanta_Countess-Quanta-Control\Src\CountessQuantaControl\KinectManager.cs,InitializeKinect,The following statement contains a magic number: speechEngine.SetInputToAudioStream (sensor.AudioSource.Start ()' new SpeechAudioFormatInfo (EncodingFormat.Pcm' 16000' 16' 1' 32000' 2' null));  
Magic Number,CountessQuantaControl,KinectManager,C:\repos\PSU-Robotics-Countess-Quanta_Countess-Quanta-Control\Src\CountessQuantaControl\KinectManager.cs,SpeechRecognized,The following statement contains a magic number: if (e.Result.Confidence >= ConfidenceThreshold) {  	string sequenceName = "";  	// Perform the specified Sequence depending on the recognized speech.  	switch (e.Result.Semantics.Value.ToString ()) {  	case "Hello":  		sequenceName = "Hello";  		break;  	case "HowAreUDoing":  		sequenceName = "HowAreUDoing";  		break;  	case "Introduce":  		sequenceName = "Introduce";  		break;  	case "Number":  		sequenceName = "Number";  		break;  	case "DoWhat":  		sequenceName = "DoWhat";  		break;  	case "Thanks":  		sequenceName = "Thanks";  		break;  	case "Count":  		sequenceName = "Count";  		break;  	case "OneAndTwo":  		sequenceName = "OneAndTwo";  		break;  	case "FiveMinusOne":  		sequenceName = "FiveMinusOne";  		break;  	case "Gesture":  		sequenceName = "Gesture";  		break;  	case "NextOne":  		sequenceName = "NextOne";  		break;  	case "NextTwo":  		sequenceName = "NextTwo";  		break;  	case "NextThree":  		sequenceName = "NextThree";  		break;  	case "PlayHarp":  		sequenceName = "PlayHarp";  		break;  	case "PLAYMUSIC":  		sequenceName = "PLAYMUSIC";  		break;  	case "lab":  		sequenceName = "lab";  		break;  	case "GoAhead":  		sequenceName = "GoAhead";  		break;  	case "NAME":  		sequenceName = "NAME";  		break;  	case "Bye":  		sequenceName = "Bye";  		break;  	case "GoodMorning":  		sequenceName = "GoodMorning";  		break;  	case "URwelcome":  		sequenceName = "URwelcome";  		break;  	case "GladSU":  		sequenceName = "GladSU";  		break;  	case "DEFAULT":  		sequenceName = "DEFAULT";  		break;  	}  	if (sequenceName != "") {  		sequenceProcessor.RunSequence (sequenceName);  	}  }  else {  	// If speech is not recognized' then use a random default response.  	Random randomGenerator = new Random ();  	int randomSequenceNumber = randomGenerator.Next (1' 5);  	string sequenceName = "DEFAULT" + randomSequenceNumber.ToString ();  	if (sequenceName != "") {  		sequenceProcessor.RunSequence (sequenceName);  	}  }  
Magic Number,CountessQuantaControl,KinectManager,C:\repos\PSU-Robotics-Countess-Quanta_Countess-Quanta-Control\Src\CountessQuantaControl\KinectManager.cs,SensorSkeletonFrameReady,The following statement contains a magic number: if (skeletons.Length != 0) {  	bool isTrackingSameSkeleton = false;  	int skeletonIdClosestToCenter = 0;  	float shortestDistanceFromCenter = 0;  	// First' check if this skeleton frame contains the skeleton that we were already tracking.  	foreach (Skeleton skel in skeletons) {  		if (skel.TrackingState == SkeletonTrackingState.Tracked) {  			if (skel.TrackingId == trackedSkeletonId) {  				isTrackingSameSkeleton = true;  				break;  			}  			else if (skeletonIdClosestToCenter == 0 || Math.Abs (skel.Joints [JointType.ShoulderCenter].Position.X) < shortestDistanceFromCenter) {  				skeletonIdClosestToCenter = skel.TrackingId;  				shortestDistanceFromCenter = Math.Abs (skel.Joints [JointType.ShoulderCenter].Position.X);  			}  		}  	}  	// If the skeleton frame does not contain the one we were tracking' then track the skeleton that is closest to the center of the image (x-axis).  	if (!isTrackingSameSkeleton) {  		trackedSkeletonId = skeletonIdClosestToCenter;  		ErrorLogging.AddMessage (ErrorLogging.LoggingLevel.Debug' "SensorSkeletonFrameReady() now tracking skeleton ID " + trackedSkeletonId.ToString () + ".");  	}  	// Update person tracking and check gestures from the tracked skeleton.  	foreach (Skeleton skel in skeletons) {  		// Only pay attention to the tracked skeleton.  		if (skel.TrackingId == trackedSkeletonId) {  			// Only pay attention to the skeleton if it is within the right and left edges of the view.  			// This should help prevent detecting false gestures' due to the skeleton being scrambled as it leaves the viewing area.  			if ((skel.ClippedEdges & FrameEdges.Left) == 0 && (skel.ClippedEdges & FrameEdges.Right) == 0) {  				personTracking.UpdatePosition (skel.Joints [JointType.ShoulderCenter].Position);  				if (gestureRecognitionEnabled) {  					// Check gesture recognition conditions.  					//leftHandGesture.Evaluate(sequenceProcessor' skel.Joints[JointType.HandLeft].Position.Y > skel.Joints[JointType.ElbowLeft].Position.Y' "Left Hand Raised");  					//rightHandGesture.Evaluate(sequenceProcessor' skel.Joints[JointType.HandRight].Position.Y > skel.Joints[JointType.ElbowRight].Position.Y' "Right Hand Raised");  					RightHandAboveHead.Evaluate (sequenceProcessor' skel.Joints [JointType.HandRight].Position.Y > skel.Joints [JointType.Head].Position.Y' "Hello");  					RightHandBetweenSpineAndShoulderCenter.Evaluate (sequenceProcessor' skel.Joints [JointType.HandRight].Position.Y > skel.Joints [JointType.Spine].Position.Y && skel.Joints [JointType.HandRight].Position.Y < skel.Joints [JointType.ShoulderCenter].Position.Y && skel.Joints [JointType.HandRight].Position.X < (skel.Joints [JointType.Spine].Position.X + 0.1)' "PLAYMUSIC");  					LeftElbowAboveLeftShoulder.Evaluate (sequenceProcessor' skel.Joints [JointType.ElbowLeft].Position.Y > skel.Joints [JointType.ShoulderLeft].Position.Y' "NeckRotate");  					WalkCloseToKinect.Evaluate (sequenceProcessor' skel.Joints [JointType.Spine].Position.Z < 1.5' "ArmRaise");  					// [Add new Evaluate calls here]  				}  			}  			else {  				ErrorLogging.AddMessage (ErrorLogging.LoggingLevel.Debug' "SensorSkeletonFrameReady() skipped update due to skeleton being outside of view.");  			}  			break;  		}  	}  }  
Magic Number,CountessQuantaControl,KinectManager,C:\repos\PSU-Robotics-Countess-Quanta_Countess-Quanta-Control\Src\CountessQuantaControl\KinectManager.cs,SensorSkeletonFrameReady,The following statement contains a magic number: if (skeletons.Length != 0) {  	bool isTrackingSameSkeleton = false;  	int skeletonIdClosestToCenter = 0;  	float shortestDistanceFromCenter = 0;  	// First' check if this skeleton frame contains the skeleton that we were already tracking.  	foreach (Skeleton skel in skeletons) {  		if (skel.TrackingState == SkeletonTrackingState.Tracked) {  			if (skel.TrackingId == trackedSkeletonId) {  				isTrackingSameSkeleton = true;  				break;  			}  			else if (skeletonIdClosestToCenter == 0 || Math.Abs (skel.Joints [JointType.ShoulderCenter].Position.X) < shortestDistanceFromCenter) {  				skeletonIdClosestToCenter = skel.TrackingId;  				shortestDistanceFromCenter = Math.Abs (skel.Joints [JointType.ShoulderCenter].Position.X);  			}  		}  	}  	// If the skeleton frame does not contain the one we were tracking' then track the skeleton that is closest to the center of the image (x-axis).  	if (!isTrackingSameSkeleton) {  		trackedSkeletonId = skeletonIdClosestToCenter;  		ErrorLogging.AddMessage (ErrorLogging.LoggingLevel.Debug' "SensorSkeletonFrameReady() now tracking skeleton ID " + trackedSkeletonId.ToString () + ".");  	}  	// Update person tracking and check gestures from the tracked skeleton.  	foreach (Skeleton skel in skeletons) {  		// Only pay attention to the tracked skeleton.  		if (skel.TrackingId == trackedSkeletonId) {  			// Only pay attention to the skeleton if it is within the right and left edges of the view.  			// This should help prevent detecting false gestures' due to the skeleton being scrambled as it leaves the viewing area.  			if ((skel.ClippedEdges & FrameEdges.Left) == 0 && (skel.ClippedEdges & FrameEdges.Right) == 0) {  				personTracking.UpdatePosition (skel.Joints [JointType.ShoulderCenter].Position);  				if (gestureRecognitionEnabled) {  					// Check gesture recognition conditions.  					//leftHandGesture.Evaluate(sequenceProcessor' skel.Joints[JointType.HandLeft].Position.Y > skel.Joints[JointType.ElbowLeft].Position.Y' "Left Hand Raised");  					//rightHandGesture.Evaluate(sequenceProcessor' skel.Joints[JointType.HandRight].Position.Y > skel.Joints[JointType.ElbowRight].Position.Y' "Right Hand Raised");  					RightHandAboveHead.Evaluate (sequenceProcessor' skel.Joints [JointType.HandRight].Position.Y > skel.Joints [JointType.Head].Position.Y' "Hello");  					RightHandBetweenSpineAndShoulderCenter.Evaluate (sequenceProcessor' skel.Joints [JointType.HandRight].Position.Y > skel.Joints [JointType.Spine].Position.Y && skel.Joints [JointType.HandRight].Position.Y < skel.Joints [JointType.ShoulderCenter].Position.Y && skel.Joints [JointType.HandRight].Position.X < (skel.Joints [JointType.Spine].Position.X + 0.1)' "PLAYMUSIC");  					LeftElbowAboveLeftShoulder.Evaluate (sequenceProcessor' skel.Joints [JointType.ElbowLeft].Position.Y > skel.Joints [JointType.ShoulderLeft].Position.Y' "NeckRotate");  					WalkCloseToKinect.Evaluate (sequenceProcessor' skel.Joints [JointType.Spine].Position.Z < 1.5' "ArmRaise");  					// [Add new Evaluate calls here]  				}  			}  			else {  				ErrorLogging.AddMessage (ErrorLogging.LoggingLevel.Debug' "SensorSkeletonFrameReady() skipped update due to skeleton being outside of view.");  			}  			break;  		}  	}  }  
Magic Number,CountessQuantaControl,KinectManager,C:\repos\PSU-Robotics-Countess-Quanta_Countess-Quanta-Control\Src\CountessQuantaControl\KinectManager.cs,SensorSkeletonFrameReady,The following statement contains a magic number: foreach (Skeleton skel in skeletons) {  	// Only pay attention to the tracked skeleton.  	if (skel.TrackingId == trackedSkeletonId) {  		// Only pay attention to the skeleton if it is within the right and left edges of the view.  		// This should help prevent detecting false gestures' due to the skeleton being scrambled as it leaves the viewing area.  		if ((skel.ClippedEdges & FrameEdges.Left) == 0 && (skel.ClippedEdges & FrameEdges.Right) == 0) {  			personTracking.UpdatePosition (skel.Joints [JointType.ShoulderCenter].Position);  			if (gestureRecognitionEnabled) {  				// Check gesture recognition conditions.  				//leftHandGesture.Evaluate(sequenceProcessor' skel.Joints[JointType.HandLeft].Position.Y > skel.Joints[JointType.ElbowLeft].Position.Y' "Left Hand Raised");  				//rightHandGesture.Evaluate(sequenceProcessor' skel.Joints[JointType.HandRight].Position.Y > skel.Joints[JointType.ElbowRight].Position.Y' "Right Hand Raised");  				RightHandAboveHead.Evaluate (sequenceProcessor' skel.Joints [JointType.HandRight].Position.Y > skel.Joints [JointType.Head].Position.Y' "Hello");  				RightHandBetweenSpineAndShoulderCenter.Evaluate (sequenceProcessor' skel.Joints [JointType.HandRight].Position.Y > skel.Joints [JointType.Spine].Position.Y && skel.Joints [JointType.HandRight].Position.Y < skel.Joints [JointType.ShoulderCenter].Position.Y && skel.Joints [JointType.HandRight].Position.X < (skel.Joints [JointType.Spine].Position.X + 0.1)' "PLAYMUSIC");  				LeftElbowAboveLeftShoulder.Evaluate (sequenceProcessor' skel.Joints [JointType.ElbowLeft].Position.Y > skel.Joints [JointType.ShoulderLeft].Position.Y' "NeckRotate");  				WalkCloseToKinect.Evaluate (sequenceProcessor' skel.Joints [JointType.Spine].Position.Z < 1.5' "ArmRaise");  				// [Add new Evaluate calls here]  			}  		}  		else {  			ErrorLogging.AddMessage (ErrorLogging.LoggingLevel.Debug' "SensorSkeletonFrameReady() skipped update due to skeleton being outside of view.");  		}  		break;  	}  }  
Magic Number,CountessQuantaControl,KinectManager,C:\repos\PSU-Robotics-Countess-Quanta_Countess-Quanta-Control\Src\CountessQuantaControl\KinectManager.cs,SensorSkeletonFrameReady,The following statement contains a magic number: foreach (Skeleton skel in skeletons) {  	// Only pay attention to the tracked skeleton.  	if (skel.TrackingId == trackedSkeletonId) {  		// Only pay attention to the skeleton if it is within the right and left edges of the view.  		// This should help prevent detecting false gestures' due to the skeleton being scrambled as it leaves the viewing area.  		if ((skel.ClippedEdges & FrameEdges.Left) == 0 && (skel.ClippedEdges & FrameEdges.Right) == 0) {  			personTracking.UpdatePosition (skel.Joints [JointType.ShoulderCenter].Position);  			if (gestureRecognitionEnabled) {  				// Check gesture recognition conditions.  				//leftHandGesture.Evaluate(sequenceProcessor' skel.Joints[JointType.HandLeft].Position.Y > skel.Joints[JointType.ElbowLeft].Position.Y' "Left Hand Raised");  				//rightHandGesture.Evaluate(sequenceProcessor' skel.Joints[JointType.HandRight].Position.Y > skel.Joints[JointType.ElbowRight].Position.Y' "Right Hand Raised");  				RightHandAboveHead.Evaluate (sequenceProcessor' skel.Joints [JointType.HandRight].Position.Y > skel.Joints [JointType.Head].Position.Y' "Hello");  				RightHandBetweenSpineAndShoulderCenter.Evaluate (sequenceProcessor' skel.Joints [JointType.HandRight].Position.Y > skel.Joints [JointType.Spine].Position.Y && skel.Joints [JointType.HandRight].Position.Y < skel.Joints [JointType.ShoulderCenter].Position.Y && skel.Joints [JointType.HandRight].Position.X < (skel.Joints [JointType.Spine].Position.X + 0.1)' "PLAYMUSIC");  				LeftElbowAboveLeftShoulder.Evaluate (sequenceProcessor' skel.Joints [JointType.ElbowLeft].Position.Y > skel.Joints [JointType.ShoulderLeft].Position.Y' "NeckRotate");  				WalkCloseToKinect.Evaluate (sequenceProcessor' skel.Joints [JointType.Spine].Position.Z < 1.5' "ArmRaise");  				// [Add new Evaluate calls here]  			}  		}  		else {  			ErrorLogging.AddMessage (ErrorLogging.LoggingLevel.Debug' "SensorSkeletonFrameReady() skipped update due to skeleton being outside of view.");  		}  		break;  	}  }  
Magic Number,CountessQuantaControl,KinectManager,C:\repos\PSU-Robotics-Countess-Quanta_Countess-Quanta-Control\Src\CountessQuantaControl\KinectManager.cs,SensorSkeletonFrameReady,The following statement contains a magic number: if (skel.TrackingId == trackedSkeletonId) {  	// Only pay attention to the skeleton if it is within the right and left edges of the view.  	// This should help prevent detecting false gestures' due to the skeleton being scrambled as it leaves the viewing area.  	if ((skel.ClippedEdges & FrameEdges.Left) == 0 && (skel.ClippedEdges & FrameEdges.Right) == 0) {  		personTracking.UpdatePosition (skel.Joints [JointType.ShoulderCenter].Position);  		if (gestureRecognitionEnabled) {  			// Check gesture recognition conditions.  			//leftHandGesture.Evaluate(sequenceProcessor' skel.Joints[JointType.HandLeft].Position.Y > skel.Joints[JointType.ElbowLeft].Position.Y' "Left Hand Raised");  			//rightHandGesture.Evaluate(sequenceProcessor' skel.Joints[JointType.HandRight].Position.Y > skel.Joints[JointType.ElbowRight].Position.Y' "Right Hand Raised");  			RightHandAboveHead.Evaluate (sequenceProcessor' skel.Joints [JointType.HandRight].Position.Y > skel.Joints [JointType.Head].Position.Y' "Hello");  			RightHandBetweenSpineAndShoulderCenter.Evaluate (sequenceProcessor' skel.Joints [JointType.HandRight].Position.Y > skel.Joints [JointType.Spine].Position.Y && skel.Joints [JointType.HandRight].Position.Y < skel.Joints [JointType.ShoulderCenter].Position.Y && skel.Joints [JointType.HandRight].Position.X < (skel.Joints [JointType.Spine].Position.X + 0.1)' "PLAYMUSIC");  			LeftElbowAboveLeftShoulder.Evaluate (sequenceProcessor' skel.Joints [JointType.ElbowLeft].Position.Y > skel.Joints [JointType.ShoulderLeft].Position.Y' "NeckRotate");  			WalkCloseToKinect.Evaluate (sequenceProcessor' skel.Joints [JointType.Spine].Position.Z < 1.5' "ArmRaise");  			// [Add new Evaluate calls here]  		}  	}  	else {  		ErrorLogging.AddMessage (ErrorLogging.LoggingLevel.Debug' "SensorSkeletonFrameReady() skipped update due to skeleton being outside of view.");  	}  	break;  }  
Magic Number,CountessQuantaControl,KinectManager,C:\repos\PSU-Robotics-Countess-Quanta_Countess-Quanta-Control\Src\CountessQuantaControl\KinectManager.cs,SensorSkeletonFrameReady,The following statement contains a magic number: if (skel.TrackingId == trackedSkeletonId) {  	// Only pay attention to the skeleton if it is within the right and left edges of the view.  	// This should help prevent detecting false gestures' due to the skeleton being scrambled as it leaves the viewing area.  	if ((skel.ClippedEdges & FrameEdges.Left) == 0 && (skel.ClippedEdges & FrameEdges.Right) == 0) {  		personTracking.UpdatePosition (skel.Joints [JointType.ShoulderCenter].Position);  		if (gestureRecognitionEnabled) {  			// Check gesture recognition conditions.  			//leftHandGesture.Evaluate(sequenceProcessor' skel.Joints[JointType.HandLeft].Position.Y > skel.Joints[JointType.ElbowLeft].Position.Y' "Left Hand Raised");  			//rightHandGesture.Evaluate(sequenceProcessor' skel.Joints[JointType.HandRight].Position.Y > skel.Joints[JointType.ElbowRight].Position.Y' "Right Hand Raised");  			RightHandAboveHead.Evaluate (sequenceProcessor' skel.Joints [JointType.HandRight].Position.Y > skel.Joints [JointType.Head].Position.Y' "Hello");  			RightHandBetweenSpineAndShoulderCenter.Evaluate (sequenceProcessor' skel.Joints [JointType.HandRight].Position.Y > skel.Joints [JointType.Spine].Position.Y && skel.Joints [JointType.HandRight].Position.Y < skel.Joints [JointType.ShoulderCenter].Position.Y && skel.Joints [JointType.HandRight].Position.X < (skel.Joints [JointType.Spine].Position.X + 0.1)' "PLAYMUSIC");  			LeftElbowAboveLeftShoulder.Evaluate (sequenceProcessor' skel.Joints [JointType.ElbowLeft].Position.Y > skel.Joints [JointType.ShoulderLeft].Position.Y' "NeckRotate");  			WalkCloseToKinect.Evaluate (sequenceProcessor' skel.Joints [JointType.Spine].Position.Z < 1.5' "ArmRaise");  			// [Add new Evaluate calls here]  		}  	}  	else {  		ErrorLogging.AddMessage (ErrorLogging.LoggingLevel.Debug' "SensorSkeletonFrameReady() skipped update due to skeleton being outside of view.");  	}  	break;  }  
Magic Number,CountessQuantaControl,KinectManager,C:\repos\PSU-Robotics-Countess-Quanta_Countess-Quanta-Control\Src\CountessQuantaControl\KinectManager.cs,SensorSkeletonFrameReady,The following statement contains a magic number: if ((skel.ClippedEdges & FrameEdges.Left) == 0 && (skel.ClippedEdges & FrameEdges.Right) == 0) {  	personTracking.UpdatePosition (skel.Joints [JointType.ShoulderCenter].Position);  	if (gestureRecognitionEnabled) {  		// Check gesture recognition conditions.  		//leftHandGesture.Evaluate(sequenceProcessor' skel.Joints[JointType.HandLeft].Position.Y > skel.Joints[JointType.ElbowLeft].Position.Y' "Left Hand Raised");  		//rightHandGesture.Evaluate(sequenceProcessor' skel.Joints[JointType.HandRight].Position.Y > skel.Joints[JointType.ElbowRight].Position.Y' "Right Hand Raised");  		RightHandAboveHead.Evaluate (sequenceProcessor' skel.Joints [JointType.HandRight].Position.Y > skel.Joints [JointType.Head].Position.Y' "Hello");  		RightHandBetweenSpineAndShoulderCenter.Evaluate (sequenceProcessor' skel.Joints [JointType.HandRight].Position.Y > skel.Joints [JointType.Spine].Position.Y && skel.Joints [JointType.HandRight].Position.Y < skel.Joints [JointType.ShoulderCenter].Position.Y && skel.Joints [JointType.HandRight].Position.X < (skel.Joints [JointType.Spine].Position.X + 0.1)' "PLAYMUSIC");  		LeftElbowAboveLeftShoulder.Evaluate (sequenceProcessor' skel.Joints [JointType.ElbowLeft].Position.Y > skel.Joints [JointType.ShoulderLeft].Position.Y' "NeckRotate");  		WalkCloseToKinect.Evaluate (sequenceProcessor' skel.Joints [JointType.Spine].Position.Z < 1.5' "ArmRaise");  		// [Add new Evaluate calls here]  	}  }  else {  	ErrorLogging.AddMessage (ErrorLogging.LoggingLevel.Debug' "SensorSkeletonFrameReady() skipped update due to skeleton being outside of view.");  }  
Magic Number,CountessQuantaControl,KinectManager,C:\repos\PSU-Robotics-Countess-Quanta_Countess-Quanta-Control\Src\CountessQuantaControl\KinectManager.cs,SensorSkeletonFrameReady,The following statement contains a magic number: if ((skel.ClippedEdges & FrameEdges.Left) == 0 && (skel.ClippedEdges & FrameEdges.Right) == 0) {  	personTracking.UpdatePosition (skel.Joints [JointType.ShoulderCenter].Position);  	if (gestureRecognitionEnabled) {  		// Check gesture recognition conditions.  		//leftHandGesture.Evaluate(sequenceProcessor' skel.Joints[JointType.HandLeft].Position.Y > skel.Joints[JointType.ElbowLeft].Position.Y' "Left Hand Raised");  		//rightHandGesture.Evaluate(sequenceProcessor' skel.Joints[JointType.HandRight].Position.Y > skel.Joints[JointType.ElbowRight].Position.Y' "Right Hand Raised");  		RightHandAboveHead.Evaluate (sequenceProcessor' skel.Joints [JointType.HandRight].Position.Y > skel.Joints [JointType.Head].Position.Y' "Hello");  		RightHandBetweenSpineAndShoulderCenter.Evaluate (sequenceProcessor' skel.Joints [JointType.HandRight].Position.Y > skel.Joints [JointType.Spine].Position.Y && skel.Joints [JointType.HandRight].Position.Y < skel.Joints [JointType.ShoulderCenter].Position.Y && skel.Joints [JointType.HandRight].Position.X < (skel.Joints [JointType.Spine].Position.X + 0.1)' "PLAYMUSIC");  		LeftElbowAboveLeftShoulder.Evaluate (sequenceProcessor' skel.Joints [JointType.ElbowLeft].Position.Y > skel.Joints [JointType.ShoulderLeft].Position.Y' "NeckRotate");  		WalkCloseToKinect.Evaluate (sequenceProcessor' skel.Joints [JointType.Spine].Position.Z < 1.5' "ArmRaise");  		// [Add new Evaluate calls here]  	}  }  else {  	ErrorLogging.AddMessage (ErrorLogging.LoggingLevel.Debug' "SensorSkeletonFrameReady() skipped update due to skeleton being outside of view.");  }  
Magic Number,CountessQuantaControl,KinectManager,C:\repos\PSU-Robotics-Countess-Quanta_Countess-Quanta-Control\Src\CountessQuantaControl\KinectManager.cs,SensorSkeletonFrameReady,The following statement contains a magic number: if (gestureRecognitionEnabled) {  	// Check gesture recognition conditions.  	//leftHandGesture.Evaluate(sequenceProcessor' skel.Joints[JointType.HandLeft].Position.Y > skel.Joints[JointType.ElbowLeft].Position.Y' "Left Hand Raised");  	//rightHandGesture.Evaluate(sequenceProcessor' skel.Joints[JointType.HandRight].Position.Y > skel.Joints[JointType.ElbowRight].Position.Y' "Right Hand Raised");  	RightHandAboveHead.Evaluate (sequenceProcessor' skel.Joints [JointType.HandRight].Position.Y > skel.Joints [JointType.Head].Position.Y' "Hello");  	RightHandBetweenSpineAndShoulderCenter.Evaluate (sequenceProcessor' skel.Joints [JointType.HandRight].Position.Y > skel.Joints [JointType.Spine].Position.Y && skel.Joints [JointType.HandRight].Position.Y < skel.Joints [JointType.ShoulderCenter].Position.Y && skel.Joints [JointType.HandRight].Position.X < (skel.Joints [JointType.Spine].Position.X + 0.1)' "PLAYMUSIC");  	LeftElbowAboveLeftShoulder.Evaluate (sequenceProcessor' skel.Joints [JointType.ElbowLeft].Position.Y > skel.Joints [JointType.ShoulderLeft].Position.Y' "NeckRotate");  	WalkCloseToKinect.Evaluate (sequenceProcessor' skel.Joints [JointType.Spine].Position.Z < 1.5' "ArmRaise");  	// [Add new Evaluate calls here]  }  
Magic Number,CountessQuantaControl,KinectManager,C:\repos\PSU-Robotics-Countess-Quanta_Countess-Quanta-Control\Src\CountessQuantaControl\KinectManager.cs,SensorSkeletonFrameReady,The following statement contains a magic number: if (gestureRecognitionEnabled) {  	// Check gesture recognition conditions.  	//leftHandGesture.Evaluate(sequenceProcessor' skel.Joints[JointType.HandLeft].Position.Y > skel.Joints[JointType.ElbowLeft].Position.Y' "Left Hand Raised");  	//rightHandGesture.Evaluate(sequenceProcessor' skel.Joints[JointType.HandRight].Position.Y > skel.Joints[JointType.ElbowRight].Position.Y' "Right Hand Raised");  	RightHandAboveHead.Evaluate (sequenceProcessor' skel.Joints [JointType.HandRight].Position.Y > skel.Joints [JointType.Head].Position.Y' "Hello");  	RightHandBetweenSpineAndShoulderCenter.Evaluate (sequenceProcessor' skel.Joints [JointType.HandRight].Position.Y > skel.Joints [JointType.Spine].Position.Y && skel.Joints [JointType.HandRight].Position.Y < skel.Joints [JointType.ShoulderCenter].Position.Y && skel.Joints [JointType.HandRight].Position.X < (skel.Joints [JointType.Spine].Position.X + 0.1)' "PLAYMUSIC");  	LeftElbowAboveLeftShoulder.Evaluate (sequenceProcessor' skel.Joints [JointType.ElbowLeft].Position.Y > skel.Joints [JointType.ShoulderLeft].Position.Y' "NeckRotate");  	WalkCloseToKinect.Evaluate (sequenceProcessor' skel.Joints [JointType.Spine].Position.Z < 1.5' "ArmRaise");  	// [Add new Evaluate calls here]  }  
Magic Number,CountessQuantaControl,KinectManager,C:\repos\PSU-Robotics-Countess-Quanta_Countess-Quanta-Control\Src\CountessQuantaControl\KinectManager.cs,SensorSkeletonFrameReady,The following statement contains a magic number: RightHandBetweenSpineAndShoulderCenter.Evaluate (sequenceProcessor' skel.Joints [JointType.HandRight].Position.Y > skel.Joints [JointType.Spine].Position.Y && skel.Joints [JointType.HandRight].Position.Y < skel.Joints [JointType.ShoulderCenter].Position.Y && skel.Joints [JointType.HandRight].Position.X < (skel.Joints [JointType.Spine].Position.X + 0.1)' "PLAYMUSIC");  
Magic Number,CountessQuantaControl,KinectManager,C:\repos\PSU-Robotics-Countess-Quanta_Countess-Quanta-Control\Src\CountessQuantaControl\KinectManager.cs,SensorSkeletonFrameReady,The following statement contains a magic number: WalkCloseToKinect.Evaluate (sequenceProcessor' skel.Joints [JointType.Spine].Position.Z < 1.5' "ArmRaise");  
Magic Number,CountessQuantaControl,ControlWindow,C:\repos\PSU-Robotics-Countess-Quanta_Countess-Quanta-Control\Src\CountessQuantaControl\ControlWindow.xaml.cs,ControlWindow,The following statement contains a magic number: logUpdateTimer.Interval = new TimeSpan (0' 0' 0' 0' 500);  
Magic Number,CountessQuantaControl,ControlWindow,C:\repos\PSU-Robotics-Countess-Quanta_Countess-Quanta-Control\Src\CountessQuantaControl\ControlWindow.xaml.cs,GenerateExampleXmls_Click,The following statement contains a magic number: exampleFrame1.AddServoPosition (new ServoPosition (0' 100));  
Magic Number,CountessQuantaControl,ControlWindow,C:\repos\PSU-Robotics-Countess-Quanta_Countess-Quanta-Control\Src\CountessQuantaControl\ControlWindow.xaml.cs,GenerateExampleXmls_Click,The following statement contains a magic number: exampleFrame1.AddServoPosition (new ServoPosition (1' 500));  
Magic Number,CountessQuantaControl,ControlWindow,C:\repos\PSU-Robotics-Countess-Quanta_Countess-Quanta-Control\Src\CountessQuantaControl\ControlWindow.xaml.cs,GenerateExampleXmls_Click,The following statement contains a magic number: exampleFrame2.AddServoPosition (new ServoPosition (0' 200));  
Magic Number,CountessQuantaControl,ControlWindow,C:\repos\PSU-Robotics-Countess-Quanta_Countess-Quanta-Control\Src\CountessQuantaControl\ControlWindow.xaml.cs,GenerateExampleXmls_Click,The following statement contains a magic number: exampleFrame2.AddServoPosition (new ServoPosition (1' 600));  
Magic Number,CountessQuantaControl,ControlWindow,C:\repos\PSU-Robotics-Countess-Quanta_Countess-Quanta-Control\Src\CountessQuantaControl\ControlWindow.xaml.cs,GenerateExampleXmls_Click,The following statement contains a magic number: exampleFrame2.timeToDestination = 0.5;  
Magic Number,CountessQuantaControl,ControlWindow,C:\repos\PSU-Robotics-Countess-Quanta_Countess-Quanta-Control\Src\CountessQuantaControl\ControlWindow.xaml.cs,LoggingLevelBox_Loaded,The following statement contains a magic number: comboBox.SelectedIndex = 2;  
Missing Default,CountessQuantaControl,AriaManager,C:\repos\PSU-Robotics-Countess-Quanta_Countess-Quanta-Control\Src\CountessQuantaControl\AriaManager.cs,InitializeAriaHardware,The following switch statement is missing a default case: switch (hr) {  case 0:  	ErrorLogging.AddMessage (ErrorLogging.LoggingLevel.Info' "InitializeAria() succeeded' connected to robot base control.");  	break;  case 1:  	ErrorLogging.AddMessage (ErrorLogging.LoggingLevel.Error' "InitializeAria() failed' could not parse arguments.");  	break;  case 2:  	ErrorLogging.AddMessage (ErrorLogging.LoggingLevel.Error' "InitializeAria() failed' could not connect to robot base.");  	break;  }  
Missing Default,CountessQuantaControl,SequenceProcessor,C:\repos\PSU-Robotics-Countess-Quanta_Countess-Quanta-Control\Src\CountessQuantaControl\SequenceProcessor.cs,RunSequenceThread,The following switch statement is missing a default case: switch (frame.eyeState) {  case "Open":  	robotEyes.SetEyeState (true' true);  	break;  case "Closed":  	robotEyes.SetEyeState (false' false);  	break;  case "LeftClosed":  	robotEyes.SetEyeState (false' true);  	break;  case "RightClosed":  	robotEyes.SetEyeState (true' false);  	break;  }  
Missing Default,CountessQuantaControl,KinectManager,C:\repos\PSU-Robotics-Countess-Quanta_Countess-Quanta-Control\Src\CountessQuantaControl\KinectManager.cs,SpeechRecognized,The following switch statement is missing a default case: switch (e.Result.Semantics.Value.ToString ()) {  case "Hello":  	sequenceName = "Hello";  	break;  case "HowAreUDoing":  	sequenceName = "HowAreUDoing";  	break;  case "Introduce":  	sequenceName = "Introduce";  	break;  case "Number":  	sequenceName = "Number";  	break;  case "DoWhat":  	sequenceName = "DoWhat";  	break;  case "Thanks":  	sequenceName = "Thanks";  	break;  case "Count":  	sequenceName = "Count";  	break;  case "OneAndTwo":  	sequenceName = "OneAndTwo";  	break;  case "FiveMinusOne":  	sequenceName = "FiveMinusOne";  	break;  case "Gesture":  	sequenceName = "Gesture";  	break;  case "NextOne":  	sequenceName = "NextOne";  	break;  case "NextTwo":  	sequenceName = "NextTwo";  	break;  case "NextThree":  	sequenceName = "NextThree";  	break;  case "PlayHarp":  	sequenceName = "PlayHarp";  	break;  case "PLAYMUSIC":  	sequenceName = "PLAYMUSIC";  	break;  case "lab":  	sequenceName = "lab";  	break;  case "GoAhead":  	sequenceName = "GoAhead";  	break;  case "NAME":  	sequenceName = "NAME";  	break;  case "Bye":  	sequenceName = "Bye";  	break;  case "GoodMorning":  	sequenceName = "GoodMorning";  	break;  case "URwelcome":  	sequenceName = "URwelcome";  	break;  case "GladSU":  	sequenceName = "GladSU";  	break;  case "DEFAULT":  	sequenceName = "DEFAULT";  	break;  }  
