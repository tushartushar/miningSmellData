Implementation smell,Namespace,Class,File,Method,Description
Long Method,Ionic.BZip2,BZip2InputStream,C:\repos\haf_DotNetZip.Semverd\src\BZip2\BZip2InputStream.cs,getAndMoveToFrontDecode,The method has 200 lines of code.
Long Method,Ionic.BZip2,BZip2Compressor,C:\repos\haf_DotNetZip.Semverd\src\BZip2\BZip2Compressor.cs,mainSort,The method has 166 lines of code.
Long Method,Ionic.BZip2,BZip2Compressor,C:\repos\haf_DotNetZip.Semverd\src\BZip2\BZip2Compressor.cs,mainSimpleSort,The method has 235 lines of code.
Long Method,Ionic.BZip2,BZip2Compressor,C:\repos\haf_DotNetZip.Semverd\src\BZip2\BZip2Compressor.cs,mainQSort3,The method has 109 lines of code.
Long Method,Ionic.BZip2,BZip2Compressor,C:\repos\haf_DotNetZip.Semverd\src\BZip2\BZip2Compressor.cs,generateMTFValues,The method has 115 lines of code.
Long Method,Ionic.BZip2,BZip2Compressor,C:\repos\haf_DotNetZip.Semverd\src\BZip2\BZip2Compressor.cs,hbMakeCodeLengths,The method has 138 lines of code.
Long Method,Ionic.BZip2,BZip2Compressor,C:\repos\haf_DotNetZip.Semverd\src\BZip2\BZip2Compressor.cs,sendMTFValues1,The method has 109 lines of code.
Long Method,Ionic.BZip2,ParallelBZip2OutputStream,C:\repos\haf_DotNetZip.Semverd\src\BZip2\ParallelBZip2OutputStream.cs,EmitPendingBuffers,The method has 139 lines of code.
Complex Method,Ionic.BZip2,BZip2InputStream,C:\repos\haf_DotNetZip.Semverd\src\BZip2\BZip2InputStream.cs,hbCreateDecodeTables,Cyclomatic complexity of the method is 9
Complex Method,Ionic.BZip2,BZip2InputStream,C:\repos\haf_DotNetZip.Semverd\src\BZip2\BZip2InputStream.cs,recvDecodingTables,Cyclomatic complexity of the method is 16
Complex Method,Ionic.BZip2,BZip2InputStream,C:\repos\haf_DotNetZip.Semverd\src\BZip2\BZip2InputStream.cs,getAndMoveToFrontDecode,Cyclomatic complexity of the method is 16
Complex Method,Ionic.BZip2,BZip2InputStream,C:\repos\haf_DotNetZip.Semverd\src\BZip2\BZip2InputStream.cs,SetupBlock,Cyclomatic complexity of the method is 13
Complex Method,Ionic.BZip2,BZip2Compressor,C:\repos\haf_DotNetZip.Semverd\src\BZip2\BZip2Compressor.cs,mainSort,Cyclomatic complexity of the method is 25
Complex Method,Ionic.BZip2,BZip2Compressor,C:\repos\haf_DotNetZip.Semverd\src\BZip2\BZip2Compressor.cs,generateMTFValues,Cyclomatic complexity of the method is 12
Complex Method,Ionic.BZip2,BZip2Compressor,C:\repos\haf_DotNetZip.Semverd\src\BZip2\BZip2Compressor.cs,hbMakeCodeLengths,Cyclomatic complexity of the method is 20
Complex Method,Ionic.BZip2,BZip2Compressor,C:\repos\haf_DotNetZip.Semverd\src\BZip2\BZip2Compressor.cs,sendMTFValues1,Cyclomatic complexity of the method is 11
Complex Method,Ionic.BZip2,BZip2Compressor,C:\repos\haf_DotNetZip.Semverd\src\BZip2\BZip2Compressor.cs,sendMTFValues4,Cyclomatic complexity of the method is 10
Complex Method,Ionic.BZip2,ParallelBZip2OutputStream,C:\repos\haf_DotNetZip.Semverd\src\BZip2\ParallelBZip2OutputStream.cs,Write,Cyclomatic complexity of the method is 8
Long Parameter List,Ionic.BZip2,BZip2InputStream,C:\repos\haf_DotNetZip.Semverd\src\BZip2\BZip2InputStream.cs,hbCreateDecodeTables,The method has 7 parameters. Parameters: limit' bbase' perm' length' minLen' maxLen' alphaSize
Long Parameter List,Ionic.BZip2,BZip2Compressor,C:\repos\haf_DotNetZip.Semverd\src\BZip2\BZip2Compressor.cs,hbAssignCodes,The method has 5 parameters. Parameters: code' length' minLen' maxLen' alphaSize
Long Parameter List,Ionic.BZip2,BZip2Compressor,C:\repos\haf_DotNetZip.Semverd\src\BZip2\BZip2Compressor.cs,hbMakeCodeLengths,The method has 5 parameters. Parameters: len' freq' state1' alphaSize' maxLen
Complex Conditional,Ionic.BZip2,BZip2InputStream,C:\repos\haf_DotNetZip.Semverd\src\BZip2\BZip2InputStream.cs,InitBlock,The conditional expression  "magic0 == 0x17 && magic1 == 0x72 && magic2 == 0x45                  && magic3 == 0x38 && magic4 == 0x50 && magic5 == 0x90"  is complex.
Complex Conditional,Ionic.BZip2,BZip2InputStream,C:\repos\haf_DotNetZip.Semverd\src\BZip2\BZip2InputStream.cs,InitBlock,The conditional expression  "magic0 != 0x31 ||                       magic1 != 0x41 ||                       magic2 != 0x59 ||                       magic3 != 0x26 ||                       magic4 != 0x53 ||                       magic5 != 0x59"  is complex.
Complex Conditional,Ionic.BZip2,BZip2Compressor,C:\repos\haf_DotNetZip.Semverd\src\BZip2\BZip2Compressor.cs,sendMTFValues0,The conditional expression  "(ge > gs) && (nPart != nGroups) && (nPart != 1)                      && (((nGroups - nPart) & 1) != 0)"  is complex.
Magic Number,Ionic.BZip2,BZip2InputStream,C:\repos\haf_DotNetZip.Semverd\src\BZip2\BZip2InputStream.cs,MakeMaps,The following statement contains a magic number: for (int i = 0; i < 256; i++)              {                  if (inUse[i])                      seqToUnseq[n++] = (byte) i;              }
Magic Number,Ionic.BZip2,BZip2InputStream,C:\repos\haf_DotNetZip.Semverd\src\BZip2\BZip2InputStream.cs,init,The following statement contains a magic number: CheckMagicChar('h'' 2);
Magic Number,Ionic.BZip2,BZip2InputStream,C:\repos\haf_DotNetZip.Semverd\src\BZip2\BZip2InputStream.cs,EndBlock,The following statement contains a magic number: this.computedCombinedCRC = (this.computedCombinedCRC << 1)                  | (this.computedCombinedCRC >> 31);
Magic Number,Ionic.BZip2,BZip2InputStream,C:\repos\haf_DotNetZip.Semverd\src\BZip2\BZip2InputStream.cs,GetBits,The following statement contains a magic number: if (bsLiveShadow < n)              {                  do                  {                      int thech = this.input.ReadByte();                        if (thech < 0)                          throw new IOException("unexpected end of stream");                        // Console.WriteLine("R {0:X2}"' thech);                        bsBuffShadow = (bsBuffShadow << 8) | thech;                      bsLiveShadow += 8;                  } while (bsLiveShadow < n);                    this.bsBuff = bsBuffShadow;              }
Magic Number,Ionic.BZip2,BZip2InputStream,C:\repos\haf_DotNetZip.Semverd\src\BZip2\BZip2InputStream.cs,GetBits,The following statement contains a magic number: if (bsLiveShadow < n)              {                  do                  {                      int thech = this.input.ReadByte();                        if (thech < 0)                          throw new IOException("unexpected end of stream");                        // Console.WriteLine("R {0:X2}"' thech);                        bsBuffShadow = (bsBuffShadow << 8) | thech;                      bsLiveShadow += 8;                  } while (bsLiveShadow < n);                    this.bsBuff = bsBuffShadow;              }
Magic Number,Ionic.BZip2,BZip2InputStream,C:\repos\haf_DotNetZip.Semverd\src\BZip2\BZip2InputStream.cs,bsGetUByte,The following statement contains a magic number: return (char) GetBits(8);
Magic Number,Ionic.BZip2,BZip2InputStream,C:\repos\haf_DotNetZip.Semverd\src\BZip2\BZip2InputStream.cs,bsGetInt,The following statement contains a magic number: return (uint)((((((GetBits(8) << 8) | GetBits(8)) << 8) | GetBits(8)) << 8) | GetBits(8));
Magic Number,Ionic.BZip2,BZip2InputStream,C:\repos\haf_DotNetZip.Semverd\src\BZip2\BZip2InputStream.cs,bsGetInt,The following statement contains a magic number: return (uint)((((((GetBits(8) << 8) | GetBits(8)) << 8) | GetBits(8)) << 8) | GetBits(8));
Magic Number,Ionic.BZip2,BZip2InputStream,C:\repos\haf_DotNetZip.Semverd\src\BZip2\BZip2InputStream.cs,bsGetInt,The following statement contains a magic number: return (uint)((((((GetBits(8) << 8) | GetBits(8)) << 8) | GetBits(8)) << 8) | GetBits(8));
Magic Number,Ionic.BZip2,BZip2InputStream,C:\repos\haf_DotNetZip.Semverd\src\BZip2\BZip2InputStream.cs,bsGetInt,The following statement contains a magic number: return (uint)((((((GetBits(8) << 8) | GetBits(8)) << 8) | GetBits(8)) << 8) | GetBits(8));
Magic Number,Ionic.BZip2,BZip2InputStream,C:\repos\haf_DotNetZip.Semverd\src\BZip2\BZip2InputStream.cs,bsGetInt,The following statement contains a magic number: return (uint)((((((GetBits(8) << 8) | GetBits(8)) << 8) | GetBits(8)) << 8) | GetBits(8));
Magic Number,Ionic.BZip2,BZip2InputStream,C:\repos\haf_DotNetZip.Semverd\src\BZip2\BZip2InputStream.cs,bsGetInt,The following statement contains a magic number: return (uint)((((((GetBits(8) << 8) | GetBits(8)) << 8) | GetBits(8)) << 8) | GetBits(8));
Magic Number,Ionic.BZip2,BZip2InputStream,C:\repos\haf_DotNetZip.Semverd\src\BZip2\BZip2InputStream.cs,bsGetInt,The following statement contains a magic number: return (uint)((((((GetBits(8) << 8) | GetBits(8)) << 8) | GetBits(8)) << 8) | GetBits(8));
Magic Number,Ionic.BZip2,BZip2InputStream,C:\repos\haf_DotNetZip.Semverd\src\BZip2\BZip2InputStream.cs,recvDecodingTables,The following statement contains a magic number: for (int i = 0; i < 16; i++)              {                  if (bsGetBit())                  {                      inUse16 |= 1 << i;                  }              }
Magic Number,Ionic.BZip2,BZip2InputStream,C:\repos\haf_DotNetZip.Semverd\src\BZip2\BZip2InputStream.cs,recvDecodingTables,The following statement contains a magic number: for (int i = 256; --i >= 0;)              {                  inUse[i] = false;              }
Magic Number,Ionic.BZip2,BZip2InputStream,C:\repos\haf_DotNetZip.Semverd\src\BZip2\BZip2InputStream.cs,recvDecodingTables,The following statement contains a magic number: for (int i = 0; i < 16; i++)              {                  if ((inUse16 & (1 << i)) != 0)                  {                      int i16 = i << 4;                      for (int j = 0; j < 16; j++)                      {                          if (bsGetBit())                          {                              inUse[i16 + j] = true;                          }                      }                  }              }
Magic Number,Ionic.BZip2,BZip2InputStream,C:\repos\haf_DotNetZip.Semverd\src\BZip2\BZip2InputStream.cs,recvDecodingTables,The following statement contains a magic number: for (int i = 0; i < 16; i++)              {                  if ((inUse16 & (1 << i)) != 0)                  {                      int i16 = i << 4;                      for (int j = 0; j < 16; j++)                      {                          if (bsGetBit())                          {                              inUse[i16 + j] = true;                          }                      }                  }              }
Magic Number,Ionic.BZip2,BZip2InputStream,C:\repos\haf_DotNetZip.Semverd\src\BZip2\BZip2InputStream.cs,recvDecodingTables,The following statement contains a magic number: for (int i = 0; i < 16; i++)              {                  if ((inUse16 & (1 << i)) != 0)                  {                      int i16 = i << 4;                      for (int j = 0; j < 16; j++)                      {                          if (bsGetBit())                          {                              inUse[i16 + j] = true;                          }                      }                  }              }
Magic Number,Ionic.BZip2,BZip2InputStream,C:\repos\haf_DotNetZip.Semverd\src\BZip2\BZip2InputStream.cs,recvDecodingTables,The following statement contains a magic number: int alphaSize = this.nInUse + 2;
Magic Number,Ionic.BZip2,BZip2InputStream,C:\repos\haf_DotNetZip.Semverd\src\BZip2\BZip2InputStream.cs,recvDecodingTables,The following statement contains a magic number: int nGroups = GetBits(3);
Magic Number,Ionic.BZip2,BZip2InputStream,C:\repos\haf_DotNetZip.Semverd\src\BZip2\BZip2InputStream.cs,recvDecodingTables,The following statement contains a magic number: int nSelectors = GetBits(15);
Magic Number,Ionic.BZip2,BZip2InputStream,C:\repos\haf_DotNetZip.Semverd\src\BZip2\BZip2InputStream.cs,recvDecodingTables,The following statement contains a magic number: for (int t = 0; t < nGroups; t++)              {                  int curr = GetBits(5);                  char[] len_t = len[t];                  for (int i = 0; i < alphaSize; i++)                  {                      while (bsGetBit())                      {                          curr += bsGetBit() ? -1 : 1;                      }                      len_t[i] = (char) curr;                  }              }
Magic Number,Ionic.BZip2,BZip2InputStream,C:\repos\haf_DotNetZip.Semverd\src\BZip2\BZip2InputStream.cs,createHuffmanDecodingTables,The following statement contains a magic number: for (int t = 0; t < nGroups; t++)              {                  int minLen = 32;                  int maxLen = 0;                  char[] len_t = len[t];                  for (int i = alphaSize; --i >= 0;)                  {                      char lent = len_t[i];                      if (lent > maxLen)                          maxLen = lent;                        if (lent < minLen)                          minLen = lent;                  }                  hbCreateDecodeTables(s.gLimit[t]' s.gBase[t]' s.gPerm[t]' len[t]' minLen'                                       maxLen' alphaSize);                  s.gMinlen[t] = minLen;              }
Magic Number,Ionic.BZip2,BZip2InputStream,C:\repos\haf_DotNetZip.Semverd\src\BZip2\BZip2InputStream.cs,getAndMoveToFrontDecode,The following statement contains a magic number: this.origPtr = GetBits(24);
Magic Number,Ionic.BZip2,BZip2InputStream,C:\repos\haf_DotNetZip.Semverd\src\BZip2\BZip2InputStream.cs,getAndMoveToFrontDecode,The following statement contains a magic number: if (this.origPtr > 10 + BZip2.BlockSizeMultiple * this.blockSize100k)                  throw new IOException("BZ_DATA_ERROR");
Magic Number,Ionic.BZip2,BZip2InputStream,C:\repos\haf_DotNetZip.Semverd\src\BZip2\BZip2InputStream.cs,getAndMoveToFrontDecode,The following statement contains a magic number: for (int i = 256; --i >= 0;)              {                  yy[i] = (byte) i;                  s.unzftab[i] = 0;              }
Magic Number,Ionic.BZip2,BZip2InputStream,C:\repos\haf_DotNetZip.Semverd\src\BZip2\BZip2InputStream.cs,getAndMoveToFrontDecode,The following statement contains a magic number: while (nextSym != eob)              {                  if ((nextSym == BZip2.RUNA) || (nextSym == BZip2.RUNB))                  {                      int es = -1;                        for (int n = 1; true; n <<= 1)                      {                          if (nextSym == BZip2.RUNA)                          {                              es += n;                          }                          else if (nextSym == BZip2.RUNB)                          {                              es += n << 1;                          }                          else                          {                              break;                          }                            if (groupPos == 0)                          {                              groupPos = BZip2.G_SIZE - 1;                              zt = s.selector[++groupNo] & 0xff;                              base_zt = s.gBase[zt];                              limit_zt = s.gLimit[zt];                              perm_zt = s.gPerm[zt];                              minLens_zt = s.gMinlen[zt];                          }                          else                          {                              groupPos--;                          }                            int zn = minLens_zt;                            // Inlined:                          // int zvec = GetBits(zn);                          while (bsLiveShadow < zn)                          {                              int thech = this.input.ReadByte();                              if (thech >= 0)                              {                                  bsBuffShadow = (bsBuffShadow << 8) | thech;                                  bsLiveShadow += 8;                                  continue;                              }                              else                              {                                  throw new IOException("unexpected end of stream");                              }                          }                          int zvec = (bsBuffShadow >> (bsLiveShadow - zn))                              & ((1 << zn) - 1);                          bsLiveShadow -= zn;                            while (zvec > limit_zt[zn])                          {                              zn++;                              while (bsLiveShadow < 1)                              {                                  int thech = this.input.ReadByte();                                  if (thech >= 0)                                  {                                      bsBuffShadow = (bsBuffShadow << 8) | thech;                                      bsLiveShadow += 8;                                      continue;                                  }                                  else                                  {                                      throw new IOException("unexpected end of stream");                                  }                              }                              bsLiveShadow--;                              zvec = (zvec << 1)                                  | ((bsBuffShadow >> bsLiveShadow) & 1);                          }                          nextSym = perm_zt[zvec - base_zt[zn]];                      }                        byte ch = s.seqToUnseq[yy[0]];                      s.unzftab[ch & 0xff] += es + 1;                        while (es-- >= 0)                      {                          s.ll8[++lastShadow] = ch;                      }                        if (lastShadow >= limitLast)                          throw new IOException("block overrun");                  }                  else                  {                      if (++lastShadow >= limitLast)                          throw new IOException("block overrun");                        byte tmp = yy[nextSym - 1];                      s.unzftab[s.seqToUnseq[tmp] & 0xff]++;                      s.ll8[lastShadow] = s.seqToUnseq[tmp];                        /*                       * This loop is hammered during decompression' hence avoid                       * native method call overhead of System.Buffer.BlockCopy for very                       * small ranges to copy.                       */                      if (nextSym <= 16)                      {                          for (int j = nextSym - 1; j > 0;)                          {                              yy[j] = yy[--j];                          }                      }                      else                      {                          System.Buffer.BlockCopy(yy' 0' yy' 1' nextSym - 1);                      }                        yy[0] = tmp;                        if (groupPos == 0)                      {                          groupPos = BZip2.G_SIZE - 1;                          zt = s.selector[++groupNo] & 0xff;                          base_zt = s.gBase[zt];                          limit_zt = s.gLimit[zt];                          perm_zt = s.gPerm[zt];                          minLens_zt = s.gMinlen[zt];                      }                      else                      {                          groupPos--;                      }                        int zn = minLens_zt;                        // Inlined:                      // int zvec = GetBits(zn);                      while (bsLiveShadow < zn)                      {                          int thech = this.input.ReadByte();                          if (thech >= 0)                          {                              bsBuffShadow = (bsBuffShadow << 8) | thech;                              bsLiveShadow += 8;                              continue;                          }                          else                          {                              throw new IOException("unexpected end of stream");                          }                      }                      int zvec = (bsBuffShadow >> (bsLiveShadow - zn))                          & ((1 << zn) - 1);                      bsLiveShadow -= zn;                        while (zvec > limit_zt[zn])                      {                          zn++;                          while (bsLiveShadow < 1)                          {                              int thech = this.input.ReadByte();                              if (thech >= 0)                              {                                  bsBuffShadow = (bsBuffShadow << 8) | thech;                                  bsLiveShadow += 8;                                  continue;                              }                              else                              {                                  throw new IOException("unexpected end of stream");                              }                          }                          bsLiveShadow--;                          zvec = (zvec << 1) | ((bsBuffShadow >> bsLiveShadow) & 1);                      }                      nextSym = perm_zt[zvec - base_zt[zn]];                  }              }
Magic Number,Ionic.BZip2,BZip2InputStream,C:\repos\haf_DotNetZip.Semverd\src\BZip2\BZip2InputStream.cs,getAndMoveToFrontDecode,The following statement contains a magic number: while (nextSym != eob)              {                  if ((nextSym == BZip2.RUNA) || (nextSym == BZip2.RUNB))                  {                      int es = -1;                        for (int n = 1; true; n <<= 1)                      {                          if (nextSym == BZip2.RUNA)                          {                              es += n;                          }                          else if (nextSym == BZip2.RUNB)                          {                              es += n << 1;                          }                          else                          {                              break;                          }                            if (groupPos == 0)                          {                              groupPos = BZip2.G_SIZE - 1;                              zt = s.selector[++groupNo] & 0xff;                              base_zt = s.gBase[zt];                              limit_zt = s.gLimit[zt];                              perm_zt = s.gPerm[zt];                              minLens_zt = s.gMinlen[zt];                          }                          else                          {                              groupPos--;                          }                            int zn = minLens_zt;                            // Inlined:                          // int zvec = GetBits(zn);                          while (bsLiveShadow < zn)                          {                              int thech = this.input.ReadByte();                              if (thech >= 0)                              {                                  bsBuffShadow = (bsBuffShadow << 8) | thech;                                  bsLiveShadow += 8;                                  continue;                              }                              else                              {                                  throw new IOException("unexpected end of stream");                              }                          }                          int zvec = (bsBuffShadow >> (bsLiveShadow - zn))                              & ((1 << zn) - 1);                          bsLiveShadow -= zn;                            while (zvec > limit_zt[zn])                          {                              zn++;                              while (bsLiveShadow < 1)                              {                                  int thech = this.input.ReadByte();                                  if (thech >= 0)                                  {                                      bsBuffShadow = (bsBuffShadow << 8) | thech;                                      bsLiveShadow += 8;                                      continue;                                  }                                  else                                  {                                      throw new IOException("unexpected end of stream");                                  }                              }                              bsLiveShadow--;                              zvec = (zvec << 1)                                  | ((bsBuffShadow >> bsLiveShadow) & 1);                          }                          nextSym = perm_zt[zvec - base_zt[zn]];                      }                        byte ch = s.seqToUnseq[yy[0]];                      s.unzftab[ch & 0xff] += es + 1;                        while (es-- >= 0)                      {                          s.ll8[++lastShadow] = ch;                      }                        if (lastShadow >= limitLast)                          throw new IOException("block overrun");                  }                  else                  {                      if (++lastShadow >= limitLast)                          throw new IOException("block overrun");                        byte tmp = yy[nextSym - 1];                      s.unzftab[s.seqToUnseq[tmp] & 0xff]++;                      s.ll8[lastShadow] = s.seqToUnseq[tmp];                        /*                       * This loop is hammered during decompression' hence avoid                       * native method call overhead of System.Buffer.BlockCopy for very                       * small ranges to copy.                       */                      if (nextSym <= 16)                      {                          for (int j = nextSym - 1; j > 0;)                          {                              yy[j] = yy[--j];                          }                      }                      else                      {                          System.Buffer.BlockCopy(yy' 0' yy' 1' nextSym - 1);                      }                        yy[0] = tmp;                        if (groupPos == 0)                      {                          groupPos = BZip2.G_SIZE - 1;                          zt = s.selector[++groupNo] & 0xff;                          base_zt = s.gBase[zt];                          limit_zt = s.gLimit[zt];                          perm_zt = s.gPerm[zt];                          minLens_zt = s.gMinlen[zt];                      }                      else                      {                          groupPos--;                      }                        int zn = minLens_zt;                        // Inlined:                      // int zvec = GetBits(zn);                      while (bsLiveShadow < zn)                      {                          int thech = this.input.ReadByte();                          if (thech >= 0)                          {                              bsBuffShadow = (bsBuffShadow << 8) | thech;                              bsLiveShadow += 8;                              continue;                          }                          else                          {                              throw new IOException("unexpected end of stream");                          }                      }                      int zvec = (bsBuffShadow >> (bsLiveShadow - zn))                          & ((1 << zn) - 1);                      bsLiveShadow -= zn;                        while (zvec > limit_zt[zn])                      {                          zn++;                          while (bsLiveShadow < 1)                          {                              int thech = this.input.ReadByte();                              if (thech >= 0)                              {                                  bsBuffShadow = (bsBuffShadow << 8) | thech;                                  bsLiveShadow += 8;                                  continue;                              }                              else                              {                                  throw new IOException("unexpected end of stream");                              }                          }                          bsLiveShadow--;                          zvec = (zvec << 1) | ((bsBuffShadow >> bsLiveShadow) & 1);                      }                      nextSym = perm_zt[zvec - base_zt[zn]];                  }              }
Magic Number,Ionic.BZip2,BZip2InputStream,C:\repos\haf_DotNetZip.Semverd\src\BZip2\BZip2InputStream.cs,getAndMoveToFrontDecode,The following statement contains a magic number: while (nextSym != eob)              {                  if ((nextSym == BZip2.RUNA) || (nextSym == BZip2.RUNB))                  {                      int es = -1;                        for (int n = 1; true; n <<= 1)                      {                          if (nextSym == BZip2.RUNA)                          {                              es += n;                          }                          else if (nextSym == BZip2.RUNB)                          {                              es += n << 1;                          }                          else                          {                              break;                          }                            if (groupPos == 0)                          {                              groupPos = BZip2.G_SIZE - 1;                              zt = s.selector[++groupNo] & 0xff;                              base_zt = s.gBase[zt];                              limit_zt = s.gLimit[zt];                              perm_zt = s.gPerm[zt];                              minLens_zt = s.gMinlen[zt];                          }                          else                          {                              groupPos--;                          }                            int zn = minLens_zt;                            // Inlined:                          // int zvec = GetBits(zn);                          while (bsLiveShadow < zn)                          {                              int thech = this.input.ReadByte();                              if (thech >= 0)                              {                                  bsBuffShadow = (bsBuffShadow << 8) | thech;                                  bsLiveShadow += 8;                                  continue;                              }                              else                              {                                  throw new IOException("unexpected end of stream");                              }                          }                          int zvec = (bsBuffShadow >> (bsLiveShadow - zn))                              & ((1 << zn) - 1);                          bsLiveShadow -= zn;                            while (zvec > limit_zt[zn])                          {                              zn++;                              while (bsLiveShadow < 1)                              {                                  int thech = this.input.ReadByte();                                  if (thech >= 0)                                  {                                      bsBuffShadow = (bsBuffShadow << 8) | thech;                                      bsLiveShadow += 8;                                      continue;                                  }                                  else                                  {                                      throw new IOException("unexpected end of stream");                                  }                              }                              bsLiveShadow--;                              zvec = (zvec << 1)                                  | ((bsBuffShadow >> bsLiveShadow) & 1);                          }                          nextSym = perm_zt[zvec - base_zt[zn]];                      }                        byte ch = s.seqToUnseq[yy[0]];                      s.unzftab[ch & 0xff] += es + 1;                        while (es-- >= 0)                      {                          s.ll8[++lastShadow] = ch;                      }                        if (lastShadow >= limitLast)                          throw new IOException("block overrun");                  }                  else                  {                      if (++lastShadow >= limitLast)                          throw new IOException("block overrun");                        byte tmp = yy[nextSym - 1];                      s.unzftab[s.seqToUnseq[tmp] & 0xff]++;                      s.ll8[lastShadow] = s.seqToUnseq[tmp];                        /*                       * This loop is hammered during decompression' hence avoid                       * native method call overhead of System.Buffer.BlockCopy for very                       * small ranges to copy.                       */                      if (nextSym <= 16)                      {                          for (int j = nextSym - 1; j > 0;)                          {                              yy[j] = yy[--j];                          }                      }                      else                      {                          System.Buffer.BlockCopy(yy' 0' yy' 1' nextSym - 1);                      }                        yy[0] = tmp;                        if (groupPos == 0)                      {                          groupPos = BZip2.G_SIZE - 1;                          zt = s.selector[++groupNo] & 0xff;                          base_zt = s.gBase[zt];                          limit_zt = s.gLimit[zt];                          perm_zt = s.gPerm[zt];                          minLens_zt = s.gMinlen[zt];                      }                      else                      {                          groupPos--;                      }                        int zn = minLens_zt;                        // Inlined:                      // int zvec = GetBits(zn);                      while (bsLiveShadow < zn)                      {                          int thech = this.input.ReadByte();                          if (thech >= 0)                          {                              bsBuffShadow = (bsBuffShadow << 8) | thech;                              bsLiveShadow += 8;                              continue;                          }                          else                          {                              throw new IOException("unexpected end of stream");                          }                      }                      int zvec = (bsBuffShadow >> (bsLiveShadow - zn))                          & ((1 << zn) - 1);                      bsLiveShadow -= zn;                        while (zvec > limit_zt[zn])                      {                          zn++;                          while (bsLiveShadow < 1)                          {                              int thech = this.input.ReadByte();                              if (thech >= 0)                              {                                  bsBuffShadow = (bsBuffShadow << 8) | thech;                                  bsLiveShadow += 8;                                  continue;                              }                              else                              {                                  throw new IOException("unexpected end of stream");                              }                          }                          bsLiveShadow--;                          zvec = (zvec << 1) | ((bsBuffShadow >> bsLiveShadow) & 1);                      }                      nextSym = perm_zt[zvec - base_zt[zn]];                  }              }
Magic Number,Ionic.BZip2,BZip2InputStream,C:\repos\haf_DotNetZip.Semverd\src\BZip2\BZip2InputStream.cs,getAndMoveToFrontDecode,The following statement contains a magic number: while (nextSym != eob)              {                  if ((nextSym == BZip2.RUNA) || (nextSym == BZip2.RUNB))                  {                      int es = -1;                        for (int n = 1; true; n <<= 1)                      {                          if (nextSym == BZip2.RUNA)                          {                              es += n;                          }                          else if (nextSym == BZip2.RUNB)                          {                              es += n << 1;                          }                          else                          {                              break;                          }                            if (groupPos == 0)                          {                              groupPos = BZip2.G_SIZE - 1;                              zt = s.selector[++groupNo] & 0xff;                              base_zt = s.gBase[zt];                              limit_zt = s.gLimit[zt];                              perm_zt = s.gPerm[zt];                              minLens_zt = s.gMinlen[zt];                          }                          else                          {                              groupPos--;                          }                            int zn = minLens_zt;                            // Inlined:                          // int zvec = GetBits(zn);                          while (bsLiveShadow < zn)                          {                              int thech = this.input.ReadByte();                              if (thech >= 0)                              {                                  bsBuffShadow = (bsBuffShadow << 8) | thech;                                  bsLiveShadow += 8;                                  continue;                              }                              else                              {                                  throw new IOException("unexpected end of stream");                              }                          }                          int zvec = (bsBuffShadow >> (bsLiveShadow - zn))                              & ((1 << zn) - 1);                          bsLiveShadow -= zn;                            while (zvec > limit_zt[zn])                          {                              zn++;                              while (bsLiveShadow < 1)                              {                                  int thech = this.input.ReadByte();                                  if (thech >= 0)                                  {                                      bsBuffShadow = (bsBuffShadow << 8) | thech;                                      bsLiveShadow += 8;                                      continue;                                  }                                  else                                  {                                      throw new IOException("unexpected end of stream");                                  }                              }                              bsLiveShadow--;                              zvec = (zvec << 1)                                  | ((bsBuffShadow >> bsLiveShadow) & 1);                          }                          nextSym = perm_zt[zvec - base_zt[zn]];                      }                        byte ch = s.seqToUnseq[yy[0]];                      s.unzftab[ch & 0xff] += es + 1;                        while (es-- >= 0)                      {                          s.ll8[++lastShadow] = ch;                      }                        if (lastShadow >= limitLast)                          throw new IOException("block overrun");                  }                  else                  {                      if (++lastShadow >= limitLast)                          throw new IOException("block overrun");                        byte tmp = yy[nextSym - 1];                      s.unzftab[s.seqToUnseq[tmp] & 0xff]++;                      s.ll8[lastShadow] = s.seqToUnseq[tmp];                        /*                       * This loop is hammered during decompression' hence avoid                       * native method call overhead of System.Buffer.BlockCopy for very                       * small ranges to copy.                       */                      if (nextSym <= 16)                      {                          for (int j = nextSym - 1; j > 0;)                          {                              yy[j] = yy[--j];                          }                      }                      else                      {                          System.Buffer.BlockCopy(yy' 0' yy' 1' nextSym - 1);                      }                        yy[0] = tmp;                        if (groupPos == 0)                      {                          groupPos = BZip2.G_SIZE - 1;                          zt = s.selector[++groupNo] & 0xff;                          base_zt = s.gBase[zt];                          limit_zt = s.gLimit[zt];                          perm_zt = s.gPerm[zt];                          minLens_zt = s.gMinlen[zt];                      }                      else                      {                          groupPos--;                      }                        int zn = minLens_zt;                        // Inlined:                      // int zvec = GetBits(zn);                      while (bsLiveShadow < zn)                      {                          int thech = this.input.ReadByte();                          if (thech >= 0)                          {                              bsBuffShadow = (bsBuffShadow << 8) | thech;                              bsLiveShadow += 8;                              continue;                          }                          else                          {                              throw new IOException("unexpected end of stream");                          }                      }                      int zvec = (bsBuffShadow >> (bsLiveShadow - zn))                          & ((1 << zn) - 1);                      bsLiveShadow -= zn;                        while (zvec > limit_zt[zn])                      {                          zn++;                          while (bsLiveShadow < 1)                          {                              int thech = this.input.ReadByte();                              if (thech >= 0)                              {                                  bsBuffShadow = (bsBuffShadow << 8) | thech;                                  bsLiveShadow += 8;                                  continue;                              }                              else                              {                                  throw new IOException("unexpected end of stream");                              }                          }                          bsLiveShadow--;                          zvec = (zvec << 1) | ((bsBuffShadow >> bsLiveShadow) & 1);                      }                      nextSym = perm_zt[zvec - base_zt[zn]];                  }              }
Magic Number,Ionic.BZip2,BZip2InputStream,C:\repos\haf_DotNetZip.Semverd\src\BZip2\BZip2InputStream.cs,getAndMoveToFrontDecode,The following statement contains a magic number: while (nextSym != eob)              {                  if ((nextSym == BZip2.RUNA) || (nextSym == BZip2.RUNB))                  {                      int es = -1;                        for (int n = 1; true; n <<= 1)                      {                          if (nextSym == BZip2.RUNA)                          {                              es += n;                          }                          else if (nextSym == BZip2.RUNB)                          {                              es += n << 1;                          }                          else                          {                              break;                          }                            if (groupPos == 0)                          {                              groupPos = BZip2.G_SIZE - 1;                              zt = s.selector[++groupNo] & 0xff;                              base_zt = s.gBase[zt];                              limit_zt = s.gLimit[zt];                              perm_zt = s.gPerm[zt];                              minLens_zt = s.gMinlen[zt];                          }                          else                          {                              groupPos--;                          }                            int zn = minLens_zt;                            // Inlined:                          // int zvec = GetBits(zn);                          while (bsLiveShadow < zn)                          {                              int thech = this.input.ReadByte();                              if (thech >= 0)                              {                                  bsBuffShadow = (bsBuffShadow << 8) | thech;                                  bsLiveShadow += 8;                                  continue;                              }                              else                              {                                  throw new IOException("unexpected end of stream");                              }                          }                          int zvec = (bsBuffShadow >> (bsLiveShadow - zn))                              & ((1 << zn) - 1);                          bsLiveShadow -= zn;                            while (zvec > limit_zt[zn])                          {                              zn++;                              while (bsLiveShadow < 1)                              {                                  int thech = this.input.ReadByte();                                  if (thech >= 0)                                  {                                      bsBuffShadow = (bsBuffShadow << 8) | thech;                                      bsLiveShadow += 8;                                      continue;                                  }                                  else                                  {                                      throw new IOException("unexpected end of stream");                                  }                              }                              bsLiveShadow--;                              zvec = (zvec << 1)                                  | ((bsBuffShadow >> bsLiveShadow) & 1);                          }                          nextSym = perm_zt[zvec - base_zt[zn]];                      }                        byte ch = s.seqToUnseq[yy[0]];                      s.unzftab[ch & 0xff] += es + 1;                        while (es-- >= 0)                      {                          s.ll8[++lastShadow] = ch;                      }                        if (lastShadow >= limitLast)                          throw new IOException("block overrun");                  }                  else                  {                      if (++lastShadow >= limitLast)                          throw new IOException("block overrun");                        byte tmp = yy[nextSym - 1];                      s.unzftab[s.seqToUnseq[tmp] & 0xff]++;                      s.ll8[lastShadow] = s.seqToUnseq[tmp];                        /*                       * This loop is hammered during decompression' hence avoid                       * native method call overhead of System.Buffer.BlockCopy for very                       * small ranges to copy.                       */                      if (nextSym <= 16)                      {                          for (int j = nextSym - 1; j > 0;)                          {                              yy[j] = yy[--j];                          }                      }                      else                      {                          System.Buffer.BlockCopy(yy' 0' yy' 1' nextSym - 1);                      }                        yy[0] = tmp;                        if (groupPos == 0)                      {                          groupPos = BZip2.G_SIZE - 1;                          zt = s.selector[++groupNo] & 0xff;                          base_zt = s.gBase[zt];                          limit_zt = s.gLimit[zt];                          perm_zt = s.gPerm[zt];                          minLens_zt = s.gMinlen[zt];                      }                      else                      {                          groupPos--;                      }                        int zn = minLens_zt;                        // Inlined:                      // int zvec = GetBits(zn);                      while (bsLiveShadow < zn)                      {                          int thech = this.input.ReadByte();                          if (thech >= 0)                          {                              bsBuffShadow = (bsBuffShadow << 8) | thech;                              bsLiveShadow += 8;                              continue;                          }                          else                          {                              throw new IOException("unexpected end of stream");                          }                      }                      int zvec = (bsBuffShadow >> (bsLiveShadow - zn))                          & ((1 << zn) - 1);                      bsLiveShadow -= zn;                        while (zvec > limit_zt[zn])                      {                          zn++;                          while (bsLiveShadow < 1)                          {                              int thech = this.input.ReadByte();                              if (thech >= 0)                              {                                  bsBuffShadow = (bsBuffShadow << 8) | thech;                                  bsLiveShadow += 8;                                  continue;                              }                              else                              {                                  throw new IOException("unexpected end of stream");                              }                          }                          bsLiveShadow--;                          zvec = (zvec << 1) | ((bsBuffShadow >> bsLiveShadow) & 1);                      }                      nextSym = perm_zt[zvec - base_zt[zn]];                  }              }
Magic Number,Ionic.BZip2,BZip2InputStream,C:\repos\haf_DotNetZip.Semverd\src\BZip2\BZip2InputStream.cs,getAndMoveToFrontDecode,The following statement contains a magic number: while (nextSym != eob)              {                  if ((nextSym == BZip2.RUNA) || (nextSym == BZip2.RUNB))                  {                      int es = -1;                        for (int n = 1; true; n <<= 1)                      {                          if (nextSym == BZip2.RUNA)                          {                              es += n;                          }                          else if (nextSym == BZip2.RUNB)                          {                              es += n << 1;                          }                          else                          {                              break;                          }                            if (groupPos == 0)                          {                              groupPos = BZip2.G_SIZE - 1;                              zt = s.selector[++groupNo] & 0xff;                              base_zt = s.gBase[zt];                              limit_zt = s.gLimit[zt];                              perm_zt = s.gPerm[zt];                              minLens_zt = s.gMinlen[zt];                          }                          else                          {                              groupPos--;                          }                            int zn = minLens_zt;                            // Inlined:                          // int zvec = GetBits(zn);                          while (bsLiveShadow < zn)                          {                              int thech = this.input.ReadByte();                              if (thech >= 0)                              {                                  bsBuffShadow = (bsBuffShadow << 8) | thech;                                  bsLiveShadow += 8;                                  continue;                              }                              else                              {                                  throw new IOException("unexpected end of stream");                              }                          }                          int zvec = (bsBuffShadow >> (bsLiveShadow - zn))                              & ((1 << zn) - 1);                          bsLiveShadow -= zn;                            while (zvec > limit_zt[zn])                          {                              zn++;                              while (bsLiveShadow < 1)                              {                                  int thech = this.input.ReadByte();                                  if (thech >= 0)                                  {                                      bsBuffShadow = (bsBuffShadow << 8) | thech;                                      bsLiveShadow += 8;                                      continue;                                  }                                  else                                  {                                      throw new IOException("unexpected end of stream");                                  }                              }                              bsLiveShadow--;                              zvec = (zvec << 1)                                  | ((bsBuffShadow >> bsLiveShadow) & 1);                          }                          nextSym = perm_zt[zvec - base_zt[zn]];                      }                        byte ch = s.seqToUnseq[yy[0]];                      s.unzftab[ch & 0xff] += es + 1;                        while (es-- >= 0)                      {                          s.ll8[++lastShadow] = ch;                      }                        if (lastShadow >= limitLast)                          throw new IOException("block overrun");                  }                  else                  {                      if (++lastShadow >= limitLast)                          throw new IOException("block overrun");                        byte tmp = yy[nextSym - 1];                      s.unzftab[s.seqToUnseq[tmp] & 0xff]++;                      s.ll8[lastShadow] = s.seqToUnseq[tmp];                        /*                       * This loop is hammered during decompression' hence avoid                       * native method call overhead of System.Buffer.BlockCopy for very                       * small ranges to copy.                       */                      if (nextSym <= 16)                      {                          for (int j = nextSym - 1; j > 0;)                          {                              yy[j] = yy[--j];                          }                      }                      else                      {                          System.Buffer.BlockCopy(yy' 0' yy' 1' nextSym - 1);                      }                        yy[0] = tmp;                        if (groupPos == 0)                      {                          groupPos = BZip2.G_SIZE - 1;                          zt = s.selector[++groupNo] & 0xff;                          base_zt = s.gBase[zt];                          limit_zt = s.gLimit[zt];                          perm_zt = s.gPerm[zt];                          minLens_zt = s.gMinlen[zt];                      }                      else                      {                          groupPos--;                      }                        int zn = minLens_zt;                        // Inlined:                      // int zvec = GetBits(zn);                      while (bsLiveShadow < zn)                      {                          int thech = this.input.ReadByte();                          if (thech >= 0)                          {                              bsBuffShadow = (bsBuffShadow << 8) | thech;                              bsLiveShadow += 8;                              continue;                          }                          else                          {                              throw new IOException("unexpected end of stream");                          }                      }                      int zvec = (bsBuffShadow >> (bsLiveShadow - zn))                          & ((1 << zn) - 1);                      bsLiveShadow -= zn;                        while (zvec > limit_zt[zn])                      {                          zn++;                          while (bsLiveShadow < 1)                          {                              int thech = this.input.ReadByte();                              if (thech >= 0)                              {                                  bsBuffShadow = (bsBuffShadow << 8) | thech;                                  bsLiveShadow += 8;                                  continue;                              }                              else                              {                                  throw new IOException("unexpected end of stream");                              }                          }                          bsLiveShadow--;                          zvec = (zvec << 1) | ((bsBuffShadow >> bsLiveShadow) & 1);                      }                      nextSym = perm_zt[zvec - base_zt[zn]];                  }              }
Magic Number,Ionic.BZip2,BZip2InputStream,C:\repos\haf_DotNetZip.Semverd\src\BZip2\BZip2InputStream.cs,getAndMoveToFrontDecode,The following statement contains a magic number: while (nextSym != eob)              {                  if ((nextSym == BZip2.RUNA) || (nextSym == BZip2.RUNB))                  {                      int es = -1;                        for (int n = 1; true; n <<= 1)                      {                          if (nextSym == BZip2.RUNA)                          {                              es += n;                          }                          else if (nextSym == BZip2.RUNB)                          {                              es += n << 1;                          }                          else                          {                              break;                          }                            if (groupPos == 0)                          {                              groupPos = BZip2.G_SIZE - 1;                              zt = s.selector[++groupNo] & 0xff;                              base_zt = s.gBase[zt];                              limit_zt = s.gLimit[zt];                              perm_zt = s.gPerm[zt];                              minLens_zt = s.gMinlen[zt];                          }                          else                          {                              groupPos--;                          }                            int zn = minLens_zt;                            // Inlined:                          // int zvec = GetBits(zn);                          while (bsLiveShadow < zn)                          {                              int thech = this.input.ReadByte();                              if (thech >= 0)                              {                                  bsBuffShadow = (bsBuffShadow << 8) | thech;                                  bsLiveShadow += 8;                                  continue;                              }                              else                              {                                  throw new IOException("unexpected end of stream");                              }                          }                          int zvec = (bsBuffShadow >> (bsLiveShadow - zn))                              & ((1 << zn) - 1);                          bsLiveShadow -= zn;                            while (zvec > limit_zt[zn])                          {                              zn++;                              while (bsLiveShadow < 1)                              {                                  int thech = this.input.ReadByte();                                  if (thech >= 0)                                  {                                      bsBuffShadow = (bsBuffShadow << 8) | thech;                                      bsLiveShadow += 8;                                      continue;                                  }                                  else                                  {                                      throw new IOException("unexpected end of stream");                                  }                              }                              bsLiveShadow--;                              zvec = (zvec << 1)                                  | ((bsBuffShadow >> bsLiveShadow) & 1);                          }                          nextSym = perm_zt[zvec - base_zt[zn]];                      }                        byte ch = s.seqToUnseq[yy[0]];                      s.unzftab[ch & 0xff] += es + 1;                        while (es-- >= 0)                      {                          s.ll8[++lastShadow] = ch;                      }                        if (lastShadow >= limitLast)                          throw new IOException("block overrun");                  }                  else                  {                      if (++lastShadow >= limitLast)                          throw new IOException("block overrun");                        byte tmp = yy[nextSym - 1];                      s.unzftab[s.seqToUnseq[tmp] & 0xff]++;                      s.ll8[lastShadow] = s.seqToUnseq[tmp];                        /*                       * This loop is hammered during decompression' hence avoid                       * native method call overhead of System.Buffer.BlockCopy for very                       * small ranges to copy.                       */                      if (nextSym <= 16)                      {                          for (int j = nextSym - 1; j > 0;)                          {                              yy[j] = yy[--j];                          }                      }                      else                      {                          System.Buffer.BlockCopy(yy' 0' yy' 1' nextSym - 1);                      }                        yy[0] = tmp;                        if (groupPos == 0)                      {                          groupPos = BZip2.G_SIZE - 1;                          zt = s.selector[++groupNo] & 0xff;                          base_zt = s.gBase[zt];                          limit_zt = s.gLimit[zt];                          perm_zt = s.gPerm[zt];                          minLens_zt = s.gMinlen[zt];                      }                      else                      {                          groupPos--;                      }                        int zn = minLens_zt;                        // Inlined:                      // int zvec = GetBits(zn);                      while (bsLiveShadow < zn)                      {                          int thech = this.input.ReadByte();                          if (thech >= 0)                          {                              bsBuffShadow = (bsBuffShadow << 8) | thech;                              bsLiveShadow += 8;                              continue;                          }                          else                          {                              throw new IOException("unexpected end of stream");                          }                      }                      int zvec = (bsBuffShadow >> (bsLiveShadow - zn))                          & ((1 << zn) - 1);                      bsLiveShadow -= zn;                        while (zvec > limit_zt[zn])                      {                          zn++;                          while (bsLiveShadow < 1)                          {                              int thech = this.input.ReadByte();                              if (thech >= 0)                              {                                  bsBuffShadow = (bsBuffShadow << 8) | thech;                                  bsLiveShadow += 8;                                  continue;                              }                              else                              {                                  throw new IOException("unexpected end of stream");                              }                          }                          bsLiveShadow--;                          zvec = (zvec << 1) | ((bsBuffShadow >> bsLiveShadow) & 1);                      }                      nextSym = perm_zt[zvec - base_zt[zn]];                  }              }
Magic Number,Ionic.BZip2,BZip2InputStream,C:\repos\haf_DotNetZip.Semverd\src\BZip2\BZip2InputStream.cs,getAndMoveToFrontDecode,The following statement contains a magic number: while (nextSym != eob)              {                  if ((nextSym == BZip2.RUNA) || (nextSym == BZip2.RUNB))                  {                      int es = -1;                        for (int n = 1; true; n <<= 1)                      {                          if (nextSym == BZip2.RUNA)                          {                              es += n;                          }                          else if (nextSym == BZip2.RUNB)                          {                              es += n << 1;                          }                          else                          {                              break;                          }                            if (groupPos == 0)                          {                              groupPos = BZip2.G_SIZE - 1;                              zt = s.selector[++groupNo] & 0xff;                              base_zt = s.gBase[zt];                              limit_zt = s.gLimit[zt];                              perm_zt = s.gPerm[zt];                              minLens_zt = s.gMinlen[zt];                          }                          else                          {                              groupPos--;                          }                            int zn = minLens_zt;                            // Inlined:                          // int zvec = GetBits(zn);                          while (bsLiveShadow < zn)                          {                              int thech = this.input.ReadByte();                              if (thech >= 0)                              {                                  bsBuffShadow = (bsBuffShadow << 8) | thech;                                  bsLiveShadow += 8;                                  continue;                              }                              else                              {                                  throw new IOException("unexpected end of stream");                              }                          }                          int zvec = (bsBuffShadow >> (bsLiveShadow - zn))                              & ((1 << zn) - 1);                          bsLiveShadow -= zn;                            while (zvec > limit_zt[zn])                          {                              zn++;                              while (bsLiveShadow < 1)                              {                                  int thech = this.input.ReadByte();                                  if (thech >= 0)                                  {                                      bsBuffShadow = (bsBuffShadow << 8) | thech;                                      bsLiveShadow += 8;                                      continue;                                  }                                  else                                  {                                      throw new IOException("unexpected end of stream");                                  }                              }                              bsLiveShadow--;                              zvec = (zvec << 1)                                  | ((bsBuffShadow >> bsLiveShadow) & 1);                          }                          nextSym = perm_zt[zvec - base_zt[zn]];                      }                        byte ch = s.seqToUnseq[yy[0]];                      s.unzftab[ch & 0xff] += es + 1;                        while (es-- >= 0)                      {                          s.ll8[++lastShadow] = ch;                      }                        if (lastShadow >= limitLast)                          throw new IOException("block overrun");                  }                  else                  {                      if (++lastShadow >= limitLast)                          throw new IOException("block overrun");                        byte tmp = yy[nextSym - 1];                      s.unzftab[s.seqToUnseq[tmp] & 0xff]++;                      s.ll8[lastShadow] = s.seqToUnseq[tmp];                        /*                       * This loop is hammered during decompression' hence avoid                       * native method call overhead of System.Buffer.BlockCopy for very                       * small ranges to copy.                       */                      if (nextSym <= 16)                      {                          for (int j = nextSym - 1; j > 0;)                          {                              yy[j] = yy[--j];                          }                      }                      else                      {                          System.Buffer.BlockCopy(yy' 0' yy' 1' nextSym - 1);                      }                        yy[0] = tmp;                        if (groupPos == 0)                      {                          groupPos = BZip2.G_SIZE - 1;                          zt = s.selector[++groupNo] & 0xff;                          base_zt = s.gBase[zt];                          limit_zt = s.gLimit[zt];                          perm_zt = s.gPerm[zt];                          minLens_zt = s.gMinlen[zt];                      }                      else                      {                          groupPos--;                      }                        int zn = minLens_zt;                        // Inlined:                      // int zvec = GetBits(zn);                      while (bsLiveShadow < zn)                      {                          int thech = this.input.ReadByte();                          if (thech >= 0)                          {                              bsBuffShadow = (bsBuffShadow << 8) | thech;                              bsLiveShadow += 8;                              continue;                          }                          else                          {                              throw new IOException("unexpected end of stream");                          }                      }                      int zvec = (bsBuffShadow >> (bsLiveShadow - zn))                          & ((1 << zn) - 1);                      bsLiveShadow -= zn;                        while (zvec > limit_zt[zn])                      {                          zn++;                          while (bsLiveShadow < 1)                          {                              int thech = this.input.ReadByte();                              if (thech >= 0)                              {                                  bsBuffShadow = (bsBuffShadow << 8) | thech;                                  bsLiveShadow += 8;                                  continue;                              }                              else                              {                                  throw new IOException("unexpected end of stream");                              }                          }                          bsLiveShadow--;                          zvec = (zvec << 1) | ((bsBuffShadow >> bsLiveShadow) & 1);                      }                      nextSym = perm_zt[zvec - base_zt[zn]];                  }              }
Magic Number,Ionic.BZip2,BZip2InputStream,C:\repos\haf_DotNetZip.Semverd\src\BZip2\BZip2InputStream.cs,getAndMoveToFrontDecode,The following statement contains a magic number: while (nextSym != eob)              {                  if ((nextSym == BZip2.RUNA) || (nextSym == BZip2.RUNB))                  {                      int es = -1;                        for (int n = 1; true; n <<= 1)                      {                          if (nextSym == BZip2.RUNA)                          {                              es += n;                          }                          else if (nextSym == BZip2.RUNB)                          {                              es += n << 1;                          }                          else                          {                              break;                          }                            if (groupPos == 0)                          {                              groupPos = BZip2.G_SIZE - 1;                              zt = s.selector[++groupNo] & 0xff;                              base_zt = s.gBase[zt];                              limit_zt = s.gLimit[zt];                              perm_zt = s.gPerm[zt];                              minLens_zt = s.gMinlen[zt];                          }                          else                          {                              groupPos--;                          }                            int zn = minLens_zt;                            // Inlined:                          // int zvec = GetBits(zn);                          while (bsLiveShadow < zn)                          {                              int thech = this.input.ReadByte();                              if (thech >= 0)                              {                                  bsBuffShadow = (bsBuffShadow << 8) | thech;                                  bsLiveShadow += 8;                                  continue;                              }                              else                              {                                  throw new IOException("unexpected end of stream");                              }                          }                          int zvec = (bsBuffShadow >> (bsLiveShadow - zn))                              & ((1 << zn) - 1);                          bsLiveShadow -= zn;                            while (zvec > limit_zt[zn])                          {                              zn++;                              while (bsLiveShadow < 1)                              {                                  int thech = this.input.ReadByte();                                  if (thech >= 0)                                  {                                      bsBuffShadow = (bsBuffShadow << 8) | thech;                                      bsLiveShadow += 8;                                      continue;                                  }                                  else                                  {                                      throw new IOException("unexpected end of stream");                                  }                              }                              bsLiveShadow--;                              zvec = (zvec << 1)                                  | ((bsBuffShadow >> bsLiveShadow) & 1);                          }                          nextSym = perm_zt[zvec - base_zt[zn]];                      }                        byte ch = s.seqToUnseq[yy[0]];                      s.unzftab[ch & 0xff] += es + 1;                        while (es-- >= 0)                      {                          s.ll8[++lastShadow] = ch;                      }                        if (lastShadow >= limitLast)                          throw new IOException("block overrun");                  }                  else                  {                      if (++lastShadow >= limitLast)                          throw new IOException("block overrun");                        byte tmp = yy[nextSym - 1];                      s.unzftab[s.seqToUnseq[tmp] & 0xff]++;                      s.ll8[lastShadow] = s.seqToUnseq[tmp];                        /*                       * This loop is hammered during decompression' hence avoid                       * native method call overhead of System.Buffer.BlockCopy for very                       * small ranges to copy.                       */                      if (nextSym <= 16)                      {                          for (int j = nextSym - 1; j > 0;)                          {                              yy[j] = yy[--j];                          }                      }                      else                      {                          System.Buffer.BlockCopy(yy' 0' yy' 1' nextSym - 1);                      }                        yy[0] = tmp;                        if (groupPos == 0)                      {                          groupPos = BZip2.G_SIZE - 1;                          zt = s.selector[++groupNo] & 0xff;                          base_zt = s.gBase[zt];                          limit_zt = s.gLimit[zt];                          perm_zt = s.gPerm[zt];                          minLens_zt = s.gMinlen[zt];                      }                      else                      {                          groupPos--;                      }                        int zn = minLens_zt;                        // Inlined:                      // int zvec = GetBits(zn);                      while (bsLiveShadow < zn)                      {                          int thech = this.input.ReadByte();                          if (thech >= 0)                          {                              bsBuffShadow = (bsBuffShadow << 8) | thech;                              bsLiveShadow += 8;                              continue;                          }                          else                          {                              throw new IOException("unexpected end of stream");                          }                      }                      int zvec = (bsBuffShadow >> (bsLiveShadow - zn))                          & ((1 << zn) - 1);                      bsLiveShadow -= zn;                        while (zvec > limit_zt[zn])                      {                          zn++;                          while (bsLiveShadow < 1)                          {                              int thech = this.input.ReadByte();                              if (thech >= 0)                              {                                  bsBuffShadow = (bsBuffShadow << 8) | thech;                                  bsLiveShadow += 8;                                  continue;                              }                              else                              {                                  throw new IOException("unexpected end of stream");                              }                          }                          bsLiveShadow--;                          zvec = (zvec << 1) | ((bsBuffShadow >> bsLiveShadow) & 1);                      }                      nextSym = perm_zt[zvec - base_zt[zn]];                  }              }
Magic Number,Ionic.BZip2,BZip2InputStream,C:\repos\haf_DotNetZip.Semverd\src\BZip2\BZip2InputStream.cs,getAndMoveToFrontDecode0,The following statement contains a magic number: while (zvec > limit_zt[zn])              {                  zn++;                  while (bsLiveShadow < 1)                  {                      int thech = this.input.ReadByte();                        if (thech >= 0)                      {                          bsBuffShadow = (bsBuffShadow << 8) | thech;                          bsLiveShadow += 8;                          continue;                      }                      else                      {                          throw new IOException("unexpected end of stream");                      }                  }                  bsLiveShadow--;                  zvec = (zvec << 1) | ((bsBuffShadow >> bsLiveShadow) & 1);              }
Magic Number,Ionic.BZip2,BZip2InputStream,C:\repos\haf_DotNetZip.Semverd\src\BZip2\BZip2InputStream.cs,getAndMoveToFrontDecode0,The following statement contains a magic number: while (zvec > limit_zt[zn])              {                  zn++;                  while (bsLiveShadow < 1)                  {                      int thech = this.input.ReadByte();                        if (thech >= 0)                      {                          bsBuffShadow = (bsBuffShadow << 8) | thech;                          bsLiveShadow += 8;                          continue;                      }                      else                      {                          throw new IOException("unexpected end of stream");                      }                  }                  bsLiveShadow--;                  zvec = (zvec << 1) | ((bsBuffShadow >> bsLiveShadow) & 1);              }
Magic Number,Ionic.BZip2,BZip2InputStream,C:\repos\haf_DotNetZip.Semverd\src\BZip2\BZip2InputStream.cs,SetupBlock,The following statement contains a magic number: for (i = 0; i <= 255; i++)              {                  if (s.unzftab[i] < 0 || s.unzftab[i] > this.last)                      throw new Exception("BZ_DATA_ERROR");              }
Magic Number,Ionic.BZip2,BZip2InputStream,C:\repos\haf_DotNetZip.Semverd\src\BZip2\BZip2InputStream.cs,SetupBlock,The following statement contains a magic number: for (i = 1; i <= 256; i++) s.cftab[i] = s.unzftab[i-1];
Magic Number,Ionic.BZip2,BZip2InputStream,C:\repos\haf_DotNetZip.Semverd\src\BZip2\BZip2InputStream.cs,SetupBlock,The following statement contains a magic number: for (i = 1; i <= 256; i++) s.cftab[i] += s.cftab[i-1];
Magic Number,Ionic.BZip2,BZip2InputStream,C:\repos\haf_DotNetZip.Semverd\src\BZip2\BZip2InputStream.cs,SetupBlock,The following statement contains a magic number: for (i = 0; i <= 256; i++)              {                  if (s.cftab[i] < 0 || s.cftab[i] > this.last+1)                  {                      var msg = String.Format("BZ_DATA_ERROR: cftab[{0}]={1} last={2}"'                                              i' s.cftab[i]' this.last);                      throw new Exception(msg);                  }              }
Magic Number,Ionic.BZip2,BZip2InputStream,C:\repos\haf_DotNetZip.Semverd\src\BZip2\BZip2InputStream.cs,SetupBlock,The following statement contains a magic number: for (i = 1; i <= 256; i++)              {                  if (s.cftab[i-1] > s.cftab[i])                      throw new Exception("BZ_DATA_ERROR");              }
Magic Number,Ionic.BZip2,BZip2InputStream,C:\repos\haf_DotNetZip.Semverd\src\BZip2\BZip2InputStream.cs,SetupBlock,The following statement contains a magic number: this.su_ch2 = 256;
Magic Number,Ionic.BZip2,BZip2InputStream,C:\repos\haf_DotNetZip.Semverd\src\BZip2\BZip2InputStream.cs,SetupRandPartA,The following statement contains a magic number: if (this.su_i2 <= this.last)              {                  this.su_chPrev = this.su_ch2;                  int su_ch2Shadow = this.data.ll8[this.su_tPos] & 0xff;                  this.su_tPos = this.data.tt[this.su_tPos];                  if (this.su_rNToGo == 0)                  {                      this.su_rNToGo = Rand.Rnums(this.su_rTPos) - 1;                      if (++this.su_rTPos == 512)                      {                          this.su_rTPos = 0;                      }                  }                  else                  {                      this.su_rNToGo--;                  }                  this.su_ch2 = su_ch2Shadow ^= (this.su_rNToGo == 1) ? 1 : 0;                  this.su_i2++;                  this.currentChar = su_ch2Shadow;                  this.currentState = CState.RAND_PART_B;                  this.crc.UpdateCRC((byte)su_ch2Shadow);              }              else              {                  EndBlock();                  InitBlock();                  SetupBlock();              }
Magic Number,Ionic.BZip2,BZip2InputStream,C:\repos\haf_DotNetZip.Semverd\src\BZip2\BZip2InputStream.cs,SetupRandPartB,The following statement contains a magic number: if (this.su_ch2 != this.su_chPrev)              {                  this.currentState = CState.RAND_PART_A;                  this.su_count = 1;                  SetupRandPartA();              }              else if (++this.su_count >= 4)              {                  this.su_z = (char) (this.data.ll8[this.su_tPos] & 0xff);                  this.su_tPos = this.data.tt[this.su_tPos];                  if (this.su_rNToGo == 0)                  {                      this.su_rNToGo = Rand.Rnums(this.su_rTPos) - 1;                      if (++this.su_rTPos == 512)                      {                          this.su_rTPos = 0;                      }                  }                  else                  {                      this.su_rNToGo--;                  }                  this.su_j2 = 0;                  this.currentState = CState.RAND_PART_C;                  if (this.su_rNToGo == 1)                  {                      this.su_z ^= (char)1;                  }                  SetupRandPartC();              }              else              {                  this.currentState = CState.RAND_PART_A;                  SetupRandPartA();              }
Magic Number,Ionic.BZip2,BZip2InputStream,C:\repos\haf_DotNetZip.Semverd\src\BZip2\BZip2InputStream.cs,SetupRandPartB,The following statement contains a magic number: if (this.su_ch2 != this.su_chPrev)              {                  this.currentState = CState.RAND_PART_A;                  this.su_count = 1;                  SetupRandPartA();              }              else if (++this.su_count >= 4)              {                  this.su_z = (char) (this.data.ll8[this.su_tPos] & 0xff);                  this.su_tPos = this.data.tt[this.su_tPos];                  if (this.su_rNToGo == 0)                  {                      this.su_rNToGo = Rand.Rnums(this.su_rTPos) - 1;                      if (++this.su_rTPos == 512)                      {                          this.su_rTPos = 0;                      }                  }                  else                  {                      this.su_rNToGo--;                  }                  this.su_j2 = 0;                  this.currentState = CState.RAND_PART_C;                  if (this.su_rNToGo == 1)                  {                      this.su_z ^= (char)1;                  }                  SetupRandPartC();              }              else              {                  this.currentState = CState.RAND_PART_A;                  SetupRandPartA();              }
Magic Number,Ionic.BZip2,BZip2InputStream,C:\repos\haf_DotNetZip.Semverd\src\BZip2\BZip2InputStream.cs,SetupNoRandPartB,The following statement contains a magic number: if (this.su_ch2 != this.su_chPrev)              {                  this.su_count = 1;                  SetupNoRandPartA();              }              else if (++this.su_count >= 4)              {                  this.su_z = (char) (this.data.ll8[this.su_tPos] & 0xff);                  this.su_tPos = this.data.tt[this.su_tPos];                  this.su_j2 = 0;                  SetupNoRandPartC();              }              else              {                  SetupNoRandPartA();              }
Magic Number,Ionic.BZip2,DecompressionState,C:\repos\haf_DotNetZip.Semverd\src\BZip2\BZip2InputStream.cs,DecompressionState,The following statement contains a magic number: this.unzftab = new int[256];
Magic Number,Ionic.BZip2,DecompressionState,C:\repos\haf_DotNetZip.Semverd\src\BZip2\BZip2InputStream.cs,DecompressionState,The following statement contains a magic number: this.cftab = new int[257];
Magic Number,Ionic.BZip2,DecompressionState,C:\repos\haf_DotNetZip.Semverd\src\BZip2\BZip2InputStream.cs,DecompressionState,The following statement contains a magic number: this.getAndMoveToFrontDecode_yy = new byte[256];
Magic Number,Ionic.BZip2,BZip2Compressor,C:\repos\haf_DotNetZip.Semverd\src\BZip2\BZip2Compressor.cs,BZip2Compressor,The following statement contains a magic number: this.outBlockFillThreshold = (blockSize * BZip2.BlockSizeMultiple) - 20;
Magic Number,Ionic.BZip2,BZip2Compressor,C:\repos\haf_DotNetZip.Semverd\src\BZip2\BZip2Compressor.cs,Reset,The following statement contains a magic number: for (int i = 256; --i >= 0;)                  this.cstate.inUse[i] = false;
Magic Number,Ionic.BZip2,BZip2Compressor,C:\repos\haf_DotNetZip.Semverd\src\BZip2\BZip2Compressor.cs,write0,The following statement contains a magic number: if (this.currentByte == b)              {                  if (++this.runLength > 254)                  {                      rc = AddRunToOutputBlock(false);                      this.currentByte = -1;                      this.runLength = 0;                      return (rc) ? 2 : 1;                  }                  return 1; // not full              }
Magic Number,Ionic.BZip2,BZip2Compressor,C:\repos\haf_DotNetZip.Semverd\src\BZip2\BZip2Compressor.cs,write0,The following statement contains a magic number: if (this.currentByte == b)              {                  if (++this.runLength > 254)                  {                      rc = AddRunToOutputBlock(false);                      this.currentByte = -1;                      this.runLength = 0;                      return (rc) ? 2 : 1;                  }                  return 1; // not full              }
Magic Number,Ionic.BZip2,BZip2Compressor,C:\repos\haf_DotNetZip.Semverd\src\BZip2\BZip2Compressor.cs,AddRunToOutputBlock,The following statement contains a magic number: switch (rl)              {                  case 1:                      block[previousLast + 2] = b;                      this.last = previousLast + 1;                      break;                    case 2:                      block[previousLast + 2] = b;                      block[previousLast + 3] = b;                      this.last = previousLast + 2;                      break;                    case 3:                      block[previousLast + 2] = b;                      block[previousLast + 3] = b;                      block[previousLast + 4] = b;                      this.last = previousLast + 3;                      break;                    default:                      rl -= 4;                      this.cstate.inUse[rl] = true;                      block[previousLast + 2] = b;                      block[previousLast + 3] = b;                      block[previousLast + 4] = b;                      block[previousLast + 5] = b;                      block[previousLast + 6] = (byte) rl;                      this.last = previousLast + 5;                      break;              }
Magic Number,Ionic.BZip2,BZip2Compressor,C:\repos\haf_DotNetZip.Semverd\src\BZip2\BZip2Compressor.cs,AddRunToOutputBlock,The following statement contains a magic number: switch (rl)              {                  case 1:                      block[previousLast + 2] = b;                      this.last = previousLast + 1;                      break;                    case 2:                      block[previousLast + 2] = b;                      block[previousLast + 3] = b;                      this.last = previousLast + 2;                      break;                    case 3:                      block[previousLast + 2] = b;                      block[previousLast + 3] = b;                      block[previousLast + 4] = b;                      this.last = previousLast + 3;                      break;                    default:                      rl -= 4;                      this.cstate.inUse[rl] = true;                      block[previousLast + 2] = b;                      block[previousLast + 3] = b;                      block[previousLast + 4] = b;                      block[previousLast + 5] = b;                      block[previousLast + 6] = (byte) rl;                      this.last = previousLast + 5;                      break;              }
Magic Number,Ionic.BZip2,BZip2Compressor,C:\repos\haf_DotNetZip.Semverd\src\BZip2\BZip2Compressor.cs,AddRunToOutputBlock,The following statement contains a magic number: switch (rl)              {                  case 1:                      block[previousLast + 2] = b;                      this.last = previousLast + 1;                      break;                    case 2:                      block[previousLast + 2] = b;                      block[previousLast + 3] = b;                      this.last = previousLast + 2;                      break;                    case 3:                      block[previousLast + 2] = b;                      block[previousLast + 3] = b;                      block[previousLast + 4] = b;                      this.last = previousLast + 3;                      break;                    default:                      rl -= 4;                      this.cstate.inUse[rl] = true;                      block[previousLast + 2] = b;                      block[previousLast + 3] = b;                      block[previousLast + 4] = b;                      block[previousLast + 5] = b;                      block[previousLast + 6] = (byte) rl;                      this.last = previousLast + 5;                      break;              }
Magic Number,Ionic.BZip2,BZip2Compressor,C:\repos\haf_DotNetZip.Semverd\src\BZip2\BZip2Compressor.cs,AddRunToOutputBlock,The following statement contains a magic number: switch (rl)              {                  case 1:                      block[previousLast + 2] = b;                      this.last = previousLast + 1;                      break;                    case 2:                      block[previousLast + 2] = b;                      block[previousLast + 3] = b;                      this.last = previousLast + 2;                      break;                    case 3:                      block[previousLast + 2] = b;                      block[previousLast + 3] = b;                      block[previousLast + 4] = b;                      this.last = previousLast + 3;                      break;                    default:                      rl -= 4;                      this.cstate.inUse[rl] = true;                      block[previousLast + 2] = b;                      block[previousLast + 3] = b;                      block[previousLast + 4] = b;                      block[previousLast + 5] = b;                      block[previousLast + 6] = (byte) rl;                      this.last = previousLast + 5;                      break;              }
Magic Number,Ionic.BZip2,BZip2Compressor,C:\repos\haf_DotNetZip.Semverd\src\BZip2\BZip2Compressor.cs,AddRunToOutputBlock,The following statement contains a magic number: switch (rl)              {                  case 1:                      block[previousLast + 2] = b;                      this.last = previousLast + 1;                      break;                    case 2:                      block[previousLast + 2] = b;                      block[previousLast + 3] = b;                      this.last = previousLast + 2;                      break;                    case 3:                      block[previousLast + 2] = b;                      block[previousLast + 3] = b;                      block[previousLast + 4] = b;                      this.last = previousLast + 3;                      break;                    default:                      rl -= 4;                      this.cstate.inUse[rl] = true;                      block[previousLast + 2] = b;                      block[previousLast + 3] = b;                      block[previousLast + 4] = b;                      block[previousLast + 5] = b;                      block[previousLast + 6] = (byte) rl;                      this.last = previousLast + 5;                      break;              }
Magic Number,Ionic.BZip2,BZip2Compressor,C:\repos\haf_DotNetZip.Semverd\src\BZip2\BZip2Compressor.cs,AddRunToOutputBlock,The following statement contains a magic number: switch (rl)              {                  case 1:                      block[previousLast + 2] = b;                      this.last = previousLast + 1;                      break;                    case 2:                      block[previousLast + 2] = b;                      block[previousLast + 3] = b;                      this.last = previousLast + 2;                      break;                    case 3:                      block[previousLast + 2] = b;                      block[previousLast + 3] = b;                      block[previousLast + 4] = b;                      this.last = previousLast + 3;                      break;                    default:                      rl -= 4;                      this.cstate.inUse[rl] = true;                      block[previousLast + 2] = b;                      block[previousLast + 3] = b;                      block[previousLast + 4] = b;                      block[previousLast + 5] = b;                      block[previousLast + 6] = (byte) rl;                      this.last = previousLast + 5;                      break;              }
Magic Number,Ionic.BZip2,BZip2Compressor,C:\repos\haf_DotNetZip.Semverd\src\BZip2\BZip2Compressor.cs,AddRunToOutputBlock,The following statement contains a magic number: switch (rl)              {                  case 1:                      block[previousLast + 2] = b;                      this.last = previousLast + 1;                      break;                    case 2:                      block[previousLast + 2] = b;                      block[previousLast + 3] = b;                      this.last = previousLast + 2;                      break;                    case 3:                      block[previousLast + 2] = b;                      block[previousLast + 3] = b;                      block[previousLast + 4] = b;                      this.last = previousLast + 3;                      break;                    default:                      rl -= 4;                      this.cstate.inUse[rl] = true;                      block[previousLast + 2] = b;                      block[previousLast + 3] = b;                      block[previousLast + 4] = b;                      block[previousLast + 5] = b;                      block[previousLast + 6] = (byte) rl;                      this.last = previousLast + 5;                      break;              }
Magic Number,Ionic.BZip2,BZip2Compressor,C:\repos\haf_DotNetZip.Semverd\src\BZip2\BZip2Compressor.cs,AddRunToOutputBlock,The following statement contains a magic number: switch (rl)              {                  case 1:                      block[previousLast + 2] = b;                      this.last = previousLast + 1;                      break;                    case 2:                      block[previousLast + 2] = b;                      block[previousLast + 3] = b;                      this.last = previousLast + 2;                      break;                    case 3:                      block[previousLast + 2] = b;                      block[previousLast + 3] = b;                      block[previousLast + 4] = b;                      this.last = previousLast + 3;                      break;                    default:                      rl -= 4;                      this.cstate.inUse[rl] = true;                      block[previousLast + 2] = b;                      block[previousLast + 3] = b;                      block[previousLast + 4] = b;                      block[previousLast + 5] = b;                      block[previousLast + 6] = (byte) rl;                      this.last = previousLast + 5;                      break;              }
Magic Number,Ionic.BZip2,BZip2Compressor,C:\repos\haf_DotNetZip.Semverd\src\BZip2\BZip2Compressor.cs,AddRunToOutputBlock,The following statement contains a magic number: switch (rl)              {                  case 1:                      block[previousLast + 2] = b;                      this.last = previousLast + 1;                      break;                    case 2:                      block[previousLast + 2] = b;                      block[previousLast + 3] = b;                      this.last = previousLast + 2;                      break;                    case 3:                      block[previousLast + 2] = b;                      block[previousLast + 3] = b;                      block[previousLast + 4] = b;                      this.last = previousLast + 3;                      break;                    default:                      rl -= 4;                      this.cstate.inUse[rl] = true;                      block[previousLast + 2] = b;                      block[previousLast + 3] = b;                      block[previousLast + 4] = b;                      block[previousLast + 5] = b;                      block[previousLast + 6] = (byte) rl;                      this.last = previousLast + 5;                      break;              }
Magic Number,Ionic.BZip2,BZip2Compressor,C:\repos\haf_DotNetZip.Semverd\src\BZip2\BZip2Compressor.cs,AddRunToOutputBlock,The following statement contains a magic number: switch (rl)              {                  case 1:                      block[previousLast + 2] = b;                      this.last = previousLast + 1;                      break;                    case 2:                      block[previousLast + 2] = b;                      block[previousLast + 3] = b;                      this.last = previousLast + 2;                      break;                    case 3:                      block[previousLast + 2] = b;                      block[previousLast + 3] = b;                      block[previousLast + 4] = b;                      this.last = previousLast + 3;                      break;                    default:                      rl -= 4;                      this.cstate.inUse[rl] = true;                      block[previousLast + 2] = b;                      block[previousLast + 3] = b;                      block[previousLast + 4] = b;                      block[previousLast + 5] = b;                      block[previousLast + 6] = (byte) rl;                      this.last = previousLast + 5;                      break;              }
Magic Number,Ionic.BZip2,BZip2Compressor,C:\repos\haf_DotNetZip.Semverd\src\BZip2\BZip2Compressor.cs,AddRunToOutputBlock,The following statement contains a magic number: switch (rl)              {                  case 1:                      block[previousLast + 2] = b;                      this.last = previousLast + 1;                      break;                    case 2:                      block[previousLast + 2] = b;                      block[previousLast + 3] = b;                      this.last = previousLast + 2;                      break;                    case 3:                      block[previousLast + 2] = b;                      block[previousLast + 3] = b;                      block[previousLast + 4] = b;                      this.last = previousLast + 3;                      break;                    default:                      rl -= 4;                      this.cstate.inUse[rl] = true;                      block[previousLast + 2] = b;                      block[previousLast + 3] = b;                      block[previousLast + 4] = b;                      block[previousLast + 5] = b;                      block[previousLast + 6] = (byte) rl;                      this.last = previousLast + 5;                      break;              }
Magic Number,Ionic.BZip2,BZip2Compressor,C:\repos\haf_DotNetZip.Semverd\src\BZip2\BZip2Compressor.cs,AddRunToOutputBlock,The following statement contains a magic number: switch (rl)              {                  case 1:                      block[previousLast + 2] = b;                      this.last = previousLast + 1;                      break;                    case 2:                      block[previousLast + 2] = b;                      block[previousLast + 3] = b;                      this.last = previousLast + 2;                      break;                    case 3:                      block[previousLast + 2] = b;                      block[previousLast + 3] = b;                      block[previousLast + 4] = b;                      this.last = previousLast + 3;                      break;                    default:                      rl -= 4;                      this.cstate.inUse[rl] = true;                      block[previousLast + 2] = b;                      block[previousLast + 3] = b;                      block[previousLast + 4] = b;                      block[previousLast + 5] = b;                      block[previousLast + 6] = (byte) rl;                      this.last = previousLast + 5;                      break;              }
Magic Number,Ionic.BZip2,BZip2Compressor,C:\repos\haf_DotNetZip.Semverd\src\BZip2\BZip2Compressor.cs,AddRunToOutputBlock,The following statement contains a magic number: switch (rl)              {                  case 1:                      block[previousLast + 2] = b;                      this.last = previousLast + 1;                      break;                    case 2:                      block[previousLast + 2] = b;                      block[previousLast + 3] = b;                      this.last = previousLast + 2;                      break;                    case 3:                      block[previousLast + 2] = b;                      block[previousLast + 3] = b;                      block[previousLast + 4] = b;                      this.last = previousLast + 3;                      break;                    default:                      rl -= 4;                      this.cstate.inUse[rl] = true;                      block[previousLast + 2] = b;                      block[previousLast + 3] = b;                      block[previousLast + 4] = b;                      block[previousLast + 5] = b;                      block[previousLast + 6] = (byte) rl;                      this.last = previousLast + 5;                      break;              }
Magic Number,Ionic.BZip2,BZip2Compressor,C:\repos\haf_DotNetZip.Semverd\src\BZip2\BZip2Compressor.cs,AddRunToOutputBlock,The following statement contains a magic number: switch (rl)              {                  case 1:                      block[previousLast + 2] = b;                      this.last = previousLast + 1;                      break;                    case 2:                      block[previousLast + 2] = b;                      block[previousLast + 3] = b;                      this.last = previousLast + 2;                      break;                    case 3:                      block[previousLast + 2] = b;                      block[previousLast + 3] = b;                      block[previousLast + 4] = b;                      this.last = previousLast + 3;                      break;                    default:                      rl -= 4;                      this.cstate.inUse[rl] = true;                      block[previousLast + 2] = b;                      block[previousLast + 3] = b;                      block[previousLast + 4] = b;                      block[previousLast + 5] = b;                      block[previousLast + 6] = (byte) rl;                      this.last = previousLast + 5;                      break;              }
Magic Number,Ionic.BZip2,BZip2Compressor,C:\repos\haf_DotNetZip.Semverd\src\BZip2\BZip2Compressor.cs,AddRunToOutputBlock,The following statement contains a magic number: switch (rl)              {                  case 1:                      block[previousLast + 2] = b;                      this.last = previousLast + 1;                      break;                    case 2:                      block[previousLast + 2] = b;                      block[previousLast + 3] = b;                      this.last = previousLast + 2;                      break;                    case 3:                      block[previousLast + 2] = b;                      block[previousLast + 3] = b;                      block[previousLast + 4] = b;                      this.last = previousLast + 3;                      break;                    default:                      rl -= 4;                      this.cstate.inUse[rl] = true;                      block[previousLast + 2] = b;                      block[previousLast + 3] = b;                      block[previousLast + 4] = b;                      block[previousLast + 5] = b;                      block[previousLast + 6] = (byte) rl;                      this.last = previousLast + 5;                      break;              }
Magic Number,Ionic.BZip2,BZip2Compressor,C:\repos\haf_DotNetZip.Semverd\src\BZip2\BZip2Compressor.cs,AddRunToOutputBlock,The following statement contains a magic number: switch (rl)              {                  case 1:                      block[previousLast + 2] = b;                      this.last = previousLast + 1;                      break;                    case 2:                      block[previousLast + 2] = b;                      block[previousLast + 3] = b;                      this.last = previousLast + 2;                      break;                    case 3:                      block[previousLast + 2] = b;                      block[previousLast + 3] = b;                      block[previousLast + 4] = b;                      this.last = previousLast + 3;                      break;                    default:                      rl -= 4;                      this.cstate.inUse[rl] = true;                      block[previousLast + 2] = b;                      block[previousLast + 3] = b;                      block[previousLast + 4] = b;                      block[previousLast + 5] = b;                      block[previousLast + 6] = (byte) rl;                      this.last = previousLast + 5;                      break;              }
Magic Number,Ionic.BZip2,BZip2Compressor,C:\repos\haf_DotNetZip.Semverd\src\BZip2\BZip2Compressor.cs,AddRunToOutputBlock,The following statement contains a magic number: switch (rl)              {                  case 1:                      block[previousLast + 2] = b;                      this.last = previousLast + 1;                      break;                    case 2:                      block[previousLast + 2] = b;                      block[previousLast + 3] = b;                      this.last = previousLast + 2;                      break;                    case 3:                      block[previousLast + 2] = b;                      block[previousLast + 3] = b;                      block[previousLast + 4] = b;                      this.last = previousLast + 3;                      break;                    default:                      rl -= 4;                      this.cstate.inUse[rl] = true;                      block[previousLast + 2] = b;                      block[previousLast + 3] = b;                      block[previousLast + 4] = b;                      block[previousLast + 5] = b;                      block[previousLast + 6] = (byte) rl;                      this.last = previousLast + 5;                      break;              }
Magic Number,Ionic.BZip2,BZip2Compressor,C:\repos\haf_DotNetZip.Semverd\src\BZip2\BZip2Compressor.cs,randomiseBlock,The following statement contains a magic number: for (int i = 256; --i >= 0;)                  inUse[i] = false;
Magic Number,Ionic.BZip2,BZip2Compressor,C:\repos\haf_DotNetZip.Semverd\src\BZip2\BZip2Compressor.cs,randomiseBlock,The following statement contains a magic number: for (int i = 0' j = 1; i <= lastShadow; i = j' j++)              {                  if (rNToGo == 0)                  {                      rNToGo = (char) Rand.Rnums(rTPos);                      if (++rTPos == 512)                      {                          rTPos = 0;                      }                  }                    rNToGo--;                  block[j] ^= (byte) ((rNToGo == 1) ? 1 : 0);                    // handle 16 bit signed numbers                  inUse[block[j] & 0xff] = true;              }
Magic Number,Ionic.BZip2,BZip2Compressor,C:\repos\haf_DotNetZip.Semverd\src\BZip2\BZip2Compressor.cs,mainSort,The following statement contains a magic number: for (int i = 65537; --i >= 0;)              {                  ftab[i] = 0;              }
Magic Number,Ionic.BZip2,BZip2Compressor,C:\repos\haf_DotNetZip.Semverd\src\BZip2\BZip2Compressor.cs,mainSort,The following statement contains a magic number: for (int i = 0; i < BZip2.NUM_OVERSHOOT_BYTES; i++)              {                  block[lastShadow + i + 2] = block[(i % (lastShadow + 1)) + 1];              }
Magic Number,Ionic.BZip2,BZip2Compressor,C:\repos\haf_DotNetZip.Semverd\src\BZip2\BZip2Compressor.cs,mainSort,The following statement contains a magic number: for (int i = 0; i <= lastShadow; i++)              {                  int c2 = block[i + 1] & 0xff;                  ftab[(c1 << 8) + c2]++;                  c1 = c2;              }
Magic Number,Ionic.BZip2,BZip2Compressor,C:\repos\haf_DotNetZip.Semverd\src\BZip2\BZip2Compressor.cs,mainSort,The following statement contains a magic number: for (int i = 1; i <= 65536; i++)                  ftab[i] += ftab[i - 1];
Magic Number,Ionic.BZip2,BZip2Compressor,C:\repos\haf_DotNetZip.Semverd\src\BZip2\BZip2Compressor.cs,mainSort,The following statement contains a magic number: for (int i = 0; i < lastShadow; i++)              {                  int c2 = block[i + 2] & 0xff;                  fmap[--ftab[(c1 << 8) + c2]] = i;                  c1 = c2;              }
Magic Number,Ionic.BZip2,BZip2Compressor,C:\repos\haf_DotNetZip.Semverd\src\BZip2\BZip2Compressor.cs,mainSort,The following statement contains a magic number: for (int i = 0; i < lastShadow; i++)              {                  int c2 = block[i + 2] & 0xff;                  fmap[--ftab[(c1 << 8) + c2]] = i;                  c1 = c2;              }
Magic Number,Ionic.BZip2,BZip2Compressor,C:\repos\haf_DotNetZip.Semverd\src\BZip2\BZip2Compressor.cs,mainSort,The following statement contains a magic number: fmap[--ftab[((block[lastShadow + 1] & 0xff) << 8) + (block[1] & 0xff)]] = lastShadow;
Magic Number,Ionic.BZip2,BZip2Compressor,C:\repos\haf_DotNetZip.Semverd\src\BZip2\BZip2Compressor.cs,mainSort,The following statement contains a magic number: for (int i = 256; --i >= 0;)              {                  bigDone[i] = false;                  runningOrder[i] = i;              }
Magic Number,Ionic.BZip2,BZip2Compressor,C:\repos\haf_DotNetZip.Semverd\src\BZip2\BZip2Compressor.cs,mainSort,The following statement contains a magic number: for (int h = 364; h != 1;)              {                  h /= 3;                  for (int i = h; i <= 255; i++)                  {                      int vv = runningOrder[i];                      int a = ftab[(vv + 1) << 8] - ftab[vv << 8];                      int b = h - 1;                      int j = i;                      for (int ro = runningOrder[j - h]; (ftab[(ro + 1) << 8] - ftab[ro << 8]) > a; ro = runningOrder[j                                                                                                                      - h])                      {                          runningOrder[j] = ro;                          j -= h;                          if (j <= b)                          {                              break;                          }                      }                      runningOrder[j] = vv;                  }              }
Magic Number,Ionic.BZip2,BZip2Compressor,C:\repos\haf_DotNetZip.Semverd\src\BZip2\BZip2Compressor.cs,mainSort,The following statement contains a magic number: for (int h = 364; h != 1;)              {                  h /= 3;                  for (int i = h; i <= 255; i++)                  {                      int vv = runningOrder[i];                      int a = ftab[(vv + 1) << 8] - ftab[vv << 8];                      int b = h - 1;                      int j = i;                      for (int ro = runningOrder[j - h]; (ftab[(ro + 1) << 8] - ftab[ro << 8]) > a; ro = runningOrder[j                                                                                                                      - h])                      {                          runningOrder[j] = ro;                          j -= h;                          if (j <= b)                          {                              break;                          }                      }                      runningOrder[j] = vv;                  }              }
Magic Number,Ionic.BZip2,BZip2Compressor,C:\repos\haf_DotNetZip.Semverd\src\BZip2\BZip2Compressor.cs,mainSort,The following statement contains a magic number: for (int h = 364; h != 1;)              {                  h /= 3;                  for (int i = h; i <= 255; i++)                  {                      int vv = runningOrder[i];                      int a = ftab[(vv + 1) << 8] - ftab[vv << 8];                      int b = h - 1;                      int j = i;                      for (int ro = runningOrder[j - h]; (ftab[(ro + 1) << 8] - ftab[ro << 8]) > a; ro = runningOrder[j                                                                                                                      - h])                      {                          runningOrder[j] = ro;                          j -= h;                          if (j <= b)                          {                              break;                          }                      }                      runningOrder[j] = vv;                  }              }
Magic Number,Ionic.BZip2,BZip2Compressor,C:\repos\haf_DotNetZip.Semverd\src\BZip2\BZip2Compressor.cs,mainSort,The following statement contains a magic number: for (int h = 364; h != 1;)              {                  h /= 3;                  for (int i = h; i <= 255; i++)                  {                      int vv = runningOrder[i];                      int a = ftab[(vv + 1) << 8] - ftab[vv << 8];                      int b = h - 1;                      int j = i;                      for (int ro = runningOrder[j - h]; (ftab[(ro + 1) << 8] - ftab[ro << 8]) > a; ro = runningOrder[j                                                                                                                      - h])                      {                          runningOrder[j] = ro;                          j -= h;                          if (j <= b)                          {                              break;                          }                      }                      runningOrder[j] = vv;                  }              }
Magic Number,Ionic.BZip2,BZip2Compressor,C:\repos\haf_DotNetZip.Semverd\src\BZip2\BZip2Compressor.cs,mainSort,The following statement contains a magic number: for (int h = 364; h != 1;)              {                  h /= 3;                  for (int i = h; i <= 255; i++)                  {                      int vv = runningOrder[i];                      int a = ftab[(vv + 1) << 8] - ftab[vv << 8];                      int b = h - 1;                      int j = i;                      for (int ro = runningOrder[j - h]; (ftab[(ro + 1) << 8] - ftab[ro << 8]) > a; ro = runningOrder[j                                                                                                                      - h])                      {                          runningOrder[j] = ro;                          j -= h;                          if (j <= b)                          {                              break;                          }                      }                      runningOrder[j] = vv;                  }              }
Magic Number,Ionic.BZip2,BZip2Compressor,C:\repos\haf_DotNetZip.Semverd\src\BZip2\BZip2Compressor.cs,mainSort,The following statement contains a magic number: for (int h = 364; h != 1;)              {                  h /= 3;                  for (int i = h; i <= 255; i++)                  {                      int vv = runningOrder[i];                      int a = ftab[(vv + 1) << 8] - ftab[vv << 8];                      int b = h - 1;                      int j = i;                      for (int ro = runningOrder[j - h]; (ftab[(ro + 1) << 8] - ftab[ro << 8]) > a; ro = runningOrder[j                                                                                                                      - h])                      {                          runningOrder[j] = ro;                          j -= h;                          if (j <= b)                          {                              break;                          }                      }                      runningOrder[j] = vv;                  }              }
Magic Number,Ionic.BZip2,BZip2Compressor,C:\repos\haf_DotNetZip.Semverd\src\BZip2\BZip2Compressor.cs,mainSort,The following statement contains a magic number: for (int h = 364; h != 1;)              {                  h /= 3;                  for (int i = h; i <= 255; i++)                  {                      int vv = runningOrder[i];                      int a = ftab[(vv + 1) << 8] - ftab[vv << 8];                      int b = h - 1;                      int j = i;                      for (int ro = runningOrder[j - h]; (ftab[(ro + 1) << 8] - ftab[ro << 8]) > a; ro = runningOrder[j                                                                                                                      - h])                      {                          runningOrder[j] = ro;                          j -= h;                          if (j <= b)                          {                              break;                          }                      }                      runningOrder[j] = vv;                  }              }
Magic Number,Ionic.BZip2,BZip2Compressor,C:\repos\haf_DotNetZip.Semverd\src\BZip2\BZip2Compressor.cs,mainSort,The following statement contains a magic number: for (int i = 0; i <= 255; i++)              {                  /*                   * Process big buckets' starting with the least full.                   */                  int ss = runningOrder[i];                    // Step 1:                  /*                   * Complete the big bucket [ss] by quicksorting any unsorted small                   * buckets [ss' j]. Hopefully previous pointer-scanning phases have                   * already completed many of the small buckets [ss' j]' so we don't                   * have to sort them at all.                   */                  for (int j = 0; j <= 255; j++)                  {                      int sb = (ss << 8) + j;                      int ftab_sb = ftab[sb];                      if ((ftab_sb & SETMASK) != SETMASK)                      {                          int lo = ftab_sb & CLEARMASK;                          int hi = (ftab[sb + 1] & CLEARMASK) - 1;                          if (hi > lo)                          {                              mainQSort3(dataShadow' lo' hi' 2);                              if (firstAttemptShadow                                  && (this.workDone > workLimitShadow))                              {                                  return;                              }                          }                          ftab[sb] = ftab_sb | SETMASK;                      }                  }                    // Step 2:                  // Now scan this big bucket so as to synthesise the                  // sorted order for small buckets [t' ss] for all t != ss.                    for (int j = 0; j <= 255; j++)                  {                      copy[j] = ftab[(j << 8) + ss] & CLEARMASK;                  }                    for (int j = ftab[ss << 8] & CLEARMASK' hj = (ftab[(ss + 1) << 8] & CLEARMASK); j < hj; j++)                  {                      int fmap_j = fmap[j];                      c1 = block[fmap_j] & 0xff;                      if (!bigDone[c1])                      {                          fmap[copy[c1]] = (fmap_j == 0) ? lastShadow : (fmap_j - 1);                          copy[c1]++;                      }                  }                    for (int j = 256; --j >= 0;)                      ftab[(j << 8) + ss] |= SETMASK;                    // Step 3:                  /*                   * The ss big bucket is now done. Record this fact' and update the                   * quadrant descriptors. Remember to update quadrants in the                   * overshoot area too' if necessary. The "if (i < 255)" test merely                   * skips this updating for the last bucket processed' since updating                   * for the last bucket is pointless.                   */                  bigDone[ss] = true;                    if (i < 255)                  {                      int bbStart = ftab[ss << 8] & CLEARMASK;                      int bbSize = (ftab[(ss + 1) << 8] & CLEARMASK) - bbStart;                      int shifts = 0;                        while ((bbSize >> shifts) > 65534)                      {                          shifts++;                      }                        for (int j = 0; j < bbSize; j++)                      {                          int a2update = fmap[bbStart + j];                          char qVal = (char) (j >> shifts);                          quadrant[a2update] = qVal;                          if (a2update < BZip2.NUM_OVERSHOOT_BYTES)                          {                              quadrant[a2update + lastShadow + 1] = qVal;                          }                      }                  }                }
Magic Number,Ionic.BZip2,BZip2Compressor,C:\repos\haf_DotNetZip.Semverd\src\BZip2\BZip2Compressor.cs,mainSort,The following statement contains a magic number: for (int i = 0; i <= 255; i++)              {                  /*                   * Process big buckets' starting with the least full.                   */                  int ss = runningOrder[i];                    // Step 1:                  /*                   * Complete the big bucket [ss] by quicksorting any unsorted small                   * buckets [ss' j]. Hopefully previous pointer-scanning phases have                   * already completed many of the small buckets [ss' j]' so we don't                   * have to sort them at all.                   */                  for (int j = 0; j <= 255; j++)                  {                      int sb = (ss << 8) + j;                      int ftab_sb = ftab[sb];                      if ((ftab_sb & SETMASK) != SETMASK)                      {                          int lo = ftab_sb & CLEARMASK;                          int hi = (ftab[sb + 1] & CLEARMASK) - 1;                          if (hi > lo)                          {                              mainQSort3(dataShadow' lo' hi' 2);                              if (firstAttemptShadow                                  && (this.workDone > workLimitShadow))                              {                                  return;                              }                          }                          ftab[sb] = ftab_sb | SETMASK;                      }                  }                    // Step 2:                  // Now scan this big bucket so as to synthesise the                  // sorted order for small buckets [t' ss] for all t != ss.                    for (int j = 0; j <= 255; j++)                  {                      copy[j] = ftab[(j << 8) + ss] & CLEARMASK;                  }                    for (int j = ftab[ss << 8] & CLEARMASK' hj = (ftab[(ss + 1) << 8] & CLEARMASK); j < hj; j++)                  {                      int fmap_j = fmap[j];                      c1 = block[fmap_j] & 0xff;                      if (!bigDone[c1])                      {                          fmap[copy[c1]] = (fmap_j == 0) ? lastShadow : (fmap_j - 1);                          copy[c1]++;                      }                  }                    for (int j = 256; --j >= 0;)                      ftab[(j << 8) + ss] |= SETMASK;                    // Step 3:                  /*                   * The ss big bucket is now done. Record this fact' and update the                   * quadrant descriptors. Remember to update quadrants in the                   * overshoot area too' if necessary. The "if (i < 255)" test merely                   * skips this updating for the last bucket processed' since updating                   * for the last bucket is pointless.                   */                  bigDone[ss] = true;                    if (i < 255)                  {                      int bbStart = ftab[ss << 8] & CLEARMASK;                      int bbSize = (ftab[(ss + 1) << 8] & CLEARMASK) - bbStart;                      int shifts = 0;                        while ((bbSize >> shifts) > 65534)                      {                          shifts++;                      }                        for (int j = 0; j < bbSize; j++)                      {                          int a2update = fmap[bbStart + j];                          char qVal = (char) (j >> shifts);                          quadrant[a2update] = qVal;                          if (a2update < BZip2.NUM_OVERSHOOT_BYTES)                          {                              quadrant[a2update + lastShadow + 1] = qVal;                          }                      }                  }                }
Magic Number,Ionic.BZip2,BZip2Compressor,C:\repos\haf_DotNetZip.Semverd\src\BZip2\BZip2Compressor.cs,mainSort,The following statement contains a magic number: for (int i = 0; i <= 255; i++)              {                  /*                   * Process big buckets' starting with the least full.                   */                  int ss = runningOrder[i];                    // Step 1:                  /*                   * Complete the big bucket [ss] by quicksorting any unsorted small                   * buckets [ss' j]. Hopefully previous pointer-scanning phases have                   * already completed many of the small buckets [ss' j]' so we don't                   * have to sort them at all.                   */                  for (int j = 0; j <= 255; j++)                  {                      int sb = (ss << 8) + j;                      int ftab_sb = ftab[sb];                      if ((ftab_sb & SETMASK) != SETMASK)                      {                          int lo = ftab_sb & CLEARMASK;                          int hi = (ftab[sb + 1] & CLEARMASK) - 1;                          if (hi > lo)                          {                              mainQSort3(dataShadow' lo' hi' 2);                              if (firstAttemptShadow                                  && (this.workDone > workLimitShadow))                              {                                  return;                              }                          }                          ftab[sb] = ftab_sb | SETMASK;                      }                  }                    // Step 2:                  // Now scan this big bucket so as to synthesise the                  // sorted order for small buckets [t' ss] for all t != ss.                    for (int j = 0; j <= 255; j++)                  {                      copy[j] = ftab[(j << 8) + ss] & CLEARMASK;                  }                    for (int j = ftab[ss << 8] & CLEARMASK' hj = (ftab[(ss + 1) << 8] & CLEARMASK); j < hj; j++)                  {                      int fmap_j = fmap[j];                      c1 = block[fmap_j] & 0xff;                      if (!bigDone[c1])                      {                          fmap[copy[c1]] = (fmap_j == 0) ? lastShadow : (fmap_j - 1);                          copy[c1]++;                      }                  }                    for (int j = 256; --j >= 0;)                      ftab[(j << 8) + ss] |= SETMASK;                    // Step 3:                  /*                   * The ss big bucket is now done. Record this fact' and update the                   * quadrant descriptors. Remember to update quadrants in the                   * overshoot area too' if necessary. The "if (i < 255)" test merely                   * skips this updating for the last bucket processed' since updating                   * for the last bucket is pointless.                   */                  bigDone[ss] = true;                    if (i < 255)                  {                      int bbStart = ftab[ss << 8] & CLEARMASK;                      int bbSize = (ftab[(ss + 1) << 8] & CLEARMASK) - bbStart;                      int shifts = 0;                        while ((bbSize >> shifts) > 65534)                      {                          shifts++;                      }                        for (int j = 0; j < bbSize; j++)                      {                          int a2update = fmap[bbStart + j];                          char qVal = (char) (j >> shifts);                          quadrant[a2update] = qVal;                          if (a2update < BZip2.NUM_OVERSHOOT_BYTES)                          {                              quadrant[a2update + lastShadow + 1] = qVal;                          }                      }                  }                }
Magic Number,Ionic.BZip2,BZip2Compressor,C:\repos\haf_DotNetZip.Semverd\src\BZip2\BZip2Compressor.cs,mainSort,The following statement contains a magic number: for (int i = 0; i <= 255; i++)              {                  /*                   * Process big buckets' starting with the least full.                   */                  int ss = runningOrder[i];                    // Step 1:                  /*                   * Complete the big bucket [ss] by quicksorting any unsorted small                   * buckets [ss' j]. Hopefully previous pointer-scanning phases have                   * already completed many of the small buckets [ss' j]' so we don't                   * have to sort them at all.                   */                  for (int j = 0; j <= 255; j++)                  {                      int sb = (ss << 8) + j;                      int ftab_sb = ftab[sb];                      if ((ftab_sb & SETMASK) != SETMASK)                      {                          int lo = ftab_sb & CLEARMASK;                          int hi = (ftab[sb + 1] & CLEARMASK) - 1;                          if (hi > lo)                          {                              mainQSort3(dataShadow' lo' hi' 2);                              if (firstAttemptShadow                                  && (this.workDone > workLimitShadow))                              {                                  return;                              }                          }                          ftab[sb] = ftab_sb | SETMASK;                      }                  }                    // Step 2:                  // Now scan this big bucket so as to synthesise the                  // sorted order for small buckets [t' ss] for all t != ss.                    for (int j = 0; j <= 255; j++)                  {                      copy[j] = ftab[(j << 8) + ss] & CLEARMASK;                  }                    for (int j = ftab[ss << 8] & CLEARMASK' hj = (ftab[(ss + 1) << 8] & CLEARMASK); j < hj; j++)                  {                      int fmap_j = fmap[j];                      c1 = block[fmap_j] & 0xff;                      if (!bigDone[c1])                      {                          fmap[copy[c1]] = (fmap_j == 0) ? lastShadow : (fmap_j - 1);                          copy[c1]++;                      }                  }                    for (int j = 256; --j >= 0;)                      ftab[(j << 8) + ss] |= SETMASK;                    // Step 3:                  /*                   * The ss big bucket is now done. Record this fact' and update the                   * quadrant descriptors. Remember to update quadrants in the                   * overshoot area too' if necessary. The "if (i < 255)" test merely                   * skips this updating for the last bucket processed' since updating                   * for the last bucket is pointless.                   */                  bigDone[ss] = true;                    if (i < 255)                  {                      int bbStart = ftab[ss << 8] & CLEARMASK;                      int bbSize = (ftab[(ss + 1) << 8] & CLEARMASK) - bbStart;                      int shifts = 0;                        while ((bbSize >> shifts) > 65534)                      {                          shifts++;                      }                        for (int j = 0; j < bbSize; j++)                      {                          int a2update = fmap[bbStart + j];                          char qVal = (char) (j >> shifts);                          quadrant[a2update] = qVal;                          if (a2update < BZip2.NUM_OVERSHOOT_BYTES)                          {                              quadrant[a2update + lastShadow + 1] = qVal;                          }                      }                  }                }
Magic Number,Ionic.BZip2,BZip2Compressor,C:\repos\haf_DotNetZip.Semverd\src\BZip2\BZip2Compressor.cs,mainSort,The following statement contains a magic number: for (int i = 0; i <= 255; i++)              {                  /*                   * Process big buckets' starting with the least full.                   */                  int ss = runningOrder[i];                    // Step 1:                  /*                   * Complete the big bucket [ss] by quicksorting any unsorted small                   * buckets [ss' j]. Hopefully previous pointer-scanning phases have                   * already completed many of the small buckets [ss' j]' so we don't                   * have to sort them at all.                   */                  for (int j = 0; j <= 255; j++)                  {                      int sb = (ss << 8) + j;                      int ftab_sb = ftab[sb];                      if ((ftab_sb & SETMASK) != SETMASK)                      {                          int lo = ftab_sb & CLEARMASK;                          int hi = (ftab[sb + 1] & CLEARMASK) - 1;                          if (hi > lo)                          {                              mainQSort3(dataShadow' lo' hi' 2);                              if (firstAttemptShadow                                  && (this.workDone > workLimitShadow))                              {                                  return;                              }                          }                          ftab[sb] = ftab_sb | SETMASK;                      }                  }                    // Step 2:                  // Now scan this big bucket so as to synthesise the                  // sorted order for small buckets [t' ss] for all t != ss.                    for (int j = 0; j <= 255; j++)                  {                      copy[j] = ftab[(j << 8) + ss] & CLEARMASK;                  }                    for (int j = ftab[ss << 8] & CLEARMASK' hj = (ftab[(ss + 1) << 8] & CLEARMASK); j < hj; j++)                  {                      int fmap_j = fmap[j];                      c1 = block[fmap_j] & 0xff;                      if (!bigDone[c1])                      {                          fmap[copy[c1]] = (fmap_j == 0) ? lastShadow : (fmap_j - 1);                          copy[c1]++;                      }                  }                    for (int j = 256; --j >= 0;)                      ftab[(j << 8) + ss] |= SETMASK;                    // Step 3:                  /*                   * The ss big bucket is now done. Record this fact' and update the                   * quadrant descriptors. Remember to update quadrants in the                   * overshoot area too' if necessary. The "if (i < 255)" test merely                   * skips this updating for the last bucket processed' since updating                   * for the last bucket is pointless.                   */                  bigDone[ss] = true;                    if (i < 255)                  {                      int bbStart = ftab[ss << 8] & CLEARMASK;                      int bbSize = (ftab[(ss + 1) << 8] & CLEARMASK) - bbStart;                      int shifts = 0;                        while ((bbSize >> shifts) > 65534)                      {                          shifts++;                      }                        for (int j = 0; j < bbSize; j++)                      {                          int a2update = fmap[bbStart + j];                          char qVal = (char) (j >> shifts);                          quadrant[a2update] = qVal;                          if (a2update < BZip2.NUM_OVERSHOOT_BYTES)                          {                              quadrant[a2update + lastShadow + 1] = qVal;                          }                      }                  }                }
Magic Number,Ionic.BZip2,BZip2Compressor,C:\repos\haf_DotNetZip.Semverd\src\BZip2\BZip2Compressor.cs,mainSort,The following statement contains a magic number: for (int i = 0; i <= 255; i++)              {                  /*                   * Process big buckets' starting with the least full.                   */                  int ss = runningOrder[i];                    // Step 1:                  /*                   * Complete the big bucket [ss] by quicksorting any unsorted small                   * buckets [ss' j]. Hopefully previous pointer-scanning phases have                   * already completed many of the small buckets [ss' j]' so we don't                   * have to sort them at all.                   */                  for (int j = 0; j <= 255; j++)                  {                      int sb = (ss << 8) + j;                      int ftab_sb = ftab[sb];                      if ((ftab_sb & SETMASK) != SETMASK)                      {                          int lo = ftab_sb & CLEARMASK;                          int hi = (ftab[sb + 1] & CLEARMASK) - 1;                          if (hi > lo)                          {                              mainQSort3(dataShadow' lo' hi' 2);                              if (firstAttemptShadow                                  && (this.workDone > workLimitShadow))                              {                                  return;                              }                          }                          ftab[sb] = ftab_sb | SETMASK;                      }                  }                    // Step 2:                  // Now scan this big bucket so as to synthesise the                  // sorted order for small buckets [t' ss] for all t != ss.                    for (int j = 0; j <= 255; j++)                  {                      copy[j] = ftab[(j << 8) + ss] & CLEARMASK;                  }                    for (int j = ftab[ss << 8] & CLEARMASK' hj = (ftab[(ss + 1) << 8] & CLEARMASK); j < hj; j++)                  {                      int fmap_j = fmap[j];                      c1 = block[fmap_j] & 0xff;                      if (!bigDone[c1])                      {                          fmap[copy[c1]] = (fmap_j == 0) ? lastShadow : (fmap_j - 1);                          copy[c1]++;                      }                  }                    for (int j = 256; --j >= 0;)                      ftab[(j << 8) + ss] |= SETMASK;                    // Step 3:                  /*                   * The ss big bucket is now done. Record this fact' and update the                   * quadrant descriptors. Remember to update quadrants in the                   * overshoot area too' if necessary. The "if (i < 255)" test merely                   * skips this updating for the last bucket processed' since updating                   * for the last bucket is pointless.                   */                  bigDone[ss] = true;                    if (i < 255)                  {                      int bbStart = ftab[ss << 8] & CLEARMASK;                      int bbSize = (ftab[(ss + 1) << 8] & CLEARMASK) - bbStart;                      int shifts = 0;                        while ((bbSize >> shifts) > 65534)                      {                          shifts++;                      }                        for (int j = 0; j < bbSize; j++)                      {                          int a2update = fmap[bbStart + j];                          char qVal = (char) (j >> shifts);                          quadrant[a2update] = qVal;                          if (a2update < BZip2.NUM_OVERSHOOT_BYTES)                          {                              quadrant[a2update + lastShadow + 1] = qVal;                          }                      }                  }                }
Magic Number,Ionic.BZip2,BZip2Compressor,C:\repos\haf_DotNetZip.Semverd\src\BZip2\BZip2Compressor.cs,mainSort,The following statement contains a magic number: for (int i = 0; i <= 255; i++)              {                  /*                   * Process big buckets' starting with the least full.                   */                  int ss = runningOrder[i];                    // Step 1:                  /*                   * Complete the big bucket [ss] by quicksorting any unsorted small                   * buckets [ss' j]. Hopefully previous pointer-scanning phases have                   * already completed many of the small buckets [ss' j]' so we don't                   * have to sort them at all.                   */                  for (int j = 0; j <= 255; j++)                  {                      int sb = (ss << 8) + j;                      int ftab_sb = ftab[sb];                      if ((ftab_sb & SETMASK) != SETMASK)                      {                          int lo = ftab_sb & CLEARMASK;                          int hi = (ftab[sb + 1] & CLEARMASK) - 1;                          if (hi > lo)                          {                              mainQSort3(dataShadow' lo' hi' 2);                              if (firstAttemptShadow                                  && (this.workDone > workLimitShadow))                              {                                  return;                              }                          }                          ftab[sb] = ftab_sb | SETMASK;                      }                  }                    // Step 2:                  // Now scan this big bucket so as to synthesise the                  // sorted order for small buckets [t' ss] for all t != ss.                    for (int j = 0; j <= 255; j++)                  {                      copy[j] = ftab[(j << 8) + ss] & CLEARMASK;                  }                    for (int j = ftab[ss << 8] & CLEARMASK' hj = (ftab[(ss + 1) << 8] & CLEARMASK); j < hj; j++)                  {                      int fmap_j = fmap[j];                      c1 = block[fmap_j] & 0xff;                      if (!bigDone[c1])                      {                          fmap[copy[c1]] = (fmap_j == 0) ? lastShadow : (fmap_j - 1);                          copy[c1]++;                      }                  }                    for (int j = 256; --j >= 0;)                      ftab[(j << 8) + ss] |= SETMASK;                    // Step 3:                  /*                   * The ss big bucket is now done. Record this fact' and update the                   * quadrant descriptors. Remember to update quadrants in the                   * overshoot area too' if necessary. The "if (i < 255)" test merely                   * skips this updating for the last bucket processed' since updating                   * for the last bucket is pointless.                   */                  bigDone[ss] = true;                    if (i < 255)                  {                      int bbStart = ftab[ss << 8] & CLEARMASK;                      int bbSize = (ftab[(ss + 1) << 8] & CLEARMASK) - bbStart;                      int shifts = 0;                        while ((bbSize >> shifts) > 65534)                      {                          shifts++;                      }                        for (int j = 0; j < bbSize; j++)                      {                          int a2update = fmap[bbStart + j];                          char qVal = (char) (j >> shifts);                          quadrant[a2update] = qVal;                          if (a2update < BZip2.NUM_OVERSHOOT_BYTES)                          {                              quadrant[a2update + lastShadow + 1] = qVal;                          }                      }                  }                }
Magic Number,Ionic.BZip2,BZip2Compressor,C:\repos\haf_DotNetZip.Semverd\src\BZip2\BZip2Compressor.cs,mainSort,The following statement contains a magic number: for (int i = 0; i <= 255; i++)              {                  /*                   * Process big buckets' starting with the least full.                   */                  int ss = runningOrder[i];                    // Step 1:                  /*                   * Complete the big bucket [ss] by quicksorting any unsorted small                   * buckets [ss' j]. Hopefully previous pointer-scanning phases have                   * already completed many of the small buckets [ss' j]' so we don't                   * have to sort them at all.                   */                  for (int j = 0; j <= 255; j++)                  {                      int sb = (ss << 8) + j;                      int ftab_sb = ftab[sb];                      if ((ftab_sb & SETMASK) != SETMASK)                      {                          int lo = ftab_sb & CLEARMASK;                          int hi = (ftab[sb + 1] & CLEARMASK) - 1;                          if (hi > lo)                          {                              mainQSort3(dataShadow' lo' hi' 2);                              if (firstAttemptShadow                                  && (this.workDone > workLimitShadow))                              {                                  return;                              }                          }                          ftab[sb] = ftab_sb | SETMASK;                      }                  }                    // Step 2:                  // Now scan this big bucket so as to synthesise the                  // sorted order for small buckets [t' ss] for all t != ss.                    for (int j = 0; j <= 255; j++)                  {                      copy[j] = ftab[(j << 8) + ss] & CLEARMASK;                  }                    for (int j = ftab[ss << 8] & CLEARMASK' hj = (ftab[(ss + 1) << 8] & CLEARMASK); j < hj; j++)                  {                      int fmap_j = fmap[j];                      c1 = block[fmap_j] & 0xff;                      if (!bigDone[c1])                      {                          fmap[copy[c1]] = (fmap_j == 0) ? lastShadow : (fmap_j - 1);                          copy[c1]++;                      }                  }                    for (int j = 256; --j >= 0;)                      ftab[(j << 8) + ss] |= SETMASK;                    // Step 3:                  /*                   * The ss big bucket is now done. Record this fact' and update the                   * quadrant descriptors. Remember to update quadrants in the                   * overshoot area too' if necessary. The "if (i < 255)" test merely                   * skips this updating for the last bucket processed' since updating                   * for the last bucket is pointless.                   */                  bigDone[ss] = true;                    if (i < 255)                  {                      int bbStart = ftab[ss << 8] & CLEARMASK;                      int bbSize = (ftab[(ss + 1) << 8] & CLEARMASK) - bbStart;                      int shifts = 0;                        while ((bbSize >> shifts) > 65534)                      {                          shifts++;                      }                        for (int j = 0; j < bbSize; j++)                      {                          int a2update = fmap[bbStart + j];                          char qVal = (char) (j >> shifts);                          quadrant[a2update] = qVal;                          if (a2update < BZip2.NUM_OVERSHOOT_BYTES)                          {                              quadrant[a2update + lastShadow + 1] = qVal;                          }                      }                  }                }
Magic Number,Ionic.BZip2,BZip2Compressor,C:\repos\haf_DotNetZip.Semverd\src\BZip2\BZip2Compressor.cs,mainSort,The following statement contains a magic number: for (int i = 0; i <= 255; i++)              {                  /*                   * Process big buckets' starting with the least full.                   */                  int ss = runningOrder[i];                    // Step 1:                  /*                   * Complete the big bucket [ss] by quicksorting any unsorted small                   * buckets [ss' j]. Hopefully previous pointer-scanning phases have                   * already completed many of the small buckets [ss' j]' so we don't                   * have to sort them at all.                   */                  for (int j = 0; j <= 255; j++)                  {                      int sb = (ss << 8) + j;                      int ftab_sb = ftab[sb];                      if ((ftab_sb & SETMASK) != SETMASK)                      {                          int lo = ftab_sb & CLEARMASK;                          int hi = (ftab[sb + 1] & CLEARMASK) - 1;                          if (hi > lo)                          {                              mainQSort3(dataShadow' lo' hi' 2);                              if (firstAttemptShadow                                  && (this.workDone > workLimitShadow))                              {                                  return;                              }                          }                          ftab[sb] = ftab_sb | SETMASK;                      }                  }                    // Step 2:                  // Now scan this big bucket so as to synthesise the                  // sorted order for small buckets [t' ss] for all t != ss.                    for (int j = 0; j <= 255; j++)                  {                      copy[j] = ftab[(j << 8) + ss] & CLEARMASK;                  }                    for (int j = ftab[ss << 8] & CLEARMASK' hj = (ftab[(ss + 1) << 8] & CLEARMASK); j < hj; j++)                  {                      int fmap_j = fmap[j];                      c1 = block[fmap_j] & 0xff;                      if (!bigDone[c1])                      {                          fmap[copy[c1]] = (fmap_j == 0) ? lastShadow : (fmap_j - 1);                          copy[c1]++;                      }                  }                    for (int j = 256; --j >= 0;)                      ftab[(j << 8) + ss] |= SETMASK;                    // Step 3:                  /*                   * The ss big bucket is now done. Record this fact' and update the                   * quadrant descriptors. Remember to update quadrants in the                   * overshoot area too' if necessary. The "if (i < 255)" test merely                   * skips this updating for the last bucket processed' since updating                   * for the last bucket is pointless.                   */                  bigDone[ss] = true;                    if (i < 255)                  {                      int bbStart = ftab[ss << 8] & CLEARMASK;                      int bbSize = (ftab[(ss + 1) << 8] & CLEARMASK) - bbStart;                      int shifts = 0;                        while ((bbSize >> shifts) > 65534)                      {                          shifts++;                      }                        for (int j = 0; j < bbSize; j++)                      {                          int a2update = fmap[bbStart + j];                          char qVal = (char) (j >> shifts);                          quadrant[a2update] = qVal;                          if (a2update < BZip2.NUM_OVERSHOOT_BYTES)                          {                              quadrant[a2update + lastShadow + 1] = qVal;                          }                      }                  }                }
Magic Number,Ionic.BZip2,BZip2Compressor,C:\repos\haf_DotNetZip.Semverd\src\BZip2\BZip2Compressor.cs,mainSort,The following statement contains a magic number: for (int i = 0; i <= 255; i++)              {                  /*                   * Process big buckets' starting with the least full.                   */                  int ss = runningOrder[i];                    // Step 1:                  /*                   * Complete the big bucket [ss] by quicksorting any unsorted small                   * buckets [ss' j]. Hopefully previous pointer-scanning phases have                   * already completed many of the small buckets [ss' j]' so we don't                   * have to sort them at all.                   */                  for (int j = 0; j <= 255; j++)                  {                      int sb = (ss << 8) + j;                      int ftab_sb = ftab[sb];                      if ((ftab_sb & SETMASK) != SETMASK)                      {                          int lo = ftab_sb & CLEARMASK;                          int hi = (ftab[sb + 1] & CLEARMASK) - 1;                          if (hi > lo)                          {                              mainQSort3(dataShadow' lo' hi' 2);                              if (firstAttemptShadow                                  && (this.workDone > workLimitShadow))                              {                                  return;                              }                          }                          ftab[sb] = ftab_sb | SETMASK;                      }                  }                    // Step 2:                  // Now scan this big bucket so as to synthesise the                  // sorted order for small buckets [t' ss] for all t != ss.                    for (int j = 0; j <= 255; j++)                  {                      copy[j] = ftab[(j << 8) + ss] & CLEARMASK;                  }                    for (int j = ftab[ss << 8] & CLEARMASK' hj = (ftab[(ss + 1) << 8] & CLEARMASK); j < hj; j++)                  {                      int fmap_j = fmap[j];                      c1 = block[fmap_j] & 0xff;                      if (!bigDone[c1])                      {                          fmap[copy[c1]] = (fmap_j == 0) ? lastShadow : (fmap_j - 1);                          copy[c1]++;                      }                  }                    for (int j = 256; --j >= 0;)                      ftab[(j << 8) + ss] |= SETMASK;                    // Step 3:                  /*                   * The ss big bucket is now done. Record this fact' and update the                   * quadrant descriptors. Remember to update quadrants in the                   * overshoot area too' if necessary. The "if (i < 255)" test merely                   * skips this updating for the last bucket processed' since updating                   * for the last bucket is pointless.                   */                  bigDone[ss] = true;                    if (i < 255)                  {                      int bbStart = ftab[ss << 8] & CLEARMASK;                      int bbSize = (ftab[(ss + 1) << 8] & CLEARMASK) - bbStart;                      int shifts = 0;                        while ((bbSize >> shifts) > 65534)                      {                          shifts++;                      }                        for (int j = 0; j < bbSize; j++)                      {                          int a2update = fmap[bbStart + j];                          char qVal = (char) (j >> shifts);                          quadrant[a2update] = qVal;                          if (a2update < BZip2.NUM_OVERSHOOT_BYTES)                          {                              quadrant[a2update + lastShadow + 1] = qVal;                          }                      }                  }                }
Magic Number,Ionic.BZip2,BZip2Compressor,C:\repos\haf_DotNetZip.Semverd\src\BZip2\BZip2Compressor.cs,mainSort,The following statement contains a magic number: for (int i = 0; i <= 255; i++)              {                  /*                   * Process big buckets' starting with the least full.                   */                  int ss = runningOrder[i];                    // Step 1:                  /*                   * Complete the big bucket [ss] by quicksorting any unsorted small                   * buckets [ss' j]. Hopefully previous pointer-scanning phases have                   * already completed many of the small buckets [ss' j]' so we don't                   * have to sort them at all.                   */                  for (int j = 0; j <= 255; j++)                  {                      int sb = (ss << 8) + j;                      int ftab_sb = ftab[sb];                      if ((ftab_sb & SETMASK) != SETMASK)                      {                          int lo = ftab_sb & CLEARMASK;                          int hi = (ftab[sb + 1] & CLEARMASK) - 1;                          if (hi > lo)                          {                              mainQSort3(dataShadow' lo' hi' 2);                              if (firstAttemptShadow                                  && (this.workDone > workLimitShadow))                              {                                  return;                              }                          }                          ftab[sb] = ftab_sb | SETMASK;                      }                  }                    // Step 2:                  // Now scan this big bucket so as to synthesise the                  // sorted order for small buckets [t' ss] for all t != ss.                    for (int j = 0; j <= 255; j++)                  {                      copy[j] = ftab[(j << 8) + ss] & CLEARMASK;                  }                    for (int j = ftab[ss << 8] & CLEARMASK' hj = (ftab[(ss + 1) << 8] & CLEARMASK); j < hj; j++)                  {                      int fmap_j = fmap[j];                      c1 = block[fmap_j] & 0xff;                      if (!bigDone[c1])                      {                          fmap[copy[c1]] = (fmap_j == 0) ? lastShadow : (fmap_j - 1);                          copy[c1]++;                      }                  }                    for (int j = 256; --j >= 0;)                      ftab[(j << 8) + ss] |= SETMASK;                    // Step 3:                  /*                   * The ss big bucket is now done. Record this fact' and update the                   * quadrant descriptors. Remember to update quadrants in the                   * overshoot area too' if necessary. The "if (i < 255)" test merely                   * skips this updating for the last bucket processed' since updating                   * for the last bucket is pointless.                   */                  bigDone[ss] = true;                    if (i < 255)                  {                      int bbStart = ftab[ss << 8] & CLEARMASK;                      int bbSize = (ftab[(ss + 1) << 8] & CLEARMASK) - bbStart;                      int shifts = 0;                        while ((bbSize >> shifts) > 65534)                      {                          shifts++;                      }                        for (int j = 0; j < bbSize; j++)                      {                          int a2update = fmap[bbStart + j];                          char qVal = (char) (j >> shifts);                          quadrant[a2update] = qVal;                          if (a2update < BZip2.NUM_OVERSHOOT_BYTES)                          {                              quadrant[a2update + lastShadow + 1] = qVal;                          }                      }                  }                }
Magic Number,Ionic.BZip2,BZip2Compressor,C:\repos\haf_DotNetZip.Semverd\src\BZip2\BZip2Compressor.cs,mainSort,The following statement contains a magic number: for (int i = 0; i <= 255; i++)              {                  /*                   * Process big buckets' starting with the least full.                   */                  int ss = runningOrder[i];                    // Step 1:                  /*                   * Complete the big bucket [ss] by quicksorting any unsorted small                   * buckets [ss' j]. Hopefully previous pointer-scanning phases have                   * already completed many of the small buckets [ss' j]' so we don't                   * have to sort them at all.                   */                  for (int j = 0; j <= 255; j++)                  {                      int sb = (ss << 8) + j;                      int ftab_sb = ftab[sb];                      if ((ftab_sb & SETMASK) != SETMASK)                      {                          int lo = ftab_sb & CLEARMASK;                          int hi = (ftab[sb + 1] & CLEARMASK) - 1;                          if (hi > lo)                          {                              mainQSort3(dataShadow' lo' hi' 2);                              if (firstAttemptShadow                                  && (this.workDone > workLimitShadow))                              {                                  return;                              }                          }                          ftab[sb] = ftab_sb | SETMASK;                      }                  }                    // Step 2:                  // Now scan this big bucket so as to synthesise the                  // sorted order for small buckets [t' ss] for all t != ss.                    for (int j = 0; j <= 255; j++)                  {                      copy[j] = ftab[(j << 8) + ss] & CLEARMASK;                  }                    for (int j = ftab[ss << 8] & CLEARMASK' hj = (ftab[(ss + 1) << 8] & CLEARMASK); j < hj; j++)                  {                      int fmap_j = fmap[j];                      c1 = block[fmap_j] & 0xff;                      if (!bigDone[c1])                      {                          fmap[copy[c1]] = (fmap_j == 0) ? lastShadow : (fmap_j - 1);                          copy[c1]++;                      }                  }                    for (int j = 256; --j >= 0;)                      ftab[(j << 8) + ss] |= SETMASK;                    // Step 3:                  /*                   * The ss big bucket is now done. Record this fact' and update the                   * quadrant descriptors. Remember to update quadrants in the                   * overshoot area too' if necessary. The "if (i < 255)" test merely                   * skips this updating for the last bucket processed' since updating                   * for the last bucket is pointless.                   */                  bigDone[ss] = true;                    if (i < 255)                  {                      int bbStart = ftab[ss << 8] & CLEARMASK;                      int bbSize = (ftab[(ss + 1) << 8] & CLEARMASK) - bbStart;                      int shifts = 0;                        while ((bbSize >> shifts) > 65534)                      {                          shifts++;                      }                        for (int j = 0; j < bbSize; j++)                      {                          int a2update = fmap[bbStart + j];                          char qVal = (char) (j >> shifts);                          quadrant[a2update] = qVal;                          if (a2update < BZip2.NUM_OVERSHOOT_BYTES)                          {                              quadrant[a2update + lastShadow + 1] = qVal;                          }                      }                  }                }
Magic Number,Ionic.BZip2,BZip2Compressor,C:\repos\haf_DotNetZip.Semverd\src\BZip2\BZip2Compressor.cs,mainSort,The following statement contains a magic number: for (int i = 0; i <= 255; i++)              {                  /*                   * Process big buckets' starting with the least full.                   */                  int ss = runningOrder[i];                    // Step 1:                  /*                   * Complete the big bucket [ss] by quicksorting any unsorted small                   * buckets [ss' j]. Hopefully previous pointer-scanning phases have                   * already completed many of the small buckets [ss' j]' so we don't                   * have to sort them at all.                   */                  for (int j = 0; j <= 255; j++)                  {                      int sb = (ss << 8) + j;                      int ftab_sb = ftab[sb];                      if ((ftab_sb & SETMASK) != SETMASK)                      {                          int lo = ftab_sb & CLEARMASK;                          int hi = (ftab[sb + 1] & CLEARMASK) - 1;                          if (hi > lo)                          {                              mainQSort3(dataShadow' lo' hi' 2);                              if (firstAttemptShadow                                  && (this.workDone > workLimitShadow))                              {                                  return;                              }                          }                          ftab[sb] = ftab_sb | SETMASK;                      }                  }                    // Step 2:                  // Now scan this big bucket so as to synthesise the                  // sorted order for small buckets [t' ss] for all t != ss.                    for (int j = 0; j <= 255; j++)                  {                      copy[j] = ftab[(j << 8) + ss] & CLEARMASK;                  }                    for (int j = ftab[ss << 8] & CLEARMASK' hj = (ftab[(ss + 1) << 8] & CLEARMASK); j < hj; j++)                  {                      int fmap_j = fmap[j];                      c1 = block[fmap_j] & 0xff;                      if (!bigDone[c1])                      {                          fmap[copy[c1]] = (fmap_j == 0) ? lastShadow : (fmap_j - 1);                          copy[c1]++;                      }                  }                    for (int j = 256; --j >= 0;)                      ftab[(j << 8) + ss] |= SETMASK;                    // Step 3:                  /*                   * The ss big bucket is now done. Record this fact' and update the                   * quadrant descriptors. Remember to update quadrants in the                   * overshoot area too' if necessary. The "if (i < 255)" test merely                   * skips this updating for the last bucket processed' since updating                   * for the last bucket is pointless.                   */                  bigDone[ss] = true;                    if (i < 255)                  {                      int bbStart = ftab[ss << 8] & CLEARMASK;                      int bbSize = (ftab[(ss + 1) << 8] & CLEARMASK) - bbStart;                      int shifts = 0;                        while ((bbSize >> shifts) > 65534)                      {                          shifts++;                      }                        for (int j = 0; j < bbSize; j++)                      {                          int a2update = fmap[bbStart + j];                          char qVal = (char) (j >> shifts);                          quadrant[a2update] = qVal;                          if (a2update < BZip2.NUM_OVERSHOOT_BYTES)                          {                              quadrant[a2update + lastShadow + 1] = qVal;                          }                      }                  }                }
Magic Number,Ionic.BZip2,BZip2Compressor,C:\repos\haf_DotNetZip.Semverd\src\BZip2\BZip2Compressor.cs,mainSort,The following statement contains a magic number: for (int i = 0; i <= 255; i++)              {                  /*                   * Process big buckets' starting with the least full.                   */                  int ss = runningOrder[i];                    // Step 1:                  /*                   * Complete the big bucket [ss] by quicksorting any unsorted small                   * buckets [ss' j]. Hopefully previous pointer-scanning phases have                   * already completed many of the small buckets [ss' j]' so we don't                   * have to sort them at all.                   */                  for (int j = 0; j <= 255; j++)                  {                      int sb = (ss << 8) + j;                      int ftab_sb = ftab[sb];                      if ((ftab_sb & SETMASK) != SETMASK)                      {                          int lo = ftab_sb & CLEARMASK;                          int hi = (ftab[sb + 1] & CLEARMASK) - 1;                          if (hi > lo)                          {                              mainQSort3(dataShadow' lo' hi' 2);                              if (firstAttemptShadow                                  && (this.workDone > workLimitShadow))                              {                                  return;                              }                          }                          ftab[sb] = ftab_sb | SETMASK;                      }                  }                    // Step 2:                  // Now scan this big bucket so as to synthesise the                  // sorted order for small buckets [t' ss] for all t != ss.                    for (int j = 0; j <= 255; j++)                  {                      copy[j] = ftab[(j << 8) + ss] & CLEARMASK;                  }                    for (int j = ftab[ss << 8] & CLEARMASK' hj = (ftab[(ss + 1) << 8] & CLEARMASK); j < hj; j++)                  {                      int fmap_j = fmap[j];                      c1 = block[fmap_j] & 0xff;                      if (!bigDone[c1])                      {                          fmap[copy[c1]] = (fmap_j == 0) ? lastShadow : (fmap_j - 1);                          copy[c1]++;                      }                  }                    for (int j = 256; --j >= 0;)                      ftab[(j << 8) + ss] |= SETMASK;                    // Step 3:                  /*                   * The ss big bucket is now done. Record this fact' and update the                   * quadrant descriptors. Remember to update quadrants in the                   * overshoot area too' if necessary. The "if (i < 255)" test merely                   * skips this updating for the last bucket processed' since updating                   * for the last bucket is pointless.                   */                  bigDone[ss] = true;                    if (i < 255)                  {                      int bbStart = ftab[ss << 8] & CLEARMASK;                      int bbSize = (ftab[(ss + 1) << 8] & CLEARMASK) - bbStart;                      int shifts = 0;                        while ((bbSize >> shifts) > 65534)                      {                          shifts++;                      }                        for (int j = 0; j < bbSize; j++)                      {                          int a2update = fmap[bbStart + j];                          char qVal = (char) (j >> shifts);                          quadrant[a2update] = qVal;                          if (a2update < BZip2.NUM_OVERSHOOT_BYTES)                          {                              quadrant[a2update + lastShadow + 1] = qVal;                          }                      }                  }                }
Magic Number,Ionic.BZip2,BZip2Compressor,C:\repos\haf_DotNetZip.Semverd\src\BZip2\BZip2Compressor.cs,mainSimpleSort,The following statement contains a magic number: if (bigN < 2)              {                  return this.firstAttempt && (this.workDone > this.workLimit);              }
Magic Number,Ionic.BZip2,BZip2Compressor,C:\repos\haf_DotNetZip.Semverd\src\BZip2\BZip2Compressor.cs,mainSimpleSort,The following statement contains a magic number: while (--hp >= 0)              {                  int h = increments[hp];                  int mj = lo + h - 1;                    for (int i = lo + h; i <= hi;)                  {                      // copy                      for (int k = 3; (i <= hi) && (--k >= 0); i++)                      {                          int v = fmap[i];                          int vd = v + d;                          int j = i;                            // for (int a;                          // (j > mj) && mainGtU((a = fmap[j - h]) + d' vd'                          // block' quadrant' lastShadow);                          // j -= h) {                          // fmap[j] = a;                          // }                          //                          // unrolled version:                            // start inline mainGTU                          bool onceRunned = false;                          int a = 0;                            HAMMER: while (true)                          {                              if (onceRunned)                              {                                  fmap[j] = a;                                  if ((j -= h) <= mj)                                  {                                      goto END_HAMMER;                                  }                              }                              else {                                  onceRunned = true;                              }                                a = fmap[j - h];                              int i1 = a + d;                              int i2 = vd;                                // following could be done in a loop' but                              // unrolled it for performance:                              if (block[i1 + 1] == block[i2 + 1])                              {                                  if (block[i1 + 2] == block[i2 + 2])                                  {                                      if (block[i1 + 3] == block[i2 + 3])                                      {                                          if (block[i1 + 4] == block[i2 + 4])                                          {                                              if (block[i1 + 5] == block[i2 + 5])                                              {                                                  if (block[(i1 += 6)] == block[(i2 += 6)])                                                  {                                                      int x = lastShadow;                                                      X: while (x > 0)                                                      {                                                          x -= 4;                                                            if (block[i1 + 1] == block[i2 + 1])                                                          {                                                              if (quadrant[i1] == quadrant[i2])                                                              {                                                                  if (block[i1 + 2] == block[i2 + 2])                                                                  {                                                                      if (quadrant[i1 + 1] == quadrant[i2 + 1])                                                                      {                                                                          if (block[i1 + 3] == block[i2 + 3])                                                                          {                                                                              if (quadrant[i1 + 2] == quadrant[i2 + 2])                                                                              {                                                                                  if (block[i1 + 4] == block[i2 + 4])                                                                                  {                                                                                      if (quadrant[i1 + 3] == quadrant[i2 + 3])                                                                                      {                                                                                          if ((i1 += 4) >= lastPlus1)                                                                                          {                                                                                              i1 -= lastPlus1;                                                                                          }                                                                                          if ((i2 += 4) >= lastPlus1)                                                                                          {                                                                                              i2 -= lastPlus1;                                                                                          }                                                                                          workDoneShadow++;                                                                                          goto X;                                                                                      }                                                                                      else if ((quadrant[i1 + 3] > quadrant[i2 + 3]))                                                                                      {                                                                                          goto HAMMER;                                                                                      }                                                                                      else {                                                                                          goto END_HAMMER;                                                                                      }                                                                                  }                                                                                  else if ((block[i1 + 4] & 0xff) > (block[i2 + 4] & 0xff))                                                                                  {                                                                                      goto HAMMER;                                                                                  }                                                                                  else {                                                                                      goto END_HAMMER;                                                                                  }                                                                              }                                                                              else if ((quadrant[i1 + 2] > quadrant[i2 + 2]))                                                                              {                                                                                  goto HAMMER;                                                                              }                                                                              else {                                                                                  goto END_HAMMER;                                                                              }                                                                          }                                                                          else if ((block[i1 + 3] & 0xff) > (block[i2 + 3] & 0xff))                                                                          {                                                                              goto HAMMER;                                                                          }                                                                          else {                                                                              goto END_HAMMER;                                                                          }                                                                      }                                                                      else if ((quadrant[i1 + 1] > quadrant[i2 + 1]))                                                                      {                                                                          goto HAMMER;                                                                      }                                                                      else {                                                                          goto END_HAMMER;                                                                      }                                                                  }                                                                  else if ((block[i1 + 2] & 0xff) > (block[i2 + 2] & 0xff))                                                                  {                                                                      goto HAMMER;                                                                  }                                                                  else {                                                                      goto END_HAMMER;                                                                  }                                                              }                                                              else if ((quadrant[i1] > quadrant[i2]))                                                              {                                                                  goto HAMMER;                                                              }                                                              else {                                                                  goto END_HAMMER;                                                              }                                                          }                                                          else if ((block[i1 + 1] & 0xff) > (block[i2 + 1] & 0xff))                                                          {                                                              goto HAMMER;                                                          }                                                          else {                                                              goto END_HAMMER;                                                          }                                                        }                                                      goto END_HAMMER;                                                  } // while x > 0                                                  else {                                                      if ((block[i1] & 0xff) > (block[i2] & 0xff))                                                      {                                                          goto HAMMER;                                                      }                                                      else {                                                          goto END_HAMMER;                                                      }                                                  }                                              }                                              else if ((block[i1 + 5] & 0xff) > (block[i2 + 5] & 0xff))                                              {                                                  goto HAMMER;                                              }                                              else {                                                  goto END_HAMMER;                                              }                                          }                                          else if ((block[i1 + 4] & 0xff) > (block[i2 + 4] & 0xff))                                          {                                              goto HAMMER;                                          }                                          else {                                              goto END_HAMMER;                                          }                                      }                                      else if ((block[i1 + 3] & 0xff) > (block[i2 + 3] & 0xff))                                      {                                          goto HAMMER;                                      }                                      else {                                          goto END_HAMMER;                                      }                                  }                                  else if ((block[i1 + 2] & 0xff) > (block[i2 + 2] & 0xff))                                  {                                      goto HAMMER;                                  }                                  else {                                      goto END_HAMMER;                                  }                              }                              else if ((block[i1 + 1] & 0xff) > (block[i2 + 1] & 0xff))                              {                                  goto HAMMER;                              }                              else {                                  goto END_HAMMER;                              }                            } // HAMMER                            END_HAMMER:                          // end inline mainGTU                            fmap[j] = v;                      }                        if (firstAttemptShadow && (i <= hi)                          && (workDoneShadow > workLimitShadow))                      {                          goto END_HP;                      }                  }              }
Magic Number,Ionic.BZip2,BZip2Compressor,C:\repos\haf_DotNetZip.Semverd\src\BZip2\BZip2Compressor.cs,mainSimpleSort,The following statement contains a magic number: while (--hp >= 0)              {                  int h = increments[hp];                  int mj = lo + h - 1;                    for (int i = lo + h; i <= hi;)                  {                      // copy                      for (int k = 3; (i <= hi) && (--k >= 0); i++)                      {                          int v = fmap[i];                          int vd = v + d;                          int j = i;                            // for (int a;                          // (j > mj) && mainGtU((a = fmap[j - h]) + d' vd'                          // block' quadrant' lastShadow);                          // j -= h) {                          // fmap[j] = a;                          // }                          //                          // unrolled version:                            // start inline mainGTU                          bool onceRunned = false;                          int a = 0;                            HAMMER: while (true)                          {                              if (onceRunned)                              {                                  fmap[j] = a;                                  if ((j -= h) <= mj)                                  {                                      goto END_HAMMER;                                  }                              }                              else {                                  onceRunned = true;                              }                                a = fmap[j - h];                              int i1 = a + d;                              int i2 = vd;                                // following could be done in a loop' but                              // unrolled it for performance:                              if (block[i1 + 1] == block[i2 + 1])                              {                                  if (block[i1 + 2] == block[i2 + 2])                                  {                                      if (block[i1 + 3] == block[i2 + 3])                                      {                                          if (block[i1 + 4] == block[i2 + 4])                                          {                                              if (block[i1 + 5] == block[i2 + 5])                                              {                                                  if (block[(i1 += 6)] == block[(i2 += 6)])                                                  {                                                      int x = lastShadow;                                                      X: while (x > 0)                                                      {                                                          x -= 4;                                                            if (block[i1 + 1] == block[i2 + 1])                                                          {                                                              if (quadrant[i1] == quadrant[i2])                                                              {                                                                  if (block[i1 + 2] == block[i2 + 2])                                                                  {                                                                      if (quadrant[i1 + 1] == quadrant[i2 + 1])                                                                      {                                                                          if (block[i1 + 3] == block[i2 + 3])                                                                          {                                                                              if (quadrant[i1 + 2] == quadrant[i2 + 2])                                                                              {                                                                                  if (block[i1 + 4] == block[i2 + 4])                                                                                  {                                                                                      if (quadrant[i1 + 3] == quadrant[i2 + 3])                                                                                      {                                                                                          if ((i1 += 4) >= lastPlus1)                                                                                          {                                                                                              i1 -= lastPlus1;                                                                                          }                                                                                          if ((i2 += 4) >= lastPlus1)                                                                                          {                                                                                              i2 -= lastPlus1;                                                                                          }                                                                                          workDoneShadow++;                                                                                          goto X;                                                                                      }                                                                                      else if ((quadrant[i1 + 3] > quadrant[i2 + 3]))                                                                                      {                                                                                          goto HAMMER;                                                                                      }                                                                                      else {                                                                                          goto END_HAMMER;                                                                                      }                                                                                  }                                                                                  else if ((block[i1 + 4] & 0xff) > (block[i2 + 4] & 0xff))                                                                                  {                                                                                      goto HAMMER;                                                                                  }                                                                                  else {                                                                                      goto END_HAMMER;                                                                                  }                                                                              }                                                                              else if ((quadrant[i1 + 2] > quadrant[i2 + 2]))                                                                              {                                                                                  goto HAMMER;                                                                              }                                                                              else {                                                                                  goto END_HAMMER;                                                                              }                                                                          }                                                                          else if ((block[i1 + 3] & 0xff) > (block[i2 + 3] & 0xff))                                                                          {                                                                              goto HAMMER;                                                                          }                                                                          else {                                                                              goto END_HAMMER;                                                                          }                                                                      }                                                                      else if ((quadrant[i1 + 1] > quadrant[i2 + 1]))                                                                      {                                                                          goto HAMMER;                                                                      }                                                                      else {                                                                          goto END_HAMMER;                                                                      }                                                                  }                                                                  else if ((block[i1 + 2] & 0xff) > (block[i2 + 2] & 0xff))                                                                  {                                                                      goto HAMMER;                                                                  }                                                                  else {                                                                      goto END_HAMMER;                                                                  }                                                              }                                                              else if ((quadrant[i1] > quadrant[i2]))                                                              {                                                                  goto HAMMER;                                                              }                                                              else {                                                                  goto END_HAMMER;                                                              }                                                          }                                                          else if ((block[i1 + 1] & 0xff) > (block[i2 + 1] & 0xff))                                                          {                                                              goto HAMMER;                                                          }                                                          else {                                                              goto END_HAMMER;                                                          }                                                        }                                                      goto END_HAMMER;                                                  } // while x > 0                                                  else {                                                      if ((block[i1] & 0xff) > (block[i2] & 0xff))                                                      {                                                          goto HAMMER;                                                      }                                                      else {                                                          goto END_HAMMER;                                                      }                                                  }                                              }                                              else if ((block[i1 + 5] & 0xff) > (block[i2 + 5] & 0xff))                                              {                                                  goto HAMMER;                                              }                                              else {                                                  goto END_HAMMER;                                              }                                          }                                          else if ((block[i1 + 4] & 0xff) > (block[i2 + 4] & 0xff))                                          {                                              goto HAMMER;                                          }                                          else {                                              goto END_HAMMER;                                          }                                      }                                      else if ((block[i1 + 3] & 0xff) > (block[i2 + 3] & 0xff))                                      {                                          goto HAMMER;                                      }                                      else {                                          goto END_HAMMER;                                      }                                  }                                  else if ((block[i1 + 2] & 0xff) > (block[i2 + 2] & 0xff))                                  {                                      goto HAMMER;                                  }                                  else {                                      goto END_HAMMER;                                  }                              }                              else if ((block[i1 + 1] & 0xff) > (block[i2 + 1] & 0xff))                              {                                  goto HAMMER;                              }                              else {                                  goto END_HAMMER;                              }                            } // HAMMER                            END_HAMMER:                          // end inline mainGTU                            fmap[j] = v;                      }                        if (firstAttemptShadow && (i <= hi)                          && (workDoneShadow > workLimitShadow))                      {                          goto END_HP;                      }                  }              }
Magic Number,Ionic.BZip2,BZip2Compressor,C:\repos\haf_DotNetZip.Semverd\src\BZip2\BZip2Compressor.cs,mainSimpleSort,The following statement contains a magic number: while (--hp >= 0)              {                  int h = increments[hp];                  int mj = lo + h - 1;                    for (int i = lo + h; i <= hi;)                  {                      // copy                      for (int k = 3; (i <= hi) && (--k >= 0); i++)                      {                          int v = fmap[i];                          int vd = v + d;                          int j = i;                            // for (int a;                          // (j > mj) && mainGtU((a = fmap[j - h]) + d' vd'                          // block' quadrant' lastShadow);                          // j -= h) {                          // fmap[j] = a;                          // }                          //                          // unrolled version:                            // start inline mainGTU                          bool onceRunned = false;                          int a = 0;                            HAMMER: while (true)                          {                              if (onceRunned)                              {                                  fmap[j] = a;                                  if ((j -= h) <= mj)                                  {                                      goto END_HAMMER;                                  }                              }                              else {                                  onceRunned = true;                              }                                a = fmap[j - h];                              int i1 = a + d;                              int i2 = vd;                                // following could be done in a loop' but                              // unrolled it for performance:                              if (block[i1 + 1] == block[i2 + 1])                              {                                  if (block[i1 + 2] == block[i2 + 2])                                  {                                      if (block[i1 + 3] == block[i2 + 3])                                      {                                          if (block[i1 + 4] == block[i2 + 4])                                          {                                              if (block[i1 + 5] == block[i2 + 5])                                              {                                                  if (block[(i1 += 6)] == block[(i2 += 6)])                                                  {                                                      int x = lastShadow;                                                      X: while (x > 0)                                                      {                                                          x -= 4;                                                            if (block[i1 + 1] == block[i2 + 1])                                                          {                                                              if (quadrant[i1] == quadrant[i2])                                                              {                                                                  if (block[i1 + 2] == block[i2 + 2])                                                                  {                                                                      if (quadrant[i1 + 1] == quadrant[i2 + 1])                                                                      {                                                                          if (block[i1 + 3] == block[i2 + 3])                                                                          {                                                                              if (quadrant[i1 + 2] == quadrant[i2 + 2])                                                                              {                                                                                  if (block[i1 + 4] == block[i2 + 4])                                                                                  {                                                                                      if (quadrant[i1 + 3] == quadrant[i2 + 3])                                                                                      {                                                                                          if ((i1 += 4) >= lastPlus1)                                                                                          {                                                                                              i1 -= lastPlus1;                                                                                          }                                                                                          if ((i2 += 4) >= lastPlus1)                                                                                          {                                                                                              i2 -= lastPlus1;                                                                                          }                                                                                          workDoneShadow++;                                                                                          goto X;                                                                                      }                                                                                      else if ((quadrant[i1 + 3] > quadrant[i2 + 3]))                                                                                      {                                                                                          goto HAMMER;                                                                                      }                                                                                      else {                                                                                          goto END_HAMMER;                                                                                      }                                                                                  }                                                                                  else if ((block[i1 + 4] & 0xff) > (block[i2 + 4] & 0xff))                                                                                  {                                                                                      goto HAMMER;                                                                                  }                                                                                  else {                                                                                      goto END_HAMMER;                                                                                  }                                                                              }                                                                              else if ((quadrant[i1 + 2] > quadrant[i2 + 2]))                                                                              {                                                                                  goto HAMMER;                                                                              }                                                                              else {                                                                                  goto END_HAMMER;                                                                              }                                                                          }                                                                          else if ((block[i1 + 3] & 0xff) > (block[i2 + 3] & 0xff))                                                                          {                                                                              goto HAMMER;                                                                          }                                                                          else {                                                                              goto END_HAMMER;                                                                          }                                                                      }                                                                      else if ((quadrant[i1 + 1] > quadrant[i2 + 1]))                                                                      {                                                                          goto HAMMER;                                                                      }                                                                      else {                                                                          goto END_HAMMER;                                                                      }                                                                  }                                                                  else if ((block[i1 + 2] & 0xff) > (block[i2 + 2] & 0xff))                                                                  {                                                                      goto HAMMER;                                                                  }                                                                  else {                                                                      goto END_HAMMER;                                                                  }                                                              }                                                              else if ((quadrant[i1] > quadrant[i2]))                                                              {                                                                  goto HAMMER;                                                              }                                                              else {                                                                  goto END_HAMMER;                                                              }                                                          }                                                          else if ((block[i1 + 1] & 0xff) > (block[i2 + 1] & 0xff))                                                          {                                                              goto HAMMER;                                                          }                                                          else {                                                              goto END_HAMMER;                                                          }                                                        }                                                      goto END_HAMMER;                                                  } // while x > 0                                                  else {                                                      if ((block[i1] & 0xff) > (block[i2] & 0xff))                                                      {                                                          goto HAMMER;                                                      }                                                      else {                                                          goto END_HAMMER;                                                      }                                                  }                                              }                                              else if ((block[i1 + 5] & 0xff) > (block[i2 + 5] & 0xff))                                              {                                                  goto HAMMER;                                              }                                              else {                                                  goto END_HAMMER;                                              }                                          }                                          else if ((block[i1 + 4] & 0xff) > (block[i2 + 4] & 0xff))                                          {                                              goto HAMMER;                                          }                                          else {                                              goto END_HAMMER;                                          }                                      }                                      else if ((block[i1 + 3] & 0xff) > (block[i2 + 3] & 0xff))                                      {                                          goto HAMMER;                                      }                                      else {                                          goto END_HAMMER;                                      }                                  }                                  else if ((block[i1 + 2] & 0xff) > (block[i2 + 2] & 0xff))                                  {                                      goto HAMMER;                                  }                                  else {                                      goto END_HAMMER;                                  }                              }                              else if ((block[i1 + 1] & 0xff) > (block[i2 + 1] & 0xff))                              {                                  goto HAMMER;                              }                              else {                                  goto END_HAMMER;                              }                            } // HAMMER                            END_HAMMER:                          // end inline mainGTU                            fmap[j] = v;                      }                        if (firstAttemptShadow && (i <= hi)                          && (workDoneShadow > workLimitShadow))                      {                          goto END_HP;                      }                  }              }
Magic Number,Ionic.BZip2,BZip2Compressor,C:\repos\haf_DotNetZip.Semverd\src\BZip2\BZip2Compressor.cs,mainSimpleSort,The following statement contains a magic number: while (--hp >= 0)              {                  int h = increments[hp];                  int mj = lo + h - 1;                    for (int i = lo + h; i <= hi;)                  {                      // copy                      for (int k = 3; (i <= hi) && (--k >= 0); i++)                      {                          int v = fmap[i];                          int vd = v + d;                          int j = i;                            // for (int a;                          // (j > mj) && mainGtU((a = fmap[j - h]) + d' vd'                          // block' quadrant' lastShadow);                          // j -= h) {                          // fmap[j] = a;                          // }                          //                          // unrolled version:                            // start inline mainGTU                          bool onceRunned = false;                          int a = 0;                            HAMMER: while (true)                          {                              if (onceRunned)                              {                                  fmap[j] = a;                                  if ((j -= h) <= mj)                                  {                                      goto END_HAMMER;                                  }                              }                              else {                                  onceRunned = true;                              }                                a = fmap[j - h];                              int i1 = a + d;                              int i2 = vd;                                // following could be done in a loop' but                              // unrolled it for performance:                              if (block[i1 + 1] == block[i2 + 1])                              {                                  if (block[i1 + 2] == block[i2 + 2])                                  {                                      if (block[i1 + 3] == block[i2 + 3])                                      {                                          if (block[i1 + 4] == block[i2 + 4])                                          {                                              if (block[i1 + 5] == block[i2 + 5])                                              {                                                  if (block[(i1 += 6)] == block[(i2 += 6)])                                                  {                                                      int x = lastShadow;                                                      X: while (x > 0)                                                      {                                                          x -= 4;                                                            if (block[i1 + 1] == block[i2 + 1])                                                          {                                                              if (quadrant[i1] == quadrant[i2])                                                              {                                                                  if (block[i1 + 2] == block[i2 + 2])                                                                  {                                                                      if (quadrant[i1 + 1] == quadrant[i2 + 1])                                                                      {                                                                          if (block[i1 + 3] == block[i2 + 3])                                                                          {                                                                              if (quadrant[i1 + 2] == quadrant[i2 + 2])                                                                              {                                                                                  if (block[i1 + 4] == block[i2 + 4])                                                                                  {                                                                                      if (quadrant[i1 + 3] == quadrant[i2 + 3])                                                                                      {                                                                                          if ((i1 += 4) >= lastPlus1)                                                                                          {                                                                                              i1 -= lastPlus1;                                                                                          }                                                                                          if ((i2 += 4) >= lastPlus1)                                                                                          {                                                                                              i2 -= lastPlus1;                                                                                          }                                                                                          workDoneShadow++;                                                                                          goto X;                                                                                      }                                                                                      else if ((quadrant[i1 + 3] > quadrant[i2 + 3]))                                                                                      {                                                                                          goto HAMMER;                                                                                      }                                                                                      else {                                                                                          goto END_HAMMER;                                                                                      }                                                                                  }                                                                                  else if ((block[i1 + 4] & 0xff) > (block[i2 + 4] & 0xff))                                                                                  {                                                                                      goto HAMMER;                                                                                  }                                                                                  else {                                                                                      goto END_HAMMER;                                                                                  }                                                                              }                                                                              else if ((quadrant[i1 + 2] > quadrant[i2 + 2]))                                                                              {                                                                                  goto HAMMER;                                                                              }                                                                              else {                                                                                  goto END_HAMMER;                                                                              }                                                                          }                                                                          else if ((block[i1 + 3] & 0xff) > (block[i2 + 3] & 0xff))                                                                          {                                                                              goto HAMMER;                                                                          }                                                                          else {                                                                              goto END_HAMMER;                                                                          }                                                                      }                                                                      else if ((quadrant[i1 + 1] > quadrant[i2 + 1]))                                                                      {                                                                          goto HAMMER;                                                                      }                                                                      else {                                                                          goto END_HAMMER;                                                                      }                                                                  }                                                                  else if ((block[i1 + 2] & 0xff) > (block[i2 + 2] & 0xff))                                                                  {                                                                      goto HAMMER;                                                                  }                                                                  else {                                                                      goto END_HAMMER;                                                                  }                                                              }                                                              else if ((quadrant[i1] > quadrant[i2]))                                                              {                                                                  goto HAMMER;                                                              }                                                              else {                                                                  goto END_HAMMER;                                                              }                                                          }                                                          else if ((block[i1 + 1] & 0xff) > (block[i2 + 1] & 0xff))                                                          {                                                              goto HAMMER;                                                          }                                                          else {                                                              goto END_HAMMER;                                                          }                                                        }                                                      goto END_HAMMER;                                                  } // while x > 0                                                  else {                                                      if ((block[i1] & 0xff) > (block[i2] & 0xff))                                                      {                                                          goto HAMMER;                                                      }                                                      else {                                                          goto END_HAMMER;                                                      }                                                  }                                              }                                              else if ((block[i1 + 5] & 0xff) > (block[i2 + 5] & 0xff))                                              {                                                  goto HAMMER;                                              }                                              else {                                                  goto END_HAMMER;                                              }                                          }                                          else if ((block[i1 + 4] & 0xff) > (block[i2 + 4] & 0xff))                                          {                                              goto HAMMER;                                          }                                          else {                                              goto END_HAMMER;                                          }                                      }                                      else if ((block[i1 + 3] & 0xff) > (block[i2 + 3] & 0xff))                                      {                                          goto HAMMER;                                      }                                      else {                                          goto END_HAMMER;                                      }                                  }                                  else if ((block[i1 + 2] & 0xff) > (block[i2 + 2] & 0xff))                                  {                                      goto HAMMER;                                  }                                  else {                                      goto END_HAMMER;                                  }                              }                              else if ((block[i1 + 1] & 0xff) > (block[i2 + 1] & 0xff))                              {                                  goto HAMMER;                              }                              else {                                  goto END_HAMMER;                              }                            } // HAMMER                            END_HAMMER:                          // end inline mainGTU                            fmap[j] = v;                      }                        if (firstAttemptShadow && (i <= hi)                          && (workDoneShadow > workLimitShadow))                      {                          goto END_HP;                      }                  }              }
Magic Number,Ionic.BZip2,BZip2Compressor,C:\repos\haf_DotNetZip.Semverd\src\BZip2\BZip2Compressor.cs,mainSimpleSort,The following statement contains a magic number: while (--hp >= 0)              {                  int h = increments[hp];                  int mj = lo + h - 1;                    for (int i = lo + h; i <= hi;)                  {                      // copy                      for (int k = 3; (i <= hi) && (--k >= 0); i++)                      {                          int v = fmap[i];                          int vd = v + d;                          int j = i;                            // for (int a;                          // (j > mj) && mainGtU((a = fmap[j - h]) + d' vd'                          // block' quadrant' lastShadow);                          // j -= h) {                          // fmap[j] = a;                          // }                          //                          // unrolled version:                            // start inline mainGTU                          bool onceRunned = false;                          int a = 0;                            HAMMER: while (true)                          {                              if (onceRunned)                              {                                  fmap[j] = a;                                  if ((j -= h) <= mj)                                  {                                      goto END_HAMMER;                                  }                              }                              else {                                  onceRunned = true;                              }                                a = fmap[j - h];                              int i1 = a + d;                              int i2 = vd;                                // following could be done in a loop' but                              // unrolled it for performance:                              if (block[i1 + 1] == block[i2 + 1])                              {                                  if (block[i1 + 2] == block[i2 + 2])                                  {                                      if (block[i1 + 3] == block[i2 + 3])                                      {                                          if (block[i1 + 4] == block[i2 + 4])                                          {                                              if (block[i1 + 5] == block[i2 + 5])                                              {                                                  if (block[(i1 += 6)] == block[(i2 += 6)])                                                  {                                                      int x = lastShadow;                                                      X: while (x > 0)                                                      {                                                          x -= 4;                                                            if (block[i1 + 1] == block[i2 + 1])                                                          {                                                              if (quadrant[i1] == quadrant[i2])                                                              {                                                                  if (block[i1 + 2] == block[i2 + 2])                                                                  {                                                                      if (quadrant[i1 + 1] == quadrant[i2 + 1])                                                                      {                                                                          if (block[i1 + 3] == block[i2 + 3])                                                                          {                                                                              if (quadrant[i1 + 2] == quadrant[i2 + 2])                                                                              {                                                                                  if (block[i1 + 4] == block[i2 + 4])                                                                                  {                                                                                      if (quadrant[i1 + 3] == quadrant[i2 + 3])                                                                                      {                                                                                          if ((i1 += 4) >= lastPlus1)                                                                                          {                                                                                              i1 -= lastPlus1;                                                                                          }                                                                                          if ((i2 += 4) >= lastPlus1)                                                                                          {                                                                                              i2 -= lastPlus1;                                                                                          }                                                                                          workDoneShadow++;                                                                                          goto X;                                                                                      }                                                                                      else if ((quadrant[i1 + 3] > quadrant[i2 + 3]))                                                                                      {                                                                                          goto HAMMER;                                                                                      }                                                                                      else {                                                                                          goto END_HAMMER;                                                                                      }                                                                                  }                                                                                  else if ((block[i1 + 4] & 0xff) > (block[i2 + 4] & 0xff))                                                                                  {                                                                                      goto HAMMER;                                                                                  }                                                                                  else {                                                                                      goto END_HAMMER;                                                                                  }                                                                              }                                                                              else if ((quadrant[i1 + 2] > quadrant[i2 + 2]))                                                                              {                                                                                  goto HAMMER;                                                                              }                                                                              else {                                                                                  goto END_HAMMER;                                                                              }                                                                          }                                                                          else if ((block[i1 + 3] & 0xff) > (block[i2 + 3] & 0xff))                                                                          {                                                                              goto HAMMER;                                                                          }                                                                          else {                                                                              goto END_HAMMER;                                                                          }                                                                      }                                                                      else if ((quadrant[i1 + 1] > quadrant[i2 + 1]))                                                                      {                                                                          goto HAMMER;                                                                      }                                                                      else {                                                                          goto END_HAMMER;                                                                      }                                                                  }                                                                  else if ((block[i1 + 2] & 0xff) > (block[i2 + 2] & 0xff))                                                                  {                                                                      goto HAMMER;                                                                  }                                                                  else {                                                                      goto END_HAMMER;                                                                  }                                                              }                                                              else if ((quadrant[i1] > quadrant[i2]))                                                              {                                                                  goto HAMMER;                                                              }                                                              else {                                                                  goto END_HAMMER;                                                              }                                                          }                                                          else if ((block[i1 + 1] & 0xff) > (block[i2 + 1] & 0xff))                                                          {                                                              goto HAMMER;                                                          }                                                          else {                                                              goto END_HAMMER;                                                          }                                                        }                                                      goto END_HAMMER;                                                  } // while x > 0                                                  else {                                                      if ((block[i1] & 0xff) > (block[i2] & 0xff))                                                      {                                                          goto HAMMER;                                                      }                                                      else {                                                          goto END_HAMMER;                                                      }                                                  }                                              }                                              else if ((block[i1 + 5] & 0xff) > (block[i2 + 5] & 0xff))                                              {                                                  goto HAMMER;                                              }                                              else {                                                  goto END_HAMMER;                                              }                                          }                                          else if ((block[i1 + 4] & 0xff) > (block[i2 + 4] & 0xff))                                          {                                              goto HAMMER;                                          }                                          else {                                              goto END_HAMMER;                                          }                                      }                                      else if ((block[i1 + 3] & 0xff) > (block[i2 + 3] & 0xff))                                      {                                          goto HAMMER;                                      }                                      else {                                          goto END_HAMMER;                                      }                                  }                                  else if ((block[i1 + 2] & 0xff) > (block[i2 + 2] & 0xff))                                  {                                      goto HAMMER;                                  }                                  else {                                      goto END_HAMMER;                                  }                              }                              else if ((block[i1 + 1] & 0xff) > (block[i2 + 1] & 0xff))                              {                                  goto HAMMER;                              }                              else {                                  goto END_HAMMER;                              }                            } // HAMMER                            END_HAMMER:                          // end inline mainGTU                            fmap[j] = v;                      }                        if (firstAttemptShadow && (i <= hi)                          && (workDoneShadow > workLimitShadow))                      {                          goto END_HP;                      }                  }              }
Magic Number,Ionic.BZip2,BZip2Compressor,C:\repos\haf_DotNetZip.Semverd\src\BZip2\BZip2Compressor.cs,mainSimpleSort,The following statement contains a magic number: while (--hp >= 0)              {                  int h = increments[hp];                  int mj = lo + h - 1;                    for (int i = lo + h; i <= hi;)                  {                      // copy                      for (int k = 3; (i <= hi) && (--k >= 0); i++)                      {                          int v = fmap[i];                          int vd = v + d;                          int j = i;                            // for (int a;                          // (j > mj) && mainGtU((a = fmap[j - h]) + d' vd'                          // block' quadrant' lastShadow);                          // j -= h) {                          // fmap[j] = a;                          // }                          //                          // unrolled version:                            // start inline mainGTU                          bool onceRunned = false;                          int a = 0;                            HAMMER: while (true)                          {                              if (onceRunned)                              {                                  fmap[j] = a;                                  if ((j -= h) <= mj)                                  {                                      goto END_HAMMER;                                  }                              }                              else {                                  onceRunned = true;                              }                                a = fmap[j - h];                              int i1 = a + d;                              int i2 = vd;                                // following could be done in a loop' but                              // unrolled it for performance:                              if (block[i1 + 1] == block[i2 + 1])                              {                                  if (block[i1 + 2] == block[i2 + 2])                                  {                                      if (block[i1 + 3] == block[i2 + 3])                                      {                                          if (block[i1 + 4] == block[i2 + 4])                                          {                                              if (block[i1 + 5] == block[i2 + 5])                                              {                                                  if (block[(i1 += 6)] == block[(i2 += 6)])                                                  {                                                      int x = lastShadow;                                                      X: while (x > 0)                                                      {                                                          x -= 4;                                                            if (block[i1 + 1] == block[i2 + 1])                                                          {                                                              if (quadrant[i1] == quadrant[i2])                                                              {                                                                  if (block[i1 + 2] == block[i2 + 2])                                                                  {                                                                      if (quadrant[i1 + 1] == quadrant[i2 + 1])                                                                      {                                                                          if (block[i1 + 3] == block[i2 + 3])                                                                          {                                                                              if (quadrant[i1 + 2] == quadrant[i2 + 2])                                                                              {                                                                                  if (block[i1 + 4] == block[i2 + 4])                                                                                  {                                                                                      if (quadrant[i1 + 3] == quadrant[i2 + 3])                                                                                      {                                                                                          if ((i1 += 4) >= lastPlus1)                                                                                          {                                                                                              i1 -= lastPlus1;                                                                                          }                                                                                          if ((i2 += 4) >= lastPlus1)                                                                                          {                                                                                              i2 -= lastPlus1;                                                                                          }                                                                                          workDoneShadow++;                                                                                          goto X;                                                                                      }                                                                                      else if ((quadrant[i1 + 3] > quadrant[i2 + 3]))                                                                                      {                                                                                          goto HAMMER;                                                                                      }                                                                                      else {                                                                                          goto END_HAMMER;                                                                                      }                                                                                  }                                                                                  else if ((block[i1 + 4] & 0xff) > (block[i2 + 4] & 0xff))                                                                                  {                                                                                      goto HAMMER;                                                                                  }                                                                                  else {                                                                                      goto END_HAMMER;                                                                                  }                                                                              }                                                                              else if ((quadrant[i1 + 2] > quadrant[i2 + 2]))                                                                              {                                                                                  goto HAMMER;                                                                              }                                                                              else {                                                                                  goto END_HAMMER;                                                                              }                                                                          }                                                                          else if ((block[i1 + 3] & 0xff) > (block[i2 + 3] & 0xff))                                                                          {                                                                              goto HAMMER;                                                                          }                                                                          else {                                                                              goto END_HAMMER;                                                                          }                                                                      }                                                                      else if ((quadrant[i1 + 1] > quadrant[i2 + 1]))                                                                      {                                                                          goto HAMMER;                                                                      }                                                                      else {                                                                          goto END_HAMMER;                                                                      }                                                                  }                                                                  else if ((block[i1 + 2] & 0xff) > (block[i2 + 2] & 0xff))                                                                  {                                                                      goto HAMMER;                                                                  }                                                                  else {                                                                      goto END_HAMMER;                                                                  }                                                              }                                                              else if ((quadrant[i1] > quadrant[i2]))                                                              {                                                                  goto HAMMER;                                                              }                                                              else {                                                                  goto END_HAMMER;                                                              }                                                          }                                                          else if ((block[i1 + 1] & 0xff) > (block[i2 + 1] & 0xff))                                                          {                                                              goto HAMMER;                                                          }                                                          else {                                                              goto END_HAMMER;                                                          }                                                        }                                                      goto END_HAMMER;                                                  } // while x > 0                                                  else {                                                      if ((block[i1] & 0xff) > (block[i2] & 0xff))                                                      {                                                          goto HAMMER;                                                      }                                                      else {                                                          goto END_HAMMER;                                                      }                                                  }                                              }                                              else if ((block[i1 + 5] & 0xff) > (block[i2 + 5] & 0xff))                                              {                                                  goto HAMMER;                                              }                                              else {                                                  goto END_HAMMER;                                              }                                          }                                          else if ((block[i1 + 4] & 0xff) > (block[i2 + 4] & 0xff))                                          {                                              goto HAMMER;                                          }                                          else {                                              goto END_HAMMER;                                          }                                      }                                      else if ((block[i1 + 3] & 0xff) > (block[i2 + 3] & 0xff))                                      {                                          goto HAMMER;                                      }                                      else {                                          goto END_HAMMER;                                      }                                  }                                  else if ((block[i1 + 2] & 0xff) > (block[i2 + 2] & 0xff))                                  {                                      goto HAMMER;                                  }                                  else {                                      goto END_HAMMER;                                  }                              }                              else if ((block[i1 + 1] & 0xff) > (block[i2 + 1] & 0xff))                              {                                  goto HAMMER;                              }                              else {                                  goto END_HAMMER;                              }                            } // HAMMER                            END_HAMMER:                          // end inline mainGTU                            fmap[j] = v;                      }                        if (firstAttemptShadow && (i <= hi)                          && (workDoneShadow > workLimitShadow))                      {                          goto END_HP;                      }                  }              }
Magic Number,Ionic.BZip2,BZip2Compressor,C:\repos\haf_DotNetZip.Semverd\src\BZip2\BZip2Compressor.cs,mainSimpleSort,The following statement contains a magic number: while (--hp >= 0)              {                  int h = increments[hp];                  int mj = lo + h - 1;                    for (int i = lo + h; i <= hi;)                  {                      // copy                      for (int k = 3; (i <= hi) && (--k >= 0); i++)                      {                          int v = fmap[i];                          int vd = v + d;                          int j = i;                            // for (int a;                          // (j > mj) && mainGtU((a = fmap[j - h]) + d' vd'                          // block' quadrant' lastShadow);                          // j -= h) {                          // fmap[j] = a;                          // }                          //                          // unrolled version:                            // start inline mainGTU                          bool onceRunned = false;                          int a = 0;                            HAMMER: while (true)                          {                              if (onceRunned)                              {                                  fmap[j] = a;                                  if ((j -= h) <= mj)                                  {                                      goto END_HAMMER;                                  }                              }                              else {                                  onceRunned = true;                              }                                a = fmap[j - h];                              int i1 = a + d;                              int i2 = vd;                                // following could be done in a loop' but                              // unrolled it for performance:                              if (block[i1 + 1] == block[i2 + 1])                              {                                  if (block[i1 + 2] == block[i2 + 2])                                  {                                      if (block[i1 + 3] == block[i2 + 3])                                      {                                          if (block[i1 + 4] == block[i2 + 4])                                          {                                              if (block[i1 + 5] == block[i2 + 5])                                              {                                                  if (block[(i1 += 6)] == block[(i2 += 6)])                                                  {                                                      int x = lastShadow;                                                      X: while (x > 0)                                                      {                                                          x -= 4;                                                            if (block[i1 + 1] == block[i2 + 1])                                                          {                                                              if (quadrant[i1] == quadrant[i2])                                                              {                                                                  if (block[i1 + 2] == block[i2 + 2])                                                                  {                                                                      if (quadrant[i1 + 1] == quadrant[i2 + 1])                                                                      {                                                                          if (block[i1 + 3] == block[i2 + 3])                                                                          {                                                                              if (quadrant[i1 + 2] == quadrant[i2 + 2])                                                                              {                                                                                  if (block[i1 + 4] == block[i2 + 4])                                                                                  {                                                                                      if (quadrant[i1 + 3] == quadrant[i2 + 3])                                                                                      {                                                                                          if ((i1 += 4) >= lastPlus1)                                                                                          {                                                                                              i1 -= lastPlus1;                                                                                          }                                                                                          if ((i2 += 4) >= lastPlus1)                                                                                          {                                                                                              i2 -= lastPlus1;                                                                                          }                                                                                          workDoneShadow++;                                                                                          goto X;                                                                                      }                                                                                      else if ((quadrant[i1 + 3] > quadrant[i2 + 3]))                                                                                      {                                                                                          goto HAMMER;                                                                                      }                                                                                      else {                                                                                          goto END_HAMMER;                                                                                      }                                                                                  }                                                                                  else if ((block[i1 + 4] & 0xff) > (block[i2 + 4] & 0xff))                                                                                  {                                                                                      goto HAMMER;                                                                                  }                                                                                  else {                                                                                      goto END_HAMMER;                                                                                  }                                                                              }                                                                              else if ((quadrant[i1 + 2] > quadrant[i2 + 2]))                                                                              {                                                                                  goto HAMMER;                                                                              }                                                                              else {                                                                                  goto END_HAMMER;                                                                              }                                                                          }                                                                          else if ((block[i1 + 3] & 0xff) > (block[i2 + 3] & 0xff))                                                                          {                                                                              goto HAMMER;                                                                          }                                                                          else {                                                                              goto END_HAMMER;                                                                          }                                                                      }                                                                      else if ((quadrant[i1 + 1] > quadrant[i2 + 1]))                                                                      {                                                                          goto HAMMER;                                                                      }                                                                      else {                                                                          goto END_HAMMER;                                                                      }                                                                  }                                                                  else if ((block[i1 + 2] & 0xff) > (block[i2 + 2] & 0xff))                                                                  {                                                                      goto HAMMER;                                                                  }                                                                  else {                                                                      goto END_HAMMER;                                                                  }                                                              }                                                              else if ((quadrant[i1] > quadrant[i2]))                                                              {                                                                  goto HAMMER;                                                              }                                                              else {                                                                  goto END_HAMMER;                                                              }                                                          }                                                          else if ((block[i1 + 1] & 0xff) > (block[i2 + 1] & 0xff))                                                          {                                                              goto HAMMER;                                                          }                                                          else {                                                              goto END_HAMMER;                                                          }                                                        }                                                      goto END_HAMMER;                                                  } // while x > 0                                                  else {                                                      if ((block[i1] & 0xff) > (block[i2] & 0xff))                                                      {                                                          goto HAMMER;                                                      }                                                      else {                                                          goto END_HAMMER;                                                      }                                                  }                                              }                                              else if ((block[i1 + 5] & 0xff) > (block[i2 + 5] & 0xff))                                              {                                                  goto HAMMER;                                              }                                              else {                                                  goto END_HAMMER;                                              }                                          }                                          else if ((block[i1 + 4] & 0xff) > (block[i2 + 4] & 0xff))                                          {                                              goto HAMMER;                                          }                                          else {                                              goto END_HAMMER;                                          }                                      }                                      else if ((block[i1 + 3] & 0xff) > (block[i2 + 3] & 0xff))                                      {                                          goto HAMMER;                                      }                                      else {                                          goto END_HAMMER;                                      }                                  }                                  else if ((block[i1 + 2] & 0xff) > (block[i2 + 2] & 0xff))                                  {                                      goto HAMMER;                                  }                                  else {                                      goto END_HAMMER;                                  }                              }                              else if ((block[i1 + 1] & 0xff) > (block[i2 + 1] & 0xff))                              {                                  goto HAMMER;                              }                              else {                                  goto END_HAMMER;                              }                            } // HAMMER                            END_HAMMER:                          // end inline mainGTU                            fmap[j] = v;                      }                        if (firstAttemptShadow && (i <= hi)                          && (workDoneShadow > workLimitShadow))                      {                          goto END_HP;                      }                  }              }
Magic Number,Ionic.BZip2,BZip2Compressor,C:\repos\haf_DotNetZip.Semverd\src\BZip2\BZip2Compressor.cs,mainSimpleSort,The following statement contains a magic number: while (--hp >= 0)              {                  int h = increments[hp];                  int mj = lo + h - 1;                    for (int i = lo + h; i <= hi;)                  {                      // copy                      for (int k = 3; (i <= hi) && (--k >= 0); i++)                      {                          int v = fmap[i];                          int vd = v + d;                          int j = i;                            // for (int a;                          // (j > mj) && mainGtU((a = fmap[j - h]) + d' vd'                          // block' quadrant' lastShadow);                          // j -= h) {                          // fmap[j] = a;                          // }                          //                          // unrolled version:                            // start inline mainGTU                          bool onceRunned = false;                          int a = 0;                            HAMMER: while (true)                          {                              if (onceRunned)                              {                                  fmap[j] = a;                                  if ((j -= h) <= mj)                                  {                                      goto END_HAMMER;                                  }                              }                              else {                                  onceRunned = true;                              }                                a = fmap[j - h];                              int i1 = a + d;                              int i2 = vd;                                // following could be done in a loop' but                              // unrolled it for performance:                              if (block[i1 + 1] == block[i2 + 1])                              {                                  if (block[i1 + 2] == block[i2 + 2])                                  {                                      if (block[i1 + 3] == block[i2 + 3])                                      {                                          if (block[i1 + 4] == block[i2 + 4])                                          {                                              if (block[i1 + 5] == block[i2 + 5])                                              {                                                  if (block[(i1 += 6)] == block[(i2 += 6)])                                                  {                                                      int x = lastShadow;                                                      X: while (x > 0)                                                      {                                                          x -= 4;                                                            if (block[i1 + 1] == block[i2 + 1])                                                          {                                                              if (quadrant[i1] == quadrant[i2])                                                              {                                                                  if (block[i1 + 2] == block[i2 + 2])                                                                  {                                                                      if (quadrant[i1 + 1] == quadrant[i2 + 1])                                                                      {                                                                          if (block[i1 + 3] == block[i2 + 3])                                                                          {                                                                              if (quadrant[i1 + 2] == quadrant[i2 + 2])                                                                              {                                                                                  if (block[i1 + 4] == block[i2 + 4])                                                                                  {                                                                                      if (quadrant[i1 + 3] == quadrant[i2 + 3])                                                                                      {                                                                                          if ((i1 += 4) >= lastPlus1)                                                                                          {                                                                                              i1 -= lastPlus1;                                                                                          }                                                                                          if ((i2 += 4) >= lastPlus1)                                                                                          {                                                                                              i2 -= lastPlus1;                                                                                          }                                                                                          workDoneShadow++;                                                                                          goto X;                                                                                      }                                                                                      else if ((quadrant[i1 + 3] > quadrant[i2 + 3]))                                                                                      {                                                                                          goto HAMMER;                                                                                      }                                                                                      else {                                                                                          goto END_HAMMER;                                                                                      }                                                                                  }                                                                                  else if ((block[i1 + 4] & 0xff) > (block[i2 + 4] & 0xff))                                                                                  {                                                                                      goto HAMMER;                                                                                  }                                                                                  else {                                                                                      goto END_HAMMER;                                                                                  }                                                                              }                                                                              else if ((quadrant[i1 + 2] > quadrant[i2 + 2]))                                                                              {                                                                                  goto HAMMER;                                                                              }                                                                              else {                                                                                  goto END_HAMMER;                                                                              }                                                                          }                                                                          else if ((block[i1 + 3] & 0xff) > (block[i2 + 3] & 0xff))                                                                          {                                                                              goto HAMMER;                                                                          }                                                                          else {                                                                              goto END_HAMMER;                                                                          }                                                                      }                                                                      else if ((quadrant[i1 + 1] > quadrant[i2 + 1]))                                                                      {                                                                          goto HAMMER;                                                                      }                                                                      else {                                                                          goto END_HAMMER;                                                                      }                                                                  }                                                                  else if ((block[i1 + 2] & 0xff) > (block[i2 + 2] & 0xff))                                                                  {                                                                      goto HAMMER;                                                                  }                                                                  else {                                                                      goto END_HAMMER;                                                                  }                                                              }                                                              else if ((quadrant[i1] > quadrant[i2]))                                                              {                                                                  goto HAMMER;                                                              }                                                              else {                                                                  goto END_HAMMER;                                                              }                                                          }                                                          else if ((block[i1 + 1] & 0xff) > (block[i2 + 1] & 0xff))                                                          {                                                              goto HAMMER;                                                          }                                                          else {                                                              goto END_HAMMER;                                                          }                                                        }                                                      goto END_HAMMER;                                                  } // while x > 0                                                  else {                                                      if ((block[i1] & 0xff) > (block[i2] & 0xff))                                                      {                                                          goto HAMMER;                                                      }                                                      else {                                                          goto END_HAMMER;                                                      }                                                  }                                              }                                              else if ((block[i1 + 5] & 0xff) > (block[i2 + 5] & 0xff))                                              {                                                  goto HAMMER;                                              }                                              else {                                                  goto END_HAMMER;                                              }                                          }                                          else if ((block[i1 + 4] & 0xff) > (block[i2 + 4] & 0xff))                                          {                                              goto HAMMER;                                          }                                          else {                                              goto END_HAMMER;                                          }                                      }                                      else if ((block[i1 + 3] & 0xff) > (block[i2 + 3] & 0xff))                                      {                                          goto HAMMER;                                      }                                      else {                                          goto END_HAMMER;                                      }                                  }                                  else if ((block[i1 + 2] & 0xff) > (block[i2 + 2] & 0xff))                                  {                                      goto HAMMER;                                  }                                  else {                                      goto END_HAMMER;                                  }                              }                              else if ((block[i1 + 1] & 0xff) > (block[i2 + 1] & 0xff))                              {                                  goto HAMMER;                              }                              else {                                  goto END_HAMMER;                              }                            } // HAMMER                            END_HAMMER:                          // end inline mainGTU                            fmap[j] = v;                      }                        if (firstAttemptShadow && (i <= hi)                          && (workDoneShadow > workLimitShadow))                      {                          goto END_HP;                      }                  }              }
Magic Number,Ionic.BZip2,BZip2Compressor,C:\repos\haf_DotNetZip.Semverd\src\BZip2\BZip2Compressor.cs,mainSimpleSort,The following statement contains a magic number: while (--hp >= 0)              {                  int h = increments[hp];                  int mj = lo + h - 1;                    for (int i = lo + h; i <= hi;)                  {                      // copy                      for (int k = 3; (i <= hi) && (--k >= 0); i++)                      {                          int v = fmap[i];                          int vd = v + d;                          int j = i;                            // for (int a;                          // (j > mj) && mainGtU((a = fmap[j - h]) + d' vd'                          // block' quadrant' lastShadow);                          // j -= h) {                          // fmap[j] = a;                          // }                          //                          // unrolled version:                            // start inline mainGTU                          bool onceRunned = false;                          int a = 0;                            HAMMER: while (true)                          {                              if (onceRunned)                              {                                  fmap[j] = a;                                  if ((j -= h) <= mj)                                  {                                      goto END_HAMMER;                                  }                              }                              else {                                  onceRunned = true;                              }                                a = fmap[j - h];                              int i1 = a + d;                              int i2 = vd;                                // following could be done in a loop' but                              // unrolled it for performance:                              if (block[i1 + 1] == block[i2 + 1])                              {                                  if (block[i1 + 2] == block[i2 + 2])                                  {                                      if (block[i1 + 3] == block[i2 + 3])                                      {                                          if (block[i1 + 4] == block[i2 + 4])                                          {                                              if (block[i1 + 5] == block[i2 + 5])                                              {                                                  if (block[(i1 += 6)] == block[(i2 += 6)])                                                  {                                                      int x = lastShadow;                                                      X: while (x > 0)                                                      {                                                          x -= 4;                                                            if (block[i1 + 1] == block[i2 + 1])                                                          {                                                              if (quadrant[i1] == quadrant[i2])                                                              {                                                                  if (block[i1 + 2] == block[i2 + 2])                                                                  {                                                                      if (quadrant[i1 + 1] == quadrant[i2 + 1])                                                                      {                                                                          if (block[i1 + 3] == block[i2 + 3])                                                                          {                                                                              if (quadrant[i1 + 2] == quadrant[i2 + 2])                                                                              {                                                                                  if (block[i1 + 4] == block[i2 + 4])                                                                                  {                                                                                      if (quadrant[i1 + 3] == quadrant[i2 + 3])                                                                                      {                                                                                          if ((i1 += 4) >= lastPlus1)                                                                                          {                                                                                              i1 -= lastPlus1;                                                                                          }                                                                                          if ((i2 += 4) >= lastPlus1)                                                                                          {                                                                                              i2 -= lastPlus1;                                                                                          }                                                                                          workDoneShadow++;                                                                                          goto X;                                                                                      }                                                                                      else if ((quadrant[i1 + 3] > quadrant[i2 + 3]))                                                                                      {                                                                                          goto HAMMER;                                                                                      }                                                                                      else {                                                                                          goto END_HAMMER;                                                                                      }                                                                                  }                                                                                  else if ((block[i1 + 4] & 0xff) > (block[i2 + 4] & 0xff))                                                                                  {                                                                                      goto HAMMER;                                                                                  }                                                                                  else {                                                                                      goto END_HAMMER;                                                                                  }                                                                              }                                                                              else if ((quadrant[i1 + 2] > quadrant[i2 + 2]))                                                                              {                                                                                  goto HAMMER;                                                                              }                                                                              else {                                                                                  goto END_HAMMER;                                                                              }                                                                          }                                                                          else if ((block[i1 + 3] & 0xff) > (block[i2 + 3] & 0xff))                                                                          {                                                                              goto HAMMER;                                                                          }                                                                          else {                                                                              goto END_HAMMER;                                                                          }                                                                      }                                                                      else if ((quadrant[i1 + 1] > quadrant[i2 + 1]))                                                                      {                                                                          goto HAMMER;                                                                      }                                                                      else {                                                                          goto END_HAMMER;                                                                      }                                                                  }                                                                  else if ((block[i1 + 2] & 0xff) > (block[i2 + 2] & 0xff))                                                                  {                                                                      goto HAMMER;                                                                  }                                                                  else {                                                                      goto END_HAMMER;                                                                  }                                                              }                                                              else if ((quadrant[i1] > quadrant[i2]))                                                              {                                                                  goto HAMMER;                                                              }                                                              else {                                                                  goto END_HAMMER;                                                              }                                                          }                                                          else if ((block[i1 + 1] & 0xff) > (block[i2 + 1] & 0xff))                                                          {                                                              goto HAMMER;                                                          }                                                          else {                                                              goto END_HAMMER;                                                          }                                                        }                                                      goto END_HAMMER;                                                  } // while x > 0                                                  else {                                                      if ((block[i1] & 0xff) > (block[i2] & 0xff))                                                      {                                                          goto HAMMER;                                                      }                                                      else {                                                          goto END_HAMMER;                                                      }                                                  }                                              }                                              else if ((block[i1 + 5] & 0xff) > (block[i2 + 5] & 0xff))                                              {                                                  goto HAMMER;                                              }                                              else {                                                  goto END_HAMMER;                                              }                                          }                                          else if ((block[i1 + 4] & 0xff) > (block[i2 + 4] & 0xff))                                          {                                              goto HAMMER;                                          }                                          else {                                              goto END_HAMMER;                                          }                                      }                                      else if ((block[i1 + 3] & 0xff) > (block[i2 + 3] & 0xff))                                      {                                          goto HAMMER;                                      }                                      else {                                          goto END_HAMMER;                                      }                                  }                                  else if ((block[i1 + 2] & 0xff) > (block[i2 + 2] & 0xff))                                  {                                      goto HAMMER;                                  }                                  else {                                      goto END_HAMMER;                                  }                              }                              else if ((block[i1 + 1] & 0xff) > (block[i2 + 1] & 0xff))                              {                                  goto HAMMER;                              }                              else {                                  goto END_HAMMER;                              }                            } // HAMMER                            END_HAMMER:                          // end inline mainGTU                            fmap[j] = v;                      }                        if (firstAttemptShadow && (i <= hi)                          && (workDoneShadow > workLimitShadow))                      {                          goto END_HP;                      }                  }              }
Magic Number,Ionic.BZip2,BZip2Compressor,C:\repos\haf_DotNetZip.Semverd\src\BZip2\BZip2Compressor.cs,mainSimpleSort,The following statement contains a magic number: while (--hp >= 0)              {                  int h = increments[hp];                  int mj = lo + h - 1;                    for (int i = lo + h; i <= hi;)                  {                      // copy                      for (int k = 3; (i <= hi) && (--k >= 0); i++)                      {                          int v = fmap[i];                          int vd = v + d;                          int j = i;                            // for (int a;                          // (j > mj) && mainGtU((a = fmap[j - h]) + d' vd'                          // block' quadrant' lastShadow);                          // j -= h) {                          // fmap[j] = a;                          // }                          //                          // unrolled version:                            // start inline mainGTU                          bool onceRunned = false;                          int a = 0;                            HAMMER: while (true)                          {                              if (onceRunned)                              {                                  fmap[j] = a;                                  if ((j -= h) <= mj)                                  {                                      goto END_HAMMER;                                  }                              }                              else {                                  onceRunned = true;                              }                                a = fmap[j - h];                              int i1 = a + d;                              int i2 = vd;                                // following could be done in a loop' but                              // unrolled it for performance:                              if (block[i1 + 1] == block[i2 + 1])                              {                                  if (block[i1 + 2] == block[i2 + 2])                                  {                                      if (block[i1 + 3] == block[i2 + 3])                                      {                                          if (block[i1 + 4] == block[i2 + 4])                                          {                                              if (block[i1 + 5] == block[i2 + 5])                                              {                                                  if (block[(i1 += 6)] == block[(i2 += 6)])                                                  {                                                      int x = lastShadow;                                                      X: while (x > 0)                                                      {                                                          x -= 4;                                                            if (block[i1 + 1] == block[i2 + 1])                                                          {                                                              if (quadrant[i1] == quadrant[i2])                                                              {                                                                  if (block[i1 + 2] == block[i2 + 2])                                                                  {                                                                      if (quadrant[i1 + 1] == quadrant[i2 + 1])                                                                      {                                                                          if (block[i1 + 3] == block[i2 + 3])                                                                          {                                                                              if (quadrant[i1 + 2] == quadrant[i2 + 2])                                                                              {                                                                                  if (block[i1 + 4] == block[i2 + 4])                                                                                  {                                                                                      if (quadrant[i1 + 3] == quadrant[i2 + 3])                                                                                      {                                                                                          if ((i1 += 4) >= lastPlus1)                                                                                          {                                                                                              i1 -= lastPlus1;                                                                                          }                                                                                          if ((i2 += 4) >= lastPlus1)                                                                                          {                                                                                              i2 -= lastPlus1;                                                                                          }                                                                                          workDoneShadow++;                                                                                          goto X;                                                                                      }                                                                                      else if ((quadrant[i1 + 3] > quadrant[i2 + 3]))                                                                                      {                                                                                          goto HAMMER;                                                                                      }                                                                                      else {                                                                                          goto END_HAMMER;                                                                                      }                                                                                  }                                                                                  else if ((block[i1 + 4] & 0xff) > (block[i2 + 4] & 0xff))                                                                                  {                                                                                      goto HAMMER;                                                                                  }                                                                                  else {                                                                                      goto END_HAMMER;                                                                                  }                                                                              }                                                                              else if ((quadrant[i1 + 2] > quadrant[i2 + 2]))                                                                              {                                                                                  goto HAMMER;                                                                              }                                                                              else {                                                                                  goto END_HAMMER;                                                                              }                                                                          }                                                                          else if ((block[i1 + 3] & 0xff) > (block[i2 + 3] & 0xff))                                                                          {                                                                              goto HAMMER;                                                                          }                                                                          else {                                                                              goto END_HAMMER;                                                                          }                                                                      }                                                                      else if ((quadrant[i1 + 1] > quadrant[i2 + 1]))                                                                      {                                                                          goto HAMMER;                                                                      }                                                                      else {                                                                          goto END_HAMMER;                                                                      }                                                                  }                                                                  else if ((block[i1 + 2] & 0xff) > (block[i2 + 2] & 0xff))                                                                  {                                                                      goto HAMMER;                                                                  }                                                                  else {                                                                      goto END_HAMMER;                                                                  }                                                              }                                                              else if ((quadrant[i1] > quadrant[i2]))                                                              {                                                                  goto HAMMER;                                                              }                                                              else {                                                                  goto END_HAMMER;                                                              }                                                          }                                                          else if ((block[i1 + 1] & 0xff) > (block[i2 + 1] & 0xff))                                                          {                                                              goto HAMMER;                                                          }                                                          else {                                                              goto END_HAMMER;                                                          }                                                        }                                                      goto END_HAMMER;                                                  } // while x > 0                                                  else {                                                      if ((block[i1] & 0xff) > (block[i2] & 0xff))                                                      {                                                          goto HAMMER;                                                      }                                                      else {                                                          goto END_HAMMER;                                                      }                                                  }                                              }                                              else if ((block[i1 + 5] & 0xff) > (block[i2 + 5] & 0xff))                                              {                                                  goto HAMMER;                                              }                                              else {                                                  goto END_HAMMER;                                              }                                          }                                          else if ((block[i1 + 4] & 0xff) > (block[i2 + 4] & 0xff))                                          {                                              goto HAMMER;                                          }                                          else {                                              goto END_HAMMER;                                          }                                      }                                      else if ((block[i1 + 3] & 0xff) > (block[i2 + 3] & 0xff))                                      {                                          goto HAMMER;                                      }                                      else {                                          goto END_HAMMER;                                      }                                  }                                  else if ((block[i1 + 2] & 0xff) > (block[i2 + 2] & 0xff))                                  {                                      goto HAMMER;                                  }                                  else {                                      goto END_HAMMER;                                  }                              }                              else if ((block[i1 + 1] & 0xff) > (block[i2 + 1] & 0xff))                              {                                  goto HAMMER;                              }                              else {                                  goto END_HAMMER;                              }                            } // HAMMER                            END_HAMMER:                          // end inline mainGTU                            fmap[j] = v;                      }                        if (firstAttemptShadow && (i <= hi)                          && (workDoneShadow > workLimitShadow))                      {                          goto END_HP;                      }                  }              }
Magic Number,Ionic.BZip2,BZip2Compressor,C:\repos\haf_DotNetZip.Semverd\src\BZip2\BZip2Compressor.cs,mainSimpleSort,The following statement contains a magic number: while (--hp >= 0)              {                  int h = increments[hp];                  int mj = lo + h - 1;                    for (int i = lo + h; i <= hi;)                  {                      // copy                      for (int k = 3; (i <= hi) && (--k >= 0); i++)                      {                          int v = fmap[i];                          int vd = v + d;                          int j = i;                            // for (int a;                          // (j > mj) && mainGtU((a = fmap[j - h]) + d' vd'                          // block' quadrant' lastShadow);                          // j -= h) {                          // fmap[j] = a;                          // }                          //                          // unrolled version:                            // start inline mainGTU                          bool onceRunned = false;                          int a = 0;                            HAMMER: while (true)                          {                              if (onceRunned)                              {                                  fmap[j] = a;                                  if ((j -= h) <= mj)                                  {                                      goto END_HAMMER;                                  }                              }                              else {                                  onceRunned = true;                              }                                a = fmap[j - h];                              int i1 = a + d;                              int i2 = vd;                                // following could be done in a loop' but                              // unrolled it for performance:                              if (block[i1 + 1] == block[i2 + 1])                              {                                  if (block[i1 + 2] == block[i2 + 2])                                  {                                      if (block[i1 + 3] == block[i2 + 3])                                      {                                          if (block[i1 + 4] == block[i2 + 4])                                          {                                              if (block[i1 + 5] == block[i2 + 5])                                              {                                                  if (block[(i1 += 6)] == block[(i2 += 6)])                                                  {                                                      int x = lastShadow;                                                      X: while (x > 0)                                                      {                                                          x -= 4;                                                            if (block[i1 + 1] == block[i2 + 1])                                                          {                                                              if (quadrant[i1] == quadrant[i2])                                                              {                                                                  if (block[i1 + 2] == block[i2 + 2])                                                                  {                                                                      if (quadrant[i1 + 1] == quadrant[i2 + 1])                                                                      {                                                                          if (block[i1 + 3] == block[i2 + 3])                                                                          {                                                                              if (quadrant[i1 + 2] == quadrant[i2 + 2])                                                                              {                                                                                  if (block[i1 + 4] == block[i2 + 4])                                                                                  {                                                                                      if (quadrant[i1 + 3] == quadrant[i2 + 3])                                                                                      {                                                                                          if ((i1 += 4) >= lastPlus1)                                                                                          {                                                                                              i1 -= lastPlus1;                                                                                          }                                                                                          if ((i2 += 4) >= lastPlus1)                                                                                          {                                                                                              i2 -= lastPlus1;                                                                                          }                                                                                          workDoneShadow++;                                                                                          goto X;                                                                                      }                                                                                      else if ((quadrant[i1 + 3] > quadrant[i2 + 3]))                                                                                      {                                                                                          goto HAMMER;                                                                                      }                                                                                      else {                                                                                          goto END_HAMMER;                                                                                      }                                                                                  }                                                                                  else if ((block[i1 + 4] & 0xff) > (block[i2 + 4] & 0xff))                                                                                  {                                                                                      goto HAMMER;                                                                                  }                                                                                  else {                                                                                      goto END_HAMMER;                                                                                  }                                                                              }                                                                              else if ((quadrant[i1 + 2] > quadrant[i2 + 2]))                                                                              {                                                                                  goto HAMMER;                                                                              }                                                                              else {                                                                                  goto END_HAMMER;                                                                              }                                                                          }                                                                          else if ((block[i1 + 3] & 0xff) > (block[i2 + 3] & 0xff))                                                                          {                                                                              goto HAMMER;                                                                          }                                                                          else {                                                                              goto END_HAMMER;                                                                          }                                                                      }                                                                      else if ((quadrant[i1 + 1] > quadrant[i2 + 1]))                                                                      {                                                                          goto HAMMER;                                                                      }                                                                      else {                                                                          goto END_HAMMER;                                                                      }                                                                  }                                                                  else if ((block[i1 + 2] & 0xff) > (block[i2 + 2] & 0xff))                                                                  {                                                                      goto HAMMER;                                                                  }                                                                  else {                                                                      goto END_HAMMER;                                                                  }                                                              }                                                              else if ((quadrant[i1] > quadrant[i2]))                                                              {                                                                  goto HAMMER;                                                              }                                                              else {                                                                  goto END_HAMMER;                                                              }                                                          }                                                          else if ((block[i1 + 1] & 0xff) > (block[i2 + 1] & 0xff))                                                          {                                                              goto HAMMER;                                                          }                                                          else {                                                              goto END_HAMMER;                                                          }                                                        }                                                      goto END_HAMMER;                                                  } // while x > 0                                                  else {                                                      if ((block[i1] & 0xff) > (block[i2] & 0xff))                                                      {                                                          goto HAMMER;                                                      }                                                      else {                                                          goto END_HAMMER;                                                      }                                                  }                                              }                                              else if ((block[i1 + 5] & 0xff) > (block[i2 + 5] & 0xff))                                              {                                                  goto HAMMER;                                              }                                              else {                                                  goto END_HAMMER;                                              }                                          }                                          else if ((block[i1 + 4] & 0xff) > (block[i2 + 4] & 0xff))                                          {                                              goto HAMMER;                                          }                                          else {                                              goto END_HAMMER;                                          }                                      }                                      else if ((block[i1 + 3] & 0xff) > (block[i2 + 3] & 0xff))                                      {                                          goto HAMMER;                                      }                                      else {                                          goto END_HAMMER;                                      }                                  }                                  else if ((block[i1 + 2] & 0xff) > (block[i2 + 2] & 0xff))                                  {                                      goto HAMMER;                                  }                                  else {                                      goto END_HAMMER;                                  }                              }                              else if ((block[i1 + 1] & 0xff) > (block[i2 + 1] & 0xff))                              {                                  goto HAMMER;                              }                              else {                                  goto END_HAMMER;                              }                            } // HAMMER                            END_HAMMER:                          // end inline mainGTU                            fmap[j] = v;                      }                        if (firstAttemptShadow && (i <= hi)                          && (workDoneShadow > workLimitShadow))                      {                          goto END_HP;                      }                  }              }
Magic Number,Ionic.BZip2,BZip2Compressor,C:\repos\haf_DotNetZip.Semverd\src\BZip2\BZip2Compressor.cs,mainSimpleSort,The following statement contains a magic number: while (--hp >= 0)              {                  int h = increments[hp];                  int mj = lo + h - 1;                    for (int i = lo + h; i <= hi;)                  {                      // copy                      for (int k = 3; (i <= hi) && (--k >= 0); i++)                      {                          int v = fmap[i];                          int vd = v + d;                          int j = i;                            // for (int a;                          // (j > mj) && mainGtU((a = fmap[j - h]) + d' vd'                          // block' quadrant' lastShadow);                          // j -= h) {                          // fmap[j] = a;                          // }                          //                          // unrolled version:                            // start inline mainGTU                          bool onceRunned = false;                          int a = 0;                            HAMMER: while (true)                          {                              if (onceRunned)                              {                                  fmap[j] = a;                                  if ((j -= h) <= mj)                                  {                                      goto END_HAMMER;                                  }                              }                              else {                                  onceRunned = true;                              }                                a = fmap[j - h];                              int i1 = a + d;                              int i2 = vd;                                // following could be done in a loop' but                              // unrolled it for performance:                              if (block[i1 + 1] == block[i2 + 1])                              {                                  if (block[i1 + 2] == block[i2 + 2])                                  {                                      if (block[i1 + 3] == block[i2 + 3])                                      {                                          if (block[i1 + 4] == block[i2 + 4])                                          {                                              if (block[i1 + 5] == block[i2 + 5])                                              {                                                  if (block[(i1 += 6)] == block[(i2 += 6)])                                                  {                                                      int x = lastShadow;                                                      X: while (x > 0)                                                      {                                                          x -= 4;                                                            if (block[i1 + 1] == block[i2 + 1])                                                          {                                                              if (quadrant[i1] == quadrant[i2])                                                              {                                                                  if (block[i1 + 2] == block[i2 + 2])                                                                  {                                                                      if (quadrant[i1 + 1] == quadrant[i2 + 1])                                                                      {                                                                          if (block[i1 + 3] == block[i2 + 3])                                                                          {                                                                              if (quadrant[i1 + 2] == quadrant[i2 + 2])                                                                              {                                                                                  if (block[i1 + 4] == block[i2 + 4])                                                                                  {                                                                                      if (quadrant[i1 + 3] == quadrant[i2 + 3])                                                                                      {                                                                                          if ((i1 += 4) >= lastPlus1)                                                                                          {                                                                                              i1 -= lastPlus1;                                                                                          }                                                                                          if ((i2 += 4) >= lastPlus1)                                                                                          {                                                                                              i2 -= lastPlus1;                                                                                          }                                                                                          workDoneShadow++;                                                                                          goto X;                                                                                      }                                                                                      else if ((quadrant[i1 + 3] > quadrant[i2 + 3]))                                                                                      {                                                                                          goto HAMMER;                                                                                      }                                                                                      else {                                                                                          goto END_HAMMER;                                                                                      }                                                                                  }                                                                                  else if ((block[i1 + 4] & 0xff) > (block[i2 + 4] & 0xff))                                                                                  {                                                                                      goto HAMMER;                                                                                  }                                                                                  else {                                                                                      goto END_HAMMER;                                                                                  }                                                                              }                                                                              else if ((quadrant[i1 + 2] > quadrant[i2 + 2]))                                                                              {                                                                                  goto HAMMER;                                                                              }                                                                              else {                                                                                  goto END_HAMMER;                                                                              }                                                                          }                                                                          else if ((block[i1 + 3] & 0xff) > (block[i2 + 3] & 0xff))                                                                          {                                                                              goto HAMMER;                                                                          }                                                                          else {                                                                              goto END_HAMMER;                                                                          }                                                                      }                                                                      else if ((quadrant[i1 + 1] > quadrant[i2 + 1]))                                                                      {                                                                          goto HAMMER;                                                                      }                                                                      else {                                                                          goto END_HAMMER;                                                                      }                                                                  }                                                                  else if ((block[i1 + 2] & 0xff) > (block[i2 + 2] & 0xff))                                                                  {                                                                      goto HAMMER;                                                                  }                                                                  else {                                                                      goto END_HAMMER;                                                                  }                                                              }                                                              else if ((quadrant[i1] > quadrant[i2]))                                                              {                                                                  goto HAMMER;                                                              }                                                              else {                                                                  goto END_HAMMER;                                                              }                                                          }                                                          else if ((block[i1 + 1] & 0xff) > (block[i2 + 1] & 0xff))                                                          {                                                              goto HAMMER;                                                          }                                                          else {                                                              goto END_HAMMER;                                                          }                                                        }                                                      goto END_HAMMER;                                                  } // while x > 0                                                  else {                                                      if ((block[i1] & 0xff) > (block[i2] & 0xff))                                                      {                                                          goto HAMMER;                                                      }                                                      else {                                                          goto END_HAMMER;                                                      }                                                  }                                              }                                              else if ((block[i1 + 5] & 0xff) > (block[i2 + 5] & 0xff))                                              {                                                  goto HAMMER;                                              }                                              else {                                                  goto END_HAMMER;                                              }                                          }                                          else if ((block[i1 + 4] & 0xff) > (block[i2 + 4] & 0xff))                                          {                                              goto HAMMER;                                          }                                          else {                                              goto END_HAMMER;                                          }                                      }                                      else if ((block[i1 + 3] & 0xff) > (block[i2 + 3] & 0xff))                                      {                                          goto HAMMER;                                      }                                      else {                                          goto END_HAMMER;                                      }                                  }                                  else if ((block[i1 + 2] & 0xff) > (block[i2 + 2] & 0xff))                                  {                                      goto HAMMER;                                  }                                  else {                                      goto END_HAMMER;                                  }                              }                              else if ((block[i1 + 1] & 0xff) > (block[i2 + 1] & 0xff))                              {                                  goto HAMMER;                              }                              else {                                  goto END_HAMMER;                              }                            } // HAMMER                            END_HAMMER:                          // end inline mainGTU                            fmap[j] = v;                      }                        if (firstAttemptShadow && (i <= hi)                          && (workDoneShadow > workLimitShadow))                      {                          goto END_HP;                      }                  }              }
Magic Number,Ionic.BZip2,BZip2Compressor,C:\repos\haf_DotNetZip.Semverd\src\BZip2\BZip2Compressor.cs,mainSimpleSort,The following statement contains a magic number: while (--hp >= 0)              {                  int h = increments[hp];                  int mj = lo + h - 1;                    for (int i = lo + h; i <= hi;)                  {                      // copy                      for (int k = 3; (i <= hi) && (--k >= 0); i++)                      {                          int v = fmap[i];                          int vd = v + d;                          int j = i;                            // for (int a;                          // (j > mj) && mainGtU((a = fmap[j - h]) + d' vd'                          // block' quadrant' lastShadow);                          // j -= h) {                          // fmap[j] = a;                          // }                          //                          // unrolled version:                            // start inline mainGTU                          bool onceRunned = false;                          int a = 0;                            HAMMER: while (true)                          {                              if (onceRunned)                              {                                  fmap[j] = a;                                  if ((j -= h) <= mj)                                  {                                      goto END_HAMMER;                                  }                              }                              else {                                  onceRunned = true;                              }                                a = fmap[j - h];                              int i1 = a + d;                              int i2 = vd;                                // following could be done in a loop' but                              // unrolled it for performance:                              if (block[i1 + 1] == block[i2 + 1])                              {                                  if (block[i1 + 2] == block[i2 + 2])                                  {                                      if (block[i1 + 3] == block[i2 + 3])                                      {                                          if (block[i1 + 4] == block[i2 + 4])                                          {                                              if (block[i1 + 5] == block[i2 + 5])                                              {                                                  if (block[(i1 += 6)] == block[(i2 += 6)])                                                  {                                                      int x = lastShadow;                                                      X: while (x > 0)                                                      {                                                          x -= 4;                                                            if (block[i1 + 1] == block[i2 + 1])                                                          {                                                              if (quadrant[i1] == quadrant[i2])                                                              {                                                                  if (block[i1 + 2] == block[i2 + 2])                                                                  {                                                                      if (quadrant[i1 + 1] == quadrant[i2 + 1])                                                                      {                                                                          if (block[i1 + 3] == block[i2 + 3])                                                                          {                                                                              if (quadrant[i1 + 2] == quadrant[i2 + 2])                                                                              {                                                                                  if (block[i1 + 4] == block[i2 + 4])                                                                                  {                                                                                      if (quadrant[i1 + 3] == quadrant[i2 + 3])                                                                                      {                                                                                          if ((i1 += 4) >= lastPlus1)                                                                                          {                                                                                              i1 -= lastPlus1;                                                                                          }                                                                                          if ((i2 += 4) >= lastPlus1)                                                                                          {                                                                                              i2 -= lastPlus1;                                                                                          }                                                                                          workDoneShadow++;                                                                                          goto X;                                                                                      }                                                                                      else if ((quadrant[i1 + 3] > quadrant[i2 + 3]))                                                                                      {                                                                                          goto HAMMER;                                                                                      }                                                                                      else {                                                                                          goto END_HAMMER;                                                                                      }                                                                                  }                                                                                  else if ((block[i1 + 4] & 0xff) > (block[i2 + 4] & 0xff))                                                                                  {                                                                                      goto HAMMER;                                                                                  }                                                                                  else {                                                                                      goto END_HAMMER;                                                                                  }                                                                              }                                                                              else if ((quadrant[i1 + 2] > quadrant[i2 + 2]))                                                                              {                                                                                  goto HAMMER;                                                                              }                                                                              else {                                                                                  goto END_HAMMER;                                                                              }                                                                          }                                                                          else if ((block[i1 + 3] & 0xff) > (block[i2 + 3] & 0xff))                                                                          {                                                                              goto HAMMER;                                                                          }                                                                          else {                                                                              goto END_HAMMER;                                                                          }                                                                      }                                                                      else if ((quadrant[i1 + 1] > quadrant[i2 + 1]))                                                                      {                                                                          goto HAMMER;                                                                      }                                                                      else {                                                                          goto END_HAMMER;                                                                      }                                                                  }                                                                  else if ((block[i1 + 2] & 0xff) > (block[i2 + 2] & 0xff))                                                                  {                                                                      goto HAMMER;                                                                  }                                                                  else {                                                                      goto END_HAMMER;                                                                  }                                                              }                                                              else if ((quadrant[i1] > quadrant[i2]))                                                              {                                                                  goto HAMMER;                                                              }                                                              else {                                                                  goto END_HAMMER;                                                              }                                                          }                                                          else if ((block[i1 + 1] & 0xff) > (block[i2 + 1] & 0xff))                                                          {                                                              goto HAMMER;                                                          }                                                          else {                                                              goto END_HAMMER;                                                          }                                                        }                                                      goto END_HAMMER;                                                  } // while x > 0                                                  else {                                                      if ((block[i1] & 0xff) > (block[i2] & 0xff))                                                      {                                                          goto HAMMER;                                                      }                                                      else {                                                          goto END_HAMMER;                                                      }                                                  }                                              }                                              else if ((block[i1 + 5] & 0xff) > (block[i2 + 5] & 0xff))                                              {                                                  goto HAMMER;                                              }                                              else {                                                  goto END_HAMMER;                                              }                                          }                                          else if ((block[i1 + 4] & 0xff) > (block[i2 + 4] & 0xff))                                          {                                              goto HAMMER;                                          }                                          else {                                              goto END_HAMMER;                                          }                                      }                                      else if ((block[i1 + 3] & 0xff) > (block[i2 + 3] & 0xff))                                      {                                          goto HAMMER;                                      }                                      else {                                          goto END_HAMMER;                                      }                                  }                                  else if ((block[i1 + 2] & 0xff) > (block[i2 + 2] & 0xff))                                  {                                      goto HAMMER;                                  }                                  else {                                      goto END_HAMMER;                                  }                              }                              else if ((block[i1 + 1] & 0xff) > (block[i2 + 1] & 0xff))                              {                                  goto HAMMER;                              }                              else {                                  goto END_HAMMER;                              }                            } // HAMMER                            END_HAMMER:                          // end inline mainGTU                            fmap[j] = v;                      }                        if (firstAttemptShadow && (i <= hi)                          && (workDoneShadow > workLimitShadow))                      {                          goto END_HP;                      }                  }              }
Magic Number,Ionic.BZip2,BZip2Compressor,C:\repos\haf_DotNetZip.Semverd\src\BZip2\BZip2Compressor.cs,mainSimpleSort,The following statement contains a magic number: while (--hp >= 0)              {                  int h = increments[hp];                  int mj = lo + h - 1;                    for (int i = lo + h; i <= hi;)                  {                      // copy                      for (int k = 3; (i <= hi) && (--k >= 0); i++)                      {                          int v = fmap[i];                          int vd = v + d;                          int j = i;                            // for (int a;                          // (j > mj) && mainGtU((a = fmap[j - h]) + d' vd'                          // block' quadrant' lastShadow);                          // j -= h) {                          // fmap[j] = a;                          // }                          //                          // unrolled version:                            // start inline mainGTU                          bool onceRunned = false;                          int a = 0;                            HAMMER: while (true)                          {                              if (onceRunned)                              {                                  fmap[j] = a;                                  if ((j -= h) <= mj)                                  {                                      goto END_HAMMER;                                  }                              }                              else {                                  onceRunned = true;                              }                                a = fmap[j - h];                              int i1 = a + d;                              int i2 = vd;                                // following could be done in a loop' but                              // unrolled it for performance:                              if (block[i1 + 1] == block[i2 + 1])                              {                                  if (block[i1 + 2] == block[i2 + 2])                                  {                                      if (block[i1 + 3] == block[i2 + 3])                                      {                                          if (block[i1 + 4] == block[i2 + 4])                                          {                                              if (block[i1 + 5] == block[i2 + 5])                                              {                                                  if (block[(i1 += 6)] == block[(i2 += 6)])                                                  {                                                      int x = lastShadow;                                                      X: while (x > 0)                                                      {                                                          x -= 4;                                                            if (block[i1 + 1] == block[i2 + 1])                                                          {                                                              if (quadrant[i1] == quadrant[i2])                                                              {                                                                  if (block[i1 + 2] == block[i2 + 2])                                                                  {                                                                      if (quadrant[i1 + 1] == quadrant[i2 + 1])                                                                      {                                                                          if (block[i1 + 3] == block[i2 + 3])                                                                          {                                                                              if (quadrant[i1 + 2] == quadrant[i2 + 2])                                                                              {                                                                                  if (block[i1 + 4] == block[i2 + 4])                                                                                  {                                                                                      if (quadrant[i1 + 3] == quadrant[i2 + 3])                                                                                      {                                                                                          if ((i1 += 4) >= lastPlus1)                                                                                          {                                                                                              i1 -= lastPlus1;                                                                                          }                                                                                          if ((i2 += 4) >= lastPlus1)                                                                                          {                                                                                              i2 -= lastPlus1;                                                                                          }                                                                                          workDoneShadow++;                                                                                          goto X;                                                                                      }                                                                                      else if ((quadrant[i1 + 3] > quadrant[i2 + 3]))                                                                                      {                                                                                          goto HAMMER;                                                                                      }                                                                                      else {                                                                                          goto END_HAMMER;                                                                                      }                                                                                  }                                                                                  else if ((block[i1 + 4] & 0xff) > (block[i2 + 4] & 0xff))                                                                                  {                                                                                      goto HAMMER;                                                                                  }                                                                                  else {                                                                                      goto END_HAMMER;                                                                                  }                                                                              }                                                                              else if ((quadrant[i1 + 2] > quadrant[i2 + 2]))                                                                              {                                                                                  goto HAMMER;                                                                              }                                                                              else {                                                                                  goto END_HAMMER;                                                                              }                                                                          }                                                                          else if ((block[i1 + 3] & 0xff) > (block[i2 + 3] & 0xff))                                                                          {                                                                              goto HAMMER;                                                                          }                                                                          else {                                                                              goto END_HAMMER;                                                                          }                                                                      }                                                                      else if ((quadrant[i1 + 1] > quadrant[i2 + 1]))                                                                      {                                                                          goto HAMMER;                                                                      }                                                                      else {                                                                          goto END_HAMMER;                                                                      }                                                                  }                                                                  else if ((block[i1 + 2] & 0xff) > (block[i2 + 2] & 0xff))                                                                  {                                                                      goto HAMMER;                                                                  }                                                                  else {                                                                      goto END_HAMMER;                                                                  }                                                              }                                                              else if ((quadrant[i1] > quadrant[i2]))                                                              {                                                                  goto HAMMER;                                                              }                                                              else {                                                                  goto END_HAMMER;                                                              }                                                          }                                                          else if ((block[i1 + 1] & 0xff) > (block[i2 + 1] & 0xff))                                                          {                                                              goto HAMMER;                                                          }                                                          else {                                                              goto END_HAMMER;                                                          }                                                        }                                                      goto END_HAMMER;                                                  } // while x > 0                                                  else {                                                      if ((block[i1] & 0xff) > (block[i2] & 0xff))                                                      {                                                          goto HAMMER;                                                      }                                                      else {                                                          goto END_HAMMER;                                                      }                                                  }                                              }                                              else if ((block[i1 + 5] & 0xff) > (block[i2 + 5] & 0xff))                                              {                                                  goto HAMMER;                                              }                                              else {                                                  goto END_HAMMER;                                              }                                          }                                          else if ((block[i1 + 4] & 0xff) > (block[i2 + 4] & 0xff))                                          {                                              goto HAMMER;                                          }                                          else {                                              goto END_HAMMER;                                          }                                      }                                      else if ((block[i1 + 3] & 0xff) > (block[i2 + 3] & 0xff))                                      {                                          goto HAMMER;                                      }                                      else {                                          goto END_HAMMER;                                      }                                  }                                  else if ((block[i1 + 2] & 0xff) > (block[i2 + 2] & 0xff))                                  {                                      goto HAMMER;                                  }                                  else {                                      goto END_HAMMER;                                  }                              }                              else if ((block[i1 + 1] & 0xff) > (block[i2 + 1] & 0xff))                              {                                  goto HAMMER;                              }                              else {                                  goto END_HAMMER;                              }                            } // HAMMER                            END_HAMMER:                          // end inline mainGTU                            fmap[j] = v;                      }                        if (firstAttemptShadow && (i <= hi)                          && (workDoneShadow > workLimitShadow))                      {                          goto END_HP;                      }                  }              }
Magic Number,Ionic.BZip2,BZip2Compressor,C:\repos\haf_DotNetZip.Semverd\src\BZip2\BZip2Compressor.cs,mainSimpleSort,The following statement contains a magic number: while (--hp >= 0)              {                  int h = increments[hp];                  int mj = lo + h - 1;                    for (int i = lo + h; i <= hi;)                  {                      // copy                      for (int k = 3; (i <= hi) && (--k >= 0); i++)                      {                          int v = fmap[i];                          int vd = v + d;                          int j = i;                            // for (int a;                          // (j > mj) && mainGtU((a = fmap[j - h]) + d' vd'                          // block' quadrant' lastShadow);                          // j -= h) {                          // fmap[j] = a;                          // }                          //                          // unrolled version:                            // start inline mainGTU                          bool onceRunned = false;                          int a = 0;                            HAMMER: while (true)                          {                              if (onceRunned)                              {                                  fmap[j] = a;                                  if ((j -= h) <= mj)                                  {                                      goto END_HAMMER;                                  }                              }                              else {                                  onceRunned = true;                              }                                a = fmap[j - h];                              int i1 = a + d;                              int i2 = vd;                                // following could be done in a loop' but                              // unrolled it for performance:                              if (block[i1 + 1] == block[i2 + 1])                              {                                  if (block[i1 + 2] == block[i2 + 2])                                  {                                      if (block[i1 + 3] == block[i2 + 3])                                      {                                          if (block[i1 + 4] == block[i2 + 4])                                          {                                              if (block[i1 + 5] == block[i2 + 5])                                              {                                                  if (block[(i1 += 6)] == block[(i2 += 6)])                                                  {                                                      int x = lastShadow;                                                      X: while (x > 0)                                                      {                                                          x -= 4;                                                            if (block[i1 + 1] == block[i2 + 1])                                                          {                                                              if (quadrant[i1] == quadrant[i2])                                                              {                                                                  if (block[i1 + 2] == block[i2 + 2])                                                                  {                                                                      if (quadrant[i1 + 1] == quadrant[i2 + 1])                                                                      {                                                                          if (block[i1 + 3] == block[i2 + 3])                                                                          {                                                                              if (quadrant[i1 + 2] == quadrant[i2 + 2])                                                                              {                                                                                  if (block[i1 + 4] == block[i2 + 4])                                                                                  {                                                                                      if (quadrant[i1 + 3] == quadrant[i2 + 3])                                                                                      {                                                                                          if ((i1 += 4) >= lastPlus1)                                                                                          {                                                                                              i1 -= lastPlus1;                                                                                          }                                                                                          if ((i2 += 4) >= lastPlus1)                                                                                          {                                                                                              i2 -= lastPlus1;                                                                                          }                                                                                          workDoneShadow++;                                                                                          goto X;                                                                                      }                                                                                      else if ((quadrant[i1 + 3] > quadrant[i2 + 3]))                                                                                      {                                                                                          goto HAMMER;                                                                                      }                                                                                      else {                                                                                          goto END_HAMMER;                                                                                      }                                                                                  }                                                                                  else if ((block[i1 + 4] & 0xff) > (block[i2 + 4] & 0xff))                                                                                  {                                                                                      goto HAMMER;                                                                                  }                                                                                  else {                                                                                      goto END_HAMMER;                                                                                  }                                                                              }                                                                              else if ((quadrant[i1 + 2] > quadrant[i2 + 2]))                                                                              {                                                                                  goto HAMMER;                                                                              }                                                                              else {                                                                                  goto END_HAMMER;                                                                              }                                                                          }                                                                          else if ((block[i1 + 3] & 0xff) > (block[i2 + 3] & 0xff))                                                                          {                                                                              goto HAMMER;                                                                          }                                                                          else {                                                                              goto END_HAMMER;                                                                          }                                                                      }                                                                      else if ((quadrant[i1 + 1] > quadrant[i2 + 1]))                                                                      {                                                                          goto HAMMER;                                                                      }                                                                      else {                                                                          goto END_HAMMER;                                                                      }                                                                  }                                                                  else if ((block[i1 + 2] & 0xff) > (block[i2 + 2] & 0xff))                                                                  {                                                                      goto HAMMER;                                                                  }                                                                  else {                                                                      goto END_HAMMER;                                                                  }                                                              }                                                              else if ((quadrant[i1] > quadrant[i2]))                                                              {                                                                  goto HAMMER;                                                              }                                                              else {                                                                  goto END_HAMMER;                                                              }                                                          }                                                          else if ((block[i1 + 1] & 0xff) > (block[i2 + 1] & 0xff))                                                          {                                                              goto HAMMER;                                                          }                                                          else {                                                              goto END_HAMMER;                                                          }                                                        }                                                      goto END_HAMMER;                                                  } // while x > 0                                                  else {                                                      if ((block[i1] & 0xff) > (block[i2] & 0xff))                                                      {                                                          goto HAMMER;                                                      }                                                      else {                                                          goto END_HAMMER;                                                      }                                                  }                                              }                                              else if ((block[i1 + 5] & 0xff) > (block[i2 + 5] & 0xff))                                              {                                                  goto HAMMER;                                              }                                              else {                                                  goto END_HAMMER;                                              }                                          }                                          else if ((block[i1 + 4] & 0xff) > (block[i2 + 4] & 0xff))                                          {                                              goto HAMMER;                                          }                                          else {                                              goto END_HAMMER;                                          }                                      }                                      else if ((block[i1 + 3] & 0xff) > (block[i2 + 3] & 0xff))                                      {                                          goto HAMMER;                                      }                                      else {                                          goto END_HAMMER;                                      }                                  }                                  else if ((block[i1 + 2] & 0xff) > (block[i2 + 2] & 0xff))                                  {                                      goto HAMMER;                                  }                                  else {                                      goto END_HAMMER;                                  }                              }                              else if ((block[i1 + 1] & 0xff) > (block[i2 + 1] & 0xff))                              {                                  goto HAMMER;                              }                              else {                                  goto END_HAMMER;                              }                            } // HAMMER                            END_HAMMER:                          // end inline mainGTU                            fmap[j] = v;                      }                        if (firstAttemptShadow && (i <= hi)                          && (workDoneShadow > workLimitShadow))                      {                          goto END_HP;                      }                  }              }
Magic Number,Ionic.BZip2,BZip2Compressor,C:\repos\haf_DotNetZip.Semverd\src\BZip2\BZip2Compressor.cs,mainSimpleSort,The following statement contains a magic number: while (--hp >= 0)              {                  int h = increments[hp];                  int mj = lo + h - 1;                    for (int i = lo + h; i <= hi;)                  {                      // copy                      for (int k = 3; (i <= hi) && (--k >= 0); i++)                      {                          int v = fmap[i];                          int vd = v + d;                          int j = i;                            // for (int a;                          // (j > mj) && mainGtU((a = fmap[j - h]) + d' vd'                          // block' quadrant' lastShadow);                          // j -= h) {                          // fmap[j] = a;                          // }                          //                          // unrolled version:                            // start inline mainGTU                          bool onceRunned = false;                          int a = 0;                            HAMMER: while (true)                          {                              if (onceRunned)                              {                                  fmap[j] = a;                                  if ((j -= h) <= mj)                                  {                                      goto END_HAMMER;                                  }                              }                              else {                                  onceRunned = true;                              }                                a = fmap[j - h];                              int i1 = a + d;                              int i2 = vd;                                // following could be done in a loop' but                              // unrolled it for performance:                              if (block[i1 + 1] == block[i2 + 1])                              {                                  if (block[i1 + 2] == block[i2 + 2])                                  {                                      if (block[i1 + 3] == block[i2 + 3])                                      {                                          if (block[i1 + 4] == block[i2 + 4])                                          {                                              if (block[i1 + 5] == block[i2 + 5])                                              {                                                  if (block[(i1 += 6)] == block[(i2 += 6)])                                                  {                                                      int x = lastShadow;                                                      X: while (x > 0)                                                      {                                                          x -= 4;                                                            if (block[i1 + 1] == block[i2 + 1])                                                          {                                                              if (quadrant[i1] == quadrant[i2])                                                              {                                                                  if (block[i1 + 2] == block[i2 + 2])                                                                  {                                                                      if (quadrant[i1 + 1] == quadrant[i2 + 1])                                                                      {                                                                          if (block[i1 + 3] == block[i2 + 3])                                                                          {                                                                              if (quadrant[i1 + 2] == quadrant[i2 + 2])                                                                              {                                                                                  if (block[i1 + 4] == block[i2 + 4])                                                                                  {                                                                                      if (quadrant[i1 + 3] == quadrant[i2 + 3])                                                                                      {                                                                                          if ((i1 += 4) >= lastPlus1)                                                                                          {                                                                                              i1 -= lastPlus1;                                                                                          }                                                                                          if ((i2 += 4) >= lastPlus1)                                                                                          {                                                                                              i2 -= lastPlus1;                                                                                          }                                                                                          workDoneShadow++;                                                                                          goto X;                                                                                      }                                                                                      else if ((quadrant[i1 + 3] > quadrant[i2 + 3]))                                                                                      {                                                                                          goto HAMMER;                                                                                      }                                                                                      else {                                                                                          goto END_HAMMER;                                                                                      }                                                                                  }                                                                                  else if ((block[i1 + 4] & 0xff) > (block[i2 + 4] & 0xff))                                                                                  {                                                                                      goto HAMMER;                                                                                  }                                                                                  else {                                                                                      goto END_HAMMER;                                                                                  }                                                                              }                                                                              else if ((quadrant[i1 + 2] > quadrant[i2 + 2]))                                                                              {                                                                                  goto HAMMER;                                                                              }                                                                              else {                                                                                  goto END_HAMMER;                                                                              }                                                                          }                                                                          else if ((block[i1 + 3] & 0xff) > (block[i2 + 3] & 0xff))                                                                          {                                                                              goto HAMMER;                                                                          }                                                                          else {                                                                              goto END_HAMMER;                                                                          }                                                                      }                                                                      else if ((quadrant[i1 + 1] > quadrant[i2 + 1]))                                                                      {                                                                          goto HAMMER;                                                                      }                                                                      else {                                                                          goto END_HAMMER;                                                                      }                                                                  }                                                                  else if ((block[i1 + 2] & 0xff) > (block[i2 + 2] & 0xff))                                                                  {                                                                      goto HAMMER;                                                                  }                                                                  else {                                                                      goto END_HAMMER;                                                                  }                                                              }                                                              else if ((quadrant[i1] > quadrant[i2]))                                                              {                                                                  goto HAMMER;                                                              }                                                              else {                                                                  goto END_HAMMER;                                                              }                                                          }                                                          else if ((block[i1 + 1] & 0xff) > (block[i2 + 1] & 0xff))                                                          {                                                              goto HAMMER;                                                          }                                                          else {                                                              goto END_HAMMER;                                                          }                                                        }                                                      goto END_HAMMER;                                                  } // while x > 0                                                  else {                                                      if ((block[i1] & 0xff) > (block[i2] & 0xff))                                                      {                                                          goto HAMMER;                                                      }                                                      else {                                                          goto END_HAMMER;                                                      }                                                  }                                              }                                              else if ((block[i1 + 5] & 0xff) > (block[i2 + 5] & 0xff))                                              {                                                  goto HAMMER;                                              }                                              else {                                                  goto END_HAMMER;                                              }                                          }                                          else if ((block[i1 + 4] & 0xff) > (block[i2 + 4] & 0xff))                                          {                                              goto HAMMER;                                          }                                          else {                                              goto END_HAMMER;                                          }                                      }                                      else if ((block[i1 + 3] & 0xff) > (block[i2 + 3] & 0xff))                                      {                                          goto HAMMER;                                      }                                      else {                                          goto END_HAMMER;                                      }                                  }                                  else if ((block[i1 + 2] & 0xff) > (block[i2 + 2] & 0xff))                                  {                                      goto HAMMER;                                  }                                  else {                                      goto END_HAMMER;                                  }                              }                              else if ((block[i1 + 1] & 0xff) > (block[i2 + 1] & 0xff))                              {                                  goto HAMMER;                              }                              else {                                  goto END_HAMMER;                              }                            } // HAMMER                            END_HAMMER:                          // end inline mainGTU                            fmap[j] = v;                      }                        if (firstAttemptShadow && (i <= hi)                          && (workDoneShadow > workLimitShadow))                      {                          goto END_HP;                      }                  }              }
Magic Number,Ionic.BZip2,BZip2Compressor,C:\repos\haf_DotNetZip.Semverd\src\BZip2\BZip2Compressor.cs,mainSimpleSort,The following statement contains a magic number: while (--hp >= 0)              {                  int h = increments[hp];                  int mj = lo + h - 1;                    for (int i = lo + h; i <= hi;)                  {                      // copy                      for (int k = 3; (i <= hi) && (--k >= 0); i++)                      {                          int v = fmap[i];                          int vd = v + d;                          int j = i;                            // for (int a;                          // (j > mj) && mainGtU((a = fmap[j - h]) + d' vd'                          // block' quadrant' lastShadow);                          // j -= h) {                          // fmap[j] = a;                          // }                          //                          // unrolled version:                            // start inline mainGTU                          bool onceRunned = false;                          int a = 0;                            HAMMER: while (true)                          {                              if (onceRunned)                              {                                  fmap[j] = a;                                  if ((j -= h) <= mj)                                  {                                      goto END_HAMMER;                                  }                              }                              else {                                  onceRunned = true;                              }                                a = fmap[j - h];                              int i1 = a + d;                              int i2 = vd;                                // following could be done in a loop' but                              // unrolled it for performance:                              if (block[i1 + 1] == block[i2 + 1])                              {                                  if (block[i1 + 2] == block[i2 + 2])                                  {                                      if (block[i1 + 3] == block[i2 + 3])                                      {                                          if (block[i1 + 4] == block[i2 + 4])                                          {                                              if (block[i1 + 5] == block[i2 + 5])                                              {                                                  if (block[(i1 += 6)] == block[(i2 += 6)])                                                  {                                                      int x = lastShadow;                                                      X: while (x > 0)                                                      {                                                          x -= 4;                                                            if (block[i1 + 1] == block[i2 + 1])                                                          {                                                              if (quadrant[i1] == quadrant[i2])                                                              {                                                                  if (block[i1 + 2] == block[i2 + 2])                                                                  {                                                                      if (quadrant[i1 + 1] == quadrant[i2 + 1])                                                                      {                                                                          if (block[i1 + 3] == block[i2 + 3])                                                                          {                                                                              if (quadrant[i1 + 2] == quadrant[i2 + 2])                                                                              {                                                                                  if (block[i1 + 4] == block[i2 + 4])                                                                                  {                                                                                      if (quadrant[i1 + 3] == quadrant[i2 + 3])                                                                                      {                                                                                          if ((i1 += 4) >= lastPlus1)                                                                                          {                                                                                              i1 -= lastPlus1;                                                                                          }                                                                                          if ((i2 += 4) >= lastPlus1)                                                                                          {                                                                                              i2 -= lastPlus1;                                                                                          }                                                                                          workDoneShadow++;                                                                                          goto X;                                                                                      }                                                                                      else if ((quadrant[i1 + 3] > quadrant[i2 + 3]))                                                                                      {                                                                                          goto HAMMER;                                                                                      }                                                                                      else {                                                                                          goto END_HAMMER;                                                                                      }                                                                                  }                                                                                  else if ((block[i1 + 4] & 0xff) > (block[i2 + 4] & 0xff))                                                                                  {                                                                                      goto HAMMER;                                                                                  }                                                                                  else {                                                                                      goto END_HAMMER;                                                                                  }                                                                              }                                                                              else if ((quadrant[i1 + 2] > quadrant[i2 + 2]))                                                                              {                                                                                  goto HAMMER;                                                                              }                                                                              else {                                                                                  goto END_HAMMER;                                                                              }                                                                          }                                                                          else if ((block[i1 + 3] & 0xff) > (block[i2 + 3] & 0xff))                                                                          {                                                                              goto HAMMER;                                                                          }                                                                          else {                                                                              goto END_HAMMER;                                                                          }                                                                      }                                                                      else if ((quadrant[i1 + 1] > quadrant[i2 + 1]))                                                                      {                                                                          goto HAMMER;                                                                      }                                                                      else {                                                                          goto END_HAMMER;                                                                      }                                                                  }                                                                  else if ((block[i1 + 2] & 0xff) > (block[i2 + 2] & 0xff))                                                                  {                                                                      goto HAMMER;                                                                  }                                                                  else {                                                                      goto END_HAMMER;                                                                  }                                                              }                                                              else if ((quadrant[i1] > quadrant[i2]))                                                              {                                                                  goto HAMMER;                                                              }                                                              else {                                                                  goto END_HAMMER;                                                              }                                                          }                                                          else if ((block[i1 + 1] & 0xff) > (block[i2 + 1] & 0xff))                                                          {                                                              goto HAMMER;                                                          }                                                          else {                                                              goto END_HAMMER;                                                          }                                                        }                                                      goto END_HAMMER;                                                  } // while x > 0                                                  else {                                                      if ((block[i1] & 0xff) > (block[i2] & 0xff))                                                      {                                                          goto HAMMER;                                                      }                                                      else {                                                          goto END_HAMMER;                                                      }                                                  }                                              }                                              else if ((block[i1 + 5] & 0xff) > (block[i2 + 5] & 0xff))                                              {                                                  goto HAMMER;                                              }                                              else {                                                  goto END_HAMMER;                                              }                                          }                                          else if ((block[i1 + 4] & 0xff) > (block[i2 + 4] & 0xff))                                          {                                              goto HAMMER;                                          }                                          else {                                              goto END_HAMMER;                                          }                                      }                                      else if ((block[i1 + 3] & 0xff) > (block[i2 + 3] & 0xff))                                      {                                          goto HAMMER;                                      }                                      else {                                          goto END_HAMMER;                                      }                                  }                                  else if ((block[i1 + 2] & 0xff) > (block[i2 + 2] & 0xff))                                  {                                      goto HAMMER;                                  }                                  else {                                      goto END_HAMMER;                                  }                              }                              else if ((block[i1 + 1] & 0xff) > (block[i2 + 1] & 0xff))                              {                                  goto HAMMER;                              }                              else {                                  goto END_HAMMER;                              }                            } // HAMMER                            END_HAMMER:                          // end inline mainGTU                            fmap[j] = v;                      }                        if (firstAttemptShadow && (i <= hi)                          && (workDoneShadow > workLimitShadow))                      {                          goto END_HP;                      }                  }              }
Magic Number,Ionic.BZip2,BZip2Compressor,C:\repos\haf_DotNetZip.Semverd\src\BZip2\BZip2Compressor.cs,mainSimpleSort,The following statement contains a magic number: while (--hp >= 0)              {                  int h = increments[hp];                  int mj = lo + h - 1;                    for (int i = lo + h; i <= hi;)                  {                      // copy                      for (int k = 3; (i <= hi) && (--k >= 0); i++)                      {                          int v = fmap[i];                          int vd = v + d;                          int j = i;                            // for (int a;                          // (j > mj) && mainGtU((a = fmap[j - h]) + d' vd'                          // block' quadrant' lastShadow);                          // j -= h) {                          // fmap[j] = a;                          // }                          //                          // unrolled version:                            // start inline mainGTU                          bool onceRunned = false;                          int a = 0;                            HAMMER: while (true)                          {                              if (onceRunned)                              {                                  fmap[j] = a;                                  if ((j -= h) <= mj)                                  {                                      goto END_HAMMER;                                  }                              }                              else {                                  onceRunned = true;                              }                                a = fmap[j - h];                              int i1 = a + d;                              int i2 = vd;                                // following could be done in a loop' but                              // unrolled it for performance:                              if (block[i1 + 1] == block[i2 + 1])                              {                                  if (block[i1 + 2] == block[i2 + 2])                                  {                                      if (block[i1 + 3] == block[i2 + 3])                                      {                                          if (block[i1 + 4] == block[i2 + 4])                                          {                                              if (block[i1 + 5] == block[i2 + 5])                                              {                                                  if (block[(i1 += 6)] == block[(i2 += 6)])                                                  {                                                      int x = lastShadow;                                                      X: while (x > 0)                                                      {                                                          x -= 4;                                                            if (block[i1 + 1] == block[i2 + 1])                                                          {                                                              if (quadrant[i1] == quadrant[i2])                                                              {                                                                  if (block[i1 + 2] == block[i2 + 2])                                                                  {                                                                      if (quadrant[i1 + 1] == quadrant[i2 + 1])                                                                      {                                                                          if (block[i1 + 3] == block[i2 + 3])                                                                          {                                                                              if (quadrant[i1 + 2] == quadrant[i2 + 2])                                                                              {                                                                                  if (block[i1 + 4] == block[i2 + 4])                                                                                  {                                                                                      if (quadrant[i1 + 3] == quadrant[i2 + 3])                                                                                      {                                                                                          if ((i1 += 4) >= lastPlus1)                                                                                          {                                                                                              i1 -= lastPlus1;                                                                                          }                                                                                          if ((i2 += 4) >= lastPlus1)                                                                                          {                                                                                              i2 -= lastPlus1;                                                                                          }                                                                                          workDoneShadow++;                                                                                          goto X;                                                                                      }                                                                                      else if ((quadrant[i1 + 3] > quadrant[i2 + 3]))                                                                                      {                                                                                          goto HAMMER;                                                                                      }                                                                                      else {                                                                                          goto END_HAMMER;                                                                                      }                                                                                  }                                                                                  else if ((block[i1 + 4] & 0xff) > (block[i2 + 4] & 0xff))                                                                                  {                                                                                      goto HAMMER;                                                                                  }                                                                                  else {                                                                                      goto END_HAMMER;                                                                                  }                                                                              }                                                                              else if ((quadrant[i1 + 2] > quadrant[i2 + 2]))                                                                              {                                                                                  goto HAMMER;                                                                              }                                                                              else {                                                                                  goto END_HAMMER;                                                                              }                                                                          }                                                                          else if ((block[i1 + 3] & 0xff) > (block[i2 + 3] & 0xff))                                                                          {                                                                              goto HAMMER;                                                                          }                                                                          else {                                                                              goto END_HAMMER;                                                                          }                                                                      }                                                                      else if ((quadrant[i1 + 1] > quadrant[i2 + 1]))                                                                      {                                                                          goto HAMMER;                                                                      }                                                                      else {                                                                          goto END_HAMMER;                                                                      }                                                                  }                                                                  else if ((block[i1 + 2] & 0xff) > (block[i2 + 2] & 0xff))                                                                  {                                                                      goto HAMMER;                                                                  }                                                                  else {                                                                      goto END_HAMMER;                                                                  }                                                              }                                                              else if ((quadrant[i1] > quadrant[i2]))                                                              {                                                                  goto HAMMER;                                                              }                                                              else {                                                                  goto END_HAMMER;                                                              }                                                          }                                                          else if ((block[i1 + 1] & 0xff) > (block[i2 + 1] & 0xff))                                                          {                                                              goto HAMMER;                                                          }                                                          else {                                                              goto END_HAMMER;                                                          }                                                        }                                                      goto END_HAMMER;                                                  } // while x > 0                                                  else {                                                      if ((block[i1] & 0xff) > (block[i2] & 0xff))                                                      {                                                          goto HAMMER;                                                      }                                                      else {                                                          goto END_HAMMER;                                                      }                                                  }                                              }                                              else if ((block[i1 + 5] & 0xff) > (block[i2 + 5] & 0xff))                                              {                                                  goto HAMMER;                                              }                                              else {                                                  goto END_HAMMER;                                              }                                          }                                          else if ((block[i1 + 4] & 0xff) > (block[i2 + 4] & 0xff))                                          {                                              goto HAMMER;                                          }                                          else {                                              goto END_HAMMER;                                          }                                      }                                      else if ((block[i1 + 3] & 0xff) > (block[i2 + 3] & 0xff))                                      {                                          goto HAMMER;                                      }                                      else {                                          goto END_HAMMER;                                      }                                  }                                  else if ((block[i1 + 2] & 0xff) > (block[i2 + 2] & 0xff))                                  {                                      goto HAMMER;                                  }                                  else {                                      goto END_HAMMER;                                  }                              }                              else if ((block[i1 + 1] & 0xff) > (block[i2 + 1] & 0xff))                              {                                  goto HAMMER;                              }                              else {                                  goto END_HAMMER;                              }                            } // HAMMER                            END_HAMMER:                          // end inline mainGTU                            fmap[j] = v;                      }                        if (firstAttemptShadow && (i <= hi)                          && (workDoneShadow > workLimitShadow))                      {                          goto END_HP;                      }                  }              }
Magic Number,Ionic.BZip2,BZip2Compressor,C:\repos\haf_DotNetZip.Semverd\src\BZip2\BZip2Compressor.cs,mainSimpleSort,The following statement contains a magic number: while (--hp >= 0)              {                  int h = increments[hp];                  int mj = lo + h - 1;                    for (int i = lo + h; i <= hi;)                  {                      // copy                      for (int k = 3; (i <= hi) && (--k >= 0); i++)                      {                          int v = fmap[i];                          int vd = v + d;                          int j = i;                            // for (int a;                          // (j > mj) && mainGtU((a = fmap[j - h]) + d' vd'                          // block' quadrant' lastShadow);                          // j -= h) {                          // fmap[j] = a;                          // }                          //                          // unrolled version:                            // start inline mainGTU                          bool onceRunned = false;                          int a = 0;                            HAMMER: while (true)                          {                              if (onceRunned)                              {                                  fmap[j] = a;                                  if ((j -= h) <= mj)                                  {                                      goto END_HAMMER;                                  }                              }                              else {                                  onceRunned = true;                              }                                a = fmap[j - h];                              int i1 = a + d;                              int i2 = vd;                                // following could be done in a loop' but                              // unrolled it for performance:                              if (block[i1 + 1] == block[i2 + 1])                              {                                  if (block[i1 + 2] == block[i2 + 2])                                  {                                      if (block[i1 + 3] == block[i2 + 3])                                      {                                          if (block[i1 + 4] == block[i2 + 4])                                          {                                              if (block[i1 + 5] == block[i2 + 5])                                              {                                                  if (block[(i1 += 6)] == block[(i2 += 6)])                                                  {                                                      int x = lastShadow;                                                      X: while (x > 0)                                                      {                                                          x -= 4;                                                            if (block[i1 + 1] == block[i2 + 1])                                                          {                                                              if (quadrant[i1] == quadrant[i2])                                                              {                                                                  if (block[i1 + 2] == block[i2 + 2])                                                                  {                                                                      if (quadrant[i1 + 1] == quadrant[i2 + 1])                                                                      {                                                                          if (block[i1 + 3] == block[i2 + 3])                                                                          {                                                                              if (quadrant[i1 + 2] == quadrant[i2 + 2])                                                                              {                                                                                  if (block[i1 + 4] == block[i2 + 4])                                                                                  {                                                                                      if (quadrant[i1 + 3] == quadrant[i2 + 3])                                                                                      {                                                                                          if ((i1 += 4) >= lastPlus1)                                                                                          {                                                                                              i1 -= lastPlus1;                                                                                          }                                                                                          if ((i2 += 4) >= lastPlus1)                                                                                          {                                                                                              i2 -= lastPlus1;                                                                                          }                                                                                          workDoneShadow++;                                                                                          goto X;                                                                                      }                                                                                      else if ((quadrant[i1 + 3] > quadrant[i2 + 3]))                                                                                      {                                                                                          goto HAMMER;                                                                                      }                                                                                      else {                                                                                          goto END_HAMMER;                                                                                      }                                                                                  }                                                                                  else if ((block[i1 + 4] & 0xff) > (block[i2 + 4] & 0xff))                                                                                  {                                                                                      goto HAMMER;                                                                                  }                                                                                  else {                                                                                      goto END_HAMMER;                                                                                  }                                                                              }                                                                              else if ((quadrant[i1 + 2] > quadrant[i2 + 2]))                                                                              {                                                                                  goto HAMMER;                                                                              }                                                                              else {                                                                                  goto END_HAMMER;                                                                              }                                                                          }                                                                          else if ((block[i1 + 3] & 0xff) > (block[i2 + 3] & 0xff))                                                                          {                                                                              goto HAMMER;                                                                          }                                                                          else {                                                                              goto END_HAMMER;                                                                          }                                                                      }                                                                      else if ((quadrant[i1 + 1] > quadrant[i2 + 1]))                                                                      {                                                                          goto HAMMER;                                                                      }                                                                      else {                                                                          goto END_HAMMER;                                                                      }                                                                  }                                                                  else if ((block[i1 + 2] & 0xff) > (block[i2 + 2] & 0xff))                                                                  {                                                                      goto HAMMER;                                                                  }                                                                  else {                                                                      goto END_HAMMER;                                                                  }                                                              }                                                              else if ((quadrant[i1] > quadrant[i2]))                                                              {                                                                  goto HAMMER;                                                              }                                                              else {                                                                  goto END_HAMMER;                                                              }                                                          }                                                          else if ((block[i1 + 1] & 0xff) > (block[i2 + 1] & 0xff))                                                          {                                                              goto HAMMER;                                                          }                                                          else {                                                              goto END_HAMMER;                                                          }                                                        }                                                      goto END_HAMMER;                                                  } // while x > 0                                                  else {                                                      if ((block[i1] & 0xff) > (block[i2] & 0xff))                                                      {                                                          goto HAMMER;                                                      }                                                      else {                                                          goto END_HAMMER;                                                      }                                                  }                                              }                                              else if ((block[i1 + 5] & 0xff) > (block[i2 + 5] & 0xff))                                              {                                                  goto HAMMER;                                              }                                              else {                                                  goto END_HAMMER;                                              }                                          }                                          else if ((block[i1 + 4] & 0xff) > (block[i2 + 4] & 0xff))                                          {                                              goto HAMMER;                                          }                                          else {                                              goto END_HAMMER;                                          }                                      }                                      else if ((block[i1 + 3] & 0xff) > (block[i2 + 3] & 0xff))                                      {                                          goto HAMMER;                                      }                                      else {                                          goto END_HAMMER;                                      }                                  }                                  else if ((block[i1 + 2] & 0xff) > (block[i2 + 2] & 0xff))                                  {                                      goto HAMMER;                                  }                                  else {                                      goto END_HAMMER;                                  }                              }                              else if ((block[i1 + 1] & 0xff) > (block[i2 + 1] & 0xff))                              {                                  goto HAMMER;                              }                              else {                                  goto END_HAMMER;                              }                            } // HAMMER                            END_HAMMER:                          // end inline mainGTU                            fmap[j] = v;                      }                        if (firstAttemptShadow && (i <= hi)                          && (workDoneShadow > workLimitShadow))                      {                          goto END_HP;                      }                  }              }
Magic Number,Ionic.BZip2,BZip2Compressor,C:\repos\haf_DotNetZip.Semverd\src\BZip2\BZip2Compressor.cs,mainSimpleSort,The following statement contains a magic number: while (--hp >= 0)              {                  int h = increments[hp];                  int mj = lo + h - 1;                    for (int i = lo + h; i <= hi;)                  {                      // copy                      for (int k = 3; (i <= hi) && (--k >= 0); i++)                      {                          int v = fmap[i];                          int vd = v + d;                          int j = i;                            // for (int a;                          // (j > mj) && mainGtU((a = fmap[j - h]) + d' vd'                          // block' quadrant' lastShadow);                          // j -= h) {                          // fmap[j] = a;                          // }                          //                          // unrolled version:                            // start inline mainGTU                          bool onceRunned = false;                          int a = 0;                            HAMMER: while (true)                          {                              if (onceRunned)                              {                                  fmap[j] = a;                                  if ((j -= h) <= mj)                                  {                                      goto END_HAMMER;                                  }                              }                              else {                                  onceRunned = true;                              }                                a = fmap[j - h];                              int i1 = a + d;                              int i2 = vd;                                // following could be done in a loop' but                              // unrolled it for performance:                              if (block[i1 + 1] == block[i2 + 1])                              {                                  if (block[i1 + 2] == block[i2 + 2])                                  {                                      if (block[i1 + 3] == block[i2 + 3])                                      {                                          if (block[i1 + 4] == block[i2 + 4])                                          {                                              if (block[i1 + 5] == block[i2 + 5])                                              {                                                  if (block[(i1 += 6)] == block[(i2 += 6)])                                                  {                                                      int x = lastShadow;                                                      X: while (x > 0)                                                      {                                                          x -= 4;                                                            if (block[i1 + 1] == block[i2 + 1])                                                          {                                                              if (quadrant[i1] == quadrant[i2])                                                              {                                                                  if (block[i1 + 2] == block[i2 + 2])                                                                  {                                                                      if (quadrant[i1 + 1] == quadrant[i2 + 1])                                                                      {                                                                          if (block[i1 + 3] == block[i2 + 3])                                                                          {                                                                              if (quadrant[i1 + 2] == quadrant[i2 + 2])                                                                              {                                                                                  if (block[i1 + 4] == block[i2 + 4])                                                                                  {                                                                                      if (quadrant[i1 + 3] == quadrant[i2 + 3])                                                                                      {                                                                                          if ((i1 += 4) >= lastPlus1)                                                                                          {                                                                                              i1 -= lastPlus1;                                                                                          }                                                                                          if ((i2 += 4) >= lastPlus1)                                                                                          {                                                                                              i2 -= lastPlus1;                                                                                          }                                                                                          workDoneShadow++;                                                                                          goto X;                                                                                      }                                                                                      else if ((quadrant[i1 + 3] > quadrant[i2 + 3]))                                                                                      {                                                                                          goto HAMMER;                                                                                      }                                                                                      else {                                                                                          goto END_HAMMER;                                                                                      }                                                                                  }                                                                                  else if ((block[i1 + 4] & 0xff) > (block[i2 + 4] & 0xff))                                                                                  {                                                                                      goto HAMMER;                                                                                  }                                                                                  else {                                                                                      goto END_HAMMER;                                                                                  }                                                                              }                                                                              else if ((quadrant[i1 + 2] > quadrant[i2 + 2]))                                                                              {                                                                                  goto HAMMER;                                                                              }                                                                              else {                                                                                  goto END_HAMMER;                                                                              }                                                                          }                                                                          else if ((block[i1 + 3] & 0xff) > (block[i2 + 3] & 0xff))                                                                          {                                                                              goto HAMMER;                                                                          }                                                                          else {                                                                              goto END_HAMMER;                                                                          }                                                                      }                                                                      else if ((quadrant[i1 + 1] > quadrant[i2 + 1]))                                                                      {                                                                          goto HAMMER;                                                                      }                                                                      else {                                                                          goto END_HAMMER;                                                                      }                                                                  }                                                                  else if ((block[i1 + 2] & 0xff) > (block[i2 + 2] & 0xff))                                                                  {                                                                      goto HAMMER;                                                                  }                                                                  else {                                                                      goto END_HAMMER;                                                                  }                                                              }                                                              else if ((quadrant[i1] > quadrant[i2]))                                                              {                                                                  goto HAMMER;                                                              }                                                              else {                                                                  goto END_HAMMER;                                                              }                                                          }                                                          else if ((block[i1 + 1] & 0xff) > (block[i2 + 1] & 0xff))                                                          {                                                              goto HAMMER;                                                          }                                                          else {                                                              goto END_HAMMER;                                                          }                                                        }                                                      goto END_HAMMER;                                                  } // while x > 0                                                  else {                                                      if ((block[i1] & 0xff) > (block[i2] & 0xff))                                                      {                                                          goto HAMMER;                                                      }                                                      else {                                                          goto END_HAMMER;                                                      }                                                  }                                              }                                              else if ((block[i1 + 5] & 0xff) > (block[i2 + 5] & 0xff))                                              {                                                  goto HAMMER;                                              }                                              else {                                                  goto END_HAMMER;                                              }                                          }                                          else if ((block[i1 + 4] & 0xff) > (block[i2 + 4] & 0xff))                                          {                                              goto HAMMER;                                          }                                          else {                                              goto END_HAMMER;                                          }                                      }                                      else if ((block[i1 + 3] & 0xff) > (block[i2 + 3] & 0xff))                                      {                                          goto HAMMER;                                      }                                      else {                                          goto END_HAMMER;                                      }                                  }                                  else if ((block[i1 + 2] & 0xff) > (block[i2 + 2] & 0xff))                                  {                                      goto HAMMER;                                  }                                  else {                                      goto END_HAMMER;                                  }                              }                              else if ((block[i1 + 1] & 0xff) > (block[i2 + 1] & 0xff))                              {                                  goto HAMMER;                              }                              else {                                  goto END_HAMMER;                              }                            } // HAMMER                            END_HAMMER:                          // end inline mainGTU                            fmap[j] = v;                      }                        if (firstAttemptShadow && (i <= hi)                          && (workDoneShadow > workLimitShadow))                      {                          goto END_HP;                      }                  }              }
Magic Number,Ionic.BZip2,BZip2Compressor,C:\repos\haf_DotNetZip.Semverd\src\BZip2\BZip2Compressor.cs,mainSimpleSort,The following statement contains a magic number: while (--hp >= 0)              {                  int h = increments[hp];                  int mj = lo + h - 1;                    for (int i = lo + h; i <= hi;)                  {                      // copy                      for (int k = 3; (i <= hi) && (--k >= 0); i++)                      {                          int v = fmap[i];                          int vd = v + d;                          int j = i;                            // for (int a;                          // (j > mj) && mainGtU((a = fmap[j - h]) + d' vd'                          // block' quadrant' lastShadow);                          // j -= h) {                          // fmap[j] = a;                          // }                          //                          // unrolled version:                            // start inline mainGTU                          bool onceRunned = false;                          int a = 0;                            HAMMER: while (true)                          {                              if (onceRunned)                              {                                  fmap[j] = a;                                  if ((j -= h) <= mj)                                  {                                      goto END_HAMMER;                                  }                              }                              else {                                  onceRunned = true;                              }                                a = fmap[j - h];                              int i1 = a + d;                              int i2 = vd;                                // following could be done in a loop' but                              // unrolled it for performance:                              if (block[i1 + 1] == block[i2 + 1])                              {                                  if (block[i1 + 2] == block[i2 + 2])                                  {                                      if (block[i1 + 3] == block[i2 + 3])                                      {                                          if (block[i1 + 4] == block[i2 + 4])                                          {                                              if (block[i1 + 5] == block[i2 + 5])                                              {                                                  if (block[(i1 += 6)] == block[(i2 += 6)])                                                  {                                                      int x = lastShadow;                                                      X: while (x > 0)                                                      {                                                          x -= 4;                                                            if (block[i1 + 1] == block[i2 + 1])                                                          {                                                              if (quadrant[i1] == quadrant[i2])                                                              {                                                                  if (block[i1 + 2] == block[i2 + 2])                                                                  {                                                                      if (quadrant[i1 + 1] == quadrant[i2 + 1])                                                                      {                                                                          if (block[i1 + 3] == block[i2 + 3])                                                                          {                                                                              if (quadrant[i1 + 2] == quadrant[i2 + 2])                                                                              {                                                                                  if (block[i1 + 4] == block[i2 + 4])                                                                                  {                                                                                      if (quadrant[i1 + 3] == quadrant[i2 + 3])                                                                                      {                                                                                          if ((i1 += 4) >= lastPlus1)                                                                                          {                                                                                              i1 -= lastPlus1;                                                                                          }                                                                                          if ((i2 += 4) >= lastPlus1)                                                                                          {                                                                                              i2 -= lastPlus1;                                                                                          }                                                                                          workDoneShadow++;                                                                                          goto X;                                                                                      }                                                                                      else if ((quadrant[i1 + 3] > quadrant[i2 + 3]))                                                                                      {                                                                                          goto HAMMER;                                                                                      }                                                                                      else {                                                                                          goto END_HAMMER;                                                                                      }                                                                                  }                                                                                  else if ((block[i1 + 4] & 0xff) > (block[i2 + 4] & 0xff))                                                                                  {                                                                                      goto HAMMER;                                                                                  }                                                                                  else {                                                                                      goto END_HAMMER;                                                                                  }                                                                              }                                                                              else if ((quadrant[i1 + 2] > quadrant[i2 + 2]))                                                                              {                                                                                  goto HAMMER;                                                                              }                                                                              else {                                                                                  goto END_HAMMER;                                                                              }                                                                          }                                                                          else if ((block[i1 + 3] & 0xff) > (block[i2 + 3] & 0xff))                                                                          {                                                                              goto HAMMER;                                                                          }                                                                          else {                                                                              goto END_HAMMER;                                                                          }                                                                      }                                                                      else if ((quadrant[i1 + 1] > quadrant[i2 + 1]))                                                                      {                                                                          goto HAMMER;                                                                      }                                                                      else {                                                                          goto END_HAMMER;                                                                      }                                                                  }                                                                  else if ((block[i1 + 2] & 0xff) > (block[i2 + 2] & 0xff))                                                                  {                                                                      goto HAMMER;                                                                  }                                                                  else {                                                                      goto END_HAMMER;                                                                  }                                                              }                                                              else if ((quadrant[i1] > quadrant[i2]))                                                              {                                                                  goto HAMMER;                                                              }                                                              else {                                                                  goto END_HAMMER;                                                              }                                                          }                                                          else if ((block[i1 + 1] & 0xff) > (block[i2 + 1] & 0xff))                                                          {                                                              goto HAMMER;                                                          }                                                          else {                                                              goto END_HAMMER;                                                          }                                                        }                                                      goto END_HAMMER;                                                  } // while x > 0                                                  else {                                                      if ((block[i1] & 0xff) > (block[i2] & 0xff))                                                      {                                                          goto HAMMER;                                                      }                                                      else {                                                          goto END_HAMMER;                                                      }                                                  }                                              }                                              else if ((block[i1 + 5] & 0xff) > (block[i2 + 5] & 0xff))                                              {                                                  goto HAMMER;                                              }                                              else {                                                  goto END_HAMMER;                                              }                                          }                                          else if ((block[i1 + 4] & 0xff) > (block[i2 + 4] & 0xff))                                          {                                              goto HAMMER;                                          }                                          else {                                              goto END_HAMMER;                                          }                                      }                                      else if ((block[i1 + 3] & 0xff) > (block[i2 + 3] & 0xff))                                      {                                          goto HAMMER;                                      }                                      else {                                          goto END_HAMMER;                                      }                                  }                                  else if ((block[i1 + 2] & 0xff) > (block[i2 + 2] & 0xff))                                  {                                      goto HAMMER;                                  }                                  else {                                      goto END_HAMMER;                                  }                              }                              else if ((block[i1 + 1] & 0xff) > (block[i2 + 1] & 0xff))                              {                                  goto HAMMER;                              }                              else {                                  goto END_HAMMER;                              }                            } // HAMMER                            END_HAMMER:                          // end inline mainGTU                            fmap[j] = v;                      }                        if (firstAttemptShadow && (i <= hi)                          && (workDoneShadow > workLimitShadow))                      {                          goto END_HP;                      }                  }              }
Magic Number,Ionic.BZip2,BZip2Compressor,C:\repos\haf_DotNetZip.Semverd\src\BZip2\BZip2Compressor.cs,mainSimpleSort,The following statement contains a magic number: while (--hp >= 0)              {                  int h = increments[hp];                  int mj = lo + h - 1;                    for (int i = lo + h; i <= hi;)                  {                      // copy                      for (int k = 3; (i <= hi) && (--k >= 0); i++)                      {                          int v = fmap[i];                          int vd = v + d;                          int j = i;                            // for (int a;                          // (j > mj) && mainGtU((a = fmap[j - h]) + d' vd'                          // block' quadrant' lastShadow);                          // j -= h) {                          // fmap[j] = a;                          // }                          //                          // unrolled version:                            // start inline mainGTU                          bool onceRunned = false;                          int a = 0;                            HAMMER: while (true)                          {                              if (onceRunned)                              {                                  fmap[j] = a;                                  if ((j -= h) <= mj)                                  {                                      goto END_HAMMER;                                  }                              }                              else {                                  onceRunned = true;                              }                                a = fmap[j - h];                              int i1 = a + d;                              int i2 = vd;                                // following could be done in a loop' but                              // unrolled it for performance:                              if (block[i1 + 1] == block[i2 + 1])                              {                                  if (block[i1 + 2] == block[i2 + 2])                                  {                                      if (block[i1 + 3] == block[i2 + 3])                                      {                                          if (block[i1 + 4] == block[i2 + 4])                                          {                                              if (block[i1 + 5] == block[i2 + 5])                                              {                                                  if (block[(i1 += 6)] == block[(i2 += 6)])                                                  {                                                      int x = lastShadow;                                                      X: while (x > 0)                                                      {                                                          x -= 4;                                                            if (block[i1 + 1] == block[i2 + 1])                                                          {                                                              if (quadrant[i1] == quadrant[i2])                                                              {                                                                  if (block[i1 + 2] == block[i2 + 2])                                                                  {                                                                      if (quadrant[i1 + 1] == quadrant[i2 + 1])                                                                      {                                                                          if (block[i1 + 3] == block[i2 + 3])                                                                          {                                                                              if (quadrant[i1 + 2] == quadrant[i2 + 2])                                                                              {                                                                                  if (block[i1 + 4] == block[i2 + 4])                                                                                  {                                                                                      if (quadrant[i1 + 3] == quadrant[i2 + 3])                                                                                      {                                                                                          if ((i1 += 4) >= lastPlus1)                                                                                          {                                                                                              i1 -= lastPlus1;                                                                                          }                                                                                          if ((i2 += 4) >= lastPlus1)                                                                                          {                                                                                              i2 -= lastPlus1;                                                                                          }                                                                                          workDoneShadow++;                                                                                          goto X;                                                                                      }                                                                                      else if ((quadrant[i1 + 3] > quadrant[i2 + 3]))                                                                                      {                                                                                          goto HAMMER;                                                                                      }                                                                                      else {                                                                                          goto END_HAMMER;                                                                                      }                                                                                  }                                                                                  else if ((block[i1 + 4] & 0xff) > (block[i2 + 4] & 0xff))                                                                                  {                                                                                      goto HAMMER;                                                                                  }                                                                                  else {                                                                                      goto END_HAMMER;                                                                                  }                                                                              }                                                                              else if ((quadrant[i1 + 2] > quadrant[i2 + 2]))                                                                              {                                                                                  goto HAMMER;                                                                              }                                                                              else {                                                                                  goto END_HAMMER;                                                                              }                                                                          }                                                                          else if ((block[i1 + 3] & 0xff) > (block[i2 + 3] & 0xff))                                                                          {                                                                              goto HAMMER;                                                                          }                                                                          else {                                                                              goto END_HAMMER;                                                                          }                                                                      }                                                                      else if ((quadrant[i1 + 1] > quadrant[i2 + 1]))                                                                      {                                                                          goto HAMMER;                                                                      }                                                                      else {                                                                          goto END_HAMMER;                                                                      }                                                                  }                                                                  else if ((block[i1 + 2] & 0xff) > (block[i2 + 2] & 0xff))                                                                  {                                                                      goto HAMMER;                                                                  }                                                                  else {                                                                      goto END_HAMMER;                                                                  }                                                              }                                                              else if ((quadrant[i1] > quadrant[i2]))                                                              {                                                                  goto HAMMER;                                                              }                                                              else {                                                                  goto END_HAMMER;                                                              }                                                          }                                                          else if ((block[i1 + 1] & 0xff) > (block[i2 + 1] & 0xff))                                                          {                                                              goto HAMMER;                                                          }                                                          else {                                                              goto END_HAMMER;                                                          }                                                        }                                                      goto END_HAMMER;                                                  } // while x > 0                                                  else {                                                      if ((block[i1] & 0xff) > (block[i2] & 0xff))                                                      {                                                          goto HAMMER;                                                      }                                                      else {                                                          goto END_HAMMER;                                                      }                                                  }                                              }                                              else if ((block[i1 + 5] & 0xff) > (block[i2 + 5] & 0xff))                                              {                                                  goto HAMMER;                                              }                                              else {                                                  goto END_HAMMER;                                              }                                          }                                          else if ((block[i1 + 4] & 0xff) > (block[i2 + 4] & 0xff))                                          {                                              goto HAMMER;                                          }                                          else {                                              goto END_HAMMER;                                          }                                      }                                      else if ((block[i1 + 3] & 0xff) > (block[i2 + 3] & 0xff))                                      {                                          goto HAMMER;                                      }                                      else {                                          goto END_HAMMER;                                      }                                  }                                  else if ((block[i1 + 2] & 0xff) > (block[i2 + 2] & 0xff))                                  {                                      goto HAMMER;                                  }                                  else {                                      goto END_HAMMER;                                  }                              }                              else if ((block[i1 + 1] & 0xff) > (block[i2 + 1] & 0xff))                              {                                  goto HAMMER;                              }                              else {                                  goto END_HAMMER;                              }                            } // HAMMER                            END_HAMMER:                          // end inline mainGTU                            fmap[j] = v;                      }                        if (firstAttemptShadow && (i <= hi)                          && (workDoneShadow > workLimitShadow))                      {                          goto END_HP;                      }                  }              }
Magic Number,Ionic.BZip2,BZip2Compressor,C:\repos\haf_DotNetZip.Semverd\src\BZip2\BZip2Compressor.cs,mainSimpleSort,The following statement contains a magic number: while (--hp >= 0)              {                  int h = increments[hp];                  int mj = lo + h - 1;                    for (int i = lo + h; i <= hi;)                  {                      // copy                      for (int k = 3; (i <= hi) && (--k >= 0); i++)                      {                          int v = fmap[i];                          int vd = v + d;                          int j = i;                            // for (int a;                          // (j > mj) && mainGtU((a = fmap[j - h]) + d' vd'                          // block' quadrant' lastShadow);                          // j -= h) {                          // fmap[j] = a;                          // }                          //                          // unrolled version:                            // start inline mainGTU                          bool onceRunned = false;                          int a = 0;                            HAMMER: while (true)                          {                              if (onceRunned)                              {                                  fmap[j] = a;                                  if ((j -= h) <= mj)                                  {                                      goto END_HAMMER;                                  }                              }                              else {                                  onceRunned = true;                              }                                a = fmap[j - h];                              int i1 = a + d;                              int i2 = vd;                                // following could be done in a loop' but                              // unrolled it for performance:                              if (block[i1 + 1] == block[i2 + 1])                              {                                  if (block[i1 + 2] == block[i2 + 2])                                  {                                      if (block[i1 + 3] == block[i2 + 3])                                      {                                          if (block[i1 + 4] == block[i2 + 4])                                          {                                              if (block[i1 + 5] == block[i2 + 5])                                              {                                                  if (block[(i1 += 6)] == block[(i2 += 6)])                                                  {                                                      int x = lastShadow;                                                      X: while (x > 0)                                                      {                                                          x -= 4;                                                            if (block[i1 + 1] == block[i2 + 1])                                                          {                                                              if (quadrant[i1] == quadrant[i2])                                                              {                                                                  if (block[i1 + 2] == block[i2 + 2])                                                                  {                                                                      if (quadrant[i1 + 1] == quadrant[i2 + 1])                                                                      {                                                                          if (block[i1 + 3] == block[i2 + 3])                                                                          {                                                                              if (quadrant[i1 + 2] == quadrant[i2 + 2])                                                                              {                                                                                  if (block[i1 + 4] == block[i2 + 4])                                                                                  {                                                                                      if (quadrant[i1 + 3] == quadrant[i2 + 3])                                                                                      {                                                                                          if ((i1 += 4) >= lastPlus1)                                                                                          {                                                                                              i1 -= lastPlus1;                                                                                          }                                                                                          if ((i2 += 4) >= lastPlus1)                                                                                          {                                                                                              i2 -= lastPlus1;                                                                                          }                                                                                          workDoneShadow++;                                                                                          goto X;                                                                                      }                                                                                      else if ((quadrant[i1 + 3] > quadrant[i2 + 3]))                                                                                      {                                                                                          goto HAMMER;                                                                                      }                                                                                      else {                                                                                          goto END_HAMMER;                                                                                      }                                                                                  }                                                                                  else if ((block[i1 + 4] & 0xff) > (block[i2 + 4] & 0xff))                                                                                  {                                                                                      goto HAMMER;                                                                                  }                                                                                  else {                                                                                      goto END_HAMMER;                                                                                  }                                                                              }                                                                              else if ((quadrant[i1 + 2] > quadrant[i2 + 2]))                                                                              {                                                                                  goto HAMMER;                                                                              }                                                                              else {                                                                                  goto END_HAMMER;                                                                              }                                                                          }                                                                          else if ((block[i1 + 3] & 0xff) > (block[i2 + 3] & 0xff))                                                                          {                                                                              goto HAMMER;                                                                          }                                                                          else {                                                                              goto END_HAMMER;                                                                          }                                                                      }                                                                      else if ((quadrant[i1 + 1] > quadrant[i2 + 1]))                                                                      {                                                                          goto HAMMER;                                                                      }                                                                      else {                                                                          goto END_HAMMER;                                                                      }                                                                  }                                                                  else if ((block[i1 + 2] & 0xff) > (block[i2 + 2] & 0xff))                                                                  {                                                                      goto HAMMER;                                                                  }                                                                  else {                                                                      goto END_HAMMER;                                                                  }                                                              }                                                              else if ((quadrant[i1] > quadrant[i2]))                                                              {                                                                  goto HAMMER;                                                              }                                                              else {                                                                  goto END_HAMMER;                                                              }                                                          }                                                          else if ((block[i1 + 1] & 0xff) > (block[i2 + 1] & 0xff))                                                          {                                                              goto HAMMER;                                                          }                                                          else {                                                              goto END_HAMMER;                                                          }                                                        }                                                      goto END_HAMMER;                                                  } // while x > 0                                                  else {                                                      if ((block[i1] & 0xff) > (block[i2] & 0xff))                                                      {                                                          goto HAMMER;                                                      }                                                      else {                                                          goto END_HAMMER;                                                      }                                                  }                                              }                                              else if ((block[i1 + 5] & 0xff) > (block[i2 + 5] & 0xff))                                              {                                                  goto HAMMER;                                              }                                              else {                                                  goto END_HAMMER;                                              }                                          }                                          else if ((block[i1 + 4] & 0xff) > (block[i2 + 4] & 0xff))                                          {                                              goto HAMMER;                                          }                                          else {                                              goto END_HAMMER;                                          }                                      }                                      else if ((block[i1 + 3] & 0xff) > (block[i2 + 3] & 0xff))                                      {                                          goto HAMMER;                                      }                                      else {                                          goto END_HAMMER;                                      }                                  }                                  else if ((block[i1 + 2] & 0xff) > (block[i2 + 2] & 0xff))                                  {                                      goto HAMMER;                                  }                                  else {                                      goto END_HAMMER;                                  }                              }                              else if ((block[i1 + 1] & 0xff) > (block[i2 + 1] & 0xff))                              {                                  goto HAMMER;                              }                              else {                                  goto END_HAMMER;                              }                            } // HAMMER                            END_HAMMER:                          // end inline mainGTU                            fmap[j] = v;                      }                        if (firstAttemptShadow && (i <= hi)                          && (workDoneShadow > workLimitShadow))                      {                          goto END_HP;                      }                  }              }
Magic Number,Ionic.BZip2,BZip2Compressor,C:\repos\haf_DotNetZip.Semverd\src\BZip2\BZip2Compressor.cs,mainSimpleSort,The following statement contains a magic number: while (--hp >= 0)              {                  int h = increments[hp];                  int mj = lo + h - 1;                    for (int i = lo + h; i <= hi;)                  {                      // copy                      for (int k = 3; (i <= hi) && (--k >= 0); i++)                      {                          int v = fmap[i];                          int vd = v + d;                          int j = i;                            // for (int a;                          // (j > mj) && mainGtU((a = fmap[j - h]) + d' vd'                          // block' quadrant' lastShadow);                          // j -= h) {                          // fmap[j] = a;                          // }                          //                          // unrolled version:                            // start inline mainGTU                          bool onceRunned = false;                          int a = 0;                            HAMMER: while (true)                          {                              if (onceRunned)                              {                                  fmap[j] = a;                                  if ((j -= h) <= mj)                                  {                                      goto END_HAMMER;                                  }                              }                              else {                                  onceRunned = true;                              }                                a = fmap[j - h];                              int i1 = a + d;                              int i2 = vd;                                // following could be done in a loop' but                              // unrolled it for performance:                              if (block[i1 + 1] == block[i2 + 1])                              {                                  if (block[i1 + 2] == block[i2 + 2])                                  {                                      if (block[i1 + 3] == block[i2 + 3])                                      {                                          if (block[i1 + 4] == block[i2 + 4])                                          {                                              if (block[i1 + 5] == block[i2 + 5])                                              {                                                  if (block[(i1 += 6)] == block[(i2 += 6)])                                                  {                                                      int x = lastShadow;                                                      X: while (x > 0)                                                      {                                                          x -= 4;                                                            if (block[i1 + 1] == block[i2 + 1])                                                          {                                                              if (quadrant[i1] == quadrant[i2])                                                              {                                                                  if (block[i1 + 2] == block[i2 + 2])                                                                  {                                                                      if (quadrant[i1 + 1] == quadrant[i2 + 1])                                                                      {                                                                          if (block[i1 + 3] == block[i2 + 3])                                                                          {                                                                              if (quadrant[i1 + 2] == quadrant[i2 + 2])                                                                              {                                                                                  if (block[i1 + 4] == block[i2 + 4])                                                                                  {                                                                                      if (quadrant[i1 + 3] == quadrant[i2 + 3])                                                                                      {                                                                                          if ((i1 += 4) >= lastPlus1)                                                                                          {                                                                                              i1 -= lastPlus1;                                                                                          }                                                                                          if ((i2 += 4) >= lastPlus1)                                                                                          {                                                                                              i2 -= lastPlus1;                                                                                          }                                                                                          workDoneShadow++;                                                                                          goto X;                                                                                      }                                                                                      else if ((quadrant[i1 + 3] > quadrant[i2 + 3]))                                                                                      {                                                                                          goto HAMMER;                                                                                      }                                                                                      else {                                                                                          goto END_HAMMER;                                                                                      }                                                                                  }                                                                                  else if ((block[i1 + 4] & 0xff) > (block[i2 + 4] & 0xff))                                                                                  {                                                                                      goto HAMMER;                                                                                  }                                                                                  else {                                                                                      goto END_HAMMER;                                                                                  }                                                                              }                                                                              else if ((quadrant[i1 + 2] > quadrant[i2 + 2]))                                                                              {                                                                                  goto HAMMER;                                                                              }                                                                              else {                                                                                  goto END_HAMMER;                                                                              }                                                                          }                                                                          else if ((block[i1 + 3] & 0xff) > (block[i2 + 3] & 0xff))                                                                          {                                                                              goto HAMMER;                                                                          }                                                                          else {                                                                              goto END_HAMMER;                                                                          }                                                                      }                                                                      else if ((quadrant[i1 + 1] > quadrant[i2 + 1]))                                                                      {                                                                          goto HAMMER;                                                                      }                                                                      else {                                                                          goto END_HAMMER;                                                                      }                                                                  }                                                                  else if ((block[i1 + 2] & 0xff) > (block[i2 + 2] & 0xff))                                                                  {                                                                      goto HAMMER;                                                                  }                                                                  else {                                                                      goto END_HAMMER;                                                                  }                                                              }                                                              else if ((quadrant[i1] > quadrant[i2]))                                                              {                                                                  goto HAMMER;                                                              }                                                              else {                                                                  goto END_HAMMER;                                                              }                                                          }                                                          else if ((block[i1 + 1] & 0xff) > (block[i2 + 1] & 0xff))                                                          {                                                              goto HAMMER;                                                          }                                                          else {                                                              goto END_HAMMER;                                                          }                                                        }                                                      goto END_HAMMER;                                                  } // while x > 0                                                  else {                                                      if ((block[i1] & 0xff) > (block[i2] & 0xff))                                                      {                                                          goto HAMMER;                                                      }                                                      else {                                                          goto END_HAMMER;                                                      }                                                  }                                              }                                              else if ((block[i1 + 5] & 0xff) > (block[i2 + 5] & 0xff))                                              {                                                  goto HAMMER;                                              }                                              else {                                                  goto END_HAMMER;                                              }                                          }                                          else if ((block[i1 + 4] & 0xff) > (block[i2 + 4] & 0xff))                                          {                                              goto HAMMER;                                          }                                          else {                                              goto END_HAMMER;                                          }                                      }                                      else if ((block[i1 + 3] & 0xff) > (block[i2 + 3] & 0xff))                                      {                                          goto HAMMER;                                      }                                      else {                                          goto END_HAMMER;                                      }                                  }                                  else if ((block[i1 + 2] & 0xff) > (block[i2 + 2] & 0xff))                                  {                                      goto HAMMER;                                  }                                  else {                                      goto END_HAMMER;                                  }                              }                              else if ((block[i1 + 1] & 0xff) > (block[i2 + 1] & 0xff))                              {                                  goto HAMMER;                              }                              else {                                  goto END_HAMMER;                              }                            } // HAMMER                            END_HAMMER:                          // end inline mainGTU                            fmap[j] = v;                      }                        if (firstAttemptShadow && (i <= hi)                          && (workDoneShadow > workLimitShadow))                      {                          goto END_HP;                      }                  }              }
Magic Number,Ionic.BZip2,BZip2Compressor,C:\repos\haf_DotNetZip.Semverd\src\BZip2\BZip2Compressor.cs,mainSimpleSort,The following statement contains a magic number: while (--hp >= 0)              {                  int h = increments[hp];                  int mj = lo + h - 1;                    for (int i = lo + h; i <= hi;)                  {                      // copy                      for (int k = 3; (i <= hi) && (--k >= 0); i++)                      {                          int v = fmap[i];                          int vd = v + d;                          int j = i;                            // for (int a;                          // (j > mj) && mainGtU((a = fmap[j - h]) + d' vd'                          // block' quadrant' lastShadow);                          // j -= h) {                          // fmap[j] = a;                          // }                          //                          // unrolled version:                            // start inline mainGTU                          bool onceRunned = false;                          int a = 0;                            HAMMER: while (true)                          {                              if (onceRunned)                              {                                  fmap[j] = a;                                  if ((j -= h) <= mj)                                  {                                      goto END_HAMMER;                                  }                              }                              else {                                  onceRunned = true;                              }                                a = fmap[j - h];                              int i1 = a + d;                              int i2 = vd;                                // following could be done in a loop' but                              // unrolled it for performance:                              if (block[i1 + 1] == block[i2 + 1])                              {                                  if (block[i1 + 2] == block[i2 + 2])                                  {                                      if (block[i1 + 3] == block[i2 + 3])                                      {                                          if (block[i1 + 4] == block[i2 + 4])                                          {                                              if (block[i1 + 5] == block[i2 + 5])                                              {                                                  if (block[(i1 += 6)] == block[(i2 += 6)])                                                  {                                                      int x = lastShadow;                                                      X: while (x > 0)                                                      {                                                          x -= 4;                                                            if (block[i1 + 1] == block[i2 + 1])                                                          {                                                              if (quadrant[i1] == quadrant[i2])                                                              {                                                                  if (block[i1 + 2] == block[i2 + 2])                                                                  {                                                                      if (quadrant[i1 + 1] == quadrant[i2 + 1])                                                                      {                                                                          if (block[i1 + 3] == block[i2 + 3])                                                                          {                                                                              if (quadrant[i1 + 2] == quadrant[i2 + 2])                                                                              {                                                                                  if (block[i1 + 4] == block[i2 + 4])                                                                                  {                                                                                      if (quadrant[i1 + 3] == quadrant[i2 + 3])                                                                                      {                                                                                          if ((i1 += 4) >= lastPlus1)                                                                                          {                                                                                              i1 -= lastPlus1;                                                                                          }                                                                                          if ((i2 += 4) >= lastPlus1)                                                                                          {                                                                                              i2 -= lastPlus1;                                                                                          }                                                                                          workDoneShadow++;                                                                                          goto X;                                                                                      }                                                                                      else if ((quadrant[i1 + 3] > quadrant[i2 + 3]))                                                                                      {                                                                                          goto HAMMER;                                                                                      }                                                                                      else {                                                                                          goto END_HAMMER;                                                                                      }                                                                                  }                                                                                  else if ((block[i1 + 4] & 0xff) > (block[i2 + 4] & 0xff))                                                                                  {                                                                                      goto HAMMER;                                                                                  }                                                                                  else {                                                                                      goto END_HAMMER;                                                                                  }                                                                              }                                                                              else if ((quadrant[i1 + 2] > quadrant[i2 + 2]))                                                                              {                                                                                  goto HAMMER;                                                                              }                                                                              else {                                                                                  goto END_HAMMER;                                                                              }                                                                          }                                                                          else if ((block[i1 + 3] & 0xff) > (block[i2 + 3] & 0xff))                                                                          {                                                                              goto HAMMER;                                                                          }                                                                          else {                                                                              goto END_HAMMER;                                                                          }                                                                      }                                                                      else if ((quadrant[i1 + 1] > quadrant[i2 + 1]))                                                                      {                                                                          goto HAMMER;                                                                      }                                                                      else {                                                                          goto END_HAMMER;                                                                      }                                                                  }                                                                  else if ((block[i1 + 2] & 0xff) > (block[i2 + 2] & 0xff))                                                                  {                                                                      goto HAMMER;                                                                  }                                                                  else {                                                                      goto END_HAMMER;                                                                  }                                                              }                                                              else if ((quadrant[i1] > quadrant[i2]))                                                              {                                                                  goto HAMMER;                                                              }                                                              else {                                                                  goto END_HAMMER;                                                              }                                                          }                                                          else if ((block[i1 + 1] & 0xff) > (block[i2 + 1] & 0xff))                                                          {                                                              goto HAMMER;                                                          }                                                          else {                                                              goto END_HAMMER;                                                          }                                                        }                                                      goto END_HAMMER;                                                  } // while x > 0                                                  else {                                                      if ((block[i1] & 0xff) > (block[i2] & 0xff))                                                      {                                                          goto HAMMER;                                                      }                                                      else {                                                          goto END_HAMMER;                                                      }                                                  }                                              }                                              else if ((block[i1 + 5] & 0xff) > (block[i2 + 5] & 0xff))                                              {                                                  goto HAMMER;                                              }                                              else {                                                  goto END_HAMMER;                                              }                                          }                                          else if ((block[i1 + 4] & 0xff) > (block[i2 + 4] & 0xff))                                          {                                              goto HAMMER;                                          }                                          else {                                              goto END_HAMMER;                                          }                                      }                                      else if ((block[i1 + 3] & 0xff) > (block[i2 + 3] & 0xff))                                      {                                          goto HAMMER;                                      }                                      else {                                          goto END_HAMMER;                                      }                                  }                                  else if ((block[i1 + 2] & 0xff) > (block[i2 + 2] & 0xff))                                  {                                      goto HAMMER;                                  }                                  else {                                      goto END_HAMMER;                                  }                              }                              else if ((block[i1 + 1] & 0xff) > (block[i2 + 1] & 0xff))                              {                                  goto HAMMER;                              }                              else {                                  goto END_HAMMER;                              }                            } // HAMMER                            END_HAMMER:                          // end inline mainGTU                            fmap[j] = v;                      }                        if (firstAttemptShadow && (i <= hi)                          && (workDoneShadow > workLimitShadow))                      {                          goto END_HP;                      }                  }              }
Magic Number,Ionic.BZip2,BZip2Compressor,C:\repos\haf_DotNetZip.Semverd\src\BZip2\BZip2Compressor.cs,mainSimpleSort,The following statement contains a magic number: while (--hp >= 0)              {                  int h = increments[hp];                  int mj = lo + h - 1;                    for (int i = lo + h; i <= hi;)                  {                      // copy                      for (int k = 3; (i <= hi) && (--k >= 0); i++)                      {                          int v = fmap[i];                          int vd = v + d;                          int j = i;                            // for (int a;                          // (j > mj) && mainGtU((a = fmap[j - h]) + d' vd'                          // block' quadrant' lastShadow);                          // j -= h) {                          // fmap[j] = a;                          // }                          //                          // unrolled version:                            // start inline mainGTU                          bool onceRunned = false;                          int a = 0;                            HAMMER: while (true)                          {                              if (onceRunned)                              {                                  fmap[j] = a;                                  if ((j -= h) <= mj)                                  {                                      goto END_HAMMER;                                  }                              }                              else {                                  onceRunned = true;                              }                                a = fmap[j - h];                              int i1 = a + d;                              int i2 = vd;                                // following could be done in a loop' but                              // unrolled it for performance:                              if (block[i1 + 1] == block[i2 + 1])                              {                                  if (block[i1 + 2] == block[i2 + 2])                                  {                                      if (block[i1 + 3] == block[i2 + 3])                                      {                                          if (block[i1 + 4] == block[i2 + 4])                                          {                                              if (block[i1 + 5] == block[i2 + 5])                                              {                                                  if (block[(i1 += 6)] == block[(i2 += 6)])                                                  {                                                      int x = lastShadow;                                                      X: while (x > 0)                                                      {                                                          x -= 4;                                                            if (block[i1 + 1] == block[i2 + 1])                                                          {                                                              if (quadrant[i1] == quadrant[i2])                                                              {                                                                  if (block[i1 + 2] == block[i2 + 2])                                                                  {                                                                      if (quadrant[i1 + 1] == quadrant[i2 + 1])                                                                      {                                                                          if (block[i1 + 3] == block[i2 + 3])                                                                          {                                                                              if (quadrant[i1 + 2] == quadrant[i2 + 2])                                                                              {                                                                                  if (block[i1 + 4] == block[i2 + 4])                                                                                  {                                                                                      if (quadrant[i1 + 3] == quadrant[i2 + 3])                                                                                      {                                                                                          if ((i1 += 4) >= lastPlus1)                                                                                          {                                                                                              i1 -= lastPlus1;                                                                                          }                                                                                          if ((i2 += 4) >= lastPlus1)                                                                                          {                                                                                              i2 -= lastPlus1;                                                                                          }                                                                                          workDoneShadow++;                                                                                          goto X;                                                                                      }                                                                                      else if ((quadrant[i1 + 3] > quadrant[i2 + 3]))                                                                                      {                                                                                          goto HAMMER;                                                                                      }                                                                                      else {                                                                                          goto END_HAMMER;                                                                                      }                                                                                  }                                                                                  else if ((block[i1 + 4] & 0xff) > (block[i2 + 4] & 0xff))                                                                                  {                                                                                      goto HAMMER;                                                                                  }                                                                                  else {                                                                                      goto END_HAMMER;                                                                                  }                                                                              }                                                                              else if ((quadrant[i1 + 2] > quadrant[i2 + 2]))                                                                              {                                                                                  goto HAMMER;                                                                              }                                                                              else {                                                                                  goto END_HAMMER;                                                                              }                                                                          }                                                                          else if ((block[i1 + 3] & 0xff) > (block[i2 + 3] & 0xff))                                                                          {                                                                              goto HAMMER;                                                                          }                                                                          else {                                                                              goto END_HAMMER;                                                                          }                                                                      }                                                                      else if ((quadrant[i1 + 1] > quadrant[i2 + 1]))                                                                      {                                                                          goto HAMMER;                                                                      }                                                                      else {                                                                          goto END_HAMMER;                                                                      }                                                                  }                                                                  else if ((block[i1 + 2] & 0xff) > (block[i2 + 2] & 0xff))                                                                  {                                                                      goto HAMMER;                                                                  }                                                                  else {                                                                      goto END_HAMMER;                                                                  }                                                              }                                                              else if ((quadrant[i1] > quadrant[i2]))                                                              {                                                                  goto HAMMER;                                                              }                                                              else {                                                                  goto END_HAMMER;                                                              }                                                          }                                                          else if ((block[i1 + 1] & 0xff) > (block[i2 + 1] & 0xff))                                                          {                                                              goto HAMMER;                                                          }                                                          else {                                                              goto END_HAMMER;                                                          }                                                        }                                                      goto END_HAMMER;                                                  } // while x > 0                                                  else {                                                      if ((block[i1] & 0xff) > (block[i2] & 0xff))                                                      {                                                          goto HAMMER;                                                      }                                                      else {                                                          goto END_HAMMER;                                                      }                                                  }                                              }                                              else if ((block[i1 + 5] & 0xff) > (block[i2 + 5] & 0xff))                                              {                                                  goto HAMMER;                                              }                                              else {                                                  goto END_HAMMER;                                              }                                          }                                          else if ((block[i1 + 4] & 0xff) > (block[i2 + 4] & 0xff))                                          {                                              goto HAMMER;                                          }                                          else {                                              goto END_HAMMER;                                          }                                      }                                      else if ((block[i1 + 3] & 0xff) > (block[i2 + 3] & 0xff))                                      {                                          goto HAMMER;                                      }                                      else {                                          goto END_HAMMER;                                      }                                  }                                  else if ((block[i1 + 2] & 0xff) > (block[i2 + 2] & 0xff))                                  {                                      goto HAMMER;                                  }                                  else {                                      goto END_HAMMER;                                  }                              }                              else if ((block[i1 + 1] & 0xff) > (block[i2 + 1] & 0xff))                              {                                  goto HAMMER;                              }                              else {                                  goto END_HAMMER;                              }                            } // HAMMER                            END_HAMMER:                          // end inline mainGTU                            fmap[j] = v;                      }                        if (firstAttemptShadow && (i <= hi)                          && (workDoneShadow > workLimitShadow))                      {                          goto END_HP;                      }                  }              }
Magic Number,Ionic.BZip2,BZip2Compressor,C:\repos\haf_DotNetZip.Semverd\src\BZip2\BZip2Compressor.cs,mainSimpleSort,The following statement contains a magic number: while (--hp >= 0)              {                  int h = increments[hp];                  int mj = lo + h - 1;                    for (int i = lo + h; i <= hi;)                  {                      // copy                      for (int k = 3; (i <= hi) && (--k >= 0); i++)                      {                          int v = fmap[i];                          int vd = v + d;                          int j = i;                            // for (int a;                          // (j > mj) && mainGtU((a = fmap[j - h]) + d' vd'                          // block' quadrant' lastShadow);                          // j -= h) {                          // fmap[j] = a;                          // }                          //                          // unrolled version:                            // start inline mainGTU                          bool onceRunned = false;                          int a = 0;                            HAMMER: while (true)                          {                              if (onceRunned)                              {                                  fmap[j] = a;                                  if ((j -= h) <= mj)                                  {                                      goto END_HAMMER;                                  }                              }                              else {                                  onceRunned = true;                              }                                a = fmap[j - h];                              int i1 = a + d;                              int i2 = vd;                                // following could be done in a loop' but                              // unrolled it for performance:                              if (block[i1 + 1] == block[i2 + 1])                              {                                  if (block[i1 + 2] == block[i2 + 2])                                  {                                      if (block[i1 + 3] == block[i2 + 3])                                      {                                          if (block[i1 + 4] == block[i2 + 4])                                          {                                              if (block[i1 + 5] == block[i2 + 5])                                              {                                                  if (block[(i1 += 6)] == block[(i2 += 6)])                                                  {                                                      int x = lastShadow;                                                      X: while (x > 0)                                                      {                                                          x -= 4;                                                            if (block[i1 + 1] == block[i2 + 1])                                                          {                                                              if (quadrant[i1] == quadrant[i2])                                                              {                                                                  if (block[i1 + 2] == block[i2 + 2])                                                                  {                                                                      if (quadrant[i1 + 1] == quadrant[i2 + 1])                                                                      {                                                                          if (block[i1 + 3] == block[i2 + 3])                                                                          {                                                                              if (quadrant[i1 + 2] == quadrant[i2 + 2])                                                                              {                                                                                  if (block[i1 + 4] == block[i2 + 4])                                                                                  {                                                                                      if (quadrant[i1 + 3] == quadrant[i2 + 3])                                                                                      {                                                                                          if ((i1 += 4) >= lastPlus1)                                                                                          {                                                                                              i1 -= lastPlus1;                                                                                          }                                                                                          if ((i2 += 4) >= lastPlus1)                                                                                          {                                                                                              i2 -= lastPlus1;                                                                                          }                                                                                          workDoneShadow++;                                                                                          goto X;                                                                                      }                                                                                      else if ((quadrant[i1 + 3] > quadrant[i2 + 3]))                                                                                      {                                                                                          goto HAMMER;                                                                                      }                                                                                      else {                                                                                          goto END_HAMMER;                                                                                      }                                                                                  }                                                                                  else if ((block[i1 + 4] & 0xff) > (block[i2 + 4] & 0xff))                                                                                  {                                                                                      goto HAMMER;                                                                                  }                                                                                  else {                                                                                      goto END_HAMMER;                                                                                  }                                                                              }                                                                              else if ((quadrant[i1 + 2] > quadrant[i2 + 2]))                                                                              {                                                                                  goto HAMMER;                                                                              }                                                                              else {                                                                                  goto END_HAMMER;                                                                              }                                                                          }                                                                          else if ((block[i1 + 3] & 0xff) > (block[i2 + 3] & 0xff))                                                                          {                                                                              goto HAMMER;                                                                          }                                                                          else {                                                                              goto END_HAMMER;                                                                          }                                                                      }                                                                      else if ((quadrant[i1 + 1] > quadrant[i2 + 1]))                                                                      {                                                                          goto HAMMER;                                                                      }                                                                      else {                                                                          goto END_HAMMER;                                                                      }                                                                  }                                                                  else if ((block[i1 + 2] & 0xff) > (block[i2 + 2] & 0xff))                                                                  {                                                                      goto HAMMER;                                                                  }                                                                  else {                                                                      goto END_HAMMER;                                                                  }                                                              }                                                              else if ((quadrant[i1] > quadrant[i2]))                                                              {                                                                  goto HAMMER;                                                              }                                                              else {                                                                  goto END_HAMMER;                                                              }                                                          }                                                          else if ((block[i1 + 1] & 0xff) > (block[i2 + 1] & 0xff))                                                          {                                                              goto HAMMER;                                                          }                                                          else {                                                              goto END_HAMMER;                                                          }                                                        }                                                      goto END_HAMMER;                                                  } // while x > 0                                                  else {                                                      if ((block[i1] & 0xff) > (block[i2] & 0xff))                                                      {                                                          goto HAMMER;                                                      }                                                      else {                                                          goto END_HAMMER;                                                      }                                                  }                                              }                                              else if ((block[i1 + 5] & 0xff) > (block[i2 + 5] & 0xff))                                              {                                                  goto HAMMER;                                              }                                              else {                                                  goto END_HAMMER;                                              }                                          }                                          else if ((block[i1 + 4] & 0xff) > (block[i2 + 4] & 0xff))                                          {                                              goto HAMMER;                                          }                                          else {                                              goto END_HAMMER;                                          }                                      }                                      else if ((block[i1 + 3] & 0xff) > (block[i2 + 3] & 0xff))                                      {                                          goto HAMMER;                                      }                                      else {                                          goto END_HAMMER;                                      }                                  }                                  else if ((block[i1 + 2] & 0xff) > (block[i2 + 2] & 0xff))                                  {                                      goto HAMMER;                                  }                                  else {                                      goto END_HAMMER;                                  }                              }                              else if ((block[i1 + 1] & 0xff) > (block[i2 + 1] & 0xff))                              {                                  goto HAMMER;                              }                              else {                                  goto END_HAMMER;                              }                            } // HAMMER                            END_HAMMER:                          // end inline mainGTU                            fmap[j] = v;                      }                        if (firstAttemptShadow && (i <= hi)                          && (workDoneShadow > workLimitShadow))                      {                          goto END_HP;                      }                  }              }
Magic Number,Ionic.BZip2,BZip2Compressor,C:\repos\haf_DotNetZip.Semverd\src\BZip2\BZip2Compressor.cs,mainSimpleSort,The following statement contains a magic number: while (--hp >= 0)              {                  int h = increments[hp];                  int mj = lo + h - 1;                    for (int i = lo + h; i <= hi;)                  {                      // copy                      for (int k = 3; (i <= hi) && (--k >= 0); i++)                      {                          int v = fmap[i];                          int vd = v + d;                          int j = i;                            // for (int a;                          // (j > mj) && mainGtU((a = fmap[j - h]) + d' vd'                          // block' quadrant' lastShadow);                          // j -= h) {                          // fmap[j] = a;                          // }                          //                          // unrolled version:                            // start inline mainGTU                          bool onceRunned = false;                          int a = 0;                            HAMMER: while (true)                          {                              if (onceRunned)                              {                                  fmap[j] = a;                                  if ((j -= h) <= mj)                                  {                                      goto END_HAMMER;                                  }                              }                              else {                                  onceRunned = true;                              }                                a = fmap[j - h];                              int i1 = a + d;                              int i2 = vd;                                // following could be done in a loop' but                              // unrolled it for performance:                              if (block[i1 + 1] == block[i2 + 1])                              {                                  if (block[i1 + 2] == block[i2 + 2])                                  {                                      if (block[i1 + 3] == block[i2 + 3])                                      {                                          if (block[i1 + 4] == block[i2 + 4])                                          {                                              if (block[i1 + 5] == block[i2 + 5])                                              {                                                  if (block[(i1 += 6)] == block[(i2 += 6)])                                                  {                                                      int x = lastShadow;                                                      X: while (x > 0)                                                      {                                                          x -= 4;                                                            if (block[i1 + 1] == block[i2 + 1])                                                          {                                                              if (quadrant[i1] == quadrant[i2])                                                              {                                                                  if (block[i1 + 2] == block[i2 + 2])                                                                  {                                                                      if (quadrant[i1 + 1] == quadrant[i2 + 1])                                                                      {                                                                          if (block[i1 + 3] == block[i2 + 3])                                                                          {                                                                              if (quadrant[i1 + 2] == quadrant[i2 + 2])                                                                              {                                                                                  if (block[i1 + 4] == block[i2 + 4])                                                                                  {                                                                                      if (quadrant[i1 + 3] == quadrant[i2 + 3])                                                                                      {                                                                                          if ((i1 += 4) >= lastPlus1)                                                                                          {                                                                                              i1 -= lastPlus1;                                                                                          }                                                                                          if ((i2 += 4) >= lastPlus1)                                                                                          {                                                                                              i2 -= lastPlus1;                                                                                          }                                                                                          workDoneShadow++;                                                                                          goto X;                                                                                      }                                                                                      else if ((quadrant[i1 + 3] > quadrant[i2 + 3]))                                                                                      {                                                                                          goto HAMMER;                                                                                      }                                                                                      else {                                                                                          goto END_HAMMER;                                                                                      }                                                                                  }                                                                                  else if ((block[i1 + 4] & 0xff) > (block[i2 + 4] & 0xff))                                                                                  {                                                                                      goto HAMMER;                                                                                  }                                                                                  else {                                                                                      goto END_HAMMER;                                                                                  }                                                                              }                                                                              else if ((quadrant[i1 + 2] > quadrant[i2 + 2]))                                                                              {                                                                                  goto HAMMER;                                                                              }                                                                              else {                                                                                  goto END_HAMMER;                                                                              }                                                                          }                                                                          else if ((block[i1 + 3] & 0xff) > (block[i2 + 3] & 0xff))                                                                          {                                                                              goto HAMMER;                                                                          }                                                                          else {                                                                              goto END_HAMMER;                                                                          }                                                                      }                                                                      else if ((quadrant[i1 + 1] > quadrant[i2 + 1]))                                                                      {                                                                          goto HAMMER;                                                                      }                                                                      else {                                                                          goto END_HAMMER;                                                                      }                                                                  }                                                                  else if ((block[i1 + 2] & 0xff) > (block[i2 + 2] & 0xff))                                                                  {                                                                      goto HAMMER;                                                                  }                                                                  else {                                                                      goto END_HAMMER;                                                                  }                                                              }                                                              else if ((quadrant[i1] > quadrant[i2]))                                                              {                                                                  goto HAMMER;                                                              }                                                              else {                                                                  goto END_HAMMER;                                                              }                                                          }                                                          else if ((block[i1 + 1] & 0xff) > (block[i2 + 1] & 0xff))                                                          {                                                              goto HAMMER;                                                          }                                                          else {                                                              goto END_HAMMER;                                                          }                                                        }                                                      goto END_HAMMER;                                                  } // while x > 0                                                  else {                                                      if ((block[i1] & 0xff) > (block[i2] & 0xff))                                                      {                                                          goto HAMMER;                                                      }                                                      else {                                                          goto END_HAMMER;                                                      }                                                  }                                              }                                              else if ((block[i1 + 5] & 0xff) > (block[i2 + 5] & 0xff))                                              {                                                  goto HAMMER;                                              }                                              else {                                                  goto END_HAMMER;                                              }                                          }                                          else if ((block[i1 + 4] & 0xff) > (block[i2 + 4] & 0xff))                                          {                                              goto HAMMER;                                          }                                          else {                                              goto END_HAMMER;                                          }                                      }                                      else if ((block[i1 + 3] & 0xff) > (block[i2 + 3] & 0xff))                                      {                                          goto HAMMER;                                      }                                      else {                                          goto END_HAMMER;                                      }                                  }                                  else if ((block[i1 + 2] & 0xff) > (block[i2 + 2] & 0xff))                                  {                                      goto HAMMER;                                  }                                  else {                                      goto END_HAMMER;                                  }                              }                              else if ((block[i1 + 1] & 0xff) > (block[i2 + 1] & 0xff))                              {                                  goto HAMMER;                              }                              else {                                  goto END_HAMMER;                              }                            } // HAMMER                            END_HAMMER:                          // end inline mainGTU                            fmap[j] = v;                      }                        if (firstAttemptShadow && (i <= hi)                          && (workDoneShadow > workLimitShadow))                      {                          goto END_HP;                      }                  }              }
Magic Number,Ionic.BZip2,BZip2Compressor,C:\repos\haf_DotNetZip.Semverd\src\BZip2\BZip2Compressor.cs,mainSimpleSort,The following statement contains a magic number: while (--hp >= 0)              {                  int h = increments[hp];                  int mj = lo + h - 1;                    for (int i = lo + h; i <= hi;)                  {                      // copy                      for (int k = 3; (i <= hi) && (--k >= 0); i++)                      {                          int v = fmap[i];                          int vd = v + d;                          int j = i;                            // for (int a;                          // (j > mj) && mainGtU((a = fmap[j - h]) + d' vd'                          // block' quadrant' lastShadow);                          // j -= h) {                          // fmap[j] = a;                          // }                          //                          // unrolled version:                            // start inline mainGTU                          bool onceRunned = false;                          int a = 0;                            HAMMER: while (true)                          {                              if (onceRunned)                              {                                  fmap[j] = a;                                  if ((j -= h) <= mj)                                  {                                      goto END_HAMMER;                                  }                              }                              else {                                  onceRunned = true;                              }                                a = fmap[j - h];                              int i1 = a + d;                              int i2 = vd;                                // following could be done in a loop' but                              // unrolled it for performance:                              if (block[i1 + 1] == block[i2 + 1])                              {                                  if (block[i1 + 2] == block[i2 + 2])                                  {                                      if (block[i1 + 3] == block[i2 + 3])                                      {                                          if (block[i1 + 4] == block[i2 + 4])                                          {                                              if (block[i1 + 5] == block[i2 + 5])                                              {                                                  if (block[(i1 += 6)] == block[(i2 += 6)])                                                  {                                                      int x = lastShadow;                                                      X: while (x > 0)                                                      {                                                          x -= 4;                                                            if (block[i1 + 1] == block[i2 + 1])                                                          {                                                              if (quadrant[i1] == quadrant[i2])                                                              {                                                                  if (block[i1 + 2] == block[i2 + 2])                                                                  {                                                                      if (quadrant[i1 + 1] == quadrant[i2 + 1])                                                                      {                                                                          if (block[i1 + 3] == block[i2 + 3])                                                                          {                                                                              if (quadrant[i1 + 2] == quadrant[i2 + 2])                                                                              {                                                                                  if (block[i1 + 4] == block[i2 + 4])                                                                                  {                                                                                      if (quadrant[i1 + 3] == quadrant[i2 + 3])                                                                                      {                                                                                          if ((i1 += 4) >= lastPlus1)                                                                                          {                                                                                              i1 -= lastPlus1;                                                                                          }                                                                                          if ((i2 += 4) >= lastPlus1)                                                                                          {                                                                                              i2 -= lastPlus1;                                                                                          }                                                                                          workDoneShadow++;                                                                                          goto X;                                                                                      }                                                                                      else if ((quadrant[i1 + 3] > quadrant[i2 + 3]))                                                                                      {                                                                                          goto HAMMER;                                                                                      }                                                                                      else {                                                                                          goto END_HAMMER;                                                                                      }                                                                                  }                                                                                  else if ((block[i1 + 4] & 0xff) > (block[i2 + 4] & 0xff))                                                                                  {                                                                                      goto HAMMER;                                                                                  }                                                                                  else {                                                                                      goto END_HAMMER;                                                                                  }                                                                              }                                                                              else if ((quadrant[i1 + 2] > quadrant[i2 + 2]))                                                                              {                                                                                  goto HAMMER;                                                                              }                                                                              else {                                                                                  goto END_HAMMER;                                                                              }                                                                          }                                                                          else if ((block[i1 + 3] & 0xff) > (block[i2 + 3] & 0xff))                                                                          {                                                                              goto HAMMER;                                                                          }                                                                          else {                                                                              goto END_HAMMER;                                                                          }                                                                      }                                                                      else if ((quadrant[i1 + 1] > quadrant[i2 + 1]))                                                                      {                                                                          goto HAMMER;                                                                      }                                                                      else {                                                                          goto END_HAMMER;                                                                      }                                                                  }                                                                  else if ((block[i1 + 2] & 0xff) > (block[i2 + 2] & 0xff))                                                                  {                                                                      goto HAMMER;                                                                  }                                                                  else {                                                                      goto END_HAMMER;                                                                  }                                                              }                                                              else if ((quadrant[i1] > quadrant[i2]))                                                              {                                                                  goto HAMMER;                                                              }                                                              else {                                                                  goto END_HAMMER;                                                              }                                                          }                                                          else if ((block[i1 + 1] & 0xff) > (block[i2 + 1] & 0xff))                                                          {                                                              goto HAMMER;                                                          }                                                          else {                                                              goto END_HAMMER;                                                          }                                                        }                                                      goto END_HAMMER;                                                  } // while x > 0                                                  else {                                                      if ((block[i1] & 0xff) > (block[i2] & 0xff))                                                      {                                                          goto HAMMER;                                                      }                                                      else {                                                          goto END_HAMMER;                                                      }                                                  }                                              }                                              else if ((block[i1 + 5] & 0xff) > (block[i2 + 5] & 0xff))                                              {                                                  goto HAMMER;                                              }                                              else {                                                  goto END_HAMMER;                                              }                                          }                                          else if ((block[i1 + 4] & 0xff) > (block[i2 + 4] & 0xff))                                          {                                              goto HAMMER;                                          }                                          else {                                              goto END_HAMMER;                                          }                                      }                                      else if ((block[i1 + 3] & 0xff) > (block[i2 + 3] & 0xff))                                      {                                          goto HAMMER;                                      }                                      else {                                          goto END_HAMMER;                                      }                                  }                                  else if ((block[i1 + 2] & 0xff) > (block[i2 + 2] & 0xff))                                  {                                      goto HAMMER;                                  }                                  else {                                      goto END_HAMMER;                                  }                              }                              else if ((block[i1 + 1] & 0xff) > (block[i2 + 1] & 0xff))                              {                                  goto HAMMER;                              }                              else {                                  goto END_HAMMER;                              }                            } // HAMMER                            END_HAMMER:                          // end inline mainGTU                            fmap[j] = v;                      }                        if (firstAttemptShadow && (i <= hi)                          && (workDoneShadow > workLimitShadow))                      {                          goto END_HP;                      }                  }              }
Magic Number,Ionic.BZip2,BZip2Compressor,C:\repos\haf_DotNetZip.Semverd\src\BZip2\BZip2Compressor.cs,mainSimpleSort,The following statement contains a magic number: while (--hp >= 0)              {                  int h = increments[hp];                  int mj = lo + h - 1;                    for (int i = lo + h; i <= hi;)                  {                      // copy                      for (int k = 3; (i <= hi) && (--k >= 0); i++)                      {                          int v = fmap[i];                          int vd = v + d;                          int j = i;                            // for (int a;                          // (j > mj) && mainGtU((a = fmap[j - h]) + d' vd'                          // block' quadrant' lastShadow);                          // j -= h) {                          // fmap[j] = a;                          // }                          //                          // unrolled version:                            // start inline mainGTU                          bool onceRunned = false;                          int a = 0;                            HAMMER: while (true)                          {                              if (onceRunned)                              {                                  fmap[j] = a;                                  if ((j -= h) <= mj)                                  {                                      goto END_HAMMER;                                  }                              }                              else {                                  onceRunned = true;                              }                                a = fmap[j - h];                              int i1 = a + d;                              int i2 = vd;                                // following could be done in a loop' but                              // unrolled it for performance:                              if (block[i1 + 1] == block[i2 + 1])                              {                                  if (block[i1 + 2] == block[i2 + 2])                                  {                                      if (block[i1 + 3] == block[i2 + 3])                                      {                                          if (block[i1 + 4] == block[i2 + 4])                                          {                                              if (block[i1 + 5] == block[i2 + 5])                                              {                                                  if (block[(i1 += 6)] == block[(i2 += 6)])                                                  {                                                      int x = lastShadow;                                                      X: while (x > 0)                                                      {                                                          x -= 4;                                                            if (block[i1 + 1] == block[i2 + 1])                                                          {                                                              if (quadrant[i1] == quadrant[i2])                                                              {                                                                  if (block[i1 + 2] == block[i2 + 2])                                                                  {                                                                      if (quadrant[i1 + 1] == quadrant[i2 + 1])                                                                      {                                                                          if (block[i1 + 3] == block[i2 + 3])                                                                          {                                                                              if (quadrant[i1 + 2] == quadrant[i2 + 2])                                                                              {                                                                                  if (block[i1 + 4] == block[i2 + 4])                                                                                  {                                                                                      if (quadrant[i1 + 3] == quadrant[i2 + 3])                                                                                      {                                                                                          if ((i1 += 4) >= lastPlus1)                                                                                          {                                                                                              i1 -= lastPlus1;                                                                                          }                                                                                          if ((i2 += 4) >= lastPlus1)                                                                                          {                                                                                              i2 -= lastPlus1;                                                                                          }                                                                                          workDoneShadow++;                                                                                          goto X;                                                                                      }                                                                                      else if ((quadrant[i1 + 3] > quadrant[i2 + 3]))                                                                                      {                                                                                          goto HAMMER;                                                                                      }                                                                                      else {                                                                                          goto END_HAMMER;                                                                                      }                                                                                  }                                                                                  else if ((block[i1 + 4] & 0xff) > (block[i2 + 4] & 0xff))                                                                                  {                                                                                      goto HAMMER;                                                                                  }                                                                                  else {                                                                                      goto END_HAMMER;                                                                                  }                                                                              }                                                                              else if ((quadrant[i1 + 2] > quadrant[i2 + 2]))                                                                              {                                                                                  goto HAMMER;                                                                              }                                                                              else {                                                                                  goto END_HAMMER;                                                                              }                                                                          }                                                                          else if ((block[i1 + 3] & 0xff) > (block[i2 + 3] & 0xff))                                                                          {                                                                              goto HAMMER;                                                                          }                                                                          else {                                                                              goto END_HAMMER;                                                                          }                                                                      }                                                                      else if ((quadrant[i1 + 1] > quadrant[i2 + 1]))                                                                      {                                                                          goto HAMMER;                                                                      }                                                                      else {                                                                          goto END_HAMMER;                                                                      }                                                                  }                                                                  else if ((block[i1 + 2] & 0xff) > (block[i2 + 2] & 0xff))                                                                  {                                                                      goto HAMMER;                                                                  }                                                                  else {                                                                      goto END_HAMMER;                                                                  }                                                              }                                                              else if ((quadrant[i1] > quadrant[i2]))                                                              {                                                                  goto HAMMER;                                                              }                                                              else {                                                                  goto END_HAMMER;                                                              }                                                          }                                                          else if ((block[i1 + 1] & 0xff) > (block[i2 + 1] & 0xff))                                                          {                                                              goto HAMMER;                                                          }                                                          else {                                                              goto END_HAMMER;                                                          }                                                        }                                                      goto END_HAMMER;                                                  } // while x > 0                                                  else {                                                      if ((block[i1] & 0xff) > (block[i2] & 0xff))                                                      {                                                          goto HAMMER;                                                      }                                                      else {                                                          goto END_HAMMER;                                                      }                                                  }                                              }                                              else if ((block[i1 + 5] & 0xff) > (block[i2 + 5] & 0xff))                                              {                                                  goto HAMMER;                                              }                                              else {                                                  goto END_HAMMER;                                              }                                          }                                          else if ((block[i1 + 4] & 0xff) > (block[i2 + 4] & 0xff))                                          {                                              goto HAMMER;                                          }                                          else {                                              goto END_HAMMER;                                          }                                      }                                      else if ((block[i1 + 3] & 0xff) > (block[i2 + 3] & 0xff))                                      {                                          goto HAMMER;                                      }                                      else {                                          goto END_HAMMER;                                      }                                  }                                  else if ((block[i1 + 2] & 0xff) > (block[i2 + 2] & 0xff))                                  {                                      goto HAMMER;                                  }                                  else {                                      goto END_HAMMER;                                  }                              }                              else if ((block[i1 + 1] & 0xff) > (block[i2 + 1] & 0xff))                              {                                  goto HAMMER;                              }                              else {                                  goto END_HAMMER;                              }                            } // HAMMER                            END_HAMMER:                          // end inline mainGTU                            fmap[j] = v;                      }                        if (firstAttemptShadow && (i <= hi)                          && (workDoneShadow > workLimitShadow))                      {                          goto END_HP;                      }                  }              }
Magic Number,Ionic.BZip2,BZip2Compressor,C:\repos\haf_DotNetZip.Semverd\src\BZip2\BZip2Compressor.cs,mainSimpleSort,The following statement contains a magic number: while (--hp >= 0)              {                  int h = increments[hp];                  int mj = lo + h - 1;                    for (int i = lo + h; i <= hi;)                  {                      // copy                      for (int k = 3; (i <= hi) && (--k >= 0); i++)                      {                          int v = fmap[i];                          int vd = v + d;                          int j = i;                            // for (int a;                          // (j > mj) && mainGtU((a = fmap[j - h]) + d' vd'                          // block' quadrant' lastShadow);                          // j -= h) {                          // fmap[j] = a;                          // }                          //                          // unrolled version:                            // start inline mainGTU                          bool onceRunned = false;                          int a = 0;                            HAMMER: while (true)                          {                              if (onceRunned)                              {                                  fmap[j] = a;                                  if ((j -= h) <= mj)                                  {                                      goto END_HAMMER;                                  }                              }                              else {                                  onceRunned = true;                              }                                a = fmap[j - h];                              int i1 = a + d;                              int i2 = vd;                                // following could be done in a loop' but                              // unrolled it for performance:                              if (block[i1 + 1] == block[i2 + 1])                              {                                  if (block[i1 + 2] == block[i2 + 2])                                  {                                      if (block[i1 + 3] == block[i2 + 3])                                      {                                          if (block[i1 + 4] == block[i2 + 4])                                          {                                              if (block[i1 + 5] == block[i2 + 5])                                              {                                                  if (block[(i1 += 6)] == block[(i2 += 6)])                                                  {                                                      int x = lastShadow;                                                      X: while (x > 0)                                                      {                                                          x -= 4;                                                            if (block[i1 + 1] == block[i2 + 1])                                                          {                                                              if (quadrant[i1] == quadrant[i2])                                                              {                                                                  if (block[i1 + 2] == block[i2 + 2])                                                                  {                                                                      if (quadrant[i1 + 1] == quadrant[i2 + 1])                                                                      {                                                                          if (block[i1 + 3] == block[i2 + 3])                                                                          {                                                                              if (quadrant[i1 + 2] == quadrant[i2 + 2])                                                                              {                                                                                  if (block[i1 + 4] == block[i2 + 4])                                                                                  {                                                                                      if (quadrant[i1 + 3] == quadrant[i2 + 3])                                                                                      {                                                                                          if ((i1 += 4) >= lastPlus1)                                                                                          {                                                                                              i1 -= lastPlus1;                                                                                          }                                                                                          if ((i2 += 4) >= lastPlus1)                                                                                          {                                                                                              i2 -= lastPlus1;                                                                                          }                                                                                          workDoneShadow++;                                                                                          goto X;                                                                                      }                                                                                      else if ((quadrant[i1 + 3] > quadrant[i2 + 3]))                                                                                      {                                                                                          goto HAMMER;                                                                                      }                                                                                      else {                                                                                          goto END_HAMMER;                                                                                      }                                                                                  }                                                                                  else if ((block[i1 + 4] & 0xff) > (block[i2 + 4] & 0xff))                                                                                  {                                                                                      goto HAMMER;                                                                                  }                                                                                  else {                                                                                      goto END_HAMMER;                                                                                  }                                                                              }                                                                              else if ((quadrant[i1 + 2] > quadrant[i2 + 2]))                                                                              {                                                                                  goto HAMMER;                                                                              }                                                                              else {                                                                                  goto END_HAMMER;                                                                              }                                                                          }                                                                          else if ((block[i1 + 3] & 0xff) > (block[i2 + 3] & 0xff))                                                                          {                                                                              goto HAMMER;                                                                          }                                                                          else {                                                                              goto END_HAMMER;                                                                          }                                                                      }                                                                      else if ((quadrant[i1 + 1] > quadrant[i2 + 1]))                                                                      {                                                                          goto HAMMER;                                                                      }                                                                      else {                                                                          goto END_HAMMER;                                                                      }                                                                  }                                                                  else if ((block[i1 + 2] & 0xff) > (block[i2 + 2] & 0xff))                                                                  {                                                                      goto HAMMER;                                                                  }                                                                  else {                                                                      goto END_HAMMER;                                                                  }                                                              }                                                              else if ((quadrant[i1] > quadrant[i2]))                                                              {                                                                  goto HAMMER;                                                              }                                                              else {                                                                  goto END_HAMMER;                                                              }                                                          }                                                          else if ((block[i1 + 1] & 0xff) > (block[i2 + 1] & 0xff))                                                          {                                                              goto HAMMER;                                                          }                                                          else {                                                              goto END_HAMMER;                                                          }                                                        }                                                      goto END_HAMMER;                                                  } // while x > 0                                                  else {                                                      if ((block[i1] & 0xff) > (block[i2] & 0xff))                                                      {                                                          goto HAMMER;                                                      }                                                      else {                                                          goto END_HAMMER;                                                      }                                                  }                                              }                                              else if ((block[i1 + 5] & 0xff) > (block[i2 + 5] & 0xff))                                              {                                                  goto HAMMER;                                              }                                              else {                                                  goto END_HAMMER;                                              }                                          }                                          else if ((block[i1 + 4] & 0xff) > (block[i2 + 4] & 0xff))                                          {                                              goto HAMMER;                                          }                                          else {                                              goto END_HAMMER;                                          }                                      }                                      else if ((block[i1 + 3] & 0xff) > (block[i2 + 3] & 0xff))                                      {                                          goto HAMMER;                                      }                                      else {                                          goto END_HAMMER;                                      }                                  }                                  else if ((block[i1 + 2] & 0xff) > (block[i2 + 2] & 0xff))                                  {                                      goto HAMMER;                                  }                                  else {                                      goto END_HAMMER;                                  }                              }                              else if ((block[i1 + 1] & 0xff) > (block[i2 + 1] & 0xff))                              {                                  goto HAMMER;                              }                              else {                                  goto END_HAMMER;                              }                            } // HAMMER                            END_HAMMER:                          // end inline mainGTU                            fmap[j] = v;                      }                        if (firstAttemptShadow && (i <= hi)                          && (workDoneShadow > workLimitShadow))                      {                          goto END_HP;                      }                  }              }
Magic Number,Ionic.BZip2,BZip2Compressor,C:\repos\haf_DotNetZip.Semverd\src\BZip2\BZip2Compressor.cs,mainSimpleSort,The following statement contains a magic number: while (--hp >= 0)              {                  int h = increments[hp];                  int mj = lo + h - 1;                    for (int i = lo + h; i <= hi;)                  {                      // copy                      for (int k = 3; (i <= hi) && (--k >= 0); i++)                      {                          int v = fmap[i];                          int vd = v + d;                          int j = i;                            // for (int a;                          // (j > mj) && mainGtU((a = fmap[j - h]) + d' vd'                          // block' quadrant' lastShadow);                          // j -= h) {                          // fmap[j] = a;                          // }                          //                          // unrolled version:                            // start inline mainGTU                          bool onceRunned = false;                          int a = 0;                            HAMMER: while (true)                          {                              if (onceRunned)                              {                                  fmap[j] = a;                                  if ((j -= h) <= mj)                                  {                                      goto END_HAMMER;                                  }                              }                              else {                                  onceRunned = true;                              }                                a = fmap[j - h];                              int i1 = a + d;                              int i2 = vd;                                // following could be done in a loop' but                              // unrolled it for performance:                              if (block[i1 + 1] == block[i2 + 1])                              {                                  if (block[i1 + 2] == block[i2 + 2])                                  {                                      if (block[i1 + 3] == block[i2 + 3])                                      {                                          if (block[i1 + 4] == block[i2 + 4])                                          {                                              if (block[i1 + 5] == block[i2 + 5])                                              {                                                  if (block[(i1 += 6)] == block[(i2 += 6)])                                                  {                                                      int x = lastShadow;                                                      X: while (x > 0)                                                      {                                                          x -= 4;                                                            if (block[i1 + 1] == block[i2 + 1])                                                          {                                                              if (quadrant[i1] == quadrant[i2])                                                              {                                                                  if (block[i1 + 2] == block[i2 + 2])                                                                  {                                                                      if (quadrant[i1 + 1] == quadrant[i2 + 1])                                                                      {                                                                          if (block[i1 + 3] == block[i2 + 3])                                                                          {                                                                              if (quadrant[i1 + 2] == quadrant[i2 + 2])                                                                              {                                                                                  if (block[i1 + 4] == block[i2 + 4])                                                                                  {                                                                                      if (quadrant[i1 + 3] == quadrant[i2 + 3])                                                                                      {                                                                                          if ((i1 += 4) >= lastPlus1)                                                                                          {                                                                                              i1 -= lastPlus1;                                                                                          }                                                                                          if ((i2 += 4) >= lastPlus1)                                                                                          {                                                                                              i2 -= lastPlus1;                                                                                          }                                                                                          workDoneShadow++;                                                                                          goto X;                                                                                      }                                                                                      else if ((quadrant[i1 + 3] > quadrant[i2 + 3]))                                                                                      {                                                                                          goto HAMMER;                                                                                      }                                                                                      else {                                                                                          goto END_HAMMER;                                                                                      }                                                                                  }                                                                                  else if ((block[i1 + 4] & 0xff) > (block[i2 + 4] & 0xff))                                                                                  {                                                                                      goto HAMMER;                                                                                  }                                                                                  else {                                                                                      goto END_HAMMER;                                                                                  }                                                                              }                                                                              else if ((quadrant[i1 + 2] > quadrant[i2 + 2]))                                                                              {                                                                                  goto HAMMER;                                                                              }                                                                              else {                                                                                  goto END_HAMMER;                                                                              }                                                                          }                                                                          else if ((block[i1 + 3] & 0xff) > (block[i2 + 3] & 0xff))                                                                          {                                                                              goto HAMMER;                                                                          }                                                                          else {                                                                              goto END_HAMMER;                                                                          }                                                                      }                                                                      else if ((quadrant[i1 + 1] > quadrant[i2 + 1]))                                                                      {                                                                          goto HAMMER;                                                                      }                                                                      else {                                                                          goto END_HAMMER;                                                                      }                                                                  }                                                                  else if ((block[i1 + 2] & 0xff) > (block[i2 + 2] & 0xff))                                                                  {                                                                      goto HAMMER;                                                                  }                                                                  else {                                                                      goto END_HAMMER;                                                                  }                                                              }                                                              else if ((quadrant[i1] > quadrant[i2]))                                                              {                                                                  goto HAMMER;                                                              }                                                              else {                                                                  goto END_HAMMER;                                                              }                                                          }                                                          else if ((block[i1 + 1] & 0xff) > (block[i2 + 1] & 0xff))                                                          {                                                              goto HAMMER;                                                          }                                                          else {                                                              goto END_HAMMER;                                                          }                                                        }                                                      goto END_HAMMER;                                                  } // while x > 0                                                  else {                                                      if ((block[i1] & 0xff) > (block[i2] & 0xff))                                                      {                                                          goto HAMMER;                                                      }                                                      else {                                                          goto END_HAMMER;                                                      }                                                  }                                              }                                              else if ((block[i1 + 5] & 0xff) > (block[i2 + 5] & 0xff))                                              {                                                  goto HAMMER;                                              }                                              else {                                                  goto END_HAMMER;                                              }                                          }                                          else if ((block[i1 + 4] & 0xff) > (block[i2 + 4] & 0xff))                                          {                                              goto HAMMER;                                          }                                          else {                                              goto END_HAMMER;                                          }                                      }                                      else if ((block[i1 + 3] & 0xff) > (block[i2 + 3] & 0xff))                                      {                                          goto HAMMER;                                      }                                      else {                                          goto END_HAMMER;                                      }                                  }                                  else if ((block[i1 + 2] & 0xff) > (block[i2 + 2] & 0xff))                                  {                                      goto HAMMER;                                  }                                  else {                                      goto END_HAMMER;                                  }                              }                              else if ((block[i1 + 1] & 0xff) > (block[i2 + 1] & 0xff))                              {                                  goto HAMMER;                              }                              else {                                  goto END_HAMMER;                              }                            } // HAMMER                            END_HAMMER:                          // end inline mainGTU                            fmap[j] = v;                      }                        if (firstAttemptShadow && (i <= hi)                          && (workDoneShadow > workLimitShadow))                      {                          goto END_HP;                      }                  }              }
Magic Number,Ionic.BZip2,BZip2Compressor,C:\repos\haf_DotNetZip.Semverd\src\BZip2\BZip2Compressor.cs,mainSimpleSort,The following statement contains a magic number: while (--hp >= 0)              {                  int h = increments[hp];                  int mj = lo + h - 1;                    for (int i = lo + h; i <= hi;)                  {                      // copy                      for (int k = 3; (i <= hi) && (--k >= 0); i++)                      {                          int v = fmap[i];                          int vd = v + d;                          int j = i;                            // for (int a;                          // (j > mj) && mainGtU((a = fmap[j - h]) + d' vd'                          // block' quadrant' lastShadow);                          // j -= h) {                          // fmap[j] = a;                          // }                          //                          // unrolled version:                            // start inline mainGTU                          bool onceRunned = false;                          int a = 0;                            HAMMER: while (true)                          {                              if (onceRunned)                              {                                  fmap[j] = a;                                  if ((j -= h) <= mj)                                  {                                      goto END_HAMMER;                                  }                              }                              else {                                  onceRunned = true;                              }                                a = fmap[j - h];                              int i1 = a + d;                              int i2 = vd;                                // following could be done in a loop' but                              // unrolled it for performance:                              if (block[i1 + 1] == block[i2 + 1])                              {                                  if (block[i1 + 2] == block[i2 + 2])                                  {                                      if (block[i1 + 3] == block[i2 + 3])                                      {                                          if (block[i1 + 4] == block[i2 + 4])                                          {                                              if (block[i1 + 5] == block[i2 + 5])                                              {                                                  if (block[(i1 += 6)] == block[(i2 += 6)])                                                  {                                                      int x = lastShadow;                                                      X: while (x > 0)                                                      {                                                          x -= 4;                                                            if (block[i1 + 1] == block[i2 + 1])                                                          {                                                              if (quadrant[i1] == quadrant[i2])                                                              {                                                                  if (block[i1 + 2] == block[i2 + 2])                                                                  {                                                                      if (quadrant[i1 + 1] == quadrant[i2 + 1])                                                                      {                                                                          if (block[i1 + 3] == block[i2 + 3])                                                                          {                                                                              if (quadrant[i1 + 2] == quadrant[i2 + 2])                                                                              {                                                                                  if (block[i1 + 4] == block[i2 + 4])                                                                                  {                                                                                      if (quadrant[i1 + 3] == quadrant[i2 + 3])                                                                                      {                                                                                          if ((i1 += 4) >= lastPlus1)                                                                                          {                                                                                              i1 -= lastPlus1;                                                                                          }                                                                                          if ((i2 += 4) >= lastPlus1)                                                                                          {                                                                                              i2 -= lastPlus1;                                                                                          }                                                                                          workDoneShadow++;                                                                                          goto X;                                                                                      }                                                                                      else if ((quadrant[i1 + 3] > quadrant[i2 + 3]))                                                                                      {                                                                                          goto HAMMER;                                                                                      }                                                                                      else {                                                                                          goto END_HAMMER;                                                                                      }                                                                                  }                                                                                  else if ((block[i1 + 4] & 0xff) > (block[i2 + 4] & 0xff))                                                                                  {                                                                                      goto HAMMER;                                                                                  }                                                                                  else {                                                                                      goto END_HAMMER;                                                                                  }                                                                              }                                                                              else if ((quadrant[i1 + 2] > quadrant[i2 + 2]))                                                                              {                                                                                  goto HAMMER;                                                                              }                                                                              else {                                                                                  goto END_HAMMER;                                                                              }                                                                          }                                                                          else if ((block[i1 + 3] & 0xff) > (block[i2 + 3] & 0xff))                                                                          {                                                                              goto HAMMER;                                                                          }                                                                          else {                                                                              goto END_HAMMER;                                                                          }                                                                      }                                                                      else if ((quadrant[i1 + 1] > quadrant[i2 + 1]))                                                                      {                                                                          goto HAMMER;                                                                      }                                                                      else {                                                                          goto END_HAMMER;                                                                      }                                                                  }                                                                  else if ((block[i1 + 2] & 0xff) > (block[i2 + 2] & 0xff))                                                                  {                                                                      goto HAMMER;                                                                  }                                                                  else {                                                                      goto END_HAMMER;                                                                  }                                                              }                                                              else if ((quadrant[i1] > quadrant[i2]))                                                              {                                                                  goto HAMMER;                                                              }                                                              else {                                                                  goto END_HAMMER;                                                              }                                                          }                                                          else if ((block[i1 + 1] & 0xff) > (block[i2 + 1] & 0xff))                                                          {                                                              goto HAMMER;                                                          }                                                          else {                                                              goto END_HAMMER;                                                          }                                                        }                                                      goto END_HAMMER;                                                  } // while x > 0                                                  else {                                                      if ((block[i1] & 0xff) > (block[i2] & 0xff))                                                      {                                                          goto HAMMER;                                                      }                                                      else {                                                          goto END_HAMMER;                                                      }                                                  }                                              }                                              else if ((block[i1 + 5] & 0xff) > (block[i2 + 5] & 0xff))                                              {                                                  goto HAMMER;                                              }                                              else {                                                  goto END_HAMMER;                                              }                                          }                                          else if ((block[i1 + 4] & 0xff) > (block[i2 + 4] & 0xff))                                          {                                              goto HAMMER;                                          }                                          else {                                              goto END_HAMMER;                                          }                                      }                                      else if ((block[i1 + 3] & 0xff) > (block[i2 + 3] & 0xff))                                      {                                          goto HAMMER;                                      }                                      else {                                          goto END_HAMMER;                                      }                                  }                                  else if ((block[i1 + 2] & 0xff) > (block[i2 + 2] & 0xff))                                  {                                      goto HAMMER;                                  }                                  else {                                      goto END_HAMMER;                                  }                              }                              else if ((block[i1 + 1] & 0xff) > (block[i2 + 1] & 0xff))                              {                                  goto HAMMER;                              }                              else {                                  goto END_HAMMER;                              }                            } // HAMMER                            END_HAMMER:                          // end inline mainGTU                            fmap[j] = v;                      }                        if (firstAttemptShadow && (i <= hi)                          && (workDoneShadow > workLimitShadow))                      {                          goto END_HP;                      }                  }              }
Magic Number,Ionic.BZip2,BZip2Compressor,C:\repos\haf_DotNetZip.Semverd\src\BZip2\BZip2Compressor.cs,mainSimpleSort,The following statement contains a magic number: while (--hp >= 0)              {                  int h = increments[hp];                  int mj = lo + h - 1;                    for (int i = lo + h; i <= hi;)                  {                      // copy                      for (int k = 3; (i <= hi) && (--k >= 0); i++)                      {                          int v = fmap[i];                          int vd = v + d;                          int j = i;                            // for (int a;                          // (j > mj) && mainGtU((a = fmap[j - h]) + d' vd'                          // block' quadrant' lastShadow);                          // j -= h) {                          // fmap[j] = a;                          // }                          //                          // unrolled version:                            // start inline mainGTU                          bool onceRunned = false;                          int a = 0;                            HAMMER: while (true)                          {                              if (onceRunned)                              {                                  fmap[j] = a;                                  if ((j -= h) <= mj)                                  {                                      goto END_HAMMER;                                  }                              }                              else {                                  onceRunned = true;                              }                                a = fmap[j - h];                              int i1 = a + d;                              int i2 = vd;                                // following could be done in a loop' but                              // unrolled it for performance:                              if (block[i1 + 1] == block[i2 + 1])                              {                                  if (block[i1 + 2] == block[i2 + 2])                                  {                                      if (block[i1 + 3] == block[i2 + 3])                                      {                                          if (block[i1 + 4] == block[i2 + 4])                                          {                                              if (block[i1 + 5] == block[i2 + 5])                                              {                                                  if (block[(i1 += 6)] == block[(i2 += 6)])                                                  {                                                      int x = lastShadow;                                                      X: while (x > 0)                                                      {                                                          x -= 4;                                                            if (block[i1 + 1] == block[i2 + 1])                                                          {                                                              if (quadrant[i1] == quadrant[i2])                                                              {                                                                  if (block[i1 + 2] == block[i2 + 2])                                                                  {                                                                      if (quadrant[i1 + 1] == quadrant[i2 + 1])                                                                      {                                                                          if (block[i1 + 3] == block[i2 + 3])                                                                          {                                                                              if (quadrant[i1 + 2] == quadrant[i2 + 2])                                                                              {                                                                                  if (block[i1 + 4] == block[i2 + 4])                                                                                  {                                                                                      if (quadrant[i1 + 3] == quadrant[i2 + 3])                                                                                      {                                                                                          if ((i1 += 4) >= lastPlus1)                                                                                          {                                                                                              i1 -= lastPlus1;                                                                                          }                                                                                          if ((i2 += 4) >= lastPlus1)                                                                                          {                                                                                              i2 -= lastPlus1;                                                                                          }                                                                                          workDoneShadow++;                                                                                          goto X;                                                                                      }                                                                                      else if ((quadrant[i1 + 3] > quadrant[i2 + 3]))                                                                                      {                                                                                          goto HAMMER;                                                                                      }                                                                                      else {                                                                                          goto END_HAMMER;                                                                                      }                                                                                  }                                                                                  else if ((block[i1 + 4] & 0xff) > (block[i2 + 4] & 0xff))                                                                                  {                                                                                      goto HAMMER;                                                                                  }                                                                                  else {                                                                                      goto END_HAMMER;                                                                                  }                                                                              }                                                                              else if ((quadrant[i1 + 2] > quadrant[i2 + 2]))                                                                              {                                                                                  goto HAMMER;                                                                              }                                                                              else {                                                                                  goto END_HAMMER;                                                                              }                                                                          }                                                                          else if ((block[i1 + 3] & 0xff) > (block[i2 + 3] & 0xff))                                                                          {                                                                              goto HAMMER;                                                                          }                                                                          else {                                                                              goto END_HAMMER;                                                                          }                                                                      }                                                                      else if ((quadrant[i1 + 1] > quadrant[i2 + 1]))                                                                      {                                                                          goto HAMMER;                                                                      }                                                                      else {                                                                          goto END_HAMMER;                                                                      }                                                                  }                                                                  else if ((block[i1 + 2] & 0xff) > (block[i2 + 2] & 0xff))                                                                  {                                                                      goto HAMMER;                                                                  }                                                                  else {                                                                      goto END_HAMMER;                                                                  }                                                              }                                                              else if ((quadrant[i1] > quadrant[i2]))                                                              {                                                                  goto HAMMER;                                                              }                                                              else {                                                                  goto END_HAMMER;                                                              }                                                          }                                                          else if ((block[i1 + 1] & 0xff) > (block[i2 + 1] & 0xff))                                                          {                                                              goto HAMMER;                                                          }                                                          else {                                                              goto END_HAMMER;                                                          }                                                        }                                                      goto END_HAMMER;                                                  } // while x > 0                                                  else {                                                      if ((block[i1] & 0xff) > (block[i2] & 0xff))                                                      {                                                          goto HAMMER;                                                      }                                                      else {                                                          goto END_HAMMER;                                                      }                                                  }                                              }                                              else if ((block[i1 + 5] & 0xff) > (block[i2 + 5] & 0xff))                                              {                                                  goto HAMMER;                                              }                                              else {                                                  goto END_HAMMER;                                              }                                          }                                          else if ((block[i1 + 4] & 0xff) > (block[i2 + 4] & 0xff))                                          {                                              goto HAMMER;                                          }                                          else {                                              goto END_HAMMER;                                          }                                      }                                      else if ((block[i1 + 3] & 0xff) > (block[i2 + 3] & 0xff))                                      {                                          goto HAMMER;                                      }                                      else {                                          goto END_HAMMER;                                      }                                  }                                  else if ((block[i1 + 2] & 0xff) > (block[i2 + 2] & 0xff))                                  {                                      goto HAMMER;                                  }                                  else {                                      goto END_HAMMER;                                  }                              }                              else if ((block[i1 + 1] & 0xff) > (block[i2 + 1] & 0xff))                              {                                  goto HAMMER;                              }                              else {                                  goto END_HAMMER;                              }                            } // HAMMER                            END_HAMMER:                          // end inline mainGTU                            fmap[j] = v;                      }                        if (firstAttemptShadow && (i <= hi)                          && (workDoneShadow > workLimitShadow))                      {                          goto END_HP;                      }                  }              }
Magic Number,Ionic.BZip2,BZip2Compressor,C:\repos\haf_DotNetZip.Semverd\src\BZip2\BZip2Compressor.cs,mainSimpleSort,The following statement contains a magic number: while (--hp >= 0)              {                  int h = increments[hp];                  int mj = lo + h - 1;                    for (int i = lo + h; i <= hi;)                  {                      // copy                      for (int k = 3; (i <= hi) && (--k >= 0); i++)                      {                          int v = fmap[i];                          int vd = v + d;                          int j = i;                            // for (int a;                          // (j > mj) && mainGtU((a = fmap[j - h]) + d' vd'                          // block' quadrant' lastShadow);                          // j -= h) {                          // fmap[j] = a;                          // }                          //                          // unrolled version:                            // start inline mainGTU                          bool onceRunned = false;                          int a = 0;                            HAMMER: while (true)                          {                              if (onceRunned)                              {                                  fmap[j] = a;                                  if ((j -= h) <= mj)                                  {                                      goto END_HAMMER;                                  }                              }                              else {                                  onceRunned = true;                              }                                a = fmap[j - h];                              int i1 = a + d;                              int i2 = vd;                                // following could be done in a loop' but                              // unrolled it for performance:                              if (block[i1 + 1] == block[i2 + 1])                              {                                  if (block[i1 + 2] == block[i2 + 2])                                  {                                      if (block[i1 + 3] == block[i2 + 3])                                      {                                          if (block[i1 + 4] == block[i2 + 4])                                          {                                              if (block[i1 + 5] == block[i2 + 5])                                              {                                                  if (block[(i1 += 6)] == block[(i2 += 6)])                                                  {                                                      int x = lastShadow;                                                      X: while (x > 0)                                                      {                                                          x -= 4;                                                            if (block[i1 + 1] == block[i2 + 1])                                                          {                                                              if (quadrant[i1] == quadrant[i2])                                                              {                                                                  if (block[i1 + 2] == block[i2 + 2])                                                                  {                                                                      if (quadrant[i1 + 1] == quadrant[i2 + 1])                                                                      {                                                                          if (block[i1 + 3] == block[i2 + 3])                                                                          {                                                                              if (quadrant[i1 + 2] == quadrant[i2 + 2])                                                                              {                                                                                  if (block[i1 + 4] == block[i2 + 4])                                                                                  {                                                                                      if (quadrant[i1 + 3] == quadrant[i2 + 3])                                                                                      {                                                                                          if ((i1 += 4) >= lastPlus1)                                                                                          {                                                                                              i1 -= lastPlus1;                                                                                          }                                                                                          if ((i2 += 4) >= lastPlus1)                                                                                          {                                                                                              i2 -= lastPlus1;                                                                                          }                                                                                          workDoneShadow++;                                                                                          goto X;                                                                                      }                                                                                      else if ((quadrant[i1 + 3] > quadrant[i2 + 3]))                                                                                      {                                                                                          goto HAMMER;                                                                                      }                                                                                      else {                                                                                          goto END_HAMMER;                                                                                      }                                                                                  }                                                                                  else if ((block[i1 + 4] & 0xff) > (block[i2 + 4] & 0xff))                                                                                  {                                                                                      goto HAMMER;                                                                                  }                                                                                  else {                                                                                      goto END_HAMMER;                                                                                  }                                                                              }                                                                              else if ((quadrant[i1 + 2] > quadrant[i2 + 2]))                                                                              {                                                                                  goto HAMMER;                                                                              }                                                                              else {                                                                                  goto END_HAMMER;                                                                              }                                                                          }                                                                          else if ((block[i1 + 3] & 0xff) > (block[i2 + 3] & 0xff))                                                                          {                                                                              goto HAMMER;                                                                          }                                                                          else {                                                                              goto END_HAMMER;                                                                          }                                                                      }                                                                      else if ((quadrant[i1 + 1] > quadrant[i2 + 1]))                                                                      {                                                                          goto HAMMER;                                                                      }                                                                      else {                                                                          goto END_HAMMER;                                                                      }                                                                  }                                                                  else if ((block[i1 + 2] & 0xff) > (block[i2 + 2] & 0xff))                                                                  {                                                                      goto HAMMER;                                                                  }                                                                  else {                                                                      goto END_HAMMER;                                                                  }                                                              }                                                              else if ((quadrant[i1] > quadrant[i2]))                                                              {                                                                  goto HAMMER;                                                              }                                                              else {                                                                  goto END_HAMMER;                                                              }                                                          }                                                          else if ((block[i1 + 1] & 0xff) > (block[i2 + 1] & 0xff))                                                          {                                                              goto HAMMER;                                                          }                                                          else {                                                              goto END_HAMMER;                                                          }                                                        }                                                      goto END_HAMMER;                                                  } // while x > 0                                                  else {                                                      if ((block[i1] & 0xff) > (block[i2] & 0xff))                                                      {                                                          goto HAMMER;                                                      }                                                      else {                                                          goto END_HAMMER;                                                      }                                                  }                                              }                                              else if ((block[i1 + 5] & 0xff) > (block[i2 + 5] & 0xff))                                              {                                                  goto HAMMER;                                              }                                              else {                                                  goto END_HAMMER;                                              }                                          }                                          else if ((block[i1 + 4] & 0xff) > (block[i2 + 4] & 0xff))                                          {                                              goto HAMMER;                                          }                                          else {                                              goto END_HAMMER;                                          }                                      }                                      else if ((block[i1 + 3] & 0xff) > (block[i2 + 3] & 0xff))                                      {                                          goto HAMMER;                                      }                                      else {                                          goto END_HAMMER;                                      }                                  }                                  else if ((block[i1 + 2] & 0xff) > (block[i2 + 2] & 0xff))                                  {                                      goto HAMMER;                                  }                                  else {                                      goto END_HAMMER;                                  }                              }                              else if ((block[i1 + 1] & 0xff) > (block[i2 + 1] & 0xff))                              {                                  goto HAMMER;                              }                              else {                                  goto END_HAMMER;                              }                            } // HAMMER                            END_HAMMER:                          // end inline mainGTU                            fmap[j] = v;                      }                        if (firstAttemptShadow && (i <= hi)                          && (workDoneShadow > workLimitShadow))                      {                          goto END_HP;                      }                  }              }
Magic Number,Ionic.BZip2,BZip2Compressor,C:\repos\haf_DotNetZip.Semverd\src\BZip2\BZip2Compressor.cs,mainSimpleSort,The following statement contains a magic number: while (--hp >= 0)              {                  int h = increments[hp];                  int mj = lo + h - 1;                    for (int i = lo + h; i <= hi;)                  {                      // copy                      for (int k = 3; (i <= hi) && (--k >= 0); i++)                      {                          int v = fmap[i];                          int vd = v + d;                          int j = i;                            // for (int a;                          // (j > mj) && mainGtU((a = fmap[j - h]) + d' vd'                          // block' quadrant' lastShadow);                          // j -= h) {                          // fmap[j] = a;                          // }                          //                          // unrolled version:                            // start inline mainGTU                          bool onceRunned = false;                          int a = 0;                            HAMMER: while (true)                          {                              if (onceRunned)                              {                                  fmap[j] = a;                                  if ((j -= h) <= mj)                                  {                                      goto END_HAMMER;                                  }                              }                              else {                                  onceRunned = true;                              }                                a = fmap[j - h];                              int i1 = a + d;                              int i2 = vd;                                // following could be done in a loop' but                              // unrolled it for performance:                              if (block[i1 + 1] == block[i2 + 1])                              {                                  if (block[i1 + 2] == block[i2 + 2])                                  {                                      if (block[i1 + 3] == block[i2 + 3])                                      {                                          if (block[i1 + 4] == block[i2 + 4])                                          {                                              if (block[i1 + 5] == block[i2 + 5])                                              {                                                  if (block[(i1 += 6)] == block[(i2 += 6)])                                                  {                                                      int x = lastShadow;                                                      X: while (x > 0)                                                      {                                                          x -= 4;                                                            if (block[i1 + 1] == block[i2 + 1])                                                          {                                                              if (quadrant[i1] == quadrant[i2])                                                              {                                                                  if (block[i1 + 2] == block[i2 + 2])                                                                  {                                                                      if (quadrant[i1 + 1] == quadrant[i2 + 1])                                                                      {                                                                          if (block[i1 + 3] == block[i2 + 3])                                                                          {                                                                              if (quadrant[i1 + 2] == quadrant[i2 + 2])                                                                              {                                                                                  if (block[i1 + 4] == block[i2 + 4])                                                                                  {                                                                                      if (quadrant[i1 + 3] == quadrant[i2 + 3])                                                                                      {                                                                                          if ((i1 += 4) >= lastPlus1)                                                                                          {                                                                                              i1 -= lastPlus1;                                                                                          }                                                                                          if ((i2 += 4) >= lastPlus1)                                                                                          {                                                                                              i2 -= lastPlus1;                                                                                          }                                                                                          workDoneShadow++;                                                                                          goto X;                                                                                      }                                                                                      else if ((quadrant[i1 + 3] > quadrant[i2 + 3]))                                                                                      {                                                                                          goto HAMMER;                                                                                      }                                                                                      else {                                                                                          goto END_HAMMER;                                                                                      }                                                                                  }                                                                                  else if ((block[i1 + 4] & 0xff) > (block[i2 + 4] & 0xff))                                                                                  {                                                                                      goto HAMMER;                                                                                  }                                                                                  else {                                                                                      goto END_HAMMER;                                                                                  }                                                                              }                                                                              else if ((quadrant[i1 + 2] > quadrant[i2 + 2]))                                                                              {                                                                                  goto HAMMER;                                                                              }                                                                              else {                                                                                  goto END_HAMMER;                                                                              }                                                                          }                                                                          else if ((block[i1 + 3] & 0xff) > (block[i2 + 3] & 0xff))                                                                          {                                                                              goto HAMMER;                                                                          }                                                                          else {                                                                              goto END_HAMMER;                                                                          }                                                                      }                                                                      else if ((quadrant[i1 + 1] > quadrant[i2 + 1]))                                                                      {                                                                          goto HAMMER;                                                                      }                                                                      else {                                                                          goto END_HAMMER;                                                                      }                                                                  }                                                                  else if ((block[i1 + 2] & 0xff) > (block[i2 + 2] & 0xff))                                                                  {                                                                      goto HAMMER;                                                                  }                                                                  else {                                                                      goto END_HAMMER;                                                                  }                                                              }                                                              else if ((quadrant[i1] > quadrant[i2]))                                                              {                                                                  goto HAMMER;                                                              }                                                              else {                                                                  goto END_HAMMER;                                                              }                                                          }                                                          else if ((block[i1 + 1] & 0xff) > (block[i2 + 1] & 0xff))                                                          {                                                              goto HAMMER;                                                          }                                                          else {                                                              goto END_HAMMER;                                                          }                                                        }                                                      goto END_HAMMER;                                                  } // while x > 0                                                  else {                                                      if ((block[i1] & 0xff) > (block[i2] & 0xff))                                                      {                                                          goto HAMMER;                                                      }                                                      else {                                                          goto END_HAMMER;                                                      }                                                  }                                              }                                              else if ((block[i1 + 5] & 0xff) > (block[i2 + 5] & 0xff))                                              {                                                  goto HAMMER;                                              }                                              else {                                                  goto END_HAMMER;                                              }                                          }                                          else if ((block[i1 + 4] & 0xff) > (block[i2 + 4] & 0xff))                                          {                                              goto HAMMER;                                          }                                          else {                                              goto END_HAMMER;                                          }                                      }                                      else if ((block[i1 + 3] & 0xff) > (block[i2 + 3] & 0xff))                                      {                                          goto HAMMER;                                      }                                      else {                                          goto END_HAMMER;                                      }                                  }                                  else if ((block[i1 + 2] & 0xff) > (block[i2 + 2] & 0xff))                                  {                                      goto HAMMER;                                  }                                  else {                                      goto END_HAMMER;                                  }                              }                              else if ((block[i1 + 1] & 0xff) > (block[i2 + 1] & 0xff))                              {                                  goto HAMMER;                              }                              else {                                  goto END_HAMMER;                              }                            } // HAMMER                            END_HAMMER:                          // end inline mainGTU                            fmap[j] = v;                      }                        if (firstAttemptShadow && (i <= hi)                          && (workDoneShadow > workLimitShadow))                      {                          goto END_HP;                      }                  }              }
Magic Number,Ionic.BZip2,BZip2Compressor,C:\repos\haf_DotNetZip.Semverd\src\BZip2\BZip2Compressor.cs,mainSimpleSort,The following statement contains a magic number: while (--hp >= 0)              {                  int h = increments[hp];                  int mj = lo + h - 1;                    for (int i = lo + h; i <= hi;)                  {                      // copy                      for (int k = 3; (i <= hi) && (--k >= 0); i++)                      {                          int v = fmap[i];                          int vd = v + d;                          int j = i;                            // for (int a;                          // (j > mj) && mainGtU((a = fmap[j - h]) + d' vd'                          // block' quadrant' lastShadow);                          // j -= h) {                          // fmap[j] = a;                          // }                          //                          // unrolled version:                            // start inline mainGTU                          bool onceRunned = false;                          int a = 0;                            HAMMER: while (true)                          {                              if (onceRunned)                              {                                  fmap[j] = a;                                  if ((j -= h) <= mj)                                  {                                      goto END_HAMMER;                                  }                              }                              else {                                  onceRunned = true;                              }                                a = fmap[j - h];                              int i1 = a + d;                              int i2 = vd;                                // following could be done in a loop' but                              // unrolled it for performance:                              if (block[i1 + 1] == block[i2 + 1])                              {                                  if (block[i1 + 2] == block[i2 + 2])                                  {                                      if (block[i1 + 3] == block[i2 + 3])                                      {                                          if (block[i1 + 4] == block[i2 + 4])                                          {                                              if (block[i1 + 5] == block[i2 + 5])                                              {                                                  if (block[(i1 += 6)] == block[(i2 += 6)])                                                  {                                                      int x = lastShadow;                                                      X: while (x > 0)                                                      {                                                          x -= 4;                                                            if (block[i1 + 1] == block[i2 + 1])                                                          {                                                              if (quadrant[i1] == quadrant[i2])                                                              {                                                                  if (block[i1 + 2] == block[i2 + 2])                                                                  {                                                                      if (quadrant[i1 + 1] == quadrant[i2 + 1])                                                                      {                                                                          if (block[i1 + 3] == block[i2 + 3])                                                                          {                                                                              if (quadrant[i1 + 2] == quadrant[i2 + 2])                                                                              {                                                                                  if (block[i1 + 4] == block[i2 + 4])                                                                                  {                                                                                      if (quadrant[i1 + 3] == quadrant[i2 + 3])                                                                                      {                                                                                          if ((i1 += 4) >= lastPlus1)                                                                                          {                                                                                              i1 -= lastPlus1;                                                                                          }                                                                                          if ((i2 += 4) >= lastPlus1)                                                                                          {                                                                                              i2 -= lastPlus1;                                                                                          }                                                                                          workDoneShadow++;                                                                                          goto X;                                                                                      }                                                                                      else if ((quadrant[i1 + 3] > quadrant[i2 + 3]))                                                                                      {                                                                                          goto HAMMER;                                                                                      }                                                                                      else {                                                                                          goto END_HAMMER;                                                                                      }                                                                                  }                                                                                  else if ((block[i1 + 4] & 0xff) > (block[i2 + 4] & 0xff))                                                                                  {                                                                                      goto HAMMER;                                                                                  }                                                                                  else {                                                                                      goto END_HAMMER;                                                                                  }                                                                              }                                                                              else if ((quadrant[i1 + 2] > quadrant[i2 + 2]))                                                                              {                                                                                  goto HAMMER;                                                                              }                                                                              else {                                                                                  goto END_HAMMER;                                                                              }                                                                          }                                                                          else if ((block[i1 + 3] & 0xff) > (block[i2 + 3] & 0xff))                                                                          {                                                                              goto HAMMER;                                                                          }                                                                          else {                                                                              goto END_HAMMER;                                                                          }                                                                      }                                                                      else if ((quadrant[i1 + 1] > quadrant[i2 + 1]))                                                                      {                                                                          goto HAMMER;                                                                      }                                                                      else {                                                                          goto END_HAMMER;                                                                      }                                                                  }                                                                  else if ((block[i1 + 2] & 0xff) > (block[i2 + 2] & 0xff))                                                                  {                                                                      goto HAMMER;                                                                  }                                                                  else {                                                                      goto END_HAMMER;                                                                  }                                                              }                                                              else if ((quadrant[i1] > quadrant[i2]))                                                              {                                                                  goto HAMMER;                                                              }                                                              else {                                                                  goto END_HAMMER;                                                              }                                                          }                                                          else if ((block[i1 + 1] & 0xff) > (block[i2 + 1] & 0xff))                                                          {                                                              goto HAMMER;                                                          }                                                          else {                                                              goto END_HAMMER;                                                          }                                                        }                                                      goto END_HAMMER;                                                  } // while x > 0                                                  else {                                                      if ((block[i1] & 0xff) > (block[i2] & 0xff))                                                      {                                                          goto HAMMER;                                                      }                                                      else {                                                          goto END_HAMMER;                                                      }                                                  }                                              }                                              else if ((block[i1 + 5] & 0xff) > (block[i2 + 5] & 0xff))                                              {                                                  goto HAMMER;                                              }                                              else {                                                  goto END_HAMMER;                                              }                                          }                                          else if ((block[i1 + 4] & 0xff) > (block[i2 + 4] & 0xff))                                          {                                              goto HAMMER;                                          }                                          else {                                              goto END_HAMMER;                                          }                                      }                                      else if ((block[i1 + 3] & 0xff) > (block[i2 + 3] & 0xff))                                      {                                          goto HAMMER;                                      }                                      else {                                          goto END_HAMMER;                                      }                                  }                                  else if ((block[i1 + 2] & 0xff) > (block[i2 + 2] & 0xff))                                  {                                      goto HAMMER;                                  }                                  else {                                      goto END_HAMMER;                                  }                              }                              else if ((block[i1 + 1] & 0xff) > (block[i2 + 1] & 0xff))                              {                                  goto HAMMER;                              }                              else {                                  goto END_HAMMER;                              }                            } // HAMMER                            END_HAMMER:                          // end inline mainGTU                            fmap[j] = v;                      }                        if (firstAttemptShadow && (i <= hi)                          && (workDoneShadow > workLimitShadow))                      {                          goto END_HP;                      }                  }              }
Magic Number,Ionic.BZip2,BZip2Compressor,C:\repos\haf_DotNetZip.Semverd\src\BZip2\BZip2Compressor.cs,mainSimpleSort,The following statement contains a magic number: while (--hp >= 0)              {                  int h = increments[hp];                  int mj = lo + h - 1;                    for (int i = lo + h; i <= hi;)                  {                      // copy                      for (int k = 3; (i <= hi) && (--k >= 0); i++)                      {                          int v = fmap[i];                          int vd = v + d;                          int j = i;                            // for (int a;                          // (j > mj) && mainGtU((a = fmap[j - h]) + d' vd'                          // block' quadrant' lastShadow);                          // j -= h) {                          // fmap[j] = a;                          // }                          //                          // unrolled version:                            // start inline mainGTU                          bool onceRunned = false;                          int a = 0;                            HAMMER: while (true)                          {                              if (onceRunned)                              {                                  fmap[j] = a;                                  if ((j -= h) <= mj)                                  {                                      goto END_HAMMER;                                  }                              }                              else {                                  onceRunned = true;                              }                                a = fmap[j - h];                              int i1 = a + d;                              int i2 = vd;                                // following could be done in a loop' but                              // unrolled it for performance:                              if (block[i1 + 1] == block[i2 + 1])                              {                                  if (block[i1 + 2] == block[i2 + 2])                                  {                                      if (block[i1 + 3] == block[i2 + 3])                                      {                                          if (block[i1 + 4] == block[i2 + 4])                                          {                                              if (block[i1 + 5] == block[i2 + 5])                                              {                                                  if (block[(i1 += 6)] == block[(i2 += 6)])                                                  {                                                      int x = lastShadow;                                                      X: while (x > 0)                                                      {                                                          x -= 4;                                                            if (block[i1 + 1] == block[i2 + 1])                                                          {                                                              if (quadrant[i1] == quadrant[i2])                                                              {                                                                  if (block[i1 + 2] == block[i2 + 2])                                                                  {                                                                      if (quadrant[i1 + 1] == quadrant[i2 + 1])                                                                      {                                                                          if (block[i1 + 3] == block[i2 + 3])                                                                          {                                                                              if (quadrant[i1 + 2] == quadrant[i2 + 2])                                                                              {                                                                                  if (block[i1 + 4] == block[i2 + 4])                                                                                  {                                                                                      if (quadrant[i1 + 3] == quadrant[i2 + 3])                                                                                      {                                                                                          if ((i1 += 4) >= lastPlus1)                                                                                          {                                                                                              i1 -= lastPlus1;                                                                                          }                                                                                          if ((i2 += 4) >= lastPlus1)                                                                                          {                                                                                              i2 -= lastPlus1;                                                                                          }                                                                                          workDoneShadow++;                                                                                          goto X;                                                                                      }                                                                                      else if ((quadrant[i1 + 3] > quadrant[i2 + 3]))                                                                                      {                                                                                          goto HAMMER;                                                                                      }                                                                                      else {                                                                                          goto END_HAMMER;                                                                                      }                                                                                  }                                                                                  else if ((block[i1 + 4] & 0xff) > (block[i2 + 4] & 0xff))                                                                                  {                                                                                      goto HAMMER;                                                                                  }                                                                                  else {                                                                                      goto END_HAMMER;                                                                                  }                                                                              }                                                                              else if ((quadrant[i1 + 2] > quadrant[i2 + 2]))                                                                              {                                                                                  goto HAMMER;                                                                              }                                                                              else {                                                                                  goto END_HAMMER;                                                                              }                                                                          }                                                                          else if ((block[i1 + 3] & 0xff) > (block[i2 + 3] & 0xff))                                                                          {                                                                              goto HAMMER;                                                                          }                                                                          else {                                                                              goto END_HAMMER;                                                                          }                                                                      }                                                                      else if ((quadrant[i1 + 1] > quadrant[i2 + 1]))                                                                      {                                                                          goto HAMMER;                                                                      }                                                                      else {                                                                          goto END_HAMMER;                                                                      }                                                                  }                                                                  else if ((block[i1 + 2] & 0xff) > (block[i2 + 2] & 0xff))                                                                  {                                                                      goto HAMMER;                                                                  }                                                                  else {                                                                      goto END_HAMMER;                                                                  }                                                              }                                                              else if ((quadrant[i1] > quadrant[i2]))                                                              {                                                                  goto HAMMER;                                                              }                                                              else {                                                                  goto END_HAMMER;                                                              }                                                          }                                                          else if ((block[i1 + 1] & 0xff) > (block[i2 + 1] & 0xff))                                                          {                                                              goto HAMMER;                                                          }                                                          else {                                                              goto END_HAMMER;                                                          }                                                        }                                                      goto END_HAMMER;                                                  } // while x > 0                                                  else {                                                      if ((block[i1] & 0xff) > (block[i2] & 0xff))                                                      {                                                          goto HAMMER;                                                      }                                                      else {                                                          goto END_HAMMER;                                                      }                                                  }                                              }                                              else if ((block[i1 + 5] & 0xff) > (block[i2 + 5] & 0xff))                                              {                                                  goto HAMMER;                                              }                                              else {                                                  goto END_HAMMER;                                              }                                          }                                          else if ((block[i1 + 4] & 0xff) > (block[i2 + 4] & 0xff))                                          {                                              goto HAMMER;                                          }                                          else {                                              goto END_HAMMER;                                          }                                      }                                      else if ((block[i1 + 3] & 0xff) > (block[i2 + 3] & 0xff))                                      {                                          goto HAMMER;                                      }                                      else {                                          goto END_HAMMER;                                      }                                  }                                  else if ((block[i1 + 2] & 0xff) > (block[i2 + 2] & 0xff))                                  {                                      goto HAMMER;                                  }                                  else {                                      goto END_HAMMER;                                  }                              }                              else if ((block[i1 + 1] & 0xff) > (block[i2 + 1] & 0xff))                              {                                  goto HAMMER;                              }                              else {                                  goto END_HAMMER;                              }                            } // HAMMER                            END_HAMMER:                          // end inline mainGTU                            fmap[j] = v;                      }                        if (firstAttemptShadow && (i <= hi)                          && (workDoneShadow > workLimitShadow))                      {                          goto END_HP;                      }                  }              }
Magic Number,Ionic.BZip2,BZip2Compressor,C:\repos\haf_DotNetZip.Semverd\src\BZip2\BZip2Compressor.cs,mainSimpleSort,The following statement contains a magic number: while (--hp >= 0)              {                  int h = increments[hp];                  int mj = lo + h - 1;                    for (int i = lo + h; i <= hi;)                  {                      // copy                      for (int k = 3; (i <= hi) && (--k >= 0); i++)                      {                          int v = fmap[i];                          int vd = v + d;                          int j = i;                            // for (int a;                          // (j > mj) && mainGtU((a = fmap[j - h]) + d' vd'                          // block' quadrant' lastShadow);                          // j -= h) {                          // fmap[j] = a;                          // }                          //                          // unrolled version:                            // start inline mainGTU                          bool onceRunned = false;                          int a = 0;                            HAMMER: while (true)                          {                              if (onceRunned)                              {                                  fmap[j] = a;                                  if ((j -= h) <= mj)                                  {                                      goto END_HAMMER;                                  }                              }                              else {                                  onceRunned = true;                              }                                a = fmap[j - h];                              int i1 = a + d;                              int i2 = vd;                                // following could be done in a loop' but                              // unrolled it for performance:                              if (block[i1 + 1] == block[i2 + 1])                              {                                  if (block[i1 + 2] == block[i2 + 2])                                  {                                      if (block[i1 + 3] == block[i2 + 3])                                      {                                          if (block[i1 + 4] == block[i2 + 4])                                          {                                              if (block[i1 + 5] == block[i2 + 5])                                              {                                                  if (block[(i1 += 6)] == block[(i2 += 6)])                                                  {                                                      int x = lastShadow;                                                      X: while (x > 0)                                                      {                                                          x -= 4;                                                            if (block[i1 + 1] == block[i2 + 1])                                                          {                                                              if (quadrant[i1] == quadrant[i2])                                                              {                                                                  if (block[i1 + 2] == block[i2 + 2])                                                                  {                                                                      if (quadrant[i1 + 1] == quadrant[i2 + 1])                                                                      {                                                                          if (block[i1 + 3] == block[i2 + 3])                                                                          {                                                                              if (quadrant[i1 + 2] == quadrant[i2 + 2])                                                                              {                                                                                  if (block[i1 + 4] == block[i2 + 4])                                                                                  {                                                                                      if (quadrant[i1 + 3] == quadrant[i2 + 3])                                                                                      {                                                                                          if ((i1 += 4) >= lastPlus1)                                                                                          {                                                                                              i1 -= lastPlus1;                                                                                          }                                                                                          if ((i2 += 4) >= lastPlus1)                                                                                          {                                                                                              i2 -= lastPlus1;                                                                                          }                                                                                          workDoneShadow++;                                                                                          goto X;                                                                                      }                                                                                      else if ((quadrant[i1 + 3] > quadrant[i2 + 3]))                                                                                      {                                                                                          goto HAMMER;                                                                                      }                                                                                      else {                                                                                          goto END_HAMMER;                                                                                      }                                                                                  }                                                                                  else if ((block[i1 + 4] & 0xff) > (block[i2 + 4] & 0xff))                                                                                  {                                                                                      goto HAMMER;                                                                                  }                                                                                  else {                                                                                      goto END_HAMMER;                                                                                  }                                                                              }                                                                              else if ((quadrant[i1 + 2] > quadrant[i2 + 2]))                                                                              {                                                                                  goto HAMMER;                                                                              }                                                                              else {                                                                                  goto END_HAMMER;                                                                              }                                                                          }                                                                          else if ((block[i1 + 3] & 0xff) > (block[i2 + 3] & 0xff))                                                                          {                                                                              goto HAMMER;                                                                          }                                                                          else {                                                                              goto END_HAMMER;                                                                          }                                                                      }                                                                      else if ((quadrant[i1 + 1] > quadrant[i2 + 1]))                                                                      {                                                                          goto HAMMER;                                                                      }                                                                      else {                                                                          goto END_HAMMER;                                                                      }                                                                  }                                                                  else if ((block[i1 + 2] & 0xff) > (block[i2 + 2] & 0xff))                                                                  {                                                                      goto HAMMER;                                                                  }                                                                  else {                                                                      goto END_HAMMER;                                                                  }                                                              }                                                              else if ((quadrant[i1] > quadrant[i2]))                                                              {                                                                  goto HAMMER;                                                              }                                                              else {                                                                  goto END_HAMMER;                                                              }                                                          }                                                          else if ((block[i1 + 1] & 0xff) > (block[i2 + 1] & 0xff))                                                          {                                                              goto HAMMER;                                                          }                                                          else {                                                              goto END_HAMMER;                                                          }                                                        }                                                      goto END_HAMMER;                                                  } // while x > 0                                                  else {                                                      if ((block[i1] & 0xff) > (block[i2] & 0xff))                                                      {                                                          goto HAMMER;                                                      }                                                      else {                                                          goto END_HAMMER;                                                      }                                                  }                                              }                                              else if ((block[i1 + 5] & 0xff) > (block[i2 + 5] & 0xff))                                              {                                                  goto HAMMER;                                              }                                              else {                                                  goto END_HAMMER;                                              }                                          }                                          else if ((block[i1 + 4] & 0xff) > (block[i2 + 4] & 0xff))                                          {                                              goto HAMMER;                                          }                                          else {                                              goto END_HAMMER;                                          }                                      }                                      else if ((block[i1 + 3] & 0xff) > (block[i2 + 3] & 0xff))                                      {                                          goto HAMMER;                                      }                                      else {                                          goto END_HAMMER;                                      }                                  }                                  else if ((block[i1 + 2] & 0xff) > (block[i2 + 2] & 0xff))                                  {                                      goto HAMMER;                                  }                                  else {                                      goto END_HAMMER;                                  }                              }                              else if ((block[i1 + 1] & 0xff) > (block[i2 + 1] & 0xff))                              {                                  goto HAMMER;                              }                              else {                                  goto END_HAMMER;                              }                            } // HAMMER                            END_HAMMER:                          // end inline mainGTU                            fmap[j] = v;                      }                        if (firstAttemptShadow && (i <= hi)                          && (workDoneShadow > workLimitShadow))                      {                          goto END_HP;                      }                  }              }
Magic Number,Ionic.BZip2,BZip2Compressor,C:\repos\haf_DotNetZip.Semverd\src\BZip2\BZip2Compressor.cs,mainSimpleSort,The following statement contains a magic number: while (--hp >= 0)              {                  int h = increments[hp];                  int mj = lo + h - 1;                    for (int i = lo + h; i <= hi;)                  {                      // copy                      for (int k = 3; (i <= hi) && (--k >= 0); i++)                      {                          int v = fmap[i];                          int vd = v + d;                          int j = i;                            // for (int a;                          // (j > mj) && mainGtU((a = fmap[j - h]) + d' vd'                          // block' quadrant' lastShadow);                          // j -= h) {                          // fmap[j] = a;                          // }                          //                          // unrolled version:                            // start inline mainGTU                          bool onceRunned = false;                          int a = 0;                            HAMMER: while (true)                          {                              if (onceRunned)                              {                                  fmap[j] = a;                                  if ((j -= h) <= mj)                                  {                                      goto END_HAMMER;                                  }                              }                              else {                                  onceRunned = true;                              }                                a = fmap[j - h];                              int i1 = a + d;                              int i2 = vd;                                // following could be done in a loop' but                              // unrolled it for performance:                              if (block[i1 + 1] == block[i2 + 1])                              {                                  if (block[i1 + 2] == block[i2 + 2])                                  {                                      if (block[i1 + 3] == block[i2 + 3])                                      {                                          if (block[i1 + 4] == block[i2 + 4])                                          {                                              if (block[i1 + 5] == block[i2 + 5])                                              {                                                  if (block[(i1 += 6)] == block[(i2 += 6)])                                                  {                                                      int x = lastShadow;                                                      X: while (x > 0)                                                      {                                                          x -= 4;                                                            if (block[i1 + 1] == block[i2 + 1])                                                          {                                                              if (quadrant[i1] == quadrant[i2])                                                              {                                                                  if (block[i1 + 2] == block[i2 + 2])                                                                  {                                                                      if (quadrant[i1 + 1] == quadrant[i2 + 1])                                                                      {                                                                          if (block[i1 + 3] == block[i2 + 3])                                                                          {                                                                              if (quadrant[i1 + 2] == quadrant[i2 + 2])                                                                              {                                                                                  if (block[i1 + 4] == block[i2 + 4])                                                                                  {                                                                                      if (quadrant[i1 + 3] == quadrant[i2 + 3])                                                                                      {                                                                                          if ((i1 += 4) >= lastPlus1)                                                                                          {                                                                                              i1 -= lastPlus1;                                                                                          }                                                                                          if ((i2 += 4) >= lastPlus1)                                                                                          {                                                                                              i2 -= lastPlus1;                                                                                          }                                                                                          workDoneShadow++;                                                                                          goto X;                                                                                      }                                                                                      else if ((quadrant[i1 + 3] > quadrant[i2 + 3]))                                                                                      {                                                                                          goto HAMMER;                                                                                      }                                                                                      else {                                                                                          goto END_HAMMER;                                                                                      }                                                                                  }                                                                                  else if ((block[i1 + 4] & 0xff) > (block[i2 + 4] & 0xff))                                                                                  {                                                                                      goto HAMMER;                                                                                  }                                                                                  else {                                                                                      goto END_HAMMER;                                                                                  }                                                                              }                                                                              else if ((quadrant[i1 + 2] > quadrant[i2 + 2]))                                                                              {                                                                                  goto HAMMER;                                                                              }                                                                              else {                                                                                  goto END_HAMMER;                                                                              }                                                                          }                                                                          else if ((block[i1 + 3] & 0xff) > (block[i2 + 3] & 0xff))                                                                          {                                                                              goto HAMMER;                                                                          }                                                                          else {                                                                              goto END_HAMMER;                                                                          }                                                                      }                                                                      else if ((quadrant[i1 + 1] > quadrant[i2 + 1]))                                                                      {                                                                          goto HAMMER;                                                                      }                                                                      else {                                                                          goto END_HAMMER;                                                                      }                                                                  }                                                                  else if ((block[i1 + 2] & 0xff) > (block[i2 + 2] & 0xff))                                                                  {                                                                      goto HAMMER;                                                                  }                                                                  else {                                                                      goto END_HAMMER;                                                                  }                                                              }                                                              else if ((quadrant[i1] > quadrant[i2]))                                                              {                                                                  goto HAMMER;                                                              }                                                              else {                                                                  goto END_HAMMER;                                                              }                                                          }                                                          else if ((block[i1 + 1] & 0xff) > (block[i2 + 1] & 0xff))                                                          {                                                              goto HAMMER;                                                          }                                                          else {                                                              goto END_HAMMER;                                                          }                                                        }                                                      goto END_HAMMER;                                                  } // while x > 0                                                  else {                                                      if ((block[i1] & 0xff) > (block[i2] & 0xff))                                                      {                                                          goto HAMMER;                                                      }                                                      else {                                                          goto END_HAMMER;                                                      }                                                  }                                              }                                              else if ((block[i1 + 5] & 0xff) > (block[i2 + 5] & 0xff))                                              {                                                  goto HAMMER;                                              }                                              else {                                                  goto END_HAMMER;                                              }                                          }                                          else if ((block[i1 + 4] & 0xff) > (block[i2 + 4] & 0xff))                                          {                                              goto HAMMER;                                          }                                          else {                                              goto END_HAMMER;                                          }                                      }                                      else if ((block[i1 + 3] & 0xff) > (block[i2 + 3] & 0xff))                                      {                                          goto HAMMER;                                      }                                      else {                                          goto END_HAMMER;                                      }                                  }                                  else if ((block[i1 + 2] & 0xff) > (block[i2 + 2] & 0xff))                                  {                                      goto HAMMER;                                  }                                  else {                                      goto END_HAMMER;                                  }                              }                              else if ((block[i1 + 1] & 0xff) > (block[i2 + 1] & 0xff))                              {                                  goto HAMMER;                              }                              else {                                  goto END_HAMMER;                              }                            } // HAMMER                            END_HAMMER:                          // end inline mainGTU                            fmap[j] = v;                      }                        if (firstAttemptShadow && (i <= hi)                          && (workDoneShadow > workLimitShadow))                      {                          goto END_HP;                      }                  }              }
Magic Number,Ionic.BZip2,BZip2Compressor,C:\repos\haf_DotNetZip.Semverd\src\BZip2\BZip2Compressor.cs,mainSimpleSort,The following statement contains a magic number: while (--hp >= 0)              {                  int h = increments[hp];                  int mj = lo + h - 1;                    for (int i = lo + h; i <= hi;)                  {                      // copy                      for (int k = 3; (i <= hi) && (--k >= 0); i++)                      {                          int v = fmap[i];                          int vd = v + d;                          int j = i;                            // for (int a;                          // (j > mj) && mainGtU((a = fmap[j - h]) + d' vd'                          // block' quadrant' lastShadow);                          // j -= h) {                          // fmap[j] = a;                          // }                          //                          // unrolled version:                            // start inline mainGTU                          bool onceRunned = false;                          int a = 0;                            HAMMER: while (true)                          {                              if (onceRunned)                              {                                  fmap[j] = a;                                  if ((j -= h) <= mj)                                  {                                      goto END_HAMMER;                                  }                              }                              else {                                  onceRunned = true;                              }                                a = fmap[j - h];                              int i1 = a + d;                              int i2 = vd;                                // following could be done in a loop' but                              // unrolled it for performance:                              if (block[i1 + 1] == block[i2 + 1])                              {                                  if (block[i1 + 2] == block[i2 + 2])                                  {                                      if (block[i1 + 3] == block[i2 + 3])                                      {                                          if (block[i1 + 4] == block[i2 + 4])                                          {                                              if (block[i1 + 5] == block[i2 + 5])                                              {                                                  if (block[(i1 += 6)] == block[(i2 += 6)])                                                  {                                                      int x = lastShadow;                                                      X: while (x > 0)                                                      {                                                          x -= 4;                                                            if (block[i1 + 1] == block[i2 + 1])                                                          {                                                              if (quadrant[i1] == quadrant[i2])                                                              {                                                                  if (block[i1 + 2] == block[i2 + 2])                                                                  {                                                                      if (quadrant[i1 + 1] == quadrant[i2 + 1])                                                                      {                                                                          if (block[i1 + 3] == block[i2 + 3])                                                                          {                                                                              if (quadrant[i1 + 2] == quadrant[i2 + 2])                                                                              {                                                                                  if (block[i1 + 4] == block[i2 + 4])                                                                                  {                                                                                      if (quadrant[i1 + 3] == quadrant[i2 + 3])                                                                                      {                                                                                          if ((i1 += 4) >= lastPlus1)                                                                                          {                                                                                              i1 -= lastPlus1;                                                                                          }                                                                                          if ((i2 += 4) >= lastPlus1)                                                                                          {                                                                                              i2 -= lastPlus1;                                                                                          }                                                                                          workDoneShadow++;                                                                                          goto X;                                                                                      }                                                                                      else if ((quadrant[i1 + 3] > quadrant[i2 + 3]))                                                                                      {                                                                                          goto HAMMER;                                                                                      }                                                                                      else {                                                                                          goto END_HAMMER;                                                                                      }                                                                                  }                                                                                  else if ((block[i1 + 4] & 0xff) > (block[i2 + 4] & 0xff))                                                                                  {                                                                                      goto HAMMER;                                                                                  }                                                                                  else {                                                                                      goto END_HAMMER;                                                                                  }                                                                              }                                                                              else if ((quadrant[i1 + 2] > quadrant[i2 + 2]))                                                                              {                                                                                  goto HAMMER;                                                                              }                                                                              else {                                                                                  goto END_HAMMER;                                                                              }                                                                          }                                                                          else if ((block[i1 + 3] & 0xff) > (block[i2 + 3] & 0xff))                                                                          {                                                                              goto HAMMER;                                                                          }                                                                          else {                                                                              goto END_HAMMER;                                                                          }                                                                      }                                                                      else if ((quadrant[i1 + 1] > quadrant[i2 + 1]))                                                                      {                                                                          goto HAMMER;                                                                      }                                                                      else {                                                                          goto END_HAMMER;                                                                      }                                                                  }                                                                  else if ((block[i1 + 2] & 0xff) > (block[i2 + 2] & 0xff))                                                                  {                                                                      goto HAMMER;                                                                  }                                                                  else {                                                                      goto END_HAMMER;                                                                  }                                                              }                                                              else if ((quadrant[i1] > quadrant[i2]))                                                              {                                                                  goto HAMMER;                                                              }                                                              else {                                                                  goto END_HAMMER;                                                              }                                                          }                                                          else if ((block[i1 + 1] & 0xff) > (block[i2 + 1] & 0xff))                                                          {                                                              goto HAMMER;                                                          }                                                          else {                                                              goto END_HAMMER;                                                          }                                                        }                                                      goto END_HAMMER;                                                  } // while x > 0                                                  else {                                                      if ((block[i1] & 0xff) > (block[i2] & 0xff))                                                      {                                                          goto HAMMER;                                                      }                                                      else {                                                          goto END_HAMMER;                                                      }                                                  }                                              }                                              else if ((block[i1 + 5] & 0xff) > (block[i2 + 5] & 0xff))                                              {                                                  goto HAMMER;                                              }                                              else {                                                  goto END_HAMMER;                                              }                                          }                                          else if ((block[i1 + 4] & 0xff) > (block[i2 + 4] & 0xff))                                          {                                              goto HAMMER;                                          }                                          else {                                              goto END_HAMMER;                                          }                                      }                                      else if ((block[i1 + 3] & 0xff) > (block[i2 + 3] & 0xff))                                      {                                          goto HAMMER;                                      }                                      else {                                          goto END_HAMMER;                                      }                                  }                                  else if ((block[i1 + 2] & 0xff) > (block[i2 + 2] & 0xff))                                  {                                      goto HAMMER;                                  }                                  else {                                      goto END_HAMMER;                                  }                              }                              else if ((block[i1 + 1] & 0xff) > (block[i2 + 1] & 0xff))                              {                                  goto HAMMER;                              }                              else {                                  goto END_HAMMER;                              }                            } // HAMMER                            END_HAMMER:                          // end inline mainGTU                            fmap[j] = v;                      }                        if (firstAttemptShadow && (i <= hi)                          && (workDoneShadow > workLimitShadow))                      {                          goto END_HP;                      }                  }              }
Magic Number,Ionic.BZip2,BZip2Compressor,C:\repos\haf_DotNetZip.Semverd\src\BZip2\BZip2Compressor.cs,mainSimpleSort,The following statement contains a magic number: while (--hp >= 0)              {                  int h = increments[hp];                  int mj = lo + h - 1;                    for (int i = lo + h; i <= hi;)                  {                      // copy                      for (int k = 3; (i <= hi) && (--k >= 0); i++)                      {                          int v = fmap[i];                          int vd = v + d;                          int j = i;                            // for (int a;                          // (j > mj) && mainGtU((a = fmap[j - h]) + d' vd'                          // block' quadrant' lastShadow);                          // j -= h) {                          // fmap[j] = a;                          // }                          //                          // unrolled version:                            // start inline mainGTU                          bool onceRunned = false;                          int a = 0;                            HAMMER: while (true)                          {                              if (onceRunned)                              {                                  fmap[j] = a;                                  if ((j -= h) <= mj)                                  {                                      goto END_HAMMER;                                  }                              }                              else {                                  onceRunned = true;                              }                                a = fmap[j - h];                              int i1 = a + d;                              int i2 = vd;                                // following could be done in a loop' but                              // unrolled it for performance:                              if (block[i1 + 1] == block[i2 + 1])                              {                                  if (block[i1 + 2] == block[i2 + 2])                                  {                                      if (block[i1 + 3] == block[i2 + 3])                                      {                                          if (block[i1 + 4] == block[i2 + 4])                                          {                                              if (block[i1 + 5] == block[i2 + 5])                                              {                                                  if (block[(i1 += 6)] == block[(i2 += 6)])                                                  {                                                      int x = lastShadow;                                                      X: while (x > 0)                                                      {                                                          x -= 4;                                                            if (block[i1 + 1] == block[i2 + 1])                                                          {                                                              if (quadrant[i1] == quadrant[i2])                                                              {                                                                  if (block[i1 + 2] == block[i2 + 2])                                                                  {                                                                      if (quadrant[i1 + 1] == quadrant[i2 + 1])                                                                      {                                                                          if (block[i1 + 3] == block[i2 + 3])                                                                          {                                                                              if (quadrant[i1 + 2] == quadrant[i2 + 2])                                                                              {                                                                                  if (block[i1 + 4] == block[i2 + 4])                                                                                  {                                                                                      if (quadrant[i1 + 3] == quadrant[i2 + 3])                                                                                      {                                                                                          if ((i1 += 4) >= lastPlus1)                                                                                          {                                                                                              i1 -= lastPlus1;                                                                                          }                                                                                          if ((i2 += 4) >= lastPlus1)                                                                                          {                                                                                              i2 -= lastPlus1;                                                                                          }                                                                                          workDoneShadow++;                                                                                          goto X;                                                                                      }                                                                                      else if ((quadrant[i1 + 3] > quadrant[i2 + 3]))                                                                                      {                                                                                          goto HAMMER;                                                                                      }                                                                                      else {                                                                                          goto END_HAMMER;                                                                                      }                                                                                  }                                                                                  else if ((block[i1 + 4] & 0xff) > (block[i2 + 4] & 0xff))                                                                                  {                                                                                      goto HAMMER;                                                                                  }                                                                                  else {                                                                                      goto END_HAMMER;                                                                                  }                                                                              }                                                                              else if ((quadrant[i1 + 2] > quadrant[i2 + 2]))                                                                              {                                                                                  goto HAMMER;                                                                              }                                                                              else {                                                                                  goto END_HAMMER;                                                                              }                                                                          }                                                                          else if ((block[i1 + 3] & 0xff) > (block[i2 + 3] & 0xff))                                                                          {                                                                              goto HAMMER;                                                                          }                                                                          else {                                                                              goto END_HAMMER;                                                                          }                                                                      }                                                                      else if ((quadrant[i1 + 1] > quadrant[i2 + 1]))                                                                      {                                                                          goto HAMMER;                                                                      }                                                                      else {                                                                          goto END_HAMMER;                                                                      }                                                                  }                                                                  else if ((block[i1 + 2] & 0xff) > (block[i2 + 2] & 0xff))                                                                  {                                                                      goto HAMMER;                                                                  }                                                                  else {                                                                      goto END_HAMMER;                                                                  }                                                              }                                                              else if ((quadrant[i1] > quadrant[i2]))                                                              {                                                                  goto HAMMER;                                                              }                                                              else {                                                                  goto END_HAMMER;                                                              }                                                          }                                                          else if ((block[i1 + 1] & 0xff) > (block[i2 + 1] & 0xff))                                                          {                                                              goto HAMMER;                                                          }                                                          else {                                                              goto END_HAMMER;                                                          }                                                        }                                                      goto END_HAMMER;                                                  } // while x > 0                                                  else {                                                      if ((block[i1] & 0xff) > (block[i2] & 0xff))                                                      {                                                          goto HAMMER;                                                      }                                                      else {                                                          goto END_HAMMER;                                                      }                                                  }                                              }                                              else if ((block[i1 + 5] & 0xff) > (block[i2 + 5] & 0xff))                                              {                                                  goto HAMMER;                                              }                                              else {                                                  goto END_HAMMER;                                              }                                          }                                          else if ((block[i1 + 4] & 0xff) > (block[i2 + 4] & 0xff))                                          {                                              goto HAMMER;                                          }                                          else {                                              goto END_HAMMER;                                          }                                      }                                      else if ((block[i1 + 3] & 0xff) > (block[i2 + 3] & 0xff))                                      {                                          goto HAMMER;                                      }                                      else {                                          goto END_HAMMER;                                      }                                  }                                  else if ((block[i1 + 2] & 0xff) > (block[i2 + 2] & 0xff))                                  {                                      goto HAMMER;                                  }                                  else {                                      goto END_HAMMER;                                  }                              }                              else if ((block[i1 + 1] & 0xff) > (block[i2 + 1] & 0xff))                              {                                  goto HAMMER;                              }                              else {                                  goto END_HAMMER;                              }                            } // HAMMER                            END_HAMMER:                          // end inline mainGTU                            fmap[j] = v;                      }                        if (firstAttemptShadow && (i <= hi)                          && (workDoneShadow > workLimitShadow))                      {                          goto END_HP;                      }                  }              }
Magic Number,Ionic.BZip2,BZip2Compressor,C:\repos\haf_DotNetZip.Semverd\src\BZip2\BZip2Compressor.cs,generateMTFValues,The following statement contains a magic number: for (int i = 0; i < 256; i++)              {                  if (inUse[i])                  {                      unseqToSeq[i] = (byte) nInUseShadow;                      nInUseShadow++;                  }              }
Magic Number,Ionic.BZip2,BZip2Compressor,C:\repos\haf_DotNetZip.Semverd\src\BZip2\BZip2Compressor.cs,generateMTFValues,The following statement contains a magic number: for (int i = 0; i <= lastShadow; i++)              {                  byte ll_i = unseqToSeq[block[fmap[i]] & 0xff];                  byte tmp = yy[0];                  int j = 0;                    while (ll_i != tmp)                  {                      j++;                      byte tmp2 = tmp;                      tmp = yy[j];                      yy[j] = tmp2;                  }                  yy[0] = tmp;                    if (j == 0)                  {                      zPend++;                  }                  else                  {                      if (zPend > 0)                      {                          zPend--;                          while (true)                          {                              if ((zPend & 1) == 0)                              {                                  sfmap[wr] = BZip2.RUNA;                                  wr++;                                  mtfFreq[BZip2.RUNA]++;                              }                              else                              {                                  sfmap[wr] = BZip2.RUNB;                                  wr++;                                  mtfFreq[BZip2.RUNB]++;                              }                                if (zPend >= 2)                              {                                  zPend = (zPend - 2) >> 1;                              }                              else                              {                                  break;                              }                          }                          zPend = 0;                      }                      sfmap[wr] = (char) (j + 1);                      wr++;                      mtfFreq[j + 1]++;                  }              }
Magic Number,Ionic.BZip2,BZip2Compressor,C:\repos\haf_DotNetZip.Semverd\src\BZip2\BZip2Compressor.cs,generateMTFValues,The following statement contains a magic number: for (int i = 0; i <= lastShadow; i++)              {                  byte ll_i = unseqToSeq[block[fmap[i]] & 0xff];                  byte tmp = yy[0];                  int j = 0;                    while (ll_i != tmp)                  {                      j++;                      byte tmp2 = tmp;                      tmp = yy[j];                      yy[j] = tmp2;                  }                  yy[0] = tmp;                    if (j == 0)                  {                      zPend++;                  }                  else                  {                      if (zPend > 0)                      {                          zPend--;                          while (true)                          {                              if ((zPend & 1) == 0)                              {                                  sfmap[wr] = BZip2.RUNA;                                  wr++;                                  mtfFreq[BZip2.RUNA]++;                              }                              else                              {                                  sfmap[wr] = BZip2.RUNB;                                  wr++;                                  mtfFreq[BZip2.RUNB]++;                              }                                if (zPend >= 2)                              {                                  zPend = (zPend - 2) >> 1;                              }                              else                              {                                  break;                              }                          }                          zPend = 0;                      }                      sfmap[wr] = (char) (j + 1);                      wr++;                      mtfFreq[j + 1]++;                  }              }
Magic Number,Ionic.BZip2,BZip2Compressor,C:\repos\haf_DotNetZip.Semverd\src\BZip2\BZip2Compressor.cs,generateMTFValues,The following statement contains a magic number: if (zPend > 0)              {                  zPend--;                  while (true)                  {                      if ((zPend & 1) == 0)                      {                          sfmap[wr] = BZip2.RUNA;                          wr++;                          mtfFreq[BZip2.RUNA]++;                      }                      else                      {                          sfmap[wr] = BZip2.RUNB;                          wr++;                          mtfFreq[BZip2.RUNB]++;                      }                        if (zPend >= 2)                      {                          zPend = (zPend - 2) >> 1;                      }                      else                      {                          break;                      }                  }              }
Magic Number,Ionic.BZip2,BZip2Compressor,C:\repos\haf_DotNetZip.Semverd\src\BZip2\BZip2Compressor.cs,generateMTFValues,The following statement contains a magic number: if (zPend > 0)              {                  zPend--;                  while (true)                  {                      if ((zPend & 1) == 0)                      {                          sfmap[wr] = BZip2.RUNA;                          wr++;                          mtfFreq[BZip2.RUNA]++;                      }                      else                      {                          sfmap[wr] = BZip2.RUNB;                          wr++;                          mtfFreq[BZip2.RUNB]++;                      }                        if (zPend >= 2)                      {                          zPend = (zPend - 2) >> 1;                      }                      else                      {                          break;                      }                  }              }
Magic Number,Ionic.BZip2,BZip2Compressor,C:\repos\haf_DotNetZip.Semverd\src\BZip2\BZip2Compressor.cs,sendMTFValues,The following statement contains a magic number: int alphaSize = this.nInUse + 2;
Magic Number,Ionic.BZip2,BZip2Compressor,C:\repos\haf_DotNetZip.Semverd\src\BZip2\BZip2Compressor.cs,sendMTFValues,The following statement contains a magic number: int nGroups = (this.nMTF < 200) ? 2 : (this.nMTF < 600) ? 3                  : (this.nMTF < 1200) ? 4 : (this.nMTF < 2400) ? 5 : 6;
Magic Number,Ionic.BZip2,BZip2Compressor,C:\repos\haf_DotNetZip.Semverd\src\BZip2\BZip2Compressor.cs,sendMTFValues,The following statement contains a magic number: int nGroups = (this.nMTF < 200) ? 2 : (this.nMTF < 600) ? 3                  : (this.nMTF < 1200) ? 4 : (this.nMTF < 2400) ? 5 : 6;
Magic Number,Ionic.BZip2,BZip2Compressor,C:\repos\haf_DotNetZip.Semverd\src\BZip2\BZip2Compressor.cs,sendMTFValues,The following statement contains a magic number: int nGroups = (this.nMTF < 200) ? 2 : (this.nMTF < 600) ? 3                  : (this.nMTF < 1200) ? 4 : (this.nMTF < 2400) ? 5 : 6;
Magic Number,Ionic.BZip2,BZip2Compressor,C:\repos\haf_DotNetZip.Semverd\src\BZip2\BZip2Compressor.cs,sendMTFValues,The following statement contains a magic number: int nGroups = (this.nMTF < 200) ? 2 : (this.nMTF < 600) ? 3                  : (this.nMTF < 1200) ? 4 : (this.nMTF < 2400) ? 5 : 6;
Magic Number,Ionic.BZip2,BZip2Compressor,C:\repos\haf_DotNetZip.Semverd\src\BZip2\BZip2Compressor.cs,sendMTFValues,The following statement contains a magic number: int nGroups = (this.nMTF < 200) ? 2 : (this.nMTF < 600) ? 3                  : (this.nMTF < 1200) ? 4 : (this.nMTF < 2400) ? 5 : 6;
Magic Number,Ionic.BZip2,BZip2Compressor,C:\repos\haf_DotNetZip.Semverd\src\BZip2\BZip2Compressor.cs,sendMTFValues,The following statement contains a magic number: int nGroups = (this.nMTF < 200) ? 2 : (this.nMTF < 600) ? 3                  : (this.nMTF < 1200) ? 4 : (this.nMTF < 2400) ? 5 : 6;
Magic Number,Ionic.BZip2,BZip2Compressor,C:\repos\haf_DotNetZip.Semverd\src\BZip2\BZip2Compressor.cs,sendMTFValues,The following statement contains a magic number: int nGroups = (this.nMTF < 200) ? 2 : (this.nMTF < 600) ? 3                  : (this.nMTF < 1200) ? 4 : (this.nMTF < 2400) ? 5 : 6;
Magic Number,Ionic.BZip2,BZip2Compressor,C:\repos\haf_DotNetZip.Semverd\src\BZip2\BZip2Compressor.cs,sendMTFValues,The following statement contains a magic number: int nGroups = (this.nMTF < 200) ? 2 : (this.nMTF < 600) ? 3                  : (this.nMTF < 1200) ? 4 : (this.nMTF < 2400) ? 5 : 6;
Magic Number,Ionic.BZip2,BZip2Compressor,C:\repos\haf_DotNetZip.Semverd\src\BZip2\BZip2Compressor.cs,sendMTFValues,The following statement contains a magic number: int nGroups = (this.nMTF < 200) ? 2 : (this.nMTF < 600) ? 3                  : (this.nMTF < 1200) ? 4 : (this.nMTF < 2400) ? 5 : 6;
Magic Number,Ionic.BZip2,BZip2Compressor,C:\repos\haf_DotNetZip.Semverd\src\BZip2\BZip2Compressor.cs,hbMakeCodeLengths,The following statement contains a magic number: for (int i = alphaSize; --i >= 0;)              {                  weight[i + 1] = (freq[i] == 0 ? 1 : freq[i]) << 8;              }
Magic Number,Ionic.BZip2,BZip2Compressor,C:\repos\haf_DotNetZip.Semverd\src\BZip2\BZip2Compressor.cs,hbMakeCodeLengths,The following statement contains a magic number: for (bool tooLong = true; tooLong;)              {                  tooLong = false;                    int nNodes = alphaSize;                  int nHeap = 0;                  heap[0] = 0;                  weight[0] = 0;                  parent[0] = -2;                    for (int i = 1; i <= alphaSize; i++)                  {                      parent[i] = -1;                      nHeap++;                      heap[nHeap] = i;                        int zz = nHeap;                      int tmp = heap[zz];                      while (weight[tmp] < weight[heap[zz >> 1]])                      {                          heap[zz] = heap[zz >> 1];                          zz >>= 1;                      }                      heap[zz] = tmp;                  }                    while (nHeap > 1)                  {                      int n1 = heap[1];                      heap[1] = heap[nHeap];                      nHeap--;                        int yy = 0;                      int zz = 1;                      int tmp = heap[1];                        while (true)                      {                          yy = zz << 1;                            if (yy > nHeap)                          {                              break;                          }                            if ((yy < nHeap)                              && (weight[heap[yy + 1]] < weight[heap[yy]]))                          {                              yy++;                          }                            if (weight[tmp] < weight[heap[yy]])                          {                              break;                          }                            heap[zz] = heap[yy];                          zz = yy;                      }                        heap[zz] = tmp;                        int n2 = heap[1];                      heap[1] = heap[nHeap];                      nHeap--;                        yy = 0;                      zz = 1;                      tmp = heap[1];                        while (true)                      {                          yy = zz << 1;                            if (yy > nHeap)                          {                              break;                          }                            if ((yy < nHeap)                              && (weight[heap[yy + 1]] < weight[heap[yy]]))                          {                              yy++;                          }                            if (weight[tmp] < weight[heap[yy]])                          {                              break;                          }                            heap[zz] = heap[yy];                          zz = yy;                      }                        heap[zz] = tmp;                      nNodes++;                      parent[n1] = parent[n2] = nNodes;                        int weight_n1 = weight[n1];                      int weight_n2 = weight[n2];                      weight[nNodes] = (int) (((uint)weight_n1 & 0xffffff00U)                                              + ((uint)weight_n2 & 0xffffff00U))                          | (1 + (((weight_n1 & 0x000000ff)                                   > (weight_n2 & 0x000000ff))                                  ? (weight_n1 & 0x000000ff)                                  : (weight_n2 & 0x000000ff)));                        parent[nNodes] = -1;                      nHeap++;                      heap[nHeap] = nNodes;                        tmp = 0;                      zz = nHeap;                      tmp = heap[zz];                      int weight_tmp = weight[tmp];                      while (weight_tmp < weight[heap[zz >> 1]])                      {                          heap[zz] = heap[zz >> 1];                          zz >>= 1;                      }                      heap[zz] = tmp;                    }                    for (int i = 1; i <= alphaSize; i++)                  {                      int j = 0;                      int k = i;                        for (int parent_k; (parent_k = parent[k]) >= 0;)                      {                          k = parent_k;                          j++;                      }                        len[i - 1] = (byte) j;                      if (j > maxLen)                      {                          tooLong = true;                      }                  }                    if (tooLong)                  {                      for (int i = 1; i < alphaSize; i++)                      {                          int j = weight[i] >> 8;                          j = 1 + (j >> 1);                          weight[i] = j << 8;                      }                  }              }
Magic Number,Ionic.BZip2,BZip2Compressor,C:\repos\haf_DotNetZip.Semverd\src\BZip2\BZip2Compressor.cs,hbMakeCodeLengths,The following statement contains a magic number: for (bool tooLong = true; tooLong;)              {                  tooLong = false;                    int nNodes = alphaSize;                  int nHeap = 0;                  heap[0] = 0;                  weight[0] = 0;                  parent[0] = -2;                    for (int i = 1; i <= alphaSize; i++)                  {                      parent[i] = -1;                      nHeap++;                      heap[nHeap] = i;                        int zz = nHeap;                      int tmp = heap[zz];                      while (weight[tmp] < weight[heap[zz >> 1]])                      {                          heap[zz] = heap[zz >> 1];                          zz >>= 1;                      }                      heap[zz] = tmp;                  }                    while (nHeap > 1)                  {                      int n1 = heap[1];                      heap[1] = heap[nHeap];                      nHeap--;                        int yy = 0;                      int zz = 1;                      int tmp = heap[1];                        while (true)                      {                          yy = zz << 1;                            if (yy > nHeap)                          {                              break;                          }                            if ((yy < nHeap)                              && (weight[heap[yy + 1]] < weight[heap[yy]]))                          {                              yy++;                          }                            if (weight[tmp] < weight[heap[yy]])                          {                              break;                          }                            heap[zz] = heap[yy];                          zz = yy;                      }                        heap[zz] = tmp;                        int n2 = heap[1];                      heap[1] = heap[nHeap];                      nHeap--;                        yy = 0;                      zz = 1;                      tmp = heap[1];                        while (true)                      {                          yy = zz << 1;                            if (yy > nHeap)                          {                              break;                          }                            if ((yy < nHeap)                              && (weight[heap[yy + 1]] < weight[heap[yy]]))                          {                              yy++;                          }                            if (weight[tmp] < weight[heap[yy]])                          {                              break;                          }                            heap[zz] = heap[yy];                          zz = yy;                      }                        heap[zz] = tmp;                      nNodes++;                      parent[n1] = parent[n2] = nNodes;                        int weight_n1 = weight[n1];                      int weight_n2 = weight[n2];                      weight[nNodes] = (int) (((uint)weight_n1 & 0xffffff00U)                                              + ((uint)weight_n2 & 0xffffff00U))                          | (1 + (((weight_n1 & 0x000000ff)                                   > (weight_n2 & 0x000000ff))                                  ? (weight_n1 & 0x000000ff)                                  : (weight_n2 & 0x000000ff)));                        parent[nNodes] = -1;                      nHeap++;                      heap[nHeap] = nNodes;                        tmp = 0;                      zz = nHeap;                      tmp = heap[zz];                      int weight_tmp = weight[tmp];                      while (weight_tmp < weight[heap[zz >> 1]])                      {                          heap[zz] = heap[zz >> 1];                          zz >>= 1;                      }                      heap[zz] = tmp;                    }                    for (int i = 1; i <= alphaSize; i++)                  {                      int j = 0;                      int k = i;                        for (int parent_k; (parent_k = parent[k]) >= 0;)                      {                          k = parent_k;                          j++;                      }                        len[i - 1] = (byte) j;                      if (j > maxLen)                      {                          tooLong = true;                      }                  }                    if (tooLong)                  {                      for (int i = 1; i < alphaSize; i++)                      {                          int j = weight[i] >> 8;                          j = 1 + (j >> 1);                          weight[i] = j << 8;                      }                  }              }
Magic Number,Ionic.BZip2,BZip2Compressor,C:\repos\haf_DotNetZip.Semverd\src\BZip2\BZip2Compressor.cs,hbMakeCodeLengths,The following statement contains a magic number: for (bool tooLong = true; tooLong;)              {                  tooLong = false;                    int nNodes = alphaSize;                  int nHeap = 0;                  heap[0] = 0;                  weight[0] = 0;                  parent[0] = -2;                    for (int i = 1; i <= alphaSize; i++)                  {                      parent[i] = -1;                      nHeap++;                      heap[nHeap] = i;                        int zz = nHeap;                      int tmp = heap[zz];                      while (weight[tmp] < weight[heap[zz >> 1]])                      {                          heap[zz] = heap[zz >> 1];                          zz >>= 1;                      }                      heap[zz] = tmp;                  }                    while (nHeap > 1)                  {                      int n1 = heap[1];                      heap[1] = heap[nHeap];                      nHeap--;                        int yy = 0;                      int zz = 1;                      int tmp = heap[1];                        while (true)                      {                          yy = zz << 1;                            if (yy > nHeap)                          {                              break;                          }                            if ((yy < nHeap)                              && (weight[heap[yy + 1]] < weight[heap[yy]]))                          {                              yy++;                          }                            if (weight[tmp] < weight[heap[yy]])                          {                              break;                          }                            heap[zz] = heap[yy];                          zz = yy;                      }                        heap[zz] = tmp;                        int n2 = heap[1];                      heap[1] = heap[nHeap];                      nHeap--;                        yy = 0;                      zz = 1;                      tmp = heap[1];                        while (true)                      {                          yy = zz << 1;                            if (yy > nHeap)                          {                              break;                          }                            if ((yy < nHeap)                              && (weight[heap[yy + 1]] < weight[heap[yy]]))                          {                              yy++;                          }                            if (weight[tmp] < weight[heap[yy]])                          {                              break;                          }                            heap[zz] = heap[yy];                          zz = yy;                      }                        heap[zz] = tmp;                      nNodes++;                      parent[n1] = parent[n2] = nNodes;                        int weight_n1 = weight[n1];                      int weight_n2 = weight[n2];                      weight[nNodes] = (int) (((uint)weight_n1 & 0xffffff00U)                                              + ((uint)weight_n2 & 0xffffff00U))                          | (1 + (((weight_n1 & 0x000000ff)                                   > (weight_n2 & 0x000000ff))                                  ? (weight_n1 & 0x000000ff)                                  : (weight_n2 & 0x000000ff)));                        parent[nNodes] = -1;                      nHeap++;                      heap[nHeap] = nNodes;                        tmp = 0;                      zz = nHeap;                      tmp = heap[zz];                      int weight_tmp = weight[tmp];                      while (weight_tmp < weight[heap[zz >> 1]])                      {                          heap[zz] = heap[zz >> 1];                          zz >>= 1;                      }                      heap[zz] = tmp;                    }                    for (int i = 1; i <= alphaSize; i++)                  {                      int j = 0;                      int k = i;                        for (int parent_k; (parent_k = parent[k]) >= 0;)                      {                          k = parent_k;                          j++;                      }                        len[i - 1] = (byte) j;                      if (j > maxLen)                      {                          tooLong = true;                      }                  }                    if (tooLong)                  {                      for (int i = 1; i < alphaSize; i++)                      {                          int j = weight[i] >> 8;                          j = 1 + (j >> 1);                          weight[i] = j << 8;                      }                  }              }
Magic Number,Ionic.BZip2,BZip2Compressor,C:\repos\haf_DotNetZip.Semverd\src\BZip2\BZip2Compressor.cs,sendMTFValues1,The following statement contains a magic number: byte[] len_2 = len[2];
Magic Number,Ionic.BZip2,BZip2Compressor,C:\repos\haf_DotNetZip.Semverd\src\BZip2\BZip2Compressor.cs,sendMTFValues1,The following statement contains a magic number: byte[] len_3 = len[3];
Magic Number,Ionic.BZip2,BZip2Compressor,C:\repos\haf_DotNetZip.Semverd\src\BZip2\BZip2Compressor.cs,sendMTFValues1,The following statement contains a magic number: byte[] len_4 = len[4];
Magic Number,Ionic.BZip2,BZip2Compressor,C:\repos\haf_DotNetZip.Semverd\src\BZip2\BZip2Compressor.cs,sendMTFValues1,The following statement contains a magic number: byte[] len_5 = len[5];
Magic Number,Ionic.BZip2,BZip2Compressor,C:\repos\haf_DotNetZip.Semverd\src\BZip2\BZip2Compressor.cs,sendMTFValues1,The following statement contains a magic number: for (int iter = 0; iter < BZip2.N_ITERS; iter++)              {                  for (int t = nGroups; --t >= 0;)                  {                      fave[t] = 0;                      int[] rfreqt = rfreq[t];                      for (int i = alphaSize; --i >= 0;)                      {                          rfreqt[i] = 0;                      }                  }                    nSelectors = 0;                    for (int gs = 0; gs < this.nMTF;)                  {                      /* Set group start & end marks. */                        /*                       * Calculate the cost of this group as coded by each of the                       * coding tables.                       */                        int ge = Math.Min(gs + BZip2.G_SIZE - 1' nMTFShadow - 1);                        if (nGroups == BZip2.NGroups)                      {                          // unrolled version of the else-block                            int[] c = new int[6];                            for (int i = gs; i <= ge; i++)                          {                              int icv = sfmap[i];                              c[0] += len_0[icv] & 0xff;                              c[1] += len_1[icv] & 0xff;                              c[2] += len_2[icv] & 0xff;                              c[3] += len_3[icv] & 0xff;                              c[4] += len_4[icv] & 0xff;                              c[5] += len_5[icv] & 0xff;                          }                            cost[0] = (short) c[0];                          cost[1] = (short) c[1];                          cost[2] = (short) c[2];                          cost[3] = (short) c[3];                          cost[4] = (short) c[4];                          cost[5] = (short) c[5];                      }                      else                      {                          for (int t = nGroups; --t >= 0;)                          {                              cost[t] = 0;                          }                            for (int i = gs; i <= ge; i++)                          {                              int icv = sfmap[i];                              for (int t = nGroups; --t >= 0;)                              {                                  cost[t] += (short) (len[t][icv] & 0xff);                              }                          }                      }                        /*                       * Find the coding table which is best for this group' and                       * record its identity in the selector table.                       */                      int bt = -1;                      for (int t = nGroups' bc = 999999999; --t >= 0;)                      {                          int cost_t = cost[t];                          if (cost_t < bc)                          {                              bc = cost_t;                              bt = t;                          }                      }                        fave[bt]++;                      selector[nSelectors] = (byte) bt;                      nSelectors++;                        /*                       * Increment the symbol frequencies for the selected table.                       */                      int[] rfreq_bt = rfreq[bt];                      for (int i = gs; i <= ge; i++)                      {                          rfreq_bt[sfmap[i]]++;                      }                        gs = ge + 1;                  }                    /*                   * Recompute the tables based on the accumulated frequencies.                   */                  for (int t = 0; t < nGroups; t++)                  {                      hbMakeCodeLengths(len[t]' rfreq[t]' this.cstate' alphaSize' 20);                  }              }
Magic Number,Ionic.BZip2,BZip2Compressor,C:\repos\haf_DotNetZip.Semverd\src\BZip2\BZip2Compressor.cs,sendMTFValues1,The following statement contains a magic number: for (int iter = 0; iter < BZip2.N_ITERS; iter++)              {                  for (int t = nGroups; --t >= 0;)                  {                      fave[t] = 0;                      int[] rfreqt = rfreq[t];                      for (int i = alphaSize; --i >= 0;)                      {                          rfreqt[i] = 0;                      }                  }                    nSelectors = 0;                    for (int gs = 0; gs < this.nMTF;)                  {                      /* Set group start & end marks. */                        /*                       * Calculate the cost of this group as coded by each of the                       * coding tables.                       */                        int ge = Math.Min(gs + BZip2.G_SIZE - 1' nMTFShadow - 1);                        if (nGroups == BZip2.NGroups)                      {                          // unrolled version of the else-block                            int[] c = new int[6];                            for (int i = gs; i <= ge; i++)                          {                              int icv = sfmap[i];                              c[0] += len_0[icv] & 0xff;                              c[1] += len_1[icv] & 0xff;                              c[2] += len_2[icv] & 0xff;                              c[3] += len_3[icv] & 0xff;                              c[4] += len_4[icv] & 0xff;                              c[5] += len_5[icv] & 0xff;                          }                            cost[0] = (short) c[0];                          cost[1] = (short) c[1];                          cost[2] = (short) c[2];                          cost[3] = (short) c[3];                          cost[4] = (short) c[4];                          cost[5] = (short) c[5];                      }                      else                      {                          for (int t = nGroups; --t >= 0;)                          {                              cost[t] = 0;                          }                            for (int i = gs; i <= ge; i++)                          {                              int icv = sfmap[i];                              for (int t = nGroups; --t >= 0;)                              {                                  cost[t] += (short) (len[t][icv] & 0xff);                              }                          }                      }                        /*                       * Find the coding table which is best for this group' and                       * record its identity in the selector table.                       */                      int bt = -1;                      for (int t = nGroups' bc = 999999999; --t >= 0;)                      {                          int cost_t = cost[t];                          if (cost_t < bc)                          {                              bc = cost_t;                              bt = t;                          }                      }                        fave[bt]++;                      selector[nSelectors] = (byte) bt;                      nSelectors++;                        /*                       * Increment the symbol frequencies for the selected table.                       */                      int[] rfreq_bt = rfreq[bt];                      for (int i = gs; i <= ge; i++)                      {                          rfreq_bt[sfmap[i]]++;                      }                        gs = ge + 1;                  }                    /*                   * Recompute the tables based on the accumulated frequencies.                   */                  for (int t = 0; t < nGroups; t++)                  {                      hbMakeCodeLengths(len[t]' rfreq[t]' this.cstate' alphaSize' 20);                  }              }
Magic Number,Ionic.BZip2,BZip2Compressor,C:\repos\haf_DotNetZip.Semverd\src\BZip2\BZip2Compressor.cs,sendMTFValues1,The following statement contains a magic number: for (int iter = 0; iter < BZip2.N_ITERS; iter++)              {                  for (int t = nGroups; --t >= 0;)                  {                      fave[t] = 0;                      int[] rfreqt = rfreq[t];                      for (int i = alphaSize; --i >= 0;)                      {                          rfreqt[i] = 0;                      }                  }                    nSelectors = 0;                    for (int gs = 0; gs < this.nMTF;)                  {                      /* Set group start & end marks. */                        /*                       * Calculate the cost of this group as coded by each of the                       * coding tables.                       */                        int ge = Math.Min(gs + BZip2.G_SIZE - 1' nMTFShadow - 1);                        if (nGroups == BZip2.NGroups)                      {                          // unrolled version of the else-block                            int[] c = new int[6];                            for (int i = gs; i <= ge; i++)                          {                              int icv = sfmap[i];                              c[0] += len_0[icv] & 0xff;                              c[1] += len_1[icv] & 0xff;                              c[2] += len_2[icv] & 0xff;                              c[3] += len_3[icv] & 0xff;                              c[4] += len_4[icv] & 0xff;                              c[5] += len_5[icv] & 0xff;                          }                            cost[0] = (short) c[0];                          cost[1] = (short) c[1];                          cost[2] = (short) c[2];                          cost[3] = (short) c[3];                          cost[4] = (short) c[4];                          cost[5] = (short) c[5];                      }                      else                      {                          for (int t = nGroups; --t >= 0;)                          {                              cost[t] = 0;                          }                            for (int i = gs; i <= ge; i++)                          {                              int icv = sfmap[i];                              for (int t = nGroups; --t >= 0;)                              {                                  cost[t] += (short) (len[t][icv] & 0xff);                              }                          }                      }                        /*                       * Find the coding table which is best for this group' and                       * record its identity in the selector table.                       */                      int bt = -1;                      for (int t = nGroups' bc = 999999999; --t >= 0;)                      {                          int cost_t = cost[t];                          if (cost_t < bc)                          {                              bc = cost_t;                              bt = t;                          }                      }                        fave[bt]++;                      selector[nSelectors] = (byte) bt;                      nSelectors++;                        /*                       * Increment the symbol frequencies for the selected table.                       */                      int[] rfreq_bt = rfreq[bt];                      for (int i = gs; i <= ge; i++)                      {                          rfreq_bt[sfmap[i]]++;                      }                        gs = ge + 1;                  }                    /*                   * Recompute the tables based on the accumulated frequencies.                   */                  for (int t = 0; t < nGroups; t++)                  {                      hbMakeCodeLengths(len[t]' rfreq[t]' this.cstate' alphaSize' 20);                  }              }
Magic Number,Ionic.BZip2,BZip2Compressor,C:\repos\haf_DotNetZip.Semverd\src\BZip2\BZip2Compressor.cs,sendMTFValues1,The following statement contains a magic number: for (int iter = 0; iter < BZip2.N_ITERS; iter++)              {                  for (int t = nGroups; --t >= 0;)                  {                      fave[t] = 0;                      int[] rfreqt = rfreq[t];                      for (int i = alphaSize; --i >= 0;)                      {                          rfreqt[i] = 0;                      }                  }                    nSelectors = 0;                    for (int gs = 0; gs < this.nMTF;)                  {                      /* Set group start & end marks. */                        /*                       * Calculate the cost of this group as coded by each of the                       * coding tables.                       */                        int ge = Math.Min(gs + BZip2.G_SIZE - 1' nMTFShadow - 1);                        if (nGroups == BZip2.NGroups)                      {                          // unrolled version of the else-block                            int[] c = new int[6];                            for (int i = gs; i <= ge; i++)                          {                              int icv = sfmap[i];                              c[0] += len_0[icv] & 0xff;                              c[1] += len_1[icv] & 0xff;                              c[2] += len_2[icv] & 0xff;                              c[3] += len_3[icv] & 0xff;                              c[4] += len_4[icv] & 0xff;                              c[5] += len_5[icv] & 0xff;                          }                            cost[0] = (short) c[0];                          cost[1] = (short) c[1];                          cost[2] = (short) c[2];                          cost[3] = (short) c[3];                          cost[4] = (short) c[4];                          cost[5] = (short) c[5];                      }                      else                      {                          for (int t = nGroups; --t >= 0;)                          {                              cost[t] = 0;                          }                            for (int i = gs; i <= ge; i++)                          {                              int icv = sfmap[i];                              for (int t = nGroups; --t >= 0;)                              {                                  cost[t] += (short) (len[t][icv] & 0xff);                              }                          }                      }                        /*                       * Find the coding table which is best for this group' and                       * record its identity in the selector table.                       */                      int bt = -1;                      for (int t = nGroups' bc = 999999999; --t >= 0;)                      {                          int cost_t = cost[t];                          if (cost_t < bc)                          {                              bc = cost_t;                              bt = t;                          }                      }                        fave[bt]++;                      selector[nSelectors] = (byte) bt;                      nSelectors++;                        /*                       * Increment the symbol frequencies for the selected table.                       */                      int[] rfreq_bt = rfreq[bt];                      for (int i = gs; i <= ge; i++)                      {                          rfreq_bt[sfmap[i]]++;                      }                        gs = ge + 1;                  }                    /*                   * Recompute the tables based on the accumulated frequencies.                   */                  for (int t = 0; t < nGroups; t++)                  {                      hbMakeCodeLengths(len[t]' rfreq[t]' this.cstate' alphaSize' 20);                  }              }
Magic Number,Ionic.BZip2,BZip2Compressor,C:\repos\haf_DotNetZip.Semverd\src\BZip2\BZip2Compressor.cs,sendMTFValues1,The following statement contains a magic number: for (int iter = 0; iter < BZip2.N_ITERS; iter++)              {                  for (int t = nGroups; --t >= 0;)                  {                      fave[t] = 0;                      int[] rfreqt = rfreq[t];                      for (int i = alphaSize; --i >= 0;)                      {                          rfreqt[i] = 0;                      }                  }                    nSelectors = 0;                    for (int gs = 0; gs < this.nMTF;)                  {                      /* Set group start & end marks. */                        /*                       * Calculate the cost of this group as coded by each of the                       * coding tables.                       */                        int ge = Math.Min(gs + BZip2.G_SIZE - 1' nMTFShadow - 1);                        if (nGroups == BZip2.NGroups)                      {                          // unrolled version of the else-block                            int[] c = new int[6];                            for (int i = gs; i <= ge; i++)                          {                              int icv = sfmap[i];                              c[0] += len_0[icv] & 0xff;                              c[1] += len_1[icv] & 0xff;                              c[2] += len_2[icv] & 0xff;                              c[3] += len_3[icv] & 0xff;                              c[4] += len_4[icv] & 0xff;                              c[5] += len_5[icv] & 0xff;                          }                            cost[0] = (short) c[0];                          cost[1] = (short) c[1];                          cost[2] = (short) c[2];                          cost[3] = (short) c[3];                          cost[4] = (short) c[4];                          cost[5] = (short) c[5];                      }                      else                      {                          for (int t = nGroups; --t >= 0;)                          {                              cost[t] = 0;                          }                            for (int i = gs; i <= ge; i++)                          {                              int icv = sfmap[i];                              for (int t = nGroups; --t >= 0;)                              {                                  cost[t] += (short) (len[t][icv] & 0xff);                              }                          }                      }                        /*                       * Find the coding table which is best for this group' and                       * record its identity in the selector table.                       */                      int bt = -1;                      for (int t = nGroups' bc = 999999999; --t >= 0;)                      {                          int cost_t = cost[t];                          if (cost_t < bc)                          {                              bc = cost_t;                              bt = t;                          }                      }                        fave[bt]++;                      selector[nSelectors] = (byte) bt;                      nSelectors++;                        /*                       * Increment the symbol frequencies for the selected table.                       */                      int[] rfreq_bt = rfreq[bt];                      for (int i = gs; i <= ge; i++)                      {                          rfreq_bt[sfmap[i]]++;                      }                        gs = ge + 1;                  }                    /*                   * Recompute the tables based on the accumulated frequencies.                   */                  for (int t = 0; t < nGroups; t++)                  {                      hbMakeCodeLengths(len[t]' rfreq[t]' this.cstate' alphaSize' 20);                  }              }
Magic Number,Ionic.BZip2,BZip2Compressor,C:\repos\haf_DotNetZip.Semverd\src\BZip2\BZip2Compressor.cs,sendMTFValues1,The following statement contains a magic number: for (int iter = 0; iter < BZip2.N_ITERS; iter++)              {                  for (int t = nGroups; --t >= 0;)                  {                      fave[t] = 0;                      int[] rfreqt = rfreq[t];                      for (int i = alphaSize; --i >= 0;)                      {                          rfreqt[i] = 0;                      }                  }                    nSelectors = 0;                    for (int gs = 0; gs < this.nMTF;)                  {                      /* Set group start & end marks. */                        /*                       * Calculate the cost of this group as coded by each of the                       * coding tables.                       */                        int ge = Math.Min(gs + BZip2.G_SIZE - 1' nMTFShadow - 1);                        if (nGroups == BZip2.NGroups)                      {                          // unrolled version of the else-block                            int[] c = new int[6];                            for (int i = gs; i <= ge; i++)                          {                              int icv = sfmap[i];                              c[0] += len_0[icv] & 0xff;                              c[1] += len_1[icv] & 0xff;                              c[2] += len_2[icv] & 0xff;                              c[3] += len_3[icv] & 0xff;                              c[4] += len_4[icv] & 0xff;                              c[5] += len_5[icv] & 0xff;                          }                            cost[0] = (short) c[0];                          cost[1] = (short) c[1];                          cost[2] = (short) c[2];                          cost[3] = (short) c[3];                          cost[4] = (short) c[4];                          cost[5] = (short) c[5];                      }                      else                      {                          for (int t = nGroups; --t >= 0;)                          {                              cost[t] = 0;                          }                            for (int i = gs; i <= ge; i++)                          {                              int icv = sfmap[i];                              for (int t = nGroups; --t >= 0;)                              {                                  cost[t] += (short) (len[t][icv] & 0xff);                              }                          }                      }                        /*                       * Find the coding table which is best for this group' and                       * record its identity in the selector table.                       */                      int bt = -1;                      for (int t = nGroups' bc = 999999999; --t >= 0;)                      {                          int cost_t = cost[t];                          if (cost_t < bc)                          {                              bc = cost_t;                              bt = t;                          }                      }                        fave[bt]++;                      selector[nSelectors] = (byte) bt;                      nSelectors++;                        /*                       * Increment the symbol frequencies for the selected table.                       */                      int[] rfreq_bt = rfreq[bt];                      for (int i = gs; i <= ge; i++)                      {                          rfreq_bt[sfmap[i]]++;                      }                        gs = ge + 1;                  }                    /*                   * Recompute the tables based on the accumulated frequencies.                   */                  for (int t = 0; t < nGroups; t++)                  {                      hbMakeCodeLengths(len[t]' rfreq[t]' this.cstate' alphaSize' 20);                  }              }
Magic Number,Ionic.BZip2,BZip2Compressor,C:\repos\haf_DotNetZip.Semverd\src\BZip2\BZip2Compressor.cs,sendMTFValues1,The following statement contains a magic number: for (int iter = 0; iter < BZip2.N_ITERS; iter++)              {                  for (int t = nGroups; --t >= 0;)                  {                      fave[t] = 0;                      int[] rfreqt = rfreq[t];                      for (int i = alphaSize; --i >= 0;)                      {                          rfreqt[i] = 0;                      }                  }                    nSelectors = 0;                    for (int gs = 0; gs < this.nMTF;)                  {                      /* Set group start & end marks. */                        /*                       * Calculate the cost of this group as coded by each of the                       * coding tables.                       */                        int ge = Math.Min(gs + BZip2.G_SIZE - 1' nMTFShadow - 1);                        if (nGroups == BZip2.NGroups)                      {                          // unrolled version of the else-block                            int[] c = new int[6];                            for (int i = gs; i <= ge; i++)                          {                              int icv = sfmap[i];                              c[0] += len_0[icv] & 0xff;                              c[1] += len_1[icv] & 0xff;                              c[2] += len_2[icv] & 0xff;                              c[3] += len_3[icv] & 0xff;                              c[4] += len_4[icv] & 0xff;                              c[5] += len_5[icv] & 0xff;                          }                            cost[0] = (short) c[0];                          cost[1] = (short) c[1];                          cost[2] = (short) c[2];                          cost[3] = (short) c[3];                          cost[4] = (short) c[4];                          cost[5] = (short) c[5];                      }                      else                      {                          for (int t = nGroups; --t >= 0;)                          {                              cost[t] = 0;                          }                            for (int i = gs; i <= ge; i++)                          {                              int icv = sfmap[i];                              for (int t = nGroups; --t >= 0;)                              {                                  cost[t] += (short) (len[t][icv] & 0xff);                              }                          }                      }                        /*                       * Find the coding table which is best for this group' and                       * record its identity in the selector table.                       */                      int bt = -1;                      for (int t = nGroups' bc = 999999999; --t >= 0;)                      {                          int cost_t = cost[t];                          if (cost_t < bc)                          {                              bc = cost_t;                              bt = t;                          }                      }                        fave[bt]++;                      selector[nSelectors] = (byte) bt;                      nSelectors++;                        /*                       * Increment the symbol frequencies for the selected table.                       */                      int[] rfreq_bt = rfreq[bt];                      for (int i = gs; i <= ge; i++)                      {                          rfreq_bt[sfmap[i]]++;                      }                        gs = ge + 1;                  }                    /*                   * Recompute the tables based on the accumulated frequencies.                   */                  for (int t = 0; t < nGroups; t++)                  {                      hbMakeCodeLengths(len[t]' rfreq[t]' this.cstate' alphaSize' 20);                  }              }
Magic Number,Ionic.BZip2,BZip2Compressor,C:\repos\haf_DotNetZip.Semverd\src\BZip2\BZip2Compressor.cs,sendMTFValues1,The following statement contains a magic number: for (int iter = 0; iter < BZip2.N_ITERS; iter++)              {                  for (int t = nGroups; --t >= 0;)                  {                      fave[t] = 0;                      int[] rfreqt = rfreq[t];                      for (int i = alphaSize; --i >= 0;)                      {                          rfreqt[i] = 0;                      }                  }                    nSelectors = 0;                    for (int gs = 0; gs < this.nMTF;)                  {                      /* Set group start & end marks. */                        /*                       * Calculate the cost of this group as coded by each of the                       * coding tables.                       */                        int ge = Math.Min(gs + BZip2.G_SIZE - 1' nMTFShadow - 1);                        if (nGroups == BZip2.NGroups)                      {                          // unrolled version of the else-block                            int[] c = new int[6];                            for (int i = gs; i <= ge; i++)                          {                              int icv = sfmap[i];                              c[0] += len_0[icv] & 0xff;                              c[1] += len_1[icv] & 0xff;                              c[2] += len_2[icv] & 0xff;                              c[3] += len_3[icv] & 0xff;                              c[4] += len_4[icv] & 0xff;                              c[5] += len_5[icv] & 0xff;                          }                            cost[0] = (short) c[0];                          cost[1] = (short) c[1];                          cost[2] = (short) c[2];                          cost[3] = (short) c[3];                          cost[4] = (short) c[4];                          cost[5] = (short) c[5];                      }                      else                      {                          for (int t = nGroups; --t >= 0;)                          {                              cost[t] = 0;                          }                            for (int i = gs; i <= ge; i++)                          {                              int icv = sfmap[i];                              for (int t = nGroups; --t >= 0;)                              {                                  cost[t] += (short) (len[t][icv] & 0xff);                              }                          }                      }                        /*                       * Find the coding table which is best for this group' and                       * record its identity in the selector table.                       */                      int bt = -1;                      for (int t = nGroups' bc = 999999999; --t >= 0;)                      {                          int cost_t = cost[t];                          if (cost_t < bc)                          {                              bc = cost_t;                              bt = t;                          }                      }                        fave[bt]++;                      selector[nSelectors] = (byte) bt;                      nSelectors++;                        /*                       * Increment the symbol frequencies for the selected table.                       */                      int[] rfreq_bt = rfreq[bt];                      for (int i = gs; i <= ge; i++)                      {                          rfreq_bt[sfmap[i]]++;                      }                        gs = ge + 1;                  }                    /*                   * Recompute the tables based on the accumulated frequencies.                   */                  for (int t = 0; t < nGroups; t++)                  {                      hbMakeCodeLengths(len[t]' rfreq[t]' this.cstate' alphaSize' 20);                  }              }
Magic Number,Ionic.BZip2,BZip2Compressor,C:\repos\haf_DotNetZip.Semverd\src\BZip2\BZip2Compressor.cs,sendMTFValues1,The following statement contains a magic number: for (int iter = 0; iter < BZip2.N_ITERS; iter++)              {                  for (int t = nGroups; --t >= 0;)                  {                      fave[t] = 0;                      int[] rfreqt = rfreq[t];                      for (int i = alphaSize; --i >= 0;)                      {                          rfreqt[i] = 0;                      }                  }                    nSelectors = 0;                    for (int gs = 0; gs < this.nMTF;)                  {                      /* Set group start & end marks. */                        /*                       * Calculate the cost of this group as coded by each of the                       * coding tables.                       */                        int ge = Math.Min(gs + BZip2.G_SIZE - 1' nMTFShadow - 1);                        if (nGroups == BZip2.NGroups)                      {                          // unrolled version of the else-block                            int[] c = new int[6];                            for (int i = gs; i <= ge; i++)                          {                              int icv = sfmap[i];                              c[0] += len_0[icv] & 0xff;                              c[1] += len_1[icv] & 0xff;                              c[2] += len_2[icv] & 0xff;                              c[3] += len_3[icv] & 0xff;                              c[4] += len_4[icv] & 0xff;                              c[5] += len_5[icv] & 0xff;                          }                            cost[0] = (short) c[0];                          cost[1] = (short) c[1];                          cost[2] = (short) c[2];                          cost[3] = (short) c[3];                          cost[4] = (short) c[4];                          cost[5] = (short) c[5];                      }                      else                      {                          for (int t = nGroups; --t >= 0;)                          {                              cost[t] = 0;                          }                            for (int i = gs; i <= ge; i++)                          {                              int icv = sfmap[i];                              for (int t = nGroups; --t >= 0;)                              {                                  cost[t] += (short) (len[t][icv] & 0xff);                              }                          }                      }                        /*                       * Find the coding table which is best for this group' and                       * record its identity in the selector table.                       */                      int bt = -1;                      for (int t = nGroups' bc = 999999999; --t >= 0;)                      {                          int cost_t = cost[t];                          if (cost_t < bc)                          {                              bc = cost_t;                              bt = t;                          }                      }                        fave[bt]++;                      selector[nSelectors] = (byte) bt;                      nSelectors++;                        /*                       * Increment the symbol frequencies for the selected table.                       */                      int[] rfreq_bt = rfreq[bt];                      for (int i = gs; i <= ge; i++)                      {                          rfreq_bt[sfmap[i]]++;                      }                        gs = ge + 1;                  }                    /*                   * Recompute the tables based on the accumulated frequencies.                   */                  for (int t = 0; t < nGroups; t++)                  {                      hbMakeCodeLengths(len[t]' rfreq[t]' this.cstate' alphaSize' 20);                  }              }
Magic Number,Ionic.BZip2,BZip2Compressor,C:\repos\haf_DotNetZip.Semverd\src\BZip2\BZip2Compressor.cs,sendMTFValues1,The following statement contains a magic number: for (int iter = 0; iter < BZip2.N_ITERS; iter++)              {                  for (int t = nGroups; --t >= 0;)                  {                      fave[t] = 0;                      int[] rfreqt = rfreq[t];                      for (int i = alphaSize; --i >= 0;)                      {                          rfreqt[i] = 0;                      }                  }                    nSelectors = 0;                    for (int gs = 0; gs < this.nMTF;)                  {                      /* Set group start & end marks. */                        /*                       * Calculate the cost of this group as coded by each of the                       * coding tables.                       */                        int ge = Math.Min(gs + BZip2.G_SIZE - 1' nMTFShadow - 1);                        if (nGroups == BZip2.NGroups)                      {                          // unrolled version of the else-block                            int[] c = new int[6];                            for (int i = gs; i <= ge; i++)                          {                              int icv = sfmap[i];                              c[0] += len_0[icv] & 0xff;                              c[1] += len_1[icv] & 0xff;                              c[2] += len_2[icv] & 0xff;                              c[3] += len_3[icv] & 0xff;                              c[4] += len_4[icv] & 0xff;                              c[5] += len_5[icv] & 0xff;                          }                            cost[0] = (short) c[0];                          cost[1] = (short) c[1];                          cost[2] = (short) c[2];                          cost[3] = (short) c[3];                          cost[4] = (short) c[4];                          cost[5] = (short) c[5];                      }                      else                      {                          for (int t = nGroups; --t >= 0;)                          {                              cost[t] = 0;                          }                            for (int i = gs; i <= ge; i++)                          {                              int icv = sfmap[i];                              for (int t = nGroups; --t >= 0;)                              {                                  cost[t] += (short) (len[t][icv] & 0xff);                              }                          }                      }                        /*                       * Find the coding table which is best for this group' and                       * record its identity in the selector table.                       */                      int bt = -1;                      for (int t = nGroups' bc = 999999999; --t >= 0;)                      {                          int cost_t = cost[t];                          if (cost_t < bc)                          {                              bc = cost_t;                              bt = t;                          }                      }                        fave[bt]++;                      selector[nSelectors] = (byte) bt;                      nSelectors++;                        /*                       * Increment the symbol frequencies for the selected table.                       */                      int[] rfreq_bt = rfreq[bt];                      for (int i = gs; i <= ge; i++)                      {                          rfreq_bt[sfmap[i]]++;                      }                        gs = ge + 1;                  }                    /*                   * Recompute the tables based on the accumulated frequencies.                   */                  for (int t = 0; t < nGroups; t++)                  {                      hbMakeCodeLengths(len[t]' rfreq[t]' this.cstate' alphaSize' 20);                  }              }
Magic Number,Ionic.BZip2,BZip2Compressor,C:\repos\haf_DotNetZip.Semverd\src\BZip2\BZip2Compressor.cs,sendMTFValues1,The following statement contains a magic number: for (int iter = 0; iter < BZip2.N_ITERS; iter++)              {                  for (int t = nGroups; --t >= 0;)                  {                      fave[t] = 0;                      int[] rfreqt = rfreq[t];                      for (int i = alphaSize; --i >= 0;)                      {                          rfreqt[i] = 0;                      }                  }                    nSelectors = 0;                    for (int gs = 0; gs < this.nMTF;)                  {                      /* Set group start & end marks. */                        /*                       * Calculate the cost of this group as coded by each of the                       * coding tables.                       */                        int ge = Math.Min(gs + BZip2.G_SIZE - 1' nMTFShadow - 1);                        if (nGroups == BZip2.NGroups)                      {                          // unrolled version of the else-block                            int[] c = new int[6];                            for (int i = gs; i <= ge; i++)                          {                              int icv = sfmap[i];                              c[0] += len_0[icv] & 0xff;                              c[1] += len_1[icv] & 0xff;                              c[2] += len_2[icv] & 0xff;                              c[3] += len_3[icv] & 0xff;                              c[4] += len_4[icv] & 0xff;                              c[5] += len_5[icv] & 0xff;                          }                            cost[0] = (short) c[0];                          cost[1] = (short) c[1];                          cost[2] = (short) c[2];                          cost[3] = (short) c[3];                          cost[4] = (short) c[4];                          cost[5] = (short) c[5];                      }                      else                      {                          for (int t = nGroups; --t >= 0;)                          {                              cost[t] = 0;                          }                            for (int i = gs; i <= ge; i++)                          {                              int icv = sfmap[i];                              for (int t = nGroups; --t >= 0;)                              {                                  cost[t] += (short) (len[t][icv] & 0xff);                              }                          }                      }                        /*                       * Find the coding table which is best for this group' and                       * record its identity in the selector table.                       */                      int bt = -1;                      for (int t = nGroups' bc = 999999999; --t >= 0;)                      {                          int cost_t = cost[t];                          if (cost_t < bc)                          {                              bc = cost_t;                              bt = t;                          }                      }                        fave[bt]++;                      selector[nSelectors] = (byte) bt;                      nSelectors++;                        /*                       * Increment the symbol frequencies for the selected table.                       */                      int[] rfreq_bt = rfreq[bt];                      for (int i = gs; i <= ge; i++)                      {                          rfreq_bt[sfmap[i]]++;                      }                        gs = ge + 1;                  }                    /*                   * Recompute the tables based on the accumulated frequencies.                   */                  for (int t = 0; t < nGroups; t++)                  {                      hbMakeCodeLengths(len[t]' rfreq[t]' this.cstate' alphaSize' 20);                  }              }
Magic Number,Ionic.BZip2,BZip2Compressor,C:\repos\haf_DotNetZip.Semverd\src\BZip2\BZip2Compressor.cs,sendMTFValues1,The following statement contains a magic number: for (int iter = 0; iter < BZip2.N_ITERS; iter++)              {                  for (int t = nGroups; --t >= 0;)                  {                      fave[t] = 0;                      int[] rfreqt = rfreq[t];                      for (int i = alphaSize; --i >= 0;)                      {                          rfreqt[i] = 0;                      }                  }                    nSelectors = 0;                    for (int gs = 0; gs < this.nMTF;)                  {                      /* Set group start & end marks. */                        /*                       * Calculate the cost of this group as coded by each of the                       * coding tables.                       */                        int ge = Math.Min(gs + BZip2.G_SIZE - 1' nMTFShadow - 1);                        if (nGroups == BZip2.NGroups)                      {                          // unrolled version of the else-block                            int[] c = new int[6];                            for (int i = gs; i <= ge; i++)                          {                              int icv = sfmap[i];                              c[0] += len_0[icv] & 0xff;                              c[1] += len_1[icv] & 0xff;                              c[2] += len_2[icv] & 0xff;                              c[3] += len_3[icv] & 0xff;                              c[4] += len_4[icv] & 0xff;                              c[5] += len_5[icv] & 0xff;                          }                            cost[0] = (short) c[0];                          cost[1] = (short) c[1];                          cost[2] = (short) c[2];                          cost[3] = (short) c[3];                          cost[4] = (short) c[4];                          cost[5] = (short) c[5];                      }                      else                      {                          for (int t = nGroups; --t >= 0;)                          {                              cost[t] = 0;                          }                            for (int i = gs; i <= ge; i++)                          {                              int icv = sfmap[i];                              for (int t = nGroups; --t >= 0;)                              {                                  cost[t] += (short) (len[t][icv] & 0xff);                              }                          }                      }                        /*                       * Find the coding table which is best for this group' and                       * record its identity in the selector table.                       */                      int bt = -1;                      for (int t = nGroups' bc = 999999999; --t >= 0;)                      {                          int cost_t = cost[t];                          if (cost_t < bc)                          {                              bc = cost_t;                              bt = t;                          }                      }                        fave[bt]++;                      selector[nSelectors] = (byte) bt;                      nSelectors++;                        /*                       * Increment the symbol frequencies for the selected table.                       */                      int[] rfreq_bt = rfreq[bt];                      for (int i = gs; i <= ge; i++)                      {                          rfreq_bt[sfmap[i]]++;                      }                        gs = ge + 1;                  }                    /*                   * Recompute the tables based on the accumulated frequencies.                   */                  for (int t = 0; t < nGroups; t++)                  {                      hbMakeCodeLengths(len[t]' rfreq[t]' this.cstate' alphaSize' 20);                  }              }
Magic Number,Ionic.BZip2,BZip2Compressor,C:\repos\haf_DotNetZip.Semverd\src\BZip2\BZip2Compressor.cs,sendMTFValues1,The following statement contains a magic number: for (int iter = 0; iter < BZip2.N_ITERS; iter++)              {                  for (int t = nGroups; --t >= 0;)                  {                      fave[t] = 0;                      int[] rfreqt = rfreq[t];                      for (int i = alphaSize; --i >= 0;)                      {                          rfreqt[i] = 0;                      }                  }                    nSelectors = 0;                    for (int gs = 0; gs < this.nMTF;)                  {                      /* Set group start & end marks. */                        /*                       * Calculate the cost of this group as coded by each of the                       * coding tables.                       */                        int ge = Math.Min(gs + BZip2.G_SIZE - 1' nMTFShadow - 1);                        if (nGroups == BZip2.NGroups)                      {                          // unrolled version of the else-block                            int[] c = new int[6];                            for (int i = gs; i <= ge; i++)                          {                              int icv = sfmap[i];                              c[0] += len_0[icv] & 0xff;                              c[1] += len_1[icv] & 0xff;                              c[2] += len_2[icv] & 0xff;                              c[3] += len_3[icv] & 0xff;                              c[4] += len_4[icv] & 0xff;                              c[5] += len_5[icv] & 0xff;                          }                            cost[0] = (short) c[0];                          cost[1] = (short) c[1];                          cost[2] = (short) c[2];                          cost[3] = (short) c[3];                          cost[4] = (short) c[4];                          cost[5] = (short) c[5];                      }                      else                      {                          for (int t = nGroups; --t >= 0;)                          {                              cost[t] = 0;                          }                            for (int i = gs; i <= ge; i++)                          {                              int icv = sfmap[i];                              for (int t = nGroups; --t >= 0;)                              {                                  cost[t] += (short) (len[t][icv] & 0xff);                              }                          }                      }                        /*                       * Find the coding table which is best for this group' and                       * record its identity in the selector table.                       */                      int bt = -1;                      for (int t = nGroups' bc = 999999999; --t >= 0;)                      {                          int cost_t = cost[t];                          if (cost_t < bc)                          {                              bc = cost_t;                              bt = t;                          }                      }                        fave[bt]++;                      selector[nSelectors] = (byte) bt;                      nSelectors++;                        /*                       * Increment the symbol frequencies for the selected table.                       */                      int[] rfreq_bt = rfreq[bt];                      for (int i = gs; i <= ge; i++)                      {                          rfreq_bt[sfmap[i]]++;                      }                        gs = ge + 1;                  }                    /*                   * Recompute the tables based on the accumulated frequencies.                   */                  for (int t = 0; t < nGroups; t++)                  {                      hbMakeCodeLengths(len[t]' rfreq[t]' this.cstate' alphaSize' 20);                  }              }
Magic Number,Ionic.BZip2,BZip2Compressor,C:\repos\haf_DotNetZip.Semverd\src\BZip2\BZip2Compressor.cs,sendMTFValues1,The following statement contains a magic number: for (int iter = 0; iter < BZip2.N_ITERS; iter++)              {                  for (int t = nGroups; --t >= 0;)                  {                      fave[t] = 0;                      int[] rfreqt = rfreq[t];                      for (int i = alphaSize; --i >= 0;)                      {                          rfreqt[i] = 0;                      }                  }                    nSelectors = 0;                    for (int gs = 0; gs < this.nMTF;)                  {                      /* Set group start & end marks. */                        /*                       * Calculate the cost of this group as coded by each of the                       * coding tables.                       */                        int ge = Math.Min(gs + BZip2.G_SIZE - 1' nMTFShadow - 1);                        if (nGroups == BZip2.NGroups)                      {                          // unrolled version of the else-block                            int[] c = new int[6];                            for (int i = gs; i <= ge; i++)                          {                              int icv = sfmap[i];                              c[0] += len_0[icv] & 0xff;                              c[1] += len_1[icv] & 0xff;                              c[2] += len_2[icv] & 0xff;                              c[3] += len_3[icv] & 0xff;                              c[4] += len_4[icv] & 0xff;                              c[5] += len_5[icv] & 0xff;                          }                            cost[0] = (short) c[0];                          cost[1] = (short) c[1];                          cost[2] = (short) c[2];                          cost[3] = (short) c[3];                          cost[4] = (short) c[4];                          cost[5] = (short) c[5];                      }                      else                      {                          for (int t = nGroups; --t >= 0;)                          {                              cost[t] = 0;                          }                            for (int i = gs; i <= ge; i++)                          {                              int icv = sfmap[i];                              for (int t = nGroups; --t >= 0;)                              {                                  cost[t] += (short) (len[t][icv] & 0xff);                              }                          }                      }                        /*                       * Find the coding table which is best for this group' and                       * record its identity in the selector table.                       */                      int bt = -1;                      for (int t = nGroups' bc = 999999999; --t >= 0;)                      {                          int cost_t = cost[t];                          if (cost_t < bc)                          {                              bc = cost_t;                              bt = t;                          }                      }                        fave[bt]++;                      selector[nSelectors] = (byte) bt;                      nSelectors++;                        /*                       * Increment the symbol frequencies for the selected table.                       */                      int[] rfreq_bt = rfreq[bt];                      for (int i = gs; i <= ge; i++)                      {                          rfreq_bt[sfmap[i]]++;                      }                        gs = ge + 1;                  }                    /*                   * Recompute the tables based on the accumulated frequencies.                   */                  for (int t = 0; t < nGroups; t++)                  {                      hbMakeCodeLengths(len[t]' rfreq[t]' this.cstate' alphaSize' 20);                  }              }
Magic Number,Ionic.BZip2,BZip2Compressor,C:\repos\haf_DotNetZip.Semverd\src\BZip2\BZip2Compressor.cs,sendMTFValues1,The following statement contains a magic number: for (int iter = 0; iter < BZip2.N_ITERS; iter++)              {                  for (int t = nGroups; --t >= 0;)                  {                      fave[t] = 0;                      int[] rfreqt = rfreq[t];                      for (int i = alphaSize; --i >= 0;)                      {                          rfreqt[i] = 0;                      }                  }                    nSelectors = 0;                    for (int gs = 0; gs < this.nMTF;)                  {                      /* Set group start & end marks. */                        /*                       * Calculate the cost of this group as coded by each of the                       * coding tables.                       */                        int ge = Math.Min(gs + BZip2.G_SIZE - 1' nMTFShadow - 1);                        if (nGroups == BZip2.NGroups)                      {                          // unrolled version of the else-block                            int[] c = new int[6];                            for (int i = gs; i <= ge; i++)                          {                              int icv = sfmap[i];                              c[0] += len_0[icv] & 0xff;                              c[1] += len_1[icv] & 0xff;                              c[2] += len_2[icv] & 0xff;                              c[3] += len_3[icv] & 0xff;                              c[4] += len_4[icv] & 0xff;                              c[5] += len_5[icv] & 0xff;                          }                            cost[0] = (short) c[0];                          cost[1] = (short) c[1];                          cost[2] = (short) c[2];                          cost[3] = (short) c[3];                          cost[4] = (short) c[4];                          cost[5] = (short) c[5];                      }                      else                      {                          for (int t = nGroups; --t >= 0;)                          {                              cost[t] = 0;                          }                            for (int i = gs; i <= ge; i++)                          {                              int icv = sfmap[i];                              for (int t = nGroups; --t >= 0;)                              {                                  cost[t] += (short) (len[t][icv] & 0xff);                              }                          }                      }                        /*                       * Find the coding table which is best for this group' and                       * record its identity in the selector table.                       */                      int bt = -1;                      for (int t = nGroups' bc = 999999999; --t >= 0;)                      {                          int cost_t = cost[t];                          if (cost_t < bc)                          {                              bc = cost_t;                              bt = t;                          }                      }                        fave[bt]++;                      selector[nSelectors] = (byte) bt;                      nSelectors++;                        /*                       * Increment the symbol frequencies for the selected table.                       */                      int[] rfreq_bt = rfreq[bt];                      for (int i = gs; i <= ge; i++)                      {                          rfreq_bt[sfmap[i]]++;                      }                        gs = ge + 1;                  }                    /*                   * Recompute the tables based on the accumulated frequencies.                   */                  for (int t = 0; t < nGroups; t++)                  {                      hbMakeCodeLengths(len[t]' rfreq[t]' this.cstate' alphaSize' 20);                  }              }
Magic Number,Ionic.BZip2,BZip2Compressor,C:\repos\haf_DotNetZip.Semverd\src\BZip2\BZip2Compressor.cs,sendMTFValues3,The following statement contains a magic number: for (int t = 0; t < nGroups; t++)              {                  int minLen = 32;                  int maxLen = 0;                  byte[] len_t = len[t];                  for (int i = alphaSize; --i >= 0;)                  {                      int l = len_t[i] & 0xff;                      if (l > maxLen)                      {                          maxLen = l;                      }                      if (l < minLen)                      {                          minLen = l;                      }                  }                    // assert (maxLen <= 20) : maxLen;                  // assert (minLen >= 1) : minLen;                    hbAssignCodes(code[t]' len[t]' minLen' maxLen' alphaSize);              }
Magic Number,Ionic.BZip2,BZip2Compressor,C:\repos\haf_DotNetZip.Semverd\src\BZip2\BZip2Compressor.cs,sendMTFValues4,The following statement contains a magic number: for (int i = 16; --i >= 0;)              {                  inUse16[i] = false;                  int i16 = i * 16;                  for (int j = 16; --j >= 0;)                  {                      if (inUse[i16 + j])                      {                          inUse16[i] = true;                      }                  }              }
Magic Number,Ionic.BZip2,BZip2Compressor,C:\repos\haf_DotNetZip.Semverd\src\BZip2\BZip2Compressor.cs,sendMTFValues4,The following statement contains a magic number: for (int i = 16; --i >= 0;)              {                  inUse16[i] = false;                  int i16 = i * 16;                  for (int j = 16; --j >= 0;)                  {                      if (inUse[i16 + j])                      {                          inUse16[i] = true;                      }                  }              }
Magic Number,Ionic.BZip2,BZip2Compressor,C:\repos\haf_DotNetZip.Semverd\src\BZip2\BZip2Compressor.cs,sendMTFValues4,The following statement contains a magic number: for (int i = 16; --i >= 0;)              {                  inUse16[i] = false;                  int i16 = i * 16;                  for (int j = 16; --j >= 0;)                  {                      if (inUse[i16 + j])                      {                          inUse16[i] = true;                      }                  }              }
Magic Number,Ionic.BZip2,BZip2Compressor,C:\repos\haf_DotNetZip.Semverd\src\BZip2\BZip2Compressor.cs,sendMTFValues4,The following statement contains a magic number: for (int i = 0; i < 16; i++)              {                  if (inUse16[i])                      u |= 1U << (16 - i - 1);              }
Magic Number,Ionic.BZip2,BZip2Compressor,C:\repos\haf_DotNetZip.Semverd\src\BZip2\BZip2Compressor.cs,sendMTFValues4,The following statement contains a magic number: for (int i = 0; i < 16; i++)              {                  if (inUse16[i])                      u |= 1U << (16 - i - 1);              }
Magic Number,Ionic.BZip2,BZip2Compressor,C:\repos\haf_DotNetZip.Semverd\src\BZip2\BZip2Compressor.cs,sendMTFValues4,The following statement contains a magic number: this.bw.WriteBits(16' u);
Magic Number,Ionic.BZip2,BZip2Compressor,C:\repos\haf_DotNetZip.Semverd\src\BZip2\BZip2Compressor.cs,sendMTFValues4,The following statement contains a magic number: for (int i = 0; i < 16; i++)              {                  if (inUse16[i])                  {                      int i16 = i * 16;                      u = 0;                      for (int j = 0; j < 16; j++)                      {                          if (inUse[i16 + j])                          {                              u |= 1U << (16 - j - 1);                          }                      }                      this.bw.WriteBits(16' u);                  }              }
Magic Number,Ionic.BZip2,BZip2Compressor,C:\repos\haf_DotNetZip.Semverd\src\BZip2\BZip2Compressor.cs,sendMTFValues4,The following statement contains a magic number: for (int i = 0; i < 16; i++)              {                  if (inUse16[i])                  {                      int i16 = i * 16;                      u = 0;                      for (int j = 0; j < 16; j++)                      {                          if (inUse[i16 + j])                          {                              u |= 1U << (16 - j - 1);                          }                      }                      this.bw.WriteBits(16' u);                  }              }
Magic Number,Ionic.BZip2,BZip2Compressor,C:\repos\haf_DotNetZip.Semverd\src\BZip2\BZip2Compressor.cs,sendMTFValues4,The following statement contains a magic number: for (int i = 0; i < 16; i++)              {                  if (inUse16[i])                  {                      int i16 = i * 16;                      u = 0;                      for (int j = 0; j < 16; j++)                      {                          if (inUse[i16 + j])                          {                              u |= 1U << (16 - j - 1);                          }                      }                      this.bw.WriteBits(16' u);                  }              }
Magic Number,Ionic.BZip2,BZip2Compressor,C:\repos\haf_DotNetZip.Semverd\src\BZip2\BZip2Compressor.cs,sendMTFValues4,The following statement contains a magic number: for (int i = 0; i < 16; i++)              {                  if (inUse16[i])                  {                      int i16 = i * 16;                      u = 0;                      for (int j = 0; j < 16; j++)                      {                          if (inUse[i16 + j])                          {                              u |= 1U << (16 - j - 1);                          }                      }                      this.bw.WriteBits(16' u);                  }              }
Magic Number,Ionic.BZip2,BZip2Compressor,C:\repos\haf_DotNetZip.Semverd\src\BZip2\BZip2Compressor.cs,sendMTFValues4,The following statement contains a magic number: for (int i = 0; i < 16; i++)              {                  if (inUse16[i])                  {                      int i16 = i * 16;                      u = 0;                      for (int j = 0; j < 16; j++)                      {                          if (inUse[i16 + j])                          {                              u |= 1U << (16 - j - 1);                          }                      }                      this.bw.WriteBits(16' u);                  }              }
Magic Number,Ionic.BZip2,BZip2Compressor,C:\repos\haf_DotNetZip.Semverd\src\BZip2\BZip2Compressor.cs,sendMTFValues5,The following statement contains a magic number: this.bw.WriteBits(3' (uint) nGroups);
Magic Number,Ionic.BZip2,BZip2Compressor,C:\repos\haf_DotNetZip.Semverd\src\BZip2\BZip2Compressor.cs,sendMTFValues5,The following statement contains a magic number: this.bw.WriteBits(15' (uint) nSelectors);
Magic Number,Ionic.BZip2,BZip2Compressor,C:\repos\haf_DotNetZip.Semverd\src\BZip2\BZip2Compressor.cs,sendMTFValues6,The following statement contains a magic number: for (int t = 0; t < nGroups; t++)              {                  byte[] len_t = len[t];                  uint curr = (uint) (len_t[0] & 0xff);                  this.bw.WriteBits(5' curr);                    for (int i = 0; i < alphaSize; i++)                  {                      int lti = len_t[i] & 0xff;                      while (curr < lti)                      {                          this.bw.WriteBits(2' 2U);                          curr++; /* 10 */                      }                        while (curr > lti)                      {                          this.bw.WriteBits(2' 3U);                          curr--; /* 11 */                      }                        this.bw.WriteBits(1' 0U);                  }              }
Magic Number,Ionic.BZip2,BZip2Compressor,C:\repos\haf_DotNetZip.Semverd\src\BZip2\BZip2Compressor.cs,sendMTFValues6,The following statement contains a magic number: for (int t = 0; t < nGroups; t++)              {                  byte[] len_t = len[t];                  uint curr = (uint) (len_t[0] & 0xff);                  this.bw.WriteBits(5' curr);                    for (int i = 0; i < alphaSize; i++)                  {                      int lti = len_t[i] & 0xff;                      while (curr < lti)                      {                          this.bw.WriteBits(2' 2U);                          curr++; /* 10 */                      }                        while (curr > lti)                      {                          this.bw.WriteBits(2' 3U);                          curr--; /* 11 */                      }                        this.bw.WriteBits(1' 0U);                  }              }
Magic Number,Ionic.BZip2,BZip2Compressor,C:\repos\haf_DotNetZip.Semverd\src\BZip2\BZip2Compressor.cs,sendMTFValues6,The following statement contains a magic number: for (int t = 0; t < nGroups; t++)              {                  byte[] len_t = len[t];                  uint curr = (uint) (len_t[0] & 0xff);                  this.bw.WriteBits(5' curr);                    for (int i = 0; i < alphaSize; i++)                  {                      int lti = len_t[i] & 0xff;                      while (curr < lti)                      {                          this.bw.WriteBits(2' 2U);                          curr++; /* 10 */                      }                        while (curr > lti)                      {                          this.bw.WriteBits(2' 3U);                          curr--; /* 11 */                      }                        this.bw.WriteBits(1' 0U);                  }              }
Magic Number,Ionic.BZip2,BZip2Compressor,C:\repos\haf_DotNetZip.Semverd\src\BZip2\BZip2Compressor.cs,moveToFrontCodeAndSend,The following statement contains a magic number: this.bw.WriteBits(24' (uint) this.origPtr);
Magic Number,Ionic.BZip2,CompressionState,C:\repos\haf_DotNetZip.Semverd\src\BZip2\BZip2Compressor.cs,CompressionState,The following statement contains a magic number: this.sfmap = new char[2 * n];
Magic Number,Ionic.BZip2,BZip2OutputStream,C:\repos\haf_DotNetZip.Semverd\src\BZip2\BZip2OutputStream.cs,Finish,The following statement contains a magic number: try              {                  var totalBefore = this.bw.TotalBytesWrittenOut;                  this.compressor.CompressAndWrite();                  TraceOutput(TraceBits.Write'"out block length (bytes): {0} (0x{0:X})"'                              this.bw.TotalBytesWrittenOut - totalBefore);                    TraceOutput(TraceBits.Crc' " combined CRC (before): {0:X8}"'                              this.combinedCRC);                  this.combinedCRC = (this.combinedCRC << 1) | (this.combinedCRC >> 31);                  this.combinedCRC ^= (uint) compressor.Crc32;                  TraceOutput(TraceBits.Crc' " block    CRC         : {0:X8}"'                              this.compressor.Crc32);                  TraceOutput(TraceBits.Crc' " combined CRC (final) : {0:X8}"'                              this.combinedCRC);                    EmitTrailer();              }              finally              {                  this.output = null;                  this.compressor = null;                  this.bw = null;              }
Magic Number,Ionic.BZip2,BZip2OutputStream,C:\repos\haf_DotNetZip.Semverd\src\BZip2\BZip2OutputStream.cs,Write,The following statement contains a magic number: do              {                  int n = compressor.Fill(buffer' offset' bytesRemaining);                  if (n != bytesRemaining)                  {                      // The compressor data block is full.  Compress and                      // write out the compressed data' then reset the                      // compressor and continue.                        var totalBefore = this.bw.TotalBytesWrittenOut;                      this.compressor.CompressAndWrite();                      TraceOutput(TraceBits.Write'"out block length (bytes): {0} (0x{0:X})"'                                  this.bw.TotalBytesWrittenOut - totalBefore);                                // and now any remaining bits                              TraceOutput(TraceBits.Write'                                          " remaining: {0} 0x{1:X}"'                                          this.bw.NumRemainingBits'                                          this.bw.RemainingBits);                        TraceOutput(TraceBits.Crc' " combined CRC (before): {0:X8}"'                                  this.combinedCRC);                      this.combinedCRC = (this.combinedCRC << 1) | (this.combinedCRC >> 31);                      this.combinedCRC ^= (uint) compressor.Crc32;                      TraceOutput(TraceBits.Crc' " block    CRC         : {0:X8}"'                                  compressor.Crc32);                      TraceOutput(TraceBits.Crc' " combined CRC (after) : {0:X8}"'                                  this.combinedCRC);                      offset += n;                  }                  bytesRemaining -= n;                  bytesWritten += n;              } while (bytesRemaining > 0);
Magic Number,Ionic.BZip2,BZip2OutputStream,C:\repos\haf_DotNetZip.Semverd\src\BZip2\BZip2OutputStream.cs,TraceOutput,The following statement contains a magic number: if ((bits & this.desiredTrace) != 0)              {                  //lock(outputLock)                  {                      int tid = System.Threading.Thread.CurrentThread.GetHashCode();  #if !SILVERLIGHT && !NETCF                      Console.ForegroundColor = (ConsoleColor) (tid % 8 + 10);  #endif                      Console.Write("{0:000} PBOS "' tid);                      Console.WriteLine(format' varParams);  #if !SILVERLIGHT && !NETCF                      Console.ResetColor();  #endif                  }              }
Magic Number,Ionic.BZip2,BZip2OutputStream,C:\repos\haf_DotNetZip.Semverd\src\BZip2\BZip2OutputStream.cs,TraceOutput,The following statement contains a magic number: if ((bits & this.desiredTrace) != 0)              {                  //lock(outputLock)                  {                      int tid = System.Threading.Thread.CurrentThread.GetHashCode();  #if !SILVERLIGHT && !NETCF                      Console.ForegroundColor = (ConsoleColor) (tid % 8 + 10);  #endif                      Console.Write("{0:000} PBOS "' tid);                      Console.WriteLine(format' varParams);  #if !SILVERLIGHT && !NETCF                      Console.ResetColor();  #endif                  }              }
Magic Number,Ionic.BZip2,ParallelBZip2OutputStream,C:\repos\haf_DotNetZip.Semverd\src\BZip2\ParallelBZip2OutputStream.cs,ParallelBZip2OutputStream,The following statement contains a magic number: this.MaxWorkers = 16;
Magic Number,Ionic.BZip2,ParallelBZip2OutputStream,C:\repos\haf_DotNetZip.Semverd\src\BZip2\ParallelBZip2OutputStream.cs,EmitPendingBuffers,The following statement contains a magic number: do              {                  int firstSkip = -1;                  int millisecondsToWait = doAll ? 200 : (mustWait ? -1 : 0);                  int nextToWrite = -1;                    do                  {                      if (Monitor.TryEnter(this.toWrite' millisecondsToWait))                      {                          nextToWrite = -1;                          try                          {                              if (this.toWrite.Count > 0)                                  nextToWrite = this.toWrite.Dequeue();                          }                          finally                          {                              Monitor.Exit(this.toWrite);                          }                            if (nextToWrite >= 0)                          {                              WorkItem workitem = this.pool[nextToWrite];                              if (workitem.ordinal != this.lastWritten + 1)                              {                                  // out of order. requeue and try again.                                  lock(this.toWrite)                                  {                                      this.toWrite.Enqueue(nextToWrite);                                  }                                    if (firstSkip == nextToWrite)                                  {                                      // We went around the list once.                                      // None of the items in the list is the one we want.                                      // Now wait for a compressor to signal again.                                      this.newlyCompressedBlob.WaitOne();                                      firstSkip = -1;                                  }                                  else if (firstSkip == -1)                                      firstSkip = nextToWrite;                                    continue;                              }                                firstSkip = -1;                                TraceOutput(TraceBits.Write'                                          "Writing block {0}"' workitem.ordinal);                                // write the data to the output                              var bw2 = workitem.bw;                              bw2.Flush(); // not bw2.FinishAndPad()!                              var ms = workitem.ms;                              ms.Seek(0'SeekOrigin.Begin);                                // cannot dump bytes!!                              // ms.WriteTo(this.output);                              //                              // must do byte shredding:                              int n;                              int y = -1;                              long totOut = 0;                              var buffer = new byte[1024];                              while ((n = ms.Read(buffer'0'buffer.Length)) > 0)                              {  #if Trace                                  if (y == -1) // diagnostics only                                  {                                      var sb1 = new System.Text.StringBuilder();                                      sb1.Append("first 16 whole bytes in block: ");                                      for (int z=0; z < 16; z++)                                          sb1.Append(String.Format(" {0:X2}"' buffer[z]));                                      TraceOutput(TraceBits.Write' sb1.ToString());                                  }  #endif                                  y = n;                                  for (int k=0; k < n; k++)                                  {                                      this.bw.WriteByte(buffer[k]);                                  }                                  totOut += n;                              }  #if Trace                              TraceOutput(TraceBits.Write'"out block length (bytes): {0} (0x{0:X})"' totOut);                              var sb = new System.Text.StringBuilder();                              sb.Append("final 16 whole bytes in block: ");                              for (int z=0; z < 16; z++)                                  sb.Append(String.Format(" {0:X2}"' buffer[y-1-12+z]));                              TraceOutput(TraceBits.Write' sb.ToString());  #endif                                // and now any remaining bits                              TraceOutput(TraceBits.Write'                                          " remaining bits: {0} 0x{1:X}"'                                          bw2.NumRemainingBits'                                          bw2.RemainingBits);                              if (bw2.NumRemainingBits > 0)                              {                                  this.bw.WriteBits(bw2.NumRemainingBits' bw2.RemainingBits);                              }                                TraceOutput(TraceBits.Crc'" combined CRC (before): {0:X8}"'                                          this.combinedCRC);                              this.combinedCRC = (this.combinedCRC << 1) | (this.combinedCRC >> 31);                              this.combinedCRC ^= (uint) workitem.Compressor.Crc32;                                TraceOutput(TraceBits.Crc'                                          " block    CRC         : {0:X8}"'                                          workitem.Compressor.Crc32);                              TraceOutput(TraceBits.Crc'                                          " combined CRC (after) : {0:X8}"'                                          this.combinedCRC);                              TraceOutput(TraceBits.Write'                                          "total written out: {0} (0x{0:X})"'                                          this.bw.TotalBytesWrittenOut);                              TraceOutput(TraceBits.Write | TraceBits.Crc' "");                                this.totalBytesWrittenOut += totOut;                                bw2.Reset();                              this.lastWritten = workitem.ordinal;                              workitem.ordinal = -1;                              this.toFill.Enqueue(workitem.index);                                // don't wait next time through                              if (millisecondsToWait == -1) millisecondsToWait = 0;                          }                      }                      else                          nextToWrite = -1;                    } while (nextToWrite >= 0);                } while (doAll && (this.lastWritten != this.latestCompressed));
Magic Number,Ionic.BZip2,ParallelBZip2OutputStream,C:\repos\haf_DotNetZip.Semverd\src\BZip2\ParallelBZip2OutputStream.cs,EmitPendingBuffers,The following statement contains a magic number: do              {                  int firstSkip = -1;                  int millisecondsToWait = doAll ? 200 : (mustWait ? -1 : 0);                  int nextToWrite = -1;                    do                  {                      if (Monitor.TryEnter(this.toWrite' millisecondsToWait))                      {                          nextToWrite = -1;                          try                          {                              if (this.toWrite.Count > 0)                                  nextToWrite = this.toWrite.Dequeue();                          }                          finally                          {                              Monitor.Exit(this.toWrite);                          }                            if (nextToWrite >= 0)                          {                              WorkItem workitem = this.pool[nextToWrite];                              if (workitem.ordinal != this.lastWritten + 1)                              {                                  // out of order. requeue and try again.                                  lock(this.toWrite)                                  {                                      this.toWrite.Enqueue(nextToWrite);                                  }                                    if (firstSkip == nextToWrite)                                  {                                      // We went around the list once.                                      // None of the items in the list is the one we want.                                      // Now wait for a compressor to signal again.                                      this.newlyCompressedBlob.WaitOne();                                      firstSkip = -1;                                  }                                  else if (firstSkip == -1)                                      firstSkip = nextToWrite;                                    continue;                              }                                firstSkip = -1;                                TraceOutput(TraceBits.Write'                                          "Writing block {0}"' workitem.ordinal);                                // write the data to the output                              var bw2 = workitem.bw;                              bw2.Flush(); // not bw2.FinishAndPad()!                              var ms = workitem.ms;                              ms.Seek(0'SeekOrigin.Begin);                                // cannot dump bytes!!                              // ms.WriteTo(this.output);                              //                              // must do byte shredding:                              int n;                              int y = -1;                              long totOut = 0;                              var buffer = new byte[1024];                              while ((n = ms.Read(buffer'0'buffer.Length)) > 0)                              {  #if Trace                                  if (y == -1) // diagnostics only                                  {                                      var sb1 = new System.Text.StringBuilder();                                      sb1.Append("first 16 whole bytes in block: ");                                      for (int z=0; z < 16; z++)                                          sb1.Append(String.Format(" {0:X2}"' buffer[z]));                                      TraceOutput(TraceBits.Write' sb1.ToString());                                  }  #endif                                  y = n;                                  for (int k=0; k < n; k++)                                  {                                      this.bw.WriteByte(buffer[k]);                                  }                                  totOut += n;                              }  #if Trace                              TraceOutput(TraceBits.Write'"out block length (bytes): {0} (0x{0:X})"' totOut);                              var sb = new System.Text.StringBuilder();                              sb.Append("final 16 whole bytes in block: ");                              for (int z=0; z < 16; z++)                                  sb.Append(String.Format(" {0:X2}"' buffer[y-1-12+z]));                              TraceOutput(TraceBits.Write' sb.ToString());  #endif                                // and now any remaining bits                              TraceOutput(TraceBits.Write'                                          " remaining bits: {0} 0x{1:X}"'                                          bw2.NumRemainingBits'                                          bw2.RemainingBits);                              if (bw2.NumRemainingBits > 0)                              {                                  this.bw.WriteBits(bw2.NumRemainingBits' bw2.RemainingBits);                              }                                TraceOutput(TraceBits.Crc'" combined CRC (before): {0:X8}"'                                          this.combinedCRC);                              this.combinedCRC = (this.combinedCRC << 1) | (this.combinedCRC >> 31);                              this.combinedCRC ^= (uint) workitem.Compressor.Crc32;                                TraceOutput(TraceBits.Crc'                                          " block    CRC         : {0:X8}"'                                          workitem.Compressor.Crc32);                              TraceOutput(TraceBits.Crc'                                          " combined CRC (after) : {0:X8}"'                                          this.combinedCRC);                              TraceOutput(TraceBits.Write'                                          "total written out: {0} (0x{0:X})"'                                          this.bw.TotalBytesWrittenOut);                              TraceOutput(TraceBits.Write | TraceBits.Crc' "");                                this.totalBytesWrittenOut += totOut;                                bw2.Reset();                              this.lastWritten = workitem.ordinal;                              workitem.ordinal = -1;                              this.toFill.Enqueue(workitem.index);                                // don't wait next time through                              if (millisecondsToWait == -1) millisecondsToWait = 0;                          }                      }                      else                          nextToWrite = -1;                    } while (nextToWrite >= 0);                } while (doAll && (this.lastWritten != this.latestCompressed));
Magic Number,Ionic.BZip2,ParallelBZip2OutputStream,C:\repos\haf_DotNetZip.Semverd\src\BZip2\ParallelBZip2OutputStream.cs,EmitPendingBuffers,The following statement contains a magic number: do              {                  int firstSkip = -1;                  int millisecondsToWait = doAll ? 200 : (mustWait ? -1 : 0);                  int nextToWrite = -1;                    do                  {                      if (Monitor.TryEnter(this.toWrite' millisecondsToWait))                      {                          nextToWrite = -1;                          try                          {                              if (this.toWrite.Count > 0)                                  nextToWrite = this.toWrite.Dequeue();                          }                          finally                          {                              Monitor.Exit(this.toWrite);                          }                            if (nextToWrite >= 0)                          {                              WorkItem workitem = this.pool[nextToWrite];                              if (workitem.ordinal != this.lastWritten + 1)                              {                                  // out of order. requeue and try again.                                  lock(this.toWrite)                                  {                                      this.toWrite.Enqueue(nextToWrite);                                  }                                    if (firstSkip == nextToWrite)                                  {                                      // We went around the list once.                                      // None of the items in the list is the one we want.                                      // Now wait for a compressor to signal again.                                      this.newlyCompressedBlob.WaitOne();                                      firstSkip = -1;                                  }                                  else if (firstSkip == -1)                                      firstSkip = nextToWrite;                                    continue;                              }                                firstSkip = -1;                                TraceOutput(TraceBits.Write'                                          "Writing block {0}"' workitem.ordinal);                                // write the data to the output                              var bw2 = workitem.bw;                              bw2.Flush(); // not bw2.FinishAndPad()!                              var ms = workitem.ms;                              ms.Seek(0'SeekOrigin.Begin);                                // cannot dump bytes!!                              // ms.WriteTo(this.output);                              //                              // must do byte shredding:                              int n;                              int y = -1;                              long totOut = 0;                              var buffer = new byte[1024];                              while ((n = ms.Read(buffer'0'buffer.Length)) > 0)                              {  #if Trace                                  if (y == -1) // diagnostics only                                  {                                      var sb1 = new System.Text.StringBuilder();                                      sb1.Append("first 16 whole bytes in block: ");                                      for (int z=0; z < 16; z++)                                          sb1.Append(String.Format(" {0:X2}"' buffer[z]));                                      TraceOutput(TraceBits.Write' sb1.ToString());                                  }  #endif                                  y = n;                                  for (int k=0; k < n; k++)                                  {                                      this.bw.WriteByte(buffer[k]);                                  }                                  totOut += n;                              }  #if Trace                              TraceOutput(TraceBits.Write'"out block length (bytes): {0} (0x{0:X})"' totOut);                              var sb = new System.Text.StringBuilder();                              sb.Append("final 16 whole bytes in block: ");                              for (int z=0; z < 16; z++)                                  sb.Append(String.Format(" {0:X2}"' buffer[y-1-12+z]));                              TraceOutput(TraceBits.Write' sb.ToString());  #endif                                // and now any remaining bits                              TraceOutput(TraceBits.Write'                                          " remaining bits: {0} 0x{1:X}"'                                          bw2.NumRemainingBits'                                          bw2.RemainingBits);                              if (bw2.NumRemainingBits > 0)                              {                                  this.bw.WriteBits(bw2.NumRemainingBits' bw2.RemainingBits);                              }                                TraceOutput(TraceBits.Crc'" combined CRC (before): {0:X8}"'                                          this.combinedCRC);                              this.combinedCRC = (this.combinedCRC << 1) | (this.combinedCRC >> 31);                              this.combinedCRC ^= (uint) workitem.Compressor.Crc32;                                TraceOutput(TraceBits.Crc'                                          " block    CRC         : {0:X8}"'                                          workitem.Compressor.Crc32);                              TraceOutput(TraceBits.Crc'                                          " combined CRC (after) : {0:X8}"'                                          this.combinedCRC);                              TraceOutput(TraceBits.Write'                                          "total written out: {0} (0x{0:X})"'                                          this.bw.TotalBytesWrittenOut);                              TraceOutput(TraceBits.Write | TraceBits.Crc' "");                                this.totalBytesWrittenOut += totOut;                                bw2.Reset();                              this.lastWritten = workitem.ordinal;                              workitem.ordinal = -1;                              this.toFill.Enqueue(workitem.index);                                // don't wait next time through                              if (millisecondsToWait == -1) millisecondsToWait = 0;                          }                      }                      else                          nextToWrite = -1;                    } while (nextToWrite >= 0);                } while (doAll && (this.lastWritten != this.latestCompressed));
Magic Number,Ionic.BZip2,ParallelBZip2OutputStream,C:\repos\haf_DotNetZip.Semverd\src\BZip2\ParallelBZip2OutputStream.cs,TraceOutput,The following statement contains a magic number: if ((bits & this.desiredTrace) != 0)              {                  lock(outputLock)                  {                      int tid = Thread.CurrentThread.GetHashCode();  #if !SILVERLIGHT                      Console.ForegroundColor = (ConsoleColor) (tid % 8 + 10);  #endif                      Console.Write("{0:000} PBOS "' tid);                      Console.WriteLine(format' varParams);  #if !SILVERLIGHT                      Console.ResetColor();  #endif                  }              }
Magic Number,Ionic.BZip2,ParallelBZip2OutputStream,C:\repos\haf_DotNetZip.Semverd\src\BZip2\ParallelBZip2OutputStream.cs,TraceOutput,The following statement contains a magic number: if ((bits & this.desiredTrace) != 0)              {                  lock(outputLock)                  {                      int tid = Thread.CurrentThread.GetHashCode();  #if !SILVERLIGHT                      Console.ForegroundColor = (ConsoleColor) (tid % 8 + 10);  #endif                      Console.Write("{0:000} PBOS "' tid);                      Console.WriteLine(format' varParams);  #if !SILVERLIGHT                      Console.ResetColor();  #endif                  }              }
Magic Number,Ionic.BZip2,BitWriter,C:\repos\haf_DotNetZip.Semverd\src\BZip2\BitWriter.cs,WriteBits,The following statement contains a magic number: while (nAccumulated >= 8)              {                  this.output.WriteByte ((byte)(u >> 24 & 0xff));                  this.totalBytesWrittenOut++;                  u <<= 8;                  nAccumulated -= 8;              }
Magic Number,Ionic.BZip2,BitWriter,C:\repos\haf_DotNetZip.Semverd\src\BZip2\BitWriter.cs,WriteBits,The following statement contains a magic number: while (nAccumulated >= 8)              {                  this.output.WriteByte ((byte)(u >> 24 & 0xff));                  this.totalBytesWrittenOut++;                  u <<= 8;                  nAccumulated -= 8;              }
Magic Number,Ionic.BZip2,BitWriter,C:\repos\haf_DotNetZip.Semverd\src\BZip2\BitWriter.cs,WriteBits,The following statement contains a magic number: while (nAccumulated >= 8)              {                  this.output.WriteByte ((byte)(u >> 24 & 0xff));                  this.totalBytesWrittenOut++;                  u <<= 8;                  nAccumulated -= 8;              }
Magic Number,Ionic.BZip2,BitWriter,C:\repos\haf_DotNetZip.Semverd\src\BZip2\BitWriter.cs,WriteBits,The following statement contains a magic number: while (nAccumulated >= 8)              {                  this.output.WriteByte ((byte)(u >> 24 & 0xff));                  this.totalBytesWrittenOut++;                  u <<= 8;                  nAccumulated -= 8;              }
Magic Number,Ionic.BZip2,BitWriter,C:\repos\haf_DotNetZip.Semverd\src\BZip2\BitWriter.cs,WriteBits,The following statement contains a magic number: this.accumulator = u | (value << (32 - nAccumulated - nbits));
Magic Number,Ionic.BZip2,BitWriter,C:\repos\haf_DotNetZip.Semverd\src\BZip2\BitWriter.cs,WriteByte,The following statement contains a magic number: WriteBits(8' b);
Magic Number,Ionic.BZip2,BitWriter,C:\repos\haf_DotNetZip.Semverd\src\BZip2\BitWriter.cs,WriteInt,The following statement contains a magic number: WriteBits(8' (u >> 24) & 0xff);
Magic Number,Ionic.BZip2,BitWriter,C:\repos\haf_DotNetZip.Semverd\src\BZip2\BitWriter.cs,WriteInt,The following statement contains a magic number: WriteBits(8' (u >> 24) & 0xff);
Magic Number,Ionic.BZip2,BitWriter,C:\repos\haf_DotNetZip.Semverd\src\BZip2\BitWriter.cs,WriteInt,The following statement contains a magic number: WriteBits(8' (u >> 16) & 0xff);
Magic Number,Ionic.BZip2,BitWriter,C:\repos\haf_DotNetZip.Semverd\src\BZip2\BitWriter.cs,WriteInt,The following statement contains a magic number: WriteBits(8' (u >> 16) & 0xff);
Magic Number,Ionic.BZip2,BitWriter,C:\repos\haf_DotNetZip.Semverd\src\BZip2\BitWriter.cs,WriteInt,The following statement contains a magic number: WriteBits(8' (u >> 8) & 0xff);
Magic Number,Ionic.BZip2,BitWriter,C:\repos\haf_DotNetZip.Semverd\src\BZip2\BitWriter.cs,WriteInt,The following statement contains a magic number: WriteBits(8' (u >> 8) & 0xff);
Magic Number,Ionic.BZip2,BitWriter,C:\repos\haf_DotNetZip.Semverd\src\BZip2\BitWriter.cs,WriteInt,The following statement contains a magic number: WriteBits(8' u & 0xff);
Magic Number,Ionic.BZip2,BitWriter,C:\repos\haf_DotNetZip.Semverd\src\BZip2\BitWriter.cs,FinishAndPad,The following statement contains a magic number: if (this.NumRemainingBits > 0)              {                  byte b = (byte)((this.accumulator >> 24) & 0xff);                  this.output.WriteByte(b);                  this.totalBytesWrittenOut++;              }
Magic Number,Ionic.Crc,CRC32,C:\repos\haf_DotNetZip.Semverd\src\CommonSrc\CRC32.cs,_InternalComputeCrc32,The following statement contains a magic number: return (Int32)(crc32Table[(W ^ B) & 0xFF] ^ (W >> 8));
Magic Number,Ionic.Crc,CRC32,C:\repos\haf_DotNetZip.Semverd\src\CommonSrc\CRC32.cs,SlurpBlock,The following statement contains a magic number: for (int i = 0; i < count; i++)              {                  int x = offset + i;                  byte b = block[x];                  if (this.reverseBits)                  {                      UInt32 temp = (_register >> 24) ^ b;                      _register = (_register << 8) ^ crc32Table[temp];                  }                  else                  {                      UInt32 temp = (_register & 0x000000FF) ^ b;                      _register = (_register >> 8) ^ crc32Table[temp];                  }              }
Magic Number,Ionic.Crc,CRC32,C:\repos\haf_DotNetZip.Semverd\src\CommonSrc\CRC32.cs,SlurpBlock,The following statement contains a magic number: for (int i = 0; i < count; i++)              {                  int x = offset + i;                  byte b = block[x];                  if (this.reverseBits)                  {                      UInt32 temp = (_register >> 24) ^ b;                      _register = (_register << 8) ^ crc32Table[temp];                  }                  else                  {                      UInt32 temp = (_register & 0x000000FF) ^ b;                      _register = (_register >> 8) ^ crc32Table[temp];                  }              }
Magic Number,Ionic.Crc,CRC32,C:\repos\haf_DotNetZip.Semverd\src\CommonSrc\CRC32.cs,SlurpBlock,The following statement contains a magic number: for (int i = 0; i < count; i++)              {                  int x = offset + i;                  byte b = block[x];                  if (this.reverseBits)                  {                      UInt32 temp = (_register >> 24) ^ b;                      _register = (_register << 8) ^ crc32Table[temp];                  }                  else                  {                      UInt32 temp = (_register & 0x000000FF) ^ b;                      _register = (_register >> 8) ^ crc32Table[temp];                  }              }
Magic Number,Ionic.Crc,CRC32,C:\repos\haf_DotNetZip.Semverd\src\CommonSrc\CRC32.cs,UpdateCRC,The following statement contains a magic number: if (this.reverseBits)              {                  UInt32 temp = (_register >> 24) ^ b;                  _register = (_register << 8) ^ crc32Table[temp];              }              else              {                  UInt32 temp = (_register & 0x000000FF) ^ b;                  _register = (_register >> 8) ^ crc32Table[temp];              }
Magic Number,Ionic.Crc,CRC32,C:\repos\haf_DotNetZip.Semverd\src\CommonSrc\CRC32.cs,UpdateCRC,The following statement contains a magic number: if (this.reverseBits)              {                  UInt32 temp = (_register >> 24) ^ b;                  _register = (_register << 8) ^ crc32Table[temp];              }              else              {                  UInt32 temp = (_register & 0x000000FF) ^ b;                  _register = (_register >> 8) ^ crc32Table[temp];              }
Magic Number,Ionic.Crc,CRC32,C:\repos\haf_DotNetZip.Semverd\src\CommonSrc\CRC32.cs,UpdateCRC,The following statement contains a magic number: if (this.reverseBits)              {                  UInt32 temp = (_register >> 24) ^ b;                  _register = (_register << 8) ^ crc32Table[temp];              }              else              {                  UInt32 temp = (_register & 0x000000FF) ^ b;                  _register = (_register >> 8) ^ crc32Table[temp];              }
Magic Number,Ionic.Crc,CRC32,C:\repos\haf_DotNetZip.Semverd\src\CommonSrc\CRC32.cs,UpdateCRC,The following statement contains a magic number: while (n-- > 0)              {                  if (this.reverseBits)                  {                      uint temp = (_register >> 24) ^ b;                      _register = (_register << 8) ^ crc32Table[(temp >= 0)                                                                ? temp                                                                : (temp + 256)];                  }                  else                  {                      UInt32 temp = (_register & 0x000000FF) ^ b;                      _register = (_register >> 8) ^ crc32Table[(temp >= 0)                                                                ? temp                                                                : (temp + 256)];                    }              }
Magic Number,Ionic.Crc,CRC32,C:\repos\haf_DotNetZip.Semverd\src\CommonSrc\CRC32.cs,UpdateCRC,The following statement contains a magic number: while (n-- > 0)              {                  if (this.reverseBits)                  {                      uint temp = (_register >> 24) ^ b;                      _register = (_register << 8) ^ crc32Table[(temp >= 0)                                                                ? temp                                                                : (temp + 256)];                  }                  else                  {                      UInt32 temp = (_register & 0x000000FF) ^ b;                      _register = (_register >> 8) ^ crc32Table[(temp >= 0)                                                                ? temp                                                                : (temp + 256)];                    }              }
Magic Number,Ionic.Crc,CRC32,C:\repos\haf_DotNetZip.Semverd\src\CommonSrc\CRC32.cs,UpdateCRC,The following statement contains a magic number: while (n-- > 0)              {                  if (this.reverseBits)                  {                      uint temp = (_register >> 24) ^ b;                      _register = (_register << 8) ^ crc32Table[(temp >= 0)                                                                ? temp                                                                : (temp + 256)];                  }                  else                  {                      UInt32 temp = (_register & 0x000000FF) ^ b;                      _register = (_register >> 8) ^ crc32Table[(temp >= 0)                                                                ? temp                                                                : (temp + 256)];                    }              }
Magic Number,Ionic.Crc,CRC32,C:\repos\haf_DotNetZip.Semverd\src\CommonSrc\CRC32.cs,UpdateCRC,The following statement contains a magic number: while (n-- > 0)              {                  if (this.reverseBits)                  {                      uint temp = (_register >> 24) ^ b;                      _register = (_register << 8) ^ crc32Table[(temp >= 0)                                                                ? temp                                                                : (temp + 256)];                  }                  else                  {                      UInt32 temp = (_register & 0x000000FF) ^ b;                      _register = (_register >> 8) ^ crc32Table[(temp >= 0)                                                                ? temp                                                                : (temp + 256)];                    }              }
Magic Number,Ionic.Crc,CRC32,C:\repos\haf_DotNetZip.Semverd\src\CommonSrc\CRC32.cs,UpdateCRC,The following statement contains a magic number: while (n-- > 0)              {                  if (this.reverseBits)                  {                      uint temp = (_register >> 24) ^ b;                      _register = (_register << 8) ^ crc32Table[(temp >= 0)                                                                ? temp                                                                : (temp + 256)];                  }                  else                  {                      UInt32 temp = (_register & 0x000000FF) ^ b;                      _register = (_register >> 8) ^ crc32Table[(temp >= 0)                                                                ? temp                                                                : (temp + 256)];                    }              }
Magic Number,Ionic.Crc,CRC32,C:\repos\haf_DotNetZip.Semverd\src\CommonSrc\CRC32.cs,ReverseBits,The following statement contains a magic number: unchecked              {                  uint ret = data;                  ret = (ret & 0x55555555) << 1 | (ret >> 1) & 0x55555555;                  ret = (ret & 0x33333333) << 2 | (ret >> 2) & 0x33333333;                  ret = (ret & 0x0F0F0F0F) << 4 | (ret >> 4) & 0x0F0F0F0F;                  ret = (ret << 24) | ((ret & 0xFF00) << 8) | ((ret >> 8) & 0xFF00) | (ret >> 24);                  return ret;              }
Magic Number,Ionic.Crc,CRC32,C:\repos\haf_DotNetZip.Semverd\src\CommonSrc\CRC32.cs,ReverseBits,The following statement contains a magic number: unchecked              {                  uint ret = data;                  ret = (ret & 0x55555555) << 1 | (ret >> 1) & 0x55555555;                  ret = (ret & 0x33333333) << 2 | (ret >> 2) & 0x33333333;                  ret = (ret & 0x0F0F0F0F) << 4 | (ret >> 4) & 0x0F0F0F0F;                  ret = (ret << 24) | ((ret & 0xFF00) << 8) | ((ret >> 8) & 0xFF00) | (ret >> 24);                  return ret;              }
Magic Number,Ionic.Crc,CRC32,C:\repos\haf_DotNetZip.Semverd\src\CommonSrc\CRC32.cs,ReverseBits,The following statement contains a magic number: unchecked              {                  uint ret = data;                  ret = (ret & 0x55555555) << 1 | (ret >> 1) & 0x55555555;                  ret = (ret & 0x33333333) << 2 | (ret >> 2) & 0x33333333;                  ret = (ret & 0x0F0F0F0F) << 4 | (ret >> 4) & 0x0F0F0F0F;                  ret = (ret << 24) | ((ret & 0xFF00) << 8) | ((ret >> 8) & 0xFF00) | (ret >> 24);                  return ret;              }
Magic Number,Ionic.Crc,CRC32,C:\repos\haf_DotNetZip.Semverd\src\CommonSrc\CRC32.cs,ReverseBits,The following statement contains a magic number: unchecked              {                  uint ret = data;                  ret = (ret & 0x55555555) << 1 | (ret >> 1) & 0x55555555;                  ret = (ret & 0x33333333) << 2 | (ret >> 2) & 0x33333333;                  ret = (ret & 0x0F0F0F0F) << 4 | (ret >> 4) & 0x0F0F0F0F;                  ret = (ret << 24) | ((ret & 0xFF00) << 8) | ((ret >> 8) & 0xFF00) | (ret >> 24);                  return ret;              }
Magic Number,Ionic.Crc,CRC32,C:\repos\haf_DotNetZip.Semverd\src\CommonSrc\CRC32.cs,ReverseBits,The following statement contains a magic number: unchecked              {                  uint ret = data;                  ret = (ret & 0x55555555) << 1 | (ret >> 1) & 0x55555555;                  ret = (ret & 0x33333333) << 2 | (ret >> 2) & 0x33333333;                  ret = (ret & 0x0F0F0F0F) << 4 | (ret >> 4) & 0x0F0F0F0F;                  ret = (ret << 24) | ((ret & 0xFF00) << 8) | ((ret >> 8) & 0xFF00) | (ret >> 24);                  return ret;              }
Magic Number,Ionic.Crc,CRC32,C:\repos\haf_DotNetZip.Semverd\src\CommonSrc\CRC32.cs,ReverseBits,The following statement contains a magic number: unchecked              {                  uint ret = data;                  ret = (ret & 0x55555555) << 1 | (ret >> 1) & 0x55555555;                  ret = (ret & 0x33333333) << 2 | (ret >> 2) & 0x33333333;                  ret = (ret & 0x0F0F0F0F) << 4 | (ret >> 4) & 0x0F0F0F0F;                  ret = (ret << 24) | ((ret & 0xFF00) << 8) | ((ret >> 8) & 0xFF00) | (ret >> 24);                  return ret;              }
Magic Number,Ionic.Crc,CRC32,C:\repos\haf_DotNetZip.Semverd\src\CommonSrc\CRC32.cs,ReverseBits,The following statement contains a magic number: unchecked              {                  uint ret = data;                  ret = (ret & 0x55555555) << 1 | (ret >> 1) & 0x55555555;                  ret = (ret & 0x33333333) << 2 | (ret >> 2) & 0x33333333;                  ret = (ret & 0x0F0F0F0F) << 4 | (ret >> 4) & 0x0F0F0F0F;                  ret = (ret << 24) | ((ret & 0xFF00) << 8) | ((ret >> 8) & 0xFF00) | (ret >> 24);                  return ret;              }
Magic Number,Ionic.Crc,CRC32,C:\repos\haf_DotNetZip.Semverd\src\CommonSrc\CRC32.cs,ReverseBits,The following statement contains a magic number: unchecked              {                  uint ret = data;                  ret = (ret & 0x55555555) << 1 | (ret >> 1) & 0x55555555;                  ret = (ret & 0x33333333) << 2 | (ret >> 2) & 0x33333333;                  ret = (ret & 0x0F0F0F0F) << 4 | (ret >> 4) & 0x0F0F0F0F;                  ret = (ret << 24) | ((ret & 0xFF00) << 8) | ((ret >> 8) & 0xFF00) | (ret >> 24);                  return ret;              }
Magic Number,Ionic.Crc,CRC32,C:\repos\haf_DotNetZip.Semverd\src\CommonSrc\CRC32.cs,ReverseBits,The following statement contains a magic number: unchecked              {                  uint u = (uint)data * 0x00020202;                  uint m = 0x01044010;                  uint s = u & m;                  uint t = (u << 2) & (m << 1);                  return (byte)((0x01001001 * (s + t)) >> 24);              }
Magic Number,Ionic.Crc,CRC32,C:\repos\haf_DotNetZip.Semverd\src\CommonSrc\CRC32.cs,ReverseBits,The following statement contains a magic number: unchecked              {                  uint u = (uint)data * 0x00020202;                  uint m = 0x01044010;                  uint s = u & m;                  uint t = (u << 2) & (m << 1);                  return (byte)((0x01001001 * (s + t)) >> 24);              }
Magic Number,Ionic.Crc,CRC32,C:\repos\haf_DotNetZip.Semverd\src\CommonSrc\CRC32.cs,GenerateLookupTable,The following statement contains a magic number: crc32Table = new UInt32[256];
Magic Number,Ionic.Crc,CRC32,C:\repos\haf_DotNetZip.Semverd\src\CommonSrc\CRC32.cs,GenerateLookupTable,The following statement contains a magic number: unchecked              {                  UInt32 dwCrc;                  byte i = 0;                  do                  {                      dwCrc = i;                      for (byte j = 8; j > 0; j--)                      {                          if ((dwCrc & 1) == 1)                          {                              dwCrc = (dwCrc >> 1) ^ dwPolynomial;                          }                          else                          {                              dwCrc >>= 1;                          }                      }                      if (reverseBits)                      {                          crc32Table[ReverseBits(i)] = ReverseBits(dwCrc);                      }                      else                      {                          crc32Table[i] = dwCrc;                      }                      i++;                  } while (i!=0);              }
Magic Number,Ionic.Crc,CRC32,C:\repos\haf_DotNetZip.Semverd\src\CommonSrc\CRC32.cs,gf2_matrix_square,The following statement contains a magic number: for (int i = 0; i < 32; i++)                  square[i] = gf2_matrix_times(mat' mat[i]);
Magic Number,Ionic.Crc,CRC32,C:\repos\haf_DotNetZip.Semverd\src\CommonSrc\CRC32.cs,Combine,The following statement contains a magic number: uint[] even = new uint[32];
Magic Number,Ionic.Crc,CRC32,C:\repos\haf_DotNetZip.Semverd\src\CommonSrc\CRC32.cs,Combine,The following statement contains a magic number: uint[] odd = new uint[32];
Magic Number,Ionic.Crc,CRC32,C:\repos\haf_DotNetZip.Semverd\src\CommonSrc\CRC32.cs,Combine,The following statement contains a magic number: for (int i = 1; i < 32; i++)              {                  odd[i] = row;                  row <<= 1;              }
Duplicate Code,Ionic.BZip2,BZip2InputStream,C:\repos\haf_DotNetZip.Semverd\src\BZip2\BZip2InputStream.cs,getAndMoveToFrontDecode,The method contains a code clone-set at the following line numbers (starting from the method definition): ((59' 113)' (158' 212))
Duplicate Code,Ionic.BZip2,BZip2Compressor,C:\repos\haf_DotNetZip.Semverd\src\BZip2\BZip2Compressor.cs,generateMTFValues,The method contains a code clone-set at the following line numbers (starting from the method definition): ((60' 86)' (95' 121))
Duplicate Code,Ionic.BZip2,BZip2Compressor,C:\repos\haf_DotNetZip.Semverd\src\BZip2\BZip2Compressor.cs,hbMakeCodeLengths,The method contains a code clone-set at the following line numbers (starting from the method definition): ((50' 75)' (84' 109))
