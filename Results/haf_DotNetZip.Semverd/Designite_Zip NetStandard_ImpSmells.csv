Implementation smell,Namespace,Class,File,Method,Description
Long Method,Ionic.BZip2,BZip2Compressor,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\BZip2\BZip2Compressor.cs,mainSort,The method has 166 lines of code.
Long Method,Ionic.BZip2,BZip2Compressor,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\BZip2\BZip2Compressor.cs,mainSimpleSort,The method has 235 lines of code.
Long Method,Ionic.BZip2,BZip2Compressor,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\BZip2\BZip2Compressor.cs,mainQSort3,The method has 109 lines of code.
Long Method,Ionic.BZip2,BZip2Compressor,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\BZip2\BZip2Compressor.cs,generateMTFValues,The method has 115 lines of code.
Long Method,Ionic.BZip2,BZip2Compressor,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\BZip2\BZip2Compressor.cs,hbMakeCodeLengths,The method has 138 lines of code.
Long Method,Ionic.BZip2,BZip2Compressor,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\BZip2\BZip2Compressor.cs,sendMTFValues1,The method has 109 lines of code.
Long Method,Ionic.BZip2,BZip2InputStream,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\BZip2\BZip2InputStream.cs,getAndMoveToFrontDecode,The method has 200 lines of code.
Long Method,Ionic.BZip2,ParallelBZip2OutputStream,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\BZip2\ParallelBZip2OutputStream.cs,EmitPendingBuffers,The method has 139 lines of code.
Long Method,Ionic.Zlib,DeflateManager,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zlib.Shared\Deflate.cs,DeflateFast,The method has 101 lines of code.
Long Method,Ionic.Zlib,DeflateManager,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zlib.Shared\Deflate.cs,DeflateSlow,The method has 127 lines of code.
Long Method,Ionic.Zlib,DeflateManager,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zlib.Shared\Deflate.cs,Deflate,The method has 149 lines of code.
Long Method,Ionic.Zlib,InflateBlocks,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zlib.Shared\Inflate.cs,Process,The method has 448 lines of code.
Long Method,Ionic.Zlib,InflateCodes,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zlib.Shared\Inflate.cs,Process,The method has 307 lines of code.
Long Method,Ionic.Zlib,InflateCodes,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zlib.Shared\Inflate.cs,InflateFast,The method has 206 lines of code.
Long Method,Ionic.Zlib,InflateManager,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zlib.Shared\Inflate.cs,Inflate,The method has 159 lines of code.
Long Method,Ionic.Zlib,InfTree,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zlib.Shared\InfTree.cs,huft_build,The method has 212 lines of code.
Long Method,Ionic.Zlib,ParallelDeflateOutputStream,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zlib.Shared\ParallelDeflateOutputStream.cs,Write,The method has 108 lines of code.
Long Method,Ionic.Zip,WinZipAesCipherStream,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\WinZipAes.cs,Write,The method has 147 lines of code.
Long Method,Ionic.Zip,ZipEntry,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipDirEntry.cs,ReadDirEntry,The method has 151 lines of code.
Long Method,Ionic.Zip,ZipEntry,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipDirEntry.cs,ReadHeader,The method has 195 lines of code.
Long Method,Ionic.Zip,ZipEntry,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipDirEntry.cs,WriteCentralDirectoryEntry,The method has 220 lines of code.
Long Method,Ionic.Zip,ZipEntry,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipDirEntry.cs,ConstructExtraField,The method has 195 lines of code.
Long Method,Ionic.Zip,ZipEntry,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipDirEntry.cs,WriteHeader,The method has 346 lines of code.
Long Method,Ionic.Zip,ZipEntry,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipDirEntry.cs,PostProcessOutput,The method has 270 lines of code.
Long Method,Ionic.Zip,ZipEntry,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipDirEntry.cs,Write,The method has 156 lines of code.
Long Method,Ionic.Zip,ZipFile,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipFile.AddUpdate.cs,Save,The method has 160 lines of code.
Long Method,Ionic.Zip,ZipOutput,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipFile.Save.cs,WriteCentralDirectoryStructure,The method has 109 lines of code.
Long Method,Ionic,FileSelector,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\FileSelector.cs,_ParseCriterion,The method has 212 lines of code.
Complex Method,Ionic.BZip2,BZip2Compressor,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\BZip2\BZip2Compressor.cs,mainSort,Cyclomatic complexity of the method is 25
Complex Method,Ionic.BZip2,BZip2Compressor,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\BZip2\BZip2Compressor.cs,mainQSort3,Cyclomatic complexity of the method is 13
Complex Method,Ionic.BZip2,BZip2Compressor,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\BZip2\BZip2Compressor.cs,generateMTFValues,Cyclomatic complexity of the method is 16
Complex Method,Ionic.BZip2,BZip2Compressor,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\BZip2\BZip2Compressor.cs,hbMakeCodeLengths,Cyclomatic complexity of the method is 20
Complex Method,Ionic.BZip2,BZip2Compressor,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\BZip2\BZip2Compressor.cs,sendMTFValues1,Cyclomatic complexity of the method is 14
Complex Method,Ionic.BZip2,BZip2Compressor,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\BZip2\BZip2Compressor.cs,sendMTFValues4,Cyclomatic complexity of the method is 10
Complex Method,Ionic.BZip2,BZip2InputStream,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\BZip2\BZip2InputStream.cs,ReadByte,Cyclomatic complexity of the method is 9
Complex Method,Ionic.BZip2,BZip2InputStream,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\BZip2\BZip2InputStream.cs,hbCreateDecodeTables,Cyclomatic complexity of the method is 9
Complex Method,Ionic.BZip2,BZip2InputStream,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\BZip2\BZip2InputStream.cs,recvDecodingTables,Cyclomatic complexity of the method is 16
Complex Method,Ionic.BZip2,BZip2InputStream,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\BZip2\BZip2InputStream.cs,getAndMoveToFrontDecode,Cyclomatic complexity of the method is 26
Complex Method,Ionic.BZip2,BZip2InputStream,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\BZip2\BZip2InputStream.cs,SetupBlock,Cyclomatic complexity of the method is 13
Complex Method,Ionic.BZip2,ParallelBZip2OutputStream,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\BZip2\ParallelBZip2OutputStream.cs,Write,Cyclomatic complexity of the method is 8
Complex Method,Ionic.Zlib,DeflateManager,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zlib.Shared\Deflate.cs,scan_tree,Cyclomatic complexity of the method is 10
Complex Method,Ionic.Zlib,DeflateManager,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zlib.Shared\Deflate.cs,send_tree,Cyclomatic complexity of the method is 10
Complex Method,Ionic.Zlib,DeflateManager,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zlib.Shared\Deflate.cs,DeflateNone,Cyclomatic complexity of the method is 11
Complex Method,Ionic.Zlib,DeflateManager,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zlib.Shared\Deflate.cs,DeflateFast,Cyclomatic complexity of the method is 14
Complex Method,Ionic.Zlib,DeflateManager,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zlib.Shared\Deflate.cs,DeflateSlow,Cyclomatic complexity of the method is 18
Complex Method,Ionic.Zlib,DeflateManager,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zlib.Shared\Deflate.cs,Deflate,Cyclomatic complexity of the method is 22
Complex Method,Ionic.Zlib,InflateBlocks,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zlib.Shared\Inflate.cs,Process,Cyclomatic complexity of the method is 52
Complex Method,Ionic.Zlib,InflateBlocks,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zlib.Shared\Inflate.cs,Flush,Cyclomatic complexity of the method is 10
Complex Method,Ionic.Zlib,InflateCodes,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zlib.Shared\Inflate.cs,Process,Cyclomatic complexity of the method is 43
Complex Method,Ionic.Zlib,InflateManager,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zlib.Shared\Inflate.cs,Inflate,Cyclomatic complexity of the method is 35
Complex Method,Ionic.Zlib,InfTree,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zlib.Shared\InfTree.cs,huft_build,Cyclomatic complexity of the method is 26
Complex Method,Ionic.Zlib,InfTree,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zlib.Shared\InfTree.cs,inflate_trees_dynamic,Cyclomatic complexity of the method is 8
Complex Method,Ionic.Zlib,Tree,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zlib.Shared\Tree.cs,gen_bitlen,Cyclomatic complexity of the method is 12
Complex Method,Ionic.Zlib,ZlibBaseStream,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zlib.Shared\ZlibBaseStream.cs,finish,Cyclomatic complexity of the method is 13
Complex Method,Ionic.Zlib,ZlibBaseStream,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zlib.Shared\ZlibBaseStream.cs,_ReadAndValidateGzipHeader,Cyclomatic complexity of the method is 9
Complex Method,Ionic.Zlib,ZlibBaseStream,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zlib.Shared\ZlibBaseStream.cs,Read,Cyclomatic complexity of the method is 18
Complex Method,Ionic.Zip,WinZipAesCipherStream,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\WinZipAes.cs,Read,Cyclomatic complexity of the method is 8
Complex Method,Ionic.Zip,WinZipAesCipherStream,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\WinZipAes.cs,Write,Cyclomatic complexity of the method is 12
Complex Method,Ionic.Zip,ZipEntry,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipDirEntry.cs,ReadDirEntry,Cyclomatic complexity of the method is 18
Complex Method,Ionic.Zip,ZipEntry,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipDirEntry.cs,Create,Cyclomatic complexity of the method is 9
Complex Method,Ionic.Zip,ZipEntry,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipDirEntry.cs,InternalExtractToBaseDir,Cyclomatic complexity of the method is 11
Complex Method,Ionic.Zip,ZipEntry,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipDirEntry.cs,GetUnsupportedAlgorithm,Cyclomatic complexity of the method is 13
Complex Method,Ionic.Zip,ZipEntry,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipDirEntry.cs,GetUnsupportedCompressionMethod,Cyclomatic complexity of the method is 9
Complex Method,Ionic.Zip,ZipEntry,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipDirEntry.cs,ReadHeader,Cyclomatic complexity of the method is 18
Complex Method,Ionic.Zip,ZipEntry,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipDirEntry.cs,ProcessExtraField,Cyclomatic complexity of the method is 10
Complex Method,Ionic.Zip,ZipEntry,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipDirEntry.cs,WriteCentralDirectoryEntry,Cyclomatic complexity of the method is 11
Complex Method,Ionic.Zip,ZipEntry,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipDirEntry.cs,ConstructExtraField,Cyclomatic complexity of the method is 14
Complex Method,Ionic.Zip,ZipEntry,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipDirEntry.cs,GetEncodedFileNameBytes,Cyclomatic complexity of the method is 8
Complex Method,Ionic.Zip,ZipEntry,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipDirEntry.cs,WantReadAgain,Cyclomatic complexity of the method is 8
Complex Method,Ionic.Zip,ZipEntry,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipDirEntry.cs,MaybeUnsetCompressionMethodForWriting,Cyclomatic complexity of the method is 10
Complex Method,Ionic.Zip,ZipEntry,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipDirEntry.cs,WriteHeader,Cyclomatic complexity of the method is 17
Complex Method,Ionic.Zip,ZipEntry,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipDirEntry.cs,FigureCrc32,Cyclomatic complexity of the method is 9
Complex Method,Ionic.Zip,ZipEntry,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipDirEntry.cs,PostProcessOutput,Cyclomatic complexity of the method is 24
Complex Method,Ionic.Zip,ZipEntry,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipDirEntry.cs,MaybeApplyCompression,Cyclomatic complexity of the method is 9
Complex Method,Ionic.Zip,ZipEntry,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipDirEntry.cs,WriteSecurityMetadata,Cyclomatic complexity of the method is 8
Complex Method,Ionic.Zip,ZipEntry,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipDirEntry.cs,CopyThroughWithRecompute,Cyclomatic complexity of the method is 10
Complex Method,Ionic.Zip,ZipFile,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipFile.AddUpdate.cs,AddFiles,Cyclomatic complexity of the method is 9
Complex Method,Ionic.Zip,ZipFile,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipFile.AddUpdate.cs,AddOrUpdateDirectoryImpl,Cyclomatic complexity of the method is 17
Complex Method,Ionic.Zip,ZipFile,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipFile.AddUpdate.cs,CheckZip,Cyclomatic complexity of the method is 15
Complex Method,Ionic.Zip,ZipFile,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipFile.AddUpdate.cs,Dispose,Cyclomatic complexity of the method is 8
Complex Method,Ionic.Zip,ZipFile,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipFile.AddUpdate.cs,_InternalExtractAll,Cyclomatic complexity of the method is 10
Complex Method,Ionic.Zip,ZipFile,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipFile.AddUpdate.cs,ReadCentralDirectory,Cyclomatic complexity of the method is 9
Complex Method,Ionic.Zip,ZipFile,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipFile.AddUpdate.cs,ReadIntoInstance_Orig,Cyclomatic complexity of the method is 11
Complex Method,Ionic.Zip,ZipFile,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipFile.AddUpdate.cs,Save,Cyclomatic complexity of the method is 21
Complex Method,Ionic.Zip,ZipFile,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipFile.AddUpdate.cs,_AddOrUpdateSelectedFiles,Cyclomatic complexity of the method is 9
Complex Method,Ionic.Zip,ZipOutput,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipFile.Save.cs,WriteCentralDirectoryStructure,Cyclomatic complexity of the method is 10
Complex Method,Ionic.Zip,ZipOutput,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipFile.Save.cs,GenCentralDirectoryFooter,Cyclomatic complexity of the method is 10
Complex Method,Ionic.Zip,ZipSegmentedStream,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipSegmentedStream.cs,TruncateBackward,Cyclomatic complexity of the method is 8
Complex Method,Ionic,FileSelector,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\FileSelector.cs,_ParseCriterion,Cyclomatic complexity of the method is 37
Complex Method,Ionic,FileSelector,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\FileSelector.cs,SelectFiles,Cyclomatic complexity of the method is 9
Long Parameter List,Ionic.BZip2,BZip2Compressor,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\BZip2\BZip2Compressor.cs,hbAssignCodes,The method has 5 parameters. Parameters: code' length' minLen' maxLen' alphaSize
Long Parameter List,Ionic.BZip2,BZip2Compressor,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\BZip2\BZip2Compressor.cs,hbMakeCodeLengths,The method has 5 parameters. Parameters: len' freq' state1' alphaSize' maxLen
Long Parameter List,Ionic.BZip2,BZip2InputStream,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\BZip2\BZip2InputStream.cs,hbCreateDecodeTables,The method has 7 parameters. Parameters: limit' bbase' perm' length' minLen' maxLen' alphaSize
Long Parameter List,Ionic.Zlib,DeflateManager,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zlib.Shared\Deflate.cs,Initialize,The method has 5 parameters. Parameters: codec' level' windowBits' memLevel' strategy
Long Parameter List,Ionic.Zlib,Config,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zlib.Shared\Deflate.cs,Config,The method has 5 parameters. Parameters: goodLength' maxLazy' niceLength' maxChainLength' flavor
Long Parameter List,Ionic.Zlib,InflateCodes,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zlib.Shared\Inflate.cs,Init,The method has 6 parameters. Parameters: bl' bd' tl' tl_index' td' td_index
Long Parameter List,Ionic.Zlib,InflateCodes,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zlib.Shared\Inflate.cs,InflateFast,The method has 8 parameters. Parameters: bl' bd' tl' tl_index' td' td_index' s' z
Long Parameter List,Ionic.Zlib,InfTree,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zlib.Shared\InfTree.cs,huft_build,The method has 11 parameters. Parameters: b' bindex' n' s' d' e' t' m' hp' hn' v
Long Parameter List,Ionic.Zlib,InfTree,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zlib.Shared\InfTree.cs,inflate_trees_bits,The method has 5 parameters. Parameters: c' bb' tb' hp' z
Long Parameter List,Ionic.Zlib,InfTree,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zlib.Shared\InfTree.cs,inflate_trees_dynamic,The method has 9 parameters. Parameters: nl' nd' c' bl' bd' tl' td' hp' z
Long Parameter List,Ionic.Zlib,InfTree,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zlib.Shared\InfTree.cs,inflate_trees_fixed,The method has 5 parameters. Parameters: bl' bd' tl' td' z
Long Parameter List,Ionic.Zlib,StaticTree,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zlib.Shared\Zlib.cs,StaticTree,The method has 5 parameters. Parameters: treeCodes' extraBits' extraBase' elems' maxLength
Long Parameter List,Ionic.Zlib,ZlibBaseStream,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zlib.Shared\ZlibBaseStream.cs,ZlibBaseStream,The method has 5 parameters. Parameters: stream' compressionMode' level' flavor' leaveOpen
Long Parameter List,Ionic.Zip,SaveProgressEventArgs,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\Events.cs,SaveProgressEventArgs,The method has 5 parameters. Parameters: archiveName' before' entriesTotal' entriesSaved' entry
Long Parameter List,Ionic.Zip,ExtractProgressEventArgs,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\Events.cs,ExtractProgressEventArgs,The method has 6 parameters. Parameters: archiveName' before' entriesTotal' entriesExtracted' entry' extractLocation
Long Parameter List,Ionic.Zip,SharedUtilities,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\Shared.cs,ReadWithRetry,The method has 5 parameters. Parameters: s' buffer' offset' count' FileName
Long Parameter List,Ionic.Zip,ZipEntry,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipDirEntry.cs,InternalExtractToBaseDir,The method has 5 parameters. Parameters: baseDir' password' zipContainer' zipEntrySource' fileName
Long Parameter List,Ionic.Zip,ZipEntry,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipDirEntry.cs,InternalExtractToStream,The method has 5 parameters. Parameters: outStream' password' zipContainer' zipEntrySource' fileName
Long Parameter List,Ionic.Zip,ZipEntry,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipDirEntry.cs,VerifyCrcAfterExtract,The method has 5 parameters. Parameters: calculatedCrc32' encryptionAlgorithm' expectedCrc32' archiveStream' uncompressedSize
Long Parameter List,Ionic.Zip,ZipEntry,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipDirEntry.cs,ExtractAndCrc,The method has 5 parameters. Parameters: archiveStream' targetOutput' compressionMethod' compressedFileDataSize' uncompressedSize
Long Parameter List,Ionic.Zip,ZipEntry,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipDirEntry.cs,FinishOutputStream,The method has 5 parameters. Parameters: s' entryCounter' encryptor' compressor' output
Long Parameter List,Ionic.Zip,ZipEntry,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipDirEntry.cs,PrepOutputStream,The method has 6 parameters. Parameters: s' streamLength' outputCounter' encryptor' compressor' output
Long Parameter List,Ionic.Zip,ZipFile,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipFile.AddUpdate.cs,AddOrUpdateDirectoryImpl,The method has 5 parameters. Parameters: directoryName' rootDirectoryPathInArchive' action' recurse' level
Long Parameter List,Ionic.Zip,ZipFile,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipFile.AddUpdate.cs,_AddOrUpdateSelectedFiles,The method has 5 parameters. Parameters: selectionCriteria' directoryOnDisk' directoryPathInArchive' recurseDirectories' wantUpdate
Long Parameter List,Ionic.Zip,ZipOutput,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipFile.Save.cs,WriteCentralDirectoryStructure,The method has 6 parameters. Parameters: s' entries' numSegments' zip64' comment' container
Long Parameter List,Ionic.Zip,ZipOutput,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipFile.Save.cs,GenCentralDirectoryFooter,The method has 6 parameters. Parameters: StartOfCentralDirectory' EndOfCentralDirectory' zip64' entryCount' comment' container
Long Identifier,Ionic.Zip,ZipConstants,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipConstants.cs,,The length of the parameter Zip64EndOfCentralDirectoryRecordSignature is 41.
Long Identifier,Ionic.Zip,ZipConstants,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipConstants.cs,,The length of the parameter Zip64EndOfCentralDirectoryLocatorSignature is 42.
Long Identifier,Ionic.Zip,ZipConstants,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipConstants.cs,,The length of the parameter EndOfCentralDirectorySignature is 30.
Long Identifier,Ionic.Zip,ZipConstants,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipConstants.cs,,The length of the parameter ZipEntryDataDescriptorSignature is 31.
Long Identifier,Ionic.Zip,ZipEntry,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipDirEntry.cs,,The length of the parameter _TrimVolumeFromFullyQualifiedPaths is 34.
Long Identifier,Ionic.Zip,ZipEntry,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipDirEntry.cs,,The length of the parameter _CompressionMethod_FromZipFile is 30.
Long Identifier,Ionic.Zip,ZipFile,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipFile.AddUpdate.cs,_InternalExtractAll,The length of the parameter overrideExtractExistingProperty is 31.
Long Identifier,Ionic.Zip,ZipFile,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipFile.AddUpdate.cs,,The length of the parameter _numberOfSegmentsForMostRecentSave is 34.
Long Identifier,Ionic,FileSelector,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\FileSelector.cs,FileSelector,The length of the parameter traverseDirectoryReparsePoints is 30.
Long Identifier,Ionic,RegexAssertions,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\FileSelector.cs,,The length of the parameter PrecededByOddNumberOfSingleQuotes is 33.
Long Identifier,Ionic,RegexAssertions,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\FileSelector.cs,,The length of the parameter FollowedByOddNumberOfSingleQuotesAndLineEnd is 43.
Long Identifier,Ionic,RegexAssertions,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\FileSelector.cs,,The length of the parameter PrecededByEvenNumberOfSingleQuotes is 34.
Long Identifier,Ionic,RegexAssertions,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\FileSelector.cs,,The length of the parameter FollowedByEvenNumberOfSingleQuotesAndLineEnd is 44.
Long Statement,Ionic.Zlib,ZlibBaseStream,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zlib.Shared\ZlibBaseStream.cs,finish,The length of the statement  "                            throw new ZlibException(String.Format("Bad CRC32 in GZIP trailer. (actual({0:X8})!=expected({1:X8}))"' crc32_actual' crc32_expected)); " is 134.
Long Statement,Ionic.Zlib,ZlibBaseStream,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zlib.Shared\ZlibBaseStream.cs,finish,The length of the statement  "                            throw new ZlibException(String.Format("Bad size in GZIP trailer. (actual({0})!=expected({1}))"' isize_actual' isize_expected)); " is 127.
Long Statement,Ionic.Zip,SharedUtilities,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\Shared.cs,DateTimeToPacked,The length of the statement  "            UInt16 packedDate = (UInt16)((time.Day & 0x0000001F) | ((time.Month << 5) & 0x000001E0) | (((time.Year - 1980) << 9) & 0x0000FE00)); " is 132.
Long Statement,Ionic.Zip,SharedUtilities,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\Shared.cs,DateTimeToPacked,The length of the statement  "            UInt16 packedTime = (UInt16)((time.Second / 2 & 0x0000001F) | ((time.Minute << 5) & 0x000007E0) | ((time.Hour << 11) & 0x0000F800)); " is 132.
Long Statement,Ionic.Zip,SharedUtilities,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\Shared.cs,ReadWithRetry,The length of the statement  "                            throw new System.IO.IOException(String.Format("Cannot read file {0}' at offset 0x{1:X8} after 10 retries"' FileName' offset)' ioexc1); " is 134.
Long Statement,Ionic.Zip,ZipCrypto,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipCrypto.cs,DecryptMessage,The length of the statement  "                                                      "Bad length during Decryption: the length parameter must be smaller than or equal to the size of the destination array."); " is 122.
Long Statement,Ionic.Zip,ZipCrypto,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipCrypto.cs,EncryptMessage,The length of the statement  "                                                      "Bad length during Encryption: The length parameter must be smaller than or equal to the size of the destination array."); " is 122.
Long Statement,Ionic.Zip,ZipEntry,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipDirEntry.cs,ReadDirEntry,The length of the statement  "                zde._RelativeOffsetOfLocalHeader = (uint)(block[i++] + block[i++] * 256 + block[i++] * 256 * 256 + block[i++] * 256 * 256 * 256); " is 129.
Long Statement,Ionic.Zip,ZipEntry,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipDirEntry.cs,ValidateEncryption,The length of the statement  "                    throw new ZipException(string.Format("Cannot extract: Entry {0} is encrypted with an algorithm not supported by DotNetZip: {1}"' " is 128.
Long Statement,Ionic.Zip,ZipEntry,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipDirEntry.cs,ReadHeader,The length of the statement  "                    throw new BadReadException(String.Format("  Bad signature (0x{0:X8}) at position  0x{1:X8}"' signature' ze.ArchiveStream.Position)); " is 132.
Long Statement,Ionic.Zip,ZipEntry,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipDirEntry.cs,ReadHeader,The length of the statement  "                ze._Encryption_FromZipFile = ze._Encryption = EncryptionAlgorithm.PkzipWeak; // this *may* change after processing the Extra field " is 130.
Long Statement,Ionic.Zip,ZipEntry,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipDirEntry.cs,ProcessExtraFieldWinZipAes,The length of the statement  "                    throw new BadReadException(String.Format("  Inconsistent size (0x{0:X4}) in WinZip AES field at position 0x{1:X16}"' dataSize' posn)); " is 134.
Long Statement,Ionic.Zip,ZipEntry,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipDirEntry.cs,ProcessExtraFieldWinZipAes,The length of the statement  "                    throw new BadReadException(String.Format("  Unexpected vendor version number (0x{0:X4}) for WinZip AES metadata at position 0x{1:X16}"' " is 135.
Long Statement,Ionic.Zip,ZipEntry,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipDirEntry.cs,ProcessExtraFieldWinZipAes,The length of the statement  "                    throw new BadReadException(String.Format("  Unexpected vendor ID (0x{0:X4}) for WinZip AES metadata at position 0x{1:X16}"' vendorId' posn)); " is 141.
Long Statement,Ionic.Zip,ZipEntry,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipDirEntry.cs,ProcessExtraFieldInfoZipTimes,The length of the statement  "                throw new BadReadException(String.Format("  Unexpected size (0x{0:X4}) for InfoZip v1 extra field at position 0x{1:X16}"' dataSize' posn)); " is 139.
Long Statement,Ionic.Zip,ZipEntry,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipDirEntry.cs,ProcessExtraFieldUnixTimes,The length of the statement  "                throw new BadReadException(String.Format("  Unexpected size (0x{0:X4}) for Extended Timestamp extra field at position 0x{1:X16}"' dataSize' posn)); " is 147.
Long Statement,Ionic.Zip,ZipEntry,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipDirEntry.cs,ProcessExtraFieldWindowsTimes,The length of the statement  "                throw new BadReadException(String.Format("  Unexpected size (0x{0:X4}) for NTFS times extra field at position 0x{1:X16}"' dataSize' posn)); " is 139.
Long Statement,Ionic.Zip,ZipEntry,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipDirEntry.cs,WantReadAgain,The length of the statement  "            if (_aesCrypto_forWrite != null && (CompressedSize - _aesCrypto_forWrite.SizeOfEncryptionMetadata) <= UncompressedSize + 0x10) return false; " is 140.
Long Statement,Ionic.Zip,ZipEntry,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipDirEntry.cs,WriteHeader,The length of the statement  "                throw new ZipException("Offset within the zip archive exceeds 0xFFFFFFFF. Consider setting the UseZip64WhenSaving property on the ZipFile instance."); " is 150.
Long Statement,Ionic.Zip,ZipEntry,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipDirEntry.cs,SetInputAndFigureFileLength,The length of the statement  "                string pwd = (_Encryption_FromZipFile == EncryptionAlgorithm.None) ? null : (this._Password ?? this._container.Password); " is 121.
Long Statement,Ionic.Zip,ZipEntry,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipDirEntry.cs,SetZip64Flags,The length of the statement  "                throw new ZipException("Compressed or Uncompressed size' or offset exceeds the maximum value. Consider setting the UseZip64WhenSaving property on the ZipFile instance."); " is 170.
Long Statement,Ionic.Zip,ZipFile,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipFile.AddUpdate.cs,AnyCaseInsensitiveMatches,The length of the statement  "            // this has to search _entries rather than _caseInsensitiveEntries because it's used to determine whether to update the latter " is 126.
Long Statement,Ionic.Zip,ZipFile,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipFile.AddUpdate.cs,Zip64SeekToCentralDirectory,The length of the statement  "                throw new BadReadException(String.Format("  Bad signature (0x{0:X8}) looking for ZIP64 EoCD Record at position 0x{1:X8}"' datum' s.Position)); " is 142.
Long Statement,Ionic.Zip,ZipFile,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipFile.AddUpdate.cs,Save,The length of the statement  "                    throw new ZipException("The number of entries is 65535 or greater. Consider setting the UseZip64WhenSaving property on the ZipFile instance."); " is 143.
Long Statement,Ionic.Zip,ZipFile,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipFile.AddUpdate.cs,Save,The length of the statement  "                throw new ZipException("Bad Directory"' new System.ArgumentException("That name specifies an existing directory. Please specify a filename."' "fileName")); " is 155.
Long Statement,Ionic.Zip,ZipOutput,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipFile.Save.cs,WriteCentralDirectoryStructure,The length of the statement  "                        throw new ZipException("The archive requires a ZIP64 Central Directory. Consider setting the ZipFile.UseZip64WhenSaving property."); " is 132.
Long Statement,Ionic.Zip,ZipOutput,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipFile.Save.cs,WriteCentralDirectoryStructure,The length of the statement  "                        throw new ZipException("The archive requires a ZIP64 Central Directory. Consider setting the ZipOutputStream.EnableZip64 property."); " is 133.
Long Statement,Ionic.Zip,ZipInputStream,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipInputStream.cs,Read,The length of the statement  "                _currentEntry.VerifyCrcAfterExtract(CrcResult' _currentEntry.Encryption' _currentEntry._Crc32' _currentEntry.ArchiveStream' _currentEntry.UncompressedSize); " is 156.
Long Statement,Ionic,TimeCriterion,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\FileSelector.cs,ToString,The length of the statement  "            sb.Append(Which.ToString()).Append(" ").Append(EnumUtil.GetDescription(Operator)).Append(" ").Append(Time.ToString("yyyy-MM-dd-HH:mm:ss")); " is 139.
Long Statement,Ionic,NameCriterion,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\FileSelector.cs,Evaluate,The length of the statement  "            string transformedFileName = entry.FileName.Replace(Path.DirectorySeparatorChar == '/' ? '\\' : '/'' Path.DirectorySeparatorChar); " is 130.
Complex Conditional,Ionic.BZip2,BZip2Compressor,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\BZip2\BZip2Compressor.cs,sendMTFValues0,The conditional expression  "(ge > gs) && (nPart != nGroups) && (nPart != 1)                      && (((nGroups - nPart) & 1) != 0)"  is complex.
Complex Conditional,Ionic.BZip2,BZip2InputStream,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\BZip2\BZip2InputStream.cs,InitBlock,The conditional expression  "magic0 == 0x17 && magic1 == 0x72 && magic2 == 0x45                  && magic3 == 0x38 && magic4 == 0x50 && magic5 == 0x90"  is complex.
Complex Conditional,Ionic.BZip2,BZip2InputStream,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\BZip2\BZip2InputStream.cs,InitBlock,The conditional expression  "magic0 != 0x31 ||                       magic1 != 0x41 ||                       magic2 != 0x59 ||                       magic3 != 0x26 ||                       magic4 != 0x53 ||                       magic5 != 0x59"  is complex.
Complex Conditional,Ionic.Zlib,DeflateManager,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zlib.Shared\Deflate.cs,DeflateSlow,The conditional expression  "match_length <= 5 && (compressionStrategy == CompressionStrategy.Filtered ||                                                (match_length == MIN_MATCH && strstart - match_start > 4096))"  is complex.
Complex Conditional,Ionic.Zlib,DeflateManager,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zlib.Shared\Deflate.cs,longest_match,The conditional expression  "window[match + best_len] != scan_end ||                      window[match + best_len - 1] != scan_end1 ||                      window[match] != window[scan] ||                      window[++match] != window[scan + 1]"  is complex.
Complex Conditional,Ionic.Zlib,DeflateManager,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zlib.Shared\Deflate.cs,Deflate,The conditional expression  "_codec.OutputBuffer == null ||                  (_codec.InputBuffer == null && _codec.AvailableBytesIn != 0) ||                  (status == FINISH_STATE && flush != FlushType.Finish)"  is complex.
Complex Conditional,Ionic.Zlib,DeflateManager,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zlib.Shared\Deflate.cs,Deflate,The conditional expression  "_codec.AvailableBytesIn != 0 || lookahead != 0 || (flush != FlushType.None && status != FINISH_STATE)"  is complex.
Complex Conditional,Ionic.Zlib,ZlibCodec,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zlib.Shared\ZlibCodec.cs,flush_pending,The conditional expression  "dstate.pending.Length <= dstate.nextPending ||                  OutputBuffer.Length <= NextOut ||                  dstate.pending.Length < (dstate.nextPending + len) ||                  OutputBuffer.Length < (NextOut + len)"  is complex.
Complex Conditional,Ionic.Zip,ZipEntry,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipDirEntry.cs,ValidateEncryption,The conditional expression  "encryptionAlgorithm != EncryptionAlgorithm.PkzipWeak &&  #if AESCRYPTO                  encryptionAlgorithm != EncryptionAlgorithm.WinZipAes128 &&                  encryptionAlgorithm != EncryptionAlgorithm.WinZipAes256 &&  #endif                  encryptionAlgorithm != EncryptionAlgorithm.None"  is complex.
Complex Conditional,Ionic.Zip,ZipEntry,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipDirEntry.cs,ConstructExtraField,The conditional expression  "_container.Zip64 == Zip64Option.Always ||                  (_container.Zip64 == Zip64Option.AsNecessary &&                   (!forCentralDirectory || _entryRequiresZip64.Value))"  is complex.
Complex Conditional,Ionic.Zip,ZipEntry,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipDirEntry.cs,NormalizeFileName,The conditional expression  "(_TrimVolumeFromFullyQualifiedPaths) && (FileName.Length >= 3)                  && (FileName[1] == ':') && (SlashFixed[2] == '/')"  is complex.
Empty Catch Block,Ionic.Zip,SharedUtilities,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\Shared.cs,StringToByteArray,The method has an empty catch block.
Empty Catch Block,Ionic.Zip,SharedUtilities,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\Shared.cs,StringToByteArray,The method has an empty catch block.
Empty Catch Block,Ionic.Zip,SharedUtilities,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\Shared.cs,ReadSignature,The method has an empty catch block.
Empty Catch Block,Ionic.Zip,SharedUtilities,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\Shared.cs,ReadEntrySignature,The method has an empty catch block.
Empty Catch Block,Ionic.Zip,SharedUtilities,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\Shared.cs,PackedToDateTime,The method has an empty catch block.
Empty Catch Block,Ionic.Zip,SharedUtilities,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\Shared.cs,PackedToDateTime,The method has an empty catch block.
Empty Catch Block,Ionic.Zip,ZipEntry,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipDirEntry.cs,_WriteEntryData,The method has an empty catch block.
Empty Catch Block,Ionic.Zip,ZipEntry,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipDirEntry.cs,SetInputAndFigureFileLength,The method has an empty catch block.
Empty Catch Block,Ionic.Zip,ZipEntry,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipDirEntry.cs,SetInputAndFigureFileLength,The method has an empty catch block.
Empty Catch Block,Ionic.Zip,ZipFile,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipFile.AddUpdate.cs,CheckZipPassword,The method has an empty catch block.
Empty Catch Block,Ionic.Zip,ZipFile,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipFile.AddUpdate.cs,ReadIntoInstance_Orig,The method has an empty catch block.
Empty Catch Block,Ionic.Zip,ZipFile,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipFile.AddUpdate.cs,ReadIntoInstance_Orig,The method has an empty catch block.
Empty Catch Block,Ionic.Zip,ZipFile,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipFile.AddUpdate.cs,IsZipFile,The method has an empty catch block.
Empty Catch Block,Ionic.Zip,ZipFile,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipFile.AddUpdate.cs,IsZipFile,The method has an empty catch block.
Empty Catch Block,Ionic.Zip,ZipFile,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipFile.AddUpdate.cs,IsZipFile,The method has an empty catch block.
Empty Catch Block,Ionic.Zip,ZipFile,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipFile.AddUpdate.cs,IsZipFile,The method has an empty catch block.
Empty Catch Block,Ionic.Zip,ZipFile,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipFile.AddUpdate.cs,Save,The method has an empty catch block.
Empty Catch Block,Ionic.Zip,ZipFile,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipFile.AddUpdate.cs,CleanupAfterSaveOperation,The method has an empty catch block.
Empty Catch Block,Ionic.Zip,ZipFile,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipFile.AddUpdate.cs,ZipFile,The method has an empty catch block.
Empty Catch Block,Ionic.Zip,ZipFile,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipFile.AddUpdate.cs,ZipFile,The method has an empty catch block.
Empty Catch Block,Ionic,FileSelector,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\FileSelector.cs,SelectFiles,The method has an empty catch block.
Empty Catch Block,Ionic,FileSelector,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\FileSelector.cs,SelectFiles,The method has an empty catch block.
Magic Number,Ionic.BZip2,BitWriter,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\BZip2\BitWriter.cs,WriteBits,The following statement contains a magic number: this.output.WriteByte ((byte)(u >> 24 & 0xff));
Magic Number,Ionic.BZip2,BitWriter,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\BZip2\BitWriter.cs,WriteBits,The following statement contains a magic number: u <<= 8;
Magic Number,Ionic.BZip2,BitWriter,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\BZip2\BitWriter.cs,WriteBits,The following statement contains a magic number: nAccumulated -= 8;
Magic Number,Ionic.BZip2,BitWriter,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\BZip2\BitWriter.cs,WriteBits,The following statement contains a magic number: nAccumulated >= 8
Magic Number,Ionic.BZip2,BitWriter,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\BZip2\BitWriter.cs,WriteBits,The following statement contains a magic number: this.accumulator = u | (value << (32 - nAccumulated - nbits));
Magic Number,Ionic.BZip2,BitWriter,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\BZip2\BitWriter.cs,WriteByte,The following statement contains a magic number: WriteBits(8' b);
Magic Number,Ionic.BZip2,BitWriter,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\BZip2\BitWriter.cs,WriteInt,The following statement contains a magic number: WriteBits(8' (u >> 24) & 0xff);
Magic Number,Ionic.BZip2,BitWriter,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\BZip2\BitWriter.cs,WriteInt,The following statement contains a magic number: WriteBits(8' (u >> 24) & 0xff);
Magic Number,Ionic.BZip2,BitWriter,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\BZip2\BitWriter.cs,WriteInt,The following statement contains a magic number: WriteBits(8' (u >> 16) & 0xff);
Magic Number,Ionic.BZip2,BitWriter,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\BZip2\BitWriter.cs,WriteInt,The following statement contains a magic number: WriteBits(8' (u >> 16) & 0xff);
Magic Number,Ionic.BZip2,BitWriter,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\BZip2\BitWriter.cs,WriteInt,The following statement contains a magic number: WriteBits(8' (u >> 8) & 0xff);
Magic Number,Ionic.BZip2,BitWriter,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\BZip2\BitWriter.cs,WriteInt,The following statement contains a magic number: WriteBits(8' (u >> 8) & 0xff);
Magic Number,Ionic.BZip2,BitWriter,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\BZip2\BitWriter.cs,WriteInt,The following statement contains a magic number: WriteBits(8' u & 0xff);
Magic Number,Ionic.BZip2,BitWriter,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\BZip2\BitWriter.cs,FinishAndPad,The following statement contains a magic number: byte b = (byte)((this.accumulator >> 24) & 0xff);
Magic Number,Ionic.BZip2,BZip2Compressor,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\BZip2\BZip2Compressor.cs,BZip2Compressor,The following statement contains a magic number: this.outBlockFillThreshold = (blockSize * BZip2.BlockSizeMultiple) - 20;
Magic Number,Ionic.BZip2,BZip2Compressor,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\BZip2\BZip2Compressor.cs,write0,The following statement contains a magic number: return (rc) ? 2 : 1;
Magic Number,Ionic.BZip2,BZip2Compressor,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\BZip2\BZip2Compressor.cs,write0,The following statement contains a magic number: ++this.runLength > 254
Magic Number,Ionic.BZip2,BZip2Compressor,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\BZip2\BZip2Compressor.cs,AddRunToOutputBlock,The following statement contains a magic number: switch (rl)              {                  case 1:                      block[previousLast + 2] = b;                      this.last = previousLast + 1;                      break;                    case 2:                      block[previousLast + 2] = b;                      block[previousLast + 3] = b;                      this.last = previousLast + 2;                      break;                    case 3:                      block[previousLast + 2] = b;                      block[previousLast + 3] = b;                      block[previousLast + 4] = b;                      this.last = previousLast + 3;                      break;                    default:                      rl -= 4;                      this.cstate.inUse[rl] = true;                      block[previousLast + 2] = b;                      block[previousLast + 3] = b;                      block[previousLast + 4] = b;                      block[previousLast + 5] = b;                      block[previousLast + 6] = (byte) rl;                      this.last = previousLast + 5;                      break;              }
Magic Number,Ionic.BZip2,BZip2Compressor,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\BZip2\BZip2Compressor.cs,AddRunToOutputBlock,The following statement contains a magic number: switch (rl)              {                  case 1:                      block[previousLast + 2] = b;                      this.last = previousLast + 1;                      break;                    case 2:                      block[previousLast + 2] = b;                      block[previousLast + 3] = b;                      this.last = previousLast + 2;                      break;                    case 3:                      block[previousLast + 2] = b;                      block[previousLast + 3] = b;                      block[previousLast + 4] = b;                      this.last = previousLast + 3;                      break;                    default:                      rl -= 4;                      this.cstate.inUse[rl] = true;                      block[previousLast + 2] = b;                      block[previousLast + 3] = b;                      block[previousLast + 4] = b;                      block[previousLast + 5] = b;                      block[previousLast + 6] = (byte) rl;                      this.last = previousLast + 5;                      break;              }
Magic Number,Ionic.BZip2,BZip2Compressor,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\BZip2\BZip2Compressor.cs,AddRunToOutputBlock,The following statement contains a magic number: switch (rl)              {                  case 1:                      block[previousLast + 2] = b;                      this.last = previousLast + 1;                      break;                    case 2:                      block[previousLast + 2] = b;                      block[previousLast + 3] = b;                      this.last = previousLast + 2;                      break;                    case 3:                      block[previousLast + 2] = b;                      block[previousLast + 3] = b;                      block[previousLast + 4] = b;                      this.last = previousLast + 3;                      break;                    default:                      rl -= 4;                      this.cstate.inUse[rl] = true;                      block[previousLast + 2] = b;                      block[previousLast + 3] = b;                      block[previousLast + 4] = b;                      block[previousLast + 5] = b;                      block[previousLast + 6] = (byte) rl;                      this.last = previousLast + 5;                      break;              }
Magic Number,Ionic.BZip2,BZip2Compressor,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\BZip2\BZip2Compressor.cs,AddRunToOutputBlock,The following statement contains a magic number: switch (rl)              {                  case 1:                      block[previousLast + 2] = b;                      this.last = previousLast + 1;                      break;                    case 2:                      block[previousLast + 2] = b;                      block[previousLast + 3] = b;                      this.last = previousLast + 2;                      break;                    case 3:                      block[previousLast + 2] = b;                      block[previousLast + 3] = b;                      block[previousLast + 4] = b;                      this.last = previousLast + 3;                      break;                    default:                      rl -= 4;                      this.cstate.inUse[rl] = true;                      block[previousLast + 2] = b;                      block[previousLast + 3] = b;                      block[previousLast + 4] = b;                      block[previousLast + 5] = b;                      block[previousLast + 6] = (byte) rl;                      this.last = previousLast + 5;                      break;              }
Magic Number,Ionic.BZip2,BZip2Compressor,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\BZip2\BZip2Compressor.cs,AddRunToOutputBlock,The following statement contains a magic number: switch (rl)              {                  case 1:                      block[previousLast + 2] = b;                      this.last = previousLast + 1;                      break;                    case 2:                      block[previousLast + 2] = b;                      block[previousLast + 3] = b;                      this.last = previousLast + 2;                      break;                    case 3:                      block[previousLast + 2] = b;                      block[previousLast + 3] = b;                      block[previousLast + 4] = b;                      this.last = previousLast + 3;                      break;                    default:                      rl -= 4;                      this.cstate.inUse[rl] = true;                      block[previousLast + 2] = b;                      block[previousLast + 3] = b;                      block[previousLast + 4] = b;                      block[previousLast + 5] = b;                      block[previousLast + 6] = (byte) rl;                      this.last = previousLast + 5;                      break;              }
Magic Number,Ionic.BZip2,BZip2Compressor,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\BZip2\BZip2Compressor.cs,AddRunToOutputBlock,The following statement contains a magic number: switch (rl)              {                  case 1:                      block[previousLast + 2] = b;                      this.last = previousLast + 1;                      break;                    case 2:                      block[previousLast + 2] = b;                      block[previousLast + 3] = b;                      this.last = previousLast + 2;                      break;                    case 3:                      block[previousLast + 2] = b;                      block[previousLast + 3] = b;                      block[previousLast + 4] = b;                      this.last = previousLast + 3;                      break;                    default:                      rl -= 4;                      this.cstate.inUse[rl] = true;                      block[previousLast + 2] = b;                      block[previousLast + 3] = b;                      block[previousLast + 4] = b;                      block[previousLast + 5] = b;                      block[previousLast + 6] = (byte) rl;                      this.last = previousLast + 5;                      break;              }
Magic Number,Ionic.BZip2,BZip2Compressor,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\BZip2\BZip2Compressor.cs,AddRunToOutputBlock,The following statement contains a magic number: switch (rl)              {                  case 1:                      block[previousLast + 2] = b;                      this.last = previousLast + 1;                      break;                    case 2:                      block[previousLast + 2] = b;                      block[previousLast + 3] = b;                      this.last = previousLast + 2;                      break;                    case 3:                      block[previousLast + 2] = b;                      block[previousLast + 3] = b;                      block[previousLast + 4] = b;                      this.last = previousLast + 3;                      break;                    default:                      rl -= 4;                      this.cstate.inUse[rl] = true;                      block[previousLast + 2] = b;                      block[previousLast + 3] = b;                      block[previousLast + 4] = b;                      block[previousLast + 5] = b;                      block[previousLast + 6] = (byte) rl;                      this.last = previousLast + 5;                      break;              }
Magic Number,Ionic.BZip2,BZip2Compressor,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\BZip2\BZip2Compressor.cs,AddRunToOutputBlock,The following statement contains a magic number: switch (rl)              {                  case 1:                      block[previousLast + 2] = b;                      this.last = previousLast + 1;                      break;                    case 2:                      block[previousLast + 2] = b;                      block[previousLast + 3] = b;                      this.last = previousLast + 2;                      break;                    case 3:                      block[previousLast + 2] = b;                      block[previousLast + 3] = b;                      block[previousLast + 4] = b;                      this.last = previousLast + 3;                      break;                    default:                      rl -= 4;                      this.cstate.inUse[rl] = true;                      block[previousLast + 2] = b;                      block[previousLast + 3] = b;                      block[previousLast + 4] = b;                      block[previousLast + 5] = b;                      block[previousLast + 6] = (byte) rl;                      this.last = previousLast + 5;                      break;              }
Magic Number,Ionic.BZip2,BZip2Compressor,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\BZip2\BZip2Compressor.cs,AddRunToOutputBlock,The following statement contains a magic number: switch (rl)              {                  case 1:                      block[previousLast + 2] = b;                      this.last = previousLast + 1;                      break;                    case 2:                      block[previousLast + 2] = b;                      block[previousLast + 3] = b;                      this.last = previousLast + 2;                      break;                    case 3:                      block[previousLast + 2] = b;                      block[previousLast + 3] = b;                      block[previousLast + 4] = b;                      this.last = previousLast + 3;                      break;                    default:                      rl -= 4;                      this.cstate.inUse[rl] = true;                      block[previousLast + 2] = b;                      block[previousLast + 3] = b;                      block[previousLast + 4] = b;                      block[previousLast + 5] = b;                      block[previousLast + 6] = (byte) rl;                      this.last = previousLast + 5;                      break;              }
Magic Number,Ionic.BZip2,BZip2Compressor,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\BZip2\BZip2Compressor.cs,AddRunToOutputBlock,The following statement contains a magic number: switch (rl)              {                  case 1:                      block[previousLast + 2] = b;                      this.last = previousLast + 1;                      break;                    case 2:                      block[previousLast + 2] = b;                      block[previousLast + 3] = b;                      this.last = previousLast + 2;                      break;                    case 3:                      block[previousLast + 2] = b;                      block[previousLast + 3] = b;                      block[previousLast + 4] = b;                      this.last = previousLast + 3;                      break;                    default:                      rl -= 4;                      this.cstate.inUse[rl] = true;                      block[previousLast + 2] = b;                      block[previousLast + 3] = b;                      block[previousLast + 4] = b;                      block[previousLast + 5] = b;                      block[previousLast + 6] = (byte) rl;                      this.last = previousLast + 5;                      break;              }
Magic Number,Ionic.BZip2,BZip2Compressor,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\BZip2\BZip2Compressor.cs,AddRunToOutputBlock,The following statement contains a magic number: switch (rl)              {                  case 1:                      block[previousLast + 2] = b;                      this.last = previousLast + 1;                      break;                    case 2:                      block[previousLast + 2] = b;                      block[previousLast + 3] = b;                      this.last = previousLast + 2;                      break;                    case 3:                      block[previousLast + 2] = b;                      block[previousLast + 3] = b;                      block[previousLast + 4] = b;                      this.last = previousLast + 3;                      break;                    default:                      rl -= 4;                      this.cstate.inUse[rl] = true;                      block[previousLast + 2] = b;                      block[previousLast + 3] = b;                      block[previousLast + 4] = b;                      block[previousLast + 5] = b;                      block[previousLast + 6] = (byte) rl;                      this.last = previousLast + 5;                      break;              }
Magic Number,Ionic.BZip2,BZip2Compressor,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\BZip2\BZip2Compressor.cs,AddRunToOutputBlock,The following statement contains a magic number: switch (rl)              {                  case 1:                      block[previousLast + 2] = b;                      this.last = previousLast + 1;                      break;                    case 2:                      block[previousLast + 2] = b;                      block[previousLast + 3] = b;                      this.last = previousLast + 2;                      break;                    case 3:                      block[previousLast + 2] = b;                      block[previousLast + 3] = b;                      block[previousLast + 4] = b;                      this.last = previousLast + 3;                      break;                    default:                      rl -= 4;                      this.cstate.inUse[rl] = true;                      block[previousLast + 2] = b;                      block[previousLast + 3] = b;                      block[previousLast + 4] = b;                      block[previousLast + 5] = b;                      block[previousLast + 6] = (byte) rl;                      this.last = previousLast + 5;                      break;              }
Magic Number,Ionic.BZip2,BZip2Compressor,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\BZip2\BZip2Compressor.cs,AddRunToOutputBlock,The following statement contains a magic number: switch (rl)              {                  case 1:                      block[previousLast + 2] = b;                      this.last = previousLast + 1;                      break;                    case 2:                      block[previousLast + 2] = b;                      block[previousLast + 3] = b;                      this.last = previousLast + 2;                      break;                    case 3:                      block[previousLast + 2] = b;                      block[previousLast + 3] = b;                      block[previousLast + 4] = b;                      this.last = previousLast + 3;                      break;                    default:                      rl -= 4;                      this.cstate.inUse[rl] = true;                      block[previousLast + 2] = b;                      block[previousLast + 3] = b;                      block[previousLast + 4] = b;                      block[previousLast + 5] = b;                      block[previousLast + 6] = (byte) rl;                      this.last = previousLast + 5;                      break;              }
Magic Number,Ionic.BZip2,BZip2Compressor,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\BZip2\BZip2Compressor.cs,AddRunToOutputBlock,The following statement contains a magic number: switch (rl)              {                  case 1:                      block[previousLast + 2] = b;                      this.last = previousLast + 1;                      break;                    case 2:                      block[previousLast + 2] = b;                      block[previousLast + 3] = b;                      this.last = previousLast + 2;                      break;                    case 3:                      block[previousLast + 2] = b;                      block[previousLast + 3] = b;                      block[previousLast + 4] = b;                      this.last = previousLast + 3;                      break;                    default:                      rl -= 4;                      this.cstate.inUse[rl] = true;                      block[previousLast + 2] = b;                      block[previousLast + 3] = b;                      block[previousLast + 4] = b;                      block[previousLast + 5] = b;                      block[previousLast + 6] = (byte) rl;                      this.last = previousLast + 5;                      break;              }
Magic Number,Ionic.BZip2,BZip2Compressor,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\BZip2\BZip2Compressor.cs,AddRunToOutputBlock,The following statement contains a magic number: switch (rl)              {                  case 1:                      block[previousLast + 2] = b;                      this.last = previousLast + 1;                      break;                    case 2:                      block[previousLast + 2] = b;                      block[previousLast + 3] = b;                      this.last = previousLast + 2;                      break;                    case 3:                      block[previousLast + 2] = b;                      block[previousLast + 3] = b;                      block[previousLast + 4] = b;                      this.last = previousLast + 3;                      break;                    default:                      rl -= 4;                      this.cstate.inUse[rl] = true;                      block[previousLast + 2] = b;                      block[previousLast + 3] = b;                      block[previousLast + 4] = b;                      block[previousLast + 5] = b;                      block[previousLast + 6] = (byte) rl;                      this.last = previousLast + 5;                      break;              }
Magic Number,Ionic.BZip2,BZip2Compressor,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\BZip2\BZip2Compressor.cs,AddRunToOutputBlock,The following statement contains a magic number: switch (rl)              {                  case 1:                      block[previousLast + 2] = b;                      this.last = previousLast + 1;                      break;                    case 2:                      block[previousLast + 2] = b;                      block[previousLast + 3] = b;                      this.last = previousLast + 2;                      break;                    case 3:                      block[previousLast + 2] = b;                      block[previousLast + 3] = b;                      block[previousLast + 4] = b;                      this.last = previousLast + 3;                      break;                    default:                      rl -= 4;                      this.cstate.inUse[rl] = true;                      block[previousLast + 2] = b;                      block[previousLast + 3] = b;                      block[previousLast + 4] = b;                      block[previousLast + 5] = b;                      block[previousLast + 6] = (byte) rl;                      this.last = previousLast + 5;                      break;              }
Magic Number,Ionic.BZip2,BZip2Compressor,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\BZip2\BZip2Compressor.cs,AddRunToOutputBlock,The following statement contains a magic number: switch (rl)              {                  case 1:                      block[previousLast + 2] = b;                      this.last = previousLast + 1;                      break;                    case 2:                      block[previousLast + 2] = b;                      block[previousLast + 3] = b;                      this.last = previousLast + 2;                      break;                    case 3:                      block[previousLast + 2] = b;                      block[previousLast + 3] = b;                      block[previousLast + 4] = b;                      this.last = previousLast + 3;                      break;                    default:                      rl -= 4;                      this.cstate.inUse[rl] = true;                      block[previousLast + 2] = b;                      block[previousLast + 3] = b;                      block[previousLast + 4] = b;                      block[previousLast + 5] = b;                      block[previousLast + 6] = (byte) rl;                      this.last = previousLast + 5;                      break;              }
Magic Number,Ionic.BZip2,BZip2Compressor,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\BZip2\BZip2Compressor.cs,randomiseBlock,The following statement contains a magic number: ++rTPos == 512
Magic Number,Ionic.BZip2,BZip2Compressor,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\BZip2\BZip2Compressor.cs,mainSort,The following statement contains a magic number: block[lastShadow + i + 2] = block[(i % (lastShadow + 1)) + 1];
Magic Number,Ionic.BZip2,BZip2Compressor,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\BZip2\BZip2Compressor.cs,mainSort,The following statement contains a magic number: ftab[(c1 << 8) + c2]++;
Magic Number,Ionic.BZip2,BZip2Compressor,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\BZip2\BZip2Compressor.cs,mainSort,The following statement contains a magic number: i <= 65536
Magic Number,Ionic.BZip2,BZip2Compressor,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\BZip2\BZip2Compressor.cs,mainSort,The following statement contains a magic number: int c2 = block[i + 2] & 0xff;
Magic Number,Ionic.BZip2,BZip2Compressor,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\BZip2\BZip2Compressor.cs,mainSort,The following statement contains a magic number: fmap[--ftab[(c1 << 8) + c2]] = i;
Magic Number,Ionic.BZip2,BZip2Compressor,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\BZip2\BZip2Compressor.cs,mainSort,The following statement contains a magic number: fmap[--ftab[((block[lastShadow + 1] & 0xff) << 8) + (block[1] & 0xff)]] = lastShadow;
Magic Number,Ionic.BZip2,BZip2Compressor,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\BZip2\BZip2Compressor.cs,mainSort,The following statement contains a magic number: h /= 3;
Magic Number,Ionic.BZip2,BZip2Compressor,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\BZip2\BZip2Compressor.cs,mainSort,The following statement contains a magic number: int a = ftab[(vv + 1) << 8] - ftab[vv << 8];
Magic Number,Ionic.BZip2,BZip2Compressor,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\BZip2\BZip2Compressor.cs,mainSort,The following statement contains a magic number: int a = ftab[(vv + 1) << 8] - ftab[vv << 8];
Magic Number,Ionic.BZip2,BZip2Compressor,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\BZip2\BZip2Compressor.cs,mainSort,The following statement contains a magic number: (ftab[(ro + 1) << 8] - ftab[ro << 8]) > a
Magic Number,Ionic.BZip2,BZip2Compressor,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\BZip2\BZip2Compressor.cs,mainSort,The following statement contains a magic number: (ftab[(ro + 1) << 8] - ftab[ro << 8]) > a
Magic Number,Ionic.BZip2,BZip2Compressor,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\BZip2\BZip2Compressor.cs,mainSort,The following statement contains a magic number: i <= 255
Magic Number,Ionic.BZip2,BZip2Compressor,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\BZip2\BZip2Compressor.cs,mainSort,The following statement contains a magic number: int sb = (ss << 8) + j;
Magic Number,Ionic.BZip2,BZip2Compressor,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\BZip2\BZip2Compressor.cs,mainSort,The following statement contains a magic number: mainQSort3(dataShadow' lo' hi' 2);
Magic Number,Ionic.BZip2,BZip2Compressor,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\BZip2\BZip2Compressor.cs,mainSort,The following statement contains a magic number: j <= 255
Magic Number,Ionic.BZip2,BZip2Compressor,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\BZip2\BZip2Compressor.cs,mainSort,The following statement contains a magic number: copy[j] = ftab[(j << 8) + ss] & CLEARMASK;
Magic Number,Ionic.BZip2,BZip2Compressor,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\BZip2\BZip2Compressor.cs,mainSort,The following statement contains a magic number: j <= 255
Magic Number,Ionic.BZip2,BZip2Compressor,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\BZip2\BZip2Compressor.cs,mainSort,The following statement contains a magic number: ftab[(j << 8) + ss] |= SETMASK;
Magic Number,Ionic.BZip2,BZip2Compressor,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\BZip2\BZip2Compressor.cs,mainSort,The following statement contains a magic number: int bbStart = ftab[ss << 8] & CLEARMASK;
Magic Number,Ionic.BZip2,BZip2Compressor,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\BZip2\BZip2Compressor.cs,mainSort,The following statement contains a magic number: int bbSize = (ftab[(ss + 1) << 8] & CLEARMASK) - bbStart;
Magic Number,Ionic.BZip2,BZip2Compressor,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\BZip2\BZip2Compressor.cs,mainSort,The following statement contains a magic number: (bbSize >> shifts) > 65534
Magic Number,Ionic.BZip2,BZip2Compressor,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\BZip2\BZip2Compressor.cs,mainSort,The following statement contains a magic number: i < 255
Magic Number,Ionic.BZip2,BZip2Compressor,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\BZip2\BZip2Compressor.cs,mainSort,The following statement contains a magic number: i <= 255
Magic Number,Ionic.BZip2,BZip2Compressor,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\BZip2\BZip2Compressor.cs,mainSimpleSort,The following statement contains a magic number: bigN < 2
Magic Number,Ionic.BZip2,BZip2Compressor,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\BZip2\BZip2Compressor.cs,mainSimpleSort,The following statement contains a magic number: X: while (x > 0)                                                      {                                                          x -= 4;                                                            if (block[i1 + 1] == block[i2 + 1])                                                          {                                                              if (quadrant[i1] == quadrant[i2])                                                              {                                                                  if (block[i1 + 2] == block[i2 + 2])                                                                  {                                                                      if (quadrant[i1 + 1] == quadrant[i2 + 1])                                                                      {                                                                          if (block[i1 + 3] == block[i2 + 3])                                                                          {                                                                              if (quadrant[i1 + 2] == quadrant[i2 + 2])                                                                              {                                                                                  if (block[i1 + 4] == block[i2 + 4])                                                                                  {                                                                                      if (quadrant[i1 + 3] == quadrant[i2 + 3])                                                                                      {                                                                                          if ((i1 += 4) >= lastPlus1)                                                                                          {                                                                                              i1 -= lastPlus1;                                                                                          }                                                                                          if ((i2 += 4) >= lastPlus1)                                                                                          {                                                                                              i2 -= lastPlus1;                                                                                          }                                                                                          workDoneShadow++;                                                                                          goto X;                                                                                      }                                                                                      else if ((quadrant[i1 + 3] > quadrant[i2 + 3]))                                                                                      {                                                                                          goto HAMMER;                                                                                      }                                                                                      else {                                                                                          goto END_HAMMER;                                                                                      }                                                                                  }                                                                                  else if ((block[i1 + 4] & 0xff) > (block[i2 + 4] & 0xff))                                                                                  {                                                                                      goto HAMMER;                                                                                  }                                                                                  else {                                                                                      goto END_HAMMER;                                                                                  }                                                                              }                                                                              else if ((quadrant[i1 + 2] > quadrant[i2 + 2]))                                                                              {                                                                                  goto HAMMER;                                                                              }                                                                              else {                                                                                  goto END_HAMMER;                                                                              }                                                                          }                                                                          else if ((block[i1 + 3] & 0xff) > (block[i2 + 3] & 0xff))                                                                          {                                                                              goto HAMMER;                                                                          }                                                                          else {                                                                              goto END_HAMMER;                                                                          }                                                                      }                                                                      else if ((quadrant[i1 + 1] > quadrant[i2 + 1]))                                                                      {                                                                          goto HAMMER;                                                                      }                                                                      else {                                                                          goto END_HAMMER;                                                                      }                                                                  }                                                                  else if ((block[i1 + 2] & 0xff) > (block[i2 + 2] & 0xff))                                                                  {                                                                      goto HAMMER;                                                                  }                                                                  else {                                                                      goto END_HAMMER;                                                                  }                                                              }                                                              else if ((quadrant[i1] > quadrant[i2]))                                                              {                                                                  goto HAMMER;                                                              }                                                              else {                                                                  goto END_HAMMER;                                                              }                                                          }                                                          else if ((block[i1 + 1] & 0xff) > (block[i2 + 1] & 0xff))                                                          {                                                              goto HAMMER;                                                          }                                                          else {                                                              goto END_HAMMER;                                                          }                                                        }
Magic Number,Ionic.BZip2,BZip2Compressor,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\BZip2\BZip2Compressor.cs,mainSimpleSort,The following statement contains a magic number: X: while (x > 0)                                                      {                                                          x -= 4;                                                            if (block[i1 + 1] == block[i2 + 1])                                                          {                                                              if (quadrant[i1] == quadrant[i2])                                                              {                                                                  if (block[i1 + 2] == block[i2 + 2])                                                                  {                                                                      if (quadrant[i1 + 1] == quadrant[i2 + 1])                                                                      {                                                                          if (block[i1 + 3] == block[i2 + 3])                                                                          {                                                                              if (quadrant[i1 + 2] == quadrant[i2 + 2])                                                                              {                                                                                  if (block[i1 + 4] == block[i2 + 4])                                                                                  {                                                                                      if (quadrant[i1 + 3] == quadrant[i2 + 3])                                                                                      {                                                                                          if ((i1 += 4) >= lastPlus1)                                                                                          {                                                                                              i1 -= lastPlus1;                                                                                          }                                                                                          if ((i2 += 4) >= lastPlus1)                                                                                          {                                                                                              i2 -= lastPlus1;                                                                                          }                                                                                          workDoneShadow++;                                                                                          goto X;                                                                                      }                                                                                      else if ((quadrant[i1 + 3] > quadrant[i2 + 3]))                                                                                      {                                                                                          goto HAMMER;                                                                                      }                                                                                      else {                                                                                          goto END_HAMMER;                                                                                      }                                                                                  }                                                                                  else if ((block[i1 + 4] & 0xff) > (block[i2 + 4] & 0xff))                                                                                  {                                                                                      goto HAMMER;                                                                                  }                                                                                  else {                                                                                      goto END_HAMMER;                                                                                  }                                                                              }                                                                              else if ((quadrant[i1 + 2] > quadrant[i2 + 2]))                                                                              {                                                                                  goto HAMMER;                                                                              }                                                                              else {                                                                                  goto END_HAMMER;                                                                              }                                                                          }                                                                          else if ((block[i1 + 3] & 0xff) > (block[i2 + 3] & 0xff))                                                                          {                                                                              goto HAMMER;                                                                          }                                                                          else {                                                                              goto END_HAMMER;                                                                          }                                                                      }                                                                      else if ((quadrant[i1 + 1] > quadrant[i2 + 1]))                                                                      {                                                                          goto HAMMER;                                                                      }                                                                      else {                                                                          goto END_HAMMER;                                                                      }                                                                  }                                                                  else if ((block[i1 + 2] & 0xff) > (block[i2 + 2] & 0xff))                                                                  {                                                                      goto HAMMER;                                                                  }                                                                  else {                                                                      goto END_HAMMER;                                                                  }                                                              }                                                              else if ((quadrant[i1] > quadrant[i2]))                                                              {                                                                  goto HAMMER;                                                              }                                                              else {                                                                  goto END_HAMMER;                                                              }                                                          }                                                          else if ((block[i1 + 1] & 0xff) > (block[i2 + 1] & 0xff))                                                          {                                                              goto HAMMER;                                                          }                                                          else {                                                              goto END_HAMMER;                                                          }                                                        }
Magic Number,Ionic.BZip2,BZip2Compressor,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\BZip2\BZip2Compressor.cs,mainSimpleSort,The following statement contains a magic number: X: while (x > 0)                                                      {                                                          x -= 4;                                                            if (block[i1 + 1] == block[i2 + 1])                                                          {                                                              if (quadrant[i1] == quadrant[i2])                                                              {                                                                  if (block[i1 + 2] == block[i2 + 2])                                                                  {                                                                      if (quadrant[i1 + 1] == quadrant[i2 + 1])                                                                      {                                                                          if (block[i1 + 3] == block[i2 + 3])                                                                          {                                                                              if (quadrant[i1 + 2] == quadrant[i2 + 2])                                                                              {                                                                                  if (block[i1 + 4] == block[i2 + 4])                                                                                  {                                                                                      if (quadrant[i1 + 3] == quadrant[i2 + 3])                                                                                      {                                                                                          if ((i1 += 4) >= lastPlus1)                                                                                          {                                                                                              i1 -= lastPlus1;                                                                                          }                                                                                          if ((i2 += 4) >= lastPlus1)                                                                                          {                                                                                              i2 -= lastPlus1;                                                                                          }                                                                                          workDoneShadow++;                                                                                          goto X;                                                                                      }                                                                                      else if ((quadrant[i1 + 3] > quadrant[i2 + 3]))                                                                                      {                                                                                          goto HAMMER;                                                                                      }                                                                                      else {                                                                                          goto END_HAMMER;                                                                                      }                                                                                  }                                                                                  else if ((block[i1 + 4] & 0xff) > (block[i2 + 4] & 0xff))                                                                                  {                                                                                      goto HAMMER;                                                                                  }                                                                                  else {                                                                                      goto END_HAMMER;                                                                                  }                                                                              }                                                                              else if ((quadrant[i1 + 2] > quadrant[i2 + 2]))                                                                              {                                                                                  goto HAMMER;                                                                              }                                                                              else {                                                                                  goto END_HAMMER;                                                                              }                                                                          }                                                                          else if ((block[i1 + 3] & 0xff) > (block[i2 + 3] & 0xff))                                                                          {                                                                              goto HAMMER;                                                                          }                                                                          else {                                                                              goto END_HAMMER;                                                                          }                                                                      }                                                                      else if ((quadrant[i1 + 1] > quadrant[i2 + 1]))                                                                      {                                                                          goto HAMMER;                                                                      }                                                                      else {                                                                          goto END_HAMMER;                                                                      }                                                                  }                                                                  else if ((block[i1 + 2] & 0xff) > (block[i2 + 2] & 0xff))                                                                  {                                                                      goto HAMMER;                                                                  }                                                                  else {                                                                      goto END_HAMMER;                                                                  }                                                              }                                                              else if ((quadrant[i1] > quadrant[i2]))                                                              {                                                                  goto HAMMER;                                                              }                                                              else {                                                                  goto END_HAMMER;                                                              }                                                          }                                                          else if ((block[i1 + 1] & 0xff) > (block[i2 + 1] & 0xff))                                                          {                                                              goto HAMMER;                                                          }                                                          else {                                                              goto END_HAMMER;                                                          }                                                        }
Magic Number,Ionic.BZip2,BZip2Compressor,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\BZip2\BZip2Compressor.cs,mainSimpleSort,The following statement contains a magic number: X: while (x > 0)                                                      {                                                          x -= 4;                                                            if (block[i1 + 1] == block[i2 + 1])                                                          {                                                              if (quadrant[i1] == quadrant[i2])                                                              {                                                                  if (block[i1 + 2] == block[i2 + 2])                                                                  {                                                                      if (quadrant[i1 + 1] == quadrant[i2 + 1])                                                                      {                                                                          if (block[i1 + 3] == block[i2 + 3])                                                                          {                                                                              if (quadrant[i1 + 2] == quadrant[i2 + 2])                                                                              {                                                                                  if (block[i1 + 4] == block[i2 + 4])                                                                                  {                                                                                      if (quadrant[i1 + 3] == quadrant[i2 + 3])                                                                                      {                                                                                          if ((i1 += 4) >= lastPlus1)                                                                                          {                                                                                              i1 -= lastPlus1;                                                                                          }                                                                                          if ((i2 += 4) >= lastPlus1)                                                                                          {                                                                                              i2 -= lastPlus1;                                                                                          }                                                                                          workDoneShadow++;                                                                                          goto X;                                                                                      }                                                                                      else if ((quadrant[i1 + 3] > quadrant[i2 + 3]))                                                                                      {                                                                                          goto HAMMER;                                                                                      }                                                                                      else {                                                                                          goto END_HAMMER;                                                                                      }                                                                                  }                                                                                  else if ((block[i1 + 4] & 0xff) > (block[i2 + 4] & 0xff))                                                                                  {                                                                                      goto HAMMER;                                                                                  }                                                                                  else {                                                                                      goto END_HAMMER;                                                                                  }                                                                              }                                                                              else if ((quadrant[i1 + 2] > quadrant[i2 + 2]))                                                                              {                                                                                  goto HAMMER;                                                                              }                                                                              else {                                                                                  goto END_HAMMER;                                                                              }                                                                          }                                                                          else if ((block[i1 + 3] & 0xff) > (block[i2 + 3] & 0xff))                                                                          {                                                                              goto HAMMER;                                                                          }                                                                          else {                                                                              goto END_HAMMER;                                                                          }                                                                      }                                                                      else if ((quadrant[i1 + 1] > quadrant[i2 + 1]))                                                                      {                                                                          goto HAMMER;                                                                      }                                                                      else {                                                                          goto END_HAMMER;                                                                      }                                                                  }                                                                  else if ((block[i1 + 2] & 0xff) > (block[i2 + 2] & 0xff))                                                                  {                                                                      goto HAMMER;                                                                  }                                                                  else {                                                                      goto END_HAMMER;                                                                  }                                                              }                                                              else if ((quadrant[i1] > quadrant[i2]))                                                              {                                                                  goto HAMMER;                                                              }                                                              else {                                                                  goto END_HAMMER;                                                              }                                                          }                                                          else if ((block[i1 + 1] & 0xff) > (block[i2 + 1] & 0xff))                                                          {                                                              goto HAMMER;                                                          }                                                          else {                                                              goto END_HAMMER;                                                          }                                                        }
Magic Number,Ionic.BZip2,BZip2Compressor,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\BZip2\BZip2Compressor.cs,mainSimpleSort,The following statement contains a magic number: X: while (x > 0)                                                      {                                                          x -= 4;                                                            if (block[i1 + 1] == block[i2 + 1])                                                          {                                                              if (quadrant[i1] == quadrant[i2])                                                              {                                                                  if (block[i1 + 2] == block[i2 + 2])                                                                  {                                                                      if (quadrant[i1 + 1] == quadrant[i2 + 1])                                                                      {                                                                          if (block[i1 + 3] == block[i2 + 3])                                                                          {                                                                              if (quadrant[i1 + 2] == quadrant[i2 + 2])                                                                              {                                                                                  if (block[i1 + 4] == block[i2 + 4])                                                                                  {                                                                                      if (quadrant[i1 + 3] == quadrant[i2 + 3])                                                                                      {                                                                                          if ((i1 += 4) >= lastPlus1)                                                                                          {                                                                                              i1 -= lastPlus1;                                                                                          }                                                                                          if ((i2 += 4) >= lastPlus1)                                                                                          {                                                                                              i2 -= lastPlus1;                                                                                          }                                                                                          workDoneShadow++;                                                                                          goto X;                                                                                      }                                                                                      else if ((quadrant[i1 + 3] > quadrant[i2 + 3]))                                                                                      {                                                                                          goto HAMMER;                                                                                      }                                                                                      else {                                                                                          goto END_HAMMER;                                                                                      }                                                                                  }                                                                                  else if ((block[i1 + 4] & 0xff) > (block[i2 + 4] & 0xff))                                                                                  {                                                                                      goto HAMMER;                                                                                  }                                                                                  else {                                                                                      goto END_HAMMER;                                                                                  }                                                                              }                                                                              else if ((quadrant[i1 + 2] > quadrant[i2 + 2]))                                                                              {                                                                                  goto HAMMER;                                                                              }                                                                              else {                                                                                  goto END_HAMMER;                                                                              }                                                                          }                                                                          else if ((block[i1 + 3] & 0xff) > (block[i2 + 3] & 0xff))                                                                          {                                                                              goto HAMMER;                                                                          }                                                                          else {                                                                              goto END_HAMMER;                                                                          }                                                                      }                                                                      else if ((quadrant[i1 + 1] > quadrant[i2 + 1]))                                                                      {                                                                          goto HAMMER;                                                                      }                                                                      else {                                                                          goto END_HAMMER;                                                                      }                                                                  }                                                                  else if ((block[i1 + 2] & 0xff) > (block[i2 + 2] & 0xff))                                                                  {                                                                      goto HAMMER;                                                                  }                                                                  else {                                                                      goto END_HAMMER;                                                                  }                                                              }                                                              else if ((quadrant[i1] > quadrant[i2]))                                                              {                                                                  goto HAMMER;                                                              }                                                              else {                                                                  goto END_HAMMER;                                                              }                                                          }                                                          else if ((block[i1 + 1] & 0xff) > (block[i2 + 1] & 0xff))                                                          {                                                              goto HAMMER;                                                          }                                                          else {                                                              goto END_HAMMER;                                                          }                                                        }
Magic Number,Ionic.BZip2,BZip2Compressor,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\BZip2\BZip2Compressor.cs,mainSimpleSort,The following statement contains a magic number: X: while (x > 0)                                                      {                                                          x -= 4;                                                            if (block[i1 + 1] == block[i2 + 1])                                                          {                                                              if (quadrant[i1] == quadrant[i2])                                                              {                                                                  if (block[i1 + 2] == block[i2 + 2])                                                                  {                                                                      if (quadrant[i1 + 1] == quadrant[i2 + 1])                                                                      {                                                                          if (block[i1 + 3] == block[i2 + 3])                                                                          {                                                                              if (quadrant[i1 + 2] == quadrant[i2 + 2])                                                                              {                                                                                  if (block[i1 + 4] == block[i2 + 4])                                                                                  {                                                                                      if (quadrant[i1 + 3] == quadrant[i2 + 3])                                                                                      {                                                                                          if ((i1 += 4) >= lastPlus1)                                                                                          {                                                                                              i1 -= lastPlus1;                                                                                          }                                                                                          if ((i2 += 4) >= lastPlus1)                                                                                          {                                                                                              i2 -= lastPlus1;                                                                                          }                                                                                          workDoneShadow++;                                                                                          goto X;                                                                                      }                                                                                      else if ((quadrant[i1 + 3] > quadrant[i2 + 3]))                                                                                      {                                                                                          goto HAMMER;                                                                                      }                                                                                      else {                                                                                          goto END_HAMMER;                                                                                      }                                                                                  }                                                                                  else if ((block[i1 + 4] & 0xff) > (block[i2 + 4] & 0xff))                                                                                  {                                                                                      goto HAMMER;                                                                                  }                                                                                  else {                                                                                      goto END_HAMMER;                                                                                  }                                                                              }                                                                              else if ((quadrant[i1 + 2] > quadrant[i2 + 2]))                                                                              {                                                                                  goto HAMMER;                                                                              }                                                                              else {                                                                                  goto END_HAMMER;                                                                              }                                                                          }                                                                          else if ((block[i1 + 3] & 0xff) > (block[i2 + 3] & 0xff))                                                                          {                                                                              goto HAMMER;                                                                          }                                                                          else {                                                                              goto END_HAMMER;                                                                          }                                                                      }                                                                      else if ((quadrant[i1 + 1] > quadrant[i2 + 1]))                                                                      {                                                                          goto HAMMER;                                                                      }                                                                      else {                                                                          goto END_HAMMER;                                                                      }                                                                  }                                                                  else if ((block[i1 + 2] & 0xff) > (block[i2 + 2] & 0xff))                                                                  {                                                                      goto HAMMER;                                                                  }                                                                  else {                                                                      goto END_HAMMER;                                                                  }                                                              }                                                              else if ((quadrant[i1] > quadrant[i2]))                                                              {                                                                  goto HAMMER;                                                              }                                                              else {                                                                  goto END_HAMMER;                                                              }                                                          }                                                          else if ((block[i1 + 1] & 0xff) > (block[i2 + 1] & 0xff))                                                          {                                                              goto HAMMER;                                                          }                                                          else {                                                              goto END_HAMMER;                                                          }                                                        }
Magic Number,Ionic.BZip2,BZip2Compressor,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\BZip2\BZip2Compressor.cs,mainSimpleSort,The following statement contains a magic number: X: while (x > 0)                                                      {                                                          x -= 4;                                                            if (block[i1 + 1] == block[i2 + 1])                                                          {                                                              if (quadrant[i1] == quadrant[i2])                                                              {                                                                  if (block[i1 + 2] == block[i2 + 2])                                                                  {                                                                      if (quadrant[i1 + 1] == quadrant[i2 + 1])                                                                      {                                                                          if (block[i1 + 3] == block[i2 + 3])                                                                          {                                                                              if (quadrant[i1 + 2] == quadrant[i2 + 2])                                                                              {                                                                                  if (block[i1 + 4] == block[i2 + 4])                                                                                  {                                                                                      if (quadrant[i1 + 3] == quadrant[i2 + 3])                                                                                      {                                                                                          if ((i1 += 4) >= lastPlus1)                                                                                          {                                                                                              i1 -= lastPlus1;                                                                                          }                                                                                          if ((i2 += 4) >= lastPlus1)                                                                                          {                                                                                              i2 -= lastPlus1;                                                                                          }                                                                                          workDoneShadow++;                                                                                          goto X;                                                                                      }                                                                                      else if ((quadrant[i1 + 3] > quadrant[i2 + 3]))                                                                                      {                                                                                          goto HAMMER;                                                                                      }                                                                                      else {                                                                                          goto END_HAMMER;                                                                                      }                                                                                  }                                                                                  else if ((block[i1 + 4] & 0xff) > (block[i2 + 4] & 0xff))                                                                                  {                                                                                      goto HAMMER;                                                                                  }                                                                                  else {                                                                                      goto END_HAMMER;                                                                                  }                                                                              }                                                                              else if ((quadrant[i1 + 2] > quadrant[i2 + 2]))                                                                              {                                                                                  goto HAMMER;                                                                              }                                                                              else {                                                                                  goto END_HAMMER;                                                                              }                                                                          }                                                                          else if ((block[i1 + 3] & 0xff) > (block[i2 + 3] & 0xff))                                                                          {                                                                              goto HAMMER;                                                                          }                                                                          else {                                                                              goto END_HAMMER;                                                                          }                                                                      }                                                                      else if ((quadrant[i1 + 1] > quadrant[i2 + 1]))                                                                      {                                                                          goto HAMMER;                                                                      }                                                                      else {                                                                          goto END_HAMMER;                                                                      }                                                                  }                                                                  else if ((block[i1 + 2] & 0xff) > (block[i2 + 2] & 0xff))                                                                  {                                                                      goto HAMMER;                                                                  }                                                                  else {                                                                      goto END_HAMMER;                                                                  }                                                              }                                                              else if ((quadrant[i1] > quadrant[i2]))                                                              {                                                                  goto HAMMER;                                                              }                                                              else {                                                                  goto END_HAMMER;                                                              }                                                          }                                                          else if ((block[i1 + 1] & 0xff) > (block[i2 + 1] & 0xff))                                                          {                                                              goto HAMMER;                                                          }                                                          else {                                                              goto END_HAMMER;                                                          }                                                        }
Magic Number,Ionic.BZip2,BZip2Compressor,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\BZip2\BZip2Compressor.cs,mainSimpleSort,The following statement contains a magic number: X: while (x > 0)                                                      {                                                          x -= 4;                                                            if (block[i1 + 1] == block[i2 + 1])                                                          {                                                              if (quadrant[i1] == quadrant[i2])                                                              {                                                                  if (block[i1 + 2] == block[i2 + 2])                                                                  {                                                                      if (quadrant[i1 + 1] == quadrant[i2 + 1])                                                                      {                                                                          if (block[i1 + 3] == block[i2 + 3])                                                                          {                                                                              if (quadrant[i1 + 2] == quadrant[i2 + 2])                                                                              {                                                                                  if (block[i1 + 4] == block[i2 + 4])                                                                                  {                                                                                      if (quadrant[i1 + 3] == quadrant[i2 + 3])                                                                                      {                                                                                          if ((i1 += 4) >= lastPlus1)                                                                                          {                                                                                              i1 -= lastPlus1;                                                                                          }                                                                                          if ((i2 += 4) >= lastPlus1)                                                                                          {                                                                                              i2 -= lastPlus1;                                                                                          }                                                                                          workDoneShadow++;                                                                                          goto X;                                                                                      }                                                                                      else if ((quadrant[i1 + 3] > quadrant[i2 + 3]))                                                                                      {                                                                                          goto HAMMER;                                                                                      }                                                                                      else {                                                                                          goto END_HAMMER;                                                                                      }                                                                                  }                                                                                  else if ((block[i1 + 4] & 0xff) > (block[i2 + 4] & 0xff))                                                                                  {                                                                                      goto HAMMER;                                                                                  }                                                                                  else {                                                                                      goto END_HAMMER;                                                                                  }                                                                              }                                                                              else if ((quadrant[i1 + 2] > quadrant[i2 + 2]))                                                                              {                                                                                  goto HAMMER;                                                                              }                                                                              else {                                                                                  goto END_HAMMER;                                                                              }                                                                          }                                                                          else if ((block[i1 + 3] & 0xff) > (block[i2 + 3] & 0xff))                                                                          {                                                                              goto HAMMER;                                                                          }                                                                          else {                                                                              goto END_HAMMER;                                                                          }                                                                      }                                                                      else if ((quadrant[i1 + 1] > quadrant[i2 + 1]))                                                                      {                                                                          goto HAMMER;                                                                      }                                                                      else {                                                                          goto END_HAMMER;                                                                      }                                                                  }                                                                  else if ((block[i1 + 2] & 0xff) > (block[i2 + 2] & 0xff))                                                                  {                                                                      goto HAMMER;                                                                  }                                                                  else {                                                                      goto END_HAMMER;                                                                  }                                                              }                                                              else if ((quadrant[i1] > quadrant[i2]))                                                              {                                                                  goto HAMMER;                                                              }                                                              else {                                                                  goto END_HAMMER;                                                              }                                                          }                                                          else if ((block[i1 + 1] & 0xff) > (block[i2 + 1] & 0xff))                                                          {                                                              goto HAMMER;                                                          }                                                          else {                                                              goto END_HAMMER;                                                          }                                                        }
Magic Number,Ionic.BZip2,BZip2Compressor,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\BZip2\BZip2Compressor.cs,mainSimpleSort,The following statement contains a magic number: X: while (x > 0)                                                      {                                                          x -= 4;                                                            if (block[i1 + 1] == block[i2 + 1])                                                          {                                                              if (quadrant[i1] == quadrant[i2])                                                              {                                                                  if (block[i1 + 2] == block[i2 + 2])                                                                  {                                                                      if (quadrant[i1 + 1] == quadrant[i2 + 1])                                                                      {                                                                          if (block[i1 + 3] == block[i2 + 3])                                                                          {                                                                              if (quadrant[i1 + 2] == quadrant[i2 + 2])                                                                              {                                                                                  if (block[i1 + 4] == block[i2 + 4])                                                                                  {                                                                                      if (quadrant[i1 + 3] == quadrant[i2 + 3])                                                                                      {                                                                                          if ((i1 += 4) >= lastPlus1)                                                                                          {                                                                                              i1 -= lastPlus1;                                                                                          }                                                                                          if ((i2 += 4) >= lastPlus1)                                                                                          {                                                                                              i2 -= lastPlus1;                                                                                          }                                                                                          workDoneShadow++;                                                                                          goto X;                                                                                      }                                                                                      else if ((quadrant[i1 + 3] > quadrant[i2 + 3]))                                                                                      {                                                                                          goto HAMMER;                                                                                      }                                                                                      else {                                                                                          goto END_HAMMER;                                                                                      }                                                                                  }                                                                                  else if ((block[i1 + 4] & 0xff) > (block[i2 + 4] & 0xff))                                                                                  {                                                                                      goto HAMMER;                                                                                  }                                                                                  else {                                                                                      goto END_HAMMER;                                                                                  }                                                                              }                                                                              else if ((quadrant[i1 + 2] > quadrant[i2 + 2]))                                                                              {                                                                                  goto HAMMER;                                                                              }                                                                              else {                                                                                  goto END_HAMMER;                                                                              }                                                                          }                                                                          else if ((block[i1 + 3] & 0xff) > (block[i2 + 3] & 0xff))                                                                          {                                                                              goto HAMMER;                                                                          }                                                                          else {                                                                              goto END_HAMMER;                                                                          }                                                                      }                                                                      else if ((quadrant[i1 + 1] > quadrant[i2 + 1]))                                                                      {                                                                          goto HAMMER;                                                                      }                                                                      else {                                                                          goto END_HAMMER;                                                                      }                                                                  }                                                                  else if ((block[i1 + 2] & 0xff) > (block[i2 + 2] & 0xff))                                                                  {                                                                      goto HAMMER;                                                                  }                                                                  else {                                                                      goto END_HAMMER;                                                                  }                                                              }                                                              else if ((quadrant[i1] > quadrant[i2]))                                                              {                                                                  goto HAMMER;                                                              }                                                              else {                                                                  goto END_HAMMER;                                                              }                                                          }                                                          else if ((block[i1 + 1] & 0xff) > (block[i2 + 1] & 0xff))                                                          {                                                              goto HAMMER;                                                          }                                                          else {                                                              goto END_HAMMER;                                                          }                                                        }
Magic Number,Ionic.BZip2,BZip2Compressor,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\BZip2\BZip2Compressor.cs,mainSimpleSort,The following statement contains a magic number: X: while (x > 0)                                                      {                                                          x -= 4;                                                            if (block[i1 + 1] == block[i2 + 1])                                                          {                                                              if (quadrant[i1] == quadrant[i2])                                                              {                                                                  if (block[i1 + 2] == block[i2 + 2])                                                                  {                                                                      if (quadrant[i1 + 1] == quadrant[i2 + 1])                                                                      {                                                                          if (block[i1 + 3] == block[i2 + 3])                                                                          {                                                                              if (quadrant[i1 + 2] == quadrant[i2 + 2])                                                                              {                                                                                  if (block[i1 + 4] == block[i2 + 4])                                                                                  {                                                                                      if (quadrant[i1 + 3] == quadrant[i2 + 3])                                                                                      {                                                                                          if ((i1 += 4) >= lastPlus1)                                                                                          {                                                                                              i1 -= lastPlus1;                                                                                          }                                                                                          if ((i2 += 4) >= lastPlus1)                                                                                          {                                                                                              i2 -= lastPlus1;                                                                                          }                                                                                          workDoneShadow++;                                                                                          goto X;                                                                                      }                                                                                      else if ((quadrant[i1 + 3] > quadrant[i2 + 3]))                                                                                      {                                                                                          goto HAMMER;                                                                                      }                                                                                      else {                                                                                          goto END_HAMMER;                                                                                      }                                                                                  }                                                                                  else if ((block[i1 + 4] & 0xff) > (block[i2 + 4] & 0xff))                                                                                  {                                                                                      goto HAMMER;                                                                                  }                                                                                  else {                                                                                      goto END_HAMMER;                                                                                  }                                                                              }                                                                              else if ((quadrant[i1 + 2] > quadrant[i2 + 2]))                                                                              {                                                                                  goto HAMMER;                                                                              }                                                                              else {                                                                                  goto END_HAMMER;                                                                              }                                                                          }                                                                          else if ((block[i1 + 3] & 0xff) > (block[i2 + 3] & 0xff))                                                                          {                                                                              goto HAMMER;                                                                          }                                                                          else {                                                                              goto END_HAMMER;                                                                          }                                                                      }                                                                      else if ((quadrant[i1 + 1] > quadrant[i2 + 1]))                                                                      {                                                                          goto HAMMER;                                                                      }                                                                      else {                                                                          goto END_HAMMER;                                                                      }                                                                  }                                                                  else if ((block[i1 + 2] & 0xff) > (block[i2 + 2] & 0xff))                                                                  {                                                                      goto HAMMER;                                                                  }                                                                  else {                                                                      goto END_HAMMER;                                                                  }                                                              }                                                              else if ((quadrant[i1] > quadrant[i2]))                                                              {                                                                  goto HAMMER;                                                              }                                                              else {                                                                  goto END_HAMMER;                                                              }                                                          }                                                          else if ((block[i1 + 1] & 0xff) > (block[i2 + 1] & 0xff))                                                          {                                                              goto HAMMER;                                                          }                                                          else {                                                              goto END_HAMMER;                                                          }                                                        }
Magic Number,Ionic.BZip2,BZip2Compressor,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\BZip2\BZip2Compressor.cs,mainSimpleSort,The following statement contains a magic number: X: while (x > 0)                                                      {                                                          x -= 4;                                                            if (block[i1 + 1] == block[i2 + 1])                                                          {                                                              if (quadrant[i1] == quadrant[i2])                                                              {                                                                  if (block[i1 + 2] == block[i2 + 2])                                                                  {                                                                      if (quadrant[i1 + 1] == quadrant[i2 + 1])                                                                      {                                                                          if (block[i1 + 3] == block[i2 + 3])                                                                          {                                                                              if (quadrant[i1 + 2] == quadrant[i2 + 2])                                                                              {                                                                                  if (block[i1 + 4] == block[i2 + 4])                                                                                  {                                                                                      if (quadrant[i1 + 3] == quadrant[i2 + 3])                                                                                      {                                                                                          if ((i1 += 4) >= lastPlus1)                                                                                          {                                                                                              i1 -= lastPlus1;                                                                                          }                                                                                          if ((i2 += 4) >= lastPlus1)                                                                                          {                                                                                              i2 -= lastPlus1;                                                                                          }                                                                                          workDoneShadow++;                                                                                          goto X;                                                                                      }                                                                                      else if ((quadrant[i1 + 3] > quadrant[i2 + 3]))                                                                                      {                                                                                          goto HAMMER;                                                                                      }                                                                                      else {                                                                                          goto END_HAMMER;                                                                                      }                                                                                  }                                                                                  else if ((block[i1 + 4] & 0xff) > (block[i2 + 4] & 0xff))                                                                                  {                                                                                      goto HAMMER;                                                                                  }                                                                                  else {                                                                                      goto END_HAMMER;                                                                                  }                                                                              }                                                                              else if ((quadrant[i1 + 2] > quadrant[i2 + 2]))                                                                              {                                                                                  goto HAMMER;                                                                              }                                                                              else {                                                                                  goto END_HAMMER;                                                                              }                                                                          }                                                                          else if ((block[i1 + 3] & 0xff) > (block[i2 + 3] & 0xff))                                                                          {                                                                              goto HAMMER;                                                                          }                                                                          else {                                                                              goto END_HAMMER;                                                                          }                                                                      }                                                                      else if ((quadrant[i1 + 1] > quadrant[i2 + 1]))                                                                      {                                                                          goto HAMMER;                                                                      }                                                                      else {                                                                          goto END_HAMMER;                                                                      }                                                                  }                                                                  else if ((block[i1 + 2] & 0xff) > (block[i2 + 2] & 0xff))                                                                  {                                                                      goto HAMMER;                                                                  }                                                                  else {                                                                      goto END_HAMMER;                                                                  }                                                              }                                                              else if ((quadrant[i1] > quadrant[i2]))                                                              {                                                                  goto HAMMER;                                                              }                                                              else {                                                                  goto END_HAMMER;                                                              }                                                          }                                                          else if ((block[i1 + 1] & 0xff) > (block[i2 + 1] & 0xff))                                                          {                                                              goto HAMMER;                                                          }                                                          else {                                                              goto END_HAMMER;                                                          }                                                        }
Magic Number,Ionic.BZip2,BZip2Compressor,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\BZip2\BZip2Compressor.cs,mainSimpleSort,The following statement contains a magic number: X: while (x > 0)                                                      {                                                          x -= 4;                                                            if (block[i1 + 1] == block[i2 + 1])                                                          {                                                              if (quadrant[i1] == quadrant[i2])                                                              {                                                                  if (block[i1 + 2] == block[i2 + 2])                                                                  {                                                                      if (quadrant[i1 + 1] == quadrant[i2 + 1])                                                                      {                                                                          if (block[i1 + 3] == block[i2 + 3])                                                                          {                                                                              if (quadrant[i1 + 2] == quadrant[i2 + 2])                                                                              {                                                                                  if (block[i1 + 4] == block[i2 + 4])                                                                                  {                                                                                      if (quadrant[i1 + 3] == quadrant[i2 + 3])                                                                                      {                                                                                          if ((i1 += 4) >= lastPlus1)                                                                                          {                                                                                              i1 -= lastPlus1;                                                                                          }                                                                                          if ((i2 += 4) >= lastPlus1)                                                                                          {                                                                                              i2 -= lastPlus1;                                                                                          }                                                                                          workDoneShadow++;                                                                                          goto X;                                                                                      }                                                                                      else if ((quadrant[i1 + 3] > quadrant[i2 + 3]))                                                                                      {                                                                                          goto HAMMER;                                                                                      }                                                                                      else {                                                                                          goto END_HAMMER;                                                                                      }                                                                                  }                                                                                  else if ((block[i1 + 4] & 0xff) > (block[i2 + 4] & 0xff))                                                                                  {                                                                                      goto HAMMER;                                                                                  }                                                                                  else {                                                                                      goto END_HAMMER;                                                                                  }                                                                              }                                                                              else if ((quadrant[i1 + 2] > quadrant[i2 + 2]))                                                                              {                                                                                  goto HAMMER;                                                                              }                                                                              else {                                                                                  goto END_HAMMER;                                                                              }                                                                          }                                                                          else if ((block[i1 + 3] & 0xff) > (block[i2 + 3] & 0xff))                                                                          {                                                                              goto HAMMER;                                                                          }                                                                          else {                                                                              goto END_HAMMER;                                                                          }                                                                      }                                                                      else if ((quadrant[i1 + 1] > quadrant[i2 + 1]))                                                                      {                                                                          goto HAMMER;                                                                      }                                                                      else {                                                                          goto END_HAMMER;                                                                      }                                                                  }                                                                  else if ((block[i1 + 2] & 0xff) > (block[i2 + 2] & 0xff))                                                                  {                                                                      goto HAMMER;                                                                  }                                                                  else {                                                                      goto END_HAMMER;                                                                  }                                                              }                                                              else if ((quadrant[i1] > quadrant[i2]))                                                              {                                                                  goto HAMMER;                                                              }                                                              else {                                                                  goto END_HAMMER;                                                              }                                                          }                                                          else if ((block[i1 + 1] & 0xff) > (block[i2 + 1] & 0xff))                                                          {                                                              goto HAMMER;                                                          }                                                          else {                                                              goto END_HAMMER;                                                          }                                                        }
Magic Number,Ionic.BZip2,BZip2Compressor,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\BZip2\BZip2Compressor.cs,mainSimpleSort,The following statement contains a magic number: X: while (x > 0)                                                      {                                                          x -= 4;                                                            if (block[i1 + 1] == block[i2 + 1])                                                          {                                                              if (quadrant[i1] == quadrant[i2])                                                              {                                                                  if (block[i1 + 2] == block[i2 + 2])                                                                  {                                                                      if (quadrant[i1 + 1] == quadrant[i2 + 1])                                                                      {                                                                          if (block[i1 + 3] == block[i2 + 3])                                                                          {                                                                              if (quadrant[i1 + 2] == quadrant[i2 + 2])                                                                              {                                                                                  if (block[i1 + 4] == block[i2 + 4])                                                                                  {                                                                                      if (quadrant[i1 + 3] == quadrant[i2 + 3])                                                                                      {                                                                                          if ((i1 += 4) >= lastPlus1)                                                                                          {                                                                                              i1 -= lastPlus1;                                                                                          }                                                                                          if ((i2 += 4) >= lastPlus1)                                                                                          {                                                                                              i2 -= lastPlus1;                                                                                          }                                                                                          workDoneShadow++;                                                                                          goto X;                                                                                      }                                                                                      else if ((quadrant[i1 + 3] > quadrant[i2 + 3]))                                                                                      {                                                                                          goto HAMMER;                                                                                      }                                                                                      else {                                                                                          goto END_HAMMER;                                                                                      }                                                                                  }                                                                                  else if ((block[i1 + 4] & 0xff) > (block[i2 + 4] & 0xff))                                                                                  {                                                                                      goto HAMMER;                                                                                  }                                                                                  else {                                                                                      goto END_HAMMER;                                                                                  }                                                                              }                                                                              else if ((quadrant[i1 + 2] > quadrant[i2 + 2]))                                                                              {                                                                                  goto HAMMER;                                                                              }                                                                              else {                                                                                  goto END_HAMMER;                                                                              }                                                                          }                                                                          else if ((block[i1 + 3] & 0xff) > (block[i2 + 3] & 0xff))                                                                          {                                                                              goto HAMMER;                                                                          }                                                                          else {                                                                              goto END_HAMMER;                                                                          }                                                                      }                                                                      else if ((quadrant[i1 + 1] > quadrant[i2 + 1]))                                                                      {                                                                          goto HAMMER;                                                                      }                                                                      else {                                                                          goto END_HAMMER;                                                                      }                                                                  }                                                                  else if ((block[i1 + 2] & 0xff) > (block[i2 + 2] & 0xff))                                                                  {                                                                      goto HAMMER;                                                                  }                                                                  else {                                                                      goto END_HAMMER;                                                                  }                                                              }                                                              else if ((quadrant[i1] > quadrant[i2]))                                                              {                                                                  goto HAMMER;                                                              }                                                              else {                                                                  goto END_HAMMER;                                                              }                                                          }                                                          else if ((block[i1 + 1] & 0xff) > (block[i2 + 1] & 0xff))                                                          {                                                              goto HAMMER;                                                          }                                                          else {                                                              goto END_HAMMER;                                                          }                                                        }
Magic Number,Ionic.BZip2,BZip2Compressor,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\BZip2\BZip2Compressor.cs,mainSimpleSort,The following statement contains a magic number: X: while (x > 0)                                                      {                                                          x -= 4;                                                            if (block[i1 + 1] == block[i2 + 1])                                                          {                                                              if (quadrant[i1] == quadrant[i2])                                                              {                                                                  if (block[i1 + 2] == block[i2 + 2])                                                                  {                                                                      if (quadrant[i1 + 1] == quadrant[i2 + 1])                                                                      {                                                                          if (block[i1 + 3] == block[i2 + 3])                                                                          {                                                                              if (quadrant[i1 + 2] == quadrant[i2 + 2])                                                                              {                                                                                  if (block[i1 + 4] == block[i2 + 4])                                                                                  {                                                                                      if (quadrant[i1 + 3] == quadrant[i2 + 3])                                                                                      {                                                                                          if ((i1 += 4) >= lastPlus1)                                                                                          {                                                                                              i1 -= lastPlus1;                                                                                          }                                                                                          if ((i2 += 4) >= lastPlus1)                                                                                          {                                                                                              i2 -= lastPlus1;                                                                                          }                                                                                          workDoneShadow++;                                                                                          goto X;                                                                                      }                                                                                      else if ((quadrant[i1 + 3] > quadrant[i2 + 3]))                                                                                      {                                                                                          goto HAMMER;                                                                                      }                                                                                      else {                                                                                          goto END_HAMMER;                                                                                      }                                                                                  }                                                                                  else if ((block[i1 + 4] & 0xff) > (block[i2 + 4] & 0xff))                                                                                  {                                                                                      goto HAMMER;                                                                                  }                                                                                  else {                                                                                      goto END_HAMMER;                                                                                  }                                                                              }                                                                              else if ((quadrant[i1 + 2] > quadrant[i2 + 2]))                                                                              {                                                                                  goto HAMMER;                                                                              }                                                                              else {                                                                                  goto END_HAMMER;                                                                              }                                                                          }                                                                          else if ((block[i1 + 3] & 0xff) > (block[i2 + 3] & 0xff))                                                                          {                                                                              goto HAMMER;                                                                          }                                                                          else {                                                                              goto END_HAMMER;                                                                          }                                                                      }                                                                      else if ((quadrant[i1 + 1] > quadrant[i2 + 1]))                                                                      {                                                                          goto HAMMER;                                                                      }                                                                      else {                                                                          goto END_HAMMER;                                                                      }                                                                  }                                                                  else if ((block[i1 + 2] & 0xff) > (block[i2 + 2] & 0xff))                                                                  {                                                                      goto HAMMER;                                                                  }                                                                  else {                                                                      goto END_HAMMER;                                                                  }                                                              }                                                              else if ((quadrant[i1] > quadrant[i2]))                                                              {                                                                  goto HAMMER;                                                              }                                                              else {                                                                  goto END_HAMMER;                                                              }                                                          }                                                          else if ((block[i1 + 1] & 0xff) > (block[i2 + 1] & 0xff))                                                          {                                                              goto HAMMER;                                                          }                                                          else {                                                              goto END_HAMMER;                                                          }                                                        }
Magic Number,Ionic.BZip2,BZip2Compressor,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\BZip2\BZip2Compressor.cs,mainSimpleSort,The following statement contains a magic number: X: while (x > 0)                                                      {                                                          x -= 4;                                                            if (block[i1 + 1] == block[i2 + 1])                                                          {                                                              if (quadrant[i1] == quadrant[i2])                                                              {                                                                  if (block[i1 + 2] == block[i2 + 2])                                                                  {                                                                      if (quadrant[i1 + 1] == quadrant[i2 + 1])                                                                      {                                                                          if (block[i1 + 3] == block[i2 + 3])                                                                          {                                                                              if (quadrant[i1 + 2] == quadrant[i2 + 2])                                                                              {                                                                                  if (block[i1 + 4] == block[i2 + 4])                                                                                  {                                                                                      if (quadrant[i1 + 3] == quadrant[i2 + 3])                                                                                      {                                                                                          if ((i1 += 4) >= lastPlus1)                                                                                          {                                                                                              i1 -= lastPlus1;                                                                                          }                                                                                          if ((i2 += 4) >= lastPlus1)                                                                                          {                                                                                              i2 -= lastPlus1;                                                                                          }                                                                                          workDoneShadow++;                                                                                          goto X;                                                                                      }                                                                                      else if ((quadrant[i1 + 3] > quadrant[i2 + 3]))                                                                                      {                                                                                          goto HAMMER;                                                                                      }                                                                                      else {                                                                                          goto END_HAMMER;                                                                                      }                                                                                  }                                                                                  else if ((block[i1 + 4] & 0xff) > (block[i2 + 4] & 0xff))                                                                                  {                                                                                      goto HAMMER;                                                                                  }                                                                                  else {                                                                                      goto END_HAMMER;                                                                                  }                                                                              }                                                                              else if ((quadrant[i1 + 2] > quadrant[i2 + 2]))                                                                              {                                                                                  goto HAMMER;                                                                              }                                                                              else {                                                                                  goto END_HAMMER;                                                                              }                                                                          }                                                                          else if ((block[i1 + 3] & 0xff) > (block[i2 + 3] & 0xff))                                                                          {                                                                              goto HAMMER;                                                                          }                                                                          else {                                                                              goto END_HAMMER;                                                                          }                                                                      }                                                                      else if ((quadrant[i1 + 1] > quadrant[i2 + 1]))                                                                      {                                                                          goto HAMMER;                                                                      }                                                                      else {                                                                          goto END_HAMMER;                                                                      }                                                                  }                                                                  else if ((block[i1 + 2] & 0xff) > (block[i2 + 2] & 0xff))                                                                  {                                                                      goto HAMMER;                                                                  }                                                                  else {                                                                      goto END_HAMMER;                                                                  }                                                              }                                                              else if ((quadrant[i1] > quadrant[i2]))                                                              {                                                                  goto HAMMER;                                                              }                                                              else {                                                                  goto END_HAMMER;                                                              }                                                          }                                                          else if ((block[i1 + 1] & 0xff) > (block[i2 + 1] & 0xff))                                                          {                                                              goto HAMMER;                                                          }                                                          else {                                                              goto END_HAMMER;                                                          }                                                        }
Magic Number,Ionic.BZip2,BZip2Compressor,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\BZip2\BZip2Compressor.cs,mainSimpleSort,The following statement contains a magic number: X: while (x > 0)                                                      {                                                          x -= 4;                                                            if (block[i1 + 1] == block[i2 + 1])                                                          {                                                              if (quadrant[i1] == quadrant[i2])                                                              {                                                                  if (block[i1 + 2] == block[i2 + 2])                                                                  {                                                                      if (quadrant[i1 + 1] == quadrant[i2 + 1])                                                                      {                                                                          if (block[i1 + 3] == block[i2 + 3])                                                                          {                                                                              if (quadrant[i1 + 2] == quadrant[i2 + 2])                                                                              {                                                                                  if (block[i1 + 4] == block[i2 + 4])                                                                                  {                                                                                      if (quadrant[i1 + 3] == quadrant[i2 + 3])                                                                                      {                                                                                          if ((i1 += 4) >= lastPlus1)                                                                                          {                                                                                              i1 -= lastPlus1;                                                                                          }                                                                                          if ((i2 += 4) >= lastPlus1)                                                                                          {                                                                                              i2 -= lastPlus1;                                                                                          }                                                                                          workDoneShadow++;                                                                                          goto X;                                                                                      }                                                                                      else if ((quadrant[i1 + 3] > quadrant[i2 + 3]))                                                                                      {                                                                                          goto HAMMER;                                                                                      }                                                                                      else {                                                                                          goto END_HAMMER;                                                                                      }                                                                                  }                                                                                  else if ((block[i1 + 4] & 0xff) > (block[i2 + 4] & 0xff))                                                                                  {                                                                                      goto HAMMER;                                                                                  }                                                                                  else {                                                                                      goto END_HAMMER;                                                                                  }                                                                              }                                                                              else if ((quadrant[i1 + 2] > quadrant[i2 + 2]))                                                                              {                                                                                  goto HAMMER;                                                                              }                                                                              else {                                                                                  goto END_HAMMER;                                                                              }                                                                          }                                                                          else if ((block[i1 + 3] & 0xff) > (block[i2 + 3] & 0xff))                                                                          {                                                                              goto HAMMER;                                                                          }                                                                          else {                                                                              goto END_HAMMER;                                                                          }                                                                      }                                                                      else if ((quadrant[i1 + 1] > quadrant[i2 + 1]))                                                                      {                                                                          goto HAMMER;                                                                      }                                                                      else {                                                                          goto END_HAMMER;                                                                      }                                                                  }                                                                  else if ((block[i1 + 2] & 0xff) > (block[i2 + 2] & 0xff))                                                                  {                                                                      goto HAMMER;                                                                  }                                                                  else {                                                                      goto END_HAMMER;                                                                  }                                                              }                                                              else if ((quadrant[i1] > quadrant[i2]))                                                              {                                                                  goto HAMMER;                                                              }                                                              else {                                                                  goto END_HAMMER;                                                              }                                                          }                                                          else if ((block[i1 + 1] & 0xff) > (block[i2 + 1] & 0xff))                                                          {                                                              goto HAMMER;                                                          }                                                          else {                                                              goto END_HAMMER;                                                          }                                                        }
Magic Number,Ionic.BZip2,BZip2Compressor,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\BZip2\BZip2Compressor.cs,mainSimpleSort,The following statement contains a magic number: X: while (x > 0)                                                      {                                                          x -= 4;                                                            if (block[i1 + 1] == block[i2 + 1])                                                          {                                                              if (quadrant[i1] == quadrant[i2])                                                              {                                                                  if (block[i1 + 2] == block[i2 + 2])                                                                  {                                                                      if (quadrant[i1 + 1] == quadrant[i2 + 1])                                                                      {                                                                          if (block[i1 + 3] == block[i2 + 3])                                                                          {                                                                              if (quadrant[i1 + 2] == quadrant[i2 + 2])                                                                              {                                                                                  if (block[i1 + 4] == block[i2 + 4])                                                                                  {                                                                                      if (quadrant[i1 + 3] == quadrant[i2 + 3])                                                                                      {                                                                                          if ((i1 += 4) >= lastPlus1)                                                                                          {                                                                                              i1 -= lastPlus1;                                                                                          }                                                                                          if ((i2 += 4) >= lastPlus1)                                                                                          {                                                                                              i2 -= lastPlus1;                                                                                          }                                                                                          workDoneShadow++;                                                                                          goto X;                                                                                      }                                                                                      else if ((quadrant[i1 + 3] > quadrant[i2 + 3]))                                                                                      {                                                                                          goto HAMMER;                                                                                      }                                                                                      else {                                                                                          goto END_HAMMER;                                                                                      }                                                                                  }                                                                                  else if ((block[i1 + 4] & 0xff) > (block[i2 + 4] & 0xff))                                                                                  {                                                                                      goto HAMMER;                                                                                  }                                                                                  else {                                                                                      goto END_HAMMER;                                                                                  }                                                                              }                                                                              else if ((quadrant[i1 + 2] > quadrant[i2 + 2]))                                                                              {                                                                                  goto HAMMER;                                                                              }                                                                              else {                                                                                  goto END_HAMMER;                                                                              }                                                                          }                                                                          else if ((block[i1 + 3] & 0xff) > (block[i2 + 3] & 0xff))                                                                          {                                                                              goto HAMMER;                                                                          }                                                                          else {                                                                              goto END_HAMMER;                                                                          }                                                                      }                                                                      else if ((quadrant[i1 + 1] > quadrant[i2 + 1]))                                                                      {                                                                          goto HAMMER;                                                                      }                                                                      else {                                                                          goto END_HAMMER;                                                                      }                                                                  }                                                                  else if ((block[i1 + 2] & 0xff) > (block[i2 + 2] & 0xff))                                                                  {                                                                      goto HAMMER;                                                                  }                                                                  else {                                                                      goto END_HAMMER;                                                                  }                                                              }                                                              else if ((quadrant[i1] > quadrant[i2]))                                                              {                                                                  goto HAMMER;                                                              }                                                              else {                                                                  goto END_HAMMER;                                                              }                                                          }                                                          else if ((block[i1 + 1] & 0xff) > (block[i2 + 1] & 0xff))                                                          {                                                              goto HAMMER;                                                          }                                                          else {                                                              goto END_HAMMER;                                                          }                                                        }
Magic Number,Ionic.BZip2,BZip2Compressor,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\BZip2\BZip2Compressor.cs,mainSimpleSort,The following statement contains a magic number: X: while (x > 0)                                                      {                                                          x -= 4;                                                            if (block[i1 + 1] == block[i2 + 1])                                                          {                                                              if (quadrant[i1] == quadrant[i2])                                                              {                                                                  if (block[i1 + 2] == block[i2 + 2])                                                                  {                                                                      if (quadrant[i1 + 1] == quadrant[i2 + 1])                                                                      {                                                                          if (block[i1 + 3] == block[i2 + 3])                                                                          {                                                                              if (quadrant[i1 + 2] == quadrant[i2 + 2])                                                                              {                                                                                  if (block[i1 + 4] == block[i2 + 4])                                                                                  {                                                                                      if (quadrant[i1 + 3] == quadrant[i2 + 3])                                                                                      {                                                                                          if ((i1 += 4) >= lastPlus1)                                                                                          {                                                                                              i1 -= lastPlus1;                                                                                          }                                                                                          if ((i2 += 4) >= lastPlus1)                                                                                          {                                                                                              i2 -= lastPlus1;                                                                                          }                                                                                          workDoneShadow++;                                                                                          goto X;                                                                                      }                                                                                      else if ((quadrant[i1 + 3] > quadrant[i2 + 3]))                                                                                      {                                                                                          goto HAMMER;                                                                                      }                                                                                      else {                                                                                          goto END_HAMMER;                                                                                      }                                                                                  }                                                                                  else if ((block[i1 + 4] & 0xff) > (block[i2 + 4] & 0xff))                                                                                  {                                                                                      goto HAMMER;                                                                                  }                                                                                  else {                                                                                      goto END_HAMMER;                                                                                  }                                                                              }                                                                              else if ((quadrant[i1 + 2] > quadrant[i2 + 2]))                                                                              {                                                                                  goto HAMMER;                                                                              }                                                                              else {                                                                                  goto END_HAMMER;                                                                              }                                                                          }                                                                          else if ((block[i1 + 3] & 0xff) > (block[i2 + 3] & 0xff))                                                                          {                                                                              goto HAMMER;                                                                          }                                                                          else {                                                                              goto END_HAMMER;                                                                          }                                                                      }                                                                      else if ((quadrant[i1 + 1] > quadrant[i2 + 1]))                                                                      {                                                                          goto HAMMER;                                                                      }                                                                      else {                                                                          goto END_HAMMER;                                                                      }                                                                  }                                                                  else if ((block[i1 + 2] & 0xff) > (block[i2 + 2] & 0xff))                                                                  {                                                                      goto HAMMER;                                                                  }                                                                  else {                                                                      goto END_HAMMER;                                                                  }                                                              }                                                              else if ((quadrant[i1] > quadrant[i2]))                                                              {                                                                  goto HAMMER;                                                              }                                                              else {                                                                  goto END_HAMMER;                                                              }                                                          }                                                          else if ((block[i1 + 1] & 0xff) > (block[i2 + 1] & 0xff))                                                          {                                                              goto HAMMER;                                                          }                                                          else {                                                              goto END_HAMMER;                                                          }                                                        }
Magic Number,Ionic.BZip2,BZip2Compressor,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\BZip2\BZip2Compressor.cs,mainSimpleSort,The following statement contains a magic number: X: while (x > 0)                                                      {                                                          x -= 4;                                                            if (block[i1 + 1] == block[i2 + 1])                                                          {                                                              if (quadrant[i1] == quadrant[i2])                                                              {                                                                  if (block[i1 + 2] == block[i2 + 2])                                                                  {                                                                      if (quadrant[i1 + 1] == quadrant[i2 + 1])                                                                      {                                                                          if (block[i1 + 3] == block[i2 + 3])                                                                          {                                                                              if (quadrant[i1 + 2] == quadrant[i2 + 2])                                                                              {                                                                                  if (block[i1 + 4] == block[i2 + 4])                                                                                  {                                                                                      if (quadrant[i1 + 3] == quadrant[i2 + 3])                                                                                      {                                                                                          if ((i1 += 4) >= lastPlus1)                                                                                          {                                                                                              i1 -= lastPlus1;                                                                                          }                                                                                          if ((i2 += 4) >= lastPlus1)                                                                                          {                                                                                              i2 -= lastPlus1;                                                                                          }                                                                                          workDoneShadow++;                                                                                          goto X;                                                                                      }                                                                                      else if ((quadrant[i1 + 3] > quadrant[i2 + 3]))                                                                                      {                                                                                          goto HAMMER;                                                                                      }                                                                                      else {                                                                                          goto END_HAMMER;                                                                                      }                                                                                  }                                                                                  else if ((block[i1 + 4] & 0xff) > (block[i2 + 4] & 0xff))                                                                                  {                                                                                      goto HAMMER;                                                                                  }                                                                                  else {                                                                                      goto END_HAMMER;                                                                                  }                                                                              }                                                                              else if ((quadrant[i1 + 2] > quadrant[i2 + 2]))                                                                              {                                                                                  goto HAMMER;                                                                              }                                                                              else {                                                                                  goto END_HAMMER;                                                                              }                                                                          }                                                                          else if ((block[i1 + 3] & 0xff) > (block[i2 + 3] & 0xff))                                                                          {                                                                              goto HAMMER;                                                                          }                                                                          else {                                                                              goto END_HAMMER;                                                                          }                                                                      }                                                                      else if ((quadrant[i1 + 1] > quadrant[i2 + 1]))                                                                      {                                                                          goto HAMMER;                                                                      }                                                                      else {                                                                          goto END_HAMMER;                                                                      }                                                                  }                                                                  else if ((block[i1 + 2] & 0xff) > (block[i2 + 2] & 0xff))                                                                  {                                                                      goto HAMMER;                                                                  }                                                                  else {                                                                      goto END_HAMMER;                                                                  }                                                              }                                                              else if ((quadrant[i1] > quadrant[i2]))                                                              {                                                                  goto HAMMER;                                                              }                                                              else {                                                                  goto END_HAMMER;                                                              }                                                          }                                                          else if ((block[i1 + 1] & 0xff) > (block[i2 + 1] & 0xff))                                                          {                                                              goto HAMMER;                                                          }                                                          else {                                                              goto END_HAMMER;                                                          }                                                        }
Magic Number,Ionic.BZip2,BZip2Compressor,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\BZip2\BZip2Compressor.cs,mainSimpleSort,The following statement contains a magic number: X: while (x > 0)                                                      {                                                          x -= 4;                                                            if (block[i1 + 1] == block[i2 + 1])                                                          {                                                              if (quadrant[i1] == quadrant[i2])                                                              {                                                                  if (block[i1 + 2] == block[i2 + 2])                                                                  {                                                                      if (quadrant[i1 + 1] == quadrant[i2 + 1])                                                                      {                                                                          if (block[i1 + 3] == block[i2 + 3])                                                                          {                                                                              if (quadrant[i1 + 2] == quadrant[i2 + 2])                                                                              {                                                                                  if (block[i1 + 4] == block[i2 + 4])                                                                                  {                                                                                      if (quadrant[i1 + 3] == quadrant[i2 + 3])                                                                                      {                                                                                          if ((i1 += 4) >= lastPlus1)                                                                                          {                                                                                              i1 -= lastPlus1;                                                                                          }                                                                                          if ((i2 += 4) >= lastPlus1)                                                                                          {                                                                                              i2 -= lastPlus1;                                                                                          }                                                                                          workDoneShadow++;                                                                                          goto X;                                                                                      }                                                                                      else if ((quadrant[i1 + 3] > quadrant[i2 + 3]))                                                                                      {                                                                                          goto HAMMER;                                                                                      }                                                                                      else {                                                                                          goto END_HAMMER;                                                                                      }                                                                                  }                                                                                  else if ((block[i1 + 4] & 0xff) > (block[i2 + 4] & 0xff))                                                                                  {                                                                                      goto HAMMER;                                                                                  }                                                                                  else {                                                                                      goto END_HAMMER;                                                                                  }                                                                              }                                                                              else if ((quadrant[i1 + 2] > quadrant[i2 + 2]))                                                                              {                                                                                  goto HAMMER;                                                                              }                                                                              else {                                                                                  goto END_HAMMER;                                                                              }                                                                          }                                                                          else if ((block[i1 + 3] & 0xff) > (block[i2 + 3] & 0xff))                                                                          {                                                                              goto HAMMER;                                                                          }                                                                          else {                                                                              goto END_HAMMER;                                                                          }                                                                      }                                                                      else if ((quadrant[i1 + 1] > quadrant[i2 + 1]))                                                                      {                                                                          goto HAMMER;                                                                      }                                                                      else {                                                                          goto END_HAMMER;                                                                      }                                                                  }                                                                  else if ((block[i1 + 2] & 0xff) > (block[i2 + 2] & 0xff))                                                                  {                                                                      goto HAMMER;                                                                  }                                                                  else {                                                                      goto END_HAMMER;                                                                  }                                                              }                                                              else if ((quadrant[i1] > quadrant[i2]))                                                              {                                                                  goto HAMMER;                                                              }                                                              else {                                                                  goto END_HAMMER;                                                              }                                                          }                                                          else if ((block[i1 + 1] & 0xff) > (block[i2 + 1] & 0xff))                                                          {                                                              goto HAMMER;                                                          }                                                          else {                                                              goto END_HAMMER;                                                          }                                                        }
Magic Number,Ionic.BZip2,BZip2Compressor,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\BZip2\BZip2Compressor.cs,mainSimpleSort,The following statement contains a magic number: X: while (x > 0)                                                      {                                                          x -= 4;                                                            if (block[i1 + 1] == block[i2 + 1])                                                          {                                                              if (quadrant[i1] == quadrant[i2])                                                              {                                                                  if (block[i1 + 2] == block[i2 + 2])                                                                  {                                                                      if (quadrant[i1 + 1] == quadrant[i2 + 1])                                                                      {                                                                          if (block[i1 + 3] == block[i2 + 3])                                                                          {                                                                              if (quadrant[i1 + 2] == quadrant[i2 + 2])                                                                              {                                                                                  if (block[i1 + 4] == block[i2 + 4])                                                                                  {                                                                                      if (quadrant[i1 + 3] == quadrant[i2 + 3])                                                                                      {                                                                                          if ((i1 += 4) >= lastPlus1)                                                                                          {                                                                                              i1 -= lastPlus1;                                                                                          }                                                                                          if ((i2 += 4) >= lastPlus1)                                                                                          {                                                                                              i2 -= lastPlus1;                                                                                          }                                                                                          workDoneShadow++;                                                                                          goto X;                                                                                      }                                                                                      else if ((quadrant[i1 + 3] > quadrant[i2 + 3]))                                                                                      {                                                                                          goto HAMMER;                                                                                      }                                                                                      else {                                                                                          goto END_HAMMER;                                                                                      }                                                                                  }                                                                                  else if ((block[i1 + 4] & 0xff) > (block[i2 + 4] & 0xff))                                                                                  {                                                                                      goto HAMMER;                                                                                  }                                                                                  else {                                                                                      goto END_HAMMER;                                                                                  }                                                                              }                                                                              else if ((quadrant[i1 + 2] > quadrant[i2 + 2]))                                                                              {                                                                                  goto HAMMER;                                                                              }                                                                              else {                                                                                  goto END_HAMMER;                                                                              }                                                                          }                                                                          else if ((block[i1 + 3] & 0xff) > (block[i2 + 3] & 0xff))                                                                          {                                                                              goto HAMMER;                                                                          }                                                                          else {                                                                              goto END_HAMMER;                                                                          }                                                                      }                                                                      else if ((quadrant[i1 + 1] > quadrant[i2 + 1]))                                                                      {                                                                          goto HAMMER;                                                                      }                                                                      else {                                                                          goto END_HAMMER;                                                                      }                                                                  }                                                                  else if ((block[i1 + 2] & 0xff) > (block[i2 + 2] & 0xff))                                                                  {                                                                      goto HAMMER;                                                                  }                                                                  else {                                                                      goto END_HAMMER;                                                                  }                                                              }                                                              else if ((quadrant[i1] > quadrant[i2]))                                                              {                                                                  goto HAMMER;                                                              }                                                              else {                                                                  goto END_HAMMER;                                                              }                                                          }                                                          else if ((block[i1 + 1] & 0xff) > (block[i2 + 1] & 0xff))                                                          {                                                              goto HAMMER;                                                          }                                                          else {                                                              goto END_HAMMER;                                                          }                                                        }
Magic Number,Ionic.BZip2,BZip2Compressor,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\BZip2\BZip2Compressor.cs,mainSimpleSort,The following statement contains a magic number: X: while (x > 0)                                                      {                                                          x -= 4;                                                            if (block[i1 + 1] == block[i2 + 1])                                                          {                                                              if (quadrant[i1] == quadrant[i2])                                                              {                                                                  if (block[i1 + 2] == block[i2 + 2])                                                                  {                                                                      if (quadrant[i1 + 1] == quadrant[i2 + 1])                                                                      {                                                                          if (block[i1 + 3] == block[i2 + 3])                                                                          {                                                                              if (quadrant[i1 + 2] == quadrant[i2 + 2])                                                                              {                                                                                  if (block[i1 + 4] == block[i2 + 4])                                                                                  {                                                                                      if (quadrant[i1 + 3] == quadrant[i2 + 3])                                                                                      {                                                                                          if ((i1 += 4) >= lastPlus1)                                                                                          {                                                                                              i1 -= lastPlus1;                                                                                          }                                                                                          if ((i2 += 4) >= lastPlus1)                                                                                          {                                                                                              i2 -= lastPlus1;                                                                                          }                                                                                          workDoneShadow++;                                                                                          goto X;                                                                                      }                                                                                      else if ((quadrant[i1 + 3] > quadrant[i2 + 3]))                                                                                      {                                                                                          goto HAMMER;                                                                                      }                                                                                      else {                                                                                          goto END_HAMMER;                                                                                      }                                                                                  }                                                                                  else if ((block[i1 + 4] & 0xff) > (block[i2 + 4] & 0xff))                                                                                  {                                                                                      goto HAMMER;                                                                                  }                                                                                  else {                                                                                      goto END_HAMMER;                                                                                  }                                                                              }                                                                              else if ((quadrant[i1 + 2] > quadrant[i2 + 2]))                                                                              {                                                                                  goto HAMMER;                                                                              }                                                                              else {                                                                                  goto END_HAMMER;                                                                              }                                                                          }                                                                          else if ((block[i1 + 3] & 0xff) > (block[i2 + 3] & 0xff))                                                                          {                                                                              goto HAMMER;                                                                          }                                                                          else {                                                                              goto END_HAMMER;                                                                          }                                                                      }                                                                      else if ((quadrant[i1 + 1] > quadrant[i2 + 1]))                                                                      {                                                                          goto HAMMER;                                                                      }                                                                      else {                                                                          goto END_HAMMER;                                                                      }                                                                  }                                                                  else if ((block[i1 + 2] & 0xff) > (block[i2 + 2] & 0xff))                                                                  {                                                                      goto HAMMER;                                                                  }                                                                  else {                                                                      goto END_HAMMER;                                                                  }                                                              }                                                              else if ((quadrant[i1] > quadrant[i2]))                                                              {                                                                  goto HAMMER;                                                              }                                                              else {                                                                  goto END_HAMMER;                                                              }                                                          }                                                          else if ((block[i1 + 1] & 0xff) > (block[i2 + 1] & 0xff))                                                          {                                                              goto HAMMER;                                                          }                                                          else {                                                              goto END_HAMMER;                                                          }                                                        }
Magic Number,Ionic.BZip2,BZip2Compressor,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\BZip2\BZip2Compressor.cs,mainSimpleSort,The following statement contains a magic number: X: while (x > 0)                                                      {                                                          x -= 4;                                                            if (block[i1 + 1] == block[i2 + 1])                                                          {                                                              if (quadrant[i1] == quadrant[i2])                                                              {                                                                  if (block[i1 + 2] == block[i2 + 2])                                                                  {                                                                      if (quadrant[i1 + 1] == quadrant[i2 + 1])                                                                      {                                                                          if (block[i1 + 3] == block[i2 + 3])                                                                          {                                                                              if (quadrant[i1 + 2] == quadrant[i2 + 2])                                                                              {                                                                                  if (block[i1 + 4] == block[i2 + 4])                                                                                  {                                                                                      if (quadrant[i1 + 3] == quadrant[i2 + 3])                                                                                      {                                                                                          if ((i1 += 4) >= lastPlus1)                                                                                          {                                                                                              i1 -= lastPlus1;                                                                                          }                                                                                          if ((i2 += 4) >= lastPlus1)                                                                                          {                                                                                              i2 -= lastPlus1;                                                                                          }                                                                                          workDoneShadow++;                                                                                          goto X;                                                                                      }                                                                                      else if ((quadrant[i1 + 3] > quadrant[i2 + 3]))                                                                                      {                                                                                          goto HAMMER;                                                                                      }                                                                                      else {                                                                                          goto END_HAMMER;                                                                                      }                                                                                  }                                                                                  else if ((block[i1 + 4] & 0xff) > (block[i2 + 4] & 0xff))                                                                                  {                                                                                      goto HAMMER;                                                                                  }                                                                                  else {                                                                                      goto END_HAMMER;                                                                                  }                                                                              }                                                                              else if ((quadrant[i1 + 2] > quadrant[i2 + 2]))                                                                              {                                                                                  goto HAMMER;                                                                              }                                                                              else {                                                                                  goto END_HAMMER;                                                                              }                                                                          }                                                                          else if ((block[i1 + 3] & 0xff) > (block[i2 + 3] & 0xff))                                                                          {                                                                              goto HAMMER;                                                                          }                                                                          else {                                                                              goto END_HAMMER;                                                                          }                                                                      }                                                                      else if ((quadrant[i1 + 1] > quadrant[i2 + 1]))                                                                      {                                                                          goto HAMMER;                                                                      }                                                                      else {                                                                          goto END_HAMMER;                                                                      }                                                                  }                                                                  else if ((block[i1 + 2] & 0xff) > (block[i2 + 2] & 0xff))                                                                  {                                                                      goto HAMMER;                                                                  }                                                                  else {                                                                      goto END_HAMMER;                                                                  }                                                              }                                                              else if ((quadrant[i1] > quadrant[i2]))                                                              {                                                                  goto HAMMER;                                                              }                                                              else {                                                                  goto END_HAMMER;                                                              }                                                          }                                                          else if ((block[i1 + 1] & 0xff) > (block[i2 + 1] & 0xff))                                                          {                                                              goto HAMMER;                                                          }                                                          else {                                                              goto END_HAMMER;                                                          }                                                        }
Magic Number,Ionic.BZip2,BZip2Compressor,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\BZip2\BZip2Compressor.cs,generateMTFValues,The following statement contains a magic number: i < 256
Magic Number,Ionic.BZip2,BZip2Compressor,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\BZip2\BZip2Compressor.cs,generateMTFValues,The following statement contains a magic number: zPend = (zPend - 2) >> 1;
Magic Number,Ionic.BZip2,BZip2Compressor,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\BZip2\BZip2Compressor.cs,generateMTFValues,The following statement contains a magic number: zPend >= 2
Magic Number,Ionic.BZip2,BZip2Compressor,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\BZip2\BZip2Compressor.cs,sendMTFValues,The following statement contains a magic number: int alphaSize = this.nInUse + 2;
Magic Number,Ionic.BZip2,BZip2Compressor,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\BZip2\BZip2Compressor.cs,sendMTFValues,The following statement contains a magic number: int nGroups = (this.nMTF < 200) ? 2 : (this.nMTF < 600) ? 3                  : (this.nMTF < 1200) ? 4 : (this.nMTF < 2400) ? 5 : 6;
Magic Number,Ionic.BZip2,BZip2Compressor,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\BZip2\BZip2Compressor.cs,sendMTFValues,The following statement contains a magic number: int nGroups = (this.nMTF < 200) ? 2 : (this.nMTF < 600) ? 3                  : (this.nMTF < 1200) ? 4 : (this.nMTF < 2400) ? 5 : 6;
Magic Number,Ionic.BZip2,BZip2Compressor,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\BZip2\BZip2Compressor.cs,sendMTFValues,The following statement contains a magic number: int nGroups = (this.nMTF < 200) ? 2 : (this.nMTF < 600) ? 3                  : (this.nMTF < 1200) ? 4 : (this.nMTF < 2400) ? 5 : 6;
Magic Number,Ionic.BZip2,BZip2Compressor,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\BZip2\BZip2Compressor.cs,sendMTFValues,The following statement contains a magic number: int nGroups = (this.nMTF < 200) ? 2 : (this.nMTF < 600) ? 3                  : (this.nMTF < 1200) ? 4 : (this.nMTF < 2400) ? 5 : 6;
Magic Number,Ionic.BZip2,BZip2Compressor,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\BZip2\BZip2Compressor.cs,sendMTFValues,The following statement contains a magic number: int nGroups = (this.nMTF < 200) ? 2 : (this.nMTF < 600) ? 3                  : (this.nMTF < 1200) ? 4 : (this.nMTF < 2400) ? 5 : 6;
Magic Number,Ionic.BZip2,BZip2Compressor,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\BZip2\BZip2Compressor.cs,sendMTFValues,The following statement contains a magic number: int nGroups = (this.nMTF < 200) ? 2 : (this.nMTF < 600) ? 3                  : (this.nMTF < 1200) ? 4 : (this.nMTF < 2400) ? 5 : 6;
Magic Number,Ionic.BZip2,BZip2Compressor,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\BZip2\BZip2Compressor.cs,sendMTFValues,The following statement contains a magic number: int nGroups = (this.nMTF < 200) ? 2 : (this.nMTF < 600) ? 3                  : (this.nMTF < 1200) ? 4 : (this.nMTF < 2400) ? 5 : 6;
Magic Number,Ionic.BZip2,BZip2Compressor,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\BZip2\BZip2Compressor.cs,sendMTFValues,The following statement contains a magic number: int nGroups = (this.nMTF < 200) ? 2 : (this.nMTF < 600) ? 3                  : (this.nMTF < 1200) ? 4 : (this.nMTF < 2400) ? 5 : 6;
Magic Number,Ionic.BZip2,BZip2Compressor,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\BZip2\BZip2Compressor.cs,sendMTFValues,The following statement contains a magic number: int nGroups = (this.nMTF < 200) ? 2 : (this.nMTF < 600) ? 3                  : (this.nMTF < 1200) ? 4 : (this.nMTF < 2400) ? 5 : 6;
Magic Number,Ionic.BZip2,BZip2Compressor,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\BZip2\BZip2Compressor.cs,hbMakeCodeLengths,The following statement contains a magic number: weight[i + 1] = (freq[i] == 0 ? 1 : freq[i]) << 8;
Magic Number,Ionic.BZip2,BZip2Compressor,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\BZip2\BZip2Compressor.cs,hbMakeCodeLengths,The following statement contains a magic number: parent[0] = -2;
Magic Number,Ionic.BZip2,BZip2Compressor,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\BZip2\BZip2Compressor.cs,hbMakeCodeLengths,The following statement contains a magic number: int j = weight[i] >> 8;
Magic Number,Ionic.BZip2,BZip2Compressor,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\BZip2\BZip2Compressor.cs,hbMakeCodeLengths,The following statement contains a magic number: weight[i] = j << 8;
Magic Number,Ionic.BZip2,BZip2Compressor,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\BZip2\BZip2Compressor.cs,sendMTFValues1,The following statement contains a magic number: byte[] len_2 = len[2];
Magic Number,Ionic.BZip2,BZip2Compressor,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\BZip2\BZip2Compressor.cs,sendMTFValues1,The following statement contains a magic number: byte[] len_3 = len[3];
Magic Number,Ionic.BZip2,BZip2Compressor,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\BZip2\BZip2Compressor.cs,sendMTFValues1,The following statement contains a magic number: byte[] len_4 = len[4];
Magic Number,Ionic.BZip2,BZip2Compressor,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\BZip2\BZip2Compressor.cs,sendMTFValues1,The following statement contains a magic number: byte[] len_5 = len[5];
Magic Number,Ionic.BZip2,BZip2Compressor,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\BZip2\BZip2Compressor.cs,sendMTFValues1,The following statement contains a magic number: int[] c = new int[6];
Magic Number,Ionic.BZip2,BZip2Compressor,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\BZip2\BZip2Compressor.cs,sendMTFValues1,The following statement contains a magic number: c[2] += len_2[icv] & 0xff;
Magic Number,Ionic.BZip2,BZip2Compressor,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\BZip2\BZip2Compressor.cs,sendMTFValues1,The following statement contains a magic number: c[3] += len_3[icv] & 0xff;
Magic Number,Ionic.BZip2,BZip2Compressor,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\BZip2\BZip2Compressor.cs,sendMTFValues1,The following statement contains a magic number: c[4] += len_4[icv] & 0xff;
Magic Number,Ionic.BZip2,BZip2Compressor,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\BZip2\BZip2Compressor.cs,sendMTFValues1,The following statement contains a magic number: c[5] += len_5[icv] & 0xff;
Magic Number,Ionic.BZip2,BZip2Compressor,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\BZip2\BZip2Compressor.cs,sendMTFValues1,The following statement contains a magic number: cost[2] = (short) c[2];
Magic Number,Ionic.BZip2,BZip2Compressor,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\BZip2\BZip2Compressor.cs,sendMTFValues1,The following statement contains a magic number: cost[2] = (short) c[2];
Magic Number,Ionic.BZip2,BZip2Compressor,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\BZip2\BZip2Compressor.cs,sendMTFValues1,The following statement contains a magic number: cost[3] = (short) c[3];
Magic Number,Ionic.BZip2,BZip2Compressor,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\BZip2\BZip2Compressor.cs,sendMTFValues1,The following statement contains a magic number: cost[3] = (short) c[3];
Magic Number,Ionic.BZip2,BZip2Compressor,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\BZip2\BZip2Compressor.cs,sendMTFValues1,The following statement contains a magic number: cost[4] = (short) c[4];
Magic Number,Ionic.BZip2,BZip2Compressor,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\BZip2\BZip2Compressor.cs,sendMTFValues1,The following statement contains a magic number: cost[4] = (short) c[4];
Magic Number,Ionic.BZip2,BZip2Compressor,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\BZip2\BZip2Compressor.cs,sendMTFValues1,The following statement contains a magic number: cost[5] = (short) c[5];
Magic Number,Ionic.BZip2,BZip2Compressor,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\BZip2\BZip2Compressor.cs,sendMTFValues1,The following statement contains a magic number: cost[5] = (short) c[5];
Magic Number,Ionic.BZip2,BZip2Compressor,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\BZip2\BZip2Compressor.cs,sendMTFValues1,The following statement contains a magic number: hbMakeCodeLengths(len[t]' rfreq[t]' this.cstate' alphaSize' 20);
Magic Number,Ionic.BZip2,BZip2Compressor,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\BZip2\BZip2Compressor.cs,sendMTFValues3,The following statement contains a magic number: int minLen = 32;
Magic Number,Ionic.BZip2,BZip2Compressor,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\BZip2\BZip2Compressor.cs,sendMTFValues4,The following statement contains a magic number: int i16 = i * 16;
Magic Number,Ionic.BZip2,BZip2Compressor,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\BZip2\BZip2Compressor.cs,sendMTFValues4,The following statement contains a magic number: u |= 1U << (16 - i - 1);
Magic Number,Ionic.BZip2,BZip2Compressor,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\BZip2\BZip2Compressor.cs,sendMTFValues4,The following statement contains a magic number: i < 16
Magic Number,Ionic.BZip2,BZip2Compressor,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\BZip2\BZip2Compressor.cs,sendMTFValues4,The following statement contains a magic number: this.bw.WriteBits(16' u);
Magic Number,Ionic.BZip2,BZip2Compressor,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\BZip2\BZip2Compressor.cs,sendMTFValues4,The following statement contains a magic number: int i16 = i * 16;
Magic Number,Ionic.BZip2,BZip2Compressor,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\BZip2\BZip2Compressor.cs,sendMTFValues4,The following statement contains a magic number: u |= 1U << (16 - j - 1);
Magic Number,Ionic.BZip2,BZip2Compressor,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\BZip2\BZip2Compressor.cs,sendMTFValues4,The following statement contains a magic number: j < 16
Magic Number,Ionic.BZip2,BZip2Compressor,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\BZip2\BZip2Compressor.cs,sendMTFValues4,The following statement contains a magic number: this.bw.WriteBits(16' u);
Magic Number,Ionic.BZip2,BZip2Compressor,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\BZip2\BZip2Compressor.cs,sendMTFValues4,The following statement contains a magic number: i < 16
Magic Number,Ionic.BZip2,BZip2Compressor,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\BZip2\BZip2Compressor.cs,sendMTFValues5,The following statement contains a magic number: this.bw.WriteBits(3' (uint) nGroups);
Magic Number,Ionic.BZip2,BZip2Compressor,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\BZip2\BZip2Compressor.cs,sendMTFValues5,The following statement contains a magic number: this.bw.WriteBits(15' (uint) nSelectors);
Magic Number,Ionic.BZip2,BZip2Compressor,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\BZip2\BZip2Compressor.cs,sendMTFValues6,The following statement contains a magic number: this.bw.WriteBits(5' curr);
Magic Number,Ionic.BZip2,BZip2Compressor,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\BZip2\BZip2Compressor.cs,sendMTFValues6,The following statement contains a magic number: this.bw.WriteBits(2' 2U);
Magic Number,Ionic.BZip2,BZip2Compressor,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\BZip2\BZip2Compressor.cs,sendMTFValues6,The following statement contains a magic number: this.bw.WriteBits(2' 2U);
Magic Number,Ionic.BZip2,BZip2Compressor,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\BZip2\BZip2Compressor.cs,sendMTFValues6,The following statement contains a magic number: this.bw.WriteBits(2' 3U);
Magic Number,Ionic.BZip2,BZip2Compressor,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\BZip2\BZip2Compressor.cs,sendMTFValues6,The following statement contains a magic number: this.bw.WriteBits(2' 3U);
Magic Number,Ionic.BZip2,BZip2Compressor,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\BZip2\BZip2Compressor.cs,moveToFrontCodeAndSend,The following statement contains a magic number: this.bw.WriteBits(24' (uint) this.origPtr);
Magic Number,Ionic.BZip2,CompressionState,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\BZip2\BZip2Compressor.cs,CompressionState,The following statement contains a magic number: this.sfmap = new char[2 * n];
Magic Number,Ionic.BZip2,BZip2InputStream,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\BZip2\BZip2InputStream.cs,MakeMaps,The following statement contains a magic number: i < 256
Magic Number,Ionic.BZip2,BZip2InputStream,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\BZip2\BZip2InputStream.cs,init,The following statement contains a magic number: CheckMagicChar('h'' 2);
Magic Number,Ionic.BZip2,BZip2InputStream,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\BZip2\BZip2InputStream.cs,EndBlock,The following statement contains a magic number: this.computedCombinedCRC = (this.computedCombinedCRC << 1)                  | (this.computedCombinedCRC >> 31);
Magic Number,Ionic.BZip2,BZip2InputStream,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\BZip2\BZip2InputStream.cs,GetBits,The following statement contains a magic number: bsBuffShadow = (bsBuffShadow << 8) | thech;
Magic Number,Ionic.BZip2,BZip2InputStream,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\BZip2\BZip2InputStream.cs,GetBits,The following statement contains a magic number: bsLiveShadow += 8;
Magic Number,Ionic.BZip2,BZip2InputStream,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\BZip2\BZip2InputStream.cs,bsGetUByte,The following statement contains a magic number: return (char) GetBits(8);
Magic Number,Ionic.BZip2,BZip2InputStream,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\BZip2\BZip2InputStream.cs,bsGetInt,The following statement contains a magic number: return (uint)((((((GetBits(8) << 8) | GetBits(8)) << 8) | GetBits(8)) << 8) | GetBits(8));
Magic Number,Ionic.BZip2,BZip2InputStream,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\BZip2\BZip2InputStream.cs,bsGetInt,The following statement contains a magic number: return (uint)((((((GetBits(8) << 8) | GetBits(8)) << 8) | GetBits(8)) << 8) | GetBits(8));
Magic Number,Ionic.BZip2,BZip2InputStream,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\BZip2\BZip2InputStream.cs,bsGetInt,The following statement contains a magic number: return (uint)((((((GetBits(8) << 8) | GetBits(8)) << 8) | GetBits(8)) << 8) | GetBits(8));
Magic Number,Ionic.BZip2,BZip2InputStream,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\BZip2\BZip2InputStream.cs,bsGetInt,The following statement contains a magic number: return (uint)((((((GetBits(8) << 8) | GetBits(8)) << 8) | GetBits(8)) << 8) | GetBits(8));
Magic Number,Ionic.BZip2,BZip2InputStream,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\BZip2\BZip2InputStream.cs,bsGetInt,The following statement contains a magic number: return (uint)((((((GetBits(8) << 8) | GetBits(8)) << 8) | GetBits(8)) << 8) | GetBits(8));
Magic Number,Ionic.BZip2,BZip2InputStream,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\BZip2\BZip2InputStream.cs,bsGetInt,The following statement contains a magic number: return (uint)((((((GetBits(8) << 8) | GetBits(8)) << 8) | GetBits(8)) << 8) | GetBits(8));
Magic Number,Ionic.BZip2,BZip2InputStream,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\BZip2\BZip2InputStream.cs,bsGetInt,The following statement contains a magic number: return (uint)((((((GetBits(8) << 8) | GetBits(8)) << 8) | GetBits(8)) << 8) | GetBits(8));
Magic Number,Ionic.BZip2,BZip2InputStream,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\BZip2\BZip2InputStream.cs,recvDecodingTables,The following statement contains a magic number: i < 16
Magic Number,Ionic.BZip2,BZip2InputStream,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\BZip2\BZip2InputStream.cs,recvDecodingTables,The following statement contains a magic number: int i16 = i << 4;
Magic Number,Ionic.BZip2,BZip2InputStream,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\BZip2\BZip2InputStream.cs,recvDecodingTables,The following statement contains a magic number: j < 16
Magic Number,Ionic.BZip2,BZip2InputStream,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\BZip2\BZip2InputStream.cs,recvDecodingTables,The following statement contains a magic number: i < 16
Magic Number,Ionic.BZip2,BZip2InputStream,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\BZip2\BZip2InputStream.cs,recvDecodingTables,The following statement contains a magic number: int alphaSize = this.nInUse + 2;
Magic Number,Ionic.BZip2,BZip2InputStream,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\BZip2\BZip2InputStream.cs,recvDecodingTables,The following statement contains a magic number: int nGroups = GetBits(3);
Magic Number,Ionic.BZip2,BZip2InputStream,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\BZip2\BZip2InputStream.cs,recvDecodingTables,The following statement contains a magic number: int nSelectors = GetBits(15);
Magic Number,Ionic.BZip2,BZip2InputStream,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\BZip2\BZip2InputStream.cs,recvDecodingTables,The following statement contains a magic number: int curr = GetBits(5);
Magic Number,Ionic.BZip2,BZip2InputStream,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\BZip2\BZip2InputStream.cs,createHuffmanDecodingTables,The following statement contains a magic number: int minLen = 32;
Magic Number,Ionic.BZip2,BZip2InputStream,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\BZip2\BZip2InputStream.cs,getAndMoveToFrontDecode,The following statement contains a magic number: this.origPtr = GetBits(24);
Magic Number,Ionic.BZip2,BZip2InputStream,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\BZip2\BZip2InputStream.cs,getAndMoveToFrontDecode,The following statement contains a magic number: this.origPtr > 10 + BZip2.BlockSizeMultiple * this.blockSize100k
Magic Number,Ionic.BZip2,BZip2InputStream,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\BZip2\BZip2InputStream.cs,getAndMoveToFrontDecode,The following statement contains a magic number: bsBuffShadow = (bsBuffShadow << 8) | thech;
Magic Number,Ionic.BZip2,BZip2InputStream,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\BZip2\BZip2InputStream.cs,getAndMoveToFrontDecode,The following statement contains a magic number: bsLiveShadow += 8;
Magic Number,Ionic.BZip2,BZip2InputStream,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\BZip2\BZip2InputStream.cs,getAndMoveToFrontDecode,The following statement contains a magic number: bsBuffShadow = (bsBuffShadow << 8) | thech;
Magic Number,Ionic.BZip2,BZip2InputStream,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\BZip2\BZip2InputStream.cs,getAndMoveToFrontDecode,The following statement contains a magic number: bsLiveShadow += 8;
Magic Number,Ionic.BZip2,BZip2InputStream,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\BZip2\BZip2InputStream.cs,getAndMoveToFrontDecode0,The following statement contains a magic number: bsBuffShadow = (bsBuffShadow << 8) | thech;
Magic Number,Ionic.BZip2,BZip2InputStream,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\BZip2\BZip2InputStream.cs,getAndMoveToFrontDecode0,The following statement contains a magic number: bsLiveShadow += 8;
Magic Number,Ionic.BZip2,BZip2InputStream,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\BZip2\BZip2InputStream.cs,SetupBlock,The following statement contains a magic number: i <= 255
Magic Number,Ionic.BZip2,BZip2InputStream,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\BZip2\BZip2InputStream.cs,SetupBlock,The following statement contains a magic number: i <= 256
Magic Number,Ionic.BZip2,BZip2InputStream,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\BZip2\BZip2InputStream.cs,SetupBlock,The following statement contains a magic number: i <= 256
Magic Number,Ionic.BZip2,BZip2InputStream,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\BZip2\BZip2InputStream.cs,SetupBlock,The following statement contains a magic number: i <= 256
Magic Number,Ionic.BZip2,BZip2InputStream,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\BZip2\BZip2InputStream.cs,SetupBlock,The following statement contains a magic number: i <= 256
Magic Number,Ionic.BZip2,BZip2InputStream,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\BZip2\BZip2InputStream.cs,SetupBlock,The following statement contains a magic number: this.su_ch2 = 256;
Magic Number,Ionic.BZip2,BZip2InputStream,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\BZip2\BZip2InputStream.cs,SetupRandPartA,The following statement contains a magic number: ++this.su_rTPos == 512
Magic Number,Ionic.BZip2,DecompressionState,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\BZip2\BZip2InputStream.cs,DecompressionState,The following statement contains a magic number: this.unzftab = new int[256];
Magic Number,Ionic.BZip2,DecompressionState,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\BZip2\BZip2InputStream.cs,DecompressionState,The following statement contains a magic number: this.cftab = new int[257];
Magic Number,Ionic.BZip2,DecompressionState,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\BZip2\BZip2InputStream.cs,DecompressionState,The following statement contains a magic number: this.getAndMoveToFrontDecode_yy = new byte[256];
Magic Number,Ionic.BZip2,BZip2OutputStream,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\BZip2\BZip2OutputStream.cs,Finish,The following statement contains a magic number: this.combinedCRC = (this.combinedCRC << 1) | (this.combinedCRC >> 31);
Magic Number,Ionic.BZip2,BZip2OutputStream,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\BZip2\BZip2OutputStream.cs,Write,The following statement contains a magic number: this.combinedCRC = (this.combinedCRC << 1) | (this.combinedCRC >> 31);
Magic Number,Ionic.BZip2,BZip2OutputStream,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\BZip2\BZip2OutputStream.cs,TraceOutput,The following statement contains a magic number: Console.ForegroundColor = (ConsoleColor) (tid % 8 + 10);
Magic Number,Ionic.BZip2,BZip2OutputStream,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\BZip2\BZip2OutputStream.cs,TraceOutput,The following statement contains a magic number: Console.ForegroundColor = (ConsoleColor) (tid % 8 + 10);
Magic Number,Ionic.BZip2,ParallelBZip2OutputStream,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\BZip2\ParallelBZip2OutputStream.cs,ParallelBZip2OutputStream,The following statement contains a magic number: this.MaxWorkers = 16;
Magic Number,Ionic.BZip2,ParallelBZip2OutputStream,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\BZip2\ParallelBZip2OutputStream.cs,EmitPendingBuffers,The following statement contains a magic number: int millisecondsToWait = doAll ? 200 : (mustWait ? -1 : 0);
Magic Number,Ionic.BZip2,ParallelBZip2OutputStream,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\BZip2\ParallelBZip2OutputStream.cs,EmitPendingBuffers,The following statement contains a magic number: var buffer = new byte[1024];
Magic Number,Ionic.BZip2,ParallelBZip2OutputStream,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\BZip2\ParallelBZip2OutputStream.cs,EmitPendingBuffers,The following statement contains a magic number: this.combinedCRC = (this.combinedCRC << 1) | (this.combinedCRC >> 31);
Magic Number,Ionic.BZip2,ParallelBZip2OutputStream,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\BZip2\ParallelBZip2OutputStream.cs,TraceOutput,The following statement contains a magic number: Console.ForegroundColor = (ConsoleColor) (tid % 8 + 10);
Magic Number,Ionic.BZip2,ParallelBZip2OutputStream,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\BZip2\ParallelBZip2OutputStream.cs,TraceOutput,The following statement contains a magic number: Console.ForegroundColor = (ConsoleColor) (tid % 8 + 10);
Magic Number,Ionic.Crc,CRC32,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zlib.Shared\CRC32.cs,_InternalComputeCrc32,The following statement contains a magic number: return (Int32)(crc32Table[(W ^ B) & 0xFF] ^ (W >> 8));
Magic Number,Ionic.Crc,CRC32,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zlib.Shared\CRC32.cs,SlurpBlock,The following statement contains a magic number: UInt32 temp = (_register >> 24) ^ b;
Magic Number,Ionic.Crc,CRC32,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zlib.Shared\CRC32.cs,SlurpBlock,The following statement contains a magic number: _register = (_register << 8) ^ crc32Table[temp];
Magic Number,Ionic.Crc,CRC32,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zlib.Shared\CRC32.cs,UpdateCRC,The following statement contains a magic number: UInt32 temp = (_register >> 24) ^ b;
Magic Number,Ionic.Crc,CRC32,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zlib.Shared\CRC32.cs,UpdateCRC,The following statement contains a magic number: _register = (_register << 8) ^ crc32Table[temp];
Magic Number,Ionic.Crc,CRC32,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zlib.Shared\CRC32.cs,UpdateCRC,The following statement contains a magic number: uint temp = (_register >> 24) ^ b;
Magic Number,Ionic.Crc,CRC32,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zlib.Shared\CRC32.cs,UpdateCRC,The following statement contains a magic number: _register = (_register << 8) ^ crc32Table[(temp >= 0)                                                                ? temp                                                                : (temp + 256)];
Magic Number,Ionic.Crc,CRC32,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zlib.Shared\CRC32.cs,UpdateCRC,The following statement contains a magic number: _register = (_register << 8) ^ crc32Table[(temp >= 0)                                                                ? temp                                                                : (temp + 256)];
Magic Number,Ionic.Crc,CRC32,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zlib.Shared\CRC32.cs,ReverseBits,The following statement contains a magic number: ret = (ret & 0x33333333) << 2 | (ret >> 2) & 0x33333333;
Magic Number,Ionic.Crc,CRC32,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zlib.Shared\CRC32.cs,ReverseBits,The following statement contains a magic number: ret = (ret & 0x33333333) << 2 | (ret >> 2) & 0x33333333;
Magic Number,Ionic.Crc,CRC32,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zlib.Shared\CRC32.cs,ReverseBits,The following statement contains a magic number: ret = (ret & 0x0F0F0F0F) << 4 | (ret >> 4) & 0x0F0F0F0F;
Magic Number,Ionic.Crc,CRC32,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zlib.Shared\CRC32.cs,ReverseBits,The following statement contains a magic number: ret = (ret & 0x0F0F0F0F) << 4 | (ret >> 4) & 0x0F0F0F0F;
Magic Number,Ionic.Crc,CRC32,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zlib.Shared\CRC32.cs,ReverseBits,The following statement contains a magic number: ret = (ret << 24) | ((ret & 0xFF00) << 8) | ((ret >> 8) & 0xFF00) | (ret >> 24);
Magic Number,Ionic.Crc,CRC32,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zlib.Shared\CRC32.cs,ReverseBits,The following statement contains a magic number: ret = (ret << 24) | ((ret & 0xFF00) << 8) | ((ret >> 8) & 0xFF00) | (ret >> 24);
Magic Number,Ionic.Crc,CRC32,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zlib.Shared\CRC32.cs,ReverseBits,The following statement contains a magic number: ret = (ret << 24) | ((ret & 0xFF00) << 8) | ((ret >> 8) & 0xFF00) | (ret >> 24);
Magic Number,Ionic.Crc,CRC32,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zlib.Shared\CRC32.cs,ReverseBits,The following statement contains a magic number: ret = (ret << 24) | ((ret & 0xFF00) << 8) | ((ret >> 8) & 0xFF00) | (ret >> 24);
Magic Number,Ionic.Crc,CRC32,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zlib.Shared\CRC32.cs,ReverseBits,The following statement contains a magic number: uint t = (u << 2) & (m << 1);
Magic Number,Ionic.Crc,CRC32,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zlib.Shared\CRC32.cs,ReverseBits,The following statement contains a magic number: return (byte)((0x01001001 * (s + t)) >> 24);
Magic Number,Ionic.Crc,CRC32,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zlib.Shared\CRC32.cs,GenerateLookupTable,The following statement contains a magic number: crc32Table = new UInt32[256];
Magic Number,Ionic.Crc,CRC32,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zlib.Shared\CRC32.cs,gf2_matrix_square,The following statement contains a magic number: i < 32
Magic Number,Ionic.Crc,CRC32,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zlib.Shared\CRC32.cs,Combine,The following statement contains a magic number: uint[] even = new uint[32];
Magic Number,Ionic.Crc,CRC32,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zlib.Shared\CRC32.cs,Combine,The following statement contains a magic number: uint[] odd = new uint[32];
Magic Number,Ionic.Crc,CRC32,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zlib.Shared\CRC32.cs,Combine,The following statement contains a magic number: i < 32
Magic Number,Ionic.Zlib,DeflateManager,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zlib.Shared\Deflate.cs,DeflateManager,The following statement contains a magic number: dyn_ltree = new short[HEAP_SIZE * 2];
Magic Number,Ionic.Zlib,DeflateManager,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zlib.Shared\Deflate.cs,DeflateManager,The following statement contains a magic number: dyn_dtree = new short[(2 * InternalConstants.D_CODES + 1) * 2];
Magic Number,Ionic.Zlib,DeflateManager,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zlib.Shared\Deflate.cs,DeflateManager,The following statement contains a magic number: dyn_dtree = new short[(2 * InternalConstants.D_CODES + 1) * 2];
Magic Number,Ionic.Zlib,DeflateManager,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zlib.Shared\Deflate.cs,DeflateManager,The following statement contains a magic number: bl_tree = new short[(2 * InternalConstants.BL_CODES + 1) * 2];
Magic Number,Ionic.Zlib,DeflateManager,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zlib.Shared\Deflate.cs,DeflateManager,The following statement contains a magic number: bl_tree = new short[(2 * InternalConstants.BL_CODES + 1) * 2];
Magic Number,Ionic.Zlib,DeflateManager,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zlib.Shared\Deflate.cs,_InitializeLazyMatch,The following statement contains a magic number: window_size = 2 * w_size;
Magic Number,Ionic.Zlib,DeflateManager,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zlib.Shared\Deflate.cs,_InitializeTreeData,The following statement contains a magic number: last_eob_len = 8;
Magic Number,Ionic.Zlib,DeflateManager,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zlib.Shared\Deflate.cs,_InitializeBlocks,The following statement contains a magic number: dyn_ltree[i * 2] = 0;
Magic Number,Ionic.Zlib,DeflateManager,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zlib.Shared\Deflate.cs,_InitializeBlocks,The following statement contains a magic number: dyn_dtree[i * 2] = 0;
Magic Number,Ionic.Zlib,DeflateManager,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zlib.Shared\Deflate.cs,_InitializeBlocks,The following statement contains a magic number: bl_tree[i * 2] = 0;
Magic Number,Ionic.Zlib,DeflateManager,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zlib.Shared\Deflate.cs,_InitializeBlocks,The following statement contains a magic number: dyn_ltree[END_BLOCK * 2] = 1;
Magic Number,Ionic.Zlib,DeflateManager,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zlib.Shared\Deflate.cs,_IsSmaller,The following statement contains a magic number: short tn2 = tree[n * 2];
Magic Number,Ionic.Zlib,DeflateManager,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zlib.Shared\Deflate.cs,_IsSmaller,The following statement contains a magic number: short tm2 = tree[m * 2];
Magic Number,Ionic.Zlib,DeflateManager,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zlib.Shared\Deflate.cs,scan_tree,The following statement contains a magic number: int nextlen = (int)tree[0 * 2 + 1];
Magic Number,Ionic.Zlib,DeflateManager,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zlib.Shared\Deflate.cs,scan_tree,The following statement contains a magic number: int max_count = 7;
Magic Number,Ionic.Zlib,DeflateManager,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zlib.Shared\Deflate.cs,scan_tree,The following statement contains a magic number: int min_count = 4;
Magic Number,Ionic.Zlib,DeflateManager,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zlib.Shared\Deflate.cs,scan_tree,The following statement contains a magic number: max_count = 138;
Magic Number,Ionic.Zlib,DeflateManager,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zlib.Shared\Deflate.cs,scan_tree,The following statement contains a magic number: min_count = 3;
Magic Number,Ionic.Zlib,DeflateManager,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zlib.Shared\Deflate.cs,scan_tree,The following statement contains a magic number: tree[(max_code + 1) * 2 + 1] = (short)0x7fff;
Magic Number,Ionic.Zlib,DeflateManager,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zlib.Shared\Deflate.cs,scan_tree,The following statement contains a magic number: nextlen = (int)tree[(n + 1) * 2 + 1];
Magic Number,Ionic.Zlib,DeflateManager,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zlib.Shared\Deflate.cs,scan_tree,The following statement contains a magic number: max_count = 138;
Magic Number,Ionic.Zlib,DeflateManager,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zlib.Shared\Deflate.cs,scan_tree,The following statement contains a magic number: min_count = 3;
Magic Number,Ionic.Zlib,DeflateManager,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zlib.Shared\Deflate.cs,build_bl_tree,The following statement contains a magic number: bl_tree[Tree.bl_order[max_blindex] * 2 + 1] != 0
Magic Number,Ionic.Zlib,DeflateManager,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zlib.Shared\Deflate.cs,build_bl_tree,The following statement contains a magic number: max_blindex >= 3
Magic Number,Ionic.Zlib,DeflateManager,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zlib.Shared\Deflate.cs,build_bl_tree,The following statement contains a magic number: opt_len += 3 * (max_blindex + 1) + 5 + 5 + 4;
Magic Number,Ionic.Zlib,DeflateManager,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zlib.Shared\Deflate.cs,build_bl_tree,The following statement contains a magic number: opt_len += 3 * (max_blindex + 1) + 5 + 5 + 4;
Magic Number,Ionic.Zlib,DeflateManager,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zlib.Shared\Deflate.cs,build_bl_tree,The following statement contains a magic number: opt_len += 3 * (max_blindex + 1) + 5 + 5 + 4;
Magic Number,Ionic.Zlib,DeflateManager,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zlib.Shared\Deflate.cs,build_bl_tree,The following statement contains a magic number: opt_len += 3 * (max_blindex + 1) + 5 + 5 + 4;
Magic Number,Ionic.Zlib,DeflateManager,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zlib.Shared\Deflate.cs,send_all_trees,The following statement contains a magic number: send_bits(lcodes - 257' 5);
Magic Number,Ionic.Zlib,DeflateManager,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zlib.Shared\Deflate.cs,send_all_trees,The following statement contains a magic number: send_bits(lcodes - 257' 5);
Magic Number,Ionic.Zlib,DeflateManager,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zlib.Shared\Deflate.cs,send_all_trees,The following statement contains a magic number: send_bits(dcodes - 1' 5);
Magic Number,Ionic.Zlib,DeflateManager,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zlib.Shared\Deflate.cs,send_all_trees,The following statement contains a magic number: send_bits(blcodes - 4' 4);
Magic Number,Ionic.Zlib,DeflateManager,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zlib.Shared\Deflate.cs,send_all_trees,The following statement contains a magic number: send_bits(blcodes - 4' 4);
Magic Number,Ionic.Zlib,DeflateManager,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zlib.Shared\Deflate.cs,send_all_trees,The following statement contains a magic number: send_bits(bl_tree[Tree.bl_order[rank] * 2 + 1]' 3);
Magic Number,Ionic.Zlib,DeflateManager,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zlib.Shared\Deflate.cs,send_all_trees,The following statement contains a magic number: send_bits(bl_tree[Tree.bl_order[rank] * 2 + 1]' 3);
Magic Number,Ionic.Zlib,DeflateManager,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zlib.Shared\Deflate.cs,send_tree,The following statement contains a magic number: int nextlen   = tree[0 * 2 + 1];
Magic Number,Ionic.Zlib,DeflateManager,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zlib.Shared\Deflate.cs,send_tree,The following statement contains a magic number: int max_count = 7;
Magic Number,Ionic.Zlib,DeflateManager,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zlib.Shared\Deflate.cs,send_tree,The following statement contains a magic number: int min_count = 4;
Magic Number,Ionic.Zlib,DeflateManager,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zlib.Shared\Deflate.cs,send_tree,The following statement contains a magic number: max_count = 138;
Magic Number,Ionic.Zlib,DeflateManager,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zlib.Shared\Deflate.cs,send_tree,The following statement contains a magic number: min_count = 3;
Magic Number,Ionic.Zlib,DeflateManager,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zlib.Shared\Deflate.cs,send_tree,The following statement contains a magic number: nextlen = tree[(n + 1) * 2 + 1];
Magic Number,Ionic.Zlib,DeflateManager,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zlib.Shared\Deflate.cs,send_tree,The following statement contains a magic number: max_count = 138;
Magic Number,Ionic.Zlib,DeflateManager,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zlib.Shared\Deflate.cs,send_tree,The following statement contains a magic number: min_count = 3;
Magic Number,Ionic.Zlib,DeflateManager,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zlib.Shared\Deflate.cs,send_code,The following statement contains a magic number: int c2 = c * 2;
Magic Number,Ionic.Zlib,DeflateManager,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zlib.Shared\Deflate.cs,send_bits,The following statement contains a magic number: pending[pendingCount++] = (byte)(bi_buf >> 8);
Magic Number,Ionic.Zlib,DeflateManager,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zlib.Shared\Deflate.cs,_tr_align,The following statement contains a magic number: send_bits(STATIC_TREES << 1' 3);
Magic Number,Ionic.Zlib,DeflateManager,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zlib.Shared\Deflate.cs,_tr_align,The following statement contains a magic number: send_bits(STATIC_TREES << 1' 3);
Magic Number,Ionic.Zlib,DeflateManager,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zlib.Shared\Deflate.cs,_tr_align,The following statement contains a magic number: 1 + last_eob_len + 10 - bi_valid < 9
Magic Number,Ionic.Zlib,DeflateManager,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zlib.Shared\Deflate.cs,_tr_align,The following statement contains a magic number: 1 + last_eob_len + 10 - bi_valid < 9
Magic Number,Ionic.Zlib,DeflateManager,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zlib.Shared\Deflate.cs,_tr_align,The following statement contains a magic number: last_eob_len = 7;
Magic Number,Ionic.Zlib,DeflateManager,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zlib.Shared\Deflate.cs,_tr_tally,The following statement contains a magic number: pending[_distanceOffset + last_lit * 2] = unchecked((byte) ( (uint)dist >> 8 ) );
Magic Number,Ionic.Zlib,DeflateManager,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zlib.Shared\Deflate.cs,_tr_tally,The following statement contains a magic number: pending[_distanceOffset + last_lit * 2] = unchecked((byte) ( (uint)dist >> 8 ) );
Magic Number,Ionic.Zlib,DeflateManager,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zlib.Shared\Deflate.cs,_tr_tally,The following statement contains a magic number: pending[_distanceOffset + last_lit * 2 + 1] = unchecked((byte)dist);
Magic Number,Ionic.Zlib,DeflateManager,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zlib.Shared\Deflate.cs,_tr_tally,The following statement contains a magic number: dyn_ltree[lc * 2]++;
Magic Number,Ionic.Zlib,DeflateManager,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zlib.Shared\Deflate.cs,_tr_tally,The following statement contains a magic number: int out_length = last_lit << 3;
Magic Number,Ionic.Zlib,DeflateManager,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zlib.Shared\Deflate.cs,_tr_tally,The following statement contains a magic number: out_length = (int)(out_length + (int)dyn_dtree[dcode * 2] * (5L + Tree.ExtraDistanceBits[dcode]));
Magic Number,Ionic.Zlib,DeflateManager,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zlib.Shared\Deflate.cs,_tr_tally,The following statement contains a magic number: out_length = (int)(out_length + (int)dyn_dtree[dcode * 2] * (5L + Tree.ExtraDistanceBits[dcode]));
Magic Number,Ionic.Zlib,DeflateManager,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zlib.Shared\Deflate.cs,_tr_tally,The following statement contains a magic number: out_length >>= 3;
Magic Number,Ionic.Zlib,DeflateManager,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zlib.Shared\Deflate.cs,_tr_tally,The following statement contains a magic number: (matches < (last_lit / 2)) && out_length < in_length / 2
Magic Number,Ionic.Zlib,DeflateManager,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zlib.Shared\Deflate.cs,_tr_tally,The following statement contains a magic number: (matches < (last_lit / 2)) && out_length < in_length / 2
Magic Number,Ionic.Zlib,DeflateManager,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zlib.Shared\Deflate.cs,_tr_tally,The following statement contains a magic number: (last_lit & 0x1fff) == 0 && (int)compressionLevel > 2
Magic Number,Ionic.Zlib,DeflateManager,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zlib.Shared\Deflate.cs,send_compressed_block,The following statement contains a magic number: int ix = _distanceOffset + lx * 2;
Magic Number,Ionic.Zlib,DeflateManager,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zlib.Shared\Deflate.cs,send_compressed_block,The following statement contains a magic number: distance = ((pending[ix] << 8) & 0xff00) |                          (pending[ix + 1] & 0xff);
Magic Number,Ionic.Zlib,DeflateManager,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zlib.Shared\Deflate.cs,send_compressed_block,The following statement contains a magic number: last_eob_len = ltree[END_BLOCK * 2 + 1];
Magic Number,Ionic.Zlib,DeflateManager,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zlib.Shared\Deflate.cs,set_data_type,The following statement contains a magic number: bin_freq += dyn_ltree[n * 2];
Magic Number,Ionic.Zlib,DeflateManager,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zlib.Shared\Deflate.cs,set_data_type,The following statement contains a magic number: n < 7
Magic Number,Ionic.Zlib,DeflateManager,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zlib.Shared\Deflate.cs,set_data_type,The following statement contains a magic number: ascii_freq += dyn_ltree[n * 2];
Magic Number,Ionic.Zlib,DeflateManager,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zlib.Shared\Deflate.cs,set_data_type,The following statement contains a magic number: n < 128
Magic Number,Ionic.Zlib,DeflateManager,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zlib.Shared\Deflate.cs,set_data_type,The following statement contains a magic number: bin_freq += dyn_ltree[n * 2];
Magic Number,Ionic.Zlib,DeflateManager,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zlib.Shared\Deflate.cs,set_data_type,The following statement contains a magic number: data_type = (sbyte)(bin_freq > (ascii_freq >> 2) ? Z_BINARY : Z_ASCII);
Magic Number,Ionic.Zlib,DeflateManager,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zlib.Shared\Deflate.cs,bi_flush,The following statement contains a magic number: pending[pendingCount++] = (byte)(bi_buf >> 8);
Magic Number,Ionic.Zlib,DeflateManager,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zlib.Shared\Deflate.cs,bi_flush,The following statement contains a magic number: bi_valid == 16
Magic Number,Ionic.Zlib,DeflateManager,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zlib.Shared\Deflate.cs,bi_windup,The following statement contains a magic number: pending[pendingCount++] = (byte)(bi_buf >> 8);
Magic Number,Ionic.Zlib,DeflateManager,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zlib.Shared\Deflate.cs,bi_windup,The following statement contains a magic number: bi_valid > 8
Magic Number,Ionic.Zlib,DeflateManager,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zlib.Shared\Deflate.cs,copy_block,The following statement contains a magic number: last_eob_len = 8;
Magic Number,Ionic.Zlib,DeflateManager,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zlib.Shared\Deflate.cs,copy_block,The following statement contains a magic number: unchecked                  {                      //put_short((short)len);                      pending[pendingCount++] = (byte)len;                      pending[pendingCount++] = (byte)(len >> 8);                      //put_short((short)~len);                      pending[pendingCount++] = (byte)~len;                      pending[pendingCount++] = (byte)(~len >> 8);                  }
Magic Number,Ionic.Zlib,DeflateManager,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zlib.Shared\Deflate.cs,copy_block,The following statement contains a magic number: unchecked                  {                      //put_short((short)len);                      pending[pendingCount++] = (byte)len;                      pending[pendingCount++] = (byte)(len >> 8);                      //put_short((short)~len);                      pending[pendingCount++] = (byte)~len;                      pending[pendingCount++] = (byte)(~len >> 8);                  }
Magic Number,Ionic.Zlib,DeflateManager,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zlib.Shared\Deflate.cs,DeflateNone,The following statement contains a magic number: max_block_size = pending.Length - 5;
Magic Number,Ionic.Zlib,DeflateManager,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zlib.Shared\Deflate.cs,DeflateNone,The following statement contains a magic number: max_block_size > pending.Length - 5
Magic Number,Ionic.Zlib,DeflateManager,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zlib.Shared\Deflate.cs,_tr_stored_block,The following statement contains a magic number: send_bits((STORED_BLOCK << 1) + (eof ? 1 : 0)' 3);
Magic Number,Ionic.Zlib,DeflateManager,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zlib.Shared\Deflate.cs,_tr_flush_block,The following statement contains a magic number: opt_lenb = (opt_len + 3 + 7) >> 3;
Magic Number,Ionic.Zlib,DeflateManager,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zlib.Shared\Deflate.cs,_tr_flush_block,The following statement contains a magic number: opt_lenb = (opt_len + 3 + 7) >> 3;
Magic Number,Ionic.Zlib,DeflateManager,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zlib.Shared\Deflate.cs,_tr_flush_block,The following statement contains a magic number: opt_lenb = (opt_len + 3 + 7) >> 3;
Magic Number,Ionic.Zlib,DeflateManager,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zlib.Shared\Deflate.cs,_tr_flush_block,The following statement contains a magic number: static_lenb = (static_len + 3 + 7) >> 3;
Magic Number,Ionic.Zlib,DeflateManager,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zlib.Shared\Deflate.cs,_tr_flush_block,The following statement contains a magic number: static_lenb = (static_len + 3 + 7) >> 3;
Magic Number,Ionic.Zlib,DeflateManager,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zlib.Shared\Deflate.cs,_tr_flush_block,The following statement contains a magic number: static_lenb = (static_len + 3 + 7) >> 3;
Magic Number,Ionic.Zlib,DeflateManager,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zlib.Shared\Deflate.cs,_tr_flush_block,The following statement contains a magic number: stored_len + 4 <= opt_lenb && buf != -1
Magic Number,Ionic.Zlib,DeflateManager,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zlib.Shared\Deflate.cs,DeflateSlow,The following statement contains a magic number: match_length <= 5 && (compressionStrategy == CompressionStrategy.Filtered ||                                                (match_length == MIN_MATCH && strstart - match_start > 4096))
Magic Number,Ionic.Zlib,DeflateManager,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zlib.Shared\Deflate.cs,DeflateSlow,The following statement contains a magic number: match_length <= 5 && (compressionStrategy == CompressionStrategy.Filtered ||                                                (match_length == MIN_MATCH && strstart - match_start > 4096))
Magic Number,Ionic.Zlib,DeflateManager,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zlib.Shared\Deflate.cs,DeflateSlow,The following statement contains a magic number: prev_length -= 2;
Magic Number,Ionic.Zlib,DeflateManager,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zlib.Shared\Deflate.cs,longest_match,The following statement contains a magic number: chain_length >>= 2;
Magic Number,Ionic.Zlib,DeflateManager,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zlib.Shared\Deflate.cs,longest_match,The following statement contains a magic number: scan += 2;
Magic Number,Ionic.Zlib,DeflateManager,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zlib.Shared\Deflate.cs,Initialize,The following statement contains a magic number: windowBits < 9 || windowBits > 15
Magic Number,Ionic.Zlib,DeflateManager,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zlib.Shared\Deflate.cs,Initialize,The following statement contains a magic number: windowBits < 9 || windowBits > 15
Magic Number,Ionic.Zlib,DeflateManager,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zlib.Shared\Deflate.cs,Initialize,The following statement contains a magic number: hash_bits = memLevel + 7;
Magic Number,Ionic.Zlib,DeflateManager,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zlib.Shared\Deflate.cs,Initialize,The following statement contains a magic number: window = new byte[w_size * 2];
Magic Number,Ionic.Zlib,DeflateManager,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zlib.Shared\Deflate.cs,Initialize,The following statement contains a magic number: lit_bufsize = 1 << (memLevel + 6);
Magic Number,Ionic.Zlib,DeflateManager,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zlib.Shared\Deflate.cs,Initialize,The following statement contains a magic number: pending = new byte[lit_bufsize * 4];
Magic Number,Ionic.Zlib,DeflateManager,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zlib.Shared\Deflate.cs,Initialize,The following statement contains a magic number: _lengthOffset = (1 + 2) * lit_bufsize;
Magic Number,Ionic.Zlib,DeflateManager,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zlib.Shared\Deflate.cs,Deflate,The following statement contains a magic number: int header = (Z_DEFLATED + ((w_bits - 8) << 4)) << 8;
Magic Number,Ionic.Zlib,DeflateManager,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zlib.Shared\Deflate.cs,Deflate,The following statement contains a magic number: int header = (Z_DEFLATED + ((w_bits - 8) << 4)) << 8;
Magic Number,Ionic.Zlib,DeflateManager,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zlib.Shared\Deflate.cs,Deflate,The following statement contains a magic number: int header = (Z_DEFLATED + ((w_bits - 8) << 4)) << 8;
Magic Number,Ionic.Zlib,DeflateManager,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zlib.Shared\Deflate.cs,Deflate,The following statement contains a magic number: level_flags = 3;
Magic Number,Ionic.Zlib,DeflateManager,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zlib.Shared\Deflate.cs,Deflate,The following statement contains a magic number: level_flags > 3
Magic Number,Ionic.Zlib,DeflateManager,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zlib.Shared\Deflate.cs,Deflate,The following statement contains a magic number: header |= (level_flags << 6);
Magic Number,Ionic.Zlib,DeflateManager,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zlib.Shared\Deflate.cs,Deflate,The following statement contains a magic number: header += 31 - (header % 31);
Magic Number,Ionic.Zlib,DeflateManager,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zlib.Shared\Deflate.cs,Deflate,The following statement contains a magic number: header += 31 - (header % 31);
Magic Number,Ionic.Zlib,DeflateManager,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zlib.Shared\Deflate.cs,Deflate,The following statement contains a magic number: pending[pendingCount++] = (byte)(header >> 8);
Magic Number,Ionic.Zlib,DeflateManager,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zlib.Shared\Deflate.cs,Deflate,The following statement contains a magic number: pending[pendingCount++] = (byte)((_codec._Adler32 & 0xFF000000) >> 24);
Magic Number,Ionic.Zlib,DeflateManager,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zlib.Shared\Deflate.cs,Deflate,The following statement contains a magic number: pending[pendingCount++] = (byte)((_codec._Adler32 & 0x00FF0000) >> 16);
Magic Number,Ionic.Zlib,DeflateManager,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zlib.Shared\Deflate.cs,Deflate,The following statement contains a magic number: pending[pendingCount++] = (byte)((_codec._Adler32 & 0x0000FF00) >> 8);
Magic Number,Ionic.Zlib,DeflateManager,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zlib.Shared\Deflate.cs,Deflate,The following statement contains a magic number: pending[pendingCount++] = (byte)((_codec._Adler32 & 0xFF000000) >> 24);
Magic Number,Ionic.Zlib,DeflateManager,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zlib.Shared\Deflate.cs,Deflate,The following statement contains a magic number: pending[pendingCount++] = (byte)((_codec._Adler32 & 0x00FF0000) >> 16);
Magic Number,Ionic.Zlib,DeflateManager,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zlib.Shared\Deflate.cs,Deflate,The following statement contains a magic number: pending[pendingCount++] = (byte)((_codec._Adler32 & 0x0000FF00) >> 8);
Magic Number,Ionic.Zlib,Config,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zlib.Shared\Deflate.cs,Config,The following statement contains a magic number: Table = new Config[] {                      new Config(0' 0' 0' 0' DeflateFlavor.Store)'                      new Config(4' 4' 8' 4' DeflateFlavor.Fast)'                      new Config(4' 5' 16' 8' DeflateFlavor.Fast)'                      new Config(4' 6' 32' 32' DeflateFlavor.Fast)'                        new Config(4' 4' 16' 16' DeflateFlavor.Slow)'                      new Config(8' 16' 32' 32' DeflateFlavor.Slow)'                      new Config(8' 16' 128' 128' DeflateFlavor.Slow)'                      new Config(8' 32' 128' 256' DeflateFlavor.Slow)'                      new Config(32' 128' 258' 1024' DeflateFlavor.Slow)'                      new Config(32' 258' 258' 4096' DeflateFlavor.Slow)'                  };
Magic Number,Ionic.Zlib,Config,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zlib.Shared\Deflate.cs,Config,The following statement contains a magic number: Table = new Config[] {                      new Config(0' 0' 0' 0' DeflateFlavor.Store)'                      new Config(4' 4' 8' 4' DeflateFlavor.Fast)'                      new Config(4' 5' 16' 8' DeflateFlavor.Fast)'                      new Config(4' 6' 32' 32' DeflateFlavor.Fast)'                        new Config(4' 4' 16' 16' DeflateFlavor.Slow)'                      new Config(8' 16' 32' 32' DeflateFlavor.Slow)'                      new Config(8' 16' 128' 128' DeflateFlavor.Slow)'                      new Config(8' 32' 128' 256' DeflateFlavor.Slow)'                      new Config(32' 128' 258' 1024' DeflateFlavor.Slow)'                      new Config(32' 258' 258' 4096' DeflateFlavor.Slow)'                  };
Magic Number,Ionic.Zlib,Config,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zlib.Shared\Deflate.cs,Config,The following statement contains a magic number: Table = new Config[] {                      new Config(0' 0' 0' 0' DeflateFlavor.Store)'                      new Config(4' 4' 8' 4' DeflateFlavor.Fast)'                      new Config(4' 5' 16' 8' DeflateFlavor.Fast)'                      new Config(4' 6' 32' 32' DeflateFlavor.Fast)'                        new Config(4' 4' 16' 16' DeflateFlavor.Slow)'                      new Config(8' 16' 32' 32' DeflateFlavor.Slow)'                      new Config(8' 16' 128' 128' DeflateFlavor.Slow)'                      new Config(8' 32' 128' 256' DeflateFlavor.Slow)'                      new Config(32' 128' 258' 1024' DeflateFlavor.Slow)'                      new Config(32' 258' 258' 4096' DeflateFlavor.Slow)'                  };
Magic Number,Ionic.Zlib,Config,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zlib.Shared\Deflate.cs,Config,The following statement contains a magic number: Table = new Config[] {                      new Config(0' 0' 0' 0' DeflateFlavor.Store)'                      new Config(4' 4' 8' 4' DeflateFlavor.Fast)'                      new Config(4' 5' 16' 8' DeflateFlavor.Fast)'                      new Config(4' 6' 32' 32' DeflateFlavor.Fast)'                        new Config(4' 4' 16' 16' DeflateFlavor.Slow)'                      new Config(8' 16' 32' 32' DeflateFlavor.Slow)'                      new Config(8' 16' 128' 128' DeflateFlavor.Slow)'                      new Config(8' 32' 128' 256' DeflateFlavor.Slow)'                      new Config(32' 128' 258' 1024' DeflateFlavor.Slow)'                      new Config(32' 258' 258' 4096' DeflateFlavor.Slow)'                  };
Magic Number,Ionic.Zlib,Config,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zlib.Shared\Deflate.cs,Config,The following statement contains a magic number: Table = new Config[] {                      new Config(0' 0' 0' 0' DeflateFlavor.Store)'                      new Config(4' 4' 8' 4' DeflateFlavor.Fast)'                      new Config(4' 5' 16' 8' DeflateFlavor.Fast)'                      new Config(4' 6' 32' 32' DeflateFlavor.Fast)'                        new Config(4' 4' 16' 16' DeflateFlavor.Slow)'                      new Config(8' 16' 32' 32' DeflateFlavor.Slow)'                      new Config(8' 16' 128' 128' DeflateFlavor.Slow)'                      new Config(8' 32' 128' 256' DeflateFlavor.Slow)'                      new Config(32' 128' 258' 1024' DeflateFlavor.Slow)'                      new Config(32' 258' 258' 4096' DeflateFlavor.Slow)'                  };
Magic Number,Ionic.Zlib,Config,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zlib.Shared\Deflate.cs,Config,The following statement contains a magic number: Table = new Config[] {                      new Config(0' 0' 0' 0' DeflateFlavor.Store)'                      new Config(4' 4' 8' 4' DeflateFlavor.Fast)'                      new Config(4' 5' 16' 8' DeflateFlavor.Fast)'                      new Config(4' 6' 32' 32' DeflateFlavor.Fast)'                        new Config(4' 4' 16' 16' DeflateFlavor.Slow)'                      new Config(8' 16' 32' 32' DeflateFlavor.Slow)'                      new Config(8' 16' 128' 128' DeflateFlavor.Slow)'                      new Config(8' 32' 128' 256' DeflateFlavor.Slow)'                      new Config(32' 128' 258' 1024' DeflateFlavor.Slow)'                      new Config(32' 258' 258' 4096' DeflateFlavor.Slow)'                  };
Magic Number,Ionic.Zlib,Config,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zlib.Shared\Deflate.cs,Config,The following statement contains a magic number: Table = new Config[] {                      new Config(0' 0' 0' 0' DeflateFlavor.Store)'                      new Config(4' 4' 8' 4' DeflateFlavor.Fast)'                      new Config(4' 5' 16' 8' DeflateFlavor.Fast)'                      new Config(4' 6' 32' 32' DeflateFlavor.Fast)'                        new Config(4' 4' 16' 16' DeflateFlavor.Slow)'                      new Config(8' 16' 32' 32' DeflateFlavor.Slow)'                      new Config(8' 16' 128' 128' DeflateFlavor.Slow)'                      new Config(8' 32' 128' 256' DeflateFlavor.Slow)'                      new Config(32' 128' 258' 1024' DeflateFlavor.Slow)'                      new Config(32' 258' 258' 4096' DeflateFlavor.Slow)'                  };
Magic Number,Ionic.Zlib,Config,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zlib.Shared\Deflate.cs,Config,The following statement contains a magic number: Table = new Config[] {                      new Config(0' 0' 0' 0' DeflateFlavor.Store)'                      new Config(4' 4' 8' 4' DeflateFlavor.Fast)'                      new Config(4' 5' 16' 8' DeflateFlavor.Fast)'                      new Config(4' 6' 32' 32' DeflateFlavor.Fast)'                        new Config(4' 4' 16' 16' DeflateFlavor.Slow)'                      new Config(8' 16' 32' 32' DeflateFlavor.Slow)'                      new Config(8' 16' 128' 128' DeflateFlavor.Slow)'                      new Config(8' 32' 128' 256' DeflateFlavor.Slow)'                      new Config(32' 128' 258' 1024' DeflateFlavor.Slow)'                      new Config(32' 258' 258' 4096' DeflateFlavor.Slow)'                  };
Magic Number,Ionic.Zlib,Config,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zlib.Shared\Deflate.cs,Config,The following statement contains a magic number: Table = new Config[] {                      new Config(0' 0' 0' 0' DeflateFlavor.Store)'                      new Config(4' 4' 8' 4' DeflateFlavor.Fast)'                      new Config(4' 5' 16' 8' DeflateFlavor.Fast)'                      new Config(4' 6' 32' 32' DeflateFlavor.Fast)'                        new Config(4' 4' 16' 16' DeflateFlavor.Slow)'                      new Config(8' 16' 32' 32' DeflateFlavor.Slow)'                      new Config(8' 16' 128' 128' DeflateFlavor.Slow)'                      new Config(8' 32' 128' 256' DeflateFlavor.Slow)'                      new Config(32' 128' 258' 1024' DeflateFlavor.Slow)'                      new Config(32' 258' 258' 4096' DeflateFlavor.Slow)'                  };
Magic Number,Ionic.Zlib,Config,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zlib.Shared\Deflate.cs,Config,The following statement contains a magic number: Table = new Config[] {                      new Config(0' 0' 0' 0' DeflateFlavor.Store)'                      new Config(4' 4' 8' 4' DeflateFlavor.Fast)'                      new Config(4' 5' 16' 8' DeflateFlavor.Fast)'                      new Config(4' 6' 32' 32' DeflateFlavor.Fast)'                        new Config(4' 4' 16' 16' DeflateFlavor.Slow)'                      new Config(8' 16' 32' 32' DeflateFlavor.Slow)'                      new Config(8' 16' 128' 128' DeflateFlavor.Slow)'                      new Config(8' 32' 128' 256' DeflateFlavor.Slow)'                      new Config(32' 128' 258' 1024' DeflateFlavor.Slow)'                      new Config(32' 258' 258' 4096' DeflateFlavor.Slow)'                  };
Magic Number,Ionic.Zlib,Config,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zlib.Shared\Deflate.cs,Config,The following statement contains a magic number: Table = new Config[] {                      new Config(0' 0' 0' 0' DeflateFlavor.Store)'                      new Config(4' 4' 8' 4' DeflateFlavor.Fast)'                      new Config(4' 5' 16' 8' DeflateFlavor.Fast)'                      new Config(4' 6' 32' 32' DeflateFlavor.Fast)'                        new Config(4' 4' 16' 16' DeflateFlavor.Slow)'                      new Config(8' 16' 32' 32' DeflateFlavor.Slow)'                      new Config(8' 16' 128' 128' DeflateFlavor.Slow)'                      new Config(8' 32' 128' 256' DeflateFlavor.Slow)'                      new Config(32' 128' 258' 1024' DeflateFlavor.Slow)'                      new Config(32' 258' 258' 4096' DeflateFlavor.Slow)'                  };
Magic Number,Ionic.Zlib,Config,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zlib.Shared\Deflate.cs,Config,The following statement contains a magic number: Table = new Config[] {                      new Config(0' 0' 0' 0' DeflateFlavor.Store)'                      new Config(4' 4' 8' 4' DeflateFlavor.Fast)'                      new Config(4' 5' 16' 8' DeflateFlavor.Fast)'                      new Config(4' 6' 32' 32' DeflateFlavor.Fast)'                        new Config(4' 4' 16' 16' DeflateFlavor.Slow)'                      new Config(8' 16' 32' 32' DeflateFlavor.Slow)'                      new Config(8' 16' 128' 128' DeflateFlavor.Slow)'                      new Config(8' 32' 128' 256' DeflateFlavor.Slow)'                      new Config(32' 128' 258' 1024' DeflateFlavor.Slow)'                      new Config(32' 258' 258' 4096' DeflateFlavor.Slow)'                  };
Magic Number,Ionic.Zlib,Config,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zlib.Shared\Deflate.cs,Config,The following statement contains a magic number: Table = new Config[] {                      new Config(0' 0' 0' 0' DeflateFlavor.Store)'                      new Config(4' 4' 8' 4' DeflateFlavor.Fast)'                      new Config(4' 5' 16' 8' DeflateFlavor.Fast)'                      new Config(4' 6' 32' 32' DeflateFlavor.Fast)'                        new Config(4' 4' 16' 16' DeflateFlavor.Slow)'                      new Config(8' 16' 32' 32' DeflateFlavor.Slow)'                      new Config(8' 16' 128' 128' DeflateFlavor.Slow)'                      new Config(8' 32' 128' 256' DeflateFlavor.Slow)'                      new Config(32' 128' 258' 1024' DeflateFlavor.Slow)'                      new Config(32' 258' 258' 4096' DeflateFlavor.Slow)'                  };
Magic Number,Ionic.Zlib,Config,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zlib.Shared\Deflate.cs,Config,The following statement contains a magic number: Table = new Config[] {                      new Config(0' 0' 0' 0' DeflateFlavor.Store)'                      new Config(4' 4' 8' 4' DeflateFlavor.Fast)'                      new Config(4' 5' 16' 8' DeflateFlavor.Fast)'                      new Config(4' 6' 32' 32' DeflateFlavor.Fast)'                        new Config(4' 4' 16' 16' DeflateFlavor.Slow)'                      new Config(8' 16' 32' 32' DeflateFlavor.Slow)'                      new Config(8' 16' 128' 128' DeflateFlavor.Slow)'                      new Config(8' 32' 128' 256' DeflateFlavor.Slow)'                      new Config(32' 128' 258' 1024' DeflateFlavor.Slow)'                      new Config(32' 258' 258' 4096' DeflateFlavor.Slow)'                  };
Magic Number,Ionic.Zlib,Config,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zlib.Shared\Deflate.cs,Config,The following statement contains a magic number: Table = new Config[] {                      new Config(0' 0' 0' 0' DeflateFlavor.Store)'                      new Config(4' 4' 8' 4' DeflateFlavor.Fast)'                      new Config(4' 5' 16' 8' DeflateFlavor.Fast)'                      new Config(4' 6' 32' 32' DeflateFlavor.Fast)'                        new Config(4' 4' 16' 16' DeflateFlavor.Slow)'                      new Config(8' 16' 32' 32' DeflateFlavor.Slow)'                      new Config(8' 16' 128' 128' DeflateFlavor.Slow)'                      new Config(8' 32' 128' 256' DeflateFlavor.Slow)'                      new Config(32' 128' 258' 1024' DeflateFlavor.Slow)'                      new Config(32' 258' 258' 4096' DeflateFlavor.Slow)'                  };
Magic Number,Ionic.Zlib,Config,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zlib.Shared\Deflate.cs,Config,The following statement contains a magic number: Table = new Config[] {                      new Config(0' 0' 0' 0' DeflateFlavor.Store)'                      new Config(4' 4' 8' 4' DeflateFlavor.Fast)'                      new Config(4' 5' 16' 8' DeflateFlavor.Fast)'                      new Config(4' 6' 32' 32' DeflateFlavor.Fast)'                        new Config(4' 4' 16' 16' DeflateFlavor.Slow)'                      new Config(8' 16' 32' 32' DeflateFlavor.Slow)'                      new Config(8' 16' 128' 128' DeflateFlavor.Slow)'                      new Config(8' 32' 128' 256' DeflateFlavor.Slow)'                      new Config(32' 128' 258' 1024' DeflateFlavor.Slow)'                      new Config(32' 258' 258' 4096' DeflateFlavor.Slow)'                  };
Magic Number,Ionic.Zlib,Config,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zlib.Shared\Deflate.cs,Config,The following statement contains a magic number: Table = new Config[] {                      new Config(0' 0' 0' 0' DeflateFlavor.Store)'                      new Config(4' 4' 8' 4' DeflateFlavor.Fast)'                      new Config(4' 5' 16' 8' DeflateFlavor.Fast)'                      new Config(4' 6' 32' 32' DeflateFlavor.Fast)'                        new Config(4' 4' 16' 16' DeflateFlavor.Slow)'                      new Config(8' 16' 32' 32' DeflateFlavor.Slow)'                      new Config(8' 16' 128' 128' DeflateFlavor.Slow)'                      new Config(8' 32' 128' 256' DeflateFlavor.Slow)'                      new Config(32' 128' 258' 1024' DeflateFlavor.Slow)'                      new Config(32' 258' 258' 4096' DeflateFlavor.Slow)'                  };
Magic Number,Ionic.Zlib,Config,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zlib.Shared\Deflate.cs,Config,The following statement contains a magic number: Table = new Config[] {                      new Config(0' 0' 0' 0' DeflateFlavor.Store)'                      new Config(4' 4' 8' 4' DeflateFlavor.Fast)'                      new Config(4' 5' 16' 8' DeflateFlavor.Fast)'                      new Config(4' 6' 32' 32' DeflateFlavor.Fast)'                        new Config(4' 4' 16' 16' DeflateFlavor.Slow)'                      new Config(8' 16' 32' 32' DeflateFlavor.Slow)'                      new Config(8' 16' 128' 128' DeflateFlavor.Slow)'                      new Config(8' 32' 128' 256' DeflateFlavor.Slow)'                      new Config(32' 128' 258' 1024' DeflateFlavor.Slow)'                      new Config(32' 258' 258' 4096' DeflateFlavor.Slow)'                  };
Magic Number,Ionic.Zlib,Config,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zlib.Shared\Deflate.cs,Config,The following statement contains a magic number: Table = new Config[] {                      new Config(0' 0' 0' 0' DeflateFlavor.Store)'                      new Config(4' 4' 8' 4' DeflateFlavor.Fast)'                      new Config(4' 5' 16' 8' DeflateFlavor.Fast)'                      new Config(4' 6' 32' 32' DeflateFlavor.Fast)'                        new Config(4' 4' 16' 16' DeflateFlavor.Slow)'                      new Config(8' 16' 32' 32' DeflateFlavor.Slow)'                      new Config(8' 16' 128' 128' DeflateFlavor.Slow)'                      new Config(8' 32' 128' 256' DeflateFlavor.Slow)'                      new Config(32' 128' 258' 1024' DeflateFlavor.Slow)'                      new Config(32' 258' 258' 4096' DeflateFlavor.Slow)'                  };
Magic Number,Ionic.Zlib,Config,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zlib.Shared\Deflate.cs,Config,The following statement contains a magic number: Table = new Config[] {                      new Config(0' 0' 0' 0' DeflateFlavor.Store)'                      new Config(4' 4' 8' 4' DeflateFlavor.Fast)'                      new Config(4' 5' 16' 8' DeflateFlavor.Fast)'                      new Config(4' 6' 32' 32' DeflateFlavor.Fast)'                        new Config(4' 4' 16' 16' DeflateFlavor.Slow)'                      new Config(8' 16' 32' 32' DeflateFlavor.Slow)'                      new Config(8' 16' 128' 128' DeflateFlavor.Slow)'                      new Config(8' 32' 128' 256' DeflateFlavor.Slow)'                      new Config(32' 128' 258' 1024' DeflateFlavor.Slow)'                      new Config(32' 258' 258' 4096' DeflateFlavor.Slow)'                  };
Magic Number,Ionic.Zlib,Config,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zlib.Shared\Deflate.cs,Config,The following statement contains a magic number: Table = new Config[] {                      new Config(0' 0' 0' 0' DeflateFlavor.Store)'                      new Config(4' 4' 8' 4' DeflateFlavor.Fast)'                      new Config(4' 5' 16' 8' DeflateFlavor.Fast)'                      new Config(4' 6' 32' 32' DeflateFlavor.Fast)'                        new Config(4' 4' 16' 16' DeflateFlavor.Slow)'                      new Config(8' 16' 32' 32' DeflateFlavor.Slow)'                      new Config(8' 16' 128' 128' DeflateFlavor.Slow)'                      new Config(8' 32' 128' 256' DeflateFlavor.Slow)'                      new Config(32' 128' 258' 1024' DeflateFlavor.Slow)'                      new Config(32' 258' 258' 4096' DeflateFlavor.Slow)'                  };
Magic Number,Ionic.Zlib,Config,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zlib.Shared\Deflate.cs,Config,The following statement contains a magic number: Table = new Config[] {                      new Config(0' 0' 0' 0' DeflateFlavor.Store)'                      new Config(4' 4' 8' 4' DeflateFlavor.Fast)'                      new Config(4' 5' 16' 8' DeflateFlavor.Fast)'                      new Config(4' 6' 32' 32' DeflateFlavor.Fast)'                        new Config(4' 4' 16' 16' DeflateFlavor.Slow)'                      new Config(8' 16' 32' 32' DeflateFlavor.Slow)'                      new Config(8' 16' 128' 128' DeflateFlavor.Slow)'                      new Config(8' 32' 128' 256' DeflateFlavor.Slow)'                      new Config(32' 128' 258' 1024' DeflateFlavor.Slow)'                      new Config(32' 258' 258' 4096' DeflateFlavor.Slow)'                  };
Magic Number,Ionic.Zlib,Config,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zlib.Shared\Deflate.cs,Config,The following statement contains a magic number: Table = new Config[] {                      new Config(0' 0' 0' 0' DeflateFlavor.Store)'                      new Config(4' 4' 8' 4' DeflateFlavor.Fast)'                      new Config(4' 5' 16' 8' DeflateFlavor.Fast)'                      new Config(4' 6' 32' 32' DeflateFlavor.Fast)'                        new Config(4' 4' 16' 16' DeflateFlavor.Slow)'                      new Config(8' 16' 32' 32' DeflateFlavor.Slow)'                      new Config(8' 16' 128' 128' DeflateFlavor.Slow)'                      new Config(8' 32' 128' 256' DeflateFlavor.Slow)'                      new Config(32' 128' 258' 1024' DeflateFlavor.Slow)'                      new Config(32' 258' 258' 4096' DeflateFlavor.Slow)'                  };
Magic Number,Ionic.Zlib,Config,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zlib.Shared\Deflate.cs,Config,The following statement contains a magic number: Table = new Config[] {                      new Config(0' 0' 0' 0' DeflateFlavor.Store)'                      new Config(4' 4' 8' 4' DeflateFlavor.Fast)'                      new Config(4' 5' 16' 8' DeflateFlavor.Fast)'                      new Config(4' 6' 32' 32' DeflateFlavor.Fast)'                        new Config(4' 4' 16' 16' DeflateFlavor.Slow)'                      new Config(8' 16' 32' 32' DeflateFlavor.Slow)'                      new Config(8' 16' 128' 128' DeflateFlavor.Slow)'                      new Config(8' 32' 128' 256' DeflateFlavor.Slow)'                      new Config(32' 128' 258' 1024' DeflateFlavor.Slow)'                      new Config(32' 258' 258' 4096' DeflateFlavor.Slow)'                  };
Magic Number,Ionic.Zlib,Config,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zlib.Shared\Deflate.cs,Config,The following statement contains a magic number: Table = new Config[] {                      new Config(0' 0' 0' 0' DeflateFlavor.Store)'                      new Config(4' 4' 8' 4' DeflateFlavor.Fast)'                      new Config(4' 5' 16' 8' DeflateFlavor.Fast)'                      new Config(4' 6' 32' 32' DeflateFlavor.Fast)'                        new Config(4' 4' 16' 16' DeflateFlavor.Slow)'                      new Config(8' 16' 32' 32' DeflateFlavor.Slow)'                      new Config(8' 16' 128' 128' DeflateFlavor.Slow)'                      new Config(8' 32' 128' 256' DeflateFlavor.Slow)'                      new Config(32' 128' 258' 1024' DeflateFlavor.Slow)'                      new Config(32' 258' 258' 4096' DeflateFlavor.Slow)'                  };
Magic Number,Ionic.Zlib,Config,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zlib.Shared\Deflate.cs,Config,The following statement contains a magic number: Table = new Config[] {                      new Config(0' 0' 0' 0' DeflateFlavor.Store)'                      new Config(4' 4' 8' 4' DeflateFlavor.Fast)'                      new Config(4' 5' 16' 8' DeflateFlavor.Fast)'                      new Config(4' 6' 32' 32' DeflateFlavor.Fast)'                        new Config(4' 4' 16' 16' DeflateFlavor.Slow)'                      new Config(8' 16' 32' 32' DeflateFlavor.Slow)'                      new Config(8' 16' 128' 128' DeflateFlavor.Slow)'                      new Config(8' 32' 128' 256' DeflateFlavor.Slow)'                      new Config(32' 128' 258' 1024' DeflateFlavor.Slow)'                      new Config(32' 258' 258' 4096' DeflateFlavor.Slow)'                  };
Magic Number,Ionic.Zlib,Config,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zlib.Shared\Deflate.cs,Config,The following statement contains a magic number: Table = new Config[] {                      new Config(0' 0' 0' 0' DeflateFlavor.Store)'                      new Config(4' 4' 8' 4' DeflateFlavor.Fast)'                      new Config(4' 5' 16' 8' DeflateFlavor.Fast)'                      new Config(4' 6' 32' 32' DeflateFlavor.Fast)'                        new Config(4' 4' 16' 16' DeflateFlavor.Slow)'                      new Config(8' 16' 32' 32' DeflateFlavor.Slow)'                      new Config(8' 16' 128' 128' DeflateFlavor.Slow)'                      new Config(8' 32' 128' 256' DeflateFlavor.Slow)'                      new Config(32' 128' 258' 1024' DeflateFlavor.Slow)'                      new Config(32' 258' 258' 4096' DeflateFlavor.Slow)'                  };
Magic Number,Ionic.Zlib,Config,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zlib.Shared\Deflate.cs,Config,The following statement contains a magic number: Table = new Config[] {                      new Config(0' 0' 0' 0' DeflateFlavor.Store)'                      new Config(4' 4' 8' 4' DeflateFlavor.Fast)'                      new Config(4' 5' 16' 8' DeflateFlavor.Fast)'                      new Config(4' 6' 32' 32' DeflateFlavor.Fast)'                        new Config(4' 4' 16' 16' DeflateFlavor.Slow)'                      new Config(8' 16' 32' 32' DeflateFlavor.Slow)'                      new Config(8' 16' 128' 128' DeflateFlavor.Slow)'                      new Config(8' 32' 128' 256' DeflateFlavor.Slow)'                      new Config(32' 128' 258' 1024' DeflateFlavor.Slow)'                      new Config(32' 258' 258' 4096' DeflateFlavor.Slow)'                  };
Magic Number,Ionic.Zlib,Config,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zlib.Shared\Deflate.cs,Config,The following statement contains a magic number: Table = new Config[] {                      new Config(0' 0' 0' 0' DeflateFlavor.Store)'                      new Config(4' 4' 8' 4' DeflateFlavor.Fast)'                      new Config(4' 5' 16' 8' DeflateFlavor.Fast)'                      new Config(4' 6' 32' 32' DeflateFlavor.Fast)'                        new Config(4' 4' 16' 16' DeflateFlavor.Slow)'                      new Config(8' 16' 32' 32' DeflateFlavor.Slow)'                      new Config(8' 16' 128' 128' DeflateFlavor.Slow)'                      new Config(8' 32' 128' 256' DeflateFlavor.Slow)'                      new Config(32' 128' 258' 1024' DeflateFlavor.Slow)'                      new Config(32' 258' 258' 4096' DeflateFlavor.Slow)'                  };
Magic Number,Ionic.Zlib,Config,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zlib.Shared\Deflate.cs,Config,The following statement contains a magic number: Table = new Config[] {                      new Config(0' 0' 0' 0' DeflateFlavor.Store)'                      new Config(4' 4' 8' 4' DeflateFlavor.Fast)'                      new Config(4' 5' 16' 8' DeflateFlavor.Fast)'                      new Config(4' 6' 32' 32' DeflateFlavor.Fast)'                        new Config(4' 4' 16' 16' DeflateFlavor.Slow)'                      new Config(8' 16' 32' 32' DeflateFlavor.Slow)'                      new Config(8' 16' 128' 128' DeflateFlavor.Slow)'                      new Config(8' 32' 128' 256' DeflateFlavor.Slow)'                      new Config(32' 128' 258' 1024' DeflateFlavor.Slow)'                      new Config(32' 258' 258' 4096' DeflateFlavor.Slow)'                  };
Magic Number,Ionic.Zlib,Config,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zlib.Shared\Deflate.cs,Config,The following statement contains a magic number: Table = new Config[] {                      new Config(0' 0' 0' 0' DeflateFlavor.Store)'                      new Config(4' 4' 8' 4' DeflateFlavor.Fast)'                      new Config(4' 5' 16' 8' DeflateFlavor.Fast)'                      new Config(4' 6' 32' 32' DeflateFlavor.Fast)'                        new Config(4' 4' 16' 16' DeflateFlavor.Slow)'                      new Config(8' 16' 32' 32' DeflateFlavor.Slow)'                      new Config(8' 16' 128' 128' DeflateFlavor.Slow)'                      new Config(8' 32' 128' 256' DeflateFlavor.Slow)'                      new Config(32' 128' 258' 1024' DeflateFlavor.Slow)'                      new Config(32' 258' 258' 4096' DeflateFlavor.Slow)'                  };
Magic Number,Ionic.Zlib,Config,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zlib.Shared\Deflate.cs,Config,The following statement contains a magic number: Table = new Config[] {                      new Config(0' 0' 0' 0' DeflateFlavor.Store)'                      new Config(4' 4' 8' 4' DeflateFlavor.Fast)'                      new Config(4' 5' 16' 8' DeflateFlavor.Fast)'                      new Config(4' 6' 32' 32' DeflateFlavor.Fast)'                        new Config(4' 4' 16' 16' DeflateFlavor.Slow)'                      new Config(8' 16' 32' 32' DeflateFlavor.Slow)'                      new Config(8' 16' 128' 128' DeflateFlavor.Slow)'                      new Config(8' 32' 128' 256' DeflateFlavor.Slow)'                      new Config(32' 128' 258' 1024' DeflateFlavor.Slow)'                      new Config(32' 258' 258' 4096' DeflateFlavor.Slow)'                  };
Magic Number,Ionic.Zlib,Config,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zlib.Shared\Deflate.cs,Config,The following statement contains a magic number: Table = new Config[] {                      new Config(0' 0' 0' 0' DeflateFlavor.Store)'                      new Config(4' 4' 8' 4' DeflateFlavor.Fast)'                      new Config(4' 5' 16' 8' DeflateFlavor.Fast)'                      new Config(4' 6' 32' 32' DeflateFlavor.Fast)'                        new Config(4' 4' 16' 16' DeflateFlavor.Slow)'                      new Config(8' 16' 32' 32' DeflateFlavor.Slow)'                      new Config(8' 16' 128' 128' DeflateFlavor.Slow)'                      new Config(8' 32' 128' 256' DeflateFlavor.Slow)'                      new Config(32' 128' 258' 1024' DeflateFlavor.Slow)'                      new Config(32' 258' 258' 4096' DeflateFlavor.Slow)'                  };
Magic Number,Ionic.Zlib,Config,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zlib.Shared\Deflate.cs,Config,The following statement contains a magic number: Table = new Config[] {                      new Config(0' 0' 0' 0' DeflateFlavor.Store)'                      new Config(4' 4' 8' 4' DeflateFlavor.Fast)'                      new Config(4' 5' 16' 8' DeflateFlavor.Fast)'                      new Config(4' 6' 32' 32' DeflateFlavor.Fast)'                        new Config(4' 4' 16' 16' DeflateFlavor.Slow)'                      new Config(8' 16' 32' 32' DeflateFlavor.Slow)'                      new Config(8' 16' 128' 128' DeflateFlavor.Slow)'                      new Config(8' 32' 128' 256' DeflateFlavor.Slow)'                      new Config(32' 128' 258' 1024' DeflateFlavor.Slow)'                      new Config(32' 258' 258' 4096' DeflateFlavor.Slow)'                  };
Magic Number,Ionic.Zlib,Config,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zlib.Shared\Deflate.cs,Config,The following statement contains a magic number: Table = new Config[] {                      new Config(0' 0' 0' 0' DeflateFlavor.Store)'                      new Config(4' 4' 8' 4' DeflateFlavor.Fast)'                      new Config(4' 5' 16' 8' DeflateFlavor.Fast)'                      new Config(4' 6' 32' 32' DeflateFlavor.Fast)'                        new Config(4' 4' 16' 16' DeflateFlavor.Slow)'                      new Config(8' 16' 32' 32' DeflateFlavor.Slow)'                      new Config(8' 16' 128' 128' DeflateFlavor.Slow)'                      new Config(8' 32' 128' 256' DeflateFlavor.Slow)'                      new Config(32' 128' 258' 1024' DeflateFlavor.Slow)'                      new Config(32' 258' 258' 4096' DeflateFlavor.Slow)'                  };
Magic Number,Ionic.Zlib,Config,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zlib.Shared\Deflate.cs,Config,The following statement contains a magic number: Table = new Config[] {                      new Config(0' 0' 0' 0' DeflateFlavor.Store)'                      new Config(4' 4' 8' 4' DeflateFlavor.Fast)'                      new Config(4' 5' 16' 8' DeflateFlavor.Fast)'                      new Config(4' 6' 32' 32' DeflateFlavor.Fast)'                        new Config(4' 4' 16' 16' DeflateFlavor.Slow)'                      new Config(8' 16' 32' 32' DeflateFlavor.Slow)'                      new Config(8' 16' 128' 128' DeflateFlavor.Slow)'                      new Config(8' 32' 128' 256' DeflateFlavor.Slow)'                      new Config(32' 128' 258' 1024' DeflateFlavor.Slow)'                      new Config(32' 258' 258' 4096' DeflateFlavor.Slow)'                  };
Magic Number,Ionic.Zlib,GZipStream,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zlib.Shared\GZipStream.cs,EmitHeader,The following statement contains a magic number: int bufferLength = 10 + cbLength + fnLength;
Magic Number,Ionic.Zlib,GZipStream,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zlib.Shared\GZipStream.cs,EmitHeader,The following statement contains a magic number: header[i++] = 8;
Magic Number,Ionic.Zlib,GZipStream,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zlib.Shared\GZipStream.cs,EmitHeader,The following statement contains a magic number: Array.Copy(BitConverter.GetBytes(timet)' 0' header' i' 4);
Magic Number,Ionic.Zlib,GZipStream,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zlib.Shared\GZipStream.cs,EmitHeader,The following statement contains a magic number: i += 4;
Magic Number,Ionic.Zlib,InflateBlocks,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zlib.Shared\Inflate.cs,InflateBlocks,The following statement contains a magic number: hufts = new int[MANY * 3];
Magic Number,Ionic.Zlib,InflateBlocks,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zlib.Shared\Inflate.cs,Process,The following statement contains a magic number: switch (mode)                  {                      case InflateBlockMode.TYPE:                            while (k < (3))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                                n--;                              b |= (_codec.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                          t = (int)(b & 7);                          last = t & 1;                            switch ((uint)t >> 1)                          {                              case 0:  // stored                                  b >>= 3; k -= (3);                                  t = k & 7; // go to byte boundary                                  b >>= t; k -= t;                                  mode = InflateBlockMode.LENS; // get length of stored block                                  break;                                case 1:  // fixed                                  int[] bl = new int[1];                                  int[] bd = new int[1];                                  int[][] tl = new int[1][];                                  int[][] td = new int[1][];                                  InfTree.inflate_trees_fixed(bl' bd' tl' td' _codec);                                  codes.Init(bl[0]' bd[0]' tl[0]' 0' td[0]' 0);                                  b >>= 3; k -= 3;                                  mode = InflateBlockMode.CODES;                                  break;                                case 2:  // dynamic                                  b >>= 3; k -= 3;                                  mode = InflateBlockMode.TABLE;                                  break;                                case 3:  // illegal                                  b >>= 3; k -= 3;                                  mode = InflateBlockMode.BAD;                                  _codec.Message = "invalid block type";                                  r = ZlibConstants.Z_DATA_ERROR;                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                          }                          break;                        case InflateBlockMode.LENS:                            while (k < (32))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                              ;                              n--;                              b |= (_codec.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            if ( ( ((~b)>>16) & 0xffff) != (b & 0xffff))                          {                              mode = InflateBlockMode.BAD;                              _codec.Message = "invalid stored block lengths";                              r = ZlibConstants.Z_DATA_ERROR;                                bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                          left = (b & 0xffff);                          b = k = 0; // dump bits                          mode = left != 0 ? InflateBlockMode.STORED : (last != 0 ? InflateBlockMode.DRY : InflateBlockMode.TYPE);                          break;                        case InflateBlockMode.STORED:                          if (n == 0)                          {                              bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                            if (m == 0)                          {                              if (q == end && readAt != 0)                              {                                  q = 0; m = (int)(q < readAt ? readAt - q - 1 : end - q);                              }                              if (m == 0)                              {                                  writeAt = q;                                  r = Flush(r);                                  q = writeAt; m = (int)(q < readAt ? readAt - q - 1 : end - q);                                  if (q == end && readAt != 0)                                  {                                      q = 0; m = (int)(q < readAt ? readAt - q - 1 : end - q);                                  }                                  if (m == 0)                                  {                                      bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                              }                          }                          r = ZlibConstants.Z_OK;                            t = left;                          if (t > n)                              t = n;                          if (t > m)                              t = m;                          Array.Copy(_codec.InputBuffer' p' window' q' t);                          p += t; n -= t;                          q += t; m -= t;                          if ((left -= t) != 0)                              break;                          mode = last != 0 ? InflateBlockMode.DRY : InflateBlockMode.TYPE;                          break;                        case InflateBlockMode.TABLE:                            while (k < (14))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                                n--;                              b |= (_codec.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            table = t = (b & 0x3fff);                          if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29)                          {                              mode = InflateBlockMode.BAD;                              _codec.Message = "too many length or distance symbols";                              r = ZlibConstants.Z_DATA_ERROR;                                bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                          t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);                          if (blens == null || blens.Length < t)                          {                              blens = new int[t];                          }                          else                          {                              Array.Clear(blens' 0' t);                              // for (int i = 0; i < t; i++)                              // {                              //     blens[i] = 0;                              // }                          }                            b >>= 14;                          k -= 14;                              index = 0;                          mode = InflateBlockMode.BTREE;                          goto case InflateBlockMode.BTREE;                        case InflateBlockMode.BTREE:                          while (index < 4 + (table >> 10))                          {                              while (k < (3))                              {                                  if (n != 0)                                  {                                      r = ZlibConstants.Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                                    n--;                                  b |= (_codec.InputBuffer[p++] & 0xff) << k;                                  k += 8;                              }                                blens[border[index++]] = b & 7;                                b >>= 3; k -= 3;                          }                            while (index < 19)                          {                              blens[border[index++]] = 0;                          }                            bb[0] = 7;                          t = inftree.inflate_trees_bits(blens' bb' tb' hufts' _codec);                          if (t != ZlibConstants.Z_OK)                          {                              r = t;                              if (r == ZlibConstants.Z_DATA_ERROR)                              {                                  blens = null;                                  mode = InflateBlockMode.BAD;                              }                                bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                            index = 0;                          mode = InflateBlockMode.DTREE;                          goto case InflateBlockMode.DTREE;                        case InflateBlockMode.DTREE:                          while (true)                          {                              t = table;                              if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)))                              {                                  break;                              }                                int i' j' c;                                t = bb[0];                                while (k < t)                              {                                  if (n != 0)                                  {                                      r = ZlibConstants.Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                                    n--;                                  b |= (_codec.InputBuffer[p++] & 0xff) << k;                                  k += 8;                              }                                t = hufts[(tb[0] + (b & InternalInflateConstants.InflateMask[t])) * 3 + 1];                              c = hufts[(tb[0] + (b & InternalInflateConstants.InflateMask[t])) * 3 + 2];                                if (c < 16)                              {                                  b >>= t; k -= t;                                  blens[index++] = c;                              }                              else                              {                                  // c == 16..18                                  i = c == 18 ? 7 : c - 14;                                  j = c == 18 ? 11 : 3;                                    while (k < (t + i))                                  {                                      if (n != 0)                                      {                                          r = ZlibConstants.Z_OK;                                      }                                      else                                      {                                          bitb = b; bitk = k;                                          _codec.AvailableBytesIn = n;                                          _codec.TotalBytesIn += p - _codec.NextIn;                                          _codec.NextIn = p;                                          writeAt = q;                                          return Flush(r);                                      }                                        n--;                                      b |= (_codec.InputBuffer[p++] & 0xff) << k;                                      k += 8;                                  }                                    b >>= t; k -= t;                                    j += (b & InternalInflateConstants.InflateMask[i]);                                    b >>= i; k -= i;                                    i = index;                                  t = table;                                  if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1))                                  {                                      blens = null;                                      mode = InflateBlockMode.BAD;                                      _codec.Message = "invalid bit length repeat";                                      r = ZlibConstants.Z_DATA_ERROR;                                        bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                                    c = (c == 16) ? blens[i-1] : 0;                                  do                                  {                                      blens[i++] = c;                                  }                                  while (--j != 0);                                  index = i;                              }                          }                            tb[0] = -1;                          {                              int[] bl = new int[] { 9 };  // must be <= 9 for lookahead assumptions                              int[] bd = new int[] { 6 }; // must be <= 9 for lookahead assumptions                              int[] tl = new int[1];                              int[] td = new int[1];                                t = table;                              t = inftree.inflate_trees_dynamic(257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' _codec);                                if (t != ZlibConstants.Z_OK)                              {                                  if (t == ZlibConstants.Z_DATA_ERROR)                                  {                                      blens = null;                                      mode = InflateBlockMode.BAD;                                  }                                  r = t;                                    bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                              codes.Init(bl[0]' bd[0]' hufts' tl[0]' hufts' td[0]);                          }                          mode = InflateBlockMode.CODES;                          goto case InflateBlockMode.CODES;                        case InflateBlockMode.CODES:                          bitb = b; bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                            r = codes.Process(this' r);                          if (r != ZlibConstants.Z_STREAM_END)                          {                              return Flush(r);                          }                            r = ZlibConstants.Z_OK;                          p = _codec.NextIn;                          n = _codec.AvailableBytesIn;                          b = bitb;                          k = bitk;                          q = writeAt;                          m = (int)(q < readAt ? readAt - q - 1 : end - q);                            if (last == 0)                          {                              mode = InflateBlockMode.TYPE;                              break;                          }                          mode = InflateBlockMode.DRY;                          goto case InflateBlockMode.DRY;                        case InflateBlockMode.DRY:                          writeAt = q;                          r = Flush(r);                          q = writeAt; m = (int)(q < readAt ? readAt - q - 1 : end - q);                          if (readAt != writeAt)                          {                              bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                          mode = InflateBlockMode.DONE;                          goto case InflateBlockMode.DONE;                        case InflateBlockMode.DONE:                          r = ZlibConstants.Z_STREAM_END;                          bitb = b;                          bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                          return Flush(r);                        case InflateBlockMode.BAD:                          r = ZlibConstants.Z_DATA_ERROR;                            bitb = b; bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                          return Flush(r);                          default:                          r = ZlibConstants.Z_STREAM_ERROR;                            bitb = b; bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                          return Flush(r);                  }
Magic Number,Ionic.Zlib,InflateBlocks,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zlib.Shared\Inflate.cs,Process,The following statement contains a magic number: switch (mode)                  {                      case InflateBlockMode.TYPE:                            while (k < (3))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                                n--;                              b |= (_codec.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                          t = (int)(b & 7);                          last = t & 1;                            switch ((uint)t >> 1)                          {                              case 0:  // stored                                  b >>= 3; k -= (3);                                  t = k & 7; // go to byte boundary                                  b >>= t; k -= t;                                  mode = InflateBlockMode.LENS; // get length of stored block                                  break;                                case 1:  // fixed                                  int[] bl = new int[1];                                  int[] bd = new int[1];                                  int[][] tl = new int[1][];                                  int[][] td = new int[1][];                                  InfTree.inflate_trees_fixed(bl' bd' tl' td' _codec);                                  codes.Init(bl[0]' bd[0]' tl[0]' 0' td[0]' 0);                                  b >>= 3; k -= 3;                                  mode = InflateBlockMode.CODES;                                  break;                                case 2:  // dynamic                                  b >>= 3; k -= 3;                                  mode = InflateBlockMode.TABLE;                                  break;                                case 3:  // illegal                                  b >>= 3; k -= 3;                                  mode = InflateBlockMode.BAD;                                  _codec.Message = "invalid block type";                                  r = ZlibConstants.Z_DATA_ERROR;                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                          }                          break;                        case InflateBlockMode.LENS:                            while (k < (32))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                              ;                              n--;                              b |= (_codec.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            if ( ( ((~b)>>16) & 0xffff) != (b & 0xffff))                          {                              mode = InflateBlockMode.BAD;                              _codec.Message = "invalid stored block lengths";                              r = ZlibConstants.Z_DATA_ERROR;                                bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                          left = (b & 0xffff);                          b = k = 0; // dump bits                          mode = left != 0 ? InflateBlockMode.STORED : (last != 0 ? InflateBlockMode.DRY : InflateBlockMode.TYPE);                          break;                        case InflateBlockMode.STORED:                          if (n == 0)                          {                              bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                            if (m == 0)                          {                              if (q == end && readAt != 0)                              {                                  q = 0; m = (int)(q < readAt ? readAt - q - 1 : end - q);                              }                              if (m == 0)                              {                                  writeAt = q;                                  r = Flush(r);                                  q = writeAt; m = (int)(q < readAt ? readAt - q - 1 : end - q);                                  if (q == end && readAt != 0)                                  {                                      q = 0; m = (int)(q < readAt ? readAt - q - 1 : end - q);                                  }                                  if (m == 0)                                  {                                      bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                              }                          }                          r = ZlibConstants.Z_OK;                            t = left;                          if (t > n)                              t = n;                          if (t > m)                              t = m;                          Array.Copy(_codec.InputBuffer' p' window' q' t);                          p += t; n -= t;                          q += t; m -= t;                          if ((left -= t) != 0)                              break;                          mode = last != 0 ? InflateBlockMode.DRY : InflateBlockMode.TYPE;                          break;                        case InflateBlockMode.TABLE:                            while (k < (14))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                                n--;                              b |= (_codec.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            table = t = (b & 0x3fff);                          if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29)                          {                              mode = InflateBlockMode.BAD;                              _codec.Message = "too many length or distance symbols";                              r = ZlibConstants.Z_DATA_ERROR;                                bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                          t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);                          if (blens == null || blens.Length < t)                          {                              blens = new int[t];                          }                          else                          {                              Array.Clear(blens' 0' t);                              // for (int i = 0; i < t; i++)                              // {                              //     blens[i] = 0;                              // }                          }                            b >>= 14;                          k -= 14;                              index = 0;                          mode = InflateBlockMode.BTREE;                          goto case InflateBlockMode.BTREE;                        case InflateBlockMode.BTREE:                          while (index < 4 + (table >> 10))                          {                              while (k < (3))                              {                                  if (n != 0)                                  {                                      r = ZlibConstants.Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                                    n--;                                  b |= (_codec.InputBuffer[p++] & 0xff) << k;                                  k += 8;                              }                                blens[border[index++]] = b & 7;                                b >>= 3; k -= 3;                          }                            while (index < 19)                          {                              blens[border[index++]] = 0;                          }                            bb[0] = 7;                          t = inftree.inflate_trees_bits(blens' bb' tb' hufts' _codec);                          if (t != ZlibConstants.Z_OK)                          {                              r = t;                              if (r == ZlibConstants.Z_DATA_ERROR)                              {                                  blens = null;                                  mode = InflateBlockMode.BAD;                              }                                bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                            index = 0;                          mode = InflateBlockMode.DTREE;                          goto case InflateBlockMode.DTREE;                        case InflateBlockMode.DTREE:                          while (true)                          {                              t = table;                              if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)))                              {                                  break;                              }                                int i' j' c;                                t = bb[0];                                while (k < t)                              {                                  if (n != 0)                                  {                                      r = ZlibConstants.Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                                    n--;                                  b |= (_codec.InputBuffer[p++] & 0xff) << k;                                  k += 8;                              }                                t = hufts[(tb[0] + (b & InternalInflateConstants.InflateMask[t])) * 3 + 1];                              c = hufts[(tb[0] + (b & InternalInflateConstants.InflateMask[t])) * 3 + 2];                                if (c < 16)                              {                                  b >>= t; k -= t;                                  blens[index++] = c;                              }                              else                              {                                  // c == 16..18                                  i = c == 18 ? 7 : c - 14;                                  j = c == 18 ? 11 : 3;                                    while (k < (t + i))                                  {                                      if (n != 0)                                      {                                          r = ZlibConstants.Z_OK;                                      }                                      else                                      {                                          bitb = b; bitk = k;                                          _codec.AvailableBytesIn = n;                                          _codec.TotalBytesIn += p - _codec.NextIn;                                          _codec.NextIn = p;                                          writeAt = q;                                          return Flush(r);                                      }                                        n--;                                      b |= (_codec.InputBuffer[p++] & 0xff) << k;                                      k += 8;                                  }                                    b >>= t; k -= t;                                    j += (b & InternalInflateConstants.InflateMask[i]);                                    b >>= i; k -= i;                                    i = index;                                  t = table;                                  if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1))                                  {                                      blens = null;                                      mode = InflateBlockMode.BAD;                                      _codec.Message = "invalid bit length repeat";                                      r = ZlibConstants.Z_DATA_ERROR;                                        bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                                    c = (c == 16) ? blens[i-1] : 0;                                  do                                  {                                      blens[i++] = c;                                  }                                  while (--j != 0);                                  index = i;                              }                          }                            tb[0] = -1;                          {                              int[] bl = new int[] { 9 };  // must be <= 9 for lookahead assumptions                              int[] bd = new int[] { 6 }; // must be <= 9 for lookahead assumptions                              int[] tl = new int[1];                              int[] td = new int[1];                                t = table;                              t = inftree.inflate_trees_dynamic(257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' _codec);                                if (t != ZlibConstants.Z_OK)                              {                                  if (t == ZlibConstants.Z_DATA_ERROR)                                  {                                      blens = null;                                      mode = InflateBlockMode.BAD;                                  }                                  r = t;                                    bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                              codes.Init(bl[0]' bd[0]' hufts' tl[0]' hufts' td[0]);                          }                          mode = InflateBlockMode.CODES;                          goto case InflateBlockMode.CODES;                        case InflateBlockMode.CODES:                          bitb = b; bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                            r = codes.Process(this' r);                          if (r != ZlibConstants.Z_STREAM_END)                          {                              return Flush(r);                          }                            r = ZlibConstants.Z_OK;                          p = _codec.NextIn;                          n = _codec.AvailableBytesIn;                          b = bitb;                          k = bitk;                          q = writeAt;                          m = (int)(q < readAt ? readAt - q - 1 : end - q);                            if (last == 0)                          {                              mode = InflateBlockMode.TYPE;                              break;                          }                          mode = InflateBlockMode.DRY;                          goto case InflateBlockMode.DRY;                        case InflateBlockMode.DRY:                          writeAt = q;                          r = Flush(r);                          q = writeAt; m = (int)(q < readAt ? readAt - q - 1 : end - q);                          if (readAt != writeAt)                          {                              bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                          mode = InflateBlockMode.DONE;                          goto case InflateBlockMode.DONE;                        case InflateBlockMode.DONE:                          r = ZlibConstants.Z_STREAM_END;                          bitb = b;                          bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                          return Flush(r);                        case InflateBlockMode.BAD:                          r = ZlibConstants.Z_DATA_ERROR;                            bitb = b; bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                          return Flush(r);                          default:                          r = ZlibConstants.Z_STREAM_ERROR;                            bitb = b; bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                          return Flush(r);                  }
Magic Number,Ionic.Zlib,InflateBlocks,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zlib.Shared\Inflate.cs,Process,The following statement contains a magic number: switch (mode)                  {                      case InflateBlockMode.TYPE:                            while (k < (3))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                                n--;                              b |= (_codec.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                          t = (int)(b & 7);                          last = t & 1;                            switch ((uint)t >> 1)                          {                              case 0:  // stored                                  b >>= 3; k -= (3);                                  t = k & 7; // go to byte boundary                                  b >>= t; k -= t;                                  mode = InflateBlockMode.LENS; // get length of stored block                                  break;                                case 1:  // fixed                                  int[] bl = new int[1];                                  int[] bd = new int[1];                                  int[][] tl = new int[1][];                                  int[][] td = new int[1][];                                  InfTree.inflate_trees_fixed(bl' bd' tl' td' _codec);                                  codes.Init(bl[0]' bd[0]' tl[0]' 0' td[0]' 0);                                  b >>= 3; k -= 3;                                  mode = InflateBlockMode.CODES;                                  break;                                case 2:  // dynamic                                  b >>= 3; k -= 3;                                  mode = InflateBlockMode.TABLE;                                  break;                                case 3:  // illegal                                  b >>= 3; k -= 3;                                  mode = InflateBlockMode.BAD;                                  _codec.Message = "invalid block type";                                  r = ZlibConstants.Z_DATA_ERROR;                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                          }                          break;                        case InflateBlockMode.LENS:                            while (k < (32))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                              ;                              n--;                              b |= (_codec.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            if ( ( ((~b)>>16) & 0xffff) != (b & 0xffff))                          {                              mode = InflateBlockMode.BAD;                              _codec.Message = "invalid stored block lengths";                              r = ZlibConstants.Z_DATA_ERROR;                                bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                          left = (b & 0xffff);                          b = k = 0; // dump bits                          mode = left != 0 ? InflateBlockMode.STORED : (last != 0 ? InflateBlockMode.DRY : InflateBlockMode.TYPE);                          break;                        case InflateBlockMode.STORED:                          if (n == 0)                          {                              bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                            if (m == 0)                          {                              if (q == end && readAt != 0)                              {                                  q = 0; m = (int)(q < readAt ? readAt - q - 1 : end - q);                              }                              if (m == 0)                              {                                  writeAt = q;                                  r = Flush(r);                                  q = writeAt; m = (int)(q < readAt ? readAt - q - 1 : end - q);                                  if (q == end && readAt != 0)                                  {                                      q = 0; m = (int)(q < readAt ? readAt - q - 1 : end - q);                                  }                                  if (m == 0)                                  {                                      bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                              }                          }                          r = ZlibConstants.Z_OK;                            t = left;                          if (t > n)                              t = n;                          if (t > m)                              t = m;                          Array.Copy(_codec.InputBuffer' p' window' q' t);                          p += t; n -= t;                          q += t; m -= t;                          if ((left -= t) != 0)                              break;                          mode = last != 0 ? InflateBlockMode.DRY : InflateBlockMode.TYPE;                          break;                        case InflateBlockMode.TABLE:                            while (k < (14))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                                n--;                              b |= (_codec.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            table = t = (b & 0x3fff);                          if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29)                          {                              mode = InflateBlockMode.BAD;                              _codec.Message = "too many length or distance symbols";                              r = ZlibConstants.Z_DATA_ERROR;                                bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                          t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);                          if (blens == null || blens.Length < t)                          {                              blens = new int[t];                          }                          else                          {                              Array.Clear(blens' 0' t);                              // for (int i = 0; i < t; i++)                              // {                              //     blens[i] = 0;                              // }                          }                            b >>= 14;                          k -= 14;                              index = 0;                          mode = InflateBlockMode.BTREE;                          goto case InflateBlockMode.BTREE;                        case InflateBlockMode.BTREE:                          while (index < 4 + (table >> 10))                          {                              while (k < (3))                              {                                  if (n != 0)                                  {                                      r = ZlibConstants.Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                                    n--;                                  b |= (_codec.InputBuffer[p++] & 0xff) << k;                                  k += 8;                              }                                blens[border[index++]] = b & 7;                                b >>= 3; k -= 3;                          }                            while (index < 19)                          {                              blens[border[index++]] = 0;                          }                            bb[0] = 7;                          t = inftree.inflate_trees_bits(blens' bb' tb' hufts' _codec);                          if (t != ZlibConstants.Z_OK)                          {                              r = t;                              if (r == ZlibConstants.Z_DATA_ERROR)                              {                                  blens = null;                                  mode = InflateBlockMode.BAD;                              }                                bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                            index = 0;                          mode = InflateBlockMode.DTREE;                          goto case InflateBlockMode.DTREE;                        case InflateBlockMode.DTREE:                          while (true)                          {                              t = table;                              if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)))                              {                                  break;                              }                                int i' j' c;                                t = bb[0];                                while (k < t)                              {                                  if (n != 0)                                  {                                      r = ZlibConstants.Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                                    n--;                                  b |= (_codec.InputBuffer[p++] & 0xff) << k;                                  k += 8;                              }                                t = hufts[(tb[0] + (b & InternalInflateConstants.InflateMask[t])) * 3 + 1];                              c = hufts[(tb[0] + (b & InternalInflateConstants.InflateMask[t])) * 3 + 2];                                if (c < 16)                              {                                  b >>= t; k -= t;                                  blens[index++] = c;                              }                              else                              {                                  // c == 16..18                                  i = c == 18 ? 7 : c - 14;                                  j = c == 18 ? 11 : 3;                                    while (k < (t + i))                                  {                                      if (n != 0)                                      {                                          r = ZlibConstants.Z_OK;                                      }                                      else                                      {                                          bitb = b; bitk = k;                                          _codec.AvailableBytesIn = n;                                          _codec.TotalBytesIn += p - _codec.NextIn;                                          _codec.NextIn = p;                                          writeAt = q;                                          return Flush(r);                                      }                                        n--;                                      b |= (_codec.InputBuffer[p++] & 0xff) << k;                                      k += 8;                                  }                                    b >>= t; k -= t;                                    j += (b & InternalInflateConstants.InflateMask[i]);                                    b >>= i; k -= i;                                    i = index;                                  t = table;                                  if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1))                                  {                                      blens = null;                                      mode = InflateBlockMode.BAD;                                      _codec.Message = "invalid bit length repeat";                                      r = ZlibConstants.Z_DATA_ERROR;                                        bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                                    c = (c == 16) ? blens[i-1] : 0;                                  do                                  {                                      blens[i++] = c;                                  }                                  while (--j != 0);                                  index = i;                              }                          }                            tb[0] = -1;                          {                              int[] bl = new int[] { 9 };  // must be <= 9 for lookahead assumptions                              int[] bd = new int[] { 6 }; // must be <= 9 for lookahead assumptions                              int[] tl = new int[1];                              int[] td = new int[1];                                t = table;                              t = inftree.inflate_trees_dynamic(257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' _codec);                                if (t != ZlibConstants.Z_OK)                              {                                  if (t == ZlibConstants.Z_DATA_ERROR)                                  {                                      blens = null;                                      mode = InflateBlockMode.BAD;                                  }                                  r = t;                                    bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                              codes.Init(bl[0]' bd[0]' hufts' tl[0]' hufts' td[0]);                          }                          mode = InflateBlockMode.CODES;                          goto case InflateBlockMode.CODES;                        case InflateBlockMode.CODES:                          bitb = b; bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                            r = codes.Process(this' r);                          if (r != ZlibConstants.Z_STREAM_END)                          {                              return Flush(r);                          }                            r = ZlibConstants.Z_OK;                          p = _codec.NextIn;                          n = _codec.AvailableBytesIn;                          b = bitb;                          k = bitk;                          q = writeAt;                          m = (int)(q < readAt ? readAt - q - 1 : end - q);                            if (last == 0)                          {                              mode = InflateBlockMode.TYPE;                              break;                          }                          mode = InflateBlockMode.DRY;                          goto case InflateBlockMode.DRY;                        case InflateBlockMode.DRY:                          writeAt = q;                          r = Flush(r);                          q = writeAt; m = (int)(q < readAt ? readAt - q - 1 : end - q);                          if (readAt != writeAt)                          {                              bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                          mode = InflateBlockMode.DONE;                          goto case InflateBlockMode.DONE;                        case InflateBlockMode.DONE:                          r = ZlibConstants.Z_STREAM_END;                          bitb = b;                          bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                          return Flush(r);                        case InflateBlockMode.BAD:                          r = ZlibConstants.Z_DATA_ERROR;                            bitb = b; bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                          return Flush(r);                          default:                          r = ZlibConstants.Z_STREAM_ERROR;                            bitb = b; bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                          return Flush(r);                  }
Magic Number,Ionic.Zlib,InflateBlocks,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zlib.Shared\Inflate.cs,Process,The following statement contains a magic number: switch (mode)                  {                      case InflateBlockMode.TYPE:                            while (k < (3))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                                n--;                              b |= (_codec.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                          t = (int)(b & 7);                          last = t & 1;                            switch ((uint)t >> 1)                          {                              case 0:  // stored                                  b >>= 3; k -= (3);                                  t = k & 7; // go to byte boundary                                  b >>= t; k -= t;                                  mode = InflateBlockMode.LENS; // get length of stored block                                  break;                                case 1:  // fixed                                  int[] bl = new int[1];                                  int[] bd = new int[1];                                  int[][] tl = new int[1][];                                  int[][] td = new int[1][];                                  InfTree.inflate_trees_fixed(bl' bd' tl' td' _codec);                                  codes.Init(bl[0]' bd[0]' tl[0]' 0' td[0]' 0);                                  b >>= 3; k -= 3;                                  mode = InflateBlockMode.CODES;                                  break;                                case 2:  // dynamic                                  b >>= 3; k -= 3;                                  mode = InflateBlockMode.TABLE;                                  break;                                case 3:  // illegal                                  b >>= 3; k -= 3;                                  mode = InflateBlockMode.BAD;                                  _codec.Message = "invalid block type";                                  r = ZlibConstants.Z_DATA_ERROR;                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                          }                          break;                        case InflateBlockMode.LENS:                            while (k < (32))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                              ;                              n--;                              b |= (_codec.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            if ( ( ((~b)>>16) & 0xffff) != (b & 0xffff))                          {                              mode = InflateBlockMode.BAD;                              _codec.Message = "invalid stored block lengths";                              r = ZlibConstants.Z_DATA_ERROR;                                bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                          left = (b & 0xffff);                          b = k = 0; // dump bits                          mode = left != 0 ? InflateBlockMode.STORED : (last != 0 ? InflateBlockMode.DRY : InflateBlockMode.TYPE);                          break;                        case InflateBlockMode.STORED:                          if (n == 0)                          {                              bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                            if (m == 0)                          {                              if (q == end && readAt != 0)                              {                                  q = 0; m = (int)(q < readAt ? readAt - q - 1 : end - q);                              }                              if (m == 0)                              {                                  writeAt = q;                                  r = Flush(r);                                  q = writeAt; m = (int)(q < readAt ? readAt - q - 1 : end - q);                                  if (q == end && readAt != 0)                                  {                                      q = 0; m = (int)(q < readAt ? readAt - q - 1 : end - q);                                  }                                  if (m == 0)                                  {                                      bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                              }                          }                          r = ZlibConstants.Z_OK;                            t = left;                          if (t > n)                              t = n;                          if (t > m)                              t = m;                          Array.Copy(_codec.InputBuffer' p' window' q' t);                          p += t; n -= t;                          q += t; m -= t;                          if ((left -= t) != 0)                              break;                          mode = last != 0 ? InflateBlockMode.DRY : InflateBlockMode.TYPE;                          break;                        case InflateBlockMode.TABLE:                            while (k < (14))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                                n--;                              b |= (_codec.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            table = t = (b & 0x3fff);                          if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29)                          {                              mode = InflateBlockMode.BAD;                              _codec.Message = "too many length or distance symbols";                              r = ZlibConstants.Z_DATA_ERROR;                                bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                          t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);                          if (blens == null || blens.Length < t)                          {                              blens = new int[t];                          }                          else                          {                              Array.Clear(blens' 0' t);                              // for (int i = 0; i < t; i++)                              // {                              //     blens[i] = 0;                              // }                          }                            b >>= 14;                          k -= 14;                              index = 0;                          mode = InflateBlockMode.BTREE;                          goto case InflateBlockMode.BTREE;                        case InflateBlockMode.BTREE:                          while (index < 4 + (table >> 10))                          {                              while (k < (3))                              {                                  if (n != 0)                                  {                                      r = ZlibConstants.Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                                    n--;                                  b |= (_codec.InputBuffer[p++] & 0xff) << k;                                  k += 8;                              }                                blens[border[index++]] = b & 7;                                b >>= 3; k -= 3;                          }                            while (index < 19)                          {                              blens[border[index++]] = 0;                          }                            bb[0] = 7;                          t = inftree.inflate_trees_bits(blens' bb' tb' hufts' _codec);                          if (t != ZlibConstants.Z_OK)                          {                              r = t;                              if (r == ZlibConstants.Z_DATA_ERROR)                              {                                  blens = null;                                  mode = InflateBlockMode.BAD;                              }                                bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                            index = 0;                          mode = InflateBlockMode.DTREE;                          goto case InflateBlockMode.DTREE;                        case InflateBlockMode.DTREE:                          while (true)                          {                              t = table;                              if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)))                              {                                  break;                              }                                int i' j' c;                                t = bb[0];                                while (k < t)                              {                                  if (n != 0)                                  {                                      r = ZlibConstants.Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                                    n--;                                  b |= (_codec.InputBuffer[p++] & 0xff) << k;                                  k += 8;                              }                                t = hufts[(tb[0] + (b & InternalInflateConstants.InflateMask[t])) * 3 + 1];                              c = hufts[(tb[0] + (b & InternalInflateConstants.InflateMask[t])) * 3 + 2];                                if (c < 16)                              {                                  b >>= t; k -= t;                                  blens[index++] = c;                              }                              else                              {                                  // c == 16..18                                  i = c == 18 ? 7 : c - 14;                                  j = c == 18 ? 11 : 3;                                    while (k < (t + i))                                  {                                      if (n != 0)                                      {                                          r = ZlibConstants.Z_OK;                                      }                                      else                                      {                                          bitb = b; bitk = k;                                          _codec.AvailableBytesIn = n;                                          _codec.TotalBytesIn += p - _codec.NextIn;                                          _codec.NextIn = p;                                          writeAt = q;                                          return Flush(r);                                      }                                        n--;                                      b |= (_codec.InputBuffer[p++] & 0xff) << k;                                      k += 8;                                  }                                    b >>= t; k -= t;                                    j += (b & InternalInflateConstants.InflateMask[i]);                                    b >>= i; k -= i;                                    i = index;                                  t = table;                                  if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1))                                  {                                      blens = null;                                      mode = InflateBlockMode.BAD;                                      _codec.Message = "invalid bit length repeat";                                      r = ZlibConstants.Z_DATA_ERROR;                                        bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                                    c = (c == 16) ? blens[i-1] : 0;                                  do                                  {                                      blens[i++] = c;                                  }                                  while (--j != 0);                                  index = i;                              }                          }                            tb[0] = -1;                          {                              int[] bl = new int[] { 9 };  // must be <= 9 for lookahead assumptions                              int[] bd = new int[] { 6 }; // must be <= 9 for lookahead assumptions                              int[] tl = new int[1];                              int[] td = new int[1];                                t = table;                              t = inftree.inflate_trees_dynamic(257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' _codec);                                if (t != ZlibConstants.Z_OK)                              {                                  if (t == ZlibConstants.Z_DATA_ERROR)                                  {                                      blens = null;                                      mode = InflateBlockMode.BAD;                                  }                                  r = t;                                    bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                              codes.Init(bl[0]' bd[0]' hufts' tl[0]' hufts' td[0]);                          }                          mode = InflateBlockMode.CODES;                          goto case InflateBlockMode.CODES;                        case InflateBlockMode.CODES:                          bitb = b; bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                            r = codes.Process(this' r);                          if (r != ZlibConstants.Z_STREAM_END)                          {                              return Flush(r);                          }                            r = ZlibConstants.Z_OK;                          p = _codec.NextIn;                          n = _codec.AvailableBytesIn;                          b = bitb;                          k = bitk;                          q = writeAt;                          m = (int)(q < readAt ? readAt - q - 1 : end - q);                            if (last == 0)                          {                              mode = InflateBlockMode.TYPE;                              break;                          }                          mode = InflateBlockMode.DRY;                          goto case InflateBlockMode.DRY;                        case InflateBlockMode.DRY:                          writeAt = q;                          r = Flush(r);                          q = writeAt; m = (int)(q < readAt ? readAt - q - 1 : end - q);                          if (readAt != writeAt)                          {                              bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                          mode = InflateBlockMode.DONE;                          goto case InflateBlockMode.DONE;                        case InflateBlockMode.DONE:                          r = ZlibConstants.Z_STREAM_END;                          bitb = b;                          bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                          return Flush(r);                        case InflateBlockMode.BAD:                          r = ZlibConstants.Z_DATA_ERROR;                            bitb = b; bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                          return Flush(r);                          default:                          r = ZlibConstants.Z_STREAM_ERROR;                            bitb = b; bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                          return Flush(r);                  }
Magic Number,Ionic.Zlib,InflateBlocks,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zlib.Shared\Inflate.cs,Process,The following statement contains a magic number: switch (mode)                  {                      case InflateBlockMode.TYPE:                            while (k < (3))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                                n--;                              b |= (_codec.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                          t = (int)(b & 7);                          last = t & 1;                            switch ((uint)t >> 1)                          {                              case 0:  // stored                                  b >>= 3; k -= (3);                                  t = k & 7; // go to byte boundary                                  b >>= t; k -= t;                                  mode = InflateBlockMode.LENS; // get length of stored block                                  break;                                case 1:  // fixed                                  int[] bl = new int[1];                                  int[] bd = new int[1];                                  int[][] tl = new int[1][];                                  int[][] td = new int[1][];                                  InfTree.inflate_trees_fixed(bl' bd' tl' td' _codec);                                  codes.Init(bl[0]' bd[0]' tl[0]' 0' td[0]' 0);                                  b >>= 3; k -= 3;                                  mode = InflateBlockMode.CODES;                                  break;                                case 2:  // dynamic                                  b >>= 3; k -= 3;                                  mode = InflateBlockMode.TABLE;                                  break;                                case 3:  // illegal                                  b >>= 3; k -= 3;                                  mode = InflateBlockMode.BAD;                                  _codec.Message = "invalid block type";                                  r = ZlibConstants.Z_DATA_ERROR;                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                          }                          break;                        case InflateBlockMode.LENS:                            while (k < (32))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                              ;                              n--;                              b |= (_codec.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            if ( ( ((~b)>>16) & 0xffff) != (b & 0xffff))                          {                              mode = InflateBlockMode.BAD;                              _codec.Message = "invalid stored block lengths";                              r = ZlibConstants.Z_DATA_ERROR;                                bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                          left = (b & 0xffff);                          b = k = 0; // dump bits                          mode = left != 0 ? InflateBlockMode.STORED : (last != 0 ? InflateBlockMode.DRY : InflateBlockMode.TYPE);                          break;                        case InflateBlockMode.STORED:                          if (n == 0)                          {                              bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                            if (m == 0)                          {                              if (q == end && readAt != 0)                              {                                  q = 0; m = (int)(q < readAt ? readAt - q - 1 : end - q);                              }                              if (m == 0)                              {                                  writeAt = q;                                  r = Flush(r);                                  q = writeAt; m = (int)(q < readAt ? readAt - q - 1 : end - q);                                  if (q == end && readAt != 0)                                  {                                      q = 0; m = (int)(q < readAt ? readAt - q - 1 : end - q);                                  }                                  if (m == 0)                                  {                                      bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                              }                          }                          r = ZlibConstants.Z_OK;                            t = left;                          if (t > n)                              t = n;                          if (t > m)                              t = m;                          Array.Copy(_codec.InputBuffer' p' window' q' t);                          p += t; n -= t;                          q += t; m -= t;                          if ((left -= t) != 0)                              break;                          mode = last != 0 ? InflateBlockMode.DRY : InflateBlockMode.TYPE;                          break;                        case InflateBlockMode.TABLE:                            while (k < (14))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                                n--;                              b |= (_codec.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            table = t = (b & 0x3fff);                          if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29)                          {                              mode = InflateBlockMode.BAD;                              _codec.Message = "too many length or distance symbols";                              r = ZlibConstants.Z_DATA_ERROR;                                bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                          t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);                          if (blens == null || blens.Length < t)                          {                              blens = new int[t];                          }                          else                          {                              Array.Clear(blens' 0' t);                              // for (int i = 0; i < t; i++)                              // {                              //     blens[i] = 0;                              // }                          }                            b >>= 14;                          k -= 14;                              index = 0;                          mode = InflateBlockMode.BTREE;                          goto case InflateBlockMode.BTREE;                        case InflateBlockMode.BTREE:                          while (index < 4 + (table >> 10))                          {                              while (k < (3))                              {                                  if (n != 0)                                  {                                      r = ZlibConstants.Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                                    n--;                                  b |= (_codec.InputBuffer[p++] & 0xff) << k;                                  k += 8;                              }                                blens[border[index++]] = b & 7;                                b >>= 3; k -= 3;                          }                            while (index < 19)                          {                              blens[border[index++]] = 0;                          }                            bb[0] = 7;                          t = inftree.inflate_trees_bits(blens' bb' tb' hufts' _codec);                          if (t != ZlibConstants.Z_OK)                          {                              r = t;                              if (r == ZlibConstants.Z_DATA_ERROR)                              {                                  blens = null;                                  mode = InflateBlockMode.BAD;                              }                                bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                            index = 0;                          mode = InflateBlockMode.DTREE;                          goto case InflateBlockMode.DTREE;                        case InflateBlockMode.DTREE:                          while (true)                          {                              t = table;                              if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)))                              {                                  break;                              }                                int i' j' c;                                t = bb[0];                                while (k < t)                              {                                  if (n != 0)                                  {                                      r = ZlibConstants.Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                                    n--;                                  b |= (_codec.InputBuffer[p++] & 0xff) << k;                                  k += 8;                              }                                t = hufts[(tb[0] + (b & InternalInflateConstants.InflateMask[t])) * 3 + 1];                              c = hufts[(tb[0] + (b & InternalInflateConstants.InflateMask[t])) * 3 + 2];                                if (c < 16)                              {                                  b >>= t; k -= t;                                  blens[index++] = c;                              }                              else                              {                                  // c == 16..18                                  i = c == 18 ? 7 : c - 14;                                  j = c == 18 ? 11 : 3;                                    while (k < (t + i))                                  {                                      if (n != 0)                                      {                                          r = ZlibConstants.Z_OK;                                      }                                      else                                      {                                          bitb = b; bitk = k;                                          _codec.AvailableBytesIn = n;                                          _codec.TotalBytesIn += p - _codec.NextIn;                                          _codec.NextIn = p;                                          writeAt = q;                                          return Flush(r);                                      }                                        n--;                                      b |= (_codec.InputBuffer[p++] & 0xff) << k;                                      k += 8;                                  }                                    b >>= t; k -= t;                                    j += (b & InternalInflateConstants.InflateMask[i]);                                    b >>= i; k -= i;                                    i = index;                                  t = table;                                  if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1))                                  {                                      blens = null;                                      mode = InflateBlockMode.BAD;                                      _codec.Message = "invalid bit length repeat";                                      r = ZlibConstants.Z_DATA_ERROR;                                        bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                                    c = (c == 16) ? blens[i-1] : 0;                                  do                                  {                                      blens[i++] = c;                                  }                                  while (--j != 0);                                  index = i;                              }                          }                            tb[0] = -1;                          {                              int[] bl = new int[] { 9 };  // must be <= 9 for lookahead assumptions                              int[] bd = new int[] { 6 }; // must be <= 9 for lookahead assumptions                              int[] tl = new int[1];                              int[] td = new int[1];                                t = table;                              t = inftree.inflate_trees_dynamic(257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' _codec);                                if (t != ZlibConstants.Z_OK)                              {                                  if (t == ZlibConstants.Z_DATA_ERROR)                                  {                                      blens = null;                                      mode = InflateBlockMode.BAD;                                  }                                  r = t;                                    bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                              codes.Init(bl[0]' bd[0]' hufts' tl[0]' hufts' td[0]);                          }                          mode = InflateBlockMode.CODES;                          goto case InflateBlockMode.CODES;                        case InflateBlockMode.CODES:                          bitb = b; bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                            r = codes.Process(this' r);                          if (r != ZlibConstants.Z_STREAM_END)                          {                              return Flush(r);                          }                            r = ZlibConstants.Z_OK;                          p = _codec.NextIn;                          n = _codec.AvailableBytesIn;                          b = bitb;                          k = bitk;                          q = writeAt;                          m = (int)(q < readAt ? readAt - q - 1 : end - q);                            if (last == 0)                          {                              mode = InflateBlockMode.TYPE;                              break;                          }                          mode = InflateBlockMode.DRY;                          goto case InflateBlockMode.DRY;                        case InflateBlockMode.DRY:                          writeAt = q;                          r = Flush(r);                          q = writeAt; m = (int)(q < readAt ? readAt - q - 1 : end - q);                          if (readAt != writeAt)                          {                              bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                          mode = InflateBlockMode.DONE;                          goto case InflateBlockMode.DONE;                        case InflateBlockMode.DONE:                          r = ZlibConstants.Z_STREAM_END;                          bitb = b;                          bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                          return Flush(r);                        case InflateBlockMode.BAD:                          r = ZlibConstants.Z_DATA_ERROR;                            bitb = b; bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                          return Flush(r);                          default:                          r = ZlibConstants.Z_STREAM_ERROR;                            bitb = b; bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                          return Flush(r);                  }
Magic Number,Ionic.Zlib,InflateBlocks,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zlib.Shared\Inflate.cs,Process,The following statement contains a magic number: switch (mode)                  {                      case InflateBlockMode.TYPE:                            while (k < (3))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                                n--;                              b |= (_codec.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                          t = (int)(b & 7);                          last = t & 1;                            switch ((uint)t >> 1)                          {                              case 0:  // stored                                  b >>= 3; k -= (3);                                  t = k & 7; // go to byte boundary                                  b >>= t; k -= t;                                  mode = InflateBlockMode.LENS; // get length of stored block                                  break;                                case 1:  // fixed                                  int[] bl = new int[1];                                  int[] bd = new int[1];                                  int[][] tl = new int[1][];                                  int[][] td = new int[1][];                                  InfTree.inflate_trees_fixed(bl' bd' tl' td' _codec);                                  codes.Init(bl[0]' bd[0]' tl[0]' 0' td[0]' 0);                                  b >>= 3; k -= 3;                                  mode = InflateBlockMode.CODES;                                  break;                                case 2:  // dynamic                                  b >>= 3; k -= 3;                                  mode = InflateBlockMode.TABLE;                                  break;                                case 3:  // illegal                                  b >>= 3; k -= 3;                                  mode = InflateBlockMode.BAD;                                  _codec.Message = "invalid block type";                                  r = ZlibConstants.Z_DATA_ERROR;                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                          }                          break;                        case InflateBlockMode.LENS:                            while (k < (32))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                              ;                              n--;                              b |= (_codec.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            if ( ( ((~b)>>16) & 0xffff) != (b & 0xffff))                          {                              mode = InflateBlockMode.BAD;                              _codec.Message = "invalid stored block lengths";                              r = ZlibConstants.Z_DATA_ERROR;                                bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                          left = (b & 0xffff);                          b = k = 0; // dump bits                          mode = left != 0 ? InflateBlockMode.STORED : (last != 0 ? InflateBlockMode.DRY : InflateBlockMode.TYPE);                          break;                        case InflateBlockMode.STORED:                          if (n == 0)                          {                              bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                            if (m == 0)                          {                              if (q == end && readAt != 0)                              {                                  q = 0; m = (int)(q < readAt ? readAt - q - 1 : end - q);                              }                              if (m == 0)                              {                                  writeAt = q;                                  r = Flush(r);                                  q = writeAt; m = (int)(q < readAt ? readAt - q - 1 : end - q);                                  if (q == end && readAt != 0)                                  {                                      q = 0; m = (int)(q < readAt ? readAt - q - 1 : end - q);                                  }                                  if (m == 0)                                  {                                      bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                              }                          }                          r = ZlibConstants.Z_OK;                            t = left;                          if (t > n)                              t = n;                          if (t > m)                              t = m;                          Array.Copy(_codec.InputBuffer' p' window' q' t);                          p += t; n -= t;                          q += t; m -= t;                          if ((left -= t) != 0)                              break;                          mode = last != 0 ? InflateBlockMode.DRY : InflateBlockMode.TYPE;                          break;                        case InflateBlockMode.TABLE:                            while (k < (14))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                                n--;                              b |= (_codec.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            table = t = (b & 0x3fff);                          if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29)                          {                              mode = InflateBlockMode.BAD;                              _codec.Message = "too many length or distance symbols";                              r = ZlibConstants.Z_DATA_ERROR;                                bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                          t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);                          if (blens == null || blens.Length < t)                          {                              blens = new int[t];                          }                          else                          {                              Array.Clear(blens' 0' t);                              // for (int i = 0; i < t; i++)                              // {                              //     blens[i] = 0;                              // }                          }                            b >>= 14;                          k -= 14;                              index = 0;                          mode = InflateBlockMode.BTREE;                          goto case InflateBlockMode.BTREE;                        case InflateBlockMode.BTREE:                          while (index < 4 + (table >> 10))                          {                              while (k < (3))                              {                                  if (n != 0)                                  {                                      r = ZlibConstants.Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                                    n--;                                  b |= (_codec.InputBuffer[p++] & 0xff) << k;                                  k += 8;                              }                                blens[border[index++]] = b & 7;                                b >>= 3; k -= 3;                          }                            while (index < 19)                          {                              blens[border[index++]] = 0;                          }                            bb[0] = 7;                          t = inftree.inflate_trees_bits(blens' bb' tb' hufts' _codec);                          if (t != ZlibConstants.Z_OK)                          {                              r = t;                              if (r == ZlibConstants.Z_DATA_ERROR)                              {                                  blens = null;                                  mode = InflateBlockMode.BAD;                              }                                bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                            index = 0;                          mode = InflateBlockMode.DTREE;                          goto case InflateBlockMode.DTREE;                        case InflateBlockMode.DTREE:                          while (true)                          {                              t = table;                              if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)))                              {                                  break;                              }                                int i' j' c;                                t = bb[0];                                while (k < t)                              {                                  if (n != 0)                                  {                                      r = ZlibConstants.Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                                    n--;                                  b |= (_codec.InputBuffer[p++] & 0xff) << k;                                  k += 8;                              }                                t = hufts[(tb[0] + (b & InternalInflateConstants.InflateMask[t])) * 3 + 1];                              c = hufts[(tb[0] + (b & InternalInflateConstants.InflateMask[t])) * 3 + 2];                                if (c < 16)                              {                                  b >>= t; k -= t;                                  blens[index++] = c;                              }                              else                              {                                  // c == 16..18                                  i = c == 18 ? 7 : c - 14;                                  j = c == 18 ? 11 : 3;                                    while (k < (t + i))                                  {                                      if (n != 0)                                      {                                          r = ZlibConstants.Z_OK;                                      }                                      else                                      {                                          bitb = b; bitk = k;                                          _codec.AvailableBytesIn = n;                                          _codec.TotalBytesIn += p - _codec.NextIn;                                          _codec.NextIn = p;                                          writeAt = q;                                          return Flush(r);                                      }                                        n--;                                      b |= (_codec.InputBuffer[p++] & 0xff) << k;                                      k += 8;                                  }                                    b >>= t; k -= t;                                    j += (b & InternalInflateConstants.InflateMask[i]);                                    b >>= i; k -= i;                                    i = index;                                  t = table;                                  if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1))                                  {                                      blens = null;                                      mode = InflateBlockMode.BAD;                                      _codec.Message = "invalid bit length repeat";                                      r = ZlibConstants.Z_DATA_ERROR;                                        bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                                    c = (c == 16) ? blens[i-1] : 0;                                  do                                  {                                      blens[i++] = c;                                  }                                  while (--j != 0);                                  index = i;                              }                          }                            tb[0] = -1;                          {                              int[] bl = new int[] { 9 };  // must be <= 9 for lookahead assumptions                              int[] bd = new int[] { 6 }; // must be <= 9 for lookahead assumptions                              int[] tl = new int[1];                              int[] td = new int[1];                                t = table;                              t = inftree.inflate_trees_dynamic(257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' _codec);                                if (t != ZlibConstants.Z_OK)                              {                                  if (t == ZlibConstants.Z_DATA_ERROR)                                  {                                      blens = null;                                      mode = InflateBlockMode.BAD;                                  }                                  r = t;                                    bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                              codes.Init(bl[0]' bd[0]' hufts' tl[0]' hufts' td[0]);                          }                          mode = InflateBlockMode.CODES;                          goto case InflateBlockMode.CODES;                        case InflateBlockMode.CODES:                          bitb = b; bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                            r = codes.Process(this' r);                          if (r != ZlibConstants.Z_STREAM_END)                          {                              return Flush(r);                          }                            r = ZlibConstants.Z_OK;                          p = _codec.NextIn;                          n = _codec.AvailableBytesIn;                          b = bitb;                          k = bitk;                          q = writeAt;                          m = (int)(q < readAt ? readAt - q - 1 : end - q);                            if (last == 0)                          {                              mode = InflateBlockMode.TYPE;                              break;                          }                          mode = InflateBlockMode.DRY;                          goto case InflateBlockMode.DRY;                        case InflateBlockMode.DRY:                          writeAt = q;                          r = Flush(r);                          q = writeAt; m = (int)(q < readAt ? readAt - q - 1 : end - q);                          if (readAt != writeAt)                          {                              bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                          mode = InflateBlockMode.DONE;                          goto case InflateBlockMode.DONE;                        case InflateBlockMode.DONE:                          r = ZlibConstants.Z_STREAM_END;                          bitb = b;                          bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                          return Flush(r);                        case InflateBlockMode.BAD:                          r = ZlibConstants.Z_DATA_ERROR;                            bitb = b; bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                          return Flush(r);                          default:                          r = ZlibConstants.Z_STREAM_ERROR;                            bitb = b; bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                          return Flush(r);                  }
Magic Number,Ionic.Zlib,InflateBlocks,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zlib.Shared\Inflate.cs,Process,The following statement contains a magic number: switch (mode)                  {                      case InflateBlockMode.TYPE:                            while (k < (3))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                                n--;                              b |= (_codec.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                          t = (int)(b & 7);                          last = t & 1;                            switch ((uint)t >> 1)                          {                              case 0:  // stored                                  b >>= 3; k -= (3);                                  t = k & 7; // go to byte boundary                                  b >>= t; k -= t;                                  mode = InflateBlockMode.LENS; // get length of stored block                                  break;                                case 1:  // fixed                                  int[] bl = new int[1];                                  int[] bd = new int[1];                                  int[][] tl = new int[1][];                                  int[][] td = new int[1][];                                  InfTree.inflate_trees_fixed(bl' bd' tl' td' _codec);                                  codes.Init(bl[0]' bd[0]' tl[0]' 0' td[0]' 0);                                  b >>= 3; k -= 3;                                  mode = InflateBlockMode.CODES;                                  break;                                case 2:  // dynamic                                  b >>= 3; k -= 3;                                  mode = InflateBlockMode.TABLE;                                  break;                                case 3:  // illegal                                  b >>= 3; k -= 3;                                  mode = InflateBlockMode.BAD;                                  _codec.Message = "invalid block type";                                  r = ZlibConstants.Z_DATA_ERROR;                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                          }                          break;                        case InflateBlockMode.LENS:                            while (k < (32))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                              ;                              n--;                              b |= (_codec.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            if ( ( ((~b)>>16) & 0xffff) != (b & 0xffff))                          {                              mode = InflateBlockMode.BAD;                              _codec.Message = "invalid stored block lengths";                              r = ZlibConstants.Z_DATA_ERROR;                                bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                          left = (b & 0xffff);                          b = k = 0; // dump bits                          mode = left != 0 ? InflateBlockMode.STORED : (last != 0 ? InflateBlockMode.DRY : InflateBlockMode.TYPE);                          break;                        case InflateBlockMode.STORED:                          if (n == 0)                          {                              bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                            if (m == 0)                          {                              if (q == end && readAt != 0)                              {                                  q = 0; m = (int)(q < readAt ? readAt - q - 1 : end - q);                              }                              if (m == 0)                              {                                  writeAt = q;                                  r = Flush(r);                                  q = writeAt; m = (int)(q < readAt ? readAt - q - 1 : end - q);                                  if (q == end && readAt != 0)                                  {                                      q = 0; m = (int)(q < readAt ? readAt - q - 1 : end - q);                                  }                                  if (m == 0)                                  {                                      bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                              }                          }                          r = ZlibConstants.Z_OK;                            t = left;                          if (t > n)                              t = n;                          if (t > m)                              t = m;                          Array.Copy(_codec.InputBuffer' p' window' q' t);                          p += t; n -= t;                          q += t; m -= t;                          if ((left -= t) != 0)                              break;                          mode = last != 0 ? InflateBlockMode.DRY : InflateBlockMode.TYPE;                          break;                        case InflateBlockMode.TABLE:                            while (k < (14))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                                n--;                              b |= (_codec.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            table = t = (b & 0x3fff);                          if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29)                          {                              mode = InflateBlockMode.BAD;                              _codec.Message = "too many length or distance symbols";                              r = ZlibConstants.Z_DATA_ERROR;                                bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                          t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);                          if (blens == null || blens.Length < t)                          {                              blens = new int[t];                          }                          else                          {                              Array.Clear(blens' 0' t);                              // for (int i = 0; i < t; i++)                              // {                              //     blens[i] = 0;                              // }                          }                            b >>= 14;                          k -= 14;                              index = 0;                          mode = InflateBlockMode.BTREE;                          goto case InflateBlockMode.BTREE;                        case InflateBlockMode.BTREE:                          while (index < 4 + (table >> 10))                          {                              while (k < (3))                              {                                  if (n != 0)                                  {                                      r = ZlibConstants.Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                                    n--;                                  b |= (_codec.InputBuffer[p++] & 0xff) << k;                                  k += 8;                              }                                blens[border[index++]] = b & 7;                                b >>= 3; k -= 3;                          }                            while (index < 19)                          {                              blens[border[index++]] = 0;                          }                            bb[0] = 7;                          t = inftree.inflate_trees_bits(blens' bb' tb' hufts' _codec);                          if (t != ZlibConstants.Z_OK)                          {                              r = t;                              if (r == ZlibConstants.Z_DATA_ERROR)                              {                                  blens = null;                                  mode = InflateBlockMode.BAD;                              }                                bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                            index = 0;                          mode = InflateBlockMode.DTREE;                          goto case InflateBlockMode.DTREE;                        case InflateBlockMode.DTREE:                          while (true)                          {                              t = table;                              if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)))                              {                                  break;                              }                                int i' j' c;                                t = bb[0];                                while (k < t)                              {                                  if (n != 0)                                  {                                      r = ZlibConstants.Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                                    n--;                                  b |= (_codec.InputBuffer[p++] & 0xff) << k;                                  k += 8;                              }                                t = hufts[(tb[0] + (b & InternalInflateConstants.InflateMask[t])) * 3 + 1];                              c = hufts[(tb[0] + (b & InternalInflateConstants.InflateMask[t])) * 3 + 2];                                if (c < 16)                              {                                  b >>= t; k -= t;                                  blens[index++] = c;                              }                              else                              {                                  // c == 16..18                                  i = c == 18 ? 7 : c - 14;                                  j = c == 18 ? 11 : 3;                                    while (k < (t + i))                                  {                                      if (n != 0)                                      {                                          r = ZlibConstants.Z_OK;                                      }                                      else                                      {                                          bitb = b; bitk = k;                                          _codec.AvailableBytesIn = n;                                          _codec.TotalBytesIn += p - _codec.NextIn;                                          _codec.NextIn = p;                                          writeAt = q;                                          return Flush(r);                                      }                                        n--;                                      b |= (_codec.InputBuffer[p++] & 0xff) << k;                                      k += 8;                                  }                                    b >>= t; k -= t;                                    j += (b & InternalInflateConstants.InflateMask[i]);                                    b >>= i; k -= i;                                    i = index;                                  t = table;                                  if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1))                                  {                                      blens = null;                                      mode = InflateBlockMode.BAD;                                      _codec.Message = "invalid bit length repeat";                                      r = ZlibConstants.Z_DATA_ERROR;                                        bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                                    c = (c == 16) ? blens[i-1] : 0;                                  do                                  {                                      blens[i++] = c;                                  }                                  while (--j != 0);                                  index = i;                              }                          }                            tb[0] = -1;                          {                              int[] bl = new int[] { 9 };  // must be <= 9 for lookahead assumptions                              int[] bd = new int[] { 6 }; // must be <= 9 for lookahead assumptions                              int[] tl = new int[1];                              int[] td = new int[1];                                t = table;                              t = inftree.inflate_trees_dynamic(257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' _codec);                                if (t != ZlibConstants.Z_OK)                              {                                  if (t == ZlibConstants.Z_DATA_ERROR)                                  {                                      blens = null;                                      mode = InflateBlockMode.BAD;                                  }                                  r = t;                                    bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                              codes.Init(bl[0]' bd[0]' hufts' tl[0]' hufts' td[0]);                          }                          mode = InflateBlockMode.CODES;                          goto case InflateBlockMode.CODES;                        case InflateBlockMode.CODES:                          bitb = b; bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                            r = codes.Process(this' r);                          if (r != ZlibConstants.Z_STREAM_END)                          {                              return Flush(r);                          }                            r = ZlibConstants.Z_OK;                          p = _codec.NextIn;                          n = _codec.AvailableBytesIn;                          b = bitb;                          k = bitk;                          q = writeAt;                          m = (int)(q < readAt ? readAt - q - 1 : end - q);                            if (last == 0)                          {                              mode = InflateBlockMode.TYPE;                              break;                          }                          mode = InflateBlockMode.DRY;                          goto case InflateBlockMode.DRY;                        case InflateBlockMode.DRY:                          writeAt = q;                          r = Flush(r);                          q = writeAt; m = (int)(q < readAt ? readAt - q - 1 : end - q);                          if (readAt != writeAt)                          {                              bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                          mode = InflateBlockMode.DONE;                          goto case InflateBlockMode.DONE;                        case InflateBlockMode.DONE:                          r = ZlibConstants.Z_STREAM_END;                          bitb = b;                          bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                          return Flush(r);                        case InflateBlockMode.BAD:                          r = ZlibConstants.Z_DATA_ERROR;                            bitb = b; bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                          return Flush(r);                          default:                          r = ZlibConstants.Z_STREAM_ERROR;                            bitb = b; bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                          return Flush(r);                  }
Magic Number,Ionic.Zlib,InflateBlocks,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zlib.Shared\Inflate.cs,Process,The following statement contains a magic number: switch (mode)                  {                      case InflateBlockMode.TYPE:                            while (k < (3))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                                n--;                              b |= (_codec.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                          t = (int)(b & 7);                          last = t & 1;                            switch ((uint)t >> 1)                          {                              case 0:  // stored                                  b >>= 3; k -= (3);                                  t = k & 7; // go to byte boundary                                  b >>= t; k -= t;                                  mode = InflateBlockMode.LENS; // get length of stored block                                  break;                                case 1:  // fixed                                  int[] bl = new int[1];                                  int[] bd = new int[1];                                  int[][] tl = new int[1][];                                  int[][] td = new int[1][];                                  InfTree.inflate_trees_fixed(bl' bd' tl' td' _codec);                                  codes.Init(bl[0]' bd[0]' tl[0]' 0' td[0]' 0);                                  b >>= 3; k -= 3;                                  mode = InflateBlockMode.CODES;                                  break;                                case 2:  // dynamic                                  b >>= 3; k -= 3;                                  mode = InflateBlockMode.TABLE;                                  break;                                case 3:  // illegal                                  b >>= 3; k -= 3;                                  mode = InflateBlockMode.BAD;                                  _codec.Message = "invalid block type";                                  r = ZlibConstants.Z_DATA_ERROR;                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                          }                          break;                        case InflateBlockMode.LENS:                            while (k < (32))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                              ;                              n--;                              b |= (_codec.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            if ( ( ((~b)>>16) & 0xffff) != (b & 0xffff))                          {                              mode = InflateBlockMode.BAD;                              _codec.Message = "invalid stored block lengths";                              r = ZlibConstants.Z_DATA_ERROR;                                bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                          left = (b & 0xffff);                          b = k = 0; // dump bits                          mode = left != 0 ? InflateBlockMode.STORED : (last != 0 ? InflateBlockMode.DRY : InflateBlockMode.TYPE);                          break;                        case InflateBlockMode.STORED:                          if (n == 0)                          {                              bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                            if (m == 0)                          {                              if (q == end && readAt != 0)                              {                                  q = 0; m = (int)(q < readAt ? readAt - q - 1 : end - q);                              }                              if (m == 0)                              {                                  writeAt = q;                                  r = Flush(r);                                  q = writeAt; m = (int)(q < readAt ? readAt - q - 1 : end - q);                                  if (q == end && readAt != 0)                                  {                                      q = 0; m = (int)(q < readAt ? readAt - q - 1 : end - q);                                  }                                  if (m == 0)                                  {                                      bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                              }                          }                          r = ZlibConstants.Z_OK;                            t = left;                          if (t > n)                              t = n;                          if (t > m)                              t = m;                          Array.Copy(_codec.InputBuffer' p' window' q' t);                          p += t; n -= t;                          q += t; m -= t;                          if ((left -= t) != 0)                              break;                          mode = last != 0 ? InflateBlockMode.DRY : InflateBlockMode.TYPE;                          break;                        case InflateBlockMode.TABLE:                            while (k < (14))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                                n--;                              b |= (_codec.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            table = t = (b & 0x3fff);                          if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29)                          {                              mode = InflateBlockMode.BAD;                              _codec.Message = "too many length or distance symbols";                              r = ZlibConstants.Z_DATA_ERROR;                                bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                          t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);                          if (blens == null || blens.Length < t)                          {                              blens = new int[t];                          }                          else                          {                              Array.Clear(blens' 0' t);                              // for (int i = 0; i < t; i++)                              // {                              //     blens[i] = 0;                              // }                          }                            b >>= 14;                          k -= 14;                              index = 0;                          mode = InflateBlockMode.BTREE;                          goto case InflateBlockMode.BTREE;                        case InflateBlockMode.BTREE:                          while (index < 4 + (table >> 10))                          {                              while (k < (3))                              {                                  if (n != 0)                                  {                                      r = ZlibConstants.Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                                    n--;                                  b |= (_codec.InputBuffer[p++] & 0xff) << k;                                  k += 8;                              }                                blens[border[index++]] = b & 7;                                b >>= 3; k -= 3;                          }                            while (index < 19)                          {                              blens[border[index++]] = 0;                          }                            bb[0] = 7;                          t = inftree.inflate_trees_bits(blens' bb' tb' hufts' _codec);                          if (t != ZlibConstants.Z_OK)                          {                              r = t;                              if (r == ZlibConstants.Z_DATA_ERROR)                              {                                  blens = null;                                  mode = InflateBlockMode.BAD;                              }                                bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                            index = 0;                          mode = InflateBlockMode.DTREE;                          goto case InflateBlockMode.DTREE;                        case InflateBlockMode.DTREE:                          while (true)                          {                              t = table;                              if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)))                              {                                  break;                              }                                int i' j' c;                                t = bb[0];                                while (k < t)                              {                                  if (n != 0)                                  {                                      r = ZlibConstants.Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                                    n--;                                  b |= (_codec.InputBuffer[p++] & 0xff) << k;                                  k += 8;                              }                                t = hufts[(tb[0] + (b & InternalInflateConstants.InflateMask[t])) * 3 + 1];                              c = hufts[(tb[0] + (b & InternalInflateConstants.InflateMask[t])) * 3 + 2];                                if (c < 16)                              {                                  b >>= t; k -= t;                                  blens[index++] = c;                              }                              else                              {                                  // c == 16..18                                  i = c == 18 ? 7 : c - 14;                                  j = c == 18 ? 11 : 3;                                    while (k < (t + i))                                  {                                      if (n != 0)                                      {                                          r = ZlibConstants.Z_OK;                                      }                                      else                                      {                                          bitb = b; bitk = k;                                          _codec.AvailableBytesIn = n;                                          _codec.TotalBytesIn += p - _codec.NextIn;                                          _codec.NextIn = p;                                          writeAt = q;                                          return Flush(r);                                      }                                        n--;                                      b |= (_codec.InputBuffer[p++] & 0xff) << k;                                      k += 8;                                  }                                    b >>= t; k -= t;                                    j += (b & InternalInflateConstants.InflateMask[i]);                                    b >>= i; k -= i;                                    i = index;                                  t = table;                                  if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1))                                  {                                      blens = null;                                      mode = InflateBlockMode.BAD;                                      _codec.Message = "invalid bit length repeat";                                      r = ZlibConstants.Z_DATA_ERROR;                                        bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                                    c = (c == 16) ? blens[i-1] : 0;                                  do                                  {                                      blens[i++] = c;                                  }                                  while (--j != 0);                                  index = i;                              }                          }                            tb[0] = -1;                          {                              int[] bl = new int[] { 9 };  // must be <= 9 for lookahead assumptions                              int[] bd = new int[] { 6 }; // must be <= 9 for lookahead assumptions                              int[] tl = new int[1];                              int[] td = new int[1];                                t = table;                              t = inftree.inflate_trees_dynamic(257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' _codec);                                if (t != ZlibConstants.Z_OK)                              {                                  if (t == ZlibConstants.Z_DATA_ERROR)                                  {                                      blens = null;                                      mode = InflateBlockMode.BAD;                                  }                                  r = t;                                    bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                              codes.Init(bl[0]' bd[0]' hufts' tl[0]' hufts' td[0]);                          }                          mode = InflateBlockMode.CODES;                          goto case InflateBlockMode.CODES;                        case InflateBlockMode.CODES:                          bitb = b; bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                            r = codes.Process(this' r);                          if (r != ZlibConstants.Z_STREAM_END)                          {                              return Flush(r);                          }                            r = ZlibConstants.Z_OK;                          p = _codec.NextIn;                          n = _codec.AvailableBytesIn;                          b = bitb;                          k = bitk;                          q = writeAt;                          m = (int)(q < readAt ? readAt - q - 1 : end - q);                            if (last == 0)                          {                              mode = InflateBlockMode.TYPE;                              break;                          }                          mode = InflateBlockMode.DRY;                          goto case InflateBlockMode.DRY;                        case InflateBlockMode.DRY:                          writeAt = q;                          r = Flush(r);                          q = writeAt; m = (int)(q < readAt ? readAt - q - 1 : end - q);                          if (readAt != writeAt)                          {                              bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                          mode = InflateBlockMode.DONE;                          goto case InflateBlockMode.DONE;                        case InflateBlockMode.DONE:                          r = ZlibConstants.Z_STREAM_END;                          bitb = b;                          bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                          return Flush(r);                        case InflateBlockMode.BAD:                          r = ZlibConstants.Z_DATA_ERROR;                            bitb = b; bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                          return Flush(r);                          default:                          r = ZlibConstants.Z_STREAM_ERROR;                            bitb = b; bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                          return Flush(r);                  }
Magic Number,Ionic.Zlib,InflateBlocks,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zlib.Shared\Inflate.cs,Process,The following statement contains a magic number: switch (mode)                  {                      case InflateBlockMode.TYPE:                            while (k < (3))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                                n--;                              b |= (_codec.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                          t = (int)(b & 7);                          last = t & 1;                            switch ((uint)t >> 1)                          {                              case 0:  // stored                                  b >>= 3; k -= (3);                                  t = k & 7; // go to byte boundary                                  b >>= t; k -= t;                                  mode = InflateBlockMode.LENS; // get length of stored block                                  break;                                case 1:  // fixed                                  int[] bl = new int[1];                                  int[] bd = new int[1];                                  int[][] tl = new int[1][];                                  int[][] td = new int[1][];                                  InfTree.inflate_trees_fixed(bl' bd' tl' td' _codec);                                  codes.Init(bl[0]' bd[0]' tl[0]' 0' td[0]' 0);                                  b >>= 3; k -= 3;                                  mode = InflateBlockMode.CODES;                                  break;                                case 2:  // dynamic                                  b >>= 3; k -= 3;                                  mode = InflateBlockMode.TABLE;                                  break;                                case 3:  // illegal                                  b >>= 3; k -= 3;                                  mode = InflateBlockMode.BAD;                                  _codec.Message = "invalid block type";                                  r = ZlibConstants.Z_DATA_ERROR;                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                          }                          break;                        case InflateBlockMode.LENS:                            while (k < (32))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                              ;                              n--;                              b |= (_codec.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            if ( ( ((~b)>>16) & 0xffff) != (b & 0xffff))                          {                              mode = InflateBlockMode.BAD;                              _codec.Message = "invalid stored block lengths";                              r = ZlibConstants.Z_DATA_ERROR;                                bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                          left = (b & 0xffff);                          b = k = 0; // dump bits                          mode = left != 0 ? InflateBlockMode.STORED : (last != 0 ? InflateBlockMode.DRY : InflateBlockMode.TYPE);                          break;                        case InflateBlockMode.STORED:                          if (n == 0)                          {                              bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                            if (m == 0)                          {                              if (q == end && readAt != 0)                              {                                  q = 0; m = (int)(q < readAt ? readAt - q - 1 : end - q);                              }                              if (m == 0)                              {                                  writeAt = q;                                  r = Flush(r);                                  q = writeAt; m = (int)(q < readAt ? readAt - q - 1 : end - q);                                  if (q == end && readAt != 0)                                  {                                      q = 0; m = (int)(q < readAt ? readAt - q - 1 : end - q);                                  }                                  if (m == 0)                                  {                                      bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                              }                          }                          r = ZlibConstants.Z_OK;                            t = left;                          if (t > n)                              t = n;                          if (t > m)                              t = m;                          Array.Copy(_codec.InputBuffer' p' window' q' t);                          p += t; n -= t;                          q += t; m -= t;                          if ((left -= t) != 0)                              break;                          mode = last != 0 ? InflateBlockMode.DRY : InflateBlockMode.TYPE;                          break;                        case InflateBlockMode.TABLE:                            while (k < (14))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                                n--;                              b |= (_codec.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            table = t = (b & 0x3fff);                          if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29)                          {                              mode = InflateBlockMode.BAD;                              _codec.Message = "too many length or distance symbols";                              r = ZlibConstants.Z_DATA_ERROR;                                bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                          t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);                          if (blens == null || blens.Length < t)                          {                              blens = new int[t];                          }                          else                          {                              Array.Clear(blens' 0' t);                              // for (int i = 0; i < t; i++)                              // {                              //     blens[i] = 0;                              // }                          }                            b >>= 14;                          k -= 14;                              index = 0;                          mode = InflateBlockMode.BTREE;                          goto case InflateBlockMode.BTREE;                        case InflateBlockMode.BTREE:                          while (index < 4 + (table >> 10))                          {                              while (k < (3))                              {                                  if (n != 0)                                  {                                      r = ZlibConstants.Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                                    n--;                                  b |= (_codec.InputBuffer[p++] & 0xff) << k;                                  k += 8;                              }                                blens[border[index++]] = b & 7;                                b >>= 3; k -= 3;                          }                            while (index < 19)                          {                              blens[border[index++]] = 0;                          }                            bb[0] = 7;                          t = inftree.inflate_trees_bits(blens' bb' tb' hufts' _codec);                          if (t != ZlibConstants.Z_OK)                          {                              r = t;                              if (r == ZlibConstants.Z_DATA_ERROR)                              {                                  blens = null;                                  mode = InflateBlockMode.BAD;                              }                                bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                            index = 0;                          mode = InflateBlockMode.DTREE;                          goto case InflateBlockMode.DTREE;                        case InflateBlockMode.DTREE:                          while (true)                          {                              t = table;                              if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)))                              {                                  break;                              }                                int i' j' c;                                t = bb[0];                                while (k < t)                              {                                  if (n != 0)                                  {                                      r = ZlibConstants.Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                                    n--;                                  b |= (_codec.InputBuffer[p++] & 0xff) << k;                                  k += 8;                              }                                t = hufts[(tb[0] + (b & InternalInflateConstants.InflateMask[t])) * 3 + 1];                              c = hufts[(tb[0] + (b & InternalInflateConstants.InflateMask[t])) * 3 + 2];                                if (c < 16)                              {                                  b >>= t; k -= t;                                  blens[index++] = c;                              }                              else                              {                                  // c == 16..18                                  i = c == 18 ? 7 : c - 14;                                  j = c == 18 ? 11 : 3;                                    while (k < (t + i))                                  {                                      if (n != 0)                                      {                                          r = ZlibConstants.Z_OK;                                      }                                      else                                      {                                          bitb = b; bitk = k;                                          _codec.AvailableBytesIn = n;                                          _codec.TotalBytesIn += p - _codec.NextIn;                                          _codec.NextIn = p;                                          writeAt = q;                                          return Flush(r);                                      }                                        n--;                                      b |= (_codec.InputBuffer[p++] & 0xff) << k;                                      k += 8;                                  }                                    b >>= t; k -= t;                                    j += (b & InternalInflateConstants.InflateMask[i]);                                    b >>= i; k -= i;                                    i = index;                                  t = table;                                  if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1))                                  {                                      blens = null;                                      mode = InflateBlockMode.BAD;                                      _codec.Message = "invalid bit length repeat";                                      r = ZlibConstants.Z_DATA_ERROR;                                        bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                                    c = (c == 16) ? blens[i-1] : 0;                                  do                                  {                                      blens[i++] = c;                                  }                                  while (--j != 0);                                  index = i;                              }                          }                            tb[0] = -1;                          {                              int[] bl = new int[] { 9 };  // must be <= 9 for lookahead assumptions                              int[] bd = new int[] { 6 }; // must be <= 9 for lookahead assumptions                              int[] tl = new int[1];                              int[] td = new int[1];                                t = table;                              t = inftree.inflate_trees_dynamic(257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' _codec);                                if (t != ZlibConstants.Z_OK)                              {                                  if (t == ZlibConstants.Z_DATA_ERROR)                                  {                                      blens = null;                                      mode = InflateBlockMode.BAD;                                  }                                  r = t;                                    bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                              codes.Init(bl[0]' bd[0]' hufts' tl[0]' hufts' td[0]);                          }                          mode = InflateBlockMode.CODES;                          goto case InflateBlockMode.CODES;                        case InflateBlockMode.CODES:                          bitb = b; bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                            r = codes.Process(this' r);                          if (r != ZlibConstants.Z_STREAM_END)                          {                              return Flush(r);                          }                            r = ZlibConstants.Z_OK;                          p = _codec.NextIn;                          n = _codec.AvailableBytesIn;                          b = bitb;                          k = bitk;                          q = writeAt;                          m = (int)(q < readAt ? readAt - q - 1 : end - q);                            if (last == 0)                          {                              mode = InflateBlockMode.TYPE;                              break;                          }                          mode = InflateBlockMode.DRY;                          goto case InflateBlockMode.DRY;                        case InflateBlockMode.DRY:                          writeAt = q;                          r = Flush(r);                          q = writeAt; m = (int)(q < readAt ? readAt - q - 1 : end - q);                          if (readAt != writeAt)                          {                              bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                          mode = InflateBlockMode.DONE;                          goto case InflateBlockMode.DONE;                        case InflateBlockMode.DONE:                          r = ZlibConstants.Z_STREAM_END;                          bitb = b;                          bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                          return Flush(r);                        case InflateBlockMode.BAD:                          r = ZlibConstants.Z_DATA_ERROR;                            bitb = b; bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                          return Flush(r);                          default:                          r = ZlibConstants.Z_STREAM_ERROR;                            bitb = b; bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                          return Flush(r);                  }
Magic Number,Ionic.Zlib,InflateBlocks,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zlib.Shared\Inflate.cs,Process,The following statement contains a magic number: switch (mode)                  {                      case InflateBlockMode.TYPE:                            while (k < (3))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                                n--;                              b |= (_codec.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                          t = (int)(b & 7);                          last = t & 1;                            switch ((uint)t >> 1)                          {                              case 0:  // stored                                  b >>= 3; k -= (3);                                  t = k & 7; // go to byte boundary                                  b >>= t; k -= t;                                  mode = InflateBlockMode.LENS; // get length of stored block                                  break;                                case 1:  // fixed                                  int[] bl = new int[1];                                  int[] bd = new int[1];                                  int[][] tl = new int[1][];                                  int[][] td = new int[1][];                                  InfTree.inflate_trees_fixed(bl' bd' tl' td' _codec);                                  codes.Init(bl[0]' bd[0]' tl[0]' 0' td[0]' 0);                                  b >>= 3; k -= 3;                                  mode = InflateBlockMode.CODES;                                  break;                                case 2:  // dynamic                                  b >>= 3; k -= 3;                                  mode = InflateBlockMode.TABLE;                                  break;                                case 3:  // illegal                                  b >>= 3; k -= 3;                                  mode = InflateBlockMode.BAD;                                  _codec.Message = "invalid block type";                                  r = ZlibConstants.Z_DATA_ERROR;                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                          }                          break;                        case InflateBlockMode.LENS:                            while (k < (32))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                              ;                              n--;                              b |= (_codec.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            if ( ( ((~b)>>16) & 0xffff) != (b & 0xffff))                          {                              mode = InflateBlockMode.BAD;                              _codec.Message = "invalid stored block lengths";                              r = ZlibConstants.Z_DATA_ERROR;                                bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                          left = (b & 0xffff);                          b = k = 0; // dump bits                          mode = left != 0 ? InflateBlockMode.STORED : (last != 0 ? InflateBlockMode.DRY : InflateBlockMode.TYPE);                          break;                        case InflateBlockMode.STORED:                          if (n == 0)                          {                              bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                            if (m == 0)                          {                              if (q == end && readAt != 0)                              {                                  q = 0; m = (int)(q < readAt ? readAt - q - 1 : end - q);                              }                              if (m == 0)                              {                                  writeAt = q;                                  r = Flush(r);                                  q = writeAt; m = (int)(q < readAt ? readAt - q - 1 : end - q);                                  if (q == end && readAt != 0)                                  {                                      q = 0; m = (int)(q < readAt ? readAt - q - 1 : end - q);                                  }                                  if (m == 0)                                  {                                      bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                              }                          }                          r = ZlibConstants.Z_OK;                            t = left;                          if (t > n)                              t = n;                          if (t > m)                              t = m;                          Array.Copy(_codec.InputBuffer' p' window' q' t);                          p += t; n -= t;                          q += t; m -= t;                          if ((left -= t) != 0)                              break;                          mode = last != 0 ? InflateBlockMode.DRY : InflateBlockMode.TYPE;                          break;                        case InflateBlockMode.TABLE:                            while (k < (14))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                                n--;                              b |= (_codec.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            table = t = (b & 0x3fff);                          if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29)                          {                              mode = InflateBlockMode.BAD;                              _codec.Message = "too many length or distance symbols";                              r = ZlibConstants.Z_DATA_ERROR;                                bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                          t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);                          if (blens == null || blens.Length < t)                          {                              blens = new int[t];                          }                          else                          {                              Array.Clear(blens' 0' t);                              // for (int i = 0; i < t; i++)                              // {                              //     blens[i] = 0;                              // }                          }                            b >>= 14;                          k -= 14;                              index = 0;                          mode = InflateBlockMode.BTREE;                          goto case InflateBlockMode.BTREE;                        case InflateBlockMode.BTREE:                          while (index < 4 + (table >> 10))                          {                              while (k < (3))                              {                                  if (n != 0)                                  {                                      r = ZlibConstants.Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                                    n--;                                  b |= (_codec.InputBuffer[p++] & 0xff) << k;                                  k += 8;                              }                                blens[border[index++]] = b & 7;                                b >>= 3; k -= 3;                          }                            while (index < 19)                          {                              blens[border[index++]] = 0;                          }                            bb[0] = 7;                          t = inftree.inflate_trees_bits(blens' bb' tb' hufts' _codec);                          if (t != ZlibConstants.Z_OK)                          {                              r = t;                              if (r == ZlibConstants.Z_DATA_ERROR)                              {                                  blens = null;                                  mode = InflateBlockMode.BAD;                              }                                bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                            index = 0;                          mode = InflateBlockMode.DTREE;                          goto case InflateBlockMode.DTREE;                        case InflateBlockMode.DTREE:                          while (true)                          {                              t = table;                              if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)))                              {                                  break;                              }                                int i' j' c;                                t = bb[0];                                while (k < t)                              {                                  if (n != 0)                                  {                                      r = ZlibConstants.Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                                    n--;                                  b |= (_codec.InputBuffer[p++] & 0xff) << k;                                  k += 8;                              }                                t = hufts[(tb[0] + (b & InternalInflateConstants.InflateMask[t])) * 3 + 1];                              c = hufts[(tb[0] + (b & InternalInflateConstants.InflateMask[t])) * 3 + 2];                                if (c < 16)                              {                                  b >>= t; k -= t;                                  blens[index++] = c;                              }                              else                              {                                  // c == 16..18                                  i = c == 18 ? 7 : c - 14;                                  j = c == 18 ? 11 : 3;                                    while (k < (t + i))                                  {                                      if (n != 0)                                      {                                          r = ZlibConstants.Z_OK;                                      }                                      else                                      {                                          bitb = b; bitk = k;                                          _codec.AvailableBytesIn = n;                                          _codec.TotalBytesIn += p - _codec.NextIn;                                          _codec.NextIn = p;                                          writeAt = q;                                          return Flush(r);                                      }                                        n--;                                      b |= (_codec.InputBuffer[p++] & 0xff) << k;                                      k += 8;                                  }                                    b >>= t; k -= t;                                    j += (b & InternalInflateConstants.InflateMask[i]);                                    b >>= i; k -= i;                                    i = index;                                  t = table;                                  if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1))                                  {                                      blens = null;                                      mode = InflateBlockMode.BAD;                                      _codec.Message = "invalid bit length repeat";                                      r = ZlibConstants.Z_DATA_ERROR;                                        bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                                    c = (c == 16) ? blens[i-1] : 0;                                  do                                  {                                      blens[i++] = c;                                  }                                  while (--j != 0);                                  index = i;                              }                          }                            tb[0] = -1;                          {                              int[] bl = new int[] { 9 };  // must be <= 9 for lookahead assumptions                              int[] bd = new int[] { 6 }; // must be <= 9 for lookahead assumptions                              int[] tl = new int[1];                              int[] td = new int[1];                                t = table;                              t = inftree.inflate_trees_dynamic(257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' _codec);                                if (t != ZlibConstants.Z_OK)                              {                                  if (t == ZlibConstants.Z_DATA_ERROR)                                  {                                      blens = null;                                      mode = InflateBlockMode.BAD;                                  }                                  r = t;                                    bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                              codes.Init(bl[0]' bd[0]' hufts' tl[0]' hufts' td[0]);                          }                          mode = InflateBlockMode.CODES;                          goto case InflateBlockMode.CODES;                        case InflateBlockMode.CODES:                          bitb = b; bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                            r = codes.Process(this' r);                          if (r != ZlibConstants.Z_STREAM_END)                          {                              return Flush(r);                          }                            r = ZlibConstants.Z_OK;                          p = _codec.NextIn;                          n = _codec.AvailableBytesIn;                          b = bitb;                          k = bitk;                          q = writeAt;                          m = (int)(q < readAt ? readAt - q - 1 : end - q);                            if (last == 0)                          {                              mode = InflateBlockMode.TYPE;                              break;                          }                          mode = InflateBlockMode.DRY;                          goto case InflateBlockMode.DRY;                        case InflateBlockMode.DRY:                          writeAt = q;                          r = Flush(r);                          q = writeAt; m = (int)(q < readAt ? readAt - q - 1 : end - q);                          if (readAt != writeAt)                          {                              bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                          mode = InflateBlockMode.DONE;                          goto case InflateBlockMode.DONE;                        case InflateBlockMode.DONE:                          r = ZlibConstants.Z_STREAM_END;                          bitb = b;                          bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                          return Flush(r);                        case InflateBlockMode.BAD:                          r = ZlibConstants.Z_DATA_ERROR;                            bitb = b; bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                          return Flush(r);                          default:                          r = ZlibConstants.Z_STREAM_ERROR;                            bitb = b; bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                          return Flush(r);                  }
Magic Number,Ionic.Zlib,InflateBlocks,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zlib.Shared\Inflate.cs,Process,The following statement contains a magic number: switch (mode)                  {                      case InflateBlockMode.TYPE:                            while (k < (3))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                                n--;                              b |= (_codec.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                          t = (int)(b & 7);                          last = t & 1;                            switch ((uint)t >> 1)                          {                              case 0:  // stored                                  b >>= 3; k -= (3);                                  t = k & 7; // go to byte boundary                                  b >>= t; k -= t;                                  mode = InflateBlockMode.LENS; // get length of stored block                                  break;                                case 1:  // fixed                                  int[] bl = new int[1];                                  int[] bd = new int[1];                                  int[][] tl = new int[1][];                                  int[][] td = new int[1][];                                  InfTree.inflate_trees_fixed(bl' bd' tl' td' _codec);                                  codes.Init(bl[0]' bd[0]' tl[0]' 0' td[0]' 0);                                  b >>= 3; k -= 3;                                  mode = InflateBlockMode.CODES;                                  break;                                case 2:  // dynamic                                  b >>= 3; k -= 3;                                  mode = InflateBlockMode.TABLE;                                  break;                                case 3:  // illegal                                  b >>= 3; k -= 3;                                  mode = InflateBlockMode.BAD;                                  _codec.Message = "invalid block type";                                  r = ZlibConstants.Z_DATA_ERROR;                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                          }                          break;                        case InflateBlockMode.LENS:                            while (k < (32))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                              ;                              n--;                              b |= (_codec.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            if ( ( ((~b)>>16) & 0xffff) != (b & 0xffff))                          {                              mode = InflateBlockMode.BAD;                              _codec.Message = "invalid stored block lengths";                              r = ZlibConstants.Z_DATA_ERROR;                                bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                          left = (b & 0xffff);                          b = k = 0; // dump bits                          mode = left != 0 ? InflateBlockMode.STORED : (last != 0 ? InflateBlockMode.DRY : InflateBlockMode.TYPE);                          break;                        case InflateBlockMode.STORED:                          if (n == 0)                          {                              bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                            if (m == 0)                          {                              if (q == end && readAt != 0)                              {                                  q = 0; m = (int)(q < readAt ? readAt - q - 1 : end - q);                              }                              if (m == 0)                              {                                  writeAt = q;                                  r = Flush(r);                                  q = writeAt; m = (int)(q < readAt ? readAt - q - 1 : end - q);                                  if (q == end && readAt != 0)                                  {                                      q = 0; m = (int)(q < readAt ? readAt - q - 1 : end - q);                                  }                                  if (m == 0)                                  {                                      bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                              }                          }                          r = ZlibConstants.Z_OK;                            t = left;                          if (t > n)                              t = n;                          if (t > m)                              t = m;                          Array.Copy(_codec.InputBuffer' p' window' q' t);                          p += t; n -= t;                          q += t; m -= t;                          if ((left -= t) != 0)                              break;                          mode = last != 0 ? InflateBlockMode.DRY : InflateBlockMode.TYPE;                          break;                        case InflateBlockMode.TABLE:                            while (k < (14))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                                n--;                              b |= (_codec.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            table = t = (b & 0x3fff);                          if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29)                          {                              mode = InflateBlockMode.BAD;                              _codec.Message = "too many length or distance symbols";                              r = ZlibConstants.Z_DATA_ERROR;                                bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                          t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);                          if (blens == null || blens.Length < t)                          {                              blens = new int[t];                          }                          else                          {                              Array.Clear(blens' 0' t);                              // for (int i = 0; i < t; i++)                              // {                              //     blens[i] = 0;                              // }                          }                            b >>= 14;                          k -= 14;                              index = 0;                          mode = InflateBlockMode.BTREE;                          goto case InflateBlockMode.BTREE;                        case InflateBlockMode.BTREE:                          while (index < 4 + (table >> 10))                          {                              while (k < (3))                              {                                  if (n != 0)                                  {                                      r = ZlibConstants.Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                                    n--;                                  b |= (_codec.InputBuffer[p++] & 0xff) << k;                                  k += 8;                              }                                blens[border[index++]] = b & 7;                                b >>= 3; k -= 3;                          }                            while (index < 19)                          {                              blens[border[index++]] = 0;                          }                            bb[0] = 7;                          t = inftree.inflate_trees_bits(blens' bb' tb' hufts' _codec);                          if (t != ZlibConstants.Z_OK)                          {                              r = t;                              if (r == ZlibConstants.Z_DATA_ERROR)                              {                                  blens = null;                                  mode = InflateBlockMode.BAD;                              }                                bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                            index = 0;                          mode = InflateBlockMode.DTREE;                          goto case InflateBlockMode.DTREE;                        case InflateBlockMode.DTREE:                          while (true)                          {                              t = table;                              if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)))                              {                                  break;                              }                                int i' j' c;                                t = bb[0];                                while (k < t)                              {                                  if (n != 0)                                  {                                      r = ZlibConstants.Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                                    n--;                                  b |= (_codec.InputBuffer[p++] & 0xff) << k;                                  k += 8;                              }                                t = hufts[(tb[0] + (b & InternalInflateConstants.InflateMask[t])) * 3 + 1];                              c = hufts[(tb[0] + (b & InternalInflateConstants.InflateMask[t])) * 3 + 2];                                if (c < 16)                              {                                  b >>= t; k -= t;                                  blens[index++] = c;                              }                              else                              {                                  // c == 16..18                                  i = c == 18 ? 7 : c - 14;                                  j = c == 18 ? 11 : 3;                                    while (k < (t + i))                                  {                                      if (n != 0)                                      {                                          r = ZlibConstants.Z_OK;                                      }                                      else                                      {                                          bitb = b; bitk = k;                                          _codec.AvailableBytesIn = n;                                          _codec.TotalBytesIn += p - _codec.NextIn;                                          _codec.NextIn = p;                                          writeAt = q;                                          return Flush(r);                                      }                                        n--;                                      b |= (_codec.InputBuffer[p++] & 0xff) << k;                                      k += 8;                                  }                                    b >>= t; k -= t;                                    j += (b & InternalInflateConstants.InflateMask[i]);                                    b >>= i; k -= i;                                    i = index;                                  t = table;                                  if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1))                                  {                                      blens = null;                                      mode = InflateBlockMode.BAD;                                      _codec.Message = "invalid bit length repeat";                                      r = ZlibConstants.Z_DATA_ERROR;                                        bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                                    c = (c == 16) ? blens[i-1] : 0;                                  do                                  {                                      blens[i++] = c;                                  }                                  while (--j != 0);                                  index = i;                              }                          }                            tb[0] = -1;                          {                              int[] bl = new int[] { 9 };  // must be <= 9 for lookahead assumptions                              int[] bd = new int[] { 6 }; // must be <= 9 for lookahead assumptions                              int[] tl = new int[1];                              int[] td = new int[1];                                t = table;                              t = inftree.inflate_trees_dynamic(257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' _codec);                                if (t != ZlibConstants.Z_OK)                              {                                  if (t == ZlibConstants.Z_DATA_ERROR)                                  {                                      blens = null;                                      mode = InflateBlockMode.BAD;                                  }                                  r = t;                                    bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                              codes.Init(bl[0]' bd[0]' hufts' tl[0]' hufts' td[0]);                          }                          mode = InflateBlockMode.CODES;                          goto case InflateBlockMode.CODES;                        case InflateBlockMode.CODES:                          bitb = b; bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                            r = codes.Process(this' r);                          if (r != ZlibConstants.Z_STREAM_END)                          {                              return Flush(r);                          }                            r = ZlibConstants.Z_OK;                          p = _codec.NextIn;                          n = _codec.AvailableBytesIn;                          b = bitb;                          k = bitk;                          q = writeAt;                          m = (int)(q < readAt ? readAt - q - 1 : end - q);                            if (last == 0)                          {                              mode = InflateBlockMode.TYPE;                              break;                          }                          mode = InflateBlockMode.DRY;                          goto case InflateBlockMode.DRY;                        case InflateBlockMode.DRY:                          writeAt = q;                          r = Flush(r);                          q = writeAt; m = (int)(q < readAt ? readAt - q - 1 : end - q);                          if (readAt != writeAt)                          {                              bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                          mode = InflateBlockMode.DONE;                          goto case InflateBlockMode.DONE;                        case InflateBlockMode.DONE:                          r = ZlibConstants.Z_STREAM_END;                          bitb = b;                          bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                          return Flush(r);                        case InflateBlockMode.BAD:                          r = ZlibConstants.Z_DATA_ERROR;                            bitb = b; bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                          return Flush(r);                          default:                          r = ZlibConstants.Z_STREAM_ERROR;                            bitb = b; bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                          return Flush(r);                  }
Magic Number,Ionic.Zlib,InflateBlocks,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zlib.Shared\Inflate.cs,Process,The following statement contains a magic number: switch (mode)                  {                      case InflateBlockMode.TYPE:                            while (k < (3))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                                n--;                              b |= (_codec.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                          t = (int)(b & 7);                          last = t & 1;                            switch ((uint)t >> 1)                          {                              case 0:  // stored                                  b >>= 3; k -= (3);                                  t = k & 7; // go to byte boundary                                  b >>= t; k -= t;                                  mode = InflateBlockMode.LENS; // get length of stored block                                  break;                                case 1:  // fixed                                  int[] bl = new int[1];                                  int[] bd = new int[1];                                  int[][] tl = new int[1][];                                  int[][] td = new int[1][];                                  InfTree.inflate_trees_fixed(bl' bd' tl' td' _codec);                                  codes.Init(bl[0]' bd[0]' tl[0]' 0' td[0]' 0);                                  b >>= 3; k -= 3;                                  mode = InflateBlockMode.CODES;                                  break;                                case 2:  // dynamic                                  b >>= 3; k -= 3;                                  mode = InflateBlockMode.TABLE;                                  break;                                case 3:  // illegal                                  b >>= 3; k -= 3;                                  mode = InflateBlockMode.BAD;                                  _codec.Message = "invalid block type";                                  r = ZlibConstants.Z_DATA_ERROR;                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                          }                          break;                        case InflateBlockMode.LENS:                            while (k < (32))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                              ;                              n--;                              b |= (_codec.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            if ( ( ((~b)>>16) & 0xffff) != (b & 0xffff))                          {                              mode = InflateBlockMode.BAD;                              _codec.Message = "invalid stored block lengths";                              r = ZlibConstants.Z_DATA_ERROR;                                bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                          left = (b & 0xffff);                          b = k = 0; // dump bits                          mode = left != 0 ? InflateBlockMode.STORED : (last != 0 ? InflateBlockMode.DRY : InflateBlockMode.TYPE);                          break;                        case InflateBlockMode.STORED:                          if (n == 0)                          {                              bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                            if (m == 0)                          {                              if (q == end && readAt != 0)                              {                                  q = 0; m = (int)(q < readAt ? readAt - q - 1 : end - q);                              }                              if (m == 0)                              {                                  writeAt = q;                                  r = Flush(r);                                  q = writeAt; m = (int)(q < readAt ? readAt - q - 1 : end - q);                                  if (q == end && readAt != 0)                                  {                                      q = 0; m = (int)(q < readAt ? readAt - q - 1 : end - q);                                  }                                  if (m == 0)                                  {                                      bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                              }                          }                          r = ZlibConstants.Z_OK;                            t = left;                          if (t > n)                              t = n;                          if (t > m)                              t = m;                          Array.Copy(_codec.InputBuffer' p' window' q' t);                          p += t; n -= t;                          q += t; m -= t;                          if ((left -= t) != 0)                              break;                          mode = last != 0 ? InflateBlockMode.DRY : InflateBlockMode.TYPE;                          break;                        case InflateBlockMode.TABLE:                            while (k < (14))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                                n--;                              b |= (_codec.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            table = t = (b & 0x3fff);                          if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29)                          {                              mode = InflateBlockMode.BAD;                              _codec.Message = "too many length or distance symbols";                              r = ZlibConstants.Z_DATA_ERROR;                                bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                          t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);                          if (blens == null || blens.Length < t)                          {                              blens = new int[t];                          }                          else                          {                              Array.Clear(blens' 0' t);                              // for (int i = 0; i < t; i++)                              // {                              //     blens[i] = 0;                              // }                          }                            b >>= 14;                          k -= 14;                              index = 0;                          mode = InflateBlockMode.BTREE;                          goto case InflateBlockMode.BTREE;                        case InflateBlockMode.BTREE:                          while (index < 4 + (table >> 10))                          {                              while (k < (3))                              {                                  if (n != 0)                                  {                                      r = ZlibConstants.Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                                    n--;                                  b |= (_codec.InputBuffer[p++] & 0xff) << k;                                  k += 8;                              }                                blens[border[index++]] = b & 7;                                b >>= 3; k -= 3;                          }                            while (index < 19)                          {                              blens[border[index++]] = 0;                          }                            bb[0] = 7;                          t = inftree.inflate_trees_bits(blens' bb' tb' hufts' _codec);                          if (t != ZlibConstants.Z_OK)                          {                              r = t;                              if (r == ZlibConstants.Z_DATA_ERROR)                              {                                  blens = null;                                  mode = InflateBlockMode.BAD;                              }                                bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                            index = 0;                          mode = InflateBlockMode.DTREE;                          goto case InflateBlockMode.DTREE;                        case InflateBlockMode.DTREE:                          while (true)                          {                              t = table;                              if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)))                              {                                  break;                              }                                int i' j' c;                                t = bb[0];                                while (k < t)                              {                                  if (n != 0)                                  {                                      r = ZlibConstants.Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                                    n--;                                  b |= (_codec.InputBuffer[p++] & 0xff) << k;                                  k += 8;                              }                                t = hufts[(tb[0] + (b & InternalInflateConstants.InflateMask[t])) * 3 + 1];                              c = hufts[(tb[0] + (b & InternalInflateConstants.InflateMask[t])) * 3 + 2];                                if (c < 16)                              {                                  b >>= t; k -= t;                                  blens[index++] = c;                              }                              else                              {                                  // c == 16..18                                  i = c == 18 ? 7 : c - 14;                                  j = c == 18 ? 11 : 3;                                    while (k < (t + i))                                  {                                      if (n != 0)                                      {                                          r = ZlibConstants.Z_OK;                                      }                                      else                                      {                                          bitb = b; bitk = k;                                          _codec.AvailableBytesIn = n;                                          _codec.TotalBytesIn += p - _codec.NextIn;                                          _codec.NextIn = p;                                          writeAt = q;                                          return Flush(r);                                      }                                        n--;                                      b |= (_codec.InputBuffer[p++] & 0xff) << k;                                      k += 8;                                  }                                    b >>= t; k -= t;                                    j += (b & InternalInflateConstants.InflateMask[i]);                                    b >>= i; k -= i;                                    i = index;                                  t = table;                                  if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1))                                  {                                      blens = null;                                      mode = InflateBlockMode.BAD;                                      _codec.Message = "invalid bit length repeat";                                      r = ZlibConstants.Z_DATA_ERROR;                                        bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                                    c = (c == 16) ? blens[i-1] : 0;                                  do                                  {                                      blens[i++] = c;                                  }                                  while (--j != 0);                                  index = i;                              }                          }                            tb[0] = -1;                          {                              int[] bl = new int[] { 9 };  // must be <= 9 for lookahead assumptions                              int[] bd = new int[] { 6 }; // must be <= 9 for lookahead assumptions                              int[] tl = new int[1];                              int[] td = new int[1];                                t = table;                              t = inftree.inflate_trees_dynamic(257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' _codec);                                if (t != ZlibConstants.Z_OK)                              {                                  if (t == ZlibConstants.Z_DATA_ERROR)                                  {                                      blens = null;                                      mode = InflateBlockMode.BAD;                                  }                                  r = t;                                    bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                              codes.Init(bl[0]' bd[0]' hufts' tl[0]' hufts' td[0]);                          }                          mode = InflateBlockMode.CODES;                          goto case InflateBlockMode.CODES;                        case InflateBlockMode.CODES:                          bitb = b; bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                            r = codes.Process(this' r);                          if (r != ZlibConstants.Z_STREAM_END)                          {                              return Flush(r);                          }                            r = ZlibConstants.Z_OK;                          p = _codec.NextIn;                          n = _codec.AvailableBytesIn;                          b = bitb;                          k = bitk;                          q = writeAt;                          m = (int)(q < readAt ? readAt - q - 1 : end - q);                            if (last == 0)                          {                              mode = InflateBlockMode.TYPE;                              break;                          }                          mode = InflateBlockMode.DRY;                          goto case InflateBlockMode.DRY;                        case InflateBlockMode.DRY:                          writeAt = q;                          r = Flush(r);                          q = writeAt; m = (int)(q < readAt ? readAt - q - 1 : end - q);                          if (readAt != writeAt)                          {                              bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                          mode = InflateBlockMode.DONE;                          goto case InflateBlockMode.DONE;                        case InflateBlockMode.DONE:                          r = ZlibConstants.Z_STREAM_END;                          bitb = b;                          bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                          return Flush(r);                        case InflateBlockMode.BAD:                          r = ZlibConstants.Z_DATA_ERROR;                            bitb = b; bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                          return Flush(r);                          default:                          r = ZlibConstants.Z_STREAM_ERROR;                            bitb = b; bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                          return Flush(r);                  }
Magic Number,Ionic.Zlib,InflateBlocks,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zlib.Shared\Inflate.cs,Process,The following statement contains a magic number: switch (mode)                  {                      case InflateBlockMode.TYPE:                            while (k < (3))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                                n--;                              b |= (_codec.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                          t = (int)(b & 7);                          last = t & 1;                            switch ((uint)t >> 1)                          {                              case 0:  // stored                                  b >>= 3; k -= (3);                                  t = k & 7; // go to byte boundary                                  b >>= t; k -= t;                                  mode = InflateBlockMode.LENS; // get length of stored block                                  break;                                case 1:  // fixed                                  int[] bl = new int[1];                                  int[] bd = new int[1];                                  int[][] tl = new int[1][];                                  int[][] td = new int[1][];                                  InfTree.inflate_trees_fixed(bl' bd' tl' td' _codec);                                  codes.Init(bl[0]' bd[0]' tl[0]' 0' td[0]' 0);                                  b >>= 3; k -= 3;                                  mode = InflateBlockMode.CODES;                                  break;                                case 2:  // dynamic                                  b >>= 3; k -= 3;                                  mode = InflateBlockMode.TABLE;                                  break;                                case 3:  // illegal                                  b >>= 3; k -= 3;                                  mode = InflateBlockMode.BAD;                                  _codec.Message = "invalid block type";                                  r = ZlibConstants.Z_DATA_ERROR;                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                          }                          break;                        case InflateBlockMode.LENS:                            while (k < (32))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                              ;                              n--;                              b |= (_codec.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            if ( ( ((~b)>>16) & 0xffff) != (b & 0xffff))                          {                              mode = InflateBlockMode.BAD;                              _codec.Message = "invalid stored block lengths";                              r = ZlibConstants.Z_DATA_ERROR;                                bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                          left = (b & 0xffff);                          b = k = 0; // dump bits                          mode = left != 0 ? InflateBlockMode.STORED : (last != 0 ? InflateBlockMode.DRY : InflateBlockMode.TYPE);                          break;                        case InflateBlockMode.STORED:                          if (n == 0)                          {                              bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                            if (m == 0)                          {                              if (q == end && readAt != 0)                              {                                  q = 0; m = (int)(q < readAt ? readAt - q - 1 : end - q);                              }                              if (m == 0)                              {                                  writeAt = q;                                  r = Flush(r);                                  q = writeAt; m = (int)(q < readAt ? readAt - q - 1 : end - q);                                  if (q == end && readAt != 0)                                  {                                      q = 0; m = (int)(q < readAt ? readAt - q - 1 : end - q);                                  }                                  if (m == 0)                                  {                                      bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                              }                          }                          r = ZlibConstants.Z_OK;                            t = left;                          if (t > n)                              t = n;                          if (t > m)                              t = m;                          Array.Copy(_codec.InputBuffer' p' window' q' t);                          p += t; n -= t;                          q += t; m -= t;                          if ((left -= t) != 0)                              break;                          mode = last != 0 ? InflateBlockMode.DRY : InflateBlockMode.TYPE;                          break;                        case InflateBlockMode.TABLE:                            while (k < (14))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                                n--;                              b |= (_codec.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            table = t = (b & 0x3fff);                          if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29)                          {                              mode = InflateBlockMode.BAD;                              _codec.Message = "too many length or distance symbols";                              r = ZlibConstants.Z_DATA_ERROR;                                bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                          t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);                          if (blens == null || blens.Length < t)                          {                              blens = new int[t];                          }                          else                          {                              Array.Clear(blens' 0' t);                              // for (int i = 0; i < t; i++)                              // {                              //     blens[i] = 0;                              // }                          }                            b >>= 14;                          k -= 14;                              index = 0;                          mode = InflateBlockMode.BTREE;                          goto case InflateBlockMode.BTREE;                        case InflateBlockMode.BTREE:                          while (index < 4 + (table >> 10))                          {                              while (k < (3))                              {                                  if (n != 0)                                  {                                      r = ZlibConstants.Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                                    n--;                                  b |= (_codec.InputBuffer[p++] & 0xff) << k;                                  k += 8;                              }                                blens[border[index++]] = b & 7;                                b >>= 3; k -= 3;                          }                            while (index < 19)                          {                              blens[border[index++]] = 0;                          }                            bb[0] = 7;                          t = inftree.inflate_trees_bits(blens' bb' tb' hufts' _codec);                          if (t != ZlibConstants.Z_OK)                          {                              r = t;                              if (r == ZlibConstants.Z_DATA_ERROR)                              {                                  blens = null;                                  mode = InflateBlockMode.BAD;                              }                                bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                            index = 0;                          mode = InflateBlockMode.DTREE;                          goto case InflateBlockMode.DTREE;                        case InflateBlockMode.DTREE:                          while (true)                          {                              t = table;                              if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)))                              {                                  break;                              }                                int i' j' c;                                t = bb[0];                                while (k < t)                              {                                  if (n != 0)                                  {                                      r = ZlibConstants.Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                                    n--;                                  b |= (_codec.InputBuffer[p++] & 0xff) << k;                                  k += 8;                              }                                t = hufts[(tb[0] + (b & InternalInflateConstants.InflateMask[t])) * 3 + 1];                              c = hufts[(tb[0] + (b & InternalInflateConstants.InflateMask[t])) * 3 + 2];                                if (c < 16)                              {                                  b >>= t; k -= t;                                  blens[index++] = c;                              }                              else                              {                                  // c == 16..18                                  i = c == 18 ? 7 : c - 14;                                  j = c == 18 ? 11 : 3;                                    while (k < (t + i))                                  {                                      if (n != 0)                                      {                                          r = ZlibConstants.Z_OK;                                      }                                      else                                      {                                          bitb = b; bitk = k;                                          _codec.AvailableBytesIn = n;                                          _codec.TotalBytesIn += p - _codec.NextIn;                                          _codec.NextIn = p;                                          writeAt = q;                                          return Flush(r);                                      }                                        n--;                                      b |= (_codec.InputBuffer[p++] & 0xff) << k;                                      k += 8;                                  }                                    b >>= t; k -= t;                                    j += (b & InternalInflateConstants.InflateMask[i]);                                    b >>= i; k -= i;                                    i = index;                                  t = table;                                  if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1))                                  {                                      blens = null;                                      mode = InflateBlockMode.BAD;                                      _codec.Message = "invalid bit length repeat";                                      r = ZlibConstants.Z_DATA_ERROR;                                        bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                                    c = (c == 16) ? blens[i-1] : 0;                                  do                                  {                                      blens[i++] = c;                                  }                                  while (--j != 0);                                  index = i;                              }                          }                            tb[0] = -1;                          {                              int[] bl = new int[] { 9 };  // must be <= 9 for lookahead assumptions                              int[] bd = new int[] { 6 }; // must be <= 9 for lookahead assumptions                              int[] tl = new int[1];                              int[] td = new int[1];                                t = table;                              t = inftree.inflate_trees_dynamic(257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' _codec);                                if (t != ZlibConstants.Z_OK)                              {                                  if (t == ZlibConstants.Z_DATA_ERROR)                                  {                                      blens = null;                                      mode = InflateBlockMode.BAD;                                  }                                  r = t;                                    bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                              codes.Init(bl[0]' bd[0]' hufts' tl[0]' hufts' td[0]);                          }                          mode = InflateBlockMode.CODES;                          goto case InflateBlockMode.CODES;                        case InflateBlockMode.CODES:                          bitb = b; bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                            r = codes.Process(this' r);                          if (r != ZlibConstants.Z_STREAM_END)                          {                              return Flush(r);                          }                            r = ZlibConstants.Z_OK;                          p = _codec.NextIn;                          n = _codec.AvailableBytesIn;                          b = bitb;                          k = bitk;                          q = writeAt;                          m = (int)(q < readAt ? readAt - q - 1 : end - q);                            if (last == 0)                          {                              mode = InflateBlockMode.TYPE;                              break;                          }                          mode = InflateBlockMode.DRY;                          goto case InflateBlockMode.DRY;                        case InflateBlockMode.DRY:                          writeAt = q;                          r = Flush(r);                          q = writeAt; m = (int)(q < readAt ? readAt - q - 1 : end - q);                          if (readAt != writeAt)                          {                              bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                          mode = InflateBlockMode.DONE;                          goto case InflateBlockMode.DONE;                        case InflateBlockMode.DONE:                          r = ZlibConstants.Z_STREAM_END;                          bitb = b;                          bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                          return Flush(r);                        case InflateBlockMode.BAD:                          r = ZlibConstants.Z_DATA_ERROR;                            bitb = b; bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                          return Flush(r);                          default:                          r = ZlibConstants.Z_STREAM_ERROR;                            bitb = b; bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                          return Flush(r);                  }
Magic Number,Ionic.Zlib,InflateBlocks,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zlib.Shared\Inflate.cs,Process,The following statement contains a magic number: switch (mode)                  {                      case InflateBlockMode.TYPE:                            while (k < (3))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                                n--;                              b |= (_codec.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                          t = (int)(b & 7);                          last = t & 1;                            switch ((uint)t >> 1)                          {                              case 0:  // stored                                  b >>= 3; k -= (3);                                  t = k & 7; // go to byte boundary                                  b >>= t; k -= t;                                  mode = InflateBlockMode.LENS; // get length of stored block                                  break;                                case 1:  // fixed                                  int[] bl = new int[1];                                  int[] bd = new int[1];                                  int[][] tl = new int[1][];                                  int[][] td = new int[1][];                                  InfTree.inflate_trees_fixed(bl' bd' tl' td' _codec);                                  codes.Init(bl[0]' bd[0]' tl[0]' 0' td[0]' 0);                                  b >>= 3; k -= 3;                                  mode = InflateBlockMode.CODES;                                  break;                                case 2:  // dynamic                                  b >>= 3; k -= 3;                                  mode = InflateBlockMode.TABLE;                                  break;                                case 3:  // illegal                                  b >>= 3; k -= 3;                                  mode = InflateBlockMode.BAD;                                  _codec.Message = "invalid block type";                                  r = ZlibConstants.Z_DATA_ERROR;                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                          }                          break;                        case InflateBlockMode.LENS:                            while (k < (32))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                              ;                              n--;                              b |= (_codec.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            if ( ( ((~b)>>16) & 0xffff) != (b & 0xffff))                          {                              mode = InflateBlockMode.BAD;                              _codec.Message = "invalid stored block lengths";                              r = ZlibConstants.Z_DATA_ERROR;                                bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                          left = (b & 0xffff);                          b = k = 0; // dump bits                          mode = left != 0 ? InflateBlockMode.STORED : (last != 0 ? InflateBlockMode.DRY : InflateBlockMode.TYPE);                          break;                        case InflateBlockMode.STORED:                          if (n == 0)                          {                              bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                            if (m == 0)                          {                              if (q == end && readAt != 0)                              {                                  q = 0; m = (int)(q < readAt ? readAt - q - 1 : end - q);                              }                              if (m == 0)                              {                                  writeAt = q;                                  r = Flush(r);                                  q = writeAt; m = (int)(q < readAt ? readAt - q - 1 : end - q);                                  if (q == end && readAt != 0)                                  {                                      q = 0; m = (int)(q < readAt ? readAt - q - 1 : end - q);                                  }                                  if (m == 0)                                  {                                      bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                              }                          }                          r = ZlibConstants.Z_OK;                            t = left;                          if (t > n)                              t = n;                          if (t > m)                              t = m;                          Array.Copy(_codec.InputBuffer' p' window' q' t);                          p += t; n -= t;                          q += t; m -= t;                          if ((left -= t) != 0)                              break;                          mode = last != 0 ? InflateBlockMode.DRY : InflateBlockMode.TYPE;                          break;                        case InflateBlockMode.TABLE:                            while (k < (14))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                                n--;                              b |= (_codec.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            table = t = (b & 0x3fff);                          if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29)                          {                              mode = InflateBlockMode.BAD;                              _codec.Message = "too many length or distance symbols";                              r = ZlibConstants.Z_DATA_ERROR;                                bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                          t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);                          if (blens == null || blens.Length < t)                          {                              blens = new int[t];                          }                          else                          {                              Array.Clear(blens' 0' t);                              // for (int i = 0; i < t; i++)                              // {                              //     blens[i] = 0;                              // }                          }                            b >>= 14;                          k -= 14;                              index = 0;                          mode = InflateBlockMode.BTREE;                          goto case InflateBlockMode.BTREE;                        case InflateBlockMode.BTREE:                          while (index < 4 + (table >> 10))                          {                              while (k < (3))                              {                                  if (n != 0)                                  {                                      r = ZlibConstants.Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                                    n--;                                  b |= (_codec.InputBuffer[p++] & 0xff) << k;                                  k += 8;                              }                                blens[border[index++]] = b & 7;                                b >>= 3; k -= 3;                          }                            while (index < 19)                          {                              blens[border[index++]] = 0;                          }                            bb[0] = 7;                          t = inftree.inflate_trees_bits(blens' bb' tb' hufts' _codec);                          if (t != ZlibConstants.Z_OK)                          {                              r = t;                              if (r == ZlibConstants.Z_DATA_ERROR)                              {                                  blens = null;                                  mode = InflateBlockMode.BAD;                              }                                bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                            index = 0;                          mode = InflateBlockMode.DTREE;                          goto case InflateBlockMode.DTREE;                        case InflateBlockMode.DTREE:                          while (true)                          {                              t = table;                              if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)))                              {                                  break;                              }                                int i' j' c;                                t = bb[0];                                while (k < t)                              {                                  if (n != 0)                                  {                                      r = ZlibConstants.Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                                    n--;                                  b |= (_codec.InputBuffer[p++] & 0xff) << k;                                  k += 8;                              }                                t = hufts[(tb[0] + (b & InternalInflateConstants.InflateMask[t])) * 3 + 1];                              c = hufts[(tb[0] + (b & InternalInflateConstants.InflateMask[t])) * 3 + 2];                                if (c < 16)                              {                                  b >>= t; k -= t;                                  blens[index++] = c;                              }                              else                              {                                  // c == 16..18                                  i = c == 18 ? 7 : c - 14;                                  j = c == 18 ? 11 : 3;                                    while (k < (t + i))                                  {                                      if (n != 0)                                      {                                          r = ZlibConstants.Z_OK;                                      }                                      else                                      {                                          bitb = b; bitk = k;                                          _codec.AvailableBytesIn = n;                                          _codec.TotalBytesIn += p - _codec.NextIn;                                          _codec.NextIn = p;                                          writeAt = q;                                          return Flush(r);                                      }                                        n--;                                      b |= (_codec.InputBuffer[p++] & 0xff) << k;                                      k += 8;                                  }                                    b >>= t; k -= t;                                    j += (b & InternalInflateConstants.InflateMask[i]);                                    b >>= i; k -= i;                                    i = index;                                  t = table;                                  if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1))                                  {                                      blens = null;                                      mode = InflateBlockMode.BAD;                                      _codec.Message = "invalid bit length repeat";                                      r = ZlibConstants.Z_DATA_ERROR;                                        bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                                    c = (c == 16) ? blens[i-1] : 0;                                  do                                  {                                      blens[i++] = c;                                  }                                  while (--j != 0);                                  index = i;                              }                          }                            tb[0] = -1;                          {                              int[] bl = new int[] { 9 };  // must be <= 9 for lookahead assumptions                              int[] bd = new int[] { 6 }; // must be <= 9 for lookahead assumptions                              int[] tl = new int[1];                              int[] td = new int[1];                                t = table;                              t = inftree.inflate_trees_dynamic(257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' _codec);                                if (t != ZlibConstants.Z_OK)                              {                                  if (t == ZlibConstants.Z_DATA_ERROR)                                  {                                      blens = null;                                      mode = InflateBlockMode.BAD;                                  }                                  r = t;                                    bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                              codes.Init(bl[0]' bd[0]' hufts' tl[0]' hufts' td[0]);                          }                          mode = InflateBlockMode.CODES;                          goto case InflateBlockMode.CODES;                        case InflateBlockMode.CODES:                          bitb = b; bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                            r = codes.Process(this' r);                          if (r != ZlibConstants.Z_STREAM_END)                          {                              return Flush(r);                          }                            r = ZlibConstants.Z_OK;                          p = _codec.NextIn;                          n = _codec.AvailableBytesIn;                          b = bitb;                          k = bitk;                          q = writeAt;                          m = (int)(q < readAt ? readAt - q - 1 : end - q);                            if (last == 0)                          {                              mode = InflateBlockMode.TYPE;                              break;                          }                          mode = InflateBlockMode.DRY;                          goto case InflateBlockMode.DRY;                        case InflateBlockMode.DRY:                          writeAt = q;                          r = Flush(r);                          q = writeAt; m = (int)(q < readAt ? readAt - q - 1 : end - q);                          if (readAt != writeAt)                          {                              bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                          mode = InflateBlockMode.DONE;                          goto case InflateBlockMode.DONE;                        case InflateBlockMode.DONE:                          r = ZlibConstants.Z_STREAM_END;                          bitb = b;                          bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                          return Flush(r);                        case InflateBlockMode.BAD:                          r = ZlibConstants.Z_DATA_ERROR;                            bitb = b; bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                          return Flush(r);                          default:                          r = ZlibConstants.Z_STREAM_ERROR;                            bitb = b; bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                          return Flush(r);                  }
Magic Number,Ionic.Zlib,InflateBlocks,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zlib.Shared\Inflate.cs,Process,The following statement contains a magic number: switch (mode)                  {                      case InflateBlockMode.TYPE:                            while (k < (3))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                                n--;                              b |= (_codec.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                          t = (int)(b & 7);                          last = t & 1;                            switch ((uint)t >> 1)                          {                              case 0:  // stored                                  b >>= 3; k -= (3);                                  t = k & 7; // go to byte boundary                                  b >>= t; k -= t;                                  mode = InflateBlockMode.LENS; // get length of stored block                                  break;                                case 1:  // fixed                                  int[] bl = new int[1];                                  int[] bd = new int[1];                                  int[][] tl = new int[1][];                                  int[][] td = new int[1][];                                  InfTree.inflate_trees_fixed(bl' bd' tl' td' _codec);                                  codes.Init(bl[0]' bd[0]' tl[0]' 0' td[0]' 0);                                  b >>= 3; k -= 3;                                  mode = InflateBlockMode.CODES;                                  break;                                case 2:  // dynamic                                  b >>= 3; k -= 3;                                  mode = InflateBlockMode.TABLE;                                  break;                                case 3:  // illegal                                  b >>= 3; k -= 3;                                  mode = InflateBlockMode.BAD;                                  _codec.Message = "invalid block type";                                  r = ZlibConstants.Z_DATA_ERROR;                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                          }                          break;                        case InflateBlockMode.LENS:                            while (k < (32))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                              ;                              n--;                              b |= (_codec.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            if ( ( ((~b)>>16) & 0xffff) != (b & 0xffff))                          {                              mode = InflateBlockMode.BAD;                              _codec.Message = "invalid stored block lengths";                              r = ZlibConstants.Z_DATA_ERROR;                                bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                          left = (b & 0xffff);                          b = k = 0; // dump bits                          mode = left != 0 ? InflateBlockMode.STORED : (last != 0 ? InflateBlockMode.DRY : InflateBlockMode.TYPE);                          break;                        case InflateBlockMode.STORED:                          if (n == 0)                          {                              bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                            if (m == 0)                          {                              if (q == end && readAt != 0)                              {                                  q = 0; m = (int)(q < readAt ? readAt - q - 1 : end - q);                              }                              if (m == 0)                              {                                  writeAt = q;                                  r = Flush(r);                                  q = writeAt; m = (int)(q < readAt ? readAt - q - 1 : end - q);                                  if (q == end && readAt != 0)                                  {                                      q = 0; m = (int)(q < readAt ? readAt - q - 1 : end - q);                                  }                                  if (m == 0)                                  {                                      bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                              }                          }                          r = ZlibConstants.Z_OK;                            t = left;                          if (t > n)                              t = n;                          if (t > m)                              t = m;                          Array.Copy(_codec.InputBuffer' p' window' q' t);                          p += t; n -= t;                          q += t; m -= t;                          if ((left -= t) != 0)                              break;                          mode = last != 0 ? InflateBlockMode.DRY : InflateBlockMode.TYPE;                          break;                        case InflateBlockMode.TABLE:                            while (k < (14))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                                n--;                              b |= (_codec.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            table = t = (b & 0x3fff);                          if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29)                          {                              mode = InflateBlockMode.BAD;                              _codec.Message = "too many length or distance symbols";                              r = ZlibConstants.Z_DATA_ERROR;                                bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                          t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);                          if (blens == null || blens.Length < t)                          {                              blens = new int[t];                          }                          else                          {                              Array.Clear(blens' 0' t);                              // for (int i = 0; i < t; i++)                              // {                              //     blens[i] = 0;                              // }                          }                            b >>= 14;                          k -= 14;                              index = 0;                          mode = InflateBlockMode.BTREE;                          goto case InflateBlockMode.BTREE;                        case InflateBlockMode.BTREE:                          while (index < 4 + (table >> 10))                          {                              while (k < (3))                              {                                  if (n != 0)                                  {                                      r = ZlibConstants.Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                                    n--;                                  b |= (_codec.InputBuffer[p++] & 0xff) << k;                                  k += 8;                              }                                blens[border[index++]] = b & 7;                                b >>= 3; k -= 3;                          }                            while (index < 19)                          {                              blens[border[index++]] = 0;                          }                            bb[0] = 7;                          t = inftree.inflate_trees_bits(blens' bb' tb' hufts' _codec);                          if (t != ZlibConstants.Z_OK)                          {                              r = t;                              if (r == ZlibConstants.Z_DATA_ERROR)                              {                                  blens = null;                                  mode = InflateBlockMode.BAD;                              }                                bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                            index = 0;                          mode = InflateBlockMode.DTREE;                          goto case InflateBlockMode.DTREE;                        case InflateBlockMode.DTREE:                          while (true)                          {                              t = table;                              if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)))                              {                                  break;                              }                                int i' j' c;                                t = bb[0];                                while (k < t)                              {                                  if (n != 0)                                  {                                      r = ZlibConstants.Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                                    n--;                                  b |= (_codec.InputBuffer[p++] & 0xff) << k;                                  k += 8;                              }                                t = hufts[(tb[0] + (b & InternalInflateConstants.InflateMask[t])) * 3 + 1];                              c = hufts[(tb[0] + (b & InternalInflateConstants.InflateMask[t])) * 3 + 2];                                if (c < 16)                              {                                  b >>= t; k -= t;                                  blens[index++] = c;                              }                              else                              {                                  // c == 16..18                                  i = c == 18 ? 7 : c - 14;                                  j = c == 18 ? 11 : 3;                                    while (k < (t + i))                                  {                                      if (n != 0)                                      {                                          r = ZlibConstants.Z_OK;                                      }                                      else                                      {                                          bitb = b; bitk = k;                                          _codec.AvailableBytesIn = n;                                          _codec.TotalBytesIn += p - _codec.NextIn;                                          _codec.NextIn = p;                                          writeAt = q;                                          return Flush(r);                                      }                                        n--;                                      b |= (_codec.InputBuffer[p++] & 0xff) << k;                                      k += 8;                                  }                                    b >>= t; k -= t;                                    j += (b & InternalInflateConstants.InflateMask[i]);                                    b >>= i; k -= i;                                    i = index;                                  t = table;                                  if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1))                                  {                                      blens = null;                                      mode = InflateBlockMode.BAD;                                      _codec.Message = "invalid bit length repeat";                                      r = ZlibConstants.Z_DATA_ERROR;                                        bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                                    c = (c == 16) ? blens[i-1] : 0;                                  do                                  {                                      blens[i++] = c;                                  }                                  while (--j != 0);                                  index = i;                              }                          }                            tb[0] = -1;                          {                              int[] bl = new int[] { 9 };  // must be <= 9 for lookahead assumptions                              int[] bd = new int[] { 6 }; // must be <= 9 for lookahead assumptions                              int[] tl = new int[1];                              int[] td = new int[1];                                t = table;                              t = inftree.inflate_trees_dynamic(257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' _codec);                                if (t != ZlibConstants.Z_OK)                              {                                  if (t == ZlibConstants.Z_DATA_ERROR)                                  {                                      blens = null;                                      mode = InflateBlockMode.BAD;                                  }                                  r = t;                                    bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                              codes.Init(bl[0]' bd[0]' hufts' tl[0]' hufts' td[0]);                          }                          mode = InflateBlockMode.CODES;                          goto case InflateBlockMode.CODES;                        case InflateBlockMode.CODES:                          bitb = b; bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                            r = codes.Process(this' r);                          if (r != ZlibConstants.Z_STREAM_END)                          {                              return Flush(r);                          }                            r = ZlibConstants.Z_OK;                          p = _codec.NextIn;                          n = _codec.AvailableBytesIn;                          b = bitb;                          k = bitk;                          q = writeAt;                          m = (int)(q < readAt ? readAt - q - 1 : end - q);                            if (last == 0)                          {                              mode = InflateBlockMode.TYPE;                              break;                          }                          mode = InflateBlockMode.DRY;                          goto case InflateBlockMode.DRY;                        case InflateBlockMode.DRY:                          writeAt = q;                          r = Flush(r);                          q = writeAt; m = (int)(q < readAt ? readAt - q - 1 : end - q);                          if (readAt != writeAt)                          {                              bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                          mode = InflateBlockMode.DONE;                          goto case InflateBlockMode.DONE;                        case InflateBlockMode.DONE:                          r = ZlibConstants.Z_STREAM_END;                          bitb = b;                          bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                          return Flush(r);                        case InflateBlockMode.BAD:                          r = ZlibConstants.Z_DATA_ERROR;                            bitb = b; bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                          return Flush(r);                          default:                          r = ZlibConstants.Z_STREAM_ERROR;                            bitb = b; bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                          return Flush(r);                  }
Magic Number,Ionic.Zlib,InflateBlocks,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zlib.Shared\Inflate.cs,Process,The following statement contains a magic number: switch (mode)                  {                      case InflateBlockMode.TYPE:                            while (k < (3))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                                n--;                              b |= (_codec.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                          t = (int)(b & 7);                          last = t & 1;                            switch ((uint)t >> 1)                          {                              case 0:  // stored                                  b >>= 3; k -= (3);                                  t = k & 7; // go to byte boundary                                  b >>= t; k -= t;                                  mode = InflateBlockMode.LENS; // get length of stored block                                  break;                                case 1:  // fixed                                  int[] bl = new int[1];                                  int[] bd = new int[1];                                  int[][] tl = new int[1][];                                  int[][] td = new int[1][];                                  InfTree.inflate_trees_fixed(bl' bd' tl' td' _codec);                                  codes.Init(bl[0]' bd[0]' tl[0]' 0' td[0]' 0);                                  b >>= 3; k -= 3;                                  mode = InflateBlockMode.CODES;                                  break;                                case 2:  // dynamic                                  b >>= 3; k -= 3;                                  mode = InflateBlockMode.TABLE;                                  break;                                case 3:  // illegal                                  b >>= 3; k -= 3;                                  mode = InflateBlockMode.BAD;                                  _codec.Message = "invalid block type";                                  r = ZlibConstants.Z_DATA_ERROR;                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                          }                          break;                        case InflateBlockMode.LENS:                            while (k < (32))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                              ;                              n--;                              b |= (_codec.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            if ( ( ((~b)>>16) & 0xffff) != (b & 0xffff))                          {                              mode = InflateBlockMode.BAD;                              _codec.Message = "invalid stored block lengths";                              r = ZlibConstants.Z_DATA_ERROR;                                bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                          left = (b & 0xffff);                          b = k = 0; // dump bits                          mode = left != 0 ? InflateBlockMode.STORED : (last != 0 ? InflateBlockMode.DRY : InflateBlockMode.TYPE);                          break;                        case InflateBlockMode.STORED:                          if (n == 0)                          {                              bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                            if (m == 0)                          {                              if (q == end && readAt != 0)                              {                                  q = 0; m = (int)(q < readAt ? readAt - q - 1 : end - q);                              }                              if (m == 0)                              {                                  writeAt = q;                                  r = Flush(r);                                  q = writeAt; m = (int)(q < readAt ? readAt - q - 1 : end - q);                                  if (q == end && readAt != 0)                                  {                                      q = 0; m = (int)(q < readAt ? readAt - q - 1 : end - q);                                  }                                  if (m == 0)                                  {                                      bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                              }                          }                          r = ZlibConstants.Z_OK;                            t = left;                          if (t > n)                              t = n;                          if (t > m)                              t = m;                          Array.Copy(_codec.InputBuffer' p' window' q' t);                          p += t; n -= t;                          q += t; m -= t;                          if ((left -= t) != 0)                              break;                          mode = last != 0 ? InflateBlockMode.DRY : InflateBlockMode.TYPE;                          break;                        case InflateBlockMode.TABLE:                            while (k < (14))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                                n--;                              b |= (_codec.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            table = t = (b & 0x3fff);                          if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29)                          {                              mode = InflateBlockMode.BAD;                              _codec.Message = "too many length or distance symbols";                              r = ZlibConstants.Z_DATA_ERROR;                                bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                          t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);                          if (blens == null || blens.Length < t)                          {                              blens = new int[t];                          }                          else                          {                              Array.Clear(blens' 0' t);                              // for (int i = 0; i < t; i++)                              // {                              //     blens[i] = 0;                              // }                          }                            b >>= 14;                          k -= 14;                              index = 0;                          mode = InflateBlockMode.BTREE;                          goto case InflateBlockMode.BTREE;                        case InflateBlockMode.BTREE:                          while (index < 4 + (table >> 10))                          {                              while (k < (3))                              {                                  if (n != 0)                                  {                                      r = ZlibConstants.Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                                    n--;                                  b |= (_codec.InputBuffer[p++] & 0xff) << k;                                  k += 8;                              }                                blens[border[index++]] = b & 7;                                b >>= 3; k -= 3;                          }                            while (index < 19)                          {                              blens[border[index++]] = 0;                          }                            bb[0] = 7;                          t = inftree.inflate_trees_bits(blens' bb' tb' hufts' _codec);                          if (t != ZlibConstants.Z_OK)                          {                              r = t;                              if (r == ZlibConstants.Z_DATA_ERROR)                              {                                  blens = null;                                  mode = InflateBlockMode.BAD;                              }                                bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                            index = 0;                          mode = InflateBlockMode.DTREE;                          goto case InflateBlockMode.DTREE;                        case InflateBlockMode.DTREE:                          while (true)                          {                              t = table;                              if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)))                              {                                  break;                              }                                int i' j' c;                                t = bb[0];                                while (k < t)                              {                                  if (n != 0)                                  {                                      r = ZlibConstants.Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                                    n--;                                  b |= (_codec.InputBuffer[p++] & 0xff) << k;                                  k += 8;                              }                                t = hufts[(tb[0] + (b & InternalInflateConstants.InflateMask[t])) * 3 + 1];                              c = hufts[(tb[0] + (b & InternalInflateConstants.InflateMask[t])) * 3 + 2];                                if (c < 16)                              {                                  b >>= t; k -= t;                                  blens[index++] = c;                              }                              else                              {                                  // c == 16..18                                  i = c == 18 ? 7 : c - 14;                                  j = c == 18 ? 11 : 3;                                    while (k < (t + i))                                  {                                      if (n != 0)                                      {                                          r = ZlibConstants.Z_OK;                                      }                                      else                                      {                                          bitb = b; bitk = k;                                          _codec.AvailableBytesIn = n;                                          _codec.TotalBytesIn += p - _codec.NextIn;                                          _codec.NextIn = p;                                          writeAt = q;                                          return Flush(r);                                      }                                        n--;                                      b |= (_codec.InputBuffer[p++] & 0xff) << k;                                      k += 8;                                  }                                    b >>= t; k -= t;                                    j += (b & InternalInflateConstants.InflateMask[i]);                                    b >>= i; k -= i;                                    i = index;                                  t = table;                                  if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1))                                  {                                      blens = null;                                      mode = InflateBlockMode.BAD;                                      _codec.Message = "invalid bit length repeat";                                      r = ZlibConstants.Z_DATA_ERROR;                                        bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                                    c = (c == 16) ? blens[i-1] : 0;                                  do                                  {                                      blens[i++] = c;                                  }                                  while (--j != 0);                                  index = i;                              }                          }                            tb[0] = -1;                          {                              int[] bl = new int[] { 9 };  // must be <= 9 for lookahead assumptions                              int[] bd = new int[] { 6 }; // must be <= 9 for lookahead assumptions                              int[] tl = new int[1];                              int[] td = new int[1];                                t = table;                              t = inftree.inflate_trees_dynamic(257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' _codec);                                if (t != ZlibConstants.Z_OK)                              {                                  if (t == ZlibConstants.Z_DATA_ERROR)                                  {                                      blens = null;                                      mode = InflateBlockMode.BAD;                                  }                                  r = t;                                    bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                              codes.Init(bl[0]' bd[0]' hufts' tl[0]' hufts' td[0]);                          }                          mode = InflateBlockMode.CODES;                          goto case InflateBlockMode.CODES;                        case InflateBlockMode.CODES:                          bitb = b; bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                            r = codes.Process(this' r);                          if (r != ZlibConstants.Z_STREAM_END)                          {                              return Flush(r);                          }                            r = ZlibConstants.Z_OK;                          p = _codec.NextIn;                          n = _codec.AvailableBytesIn;                          b = bitb;                          k = bitk;                          q = writeAt;                          m = (int)(q < readAt ? readAt - q - 1 : end - q);                            if (last == 0)                          {                              mode = InflateBlockMode.TYPE;                              break;                          }                          mode = InflateBlockMode.DRY;                          goto case InflateBlockMode.DRY;                        case InflateBlockMode.DRY:                          writeAt = q;                          r = Flush(r);                          q = writeAt; m = (int)(q < readAt ? readAt - q - 1 : end - q);                          if (readAt != writeAt)                          {                              bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                          mode = InflateBlockMode.DONE;                          goto case InflateBlockMode.DONE;                        case InflateBlockMode.DONE:                          r = ZlibConstants.Z_STREAM_END;                          bitb = b;                          bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                          return Flush(r);                        case InflateBlockMode.BAD:                          r = ZlibConstants.Z_DATA_ERROR;                            bitb = b; bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                          return Flush(r);                          default:                          r = ZlibConstants.Z_STREAM_ERROR;                            bitb = b; bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                          return Flush(r);                  }
Magic Number,Ionic.Zlib,InflateBlocks,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zlib.Shared\Inflate.cs,Process,The following statement contains a magic number: switch (mode)                  {                      case InflateBlockMode.TYPE:                            while (k < (3))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                                n--;                              b |= (_codec.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                          t = (int)(b & 7);                          last = t & 1;                            switch ((uint)t >> 1)                          {                              case 0:  // stored                                  b >>= 3; k -= (3);                                  t = k & 7; // go to byte boundary                                  b >>= t; k -= t;                                  mode = InflateBlockMode.LENS; // get length of stored block                                  break;                                case 1:  // fixed                                  int[] bl = new int[1];                                  int[] bd = new int[1];                                  int[][] tl = new int[1][];                                  int[][] td = new int[1][];                                  InfTree.inflate_trees_fixed(bl' bd' tl' td' _codec);                                  codes.Init(bl[0]' bd[0]' tl[0]' 0' td[0]' 0);                                  b >>= 3; k -= 3;                                  mode = InflateBlockMode.CODES;                                  break;                                case 2:  // dynamic                                  b >>= 3; k -= 3;                                  mode = InflateBlockMode.TABLE;                                  break;                                case 3:  // illegal                                  b >>= 3; k -= 3;                                  mode = InflateBlockMode.BAD;                                  _codec.Message = "invalid block type";                                  r = ZlibConstants.Z_DATA_ERROR;                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                          }                          break;                        case InflateBlockMode.LENS:                            while (k < (32))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                              ;                              n--;                              b |= (_codec.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            if ( ( ((~b)>>16) & 0xffff) != (b & 0xffff))                          {                              mode = InflateBlockMode.BAD;                              _codec.Message = "invalid stored block lengths";                              r = ZlibConstants.Z_DATA_ERROR;                                bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                          left = (b & 0xffff);                          b = k = 0; // dump bits                          mode = left != 0 ? InflateBlockMode.STORED : (last != 0 ? InflateBlockMode.DRY : InflateBlockMode.TYPE);                          break;                        case InflateBlockMode.STORED:                          if (n == 0)                          {                              bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                            if (m == 0)                          {                              if (q == end && readAt != 0)                              {                                  q = 0; m = (int)(q < readAt ? readAt - q - 1 : end - q);                              }                              if (m == 0)                              {                                  writeAt = q;                                  r = Flush(r);                                  q = writeAt; m = (int)(q < readAt ? readAt - q - 1 : end - q);                                  if (q == end && readAt != 0)                                  {                                      q = 0; m = (int)(q < readAt ? readAt - q - 1 : end - q);                                  }                                  if (m == 0)                                  {                                      bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                              }                          }                          r = ZlibConstants.Z_OK;                            t = left;                          if (t > n)                              t = n;                          if (t > m)                              t = m;                          Array.Copy(_codec.InputBuffer' p' window' q' t);                          p += t; n -= t;                          q += t; m -= t;                          if ((left -= t) != 0)                              break;                          mode = last != 0 ? InflateBlockMode.DRY : InflateBlockMode.TYPE;                          break;                        case InflateBlockMode.TABLE:                            while (k < (14))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                                n--;                              b |= (_codec.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            table = t = (b & 0x3fff);                          if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29)                          {                              mode = InflateBlockMode.BAD;                              _codec.Message = "too many length or distance symbols";                              r = ZlibConstants.Z_DATA_ERROR;                                bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                          t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);                          if (blens == null || blens.Length < t)                          {                              blens = new int[t];                          }                          else                          {                              Array.Clear(blens' 0' t);                              // for (int i = 0; i < t; i++)                              // {                              //     blens[i] = 0;                              // }                          }                            b >>= 14;                          k -= 14;                              index = 0;                          mode = InflateBlockMode.BTREE;                          goto case InflateBlockMode.BTREE;                        case InflateBlockMode.BTREE:                          while (index < 4 + (table >> 10))                          {                              while (k < (3))                              {                                  if (n != 0)                                  {                                      r = ZlibConstants.Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                                    n--;                                  b |= (_codec.InputBuffer[p++] & 0xff) << k;                                  k += 8;                              }                                blens[border[index++]] = b & 7;                                b >>= 3; k -= 3;                          }                            while (index < 19)                          {                              blens[border[index++]] = 0;                          }                            bb[0] = 7;                          t = inftree.inflate_trees_bits(blens' bb' tb' hufts' _codec);                          if (t != ZlibConstants.Z_OK)                          {                              r = t;                              if (r == ZlibConstants.Z_DATA_ERROR)                              {                                  blens = null;                                  mode = InflateBlockMode.BAD;                              }                                bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                            index = 0;                          mode = InflateBlockMode.DTREE;                          goto case InflateBlockMode.DTREE;                        case InflateBlockMode.DTREE:                          while (true)                          {                              t = table;                              if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)))                              {                                  break;                              }                                int i' j' c;                                t = bb[0];                                while (k < t)                              {                                  if (n != 0)                                  {                                      r = ZlibConstants.Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                                    n--;                                  b |= (_codec.InputBuffer[p++] & 0xff) << k;                                  k += 8;                              }                                t = hufts[(tb[0] + (b & InternalInflateConstants.InflateMask[t])) * 3 + 1];                              c = hufts[(tb[0] + (b & InternalInflateConstants.InflateMask[t])) * 3 + 2];                                if (c < 16)                              {                                  b >>= t; k -= t;                                  blens[index++] = c;                              }                              else                              {                                  // c == 16..18                                  i = c == 18 ? 7 : c - 14;                                  j = c == 18 ? 11 : 3;                                    while (k < (t + i))                                  {                                      if (n != 0)                                      {                                          r = ZlibConstants.Z_OK;                                      }                                      else                                      {                                          bitb = b; bitk = k;                                          _codec.AvailableBytesIn = n;                                          _codec.TotalBytesIn += p - _codec.NextIn;                                          _codec.NextIn = p;                                          writeAt = q;                                          return Flush(r);                                      }                                        n--;                                      b |= (_codec.InputBuffer[p++] & 0xff) << k;                                      k += 8;                                  }                                    b >>= t; k -= t;                                    j += (b & InternalInflateConstants.InflateMask[i]);                                    b >>= i; k -= i;                                    i = index;                                  t = table;                                  if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1))                                  {                                      blens = null;                                      mode = InflateBlockMode.BAD;                                      _codec.Message = "invalid bit length repeat";                                      r = ZlibConstants.Z_DATA_ERROR;                                        bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                                    c = (c == 16) ? blens[i-1] : 0;                                  do                                  {                                      blens[i++] = c;                                  }                                  while (--j != 0);                                  index = i;                              }                          }                            tb[0] = -1;                          {                              int[] bl = new int[] { 9 };  // must be <= 9 for lookahead assumptions                              int[] bd = new int[] { 6 }; // must be <= 9 for lookahead assumptions                              int[] tl = new int[1];                              int[] td = new int[1];                                t = table;                              t = inftree.inflate_trees_dynamic(257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' _codec);                                if (t != ZlibConstants.Z_OK)                              {                                  if (t == ZlibConstants.Z_DATA_ERROR)                                  {                                      blens = null;                                      mode = InflateBlockMode.BAD;                                  }                                  r = t;                                    bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                              codes.Init(bl[0]' bd[0]' hufts' tl[0]' hufts' td[0]);                          }                          mode = InflateBlockMode.CODES;                          goto case InflateBlockMode.CODES;                        case InflateBlockMode.CODES:                          bitb = b; bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                            r = codes.Process(this' r);                          if (r != ZlibConstants.Z_STREAM_END)                          {                              return Flush(r);                          }                            r = ZlibConstants.Z_OK;                          p = _codec.NextIn;                          n = _codec.AvailableBytesIn;                          b = bitb;                          k = bitk;                          q = writeAt;                          m = (int)(q < readAt ? readAt - q - 1 : end - q);                            if (last == 0)                          {                              mode = InflateBlockMode.TYPE;                              break;                          }                          mode = InflateBlockMode.DRY;                          goto case InflateBlockMode.DRY;                        case InflateBlockMode.DRY:                          writeAt = q;                          r = Flush(r);                          q = writeAt; m = (int)(q < readAt ? readAt - q - 1 : end - q);                          if (readAt != writeAt)                          {                              bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                          mode = InflateBlockMode.DONE;                          goto case InflateBlockMode.DONE;                        case InflateBlockMode.DONE:                          r = ZlibConstants.Z_STREAM_END;                          bitb = b;                          bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                          return Flush(r);                        case InflateBlockMode.BAD:                          r = ZlibConstants.Z_DATA_ERROR;                            bitb = b; bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                          return Flush(r);                          default:                          r = ZlibConstants.Z_STREAM_ERROR;                            bitb = b; bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                          return Flush(r);                  }
Magic Number,Ionic.Zlib,InflateBlocks,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zlib.Shared\Inflate.cs,Process,The following statement contains a magic number: switch (mode)                  {                      case InflateBlockMode.TYPE:                            while (k < (3))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                                n--;                              b |= (_codec.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                          t = (int)(b & 7);                          last = t & 1;                            switch ((uint)t >> 1)                          {                              case 0:  // stored                                  b >>= 3; k -= (3);                                  t = k & 7; // go to byte boundary                                  b >>= t; k -= t;                                  mode = InflateBlockMode.LENS; // get length of stored block                                  break;                                case 1:  // fixed                                  int[] bl = new int[1];                                  int[] bd = new int[1];                                  int[][] tl = new int[1][];                                  int[][] td = new int[1][];                                  InfTree.inflate_trees_fixed(bl' bd' tl' td' _codec);                                  codes.Init(bl[0]' bd[0]' tl[0]' 0' td[0]' 0);                                  b >>= 3; k -= 3;                                  mode = InflateBlockMode.CODES;                                  break;                                case 2:  // dynamic                                  b >>= 3; k -= 3;                                  mode = InflateBlockMode.TABLE;                                  break;                                case 3:  // illegal                                  b >>= 3; k -= 3;                                  mode = InflateBlockMode.BAD;                                  _codec.Message = "invalid block type";                                  r = ZlibConstants.Z_DATA_ERROR;                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                          }                          break;                        case InflateBlockMode.LENS:                            while (k < (32))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                              ;                              n--;                              b |= (_codec.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            if ( ( ((~b)>>16) & 0xffff) != (b & 0xffff))                          {                              mode = InflateBlockMode.BAD;                              _codec.Message = "invalid stored block lengths";                              r = ZlibConstants.Z_DATA_ERROR;                                bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                          left = (b & 0xffff);                          b = k = 0; // dump bits                          mode = left != 0 ? InflateBlockMode.STORED : (last != 0 ? InflateBlockMode.DRY : InflateBlockMode.TYPE);                          break;                        case InflateBlockMode.STORED:                          if (n == 0)                          {                              bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                            if (m == 0)                          {                              if (q == end && readAt != 0)                              {                                  q = 0; m = (int)(q < readAt ? readAt - q - 1 : end - q);                              }                              if (m == 0)                              {                                  writeAt = q;                                  r = Flush(r);                                  q = writeAt; m = (int)(q < readAt ? readAt - q - 1 : end - q);                                  if (q == end && readAt != 0)                                  {                                      q = 0; m = (int)(q < readAt ? readAt - q - 1 : end - q);                                  }                                  if (m == 0)                                  {                                      bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                              }                          }                          r = ZlibConstants.Z_OK;                            t = left;                          if (t > n)                              t = n;                          if (t > m)                              t = m;                          Array.Copy(_codec.InputBuffer' p' window' q' t);                          p += t; n -= t;                          q += t; m -= t;                          if ((left -= t) != 0)                              break;                          mode = last != 0 ? InflateBlockMode.DRY : InflateBlockMode.TYPE;                          break;                        case InflateBlockMode.TABLE:                            while (k < (14))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                                n--;                              b |= (_codec.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            table = t = (b & 0x3fff);                          if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29)                          {                              mode = InflateBlockMode.BAD;                              _codec.Message = "too many length or distance symbols";                              r = ZlibConstants.Z_DATA_ERROR;                                bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                          t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);                          if (blens == null || blens.Length < t)                          {                              blens = new int[t];                          }                          else                          {                              Array.Clear(blens' 0' t);                              // for (int i = 0; i < t; i++)                              // {                              //     blens[i] = 0;                              // }                          }                            b >>= 14;                          k -= 14;                              index = 0;                          mode = InflateBlockMode.BTREE;                          goto case InflateBlockMode.BTREE;                        case InflateBlockMode.BTREE:                          while (index < 4 + (table >> 10))                          {                              while (k < (3))                              {                                  if (n != 0)                                  {                                      r = ZlibConstants.Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                                    n--;                                  b |= (_codec.InputBuffer[p++] & 0xff) << k;                                  k += 8;                              }                                blens[border[index++]] = b & 7;                                b >>= 3; k -= 3;                          }                            while (index < 19)                          {                              blens[border[index++]] = 0;                          }                            bb[0] = 7;                          t = inftree.inflate_trees_bits(blens' bb' tb' hufts' _codec);                          if (t != ZlibConstants.Z_OK)                          {                              r = t;                              if (r == ZlibConstants.Z_DATA_ERROR)                              {                                  blens = null;                                  mode = InflateBlockMode.BAD;                              }                                bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                            index = 0;                          mode = InflateBlockMode.DTREE;                          goto case InflateBlockMode.DTREE;                        case InflateBlockMode.DTREE:                          while (true)                          {                              t = table;                              if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)))                              {                                  break;                              }                                int i' j' c;                                t = bb[0];                                while (k < t)                              {                                  if (n != 0)                                  {                                      r = ZlibConstants.Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                                    n--;                                  b |= (_codec.InputBuffer[p++] & 0xff) << k;                                  k += 8;                              }                                t = hufts[(tb[0] + (b & InternalInflateConstants.InflateMask[t])) * 3 + 1];                              c = hufts[(tb[0] + (b & InternalInflateConstants.InflateMask[t])) * 3 + 2];                                if (c < 16)                              {                                  b >>= t; k -= t;                                  blens[index++] = c;                              }                              else                              {                                  // c == 16..18                                  i = c == 18 ? 7 : c - 14;                                  j = c == 18 ? 11 : 3;                                    while (k < (t + i))                                  {                                      if (n != 0)                                      {                                          r = ZlibConstants.Z_OK;                                      }                                      else                                      {                                          bitb = b; bitk = k;                                          _codec.AvailableBytesIn = n;                                          _codec.TotalBytesIn += p - _codec.NextIn;                                          _codec.NextIn = p;                                          writeAt = q;                                          return Flush(r);                                      }                                        n--;                                      b |= (_codec.InputBuffer[p++] & 0xff) << k;                                      k += 8;                                  }                                    b >>= t; k -= t;                                    j += (b & InternalInflateConstants.InflateMask[i]);                                    b >>= i; k -= i;                                    i = index;                                  t = table;                                  if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1))                                  {                                      blens = null;                                      mode = InflateBlockMode.BAD;                                      _codec.Message = "invalid bit length repeat";                                      r = ZlibConstants.Z_DATA_ERROR;                                        bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                                    c = (c == 16) ? blens[i-1] : 0;                                  do                                  {                                      blens[i++] = c;                                  }                                  while (--j != 0);                                  index = i;                              }                          }                            tb[0] = -1;                          {                              int[] bl = new int[] { 9 };  // must be <= 9 for lookahead assumptions                              int[] bd = new int[] { 6 }; // must be <= 9 for lookahead assumptions                              int[] tl = new int[1];                              int[] td = new int[1];                                t = table;                              t = inftree.inflate_trees_dynamic(257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' _codec);                                if (t != ZlibConstants.Z_OK)                              {                                  if (t == ZlibConstants.Z_DATA_ERROR)                                  {                                      blens = null;                                      mode = InflateBlockMode.BAD;                                  }                                  r = t;                                    bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                              codes.Init(bl[0]' bd[0]' hufts' tl[0]' hufts' td[0]);                          }                          mode = InflateBlockMode.CODES;                          goto case InflateBlockMode.CODES;                        case InflateBlockMode.CODES:                          bitb = b; bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                            r = codes.Process(this' r);                          if (r != ZlibConstants.Z_STREAM_END)                          {                              return Flush(r);                          }                            r = ZlibConstants.Z_OK;                          p = _codec.NextIn;                          n = _codec.AvailableBytesIn;                          b = bitb;                          k = bitk;                          q = writeAt;                          m = (int)(q < readAt ? readAt - q - 1 : end - q);                            if (last == 0)                          {                              mode = InflateBlockMode.TYPE;                              break;                          }                          mode = InflateBlockMode.DRY;                          goto case InflateBlockMode.DRY;                        case InflateBlockMode.DRY:                          writeAt = q;                          r = Flush(r);                          q = writeAt; m = (int)(q < readAt ? readAt - q - 1 : end - q);                          if (readAt != writeAt)                          {                              bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                          mode = InflateBlockMode.DONE;                          goto case InflateBlockMode.DONE;                        case InflateBlockMode.DONE:                          r = ZlibConstants.Z_STREAM_END;                          bitb = b;                          bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                          return Flush(r);                        case InflateBlockMode.BAD:                          r = ZlibConstants.Z_DATA_ERROR;                            bitb = b; bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                          return Flush(r);                          default:                          r = ZlibConstants.Z_STREAM_ERROR;                            bitb = b; bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                          return Flush(r);                  }
Magic Number,Ionic.Zlib,InflateBlocks,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zlib.Shared\Inflate.cs,Process,The following statement contains a magic number: switch (mode)                  {                      case InflateBlockMode.TYPE:                            while (k < (3))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                                n--;                              b |= (_codec.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                          t = (int)(b & 7);                          last = t & 1;                            switch ((uint)t >> 1)                          {                              case 0:  // stored                                  b >>= 3; k -= (3);                                  t = k & 7; // go to byte boundary                                  b >>= t; k -= t;                                  mode = InflateBlockMode.LENS; // get length of stored block                                  break;                                case 1:  // fixed                                  int[] bl = new int[1];                                  int[] bd = new int[1];                                  int[][] tl = new int[1][];                                  int[][] td = new int[1][];                                  InfTree.inflate_trees_fixed(bl' bd' tl' td' _codec);                                  codes.Init(bl[0]' bd[0]' tl[0]' 0' td[0]' 0);                                  b >>= 3; k -= 3;                                  mode = InflateBlockMode.CODES;                                  break;                                case 2:  // dynamic                                  b >>= 3; k -= 3;                                  mode = InflateBlockMode.TABLE;                                  break;                                case 3:  // illegal                                  b >>= 3; k -= 3;                                  mode = InflateBlockMode.BAD;                                  _codec.Message = "invalid block type";                                  r = ZlibConstants.Z_DATA_ERROR;                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                          }                          break;                        case InflateBlockMode.LENS:                            while (k < (32))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                              ;                              n--;                              b |= (_codec.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            if ( ( ((~b)>>16) & 0xffff) != (b & 0xffff))                          {                              mode = InflateBlockMode.BAD;                              _codec.Message = "invalid stored block lengths";                              r = ZlibConstants.Z_DATA_ERROR;                                bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                          left = (b & 0xffff);                          b = k = 0; // dump bits                          mode = left != 0 ? InflateBlockMode.STORED : (last != 0 ? InflateBlockMode.DRY : InflateBlockMode.TYPE);                          break;                        case InflateBlockMode.STORED:                          if (n == 0)                          {                              bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                            if (m == 0)                          {                              if (q == end && readAt != 0)                              {                                  q = 0; m = (int)(q < readAt ? readAt - q - 1 : end - q);                              }                              if (m == 0)                              {                                  writeAt = q;                                  r = Flush(r);                                  q = writeAt; m = (int)(q < readAt ? readAt - q - 1 : end - q);                                  if (q == end && readAt != 0)                                  {                                      q = 0; m = (int)(q < readAt ? readAt - q - 1 : end - q);                                  }                                  if (m == 0)                                  {                                      bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                              }                          }                          r = ZlibConstants.Z_OK;                            t = left;                          if (t > n)                              t = n;                          if (t > m)                              t = m;                          Array.Copy(_codec.InputBuffer' p' window' q' t);                          p += t; n -= t;                          q += t; m -= t;                          if ((left -= t) != 0)                              break;                          mode = last != 0 ? InflateBlockMode.DRY : InflateBlockMode.TYPE;                          break;                        case InflateBlockMode.TABLE:                            while (k < (14))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                                n--;                              b |= (_codec.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            table = t = (b & 0x3fff);                          if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29)                          {                              mode = InflateBlockMode.BAD;                              _codec.Message = "too many length or distance symbols";                              r = ZlibConstants.Z_DATA_ERROR;                                bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                          t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);                          if (blens == null || blens.Length < t)                          {                              blens = new int[t];                          }                          else                          {                              Array.Clear(blens' 0' t);                              // for (int i = 0; i < t; i++)                              // {                              //     blens[i] = 0;                              // }                          }                            b >>= 14;                          k -= 14;                              index = 0;                          mode = InflateBlockMode.BTREE;                          goto case InflateBlockMode.BTREE;                        case InflateBlockMode.BTREE:                          while (index < 4 + (table >> 10))                          {                              while (k < (3))                              {                                  if (n != 0)                                  {                                      r = ZlibConstants.Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                                    n--;                                  b |= (_codec.InputBuffer[p++] & 0xff) << k;                                  k += 8;                              }                                blens[border[index++]] = b & 7;                                b >>= 3; k -= 3;                          }                            while (index < 19)                          {                              blens[border[index++]] = 0;                          }                            bb[0] = 7;                          t = inftree.inflate_trees_bits(blens' bb' tb' hufts' _codec);                          if (t != ZlibConstants.Z_OK)                          {                              r = t;                              if (r == ZlibConstants.Z_DATA_ERROR)                              {                                  blens = null;                                  mode = InflateBlockMode.BAD;                              }                                bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                            index = 0;                          mode = InflateBlockMode.DTREE;                          goto case InflateBlockMode.DTREE;                        case InflateBlockMode.DTREE:                          while (true)                          {                              t = table;                              if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)))                              {                                  break;                              }                                int i' j' c;                                t = bb[0];                                while (k < t)                              {                                  if (n != 0)                                  {                                      r = ZlibConstants.Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                                    n--;                                  b |= (_codec.InputBuffer[p++] & 0xff) << k;                                  k += 8;                              }                                t = hufts[(tb[0] + (b & InternalInflateConstants.InflateMask[t])) * 3 + 1];                              c = hufts[(tb[0] + (b & InternalInflateConstants.InflateMask[t])) * 3 + 2];                                if (c < 16)                              {                                  b >>= t; k -= t;                                  blens[index++] = c;                              }                              else                              {                                  // c == 16..18                                  i = c == 18 ? 7 : c - 14;                                  j = c == 18 ? 11 : 3;                                    while (k < (t + i))                                  {                                      if (n != 0)                                      {                                          r = ZlibConstants.Z_OK;                                      }                                      else                                      {                                          bitb = b; bitk = k;                                          _codec.AvailableBytesIn = n;                                          _codec.TotalBytesIn += p - _codec.NextIn;                                          _codec.NextIn = p;                                          writeAt = q;                                          return Flush(r);                                      }                                        n--;                                      b |= (_codec.InputBuffer[p++] & 0xff) << k;                                      k += 8;                                  }                                    b >>= t; k -= t;                                    j += (b & InternalInflateConstants.InflateMask[i]);                                    b >>= i; k -= i;                                    i = index;                                  t = table;                                  if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1))                                  {                                      blens = null;                                      mode = InflateBlockMode.BAD;                                      _codec.Message = "invalid bit length repeat";                                      r = ZlibConstants.Z_DATA_ERROR;                                        bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                                    c = (c == 16) ? blens[i-1] : 0;                                  do                                  {                                      blens[i++] = c;                                  }                                  while (--j != 0);                                  index = i;                              }                          }                            tb[0] = -1;                          {                              int[] bl = new int[] { 9 };  // must be <= 9 for lookahead assumptions                              int[] bd = new int[] { 6 }; // must be <= 9 for lookahead assumptions                              int[] tl = new int[1];                              int[] td = new int[1];                                t = table;                              t = inftree.inflate_trees_dynamic(257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' _codec);                                if (t != ZlibConstants.Z_OK)                              {                                  if (t == ZlibConstants.Z_DATA_ERROR)                                  {                                      blens = null;                                      mode = InflateBlockMode.BAD;                                  }                                  r = t;                                    bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                              codes.Init(bl[0]' bd[0]' hufts' tl[0]' hufts' td[0]);                          }                          mode = InflateBlockMode.CODES;                          goto case InflateBlockMode.CODES;                        case InflateBlockMode.CODES:                          bitb = b; bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                            r = codes.Process(this' r);                          if (r != ZlibConstants.Z_STREAM_END)                          {                              return Flush(r);                          }                            r = ZlibConstants.Z_OK;                          p = _codec.NextIn;                          n = _codec.AvailableBytesIn;                          b = bitb;                          k = bitk;                          q = writeAt;                          m = (int)(q < readAt ? readAt - q - 1 : end - q);                            if (last == 0)                          {                              mode = InflateBlockMode.TYPE;                              break;                          }                          mode = InflateBlockMode.DRY;                          goto case InflateBlockMode.DRY;                        case InflateBlockMode.DRY:                          writeAt = q;                          r = Flush(r);                          q = writeAt; m = (int)(q < readAt ? readAt - q - 1 : end - q);                          if (readAt != writeAt)                          {                              bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                          mode = InflateBlockMode.DONE;                          goto case InflateBlockMode.DONE;                        case InflateBlockMode.DONE:                          r = ZlibConstants.Z_STREAM_END;                          bitb = b;                          bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                          return Flush(r);                        case InflateBlockMode.BAD:                          r = ZlibConstants.Z_DATA_ERROR;                            bitb = b; bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                          return Flush(r);                          default:                          r = ZlibConstants.Z_STREAM_ERROR;                            bitb = b; bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                          return Flush(r);                  }
Magic Number,Ionic.Zlib,InflateBlocks,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zlib.Shared\Inflate.cs,Process,The following statement contains a magic number: switch (mode)                  {                      case InflateBlockMode.TYPE:                            while (k < (3))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                                n--;                              b |= (_codec.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                          t = (int)(b & 7);                          last = t & 1;                            switch ((uint)t >> 1)                          {                              case 0:  // stored                                  b >>= 3; k -= (3);                                  t = k & 7; // go to byte boundary                                  b >>= t; k -= t;                                  mode = InflateBlockMode.LENS; // get length of stored block                                  break;                                case 1:  // fixed                                  int[] bl = new int[1];                                  int[] bd = new int[1];                                  int[][] tl = new int[1][];                                  int[][] td = new int[1][];                                  InfTree.inflate_trees_fixed(bl' bd' tl' td' _codec);                                  codes.Init(bl[0]' bd[0]' tl[0]' 0' td[0]' 0);                                  b >>= 3; k -= 3;                                  mode = InflateBlockMode.CODES;                                  break;                                case 2:  // dynamic                                  b >>= 3; k -= 3;                                  mode = InflateBlockMode.TABLE;                                  break;                                case 3:  // illegal                                  b >>= 3; k -= 3;                                  mode = InflateBlockMode.BAD;                                  _codec.Message = "invalid block type";                                  r = ZlibConstants.Z_DATA_ERROR;                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                          }                          break;                        case InflateBlockMode.LENS:                            while (k < (32))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                              ;                              n--;                              b |= (_codec.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            if ( ( ((~b)>>16) & 0xffff) != (b & 0xffff))                          {                              mode = InflateBlockMode.BAD;                              _codec.Message = "invalid stored block lengths";                              r = ZlibConstants.Z_DATA_ERROR;                                bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                          left = (b & 0xffff);                          b = k = 0; // dump bits                          mode = left != 0 ? InflateBlockMode.STORED : (last != 0 ? InflateBlockMode.DRY : InflateBlockMode.TYPE);                          break;                        case InflateBlockMode.STORED:                          if (n == 0)                          {                              bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                            if (m == 0)                          {                              if (q == end && readAt != 0)                              {                                  q = 0; m = (int)(q < readAt ? readAt - q - 1 : end - q);                              }                              if (m == 0)                              {                                  writeAt = q;                                  r = Flush(r);                                  q = writeAt; m = (int)(q < readAt ? readAt - q - 1 : end - q);                                  if (q == end && readAt != 0)                                  {                                      q = 0; m = (int)(q < readAt ? readAt - q - 1 : end - q);                                  }                                  if (m == 0)                                  {                                      bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                              }                          }                          r = ZlibConstants.Z_OK;                            t = left;                          if (t > n)                              t = n;                          if (t > m)                              t = m;                          Array.Copy(_codec.InputBuffer' p' window' q' t);                          p += t; n -= t;                          q += t; m -= t;                          if ((left -= t) != 0)                              break;                          mode = last != 0 ? InflateBlockMode.DRY : InflateBlockMode.TYPE;                          break;                        case InflateBlockMode.TABLE:                            while (k < (14))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                                n--;                              b |= (_codec.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            table = t = (b & 0x3fff);                          if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29)                          {                              mode = InflateBlockMode.BAD;                              _codec.Message = "too many length or distance symbols";                              r = ZlibConstants.Z_DATA_ERROR;                                bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                          t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);                          if (blens == null || blens.Length < t)                          {                              blens = new int[t];                          }                          else                          {                              Array.Clear(blens' 0' t);                              // for (int i = 0; i < t; i++)                              // {                              //     blens[i] = 0;                              // }                          }                            b >>= 14;                          k -= 14;                              index = 0;                          mode = InflateBlockMode.BTREE;                          goto case InflateBlockMode.BTREE;                        case InflateBlockMode.BTREE:                          while (index < 4 + (table >> 10))                          {                              while (k < (3))                              {                                  if (n != 0)                                  {                                      r = ZlibConstants.Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                                    n--;                                  b |= (_codec.InputBuffer[p++] & 0xff) << k;                                  k += 8;                              }                                blens[border[index++]] = b & 7;                                b >>= 3; k -= 3;                          }                            while (index < 19)                          {                              blens[border[index++]] = 0;                          }                            bb[0] = 7;                          t = inftree.inflate_trees_bits(blens' bb' tb' hufts' _codec);                          if (t != ZlibConstants.Z_OK)                          {                              r = t;                              if (r == ZlibConstants.Z_DATA_ERROR)                              {                                  blens = null;                                  mode = InflateBlockMode.BAD;                              }                                bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                            index = 0;                          mode = InflateBlockMode.DTREE;                          goto case InflateBlockMode.DTREE;                        case InflateBlockMode.DTREE:                          while (true)                          {                              t = table;                              if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)))                              {                                  break;                              }                                int i' j' c;                                t = bb[0];                                while (k < t)                              {                                  if (n != 0)                                  {                                      r = ZlibConstants.Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                                    n--;                                  b |= (_codec.InputBuffer[p++] & 0xff) << k;                                  k += 8;                              }                                t = hufts[(tb[0] + (b & InternalInflateConstants.InflateMask[t])) * 3 + 1];                              c = hufts[(tb[0] + (b & InternalInflateConstants.InflateMask[t])) * 3 + 2];                                if (c < 16)                              {                                  b >>= t; k -= t;                                  blens[index++] = c;                              }                              else                              {                                  // c == 16..18                                  i = c == 18 ? 7 : c - 14;                                  j = c == 18 ? 11 : 3;                                    while (k < (t + i))                                  {                                      if (n != 0)                                      {                                          r = ZlibConstants.Z_OK;                                      }                                      else                                      {                                          bitb = b; bitk = k;                                          _codec.AvailableBytesIn = n;                                          _codec.TotalBytesIn += p - _codec.NextIn;                                          _codec.NextIn = p;                                          writeAt = q;                                          return Flush(r);                                      }                                        n--;                                      b |= (_codec.InputBuffer[p++] & 0xff) << k;                                      k += 8;                                  }                                    b >>= t; k -= t;                                    j += (b & InternalInflateConstants.InflateMask[i]);                                    b >>= i; k -= i;                                    i = index;                                  t = table;                                  if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1))                                  {                                      blens = null;                                      mode = InflateBlockMode.BAD;                                      _codec.Message = "invalid bit length repeat";                                      r = ZlibConstants.Z_DATA_ERROR;                                        bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                                    c = (c == 16) ? blens[i-1] : 0;                                  do                                  {                                      blens[i++] = c;                                  }                                  while (--j != 0);                                  index = i;                              }                          }                            tb[0] = -1;                          {                              int[] bl = new int[] { 9 };  // must be <= 9 for lookahead assumptions                              int[] bd = new int[] { 6 }; // must be <= 9 for lookahead assumptions                              int[] tl = new int[1];                              int[] td = new int[1];                                t = table;                              t = inftree.inflate_trees_dynamic(257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' _codec);                                if (t != ZlibConstants.Z_OK)                              {                                  if (t == ZlibConstants.Z_DATA_ERROR)                                  {                                      blens = null;                                      mode = InflateBlockMode.BAD;                                  }                                  r = t;                                    bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                              codes.Init(bl[0]' bd[0]' hufts' tl[0]' hufts' td[0]);                          }                          mode = InflateBlockMode.CODES;                          goto case InflateBlockMode.CODES;                        case InflateBlockMode.CODES:                          bitb = b; bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                            r = codes.Process(this' r);                          if (r != ZlibConstants.Z_STREAM_END)                          {                              return Flush(r);                          }                            r = ZlibConstants.Z_OK;                          p = _codec.NextIn;                          n = _codec.AvailableBytesIn;                          b = bitb;                          k = bitk;                          q = writeAt;                          m = (int)(q < readAt ? readAt - q - 1 : end - q);                            if (last == 0)                          {                              mode = InflateBlockMode.TYPE;                              break;                          }                          mode = InflateBlockMode.DRY;                          goto case InflateBlockMode.DRY;                        case InflateBlockMode.DRY:                          writeAt = q;                          r = Flush(r);                          q = writeAt; m = (int)(q < readAt ? readAt - q - 1 : end - q);                          if (readAt != writeAt)                          {                              bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                          mode = InflateBlockMode.DONE;                          goto case InflateBlockMode.DONE;                        case InflateBlockMode.DONE:                          r = ZlibConstants.Z_STREAM_END;                          bitb = b;                          bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                          return Flush(r);                        case InflateBlockMode.BAD:                          r = ZlibConstants.Z_DATA_ERROR;                            bitb = b; bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                          return Flush(r);                          default:                          r = ZlibConstants.Z_STREAM_ERROR;                            bitb = b; bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                          return Flush(r);                  }
Magic Number,Ionic.Zlib,InflateBlocks,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zlib.Shared\Inflate.cs,Process,The following statement contains a magic number: switch (mode)                  {                      case InflateBlockMode.TYPE:                            while (k < (3))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                                n--;                              b |= (_codec.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                          t = (int)(b & 7);                          last = t & 1;                            switch ((uint)t >> 1)                          {                              case 0:  // stored                                  b >>= 3; k -= (3);                                  t = k & 7; // go to byte boundary                                  b >>= t; k -= t;                                  mode = InflateBlockMode.LENS; // get length of stored block                                  break;                                case 1:  // fixed                                  int[] bl = new int[1];                                  int[] bd = new int[1];                                  int[][] tl = new int[1][];                                  int[][] td = new int[1][];                                  InfTree.inflate_trees_fixed(bl' bd' tl' td' _codec);                                  codes.Init(bl[0]' bd[0]' tl[0]' 0' td[0]' 0);                                  b >>= 3; k -= 3;                                  mode = InflateBlockMode.CODES;                                  break;                                case 2:  // dynamic                                  b >>= 3; k -= 3;                                  mode = InflateBlockMode.TABLE;                                  break;                                case 3:  // illegal                                  b >>= 3; k -= 3;                                  mode = InflateBlockMode.BAD;                                  _codec.Message = "invalid block type";                                  r = ZlibConstants.Z_DATA_ERROR;                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                          }                          break;                        case InflateBlockMode.LENS:                            while (k < (32))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                              ;                              n--;                              b |= (_codec.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            if ( ( ((~b)>>16) & 0xffff) != (b & 0xffff))                          {                              mode = InflateBlockMode.BAD;                              _codec.Message = "invalid stored block lengths";                              r = ZlibConstants.Z_DATA_ERROR;                                bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                          left = (b & 0xffff);                          b = k = 0; // dump bits                          mode = left != 0 ? InflateBlockMode.STORED : (last != 0 ? InflateBlockMode.DRY : InflateBlockMode.TYPE);                          break;                        case InflateBlockMode.STORED:                          if (n == 0)                          {                              bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                            if (m == 0)                          {                              if (q == end && readAt != 0)                              {                                  q = 0; m = (int)(q < readAt ? readAt - q - 1 : end - q);                              }                              if (m == 0)                              {                                  writeAt = q;                                  r = Flush(r);                                  q = writeAt; m = (int)(q < readAt ? readAt - q - 1 : end - q);                                  if (q == end && readAt != 0)                                  {                                      q = 0; m = (int)(q < readAt ? readAt - q - 1 : end - q);                                  }                                  if (m == 0)                                  {                                      bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                              }                          }                          r = ZlibConstants.Z_OK;                            t = left;                          if (t > n)                              t = n;                          if (t > m)                              t = m;                          Array.Copy(_codec.InputBuffer' p' window' q' t);                          p += t; n -= t;                          q += t; m -= t;                          if ((left -= t) != 0)                              break;                          mode = last != 0 ? InflateBlockMode.DRY : InflateBlockMode.TYPE;                          break;                        case InflateBlockMode.TABLE:                            while (k < (14))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                                n--;                              b |= (_codec.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            table = t = (b & 0x3fff);                          if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29)                          {                              mode = InflateBlockMode.BAD;                              _codec.Message = "too many length or distance symbols";                              r = ZlibConstants.Z_DATA_ERROR;                                bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                          t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);                          if (blens == null || blens.Length < t)                          {                              blens = new int[t];                          }                          else                          {                              Array.Clear(blens' 0' t);                              // for (int i = 0; i < t; i++)                              // {                              //     blens[i] = 0;                              // }                          }                            b >>= 14;                          k -= 14;                              index = 0;                          mode = InflateBlockMode.BTREE;                          goto case InflateBlockMode.BTREE;                        case InflateBlockMode.BTREE:                          while (index < 4 + (table >> 10))                          {                              while (k < (3))                              {                                  if (n != 0)                                  {                                      r = ZlibConstants.Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                                    n--;                                  b |= (_codec.InputBuffer[p++] & 0xff) << k;                                  k += 8;                              }                                blens[border[index++]] = b & 7;                                b >>= 3; k -= 3;                          }                            while (index < 19)                          {                              blens[border[index++]] = 0;                          }                            bb[0] = 7;                          t = inftree.inflate_trees_bits(blens' bb' tb' hufts' _codec);                          if (t != ZlibConstants.Z_OK)                          {                              r = t;                              if (r == ZlibConstants.Z_DATA_ERROR)                              {                                  blens = null;                                  mode = InflateBlockMode.BAD;                              }                                bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                            index = 0;                          mode = InflateBlockMode.DTREE;                          goto case InflateBlockMode.DTREE;                        case InflateBlockMode.DTREE:                          while (true)                          {                              t = table;                              if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)))                              {                                  break;                              }                                int i' j' c;                                t = bb[0];                                while (k < t)                              {                                  if (n != 0)                                  {                                      r = ZlibConstants.Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                                    n--;                                  b |= (_codec.InputBuffer[p++] & 0xff) << k;                                  k += 8;                              }                                t = hufts[(tb[0] + (b & InternalInflateConstants.InflateMask[t])) * 3 + 1];                              c = hufts[(tb[0] + (b & InternalInflateConstants.InflateMask[t])) * 3 + 2];                                if (c < 16)                              {                                  b >>= t; k -= t;                                  blens[index++] = c;                              }                              else                              {                                  // c == 16..18                                  i = c == 18 ? 7 : c - 14;                                  j = c == 18 ? 11 : 3;                                    while (k < (t + i))                                  {                                      if (n != 0)                                      {                                          r = ZlibConstants.Z_OK;                                      }                                      else                                      {                                          bitb = b; bitk = k;                                          _codec.AvailableBytesIn = n;                                          _codec.TotalBytesIn += p - _codec.NextIn;                                          _codec.NextIn = p;                                          writeAt = q;                                          return Flush(r);                                      }                                        n--;                                      b |= (_codec.InputBuffer[p++] & 0xff) << k;                                      k += 8;                                  }                                    b >>= t; k -= t;                                    j += (b & InternalInflateConstants.InflateMask[i]);                                    b >>= i; k -= i;                                    i = index;                                  t = table;                                  if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1))                                  {                                      blens = null;                                      mode = InflateBlockMode.BAD;                                      _codec.Message = "invalid bit length repeat";                                      r = ZlibConstants.Z_DATA_ERROR;                                        bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                                    c = (c == 16) ? blens[i-1] : 0;                                  do                                  {                                      blens[i++] = c;                                  }                                  while (--j != 0);                                  index = i;                              }                          }                            tb[0] = -1;                          {                              int[] bl = new int[] { 9 };  // must be <= 9 for lookahead assumptions                              int[] bd = new int[] { 6 }; // must be <= 9 for lookahead assumptions                              int[] tl = new int[1];                              int[] td = new int[1];                                t = table;                              t = inftree.inflate_trees_dynamic(257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' _codec);                                if (t != ZlibConstants.Z_OK)                              {                                  if (t == ZlibConstants.Z_DATA_ERROR)                                  {                                      blens = null;                                      mode = InflateBlockMode.BAD;                                  }                                  r = t;                                    bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                              codes.Init(bl[0]' bd[0]' hufts' tl[0]' hufts' td[0]);                          }                          mode = InflateBlockMode.CODES;                          goto case InflateBlockMode.CODES;                        case InflateBlockMode.CODES:                          bitb = b; bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                            r = codes.Process(this' r);                          if (r != ZlibConstants.Z_STREAM_END)                          {                              return Flush(r);                          }                            r = ZlibConstants.Z_OK;                          p = _codec.NextIn;                          n = _codec.AvailableBytesIn;                          b = bitb;                          k = bitk;                          q = writeAt;                          m = (int)(q < readAt ? readAt - q - 1 : end - q);                            if (last == 0)                          {                              mode = InflateBlockMode.TYPE;                              break;                          }                          mode = InflateBlockMode.DRY;                          goto case InflateBlockMode.DRY;                        case InflateBlockMode.DRY:                          writeAt = q;                          r = Flush(r);                          q = writeAt; m = (int)(q < readAt ? readAt - q - 1 : end - q);                          if (readAt != writeAt)                          {                              bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                          mode = InflateBlockMode.DONE;                          goto case InflateBlockMode.DONE;                        case InflateBlockMode.DONE:                          r = ZlibConstants.Z_STREAM_END;                          bitb = b;                          bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                          return Flush(r);                        case InflateBlockMode.BAD:                          r = ZlibConstants.Z_DATA_ERROR;                            bitb = b; bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                          return Flush(r);                          default:                          r = ZlibConstants.Z_STREAM_ERROR;                            bitb = b; bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                          return Flush(r);                  }
Magic Number,Ionic.Zlib,InflateBlocks,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zlib.Shared\Inflate.cs,Process,The following statement contains a magic number: switch (mode)                  {                      case InflateBlockMode.TYPE:                            while (k < (3))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                                n--;                              b |= (_codec.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                          t = (int)(b & 7);                          last = t & 1;                            switch ((uint)t >> 1)                          {                              case 0:  // stored                                  b >>= 3; k -= (3);                                  t = k & 7; // go to byte boundary                                  b >>= t; k -= t;                                  mode = InflateBlockMode.LENS; // get length of stored block                                  break;                                case 1:  // fixed                                  int[] bl = new int[1];                                  int[] bd = new int[1];                                  int[][] tl = new int[1][];                                  int[][] td = new int[1][];                                  InfTree.inflate_trees_fixed(bl' bd' tl' td' _codec);                                  codes.Init(bl[0]' bd[0]' tl[0]' 0' td[0]' 0);                                  b >>= 3; k -= 3;                                  mode = InflateBlockMode.CODES;                                  break;                                case 2:  // dynamic                                  b >>= 3; k -= 3;                                  mode = InflateBlockMode.TABLE;                                  break;                                case 3:  // illegal                                  b >>= 3; k -= 3;                                  mode = InflateBlockMode.BAD;                                  _codec.Message = "invalid block type";                                  r = ZlibConstants.Z_DATA_ERROR;                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                          }                          break;                        case InflateBlockMode.LENS:                            while (k < (32))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                              ;                              n--;                              b |= (_codec.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            if ( ( ((~b)>>16) & 0xffff) != (b & 0xffff))                          {                              mode = InflateBlockMode.BAD;                              _codec.Message = "invalid stored block lengths";                              r = ZlibConstants.Z_DATA_ERROR;                                bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                          left = (b & 0xffff);                          b = k = 0; // dump bits                          mode = left != 0 ? InflateBlockMode.STORED : (last != 0 ? InflateBlockMode.DRY : InflateBlockMode.TYPE);                          break;                        case InflateBlockMode.STORED:                          if (n == 0)                          {                              bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                            if (m == 0)                          {                              if (q == end && readAt != 0)                              {                                  q = 0; m = (int)(q < readAt ? readAt - q - 1 : end - q);                              }                              if (m == 0)                              {                                  writeAt = q;                                  r = Flush(r);                                  q = writeAt; m = (int)(q < readAt ? readAt - q - 1 : end - q);                                  if (q == end && readAt != 0)                                  {                                      q = 0; m = (int)(q < readAt ? readAt - q - 1 : end - q);                                  }                                  if (m == 0)                                  {                                      bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                              }                          }                          r = ZlibConstants.Z_OK;                            t = left;                          if (t > n)                              t = n;                          if (t > m)                              t = m;                          Array.Copy(_codec.InputBuffer' p' window' q' t);                          p += t; n -= t;                          q += t; m -= t;                          if ((left -= t) != 0)                              break;                          mode = last != 0 ? InflateBlockMode.DRY : InflateBlockMode.TYPE;                          break;                        case InflateBlockMode.TABLE:                            while (k < (14))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                                n--;                              b |= (_codec.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            table = t = (b & 0x3fff);                          if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29)                          {                              mode = InflateBlockMode.BAD;                              _codec.Message = "too many length or distance symbols";                              r = ZlibConstants.Z_DATA_ERROR;                                bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                          t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);                          if (blens == null || blens.Length < t)                          {                              blens = new int[t];                          }                          else                          {                              Array.Clear(blens' 0' t);                              // for (int i = 0; i < t; i++)                              // {                              //     blens[i] = 0;                              // }                          }                            b >>= 14;                          k -= 14;                              index = 0;                          mode = InflateBlockMode.BTREE;                          goto case InflateBlockMode.BTREE;                        case InflateBlockMode.BTREE:                          while (index < 4 + (table >> 10))                          {                              while (k < (3))                              {                                  if (n != 0)                                  {                                      r = ZlibConstants.Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                                    n--;                                  b |= (_codec.InputBuffer[p++] & 0xff) << k;                                  k += 8;                              }                                blens[border[index++]] = b & 7;                                b >>= 3; k -= 3;                          }                            while (index < 19)                          {                              blens[border[index++]] = 0;                          }                            bb[0] = 7;                          t = inftree.inflate_trees_bits(blens' bb' tb' hufts' _codec);                          if (t != ZlibConstants.Z_OK)                          {                              r = t;                              if (r == ZlibConstants.Z_DATA_ERROR)                              {                                  blens = null;                                  mode = InflateBlockMode.BAD;                              }                                bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                            index = 0;                          mode = InflateBlockMode.DTREE;                          goto case InflateBlockMode.DTREE;                        case InflateBlockMode.DTREE:                          while (true)                          {                              t = table;                              if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)))                              {                                  break;                              }                                int i' j' c;                                t = bb[0];                                while (k < t)                              {                                  if (n != 0)                                  {                                      r = ZlibConstants.Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                                    n--;                                  b |= (_codec.InputBuffer[p++] & 0xff) << k;                                  k += 8;                              }                                t = hufts[(tb[0] + (b & InternalInflateConstants.InflateMask[t])) * 3 + 1];                              c = hufts[(tb[0] + (b & InternalInflateConstants.InflateMask[t])) * 3 + 2];                                if (c < 16)                              {                                  b >>= t; k -= t;                                  blens[index++] = c;                              }                              else                              {                                  // c == 16..18                                  i = c == 18 ? 7 : c - 14;                                  j = c == 18 ? 11 : 3;                                    while (k < (t + i))                                  {                                      if (n != 0)                                      {                                          r = ZlibConstants.Z_OK;                                      }                                      else                                      {                                          bitb = b; bitk = k;                                          _codec.AvailableBytesIn = n;                                          _codec.TotalBytesIn += p - _codec.NextIn;                                          _codec.NextIn = p;                                          writeAt = q;                                          return Flush(r);                                      }                                        n--;                                      b |= (_codec.InputBuffer[p++] & 0xff) << k;                                      k += 8;                                  }                                    b >>= t; k -= t;                                    j += (b & InternalInflateConstants.InflateMask[i]);                                    b >>= i; k -= i;                                    i = index;                                  t = table;                                  if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1))                                  {                                      blens = null;                                      mode = InflateBlockMode.BAD;                                      _codec.Message = "invalid bit length repeat";                                      r = ZlibConstants.Z_DATA_ERROR;                                        bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                                    c = (c == 16) ? blens[i-1] : 0;                                  do                                  {                                      blens[i++] = c;                                  }                                  while (--j != 0);                                  index = i;                              }                          }                            tb[0] = -1;                          {                              int[] bl = new int[] { 9 };  // must be <= 9 for lookahead assumptions                              int[] bd = new int[] { 6 }; // must be <= 9 for lookahead assumptions                              int[] tl = new int[1];                              int[] td = new int[1];                                t = table;                              t = inftree.inflate_trees_dynamic(257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' _codec);                                if (t != ZlibConstants.Z_OK)                              {                                  if (t == ZlibConstants.Z_DATA_ERROR)                                  {                                      blens = null;                                      mode = InflateBlockMode.BAD;                                  }                                  r = t;                                    bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                              codes.Init(bl[0]' bd[0]' hufts' tl[0]' hufts' td[0]);                          }                          mode = InflateBlockMode.CODES;                          goto case InflateBlockMode.CODES;                        case InflateBlockMode.CODES:                          bitb = b; bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                            r = codes.Process(this' r);                          if (r != ZlibConstants.Z_STREAM_END)                          {                              return Flush(r);                          }                            r = ZlibConstants.Z_OK;                          p = _codec.NextIn;                          n = _codec.AvailableBytesIn;                          b = bitb;                          k = bitk;                          q = writeAt;                          m = (int)(q < readAt ? readAt - q - 1 : end - q);                            if (last == 0)                          {                              mode = InflateBlockMode.TYPE;                              break;                          }                          mode = InflateBlockMode.DRY;                          goto case InflateBlockMode.DRY;                        case InflateBlockMode.DRY:                          writeAt = q;                          r = Flush(r);                          q = writeAt; m = (int)(q < readAt ? readAt - q - 1 : end - q);                          if (readAt != writeAt)                          {                              bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                          mode = InflateBlockMode.DONE;                          goto case InflateBlockMode.DONE;                        case InflateBlockMode.DONE:                          r = ZlibConstants.Z_STREAM_END;                          bitb = b;                          bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                          return Flush(r);                        case InflateBlockMode.BAD:                          r = ZlibConstants.Z_DATA_ERROR;                            bitb = b; bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                          return Flush(r);                          default:                          r = ZlibConstants.Z_STREAM_ERROR;                            bitb = b; bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                          return Flush(r);                  }
Magic Number,Ionic.Zlib,InflateBlocks,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zlib.Shared\Inflate.cs,Process,The following statement contains a magic number: switch (mode)                  {                      case InflateBlockMode.TYPE:                            while (k < (3))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                                n--;                              b |= (_codec.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                          t = (int)(b & 7);                          last = t & 1;                            switch ((uint)t >> 1)                          {                              case 0:  // stored                                  b >>= 3; k -= (3);                                  t = k & 7; // go to byte boundary                                  b >>= t; k -= t;                                  mode = InflateBlockMode.LENS; // get length of stored block                                  break;                                case 1:  // fixed                                  int[] bl = new int[1];                                  int[] bd = new int[1];                                  int[][] tl = new int[1][];                                  int[][] td = new int[1][];                                  InfTree.inflate_trees_fixed(bl' bd' tl' td' _codec);                                  codes.Init(bl[0]' bd[0]' tl[0]' 0' td[0]' 0);                                  b >>= 3; k -= 3;                                  mode = InflateBlockMode.CODES;                                  break;                                case 2:  // dynamic                                  b >>= 3; k -= 3;                                  mode = InflateBlockMode.TABLE;                                  break;                                case 3:  // illegal                                  b >>= 3; k -= 3;                                  mode = InflateBlockMode.BAD;                                  _codec.Message = "invalid block type";                                  r = ZlibConstants.Z_DATA_ERROR;                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                          }                          break;                        case InflateBlockMode.LENS:                            while (k < (32))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                              ;                              n--;                              b |= (_codec.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            if ( ( ((~b)>>16) & 0xffff) != (b & 0xffff))                          {                              mode = InflateBlockMode.BAD;                              _codec.Message = "invalid stored block lengths";                              r = ZlibConstants.Z_DATA_ERROR;                                bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                          left = (b & 0xffff);                          b = k = 0; // dump bits                          mode = left != 0 ? InflateBlockMode.STORED : (last != 0 ? InflateBlockMode.DRY : InflateBlockMode.TYPE);                          break;                        case InflateBlockMode.STORED:                          if (n == 0)                          {                              bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                            if (m == 0)                          {                              if (q == end && readAt != 0)                              {                                  q = 0; m = (int)(q < readAt ? readAt - q - 1 : end - q);                              }                              if (m == 0)                              {                                  writeAt = q;                                  r = Flush(r);                                  q = writeAt; m = (int)(q < readAt ? readAt - q - 1 : end - q);                                  if (q == end && readAt != 0)                                  {                                      q = 0; m = (int)(q < readAt ? readAt - q - 1 : end - q);                                  }                                  if (m == 0)                                  {                                      bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                              }                          }                          r = ZlibConstants.Z_OK;                            t = left;                          if (t > n)                              t = n;                          if (t > m)                              t = m;                          Array.Copy(_codec.InputBuffer' p' window' q' t);                          p += t; n -= t;                          q += t; m -= t;                          if ((left -= t) != 0)                              break;                          mode = last != 0 ? InflateBlockMode.DRY : InflateBlockMode.TYPE;                          break;                        case InflateBlockMode.TABLE:                            while (k < (14))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                                n--;                              b |= (_codec.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            table = t = (b & 0x3fff);                          if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29)                          {                              mode = InflateBlockMode.BAD;                              _codec.Message = "too many length or distance symbols";                              r = ZlibConstants.Z_DATA_ERROR;                                bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                          t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);                          if (blens == null || blens.Length < t)                          {                              blens = new int[t];                          }                          else                          {                              Array.Clear(blens' 0' t);                              // for (int i = 0; i < t; i++)                              // {                              //     blens[i] = 0;                              // }                          }                            b >>= 14;                          k -= 14;                              index = 0;                          mode = InflateBlockMode.BTREE;                          goto case InflateBlockMode.BTREE;                        case InflateBlockMode.BTREE:                          while (index < 4 + (table >> 10))                          {                              while (k < (3))                              {                                  if (n != 0)                                  {                                      r = ZlibConstants.Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                                    n--;                                  b |= (_codec.InputBuffer[p++] & 0xff) << k;                                  k += 8;                              }                                blens[border[index++]] = b & 7;                                b >>= 3; k -= 3;                          }                            while (index < 19)                          {                              blens[border[index++]] = 0;                          }                            bb[0] = 7;                          t = inftree.inflate_trees_bits(blens' bb' tb' hufts' _codec);                          if (t != ZlibConstants.Z_OK)                          {                              r = t;                              if (r == ZlibConstants.Z_DATA_ERROR)                              {                                  blens = null;                                  mode = InflateBlockMode.BAD;                              }                                bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                            index = 0;                          mode = InflateBlockMode.DTREE;                          goto case InflateBlockMode.DTREE;                        case InflateBlockMode.DTREE:                          while (true)                          {                              t = table;                              if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)))                              {                                  break;                              }                                int i' j' c;                                t = bb[0];                                while (k < t)                              {                                  if (n != 0)                                  {                                      r = ZlibConstants.Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                                    n--;                                  b |= (_codec.InputBuffer[p++] & 0xff) << k;                                  k += 8;                              }                                t = hufts[(tb[0] + (b & InternalInflateConstants.InflateMask[t])) * 3 + 1];                              c = hufts[(tb[0] + (b & InternalInflateConstants.InflateMask[t])) * 3 + 2];                                if (c < 16)                              {                                  b >>= t; k -= t;                                  blens[index++] = c;                              }                              else                              {                                  // c == 16..18                                  i = c == 18 ? 7 : c - 14;                                  j = c == 18 ? 11 : 3;                                    while (k < (t + i))                                  {                                      if (n != 0)                                      {                                          r = ZlibConstants.Z_OK;                                      }                                      else                                      {                                          bitb = b; bitk = k;                                          _codec.AvailableBytesIn = n;                                          _codec.TotalBytesIn += p - _codec.NextIn;                                          _codec.NextIn = p;                                          writeAt = q;                                          return Flush(r);                                      }                                        n--;                                      b |= (_codec.InputBuffer[p++] & 0xff) << k;                                      k += 8;                                  }                                    b >>= t; k -= t;                                    j += (b & InternalInflateConstants.InflateMask[i]);                                    b >>= i; k -= i;                                    i = index;                                  t = table;                                  if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1))                                  {                                      blens = null;                                      mode = InflateBlockMode.BAD;                                      _codec.Message = "invalid bit length repeat";                                      r = ZlibConstants.Z_DATA_ERROR;                                        bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                                    c = (c == 16) ? blens[i-1] : 0;                                  do                                  {                                      blens[i++] = c;                                  }                                  while (--j != 0);                                  index = i;                              }                          }                            tb[0] = -1;                          {                              int[] bl = new int[] { 9 };  // must be <= 9 for lookahead assumptions                              int[] bd = new int[] { 6 }; // must be <= 9 for lookahead assumptions                              int[] tl = new int[1];                              int[] td = new int[1];                                t = table;                              t = inftree.inflate_trees_dynamic(257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' _codec);                                if (t != ZlibConstants.Z_OK)                              {                                  if (t == ZlibConstants.Z_DATA_ERROR)                                  {                                      blens = null;                                      mode = InflateBlockMode.BAD;                                  }                                  r = t;                                    bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                              codes.Init(bl[0]' bd[0]' hufts' tl[0]' hufts' td[0]);                          }                          mode = InflateBlockMode.CODES;                          goto case InflateBlockMode.CODES;                        case InflateBlockMode.CODES:                          bitb = b; bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                            r = codes.Process(this' r);                          if (r != ZlibConstants.Z_STREAM_END)                          {                              return Flush(r);                          }                            r = ZlibConstants.Z_OK;                          p = _codec.NextIn;                          n = _codec.AvailableBytesIn;                          b = bitb;                          k = bitk;                          q = writeAt;                          m = (int)(q < readAt ? readAt - q - 1 : end - q);                            if (last == 0)                          {                              mode = InflateBlockMode.TYPE;                              break;                          }                          mode = InflateBlockMode.DRY;                          goto case InflateBlockMode.DRY;                        case InflateBlockMode.DRY:                          writeAt = q;                          r = Flush(r);                          q = writeAt; m = (int)(q < readAt ? readAt - q - 1 : end - q);                          if (readAt != writeAt)                          {                              bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                          mode = InflateBlockMode.DONE;                          goto case InflateBlockMode.DONE;                        case InflateBlockMode.DONE:                          r = ZlibConstants.Z_STREAM_END;                          bitb = b;                          bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                          return Flush(r);                        case InflateBlockMode.BAD:                          r = ZlibConstants.Z_DATA_ERROR;                            bitb = b; bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                          return Flush(r);                          default:                          r = ZlibConstants.Z_STREAM_ERROR;                            bitb = b; bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                          return Flush(r);                  }
Magic Number,Ionic.Zlib,InflateBlocks,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zlib.Shared\Inflate.cs,Process,The following statement contains a magic number: switch (mode)                  {                      case InflateBlockMode.TYPE:                            while (k < (3))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                                n--;                              b |= (_codec.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                          t = (int)(b & 7);                          last = t & 1;                            switch ((uint)t >> 1)                          {                              case 0:  // stored                                  b >>= 3; k -= (3);                                  t = k & 7; // go to byte boundary                                  b >>= t; k -= t;                                  mode = InflateBlockMode.LENS; // get length of stored block                                  break;                                case 1:  // fixed                                  int[] bl = new int[1];                                  int[] bd = new int[1];                                  int[][] tl = new int[1][];                                  int[][] td = new int[1][];                                  InfTree.inflate_trees_fixed(bl' bd' tl' td' _codec);                                  codes.Init(bl[0]' bd[0]' tl[0]' 0' td[0]' 0);                                  b >>= 3; k -= 3;                                  mode = InflateBlockMode.CODES;                                  break;                                case 2:  // dynamic                                  b >>= 3; k -= 3;                                  mode = InflateBlockMode.TABLE;                                  break;                                case 3:  // illegal                                  b >>= 3; k -= 3;                                  mode = InflateBlockMode.BAD;                                  _codec.Message = "invalid block type";                                  r = ZlibConstants.Z_DATA_ERROR;                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                          }                          break;                        case InflateBlockMode.LENS:                            while (k < (32))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                              ;                              n--;                              b |= (_codec.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            if ( ( ((~b)>>16) & 0xffff) != (b & 0xffff))                          {                              mode = InflateBlockMode.BAD;                              _codec.Message = "invalid stored block lengths";                              r = ZlibConstants.Z_DATA_ERROR;                                bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                          left = (b & 0xffff);                          b = k = 0; // dump bits                          mode = left != 0 ? InflateBlockMode.STORED : (last != 0 ? InflateBlockMode.DRY : InflateBlockMode.TYPE);                          break;                        case InflateBlockMode.STORED:                          if (n == 0)                          {                              bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                            if (m == 0)                          {                              if (q == end && readAt != 0)                              {                                  q = 0; m = (int)(q < readAt ? readAt - q - 1 : end - q);                              }                              if (m == 0)                              {                                  writeAt = q;                                  r = Flush(r);                                  q = writeAt; m = (int)(q < readAt ? readAt - q - 1 : end - q);                                  if (q == end && readAt != 0)                                  {                                      q = 0; m = (int)(q < readAt ? readAt - q - 1 : end - q);                                  }                                  if (m == 0)                                  {                                      bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                              }                          }                          r = ZlibConstants.Z_OK;                            t = left;                          if (t > n)                              t = n;                          if (t > m)                              t = m;                          Array.Copy(_codec.InputBuffer' p' window' q' t);                          p += t; n -= t;                          q += t; m -= t;                          if ((left -= t) != 0)                              break;                          mode = last != 0 ? InflateBlockMode.DRY : InflateBlockMode.TYPE;                          break;                        case InflateBlockMode.TABLE:                            while (k < (14))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                                n--;                              b |= (_codec.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            table = t = (b & 0x3fff);                          if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29)                          {                              mode = InflateBlockMode.BAD;                              _codec.Message = "too many length or distance symbols";                              r = ZlibConstants.Z_DATA_ERROR;                                bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                          t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);                          if (blens == null || blens.Length < t)                          {                              blens = new int[t];                          }                          else                          {                              Array.Clear(blens' 0' t);                              // for (int i = 0; i < t; i++)                              // {                              //     blens[i] = 0;                              // }                          }                            b >>= 14;                          k -= 14;                              index = 0;                          mode = InflateBlockMode.BTREE;                          goto case InflateBlockMode.BTREE;                        case InflateBlockMode.BTREE:                          while (index < 4 + (table >> 10))                          {                              while (k < (3))                              {                                  if (n != 0)                                  {                                      r = ZlibConstants.Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                                    n--;                                  b |= (_codec.InputBuffer[p++] & 0xff) << k;                                  k += 8;                              }                                blens[border[index++]] = b & 7;                                b >>= 3; k -= 3;                          }                            while (index < 19)                          {                              blens[border[index++]] = 0;                          }                            bb[0] = 7;                          t = inftree.inflate_trees_bits(blens' bb' tb' hufts' _codec);                          if (t != ZlibConstants.Z_OK)                          {                              r = t;                              if (r == ZlibConstants.Z_DATA_ERROR)                              {                                  blens = null;                                  mode = InflateBlockMode.BAD;                              }                                bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                            index = 0;                          mode = InflateBlockMode.DTREE;                          goto case InflateBlockMode.DTREE;                        case InflateBlockMode.DTREE:                          while (true)                          {                              t = table;                              if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)))                              {                                  break;                              }                                int i' j' c;                                t = bb[0];                                while (k < t)                              {                                  if (n != 0)                                  {                                      r = ZlibConstants.Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                                    n--;                                  b |= (_codec.InputBuffer[p++] & 0xff) << k;                                  k += 8;                              }                                t = hufts[(tb[0] + (b & InternalInflateConstants.InflateMask[t])) * 3 + 1];                              c = hufts[(tb[0] + (b & InternalInflateConstants.InflateMask[t])) * 3 + 2];                                if (c < 16)                              {                                  b >>= t; k -= t;                                  blens[index++] = c;                              }                              else                              {                                  // c == 16..18                                  i = c == 18 ? 7 : c - 14;                                  j = c == 18 ? 11 : 3;                                    while (k < (t + i))                                  {                                      if (n != 0)                                      {                                          r = ZlibConstants.Z_OK;                                      }                                      else                                      {                                          bitb = b; bitk = k;                                          _codec.AvailableBytesIn = n;                                          _codec.TotalBytesIn += p - _codec.NextIn;                                          _codec.NextIn = p;                                          writeAt = q;                                          return Flush(r);                                      }                                        n--;                                      b |= (_codec.InputBuffer[p++] & 0xff) << k;                                      k += 8;                                  }                                    b >>= t; k -= t;                                    j += (b & InternalInflateConstants.InflateMask[i]);                                    b >>= i; k -= i;                                    i = index;                                  t = table;                                  if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1))                                  {                                      blens = null;                                      mode = InflateBlockMode.BAD;                                      _codec.Message = "invalid bit length repeat";                                      r = ZlibConstants.Z_DATA_ERROR;                                        bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                                    c = (c == 16) ? blens[i-1] : 0;                                  do                                  {                                      blens[i++] = c;                                  }                                  while (--j != 0);                                  index = i;                              }                          }                            tb[0] = -1;                          {                              int[] bl = new int[] { 9 };  // must be <= 9 for lookahead assumptions                              int[] bd = new int[] { 6 }; // must be <= 9 for lookahead assumptions                              int[] tl = new int[1];                              int[] td = new int[1];                                t = table;                              t = inftree.inflate_trees_dynamic(257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' _codec);                                if (t != ZlibConstants.Z_OK)                              {                                  if (t == ZlibConstants.Z_DATA_ERROR)                                  {                                      blens = null;                                      mode = InflateBlockMode.BAD;                                  }                                  r = t;                                    bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                              codes.Init(bl[0]' bd[0]' hufts' tl[0]' hufts' td[0]);                          }                          mode = InflateBlockMode.CODES;                          goto case InflateBlockMode.CODES;                        case InflateBlockMode.CODES:                          bitb = b; bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                            r = codes.Process(this' r);                          if (r != ZlibConstants.Z_STREAM_END)                          {                              return Flush(r);                          }                            r = ZlibConstants.Z_OK;                          p = _codec.NextIn;                          n = _codec.AvailableBytesIn;                          b = bitb;                          k = bitk;                          q = writeAt;                          m = (int)(q < readAt ? readAt - q - 1 : end - q);                            if (last == 0)                          {                              mode = InflateBlockMode.TYPE;                              break;                          }                          mode = InflateBlockMode.DRY;                          goto case InflateBlockMode.DRY;                        case InflateBlockMode.DRY:                          writeAt = q;                          r = Flush(r);                          q = writeAt; m = (int)(q < readAt ? readAt - q - 1 : end - q);                          if (readAt != writeAt)                          {                              bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                          mode = InflateBlockMode.DONE;                          goto case InflateBlockMode.DONE;                        case InflateBlockMode.DONE:                          r = ZlibConstants.Z_STREAM_END;                          bitb = b;                          bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                          return Flush(r);                        case InflateBlockMode.BAD:                          r = ZlibConstants.Z_DATA_ERROR;                            bitb = b; bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                          return Flush(r);                          default:                          r = ZlibConstants.Z_STREAM_ERROR;                            bitb = b; bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                          return Flush(r);                  }
Magic Number,Ionic.Zlib,InflateBlocks,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zlib.Shared\Inflate.cs,Process,The following statement contains a magic number: switch (mode)                  {                      case InflateBlockMode.TYPE:                            while (k < (3))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                                n--;                              b |= (_codec.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                          t = (int)(b & 7);                          last = t & 1;                            switch ((uint)t >> 1)                          {                              case 0:  // stored                                  b >>= 3; k -= (3);                                  t = k & 7; // go to byte boundary                                  b >>= t; k -= t;                                  mode = InflateBlockMode.LENS; // get length of stored block                                  break;                                case 1:  // fixed                                  int[] bl = new int[1];                                  int[] bd = new int[1];                                  int[][] tl = new int[1][];                                  int[][] td = new int[1][];                                  InfTree.inflate_trees_fixed(bl' bd' tl' td' _codec);                                  codes.Init(bl[0]' bd[0]' tl[0]' 0' td[0]' 0);                                  b >>= 3; k -= 3;                                  mode = InflateBlockMode.CODES;                                  break;                                case 2:  // dynamic                                  b >>= 3; k -= 3;                                  mode = InflateBlockMode.TABLE;                                  break;                                case 3:  // illegal                                  b >>= 3; k -= 3;                                  mode = InflateBlockMode.BAD;                                  _codec.Message = "invalid block type";                                  r = ZlibConstants.Z_DATA_ERROR;                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                          }                          break;                        case InflateBlockMode.LENS:                            while (k < (32))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                              ;                              n--;                              b |= (_codec.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            if ( ( ((~b)>>16) & 0xffff) != (b & 0xffff))                          {                              mode = InflateBlockMode.BAD;                              _codec.Message = "invalid stored block lengths";                              r = ZlibConstants.Z_DATA_ERROR;                                bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                          left = (b & 0xffff);                          b = k = 0; // dump bits                          mode = left != 0 ? InflateBlockMode.STORED : (last != 0 ? InflateBlockMode.DRY : InflateBlockMode.TYPE);                          break;                        case InflateBlockMode.STORED:                          if (n == 0)                          {                              bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                            if (m == 0)                          {                              if (q == end && readAt != 0)                              {                                  q = 0; m = (int)(q < readAt ? readAt - q - 1 : end - q);                              }                              if (m == 0)                              {                                  writeAt = q;                                  r = Flush(r);                                  q = writeAt; m = (int)(q < readAt ? readAt - q - 1 : end - q);                                  if (q == end && readAt != 0)                                  {                                      q = 0; m = (int)(q < readAt ? readAt - q - 1 : end - q);                                  }                                  if (m == 0)                                  {                                      bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                              }                          }                          r = ZlibConstants.Z_OK;                            t = left;                          if (t > n)                              t = n;                          if (t > m)                              t = m;                          Array.Copy(_codec.InputBuffer' p' window' q' t);                          p += t; n -= t;                          q += t; m -= t;                          if ((left -= t) != 0)                              break;                          mode = last != 0 ? InflateBlockMode.DRY : InflateBlockMode.TYPE;                          break;                        case InflateBlockMode.TABLE:                            while (k < (14))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                                n--;                              b |= (_codec.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            table = t = (b & 0x3fff);                          if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29)                          {                              mode = InflateBlockMode.BAD;                              _codec.Message = "too many length or distance symbols";                              r = ZlibConstants.Z_DATA_ERROR;                                bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                          t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);                          if (blens == null || blens.Length < t)                          {                              blens = new int[t];                          }                          else                          {                              Array.Clear(blens' 0' t);                              // for (int i = 0; i < t; i++)                              // {                              //     blens[i] = 0;                              // }                          }                            b >>= 14;                          k -= 14;                              index = 0;                          mode = InflateBlockMode.BTREE;                          goto case InflateBlockMode.BTREE;                        case InflateBlockMode.BTREE:                          while (index < 4 + (table >> 10))                          {                              while (k < (3))                              {                                  if (n != 0)                                  {                                      r = ZlibConstants.Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                                    n--;                                  b |= (_codec.InputBuffer[p++] & 0xff) << k;                                  k += 8;                              }                                blens[border[index++]] = b & 7;                                b >>= 3; k -= 3;                          }                            while (index < 19)                          {                              blens[border[index++]] = 0;                          }                            bb[0] = 7;                          t = inftree.inflate_trees_bits(blens' bb' tb' hufts' _codec);                          if (t != ZlibConstants.Z_OK)                          {                              r = t;                              if (r == ZlibConstants.Z_DATA_ERROR)                              {                                  blens = null;                                  mode = InflateBlockMode.BAD;                              }                                bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                            index = 0;                          mode = InflateBlockMode.DTREE;                          goto case InflateBlockMode.DTREE;                        case InflateBlockMode.DTREE:                          while (true)                          {                              t = table;                              if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)))                              {                                  break;                              }                                int i' j' c;                                t = bb[0];                                while (k < t)                              {                                  if (n != 0)                                  {                                      r = ZlibConstants.Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                                    n--;                                  b |= (_codec.InputBuffer[p++] & 0xff) << k;                                  k += 8;                              }                                t = hufts[(tb[0] + (b & InternalInflateConstants.InflateMask[t])) * 3 + 1];                              c = hufts[(tb[0] + (b & InternalInflateConstants.InflateMask[t])) * 3 + 2];                                if (c < 16)                              {                                  b >>= t; k -= t;                                  blens[index++] = c;                              }                              else                              {                                  // c == 16..18                                  i = c == 18 ? 7 : c - 14;                                  j = c == 18 ? 11 : 3;                                    while (k < (t + i))                                  {                                      if (n != 0)                                      {                                          r = ZlibConstants.Z_OK;                                      }                                      else                                      {                                          bitb = b; bitk = k;                                          _codec.AvailableBytesIn = n;                                          _codec.TotalBytesIn += p - _codec.NextIn;                                          _codec.NextIn = p;                                          writeAt = q;                                          return Flush(r);                                      }                                        n--;                                      b |= (_codec.InputBuffer[p++] & 0xff) << k;                                      k += 8;                                  }                                    b >>= t; k -= t;                                    j += (b & InternalInflateConstants.InflateMask[i]);                                    b >>= i; k -= i;                                    i = index;                                  t = table;                                  if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1))                                  {                                      blens = null;                                      mode = InflateBlockMode.BAD;                                      _codec.Message = "invalid bit length repeat";                                      r = ZlibConstants.Z_DATA_ERROR;                                        bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                                    c = (c == 16) ? blens[i-1] : 0;                                  do                                  {                                      blens[i++] = c;                                  }                                  while (--j != 0);                                  index = i;                              }                          }                            tb[0] = -1;                          {                              int[] bl = new int[] { 9 };  // must be <= 9 for lookahead assumptions                              int[] bd = new int[] { 6 }; // must be <= 9 for lookahead assumptions                              int[] tl = new int[1];                              int[] td = new int[1];                                t = table;                              t = inftree.inflate_trees_dynamic(257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' _codec);                                if (t != ZlibConstants.Z_OK)                              {                                  if (t == ZlibConstants.Z_DATA_ERROR)                                  {                                      blens = null;                                      mode = InflateBlockMode.BAD;                                  }                                  r = t;                                    bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                              codes.Init(bl[0]' bd[0]' hufts' tl[0]' hufts' td[0]);                          }                          mode = InflateBlockMode.CODES;                          goto case InflateBlockMode.CODES;                        case InflateBlockMode.CODES:                          bitb = b; bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                            r = codes.Process(this' r);                          if (r != ZlibConstants.Z_STREAM_END)                          {                              return Flush(r);                          }                            r = ZlibConstants.Z_OK;                          p = _codec.NextIn;                          n = _codec.AvailableBytesIn;                          b = bitb;                          k = bitk;                          q = writeAt;                          m = (int)(q < readAt ? readAt - q - 1 : end - q);                            if (last == 0)                          {                              mode = InflateBlockMode.TYPE;                              break;                          }                          mode = InflateBlockMode.DRY;                          goto case InflateBlockMode.DRY;                        case InflateBlockMode.DRY:                          writeAt = q;                          r = Flush(r);                          q = writeAt; m = (int)(q < readAt ? readAt - q - 1 : end - q);                          if (readAt != writeAt)                          {                              bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                          mode = InflateBlockMode.DONE;                          goto case InflateBlockMode.DONE;                        case InflateBlockMode.DONE:                          r = ZlibConstants.Z_STREAM_END;                          bitb = b;                          bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                          return Flush(r);                        case InflateBlockMode.BAD:                          r = ZlibConstants.Z_DATA_ERROR;                            bitb = b; bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                          return Flush(r);                          default:                          r = ZlibConstants.Z_STREAM_ERROR;                            bitb = b; bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                          return Flush(r);                  }
Magic Number,Ionic.Zlib,InflateBlocks,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zlib.Shared\Inflate.cs,Process,The following statement contains a magic number: switch (mode)                  {                      case InflateBlockMode.TYPE:                            while (k < (3))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                                n--;                              b |= (_codec.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                          t = (int)(b & 7);                          last = t & 1;                            switch ((uint)t >> 1)                          {                              case 0:  // stored                                  b >>= 3; k -= (3);                                  t = k & 7; // go to byte boundary                                  b >>= t; k -= t;                                  mode = InflateBlockMode.LENS; // get length of stored block                                  break;                                case 1:  // fixed                                  int[] bl = new int[1];                                  int[] bd = new int[1];                                  int[][] tl = new int[1][];                                  int[][] td = new int[1][];                                  InfTree.inflate_trees_fixed(bl' bd' tl' td' _codec);                                  codes.Init(bl[0]' bd[0]' tl[0]' 0' td[0]' 0);                                  b >>= 3; k -= 3;                                  mode = InflateBlockMode.CODES;                                  break;                                case 2:  // dynamic                                  b >>= 3; k -= 3;                                  mode = InflateBlockMode.TABLE;                                  break;                                case 3:  // illegal                                  b >>= 3; k -= 3;                                  mode = InflateBlockMode.BAD;                                  _codec.Message = "invalid block type";                                  r = ZlibConstants.Z_DATA_ERROR;                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                          }                          break;                        case InflateBlockMode.LENS:                            while (k < (32))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                              ;                              n--;                              b |= (_codec.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            if ( ( ((~b)>>16) & 0xffff) != (b & 0xffff))                          {                              mode = InflateBlockMode.BAD;                              _codec.Message = "invalid stored block lengths";                              r = ZlibConstants.Z_DATA_ERROR;                                bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                          left = (b & 0xffff);                          b = k = 0; // dump bits                          mode = left != 0 ? InflateBlockMode.STORED : (last != 0 ? InflateBlockMode.DRY : InflateBlockMode.TYPE);                          break;                        case InflateBlockMode.STORED:                          if (n == 0)                          {                              bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                            if (m == 0)                          {                              if (q == end && readAt != 0)                              {                                  q = 0; m = (int)(q < readAt ? readAt - q - 1 : end - q);                              }                              if (m == 0)                              {                                  writeAt = q;                                  r = Flush(r);                                  q = writeAt; m = (int)(q < readAt ? readAt - q - 1 : end - q);                                  if (q == end && readAt != 0)                                  {                                      q = 0; m = (int)(q < readAt ? readAt - q - 1 : end - q);                                  }                                  if (m == 0)                                  {                                      bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                              }                          }                          r = ZlibConstants.Z_OK;                            t = left;                          if (t > n)                              t = n;                          if (t > m)                              t = m;                          Array.Copy(_codec.InputBuffer' p' window' q' t);                          p += t; n -= t;                          q += t; m -= t;                          if ((left -= t) != 0)                              break;                          mode = last != 0 ? InflateBlockMode.DRY : InflateBlockMode.TYPE;                          break;                        case InflateBlockMode.TABLE:                            while (k < (14))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                                n--;                              b |= (_codec.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            table = t = (b & 0x3fff);                          if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29)                          {                              mode = InflateBlockMode.BAD;                              _codec.Message = "too many length or distance symbols";                              r = ZlibConstants.Z_DATA_ERROR;                                bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                          t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);                          if (blens == null || blens.Length < t)                          {                              blens = new int[t];                          }                          else                          {                              Array.Clear(blens' 0' t);                              // for (int i = 0; i < t; i++)                              // {                              //     blens[i] = 0;                              // }                          }                            b >>= 14;                          k -= 14;                              index = 0;                          mode = InflateBlockMode.BTREE;                          goto case InflateBlockMode.BTREE;                        case InflateBlockMode.BTREE:                          while (index < 4 + (table >> 10))                          {                              while (k < (3))                              {                                  if (n != 0)                                  {                                      r = ZlibConstants.Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                                    n--;                                  b |= (_codec.InputBuffer[p++] & 0xff) << k;                                  k += 8;                              }                                blens[border[index++]] = b & 7;                                b >>= 3; k -= 3;                          }                            while (index < 19)                          {                              blens[border[index++]] = 0;                          }                            bb[0] = 7;                          t = inftree.inflate_trees_bits(blens' bb' tb' hufts' _codec);                          if (t != ZlibConstants.Z_OK)                          {                              r = t;                              if (r == ZlibConstants.Z_DATA_ERROR)                              {                                  blens = null;                                  mode = InflateBlockMode.BAD;                              }                                bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                            index = 0;                          mode = InflateBlockMode.DTREE;                          goto case InflateBlockMode.DTREE;                        case InflateBlockMode.DTREE:                          while (true)                          {                              t = table;                              if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)))                              {                                  break;                              }                                int i' j' c;                                t = bb[0];                                while (k < t)                              {                                  if (n != 0)                                  {                                      r = ZlibConstants.Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                                    n--;                                  b |= (_codec.InputBuffer[p++] & 0xff) << k;                                  k += 8;                              }                                t = hufts[(tb[0] + (b & InternalInflateConstants.InflateMask[t])) * 3 + 1];                              c = hufts[(tb[0] + (b & InternalInflateConstants.InflateMask[t])) * 3 + 2];                                if (c < 16)                              {                                  b >>= t; k -= t;                                  blens[index++] = c;                              }                              else                              {                                  // c == 16..18                                  i = c == 18 ? 7 : c - 14;                                  j = c == 18 ? 11 : 3;                                    while (k < (t + i))                                  {                                      if (n != 0)                                      {                                          r = ZlibConstants.Z_OK;                                      }                                      else                                      {                                          bitb = b; bitk = k;                                          _codec.AvailableBytesIn = n;                                          _codec.TotalBytesIn += p - _codec.NextIn;                                          _codec.NextIn = p;                                          writeAt = q;                                          return Flush(r);                                      }                                        n--;                                      b |= (_codec.InputBuffer[p++] & 0xff) << k;                                      k += 8;                                  }                                    b >>= t; k -= t;                                    j += (b & InternalInflateConstants.InflateMask[i]);                                    b >>= i; k -= i;                                    i = index;                                  t = table;                                  if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1))                                  {                                      blens = null;                                      mode = InflateBlockMode.BAD;                                      _codec.Message = "invalid bit length repeat";                                      r = ZlibConstants.Z_DATA_ERROR;                                        bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                                    c = (c == 16) ? blens[i-1] : 0;                                  do                                  {                                      blens[i++] = c;                                  }                                  while (--j != 0);                                  index = i;                              }                          }                            tb[0] = -1;                          {                              int[] bl = new int[] { 9 };  // must be <= 9 for lookahead assumptions                              int[] bd = new int[] { 6 }; // must be <= 9 for lookahead assumptions                              int[] tl = new int[1];                              int[] td = new int[1];                                t = table;                              t = inftree.inflate_trees_dynamic(257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' _codec);                                if (t != ZlibConstants.Z_OK)                              {                                  if (t == ZlibConstants.Z_DATA_ERROR)                                  {                                      blens = null;                                      mode = InflateBlockMode.BAD;                                  }                                  r = t;                                    bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                              codes.Init(bl[0]' bd[0]' hufts' tl[0]' hufts' td[0]);                          }                          mode = InflateBlockMode.CODES;                          goto case InflateBlockMode.CODES;                        case InflateBlockMode.CODES:                          bitb = b; bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                            r = codes.Process(this' r);                          if (r != ZlibConstants.Z_STREAM_END)                          {                              return Flush(r);                          }                            r = ZlibConstants.Z_OK;                          p = _codec.NextIn;                          n = _codec.AvailableBytesIn;                          b = bitb;                          k = bitk;                          q = writeAt;                          m = (int)(q < readAt ? readAt - q - 1 : end - q);                            if (last == 0)                          {                              mode = InflateBlockMode.TYPE;                              break;                          }                          mode = InflateBlockMode.DRY;                          goto case InflateBlockMode.DRY;                        case InflateBlockMode.DRY:                          writeAt = q;                          r = Flush(r);                          q = writeAt; m = (int)(q < readAt ? readAt - q - 1 : end - q);                          if (readAt != writeAt)                          {                              bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                          mode = InflateBlockMode.DONE;                          goto case InflateBlockMode.DONE;                        case InflateBlockMode.DONE:                          r = ZlibConstants.Z_STREAM_END;                          bitb = b;                          bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                          return Flush(r);                        case InflateBlockMode.BAD:                          r = ZlibConstants.Z_DATA_ERROR;                            bitb = b; bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                          return Flush(r);                          default:                          r = ZlibConstants.Z_STREAM_ERROR;                            bitb = b; bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                          return Flush(r);                  }
Magic Number,Ionic.Zlib,InflateBlocks,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zlib.Shared\Inflate.cs,Process,The following statement contains a magic number: switch (mode)                  {                      case InflateBlockMode.TYPE:                            while (k < (3))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                                n--;                              b |= (_codec.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                          t = (int)(b & 7);                          last = t & 1;                            switch ((uint)t >> 1)                          {                              case 0:  // stored                                  b >>= 3; k -= (3);                                  t = k & 7; // go to byte boundary                                  b >>= t; k -= t;                                  mode = InflateBlockMode.LENS; // get length of stored block                                  break;                                case 1:  // fixed                                  int[] bl = new int[1];                                  int[] bd = new int[1];                                  int[][] tl = new int[1][];                                  int[][] td = new int[1][];                                  InfTree.inflate_trees_fixed(bl' bd' tl' td' _codec);                                  codes.Init(bl[0]' bd[0]' tl[0]' 0' td[0]' 0);                                  b >>= 3; k -= 3;                                  mode = InflateBlockMode.CODES;                                  break;                                case 2:  // dynamic                                  b >>= 3; k -= 3;                                  mode = InflateBlockMode.TABLE;                                  break;                                case 3:  // illegal                                  b >>= 3; k -= 3;                                  mode = InflateBlockMode.BAD;                                  _codec.Message = "invalid block type";                                  r = ZlibConstants.Z_DATA_ERROR;                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                          }                          break;                        case InflateBlockMode.LENS:                            while (k < (32))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                              ;                              n--;                              b |= (_codec.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            if ( ( ((~b)>>16) & 0xffff) != (b & 0xffff))                          {                              mode = InflateBlockMode.BAD;                              _codec.Message = "invalid stored block lengths";                              r = ZlibConstants.Z_DATA_ERROR;                                bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                          left = (b & 0xffff);                          b = k = 0; // dump bits                          mode = left != 0 ? InflateBlockMode.STORED : (last != 0 ? InflateBlockMode.DRY : InflateBlockMode.TYPE);                          break;                        case InflateBlockMode.STORED:                          if (n == 0)                          {                              bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                            if (m == 0)                          {                              if (q == end && readAt != 0)                              {                                  q = 0; m = (int)(q < readAt ? readAt - q - 1 : end - q);                              }                              if (m == 0)                              {                                  writeAt = q;                                  r = Flush(r);                                  q = writeAt; m = (int)(q < readAt ? readAt - q - 1 : end - q);                                  if (q == end && readAt != 0)                                  {                                      q = 0; m = (int)(q < readAt ? readAt - q - 1 : end - q);                                  }                                  if (m == 0)                                  {                                      bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                              }                          }                          r = ZlibConstants.Z_OK;                            t = left;                          if (t > n)                              t = n;                          if (t > m)                              t = m;                          Array.Copy(_codec.InputBuffer' p' window' q' t);                          p += t; n -= t;                          q += t; m -= t;                          if ((left -= t) != 0)                              break;                          mode = last != 0 ? InflateBlockMode.DRY : InflateBlockMode.TYPE;                          break;                        case InflateBlockMode.TABLE:                            while (k < (14))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                                n--;                              b |= (_codec.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            table = t = (b & 0x3fff);                          if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29)                          {                              mode = InflateBlockMode.BAD;                              _codec.Message = "too many length or distance symbols";                              r = ZlibConstants.Z_DATA_ERROR;                                bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                          t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);                          if (blens == null || blens.Length < t)                          {                              blens = new int[t];                          }                          else                          {                              Array.Clear(blens' 0' t);                              // for (int i = 0; i < t; i++)                              // {                              //     blens[i] = 0;                              // }                          }                            b >>= 14;                          k -= 14;                              index = 0;                          mode = InflateBlockMode.BTREE;                          goto case InflateBlockMode.BTREE;                        case InflateBlockMode.BTREE:                          while (index < 4 + (table >> 10))                          {                              while (k < (3))                              {                                  if (n != 0)                                  {                                      r = ZlibConstants.Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                                    n--;                                  b |= (_codec.InputBuffer[p++] & 0xff) << k;                                  k += 8;                              }                                blens[border[index++]] = b & 7;                                b >>= 3; k -= 3;                          }                            while (index < 19)                          {                              blens[border[index++]] = 0;                          }                            bb[0] = 7;                          t = inftree.inflate_trees_bits(blens' bb' tb' hufts' _codec);                          if (t != ZlibConstants.Z_OK)                          {                              r = t;                              if (r == ZlibConstants.Z_DATA_ERROR)                              {                                  blens = null;                                  mode = InflateBlockMode.BAD;                              }                                bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                            index = 0;                          mode = InflateBlockMode.DTREE;                          goto case InflateBlockMode.DTREE;                        case InflateBlockMode.DTREE:                          while (true)                          {                              t = table;                              if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)))                              {                                  break;                              }                                int i' j' c;                                t = bb[0];                                while (k < t)                              {                                  if (n != 0)                                  {                                      r = ZlibConstants.Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                                    n--;                                  b |= (_codec.InputBuffer[p++] & 0xff) << k;                                  k += 8;                              }                                t = hufts[(tb[0] + (b & InternalInflateConstants.InflateMask[t])) * 3 + 1];                              c = hufts[(tb[0] + (b & InternalInflateConstants.InflateMask[t])) * 3 + 2];                                if (c < 16)                              {                                  b >>= t; k -= t;                                  blens[index++] = c;                              }                              else                              {                                  // c == 16..18                                  i = c == 18 ? 7 : c - 14;                                  j = c == 18 ? 11 : 3;                                    while (k < (t + i))                                  {                                      if (n != 0)                                      {                                          r = ZlibConstants.Z_OK;                                      }                                      else                                      {                                          bitb = b; bitk = k;                                          _codec.AvailableBytesIn = n;                                          _codec.TotalBytesIn += p - _codec.NextIn;                                          _codec.NextIn = p;                                          writeAt = q;                                          return Flush(r);                                      }                                        n--;                                      b |= (_codec.InputBuffer[p++] & 0xff) << k;                                      k += 8;                                  }                                    b >>= t; k -= t;                                    j += (b & InternalInflateConstants.InflateMask[i]);                                    b >>= i; k -= i;                                    i = index;                                  t = table;                                  if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1))                                  {                                      blens = null;                                      mode = InflateBlockMode.BAD;                                      _codec.Message = "invalid bit length repeat";                                      r = ZlibConstants.Z_DATA_ERROR;                                        bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                                    c = (c == 16) ? blens[i-1] : 0;                                  do                                  {                                      blens[i++] = c;                                  }                                  while (--j != 0);                                  index = i;                              }                          }                            tb[0] = -1;                          {                              int[] bl = new int[] { 9 };  // must be <= 9 for lookahead assumptions                              int[] bd = new int[] { 6 }; // must be <= 9 for lookahead assumptions                              int[] tl = new int[1];                              int[] td = new int[1];                                t = table;                              t = inftree.inflate_trees_dynamic(257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' _codec);                                if (t != ZlibConstants.Z_OK)                              {                                  if (t == ZlibConstants.Z_DATA_ERROR)                                  {                                      blens = null;                                      mode = InflateBlockMode.BAD;                                  }                                  r = t;                                    bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                              codes.Init(bl[0]' bd[0]' hufts' tl[0]' hufts' td[0]);                          }                          mode = InflateBlockMode.CODES;                          goto case InflateBlockMode.CODES;                        case InflateBlockMode.CODES:                          bitb = b; bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                            r = codes.Process(this' r);                          if (r != ZlibConstants.Z_STREAM_END)                          {                              return Flush(r);                          }                            r = ZlibConstants.Z_OK;                          p = _codec.NextIn;                          n = _codec.AvailableBytesIn;                          b = bitb;                          k = bitk;                          q = writeAt;                          m = (int)(q < readAt ? readAt - q - 1 : end - q);                            if (last == 0)                          {                              mode = InflateBlockMode.TYPE;                              break;                          }                          mode = InflateBlockMode.DRY;                          goto case InflateBlockMode.DRY;                        case InflateBlockMode.DRY:                          writeAt = q;                          r = Flush(r);                          q = writeAt; m = (int)(q < readAt ? readAt - q - 1 : end - q);                          if (readAt != writeAt)                          {                              bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                          mode = InflateBlockMode.DONE;                          goto case InflateBlockMode.DONE;                        case InflateBlockMode.DONE:                          r = ZlibConstants.Z_STREAM_END;                          bitb = b;                          bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                          return Flush(r);                        case InflateBlockMode.BAD:                          r = ZlibConstants.Z_DATA_ERROR;                            bitb = b; bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                          return Flush(r);                          default:                          r = ZlibConstants.Z_STREAM_ERROR;                            bitb = b; bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                          return Flush(r);                  }
Magic Number,Ionic.Zlib,InflateBlocks,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zlib.Shared\Inflate.cs,Process,The following statement contains a magic number: switch (mode)                  {                      case InflateBlockMode.TYPE:                            while (k < (3))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                                n--;                              b |= (_codec.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                          t = (int)(b & 7);                          last = t & 1;                            switch ((uint)t >> 1)                          {                              case 0:  // stored                                  b >>= 3; k -= (3);                                  t = k & 7; // go to byte boundary                                  b >>= t; k -= t;                                  mode = InflateBlockMode.LENS; // get length of stored block                                  break;                                case 1:  // fixed                                  int[] bl = new int[1];                                  int[] bd = new int[1];                                  int[][] tl = new int[1][];                                  int[][] td = new int[1][];                                  InfTree.inflate_trees_fixed(bl' bd' tl' td' _codec);                                  codes.Init(bl[0]' bd[0]' tl[0]' 0' td[0]' 0);                                  b >>= 3; k -= 3;                                  mode = InflateBlockMode.CODES;                                  break;                                case 2:  // dynamic                                  b >>= 3; k -= 3;                                  mode = InflateBlockMode.TABLE;                                  break;                                case 3:  // illegal                                  b >>= 3; k -= 3;                                  mode = InflateBlockMode.BAD;                                  _codec.Message = "invalid block type";                                  r = ZlibConstants.Z_DATA_ERROR;                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                          }                          break;                        case InflateBlockMode.LENS:                            while (k < (32))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                              ;                              n--;                              b |= (_codec.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            if ( ( ((~b)>>16) & 0xffff) != (b & 0xffff))                          {                              mode = InflateBlockMode.BAD;                              _codec.Message = "invalid stored block lengths";                              r = ZlibConstants.Z_DATA_ERROR;                                bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                          left = (b & 0xffff);                          b = k = 0; // dump bits                          mode = left != 0 ? InflateBlockMode.STORED : (last != 0 ? InflateBlockMode.DRY : InflateBlockMode.TYPE);                          break;                        case InflateBlockMode.STORED:                          if (n == 0)                          {                              bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                            if (m == 0)                          {                              if (q == end && readAt != 0)                              {                                  q = 0; m = (int)(q < readAt ? readAt - q - 1 : end - q);                              }                              if (m == 0)                              {                                  writeAt = q;                                  r = Flush(r);                                  q = writeAt; m = (int)(q < readAt ? readAt - q - 1 : end - q);                                  if (q == end && readAt != 0)                                  {                                      q = 0; m = (int)(q < readAt ? readAt - q - 1 : end - q);                                  }                                  if (m == 0)                                  {                                      bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                              }                          }                          r = ZlibConstants.Z_OK;                            t = left;                          if (t > n)                              t = n;                          if (t > m)                              t = m;                          Array.Copy(_codec.InputBuffer' p' window' q' t);                          p += t; n -= t;                          q += t; m -= t;                          if ((left -= t) != 0)                              break;                          mode = last != 0 ? InflateBlockMode.DRY : InflateBlockMode.TYPE;                          break;                        case InflateBlockMode.TABLE:                            while (k < (14))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                                n--;                              b |= (_codec.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            table = t = (b & 0x3fff);                          if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29)                          {                              mode = InflateBlockMode.BAD;                              _codec.Message = "too many length or distance symbols";                              r = ZlibConstants.Z_DATA_ERROR;                                bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                          t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);                          if (blens == null || blens.Length < t)                          {                              blens = new int[t];                          }                          else                          {                              Array.Clear(blens' 0' t);                              // for (int i = 0; i < t; i++)                              // {                              //     blens[i] = 0;                              // }                          }                            b >>= 14;                          k -= 14;                              index = 0;                          mode = InflateBlockMode.BTREE;                          goto case InflateBlockMode.BTREE;                        case InflateBlockMode.BTREE:                          while (index < 4 + (table >> 10))                          {                              while (k < (3))                              {                                  if (n != 0)                                  {                                      r = ZlibConstants.Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                                    n--;                                  b |= (_codec.InputBuffer[p++] & 0xff) << k;                                  k += 8;                              }                                blens[border[index++]] = b & 7;                                b >>= 3; k -= 3;                          }                            while (index < 19)                          {                              blens[border[index++]] = 0;                          }                            bb[0] = 7;                          t = inftree.inflate_trees_bits(blens' bb' tb' hufts' _codec);                          if (t != ZlibConstants.Z_OK)                          {                              r = t;                              if (r == ZlibConstants.Z_DATA_ERROR)                              {                                  blens = null;                                  mode = InflateBlockMode.BAD;                              }                                bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                            index = 0;                          mode = InflateBlockMode.DTREE;                          goto case InflateBlockMode.DTREE;                        case InflateBlockMode.DTREE:                          while (true)                          {                              t = table;                              if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)))                              {                                  break;                              }                                int i' j' c;                                t = bb[0];                                while (k < t)                              {                                  if (n != 0)                                  {                                      r = ZlibConstants.Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                                    n--;                                  b |= (_codec.InputBuffer[p++] & 0xff) << k;                                  k += 8;                              }                                t = hufts[(tb[0] + (b & InternalInflateConstants.InflateMask[t])) * 3 + 1];                              c = hufts[(tb[0] + (b & InternalInflateConstants.InflateMask[t])) * 3 + 2];                                if (c < 16)                              {                                  b >>= t; k -= t;                                  blens[index++] = c;                              }                              else                              {                                  // c == 16..18                                  i = c == 18 ? 7 : c - 14;                                  j = c == 18 ? 11 : 3;                                    while (k < (t + i))                                  {                                      if (n != 0)                                      {                                          r = ZlibConstants.Z_OK;                                      }                                      else                                      {                                          bitb = b; bitk = k;                                          _codec.AvailableBytesIn = n;                                          _codec.TotalBytesIn += p - _codec.NextIn;                                          _codec.NextIn = p;                                          writeAt = q;                                          return Flush(r);                                      }                                        n--;                                      b |= (_codec.InputBuffer[p++] & 0xff) << k;                                      k += 8;                                  }                                    b >>= t; k -= t;                                    j += (b & InternalInflateConstants.InflateMask[i]);                                    b >>= i; k -= i;                                    i = index;                                  t = table;                                  if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1))                                  {                                      blens = null;                                      mode = InflateBlockMode.BAD;                                      _codec.Message = "invalid bit length repeat";                                      r = ZlibConstants.Z_DATA_ERROR;                                        bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                                    c = (c == 16) ? blens[i-1] : 0;                                  do                                  {                                      blens[i++] = c;                                  }                                  while (--j != 0);                                  index = i;                              }                          }                            tb[0] = -1;                          {                              int[] bl = new int[] { 9 };  // must be <= 9 for lookahead assumptions                              int[] bd = new int[] { 6 }; // must be <= 9 for lookahead assumptions                              int[] tl = new int[1];                              int[] td = new int[1];                                t = table;                              t = inftree.inflate_trees_dynamic(257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' _codec);                                if (t != ZlibConstants.Z_OK)                              {                                  if (t == ZlibConstants.Z_DATA_ERROR)                                  {                                      blens = null;                                      mode = InflateBlockMode.BAD;                                  }                                  r = t;                                    bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                              codes.Init(bl[0]' bd[0]' hufts' tl[0]' hufts' td[0]);                          }                          mode = InflateBlockMode.CODES;                          goto case InflateBlockMode.CODES;                        case InflateBlockMode.CODES:                          bitb = b; bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                            r = codes.Process(this' r);                          if (r != ZlibConstants.Z_STREAM_END)                          {                              return Flush(r);                          }                            r = ZlibConstants.Z_OK;                          p = _codec.NextIn;                          n = _codec.AvailableBytesIn;                          b = bitb;                          k = bitk;                          q = writeAt;                          m = (int)(q < readAt ? readAt - q - 1 : end - q);                            if (last == 0)                          {                              mode = InflateBlockMode.TYPE;                              break;                          }                          mode = InflateBlockMode.DRY;                          goto case InflateBlockMode.DRY;                        case InflateBlockMode.DRY:                          writeAt = q;                          r = Flush(r);                          q = writeAt; m = (int)(q < readAt ? readAt - q - 1 : end - q);                          if (readAt != writeAt)                          {                              bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                          mode = InflateBlockMode.DONE;                          goto case InflateBlockMode.DONE;                        case InflateBlockMode.DONE:                          r = ZlibConstants.Z_STREAM_END;                          bitb = b;                          bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                          return Flush(r);                        case InflateBlockMode.BAD:                          r = ZlibConstants.Z_DATA_ERROR;                            bitb = b; bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                          return Flush(r);                          default:                          r = ZlibConstants.Z_STREAM_ERROR;                            bitb = b; bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                          return Flush(r);                  }
Magic Number,Ionic.Zlib,InflateBlocks,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zlib.Shared\Inflate.cs,Process,The following statement contains a magic number: switch (mode)                  {                      case InflateBlockMode.TYPE:                            while (k < (3))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                                n--;                              b |= (_codec.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                          t = (int)(b & 7);                          last = t & 1;                            switch ((uint)t >> 1)                          {                              case 0:  // stored                                  b >>= 3; k -= (3);                                  t = k & 7; // go to byte boundary                                  b >>= t; k -= t;                                  mode = InflateBlockMode.LENS; // get length of stored block                                  break;                                case 1:  // fixed                                  int[] bl = new int[1];                                  int[] bd = new int[1];                                  int[][] tl = new int[1][];                                  int[][] td = new int[1][];                                  InfTree.inflate_trees_fixed(bl' bd' tl' td' _codec);                                  codes.Init(bl[0]' bd[0]' tl[0]' 0' td[0]' 0);                                  b >>= 3; k -= 3;                                  mode = InflateBlockMode.CODES;                                  break;                                case 2:  // dynamic                                  b >>= 3; k -= 3;                                  mode = InflateBlockMode.TABLE;                                  break;                                case 3:  // illegal                                  b >>= 3; k -= 3;                                  mode = InflateBlockMode.BAD;                                  _codec.Message = "invalid block type";                                  r = ZlibConstants.Z_DATA_ERROR;                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                          }                          break;                        case InflateBlockMode.LENS:                            while (k < (32))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                              ;                              n--;                              b |= (_codec.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            if ( ( ((~b)>>16) & 0xffff) != (b & 0xffff))                          {                              mode = InflateBlockMode.BAD;                              _codec.Message = "invalid stored block lengths";                              r = ZlibConstants.Z_DATA_ERROR;                                bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                          left = (b & 0xffff);                          b = k = 0; // dump bits                          mode = left != 0 ? InflateBlockMode.STORED : (last != 0 ? InflateBlockMode.DRY : InflateBlockMode.TYPE);                          break;                        case InflateBlockMode.STORED:                          if (n == 0)                          {                              bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                            if (m == 0)                          {                              if (q == end && readAt != 0)                              {                                  q = 0; m = (int)(q < readAt ? readAt - q - 1 : end - q);                              }                              if (m == 0)                              {                                  writeAt = q;                                  r = Flush(r);                                  q = writeAt; m = (int)(q < readAt ? readAt - q - 1 : end - q);                                  if (q == end && readAt != 0)                                  {                                      q = 0; m = (int)(q < readAt ? readAt - q - 1 : end - q);                                  }                                  if (m == 0)                                  {                                      bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                              }                          }                          r = ZlibConstants.Z_OK;                            t = left;                          if (t > n)                              t = n;                          if (t > m)                              t = m;                          Array.Copy(_codec.InputBuffer' p' window' q' t);                          p += t; n -= t;                          q += t; m -= t;                          if ((left -= t) != 0)                              break;                          mode = last != 0 ? InflateBlockMode.DRY : InflateBlockMode.TYPE;                          break;                        case InflateBlockMode.TABLE:                            while (k < (14))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                                n--;                              b |= (_codec.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            table = t = (b & 0x3fff);                          if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29)                          {                              mode = InflateBlockMode.BAD;                              _codec.Message = "too many length or distance symbols";                              r = ZlibConstants.Z_DATA_ERROR;                                bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                          t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);                          if (blens == null || blens.Length < t)                          {                              blens = new int[t];                          }                          else                          {                              Array.Clear(blens' 0' t);                              // for (int i = 0; i < t; i++)                              // {                              //     blens[i] = 0;                              // }                          }                            b >>= 14;                          k -= 14;                              index = 0;                          mode = InflateBlockMode.BTREE;                          goto case InflateBlockMode.BTREE;                        case InflateBlockMode.BTREE:                          while (index < 4 + (table >> 10))                          {                              while (k < (3))                              {                                  if (n != 0)                                  {                                      r = ZlibConstants.Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                                    n--;                                  b |= (_codec.InputBuffer[p++] & 0xff) << k;                                  k += 8;                              }                                blens[border[index++]] = b & 7;                                b >>= 3; k -= 3;                          }                            while (index < 19)                          {                              blens[border[index++]] = 0;                          }                            bb[0] = 7;                          t = inftree.inflate_trees_bits(blens' bb' tb' hufts' _codec);                          if (t != ZlibConstants.Z_OK)                          {                              r = t;                              if (r == ZlibConstants.Z_DATA_ERROR)                              {                                  blens = null;                                  mode = InflateBlockMode.BAD;                              }                                bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                            index = 0;                          mode = InflateBlockMode.DTREE;                          goto case InflateBlockMode.DTREE;                        case InflateBlockMode.DTREE:                          while (true)                          {                              t = table;                              if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)))                              {                                  break;                              }                                int i' j' c;                                t = bb[0];                                while (k < t)                              {                                  if (n != 0)                                  {                                      r = ZlibConstants.Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                                    n--;                                  b |= (_codec.InputBuffer[p++] & 0xff) << k;                                  k += 8;                              }                                t = hufts[(tb[0] + (b & InternalInflateConstants.InflateMask[t])) * 3 + 1];                              c = hufts[(tb[0] + (b & InternalInflateConstants.InflateMask[t])) * 3 + 2];                                if (c < 16)                              {                                  b >>= t; k -= t;                                  blens[index++] = c;                              }                              else                              {                                  // c == 16..18                                  i = c == 18 ? 7 : c - 14;                                  j = c == 18 ? 11 : 3;                                    while (k < (t + i))                                  {                                      if (n != 0)                                      {                                          r = ZlibConstants.Z_OK;                                      }                                      else                                      {                                          bitb = b; bitk = k;                                          _codec.AvailableBytesIn = n;                                          _codec.TotalBytesIn += p - _codec.NextIn;                                          _codec.NextIn = p;                                          writeAt = q;                                          return Flush(r);                                      }                                        n--;                                      b |= (_codec.InputBuffer[p++] & 0xff) << k;                                      k += 8;                                  }                                    b >>= t; k -= t;                                    j += (b & InternalInflateConstants.InflateMask[i]);                                    b >>= i; k -= i;                                    i = index;                                  t = table;                                  if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1))                                  {                                      blens = null;                                      mode = InflateBlockMode.BAD;                                      _codec.Message = "invalid bit length repeat";                                      r = ZlibConstants.Z_DATA_ERROR;                                        bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                                    c = (c == 16) ? blens[i-1] : 0;                                  do                                  {                                      blens[i++] = c;                                  }                                  while (--j != 0);                                  index = i;                              }                          }                            tb[0] = -1;                          {                              int[] bl = new int[] { 9 };  // must be <= 9 for lookahead assumptions                              int[] bd = new int[] { 6 }; // must be <= 9 for lookahead assumptions                              int[] tl = new int[1];                              int[] td = new int[1];                                t = table;                              t = inftree.inflate_trees_dynamic(257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' _codec);                                if (t != ZlibConstants.Z_OK)                              {                                  if (t == ZlibConstants.Z_DATA_ERROR)                                  {                                      blens = null;                                      mode = InflateBlockMode.BAD;                                  }                                  r = t;                                    bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                              codes.Init(bl[0]' bd[0]' hufts' tl[0]' hufts' td[0]);                          }                          mode = InflateBlockMode.CODES;                          goto case InflateBlockMode.CODES;                        case InflateBlockMode.CODES:                          bitb = b; bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                            r = codes.Process(this' r);                          if (r != ZlibConstants.Z_STREAM_END)                          {                              return Flush(r);                          }                            r = ZlibConstants.Z_OK;                          p = _codec.NextIn;                          n = _codec.AvailableBytesIn;                          b = bitb;                          k = bitk;                          q = writeAt;                          m = (int)(q < readAt ? readAt - q - 1 : end - q);                            if (last == 0)                          {                              mode = InflateBlockMode.TYPE;                              break;                          }                          mode = InflateBlockMode.DRY;                          goto case InflateBlockMode.DRY;                        case InflateBlockMode.DRY:                          writeAt = q;                          r = Flush(r);                          q = writeAt; m = (int)(q < readAt ? readAt - q - 1 : end - q);                          if (readAt != writeAt)                          {                              bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                          mode = InflateBlockMode.DONE;                          goto case InflateBlockMode.DONE;                        case InflateBlockMode.DONE:                          r = ZlibConstants.Z_STREAM_END;                          bitb = b;                          bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                          return Flush(r);                        case InflateBlockMode.BAD:                          r = ZlibConstants.Z_DATA_ERROR;                            bitb = b; bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                          return Flush(r);                          default:                          r = ZlibConstants.Z_STREAM_ERROR;                            bitb = b; bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                          return Flush(r);                  }
Magic Number,Ionic.Zlib,InflateBlocks,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zlib.Shared\Inflate.cs,Process,The following statement contains a magic number: switch (mode)                  {                      case InflateBlockMode.TYPE:                            while (k < (3))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                                n--;                              b |= (_codec.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                          t = (int)(b & 7);                          last = t & 1;                            switch ((uint)t >> 1)                          {                              case 0:  // stored                                  b >>= 3; k -= (3);                                  t = k & 7; // go to byte boundary                                  b >>= t; k -= t;                                  mode = InflateBlockMode.LENS; // get length of stored block                                  break;                                case 1:  // fixed                                  int[] bl = new int[1];                                  int[] bd = new int[1];                                  int[][] tl = new int[1][];                                  int[][] td = new int[1][];                                  InfTree.inflate_trees_fixed(bl' bd' tl' td' _codec);                                  codes.Init(bl[0]' bd[0]' tl[0]' 0' td[0]' 0);                                  b >>= 3; k -= 3;                                  mode = InflateBlockMode.CODES;                                  break;                                case 2:  // dynamic                                  b >>= 3; k -= 3;                                  mode = InflateBlockMode.TABLE;                                  break;                                case 3:  // illegal                                  b >>= 3; k -= 3;                                  mode = InflateBlockMode.BAD;                                  _codec.Message = "invalid block type";                                  r = ZlibConstants.Z_DATA_ERROR;                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                          }                          break;                        case InflateBlockMode.LENS:                            while (k < (32))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                              ;                              n--;                              b |= (_codec.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            if ( ( ((~b)>>16) & 0xffff) != (b & 0xffff))                          {                              mode = InflateBlockMode.BAD;                              _codec.Message = "invalid stored block lengths";                              r = ZlibConstants.Z_DATA_ERROR;                                bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                          left = (b & 0xffff);                          b = k = 0; // dump bits                          mode = left != 0 ? InflateBlockMode.STORED : (last != 0 ? InflateBlockMode.DRY : InflateBlockMode.TYPE);                          break;                        case InflateBlockMode.STORED:                          if (n == 0)                          {                              bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                            if (m == 0)                          {                              if (q == end && readAt != 0)                              {                                  q = 0; m = (int)(q < readAt ? readAt - q - 1 : end - q);                              }                              if (m == 0)                              {                                  writeAt = q;                                  r = Flush(r);                                  q = writeAt; m = (int)(q < readAt ? readAt - q - 1 : end - q);                                  if (q == end && readAt != 0)                                  {                                      q = 0; m = (int)(q < readAt ? readAt - q - 1 : end - q);                                  }                                  if (m == 0)                                  {                                      bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                              }                          }                          r = ZlibConstants.Z_OK;                            t = left;                          if (t > n)                              t = n;                          if (t > m)                              t = m;                          Array.Copy(_codec.InputBuffer' p' window' q' t);                          p += t; n -= t;                          q += t; m -= t;                          if ((left -= t) != 0)                              break;                          mode = last != 0 ? InflateBlockMode.DRY : InflateBlockMode.TYPE;                          break;                        case InflateBlockMode.TABLE:                            while (k < (14))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                                n--;                              b |= (_codec.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            table = t = (b & 0x3fff);                          if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29)                          {                              mode = InflateBlockMode.BAD;                              _codec.Message = "too many length or distance symbols";                              r = ZlibConstants.Z_DATA_ERROR;                                bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                          t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);                          if (blens == null || blens.Length < t)                          {                              blens = new int[t];                          }                          else                          {                              Array.Clear(blens' 0' t);                              // for (int i = 0; i < t; i++)                              // {                              //     blens[i] = 0;                              // }                          }                            b >>= 14;                          k -= 14;                              index = 0;                          mode = InflateBlockMode.BTREE;                          goto case InflateBlockMode.BTREE;                        case InflateBlockMode.BTREE:                          while (index < 4 + (table >> 10))                          {                              while (k < (3))                              {                                  if (n != 0)                                  {                                      r = ZlibConstants.Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                                    n--;                                  b |= (_codec.InputBuffer[p++] & 0xff) << k;                                  k += 8;                              }                                blens[border[index++]] = b & 7;                                b >>= 3; k -= 3;                          }                            while (index < 19)                          {                              blens[border[index++]] = 0;                          }                            bb[0] = 7;                          t = inftree.inflate_trees_bits(blens' bb' tb' hufts' _codec);                          if (t != ZlibConstants.Z_OK)                          {                              r = t;                              if (r == ZlibConstants.Z_DATA_ERROR)                              {                                  blens = null;                                  mode = InflateBlockMode.BAD;                              }                                bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                            index = 0;                          mode = InflateBlockMode.DTREE;                          goto case InflateBlockMode.DTREE;                        case InflateBlockMode.DTREE:                          while (true)                          {                              t = table;                              if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)))                              {                                  break;                              }                                int i' j' c;                                t = bb[0];                                while (k < t)                              {                                  if (n != 0)                                  {                                      r = ZlibConstants.Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                                    n--;                                  b |= (_codec.InputBuffer[p++] & 0xff) << k;                                  k += 8;                              }                                t = hufts[(tb[0] + (b & InternalInflateConstants.InflateMask[t])) * 3 + 1];                              c = hufts[(tb[0] + (b & InternalInflateConstants.InflateMask[t])) * 3 + 2];                                if (c < 16)                              {                                  b >>= t; k -= t;                                  blens[index++] = c;                              }                              else                              {                                  // c == 16..18                                  i = c == 18 ? 7 : c - 14;                                  j = c == 18 ? 11 : 3;                                    while (k < (t + i))                                  {                                      if (n != 0)                                      {                                          r = ZlibConstants.Z_OK;                                      }                                      else                                      {                                          bitb = b; bitk = k;                                          _codec.AvailableBytesIn = n;                                          _codec.TotalBytesIn += p - _codec.NextIn;                                          _codec.NextIn = p;                                          writeAt = q;                                          return Flush(r);                                      }                                        n--;                                      b |= (_codec.InputBuffer[p++] & 0xff) << k;                                      k += 8;                                  }                                    b >>= t; k -= t;                                    j += (b & InternalInflateConstants.InflateMask[i]);                                    b >>= i; k -= i;                                    i = index;                                  t = table;                                  if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1))                                  {                                      blens = null;                                      mode = InflateBlockMode.BAD;                                      _codec.Message = "invalid bit length repeat";                                      r = ZlibConstants.Z_DATA_ERROR;                                        bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                                    c = (c == 16) ? blens[i-1] : 0;                                  do                                  {                                      blens[i++] = c;                                  }                                  while (--j != 0);                                  index = i;                              }                          }                            tb[0] = -1;                          {                              int[] bl = new int[] { 9 };  // must be <= 9 for lookahead assumptions                              int[] bd = new int[] { 6 }; // must be <= 9 for lookahead assumptions                              int[] tl = new int[1];                              int[] td = new int[1];                                t = table;                              t = inftree.inflate_trees_dynamic(257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' _codec);                                if (t != ZlibConstants.Z_OK)                              {                                  if (t == ZlibConstants.Z_DATA_ERROR)                                  {                                      blens = null;                                      mode = InflateBlockMode.BAD;                                  }                                  r = t;                                    bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                              codes.Init(bl[0]' bd[0]' hufts' tl[0]' hufts' td[0]);                          }                          mode = InflateBlockMode.CODES;                          goto case InflateBlockMode.CODES;                        case InflateBlockMode.CODES:                          bitb = b; bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                            r = codes.Process(this' r);                          if (r != ZlibConstants.Z_STREAM_END)                          {                              return Flush(r);                          }                            r = ZlibConstants.Z_OK;                          p = _codec.NextIn;                          n = _codec.AvailableBytesIn;                          b = bitb;                          k = bitk;                          q = writeAt;                          m = (int)(q < readAt ? readAt - q - 1 : end - q);                            if (last == 0)                          {                              mode = InflateBlockMode.TYPE;                              break;                          }                          mode = InflateBlockMode.DRY;                          goto case InflateBlockMode.DRY;                        case InflateBlockMode.DRY:                          writeAt = q;                          r = Flush(r);                          q = writeAt; m = (int)(q < readAt ? readAt - q - 1 : end - q);                          if (readAt != writeAt)                          {                              bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                          mode = InflateBlockMode.DONE;                          goto case InflateBlockMode.DONE;                        case InflateBlockMode.DONE:                          r = ZlibConstants.Z_STREAM_END;                          bitb = b;                          bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                          return Flush(r);                        case InflateBlockMode.BAD:                          r = ZlibConstants.Z_DATA_ERROR;                            bitb = b; bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                          return Flush(r);                          default:                          r = ZlibConstants.Z_STREAM_ERROR;                            bitb = b; bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                          return Flush(r);                  }
Magic Number,Ionic.Zlib,InflateBlocks,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zlib.Shared\Inflate.cs,Process,The following statement contains a magic number: switch (mode)                  {                      case InflateBlockMode.TYPE:                            while (k < (3))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                                n--;                              b |= (_codec.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                          t = (int)(b & 7);                          last = t & 1;                            switch ((uint)t >> 1)                          {                              case 0:  // stored                                  b >>= 3; k -= (3);                                  t = k & 7; // go to byte boundary                                  b >>= t; k -= t;                                  mode = InflateBlockMode.LENS; // get length of stored block                                  break;                                case 1:  // fixed                                  int[] bl = new int[1];                                  int[] bd = new int[1];                                  int[][] tl = new int[1][];                                  int[][] td = new int[1][];                                  InfTree.inflate_trees_fixed(bl' bd' tl' td' _codec);                                  codes.Init(bl[0]' bd[0]' tl[0]' 0' td[0]' 0);                                  b >>= 3; k -= 3;                                  mode = InflateBlockMode.CODES;                                  break;                                case 2:  // dynamic                                  b >>= 3; k -= 3;                                  mode = InflateBlockMode.TABLE;                                  break;                                case 3:  // illegal                                  b >>= 3; k -= 3;                                  mode = InflateBlockMode.BAD;                                  _codec.Message = "invalid block type";                                  r = ZlibConstants.Z_DATA_ERROR;                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                          }                          break;                        case InflateBlockMode.LENS:                            while (k < (32))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                              ;                              n--;                              b |= (_codec.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            if ( ( ((~b)>>16) & 0xffff) != (b & 0xffff))                          {                              mode = InflateBlockMode.BAD;                              _codec.Message = "invalid stored block lengths";                              r = ZlibConstants.Z_DATA_ERROR;                                bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                          left = (b & 0xffff);                          b = k = 0; // dump bits                          mode = left != 0 ? InflateBlockMode.STORED : (last != 0 ? InflateBlockMode.DRY : InflateBlockMode.TYPE);                          break;                        case InflateBlockMode.STORED:                          if (n == 0)                          {                              bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                            if (m == 0)                          {                              if (q == end && readAt != 0)                              {                                  q = 0; m = (int)(q < readAt ? readAt - q - 1 : end - q);                              }                              if (m == 0)                              {                                  writeAt = q;                                  r = Flush(r);                                  q = writeAt; m = (int)(q < readAt ? readAt - q - 1 : end - q);                                  if (q == end && readAt != 0)                                  {                                      q = 0; m = (int)(q < readAt ? readAt - q - 1 : end - q);                                  }                                  if (m == 0)                                  {                                      bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                              }                          }                          r = ZlibConstants.Z_OK;                            t = left;                          if (t > n)                              t = n;                          if (t > m)                              t = m;                          Array.Copy(_codec.InputBuffer' p' window' q' t);                          p += t; n -= t;                          q += t; m -= t;                          if ((left -= t) != 0)                              break;                          mode = last != 0 ? InflateBlockMode.DRY : InflateBlockMode.TYPE;                          break;                        case InflateBlockMode.TABLE:                            while (k < (14))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                                n--;                              b |= (_codec.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            table = t = (b & 0x3fff);                          if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29)                          {                              mode = InflateBlockMode.BAD;                              _codec.Message = "too many length or distance symbols";                              r = ZlibConstants.Z_DATA_ERROR;                                bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                          t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);                          if (blens == null || blens.Length < t)                          {                              blens = new int[t];                          }                          else                          {                              Array.Clear(blens' 0' t);                              // for (int i = 0; i < t; i++)                              // {                              //     blens[i] = 0;                              // }                          }                            b >>= 14;                          k -= 14;                              index = 0;                          mode = InflateBlockMode.BTREE;                          goto case InflateBlockMode.BTREE;                        case InflateBlockMode.BTREE:                          while (index < 4 + (table >> 10))                          {                              while (k < (3))                              {                                  if (n != 0)                                  {                                      r = ZlibConstants.Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                                    n--;                                  b |= (_codec.InputBuffer[p++] & 0xff) << k;                                  k += 8;                              }                                blens[border[index++]] = b & 7;                                b >>= 3; k -= 3;                          }                            while (index < 19)                          {                              blens[border[index++]] = 0;                          }                            bb[0] = 7;                          t = inftree.inflate_trees_bits(blens' bb' tb' hufts' _codec);                          if (t != ZlibConstants.Z_OK)                          {                              r = t;                              if (r == ZlibConstants.Z_DATA_ERROR)                              {                                  blens = null;                                  mode = InflateBlockMode.BAD;                              }                                bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                            index = 0;                          mode = InflateBlockMode.DTREE;                          goto case InflateBlockMode.DTREE;                        case InflateBlockMode.DTREE:                          while (true)                          {                              t = table;                              if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)))                              {                                  break;                              }                                int i' j' c;                                t = bb[0];                                while (k < t)                              {                                  if (n != 0)                                  {                                      r = ZlibConstants.Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                                    n--;                                  b |= (_codec.InputBuffer[p++] & 0xff) << k;                                  k += 8;                              }                                t = hufts[(tb[0] + (b & InternalInflateConstants.InflateMask[t])) * 3 + 1];                              c = hufts[(tb[0] + (b & InternalInflateConstants.InflateMask[t])) * 3 + 2];                                if (c < 16)                              {                                  b >>= t; k -= t;                                  blens[index++] = c;                              }                              else                              {                                  // c == 16..18                                  i = c == 18 ? 7 : c - 14;                                  j = c == 18 ? 11 : 3;                                    while (k < (t + i))                                  {                                      if (n != 0)                                      {                                          r = ZlibConstants.Z_OK;                                      }                                      else                                      {                                          bitb = b; bitk = k;                                          _codec.AvailableBytesIn = n;                                          _codec.TotalBytesIn += p - _codec.NextIn;                                          _codec.NextIn = p;                                          writeAt = q;                                          return Flush(r);                                      }                                        n--;                                      b |= (_codec.InputBuffer[p++] & 0xff) << k;                                      k += 8;                                  }                                    b >>= t; k -= t;                                    j += (b & InternalInflateConstants.InflateMask[i]);                                    b >>= i; k -= i;                                    i = index;                                  t = table;                                  if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1))                                  {                                      blens = null;                                      mode = InflateBlockMode.BAD;                                      _codec.Message = "invalid bit length repeat";                                      r = ZlibConstants.Z_DATA_ERROR;                                        bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                                    c = (c == 16) ? blens[i-1] : 0;                                  do                                  {                                      blens[i++] = c;                                  }                                  while (--j != 0);                                  index = i;                              }                          }                            tb[0] = -1;                          {                              int[] bl = new int[] { 9 };  // must be <= 9 for lookahead assumptions                              int[] bd = new int[] { 6 }; // must be <= 9 for lookahead assumptions                              int[] tl = new int[1];                              int[] td = new int[1];                                t = table;                              t = inftree.inflate_trees_dynamic(257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' _codec);                                if (t != ZlibConstants.Z_OK)                              {                                  if (t == ZlibConstants.Z_DATA_ERROR)                                  {                                      blens = null;                                      mode = InflateBlockMode.BAD;                                  }                                  r = t;                                    bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                              codes.Init(bl[0]' bd[0]' hufts' tl[0]' hufts' td[0]);                          }                          mode = InflateBlockMode.CODES;                          goto case InflateBlockMode.CODES;                        case InflateBlockMode.CODES:                          bitb = b; bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                            r = codes.Process(this' r);                          if (r != ZlibConstants.Z_STREAM_END)                          {                              return Flush(r);                          }                            r = ZlibConstants.Z_OK;                          p = _codec.NextIn;                          n = _codec.AvailableBytesIn;                          b = bitb;                          k = bitk;                          q = writeAt;                          m = (int)(q < readAt ? readAt - q - 1 : end - q);                            if (last == 0)                          {                              mode = InflateBlockMode.TYPE;                              break;                          }                          mode = InflateBlockMode.DRY;                          goto case InflateBlockMode.DRY;                        case InflateBlockMode.DRY:                          writeAt = q;                          r = Flush(r);                          q = writeAt; m = (int)(q < readAt ? readAt - q - 1 : end - q);                          if (readAt != writeAt)                          {                              bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                          mode = InflateBlockMode.DONE;                          goto case InflateBlockMode.DONE;                        case InflateBlockMode.DONE:                          r = ZlibConstants.Z_STREAM_END;                          bitb = b;                          bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                          return Flush(r);                        case InflateBlockMode.BAD:                          r = ZlibConstants.Z_DATA_ERROR;                            bitb = b; bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                          return Flush(r);                          default:                          r = ZlibConstants.Z_STREAM_ERROR;                            bitb = b; bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                          return Flush(r);                  }
Magic Number,Ionic.Zlib,InflateBlocks,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zlib.Shared\Inflate.cs,Process,The following statement contains a magic number: switch (mode)                  {                      case InflateBlockMode.TYPE:                            while (k < (3))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                                n--;                              b |= (_codec.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                          t = (int)(b & 7);                          last = t & 1;                            switch ((uint)t >> 1)                          {                              case 0:  // stored                                  b >>= 3; k -= (3);                                  t = k & 7; // go to byte boundary                                  b >>= t; k -= t;                                  mode = InflateBlockMode.LENS; // get length of stored block                                  break;                                case 1:  // fixed                                  int[] bl = new int[1];                                  int[] bd = new int[1];                                  int[][] tl = new int[1][];                                  int[][] td = new int[1][];                                  InfTree.inflate_trees_fixed(bl' bd' tl' td' _codec);                                  codes.Init(bl[0]' bd[0]' tl[0]' 0' td[0]' 0);                                  b >>= 3; k -= 3;                                  mode = InflateBlockMode.CODES;                                  break;                                case 2:  // dynamic                                  b >>= 3; k -= 3;                                  mode = InflateBlockMode.TABLE;                                  break;                                case 3:  // illegal                                  b >>= 3; k -= 3;                                  mode = InflateBlockMode.BAD;                                  _codec.Message = "invalid block type";                                  r = ZlibConstants.Z_DATA_ERROR;                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                          }                          break;                        case InflateBlockMode.LENS:                            while (k < (32))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                              ;                              n--;                              b |= (_codec.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            if ( ( ((~b)>>16) & 0xffff) != (b & 0xffff))                          {                              mode = InflateBlockMode.BAD;                              _codec.Message = "invalid stored block lengths";                              r = ZlibConstants.Z_DATA_ERROR;                                bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                          left = (b & 0xffff);                          b = k = 0; // dump bits                          mode = left != 0 ? InflateBlockMode.STORED : (last != 0 ? InflateBlockMode.DRY : InflateBlockMode.TYPE);                          break;                        case InflateBlockMode.STORED:                          if (n == 0)                          {                              bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                            if (m == 0)                          {                              if (q == end && readAt != 0)                              {                                  q = 0; m = (int)(q < readAt ? readAt - q - 1 : end - q);                              }                              if (m == 0)                              {                                  writeAt = q;                                  r = Flush(r);                                  q = writeAt; m = (int)(q < readAt ? readAt - q - 1 : end - q);                                  if (q == end && readAt != 0)                                  {                                      q = 0; m = (int)(q < readAt ? readAt - q - 1 : end - q);                                  }                                  if (m == 0)                                  {                                      bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                              }                          }                          r = ZlibConstants.Z_OK;                            t = left;                          if (t > n)                              t = n;                          if (t > m)                              t = m;                          Array.Copy(_codec.InputBuffer' p' window' q' t);                          p += t; n -= t;                          q += t; m -= t;                          if ((left -= t) != 0)                              break;                          mode = last != 0 ? InflateBlockMode.DRY : InflateBlockMode.TYPE;                          break;                        case InflateBlockMode.TABLE:                            while (k < (14))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                                n--;                              b |= (_codec.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            table = t = (b & 0x3fff);                          if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29)                          {                              mode = InflateBlockMode.BAD;                              _codec.Message = "too many length or distance symbols";                              r = ZlibConstants.Z_DATA_ERROR;                                bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                          t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);                          if (blens == null || blens.Length < t)                          {                              blens = new int[t];                          }                          else                          {                              Array.Clear(blens' 0' t);                              // for (int i = 0; i < t; i++)                              // {                              //     blens[i] = 0;                              // }                          }                            b >>= 14;                          k -= 14;                              index = 0;                          mode = InflateBlockMode.BTREE;                          goto case InflateBlockMode.BTREE;                        case InflateBlockMode.BTREE:                          while (index < 4 + (table >> 10))                          {                              while (k < (3))                              {                                  if (n != 0)                                  {                                      r = ZlibConstants.Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                                    n--;                                  b |= (_codec.InputBuffer[p++] & 0xff) << k;                                  k += 8;                              }                                blens[border[index++]] = b & 7;                                b >>= 3; k -= 3;                          }                            while (index < 19)                          {                              blens[border[index++]] = 0;                          }                            bb[0] = 7;                          t = inftree.inflate_trees_bits(blens' bb' tb' hufts' _codec);                          if (t != ZlibConstants.Z_OK)                          {                              r = t;                              if (r == ZlibConstants.Z_DATA_ERROR)                              {                                  blens = null;                                  mode = InflateBlockMode.BAD;                              }                                bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                            index = 0;                          mode = InflateBlockMode.DTREE;                          goto case InflateBlockMode.DTREE;                        case InflateBlockMode.DTREE:                          while (true)                          {                              t = table;                              if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)))                              {                                  break;                              }                                int i' j' c;                                t = bb[0];                                while (k < t)                              {                                  if (n != 0)                                  {                                      r = ZlibConstants.Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                                    n--;                                  b |= (_codec.InputBuffer[p++] & 0xff) << k;                                  k += 8;                              }                                t = hufts[(tb[0] + (b & InternalInflateConstants.InflateMask[t])) * 3 + 1];                              c = hufts[(tb[0] + (b & InternalInflateConstants.InflateMask[t])) * 3 + 2];                                if (c < 16)                              {                                  b >>= t; k -= t;                                  blens[index++] = c;                              }                              else                              {                                  // c == 16..18                                  i = c == 18 ? 7 : c - 14;                                  j = c == 18 ? 11 : 3;                                    while (k < (t + i))                                  {                                      if (n != 0)                                      {                                          r = ZlibConstants.Z_OK;                                      }                                      else                                      {                                          bitb = b; bitk = k;                                          _codec.AvailableBytesIn = n;                                          _codec.TotalBytesIn += p - _codec.NextIn;                                          _codec.NextIn = p;                                          writeAt = q;                                          return Flush(r);                                      }                                        n--;                                      b |= (_codec.InputBuffer[p++] & 0xff) << k;                                      k += 8;                                  }                                    b >>= t; k -= t;                                    j += (b & InternalInflateConstants.InflateMask[i]);                                    b >>= i; k -= i;                                    i = index;                                  t = table;                                  if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1))                                  {                                      blens = null;                                      mode = InflateBlockMode.BAD;                                      _codec.Message = "invalid bit length repeat";                                      r = ZlibConstants.Z_DATA_ERROR;                                        bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                                    c = (c == 16) ? blens[i-1] : 0;                                  do                                  {                                      blens[i++] = c;                                  }                                  while (--j != 0);                                  index = i;                              }                          }                            tb[0] = -1;                          {                              int[] bl = new int[] { 9 };  // must be <= 9 for lookahead assumptions                              int[] bd = new int[] { 6 }; // must be <= 9 for lookahead assumptions                              int[] tl = new int[1];                              int[] td = new int[1];                                t = table;                              t = inftree.inflate_trees_dynamic(257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' _codec);                                if (t != ZlibConstants.Z_OK)                              {                                  if (t == ZlibConstants.Z_DATA_ERROR)                                  {                                      blens = null;                                      mode = InflateBlockMode.BAD;                                  }                                  r = t;                                    bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                              codes.Init(bl[0]' bd[0]' hufts' tl[0]' hufts' td[0]);                          }                          mode = InflateBlockMode.CODES;                          goto case InflateBlockMode.CODES;                        case InflateBlockMode.CODES:                          bitb = b; bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                            r = codes.Process(this' r);                          if (r != ZlibConstants.Z_STREAM_END)                          {                              return Flush(r);                          }                            r = ZlibConstants.Z_OK;                          p = _codec.NextIn;                          n = _codec.AvailableBytesIn;                          b = bitb;                          k = bitk;                          q = writeAt;                          m = (int)(q < readAt ? readAt - q - 1 : end - q);                            if (last == 0)                          {                              mode = InflateBlockMode.TYPE;                              break;                          }                          mode = InflateBlockMode.DRY;                          goto case InflateBlockMode.DRY;                        case InflateBlockMode.DRY:                          writeAt = q;                          r = Flush(r);                          q = writeAt; m = (int)(q < readAt ? readAt - q - 1 : end - q);                          if (readAt != writeAt)                          {                              bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                          mode = InflateBlockMode.DONE;                          goto case InflateBlockMode.DONE;                        case InflateBlockMode.DONE:                          r = ZlibConstants.Z_STREAM_END;                          bitb = b;                          bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                          return Flush(r);                        case InflateBlockMode.BAD:                          r = ZlibConstants.Z_DATA_ERROR;                            bitb = b; bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                          return Flush(r);                          default:                          r = ZlibConstants.Z_STREAM_ERROR;                            bitb = b; bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                          return Flush(r);                  }
Magic Number,Ionic.Zlib,InflateBlocks,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zlib.Shared\Inflate.cs,Process,The following statement contains a magic number: switch (mode)                  {                      case InflateBlockMode.TYPE:                            while (k < (3))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                                n--;                              b |= (_codec.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                          t = (int)(b & 7);                          last = t & 1;                            switch ((uint)t >> 1)                          {                              case 0:  // stored                                  b >>= 3; k -= (3);                                  t = k & 7; // go to byte boundary                                  b >>= t; k -= t;                                  mode = InflateBlockMode.LENS; // get length of stored block                                  break;                                case 1:  // fixed                                  int[] bl = new int[1];                                  int[] bd = new int[1];                                  int[][] tl = new int[1][];                                  int[][] td = new int[1][];                                  InfTree.inflate_trees_fixed(bl' bd' tl' td' _codec);                                  codes.Init(bl[0]' bd[0]' tl[0]' 0' td[0]' 0);                                  b >>= 3; k -= 3;                                  mode = InflateBlockMode.CODES;                                  break;                                case 2:  // dynamic                                  b >>= 3; k -= 3;                                  mode = InflateBlockMode.TABLE;                                  break;                                case 3:  // illegal                                  b >>= 3; k -= 3;                                  mode = InflateBlockMode.BAD;                                  _codec.Message = "invalid block type";                                  r = ZlibConstants.Z_DATA_ERROR;                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                          }                          break;                        case InflateBlockMode.LENS:                            while (k < (32))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                              ;                              n--;                              b |= (_codec.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            if ( ( ((~b)>>16) & 0xffff) != (b & 0xffff))                          {                              mode = InflateBlockMode.BAD;                              _codec.Message = "invalid stored block lengths";                              r = ZlibConstants.Z_DATA_ERROR;                                bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                          left = (b & 0xffff);                          b = k = 0; // dump bits                          mode = left != 0 ? InflateBlockMode.STORED : (last != 0 ? InflateBlockMode.DRY : InflateBlockMode.TYPE);                          break;                        case InflateBlockMode.STORED:                          if (n == 0)                          {                              bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                            if (m == 0)                          {                              if (q == end && readAt != 0)                              {                                  q = 0; m = (int)(q < readAt ? readAt - q - 1 : end - q);                              }                              if (m == 0)                              {                                  writeAt = q;                                  r = Flush(r);                                  q = writeAt; m = (int)(q < readAt ? readAt - q - 1 : end - q);                                  if (q == end && readAt != 0)                                  {                                      q = 0; m = (int)(q < readAt ? readAt - q - 1 : end - q);                                  }                                  if (m == 0)                                  {                                      bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                              }                          }                          r = ZlibConstants.Z_OK;                            t = left;                          if (t > n)                              t = n;                          if (t > m)                              t = m;                          Array.Copy(_codec.InputBuffer' p' window' q' t);                          p += t; n -= t;                          q += t; m -= t;                          if ((left -= t) != 0)                              break;                          mode = last != 0 ? InflateBlockMode.DRY : InflateBlockMode.TYPE;                          break;                        case InflateBlockMode.TABLE:                            while (k < (14))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                                n--;                              b |= (_codec.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            table = t = (b & 0x3fff);                          if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29)                          {                              mode = InflateBlockMode.BAD;                              _codec.Message = "too many length or distance symbols";                              r = ZlibConstants.Z_DATA_ERROR;                                bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                          t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);                          if (blens == null || blens.Length < t)                          {                              blens = new int[t];                          }                          else                          {                              Array.Clear(blens' 0' t);                              // for (int i = 0; i < t; i++)                              // {                              //     blens[i] = 0;                              // }                          }                            b >>= 14;                          k -= 14;                              index = 0;                          mode = InflateBlockMode.BTREE;                          goto case InflateBlockMode.BTREE;                        case InflateBlockMode.BTREE:                          while (index < 4 + (table >> 10))                          {                              while (k < (3))                              {                                  if (n != 0)                                  {                                      r = ZlibConstants.Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                                    n--;                                  b |= (_codec.InputBuffer[p++] & 0xff) << k;                                  k += 8;                              }                                blens[border[index++]] = b & 7;                                b >>= 3; k -= 3;                          }                            while (index < 19)                          {                              blens[border[index++]] = 0;                          }                            bb[0] = 7;                          t = inftree.inflate_trees_bits(blens' bb' tb' hufts' _codec);                          if (t != ZlibConstants.Z_OK)                          {                              r = t;                              if (r == ZlibConstants.Z_DATA_ERROR)                              {                                  blens = null;                                  mode = InflateBlockMode.BAD;                              }                                bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                            index = 0;                          mode = InflateBlockMode.DTREE;                          goto case InflateBlockMode.DTREE;                        case InflateBlockMode.DTREE:                          while (true)                          {                              t = table;                              if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)))                              {                                  break;                              }                                int i' j' c;                                t = bb[0];                                while (k < t)                              {                                  if (n != 0)                                  {                                      r = ZlibConstants.Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                                    n--;                                  b |= (_codec.InputBuffer[p++] & 0xff) << k;                                  k += 8;                              }                                t = hufts[(tb[0] + (b & InternalInflateConstants.InflateMask[t])) * 3 + 1];                              c = hufts[(tb[0] + (b & InternalInflateConstants.InflateMask[t])) * 3 + 2];                                if (c < 16)                              {                                  b >>= t; k -= t;                                  blens[index++] = c;                              }                              else                              {                                  // c == 16..18                                  i = c == 18 ? 7 : c - 14;                                  j = c == 18 ? 11 : 3;                                    while (k < (t + i))                                  {                                      if (n != 0)                                      {                                          r = ZlibConstants.Z_OK;                                      }                                      else                                      {                                          bitb = b; bitk = k;                                          _codec.AvailableBytesIn = n;                                          _codec.TotalBytesIn += p - _codec.NextIn;                                          _codec.NextIn = p;                                          writeAt = q;                                          return Flush(r);                                      }                                        n--;                                      b |= (_codec.InputBuffer[p++] & 0xff) << k;                                      k += 8;                                  }                                    b >>= t; k -= t;                                    j += (b & InternalInflateConstants.InflateMask[i]);                                    b >>= i; k -= i;                                    i = index;                                  t = table;                                  if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1))                                  {                                      blens = null;                                      mode = InflateBlockMode.BAD;                                      _codec.Message = "invalid bit length repeat";                                      r = ZlibConstants.Z_DATA_ERROR;                                        bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                                    c = (c == 16) ? blens[i-1] : 0;                                  do                                  {                                      blens[i++] = c;                                  }                                  while (--j != 0);                                  index = i;                              }                          }                            tb[0] = -1;                          {                              int[] bl = new int[] { 9 };  // must be <= 9 for lookahead assumptions                              int[] bd = new int[] { 6 }; // must be <= 9 for lookahead assumptions                              int[] tl = new int[1];                              int[] td = new int[1];                                t = table;                              t = inftree.inflate_trees_dynamic(257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' _codec);                                if (t != ZlibConstants.Z_OK)                              {                                  if (t == ZlibConstants.Z_DATA_ERROR)                                  {                                      blens = null;                                      mode = InflateBlockMode.BAD;                                  }                                  r = t;                                    bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                              codes.Init(bl[0]' bd[0]' hufts' tl[0]' hufts' td[0]);                          }                          mode = InflateBlockMode.CODES;                          goto case InflateBlockMode.CODES;                        case InflateBlockMode.CODES:                          bitb = b; bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                            r = codes.Process(this' r);                          if (r != ZlibConstants.Z_STREAM_END)                          {                              return Flush(r);                          }                            r = ZlibConstants.Z_OK;                          p = _codec.NextIn;                          n = _codec.AvailableBytesIn;                          b = bitb;                          k = bitk;                          q = writeAt;                          m = (int)(q < readAt ? readAt - q - 1 : end - q);                            if (last == 0)                          {                              mode = InflateBlockMode.TYPE;                              break;                          }                          mode = InflateBlockMode.DRY;                          goto case InflateBlockMode.DRY;                        case InflateBlockMode.DRY:                          writeAt = q;                          r = Flush(r);                          q = writeAt; m = (int)(q < readAt ? readAt - q - 1 : end - q);                          if (readAt != writeAt)                          {                              bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                          mode = InflateBlockMode.DONE;                          goto case InflateBlockMode.DONE;                        case InflateBlockMode.DONE:                          r = ZlibConstants.Z_STREAM_END;                          bitb = b;                          bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                          return Flush(r);                        case InflateBlockMode.BAD:                          r = ZlibConstants.Z_DATA_ERROR;                            bitb = b; bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                          return Flush(r);                          default:                          r = ZlibConstants.Z_STREAM_ERROR;                            bitb = b; bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                          return Flush(r);                  }
Magic Number,Ionic.Zlib,InflateBlocks,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zlib.Shared\Inflate.cs,Process,The following statement contains a magic number: switch (mode)                  {                      case InflateBlockMode.TYPE:                            while (k < (3))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                                n--;                              b |= (_codec.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                          t = (int)(b & 7);                          last = t & 1;                            switch ((uint)t >> 1)                          {                              case 0:  // stored                                  b >>= 3; k -= (3);                                  t = k & 7; // go to byte boundary                                  b >>= t; k -= t;                                  mode = InflateBlockMode.LENS; // get length of stored block                                  break;                                case 1:  // fixed                                  int[] bl = new int[1];                                  int[] bd = new int[1];                                  int[][] tl = new int[1][];                                  int[][] td = new int[1][];                                  InfTree.inflate_trees_fixed(bl' bd' tl' td' _codec);                                  codes.Init(bl[0]' bd[0]' tl[0]' 0' td[0]' 0);                                  b >>= 3; k -= 3;                                  mode = InflateBlockMode.CODES;                                  break;                                case 2:  // dynamic                                  b >>= 3; k -= 3;                                  mode = InflateBlockMode.TABLE;                                  break;                                case 3:  // illegal                                  b >>= 3; k -= 3;                                  mode = InflateBlockMode.BAD;                                  _codec.Message = "invalid block type";                                  r = ZlibConstants.Z_DATA_ERROR;                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                          }                          break;                        case InflateBlockMode.LENS:                            while (k < (32))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                              ;                              n--;                              b |= (_codec.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            if ( ( ((~b)>>16) & 0xffff) != (b & 0xffff))                          {                              mode = InflateBlockMode.BAD;                              _codec.Message = "invalid stored block lengths";                              r = ZlibConstants.Z_DATA_ERROR;                                bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                          left = (b & 0xffff);                          b = k = 0; // dump bits                          mode = left != 0 ? InflateBlockMode.STORED : (last != 0 ? InflateBlockMode.DRY : InflateBlockMode.TYPE);                          break;                        case InflateBlockMode.STORED:                          if (n == 0)                          {                              bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                            if (m == 0)                          {                              if (q == end && readAt != 0)                              {                                  q = 0; m = (int)(q < readAt ? readAt - q - 1 : end - q);                              }                              if (m == 0)                              {                                  writeAt = q;                                  r = Flush(r);                                  q = writeAt; m = (int)(q < readAt ? readAt - q - 1 : end - q);                                  if (q == end && readAt != 0)                                  {                                      q = 0; m = (int)(q < readAt ? readAt - q - 1 : end - q);                                  }                                  if (m == 0)                                  {                                      bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                              }                          }                          r = ZlibConstants.Z_OK;                            t = left;                          if (t > n)                              t = n;                          if (t > m)                              t = m;                          Array.Copy(_codec.InputBuffer' p' window' q' t);                          p += t; n -= t;                          q += t; m -= t;                          if ((left -= t) != 0)                              break;                          mode = last != 0 ? InflateBlockMode.DRY : InflateBlockMode.TYPE;                          break;                        case InflateBlockMode.TABLE:                            while (k < (14))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                                n--;                              b |= (_codec.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            table = t = (b & 0x3fff);                          if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29)                          {                              mode = InflateBlockMode.BAD;                              _codec.Message = "too many length or distance symbols";                              r = ZlibConstants.Z_DATA_ERROR;                                bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                          t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);                          if (blens == null || blens.Length < t)                          {                              blens = new int[t];                          }                          else                          {                              Array.Clear(blens' 0' t);                              // for (int i = 0; i < t; i++)                              // {                              //     blens[i] = 0;                              // }                          }                            b >>= 14;                          k -= 14;                              index = 0;                          mode = InflateBlockMode.BTREE;                          goto case InflateBlockMode.BTREE;                        case InflateBlockMode.BTREE:                          while (index < 4 + (table >> 10))                          {                              while (k < (3))                              {                                  if (n != 0)                                  {                                      r = ZlibConstants.Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                                    n--;                                  b |= (_codec.InputBuffer[p++] & 0xff) << k;                                  k += 8;                              }                                blens[border[index++]] = b & 7;                                b >>= 3; k -= 3;                          }                            while (index < 19)                          {                              blens[border[index++]] = 0;                          }                            bb[0] = 7;                          t = inftree.inflate_trees_bits(blens' bb' tb' hufts' _codec);                          if (t != ZlibConstants.Z_OK)                          {                              r = t;                              if (r == ZlibConstants.Z_DATA_ERROR)                              {                                  blens = null;                                  mode = InflateBlockMode.BAD;                              }                                bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                            index = 0;                          mode = InflateBlockMode.DTREE;                          goto case InflateBlockMode.DTREE;                        case InflateBlockMode.DTREE:                          while (true)                          {                              t = table;                              if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)))                              {                                  break;                              }                                int i' j' c;                                t = bb[0];                                while (k < t)                              {                                  if (n != 0)                                  {                                      r = ZlibConstants.Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                                    n--;                                  b |= (_codec.InputBuffer[p++] & 0xff) << k;                                  k += 8;                              }                                t = hufts[(tb[0] + (b & InternalInflateConstants.InflateMask[t])) * 3 + 1];                              c = hufts[(tb[0] + (b & InternalInflateConstants.InflateMask[t])) * 3 + 2];                                if (c < 16)                              {                                  b >>= t; k -= t;                                  blens[index++] = c;                              }                              else                              {                                  // c == 16..18                                  i = c == 18 ? 7 : c - 14;                                  j = c == 18 ? 11 : 3;                                    while (k < (t + i))                                  {                                      if (n != 0)                                      {                                          r = ZlibConstants.Z_OK;                                      }                                      else                                      {                                          bitb = b; bitk = k;                                          _codec.AvailableBytesIn = n;                                          _codec.TotalBytesIn += p - _codec.NextIn;                                          _codec.NextIn = p;                                          writeAt = q;                                          return Flush(r);                                      }                                        n--;                                      b |= (_codec.InputBuffer[p++] & 0xff) << k;                                      k += 8;                                  }                                    b >>= t; k -= t;                                    j += (b & InternalInflateConstants.InflateMask[i]);                                    b >>= i; k -= i;                                    i = index;                                  t = table;                                  if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1))                                  {                                      blens = null;                                      mode = InflateBlockMode.BAD;                                      _codec.Message = "invalid bit length repeat";                                      r = ZlibConstants.Z_DATA_ERROR;                                        bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                                    c = (c == 16) ? blens[i-1] : 0;                                  do                                  {                                      blens[i++] = c;                                  }                                  while (--j != 0);                                  index = i;                              }                          }                            tb[0] = -1;                          {                              int[] bl = new int[] { 9 };  // must be <= 9 for lookahead assumptions                              int[] bd = new int[] { 6 }; // must be <= 9 for lookahead assumptions                              int[] tl = new int[1];                              int[] td = new int[1];                                t = table;                              t = inftree.inflate_trees_dynamic(257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' _codec);                                if (t != ZlibConstants.Z_OK)                              {                                  if (t == ZlibConstants.Z_DATA_ERROR)                                  {                                      blens = null;                                      mode = InflateBlockMode.BAD;                                  }                                  r = t;                                    bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                              codes.Init(bl[0]' bd[0]' hufts' tl[0]' hufts' td[0]);                          }                          mode = InflateBlockMode.CODES;                          goto case InflateBlockMode.CODES;                        case InflateBlockMode.CODES:                          bitb = b; bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                            r = codes.Process(this' r);                          if (r != ZlibConstants.Z_STREAM_END)                          {                              return Flush(r);                          }                            r = ZlibConstants.Z_OK;                          p = _codec.NextIn;                          n = _codec.AvailableBytesIn;                          b = bitb;                          k = bitk;                          q = writeAt;                          m = (int)(q < readAt ? readAt - q - 1 : end - q);                            if (last == 0)                          {                              mode = InflateBlockMode.TYPE;                              break;                          }                          mode = InflateBlockMode.DRY;                          goto case InflateBlockMode.DRY;                        case InflateBlockMode.DRY:                          writeAt = q;                          r = Flush(r);                          q = writeAt; m = (int)(q < readAt ? readAt - q - 1 : end - q);                          if (readAt != writeAt)                          {                              bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                          mode = InflateBlockMode.DONE;                          goto case InflateBlockMode.DONE;                        case InflateBlockMode.DONE:                          r = ZlibConstants.Z_STREAM_END;                          bitb = b;                          bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                          return Flush(r);                        case InflateBlockMode.BAD:                          r = ZlibConstants.Z_DATA_ERROR;                            bitb = b; bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                          return Flush(r);                          default:                          r = ZlibConstants.Z_STREAM_ERROR;                            bitb = b; bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                          return Flush(r);                  }
Magic Number,Ionic.Zlib,InflateBlocks,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zlib.Shared\Inflate.cs,Process,The following statement contains a magic number: switch (mode)                  {                      case InflateBlockMode.TYPE:                            while (k < (3))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                                n--;                              b |= (_codec.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                          t = (int)(b & 7);                          last = t & 1;                            switch ((uint)t >> 1)                          {                              case 0:  // stored                                  b >>= 3; k -= (3);                                  t = k & 7; // go to byte boundary                                  b >>= t; k -= t;                                  mode = InflateBlockMode.LENS; // get length of stored block                                  break;                                case 1:  // fixed                                  int[] bl = new int[1];                                  int[] bd = new int[1];                                  int[][] tl = new int[1][];                                  int[][] td = new int[1][];                                  InfTree.inflate_trees_fixed(bl' bd' tl' td' _codec);                                  codes.Init(bl[0]' bd[0]' tl[0]' 0' td[0]' 0);                                  b >>= 3; k -= 3;                                  mode = InflateBlockMode.CODES;                                  break;                                case 2:  // dynamic                                  b >>= 3; k -= 3;                                  mode = InflateBlockMode.TABLE;                                  break;                                case 3:  // illegal                                  b >>= 3; k -= 3;                                  mode = InflateBlockMode.BAD;                                  _codec.Message = "invalid block type";                                  r = ZlibConstants.Z_DATA_ERROR;                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                          }                          break;                        case InflateBlockMode.LENS:                            while (k < (32))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                              ;                              n--;                              b |= (_codec.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            if ( ( ((~b)>>16) & 0xffff) != (b & 0xffff))                          {                              mode = InflateBlockMode.BAD;                              _codec.Message = "invalid stored block lengths";                              r = ZlibConstants.Z_DATA_ERROR;                                bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                          left = (b & 0xffff);                          b = k = 0; // dump bits                          mode = left != 0 ? InflateBlockMode.STORED : (last != 0 ? InflateBlockMode.DRY : InflateBlockMode.TYPE);                          break;                        case InflateBlockMode.STORED:                          if (n == 0)                          {                              bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                            if (m == 0)                          {                              if (q == end && readAt != 0)                              {                                  q = 0; m = (int)(q < readAt ? readAt - q - 1 : end - q);                              }                              if (m == 0)                              {                                  writeAt = q;                                  r = Flush(r);                                  q = writeAt; m = (int)(q < readAt ? readAt - q - 1 : end - q);                                  if (q == end && readAt != 0)                                  {                                      q = 0; m = (int)(q < readAt ? readAt - q - 1 : end - q);                                  }                                  if (m == 0)                                  {                                      bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                              }                          }                          r = ZlibConstants.Z_OK;                            t = left;                          if (t > n)                              t = n;                          if (t > m)                              t = m;                          Array.Copy(_codec.InputBuffer' p' window' q' t);                          p += t; n -= t;                          q += t; m -= t;                          if ((left -= t) != 0)                              break;                          mode = last != 0 ? InflateBlockMode.DRY : InflateBlockMode.TYPE;                          break;                        case InflateBlockMode.TABLE:                            while (k < (14))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                                n--;                              b |= (_codec.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            table = t = (b & 0x3fff);                          if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29)                          {                              mode = InflateBlockMode.BAD;                              _codec.Message = "too many length or distance symbols";                              r = ZlibConstants.Z_DATA_ERROR;                                bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                          t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);                          if (blens == null || blens.Length < t)                          {                              blens = new int[t];                          }                          else                          {                              Array.Clear(blens' 0' t);                              // for (int i = 0; i < t; i++)                              // {                              //     blens[i] = 0;                              // }                          }                            b >>= 14;                          k -= 14;                              index = 0;                          mode = InflateBlockMode.BTREE;                          goto case InflateBlockMode.BTREE;                        case InflateBlockMode.BTREE:                          while (index < 4 + (table >> 10))                          {                              while (k < (3))                              {                                  if (n != 0)                                  {                                      r = ZlibConstants.Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                                    n--;                                  b |= (_codec.InputBuffer[p++] & 0xff) << k;                                  k += 8;                              }                                blens[border[index++]] = b & 7;                                b >>= 3; k -= 3;                          }                            while (index < 19)                          {                              blens[border[index++]] = 0;                          }                            bb[0] = 7;                          t = inftree.inflate_trees_bits(blens' bb' tb' hufts' _codec);                          if (t != ZlibConstants.Z_OK)                          {                              r = t;                              if (r == ZlibConstants.Z_DATA_ERROR)                              {                                  blens = null;                                  mode = InflateBlockMode.BAD;                              }                                bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                            index = 0;                          mode = InflateBlockMode.DTREE;                          goto case InflateBlockMode.DTREE;                        case InflateBlockMode.DTREE:                          while (true)                          {                              t = table;                              if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)))                              {                                  break;                              }                                int i' j' c;                                t = bb[0];                                while (k < t)                              {                                  if (n != 0)                                  {                                      r = ZlibConstants.Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                                    n--;                                  b |= (_codec.InputBuffer[p++] & 0xff) << k;                                  k += 8;                              }                                t = hufts[(tb[0] + (b & InternalInflateConstants.InflateMask[t])) * 3 + 1];                              c = hufts[(tb[0] + (b & InternalInflateConstants.InflateMask[t])) * 3 + 2];                                if (c < 16)                              {                                  b >>= t; k -= t;                                  blens[index++] = c;                              }                              else                              {                                  // c == 16..18                                  i = c == 18 ? 7 : c - 14;                                  j = c == 18 ? 11 : 3;                                    while (k < (t + i))                                  {                                      if (n != 0)                                      {                                          r = ZlibConstants.Z_OK;                                      }                                      else                                      {                                          bitb = b; bitk = k;                                          _codec.AvailableBytesIn = n;                                          _codec.TotalBytesIn += p - _codec.NextIn;                                          _codec.NextIn = p;                                          writeAt = q;                                          return Flush(r);                                      }                                        n--;                                      b |= (_codec.InputBuffer[p++] & 0xff) << k;                                      k += 8;                                  }                                    b >>= t; k -= t;                                    j += (b & InternalInflateConstants.InflateMask[i]);                                    b >>= i; k -= i;                                    i = index;                                  t = table;                                  if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1))                                  {                                      blens = null;                                      mode = InflateBlockMode.BAD;                                      _codec.Message = "invalid bit length repeat";                                      r = ZlibConstants.Z_DATA_ERROR;                                        bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                                    c = (c == 16) ? blens[i-1] : 0;                                  do                                  {                                      blens[i++] = c;                                  }                                  while (--j != 0);                                  index = i;                              }                          }                            tb[0] = -1;                          {                              int[] bl = new int[] { 9 };  // must be <= 9 for lookahead assumptions                              int[] bd = new int[] { 6 }; // must be <= 9 for lookahead assumptions                              int[] tl = new int[1];                              int[] td = new int[1];                                t = table;                              t = inftree.inflate_trees_dynamic(257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' _codec);                                if (t != ZlibConstants.Z_OK)                              {                                  if (t == ZlibConstants.Z_DATA_ERROR)                                  {                                      blens = null;                                      mode = InflateBlockMode.BAD;                                  }                                  r = t;                                    bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                              codes.Init(bl[0]' bd[0]' hufts' tl[0]' hufts' td[0]);                          }                          mode = InflateBlockMode.CODES;                          goto case InflateBlockMode.CODES;                        case InflateBlockMode.CODES:                          bitb = b; bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                            r = codes.Process(this' r);                          if (r != ZlibConstants.Z_STREAM_END)                          {                              return Flush(r);                          }                            r = ZlibConstants.Z_OK;                          p = _codec.NextIn;                          n = _codec.AvailableBytesIn;                          b = bitb;                          k = bitk;                          q = writeAt;                          m = (int)(q < readAt ? readAt - q - 1 : end - q);                            if (last == 0)                          {                              mode = InflateBlockMode.TYPE;                              break;                          }                          mode = InflateBlockMode.DRY;                          goto case InflateBlockMode.DRY;                        case InflateBlockMode.DRY:                          writeAt = q;                          r = Flush(r);                          q = writeAt; m = (int)(q < readAt ? readAt - q - 1 : end - q);                          if (readAt != writeAt)                          {                              bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                          mode = InflateBlockMode.DONE;                          goto case InflateBlockMode.DONE;                        case InflateBlockMode.DONE:                          r = ZlibConstants.Z_STREAM_END;                          bitb = b;                          bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                          return Flush(r);                        case InflateBlockMode.BAD:                          r = ZlibConstants.Z_DATA_ERROR;                            bitb = b; bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                          return Flush(r);                          default:                          r = ZlibConstants.Z_STREAM_ERROR;                            bitb = b; bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                          return Flush(r);                  }
Magic Number,Ionic.Zlib,InflateBlocks,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zlib.Shared\Inflate.cs,Process,The following statement contains a magic number: switch (mode)                  {                      case InflateBlockMode.TYPE:                            while (k < (3))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                                n--;                              b |= (_codec.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                          t = (int)(b & 7);                          last = t & 1;                            switch ((uint)t >> 1)                          {                              case 0:  // stored                                  b >>= 3; k -= (3);                                  t = k & 7; // go to byte boundary                                  b >>= t; k -= t;                                  mode = InflateBlockMode.LENS; // get length of stored block                                  break;                                case 1:  // fixed                                  int[] bl = new int[1];                                  int[] bd = new int[1];                                  int[][] tl = new int[1][];                                  int[][] td = new int[1][];                                  InfTree.inflate_trees_fixed(bl' bd' tl' td' _codec);                                  codes.Init(bl[0]' bd[0]' tl[0]' 0' td[0]' 0);                                  b >>= 3; k -= 3;                                  mode = InflateBlockMode.CODES;                                  break;                                case 2:  // dynamic                                  b >>= 3; k -= 3;                                  mode = InflateBlockMode.TABLE;                                  break;                                case 3:  // illegal                                  b >>= 3; k -= 3;                                  mode = InflateBlockMode.BAD;                                  _codec.Message = "invalid block type";                                  r = ZlibConstants.Z_DATA_ERROR;                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                          }                          break;                        case InflateBlockMode.LENS:                            while (k < (32))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                              ;                              n--;                              b |= (_codec.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            if ( ( ((~b)>>16) & 0xffff) != (b & 0xffff))                          {                              mode = InflateBlockMode.BAD;                              _codec.Message = "invalid stored block lengths";                              r = ZlibConstants.Z_DATA_ERROR;                                bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                          left = (b & 0xffff);                          b = k = 0; // dump bits                          mode = left != 0 ? InflateBlockMode.STORED : (last != 0 ? InflateBlockMode.DRY : InflateBlockMode.TYPE);                          break;                        case InflateBlockMode.STORED:                          if (n == 0)                          {                              bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                            if (m == 0)                          {                              if (q == end && readAt != 0)                              {                                  q = 0; m = (int)(q < readAt ? readAt - q - 1 : end - q);                              }                              if (m == 0)                              {                                  writeAt = q;                                  r = Flush(r);                                  q = writeAt; m = (int)(q < readAt ? readAt - q - 1 : end - q);                                  if (q == end && readAt != 0)                                  {                                      q = 0; m = (int)(q < readAt ? readAt - q - 1 : end - q);                                  }                                  if (m == 0)                                  {                                      bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                              }                          }                          r = ZlibConstants.Z_OK;                            t = left;                          if (t > n)                              t = n;                          if (t > m)                              t = m;                          Array.Copy(_codec.InputBuffer' p' window' q' t);                          p += t; n -= t;                          q += t; m -= t;                          if ((left -= t) != 0)                              break;                          mode = last != 0 ? InflateBlockMode.DRY : InflateBlockMode.TYPE;                          break;                        case InflateBlockMode.TABLE:                            while (k < (14))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                                n--;                              b |= (_codec.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            table = t = (b & 0x3fff);                          if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29)                          {                              mode = InflateBlockMode.BAD;                              _codec.Message = "too many length or distance symbols";                              r = ZlibConstants.Z_DATA_ERROR;                                bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                          t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);                          if (blens == null || blens.Length < t)                          {                              blens = new int[t];                          }                          else                          {                              Array.Clear(blens' 0' t);                              // for (int i = 0; i < t; i++)                              // {                              //     blens[i] = 0;                              // }                          }                            b >>= 14;                          k -= 14;                              index = 0;                          mode = InflateBlockMode.BTREE;                          goto case InflateBlockMode.BTREE;                        case InflateBlockMode.BTREE:                          while (index < 4 + (table >> 10))                          {                              while (k < (3))                              {                                  if (n != 0)                                  {                                      r = ZlibConstants.Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                                    n--;                                  b |= (_codec.InputBuffer[p++] & 0xff) << k;                                  k += 8;                              }                                blens[border[index++]] = b & 7;                                b >>= 3; k -= 3;                          }                            while (index < 19)                          {                              blens[border[index++]] = 0;                          }                            bb[0] = 7;                          t = inftree.inflate_trees_bits(blens' bb' tb' hufts' _codec);                          if (t != ZlibConstants.Z_OK)                          {                              r = t;                              if (r == ZlibConstants.Z_DATA_ERROR)                              {                                  blens = null;                                  mode = InflateBlockMode.BAD;                              }                                bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                            index = 0;                          mode = InflateBlockMode.DTREE;                          goto case InflateBlockMode.DTREE;                        case InflateBlockMode.DTREE:                          while (true)                          {                              t = table;                              if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)))                              {                                  break;                              }                                int i' j' c;                                t = bb[0];                                while (k < t)                              {                                  if (n != 0)                                  {                                      r = ZlibConstants.Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                                    n--;                                  b |= (_codec.InputBuffer[p++] & 0xff) << k;                                  k += 8;                              }                                t = hufts[(tb[0] + (b & InternalInflateConstants.InflateMask[t])) * 3 + 1];                              c = hufts[(tb[0] + (b & InternalInflateConstants.InflateMask[t])) * 3 + 2];                                if (c < 16)                              {                                  b >>= t; k -= t;                                  blens[index++] = c;                              }                              else                              {                                  // c == 16..18                                  i = c == 18 ? 7 : c - 14;                                  j = c == 18 ? 11 : 3;                                    while (k < (t + i))                                  {                                      if (n != 0)                                      {                                          r = ZlibConstants.Z_OK;                                      }                                      else                                      {                                          bitb = b; bitk = k;                                          _codec.AvailableBytesIn = n;                                          _codec.TotalBytesIn += p - _codec.NextIn;                                          _codec.NextIn = p;                                          writeAt = q;                                          return Flush(r);                                      }                                        n--;                                      b |= (_codec.InputBuffer[p++] & 0xff) << k;                                      k += 8;                                  }                                    b >>= t; k -= t;                                    j += (b & InternalInflateConstants.InflateMask[i]);                                    b >>= i; k -= i;                                    i = index;                                  t = table;                                  if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1))                                  {                                      blens = null;                                      mode = InflateBlockMode.BAD;                                      _codec.Message = "invalid bit length repeat";                                      r = ZlibConstants.Z_DATA_ERROR;                                        bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                                    c = (c == 16) ? blens[i-1] : 0;                                  do                                  {                                      blens[i++] = c;                                  }                                  while (--j != 0);                                  index = i;                              }                          }                            tb[0] = -1;                          {                              int[] bl = new int[] { 9 };  // must be <= 9 for lookahead assumptions                              int[] bd = new int[] { 6 }; // must be <= 9 for lookahead assumptions                              int[] tl = new int[1];                              int[] td = new int[1];                                t = table;                              t = inftree.inflate_trees_dynamic(257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' _codec);                                if (t != ZlibConstants.Z_OK)                              {                                  if (t == ZlibConstants.Z_DATA_ERROR)                                  {                                      blens = null;                                      mode = InflateBlockMode.BAD;                                  }                                  r = t;                                    bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                              codes.Init(bl[0]' bd[0]' hufts' tl[0]' hufts' td[0]);                          }                          mode = InflateBlockMode.CODES;                          goto case InflateBlockMode.CODES;                        case InflateBlockMode.CODES:                          bitb = b; bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                            r = codes.Process(this' r);                          if (r != ZlibConstants.Z_STREAM_END)                          {                              return Flush(r);                          }                            r = ZlibConstants.Z_OK;                          p = _codec.NextIn;                          n = _codec.AvailableBytesIn;                          b = bitb;                          k = bitk;                          q = writeAt;                          m = (int)(q < readAt ? readAt - q - 1 : end - q);                            if (last == 0)                          {                              mode = InflateBlockMode.TYPE;                              break;                          }                          mode = InflateBlockMode.DRY;                          goto case InflateBlockMode.DRY;                        case InflateBlockMode.DRY:                          writeAt = q;                          r = Flush(r);                          q = writeAt; m = (int)(q < readAt ? readAt - q - 1 : end - q);                          if (readAt != writeAt)                          {                              bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                          mode = InflateBlockMode.DONE;                          goto case InflateBlockMode.DONE;                        case InflateBlockMode.DONE:                          r = ZlibConstants.Z_STREAM_END;                          bitb = b;                          bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                          return Flush(r);                        case InflateBlockMode.BAD:                          r = ZlibConstants.Z_DATA_ERROR;                            bitb = b; bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                          return Flush(r);                          default:                          r = ZlibConstants.Z_STREAM_ERROR;                            bitb = b; bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                          return Flush(r);                  }
Magic Number,Ionic.Zlib,InflateBlocks,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zlib.Shared\Inflate.cs,Process,The following statement contains a magic number: switch (mode)                  {                      case InflateBlockMode.TYPE:                            while (k < (3))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                                n--;                              b |= (_codec.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                          t = (int)(b & 7);                          last = t & 1;                            switch ((uint)t >> 1)                          {                              case 0:  // stored                                  b >>= 3; k -= (3);                                  t = k & 7; // go to byte boundary                                  b >>= t; k -= t;                                  mode = InflateBlockMode.LENS; // get length of stored block                                  break;                                case 1:  // fixed                                  int[] bl = new int[1];                                  int[] bd = new int[1];                                  int[][] tl = new int[1][];                                  int[][] td = new int[1][];                                  InfTree.inflate_trees_fixed(bl' bd' tl' td' _codec);                                  codes.Init(bl[0]' bd[0]' tl[0]' 0' td[0]' 0);                                  b >>= 3; k -= 3;                                  mode = InflateBlockMode.CODES;                                  break;                                case 2:  // dynamic                                  b >>= 3; k -= 3;                                  mode = InflateBlockMode.TABLE;                                  break;                                case 3:  // illegal                                  b >>= 3; k -= 3;                                  mode = InflateBlockMode.BAD;                                  _codec.Message = "invalid block type";                                  r = ZlibConstants.Z_DATA_ERROR;                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                          }                          break;                        case InflateBlockMode.LENS:                            while (k < (32))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                              ;                              n--;                              b |= (_codec.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            if ( ( ((~b)>>16) & 0xffff) != (b & 0xffff))                          {                              mode = InflateBlockMode.BAD;                              _codec.Message = "invalid stored block lengths";                              r = ZlibConstants.Z_DATA_ERROR;                                bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                          left = (b & 0xffff);                          b = k = 0; // dump bits                          mode = left != 0 ? InflateBlockMode.STORED : (last != 0 ? InflateBlockMode.DRY : InflateBlockMode.TYPE);                          break;                        case InflateBlockMode.STORED:                          if (n == 0)                          {                              bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                            if (m == 0)                          {                              if (q == end && readAt != 0)                              {                                  q = 0; m = (int)(q < readAt ? readAt - q - 1 : end - q);                              }                              if (m == 0)                              {                                  writeAt = q;                                  r = Flush(r);                                  q = writeAt; m = (int)(q < readAt ? readAt - q - 1 : end - q);                                  if (q == end && readAt != 0)                                  {                                      q = 0; m = (int)(q < readAt ? readAt - q - 1 : end - q);                                  }                                  if (m == 0)                                  {                                      bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                              }                          }                          r = ZlibConstants.Z_OK;                            t = left;                          if (t > n)                              t = n;                          if (t > m)                              t = m;                          Array.Copy(_codec.InputBuffer' p' window' q' t);                          p += t; n -= t;                          q += t; m -= t;                          if ((left -= t) != 0)                              break;                          mode = last != 0 ? InflateBlockMode.DRY : InflateBlockMode.TYPE;                          break;                        case InflateBlockMode.TABLE:                            while (k < (14))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                                n--;                              b |= (_codec.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            table = t = (b & 0x3fff);                          if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29)                          {                              mode = InflateBlockMode.BAD;                              _codec.Message = "too many length or distance symbols";                              r = ZlibConstants.Z_DATA_ERROR;                                bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                          t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);                          if (blens == null || blens.Length < t)                          {                              blens = new int[t];                          }                          else                          {                              Array.Clear(blens' 0' t);                              // for (int i = 0; i < t; i++)                              // {                              //     blens[i] = 0;                              // }                          }                            b >>= 14;                          k -= 14;                              index = 0;                          mode = InflateBlockMode.BTREE;                          goto case InflateBlockMode.BTREE;                        case InflateBlockMode.BTREE:                          while (index < 4 + (table >> 10))                          {                              while (k < (3))                              {                                  if (n != 0)                                  {                                      r = ZlibConstants.Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                                    n--;                                  b |= (_codec.InputBuffer[p++] & 0xff) << k;                                  k += 8;                              }                                blens[border[index++]] = b & 7;                                b >>= 3; k -= 3;                          }                            while (index < 19)                          {                              blens[border[index++]] = 0;                          }                            bb[0] = 7;                          t = inftree.inflate_trees_bits(blens' bb' tb' hufts' _codec);                          if (t != ZlibConstants.Z_OK)                          {                              r = t;                              if (r == ZlibConstants.Z_DATA_ERROR)                              {                                  blens = null;                                  mode = InflateBlockMode.BAD;                              }                                bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                            index = 0;                          mode = InflateBlockMode.DTREE;                          goto case InflateBlockMode.DTREE;                        case InflateBlockMode.DTREE:                          while (true)                          {                              t = table;                              if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)))                              {                                  break;                              }                                int i' j' c;                                t = bb[0];                                while (k < t)                              {                                  if (n != 0)                                  {                                      r = ZlibConstants.Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                                    n--;                                  b |= (_codec.InputBuffer[p++] & 0xff) << k;                                  k += 8;                              }                                t = hufts[(tb[0] + (b & InternalInflateConstants.InflateMask[t])) * 3 + 1];                              c = hufts[(tb[0] + (b & InternalInflateConstants.InflateMask[t])) * 3 + 2];                                if (c < 16)                              {                                  b >>= t; k -= t;                                  blens[index++] = c;                              }                              else                              {                                  // c == 16..18                                  i = c == 18 ? 7 : c - 14;                                  j = c == 18 ? 11 : 3;                                    while (k < (t + i))                                  {                                      if (n != 0)                                      {                                          r = ZlibConstants.Z_OK;                                      }                                      else                                      {                                          bitb = b; bitk = k;                                          _codec.AvailableBytesIn = n;                                          _codec.TotalBytesIn += p - _codec.NextIn;                                          _codec.NextIn = p;                                          writeAt = q;                                          return Flush(r);                                      }                                        n--;                                      b |= (_codec.InputBuffer[p++] & 0xff) << k;                                      k += 8;                                  }                                    b >>= t; k -= t;                                    j += (b & InternalInflateConstants.InflateMask[i]);                                    b >>= i; k -= i;                                    i = index;                                  t = table;                                  if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1))                                  {                                      blens = null;                                      mode = InflateBlockMode.BAD;                                      _codec.Message = "invalid bit length repeat";                                      r = ZlibConstants.Z_DATA_ERROR;                                        bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                                    c = (c == 16) ? blens[i-1] : 0;                                  do                                  {                                      blens[i++] = c;                                  }                                  while (--j != 0);                                  index = i;                              }                          }                            tb[0] = -1;                          {                              int[] bl = new int[] { 9 };  // must be <= 9 for lookahead assumptions                              int[] bd = new int[] { 6 }; // must be <= 9 for lookahead assumptions                              int[] tl = new int[1];                              int[] td = new int[1];                                t = table;                              t = inftree.inflate_trees_dynamic(257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' _codec);                                if (t != ZlibConstants.Z_OK)                              {                                  if (t == ZlibConstants.Z_DATA_ERROR)                                  {                                      blens = null;                                      mode = InflateBlockMode.BAD;                                  }                                  r = t;                                    bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                              codes.Init(bl[0]' bd[0]' hufts' tl[0]' hufts' td[0]);                          }                          mode = InflateBlockMode.CODES;                          goto case InflateBlockMode.CODES;                        case InflateBlockMode.CODES:                          bitb = b; bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                            r = codes.Process(this' r);                          if (r != ZlibConstants.Z_STREAM_END)                          {                              return Flush(r);                          }                            r = ZlibConstants.Z_OK;                          p = _codec.NextIn;                          n = _codec.AvailableBytesIn;                          b = bitb;                          k = bitk;                          q = writeAt;                          m = (int)(q < readAt ? readAt - q - 1 : end - q);                            if (last == 0)                          {                              mode = InflateBlockMode.TYPE;                              break;                          }                          mode = InflateBlockMode.DRY;                          goto case InflateBlockMode.DRY;                        case InflateBlockMode.DRY:                          writeAt = q;                          r = Flush(r);                          q = writeAt; m = (int)(q < readAt ? readAt - q - 1 : end - q);                          if (readAt != writeAt)                          {                              bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                          mode = InflateBlockMode.DONE;                          goto case InflateBlockMode.DONE;                        case InflateBlockMode.DONE:                          r = ZlibConstants.Z_STREAM_END;                          bitb = b;                          bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                          return Flush(r);                        case InflateBlockMode.BAD:                          r = ZlibConstants.Z_DATA_ERROR;                            bitb = b; bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                          return Flush(r);                          default:                          r = ZlibConstants.Z_STREAM_ERROR;                            bitb = b; bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                          return Flush(r);                  }
Magic Number,Ionic.Zlib,InflateBlocks,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zlib.Shared\Inflate.cs,Process,The following statement contains a magic number: switch (mode)                  {                      case InflateBlockMode.TYPE:                            while (k < (3))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                                n--;                              b |= (_codec.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                          t = (int)(b & 7);                          last = t & 1;                            switch ((uint)t >> 1)                          {                              case 0:  // stored                                  b >>= 3; k -= (3);                                  t = k & 7; // go to byte boundary                                  b >>= t; k -= t;                                  mode = InflateBlockMode.LENS; // get length of stored block                                  break;                                case 1:  // fixed                                  int[] bl = new int[1];                                  int[] bd = new int[1];                                  int[][] tl = new int[1][];                                  int[][] td = new int[1][];                                  InfTree.inflate_trees_fixed(bl' bd' tl' td' _codec);                                  codes.Init(bl[0]' bd[0]' tl[0]' 0' td[0]' 0);                                  b >>= 3; k -= 3;                                  mode = InflateBlockMode.CODES;                                  break;                                case 2:  // dynamic                                  b >>= 3; k -= 3;                                  mode = InflateBlockMode.TABLE;                                  break;                                case 3:  // illegal                                  b >>= 3; k -= 3;                                  mode = InflateBlockMode.BAD;                                  _codec.Message = "invalid block type";                                  r = ZlibConstants.Z_DATA_ERROR;                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                          }                          break;                        case InflateBlockMode.LENS:                            while (k < (32))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                              ;                              n--;                              b |= (_codec.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            if ( ( ((~b)>>16) & 0xffff) != (b & 0xffff))                          {                              mode = InflateBlockMode.BAD;                              _codec.Message = "invalid stored block lengths";                              r = ZlibConstants.Z_DATA_ERROR;                                bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                          left = (b & 0xffff);                          b = k = 0; // dump bits                          mode = left != 0 ? InflateBlockMode.STORED : (last != 0 ? InflateBlockMode.DRY : InflateBlockMode.TYPE);                          break;                        case InflateBlockMode.STORED:                          if (n == 0)                          {                              bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                            if (m == 0)                          {                              if (q == end && readAt != 0)                              {                                  q = 0; m = (int)(q < readAt ? readAt - q - 1 : end - q);                              }                              if (m == 0)                              {                                  writeAt = q;                                  r = Flush(r);                                  q = writeAt; m = (int)(q < readAt ? readAt - q - 1 : end - q);                                  if (q == end && readAt != 0)                                  {                                      q = 0; m = (int)(q < readAt ? readAt - q - 1 : end - q);                                  }                                  if (m == 0)                                  {                                      bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                              }                          }                          r = ZlibConstants.Z_OK;                            t = left;                          if (t > n)                              t = n;                          if (t > m)                              t = m;                          Array.Copy(_codec.InputBuffer' p' window' q' t);                          p += t; n -= t;                          q += t; m -= t;                          if ((left -= t) != 0)                              break;                          mode = last != 0 ? InflateBlockMode.DRY : InflateBlockMode.TYPE;                          break;                        case InflateBlockMode.TABLE:                            while (k < (14))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                                n--;                              b |= (_codec.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            table = t = (b & 0x3fff);                          if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29)                          {                              mode = InflateBlockMode.BAD;                              _codec.Message = "too many length or distance symbols";                              r = ZlibConstants.Z_DATA_ERROR;                                bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                          t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);                          if (blens == null || blens.Length < t)                          {                              blens = new int[t];                          }                          else                          {                              Array.Clear(blens' 0' t);                              // for (int i = 0; i < t; i++)                              // {                              //     blens[i] = 0;                              // }                          }                            b >>= 14;                          k -= 14;                              index = 0;                          mode = InflateBlockMode.BTREE;                          goto case InflateBlockMode.BTREE;                        case InflateBlockMode.BTREE:                          while (index < 4 + (table >> 10))                          {                              while (k < (3))                              {                                  if (n != 0)                                  {                                      r = ZlibConstants.Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                                    n--;                                  b |= (_codec.InputBuffer[p++] & 0xff) << k;                                  k += 8;                              }                                blens[border[index++]] = b & 7;                                b >>= 3; k -= 3;                          }                            while (index < 19)                          {                              blens[border[index++]] = 0;                          }                            bb[0] = 7;                          t = inftree.inflate_trees_bits(blens' bb' tb' hufts' _codec);                          if (t != ZlibConstants.Z_OK)                          {                              r = t;                              if (r == ZlibConstants.Z_DATA_ERROR)                              {                                  blens = null;                                  mode = InflateBlockMode.BAD;                              }                                bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                            index = 0;                          mode = InflateBlockMode.DTREE;                          goto case InflateBlockMode.DTREE;                        case InflateBlockMode.DTREE:                          while (true)                          {                              t = table;                              if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)))                              {                                  break;                              }                                int i' j' c;                                t = bb[0];                                while (k < t)                              {                                  if (n != 0)                                  {                                      r = ZlibConstants.Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                                    n--;                                  b |= (_codec.InputBuffer[p++] & 0xff) << k;                                  k += 8;                              }                                t = hufts[(tb[0] + (b & InternalInflateConstants.InflateMask[t])) * 3 + 1];                              c = hufts[(tb[0] + (b & InternalInflateConstants.InflateMask[t])) * 3 + 2];                                if (c < 16)                              {                                  b >>= t; k -= t;                                  blens[index++] = c;                              }                              else                              {                                  // c == 16..18                                  i = c == 18 ? 7 : c - 14;                                  j = c == 18 ? 11 : 3;                                    while (k < (t + i))                                  {                                      if (n != 0)                                      {                                          r = ZlibConstants.Z_OK;                                      }                                      else                                      {                                          bitb = b; bitk = k;                                          _codec.AvailableBytesIn = n;                                          _codec.TotalBytesIn += p - _codec.NextIn;                                          _codec.NextIn = p;                                          writeAt = q;                                          return Flush(r);                                      }                                        n--;                                      b |= (_codec.InputBuffer[p++] & 0xff) << k;                                      k += 8;                                  }                                    b >>= t; k -= t;                                    j += (b & InternalInflateConstants.InflateMask[i]);                                    b >>= i; k -= i;                                    i = index;                                  t = table;                                  if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1))                                  {                                      blens = null;                                      mode = InflateBlockMode.BAD;                                      _codec.Message = "invalid bit length repeat";                                      r = ZlibConstants.Z_DATA_ERROR;                                        bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                                    c = (c == 16) ? blens[i-1] : 0;                                  do                                  {                                      blens[i++] = c;                                  }                                  while (--j != 0);                                  index = i;                              }                          }                            tb[0] = -1;                          {                              int[] bl = new int[] { 9 };  // must be <= 9 for lookahead assumptions                              int[] bd = new int[] { 6 }; // must be <= 9 for lookahead assumptions                              int[] tl = new int[1];                              int[] td = new int[1];                                t = table;                              t = inftree.inflate_trees_dynamic(257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' _codec);                                if (t != ZlibConstants.Z_OK)                              {                                  if (t == ZlibConstants.Z_DATA_ERROR)                                  {                                      blens = null;                                      mode = InflateBlockMode.BAD;                                  }                                  r = t;                                    bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                              codes.Init(bl[0]' bd[0]' hufts' tl[0]' hufts' td[0]);                          }                          mode = InflateBlockMode.CODES;                          goto case InflateBlockMode.CODES;                        case InflateBlockMode.CODES:                          bitb = b; bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                            r = codes.Process(this' r);                          if (r != ZlibConstants.Z_STREAM_END)                          {                              return Flush(r);                          }                            r = ZlibConstants.Z_OK;                          p = _codec.NextIn;                          n = _codec.AvailableBytesIn;                          b = bitb;                          k = bitk;                          q = writeAt;                          m = (int)(q < readAt ? readAt - q - 1 : end - q);                            if (last == 0)                          {                              mode = InflateBlockMode.TYPE;                              break;                          }                          mode = InflateBlockMode.DRY;                          goto case InflateBlockMode.DRY;                        case InflateBlockMode.DRY:                          writeAt = q;                          r = Flush(r);                          q = writeAt; m = (int)(q < readAt ? readAt - q - 1 : end - q);                          if (readAt != writeAt)                          {                              bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                          mode = InflateBlockMode.DONE;                          goto case InflateBlockMode.DONE;                        case InflateBlockMode.DONE:                          r = ZlibConstants.Z_STREAM_END;                          bitb = b;                          bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                          return Flush(r);                        case InflateBlockMode.BAD:                          r = ZlibConstants.Z_DATA_ERROR;                            bitb = b; bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                          return Flush(r);                          default:                          r = ZlibConstants.Z_STREAM_ERROR;                            bitb = b; bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                          return Flush(r);                  }
Magic Number,Ionic.Zlib,InflateBlocks,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zlib.Shared\Inflate.cs,Process,The following statement contains a magic number: switch (mode)                  {                      case InflateBlockMode.TYPE:                            while (k < (3))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                                n--;                              b |= (_codec.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                          t = (int)(b & 7);                          last = t & 1;                            switch ((uint)t >> 1)                          {                              case 0:  // stored                                  b >>= 3; k -= (3);                                  t = k & 7; // go to byte boundary                                  b >>= t; k -= t;                                  mode = InflateBlockMode.LENS; // get length of stored block                                  break;                                case 1:  // fixed                                  int[] bl = new int[1];                                  int[] bd = new int[1];                                  int[][] tl = new int[1][];                                  int[][] td = new int[1][];                                  InfTree.inflate_trees_fixed(bl' bd' tl' td' _codec);                                  codes.Init(bl[0]' bd[0]' tl[0]' 0' td[0]' 0);                                  b >>= 3; k -= 3;                                  mode = InflateBlockMode.CODES;                                  break;                                case 2:  // dynamic                                  b >>= 3; k -= 3;                                  mode = InflateBlockMode.TABLE;                                  break;                                case 3:  // illegal                                  b >>= 3; k -= 3;                                  mode = InflateBlockMode.BAD;                                  _codec.Message = "invalid block type";                                  r = ZlibConstants.Z_DATA_ERROR;                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                          }                          break;                        case InflateBlockMode.LENS:                            while (k < (32))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                              ;                              n--;                              b |= (_codec.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            if ( ( ((~b)>>16) & 0xffff) != (b & 0xffff))                          {                              mode = InflateBlockMode.BAD;                              _codec.Message = "invalid stored block lengths";                              r = ZlibConstants.Z_DATA_ERROR;                                bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                          left = (b & 0xffff);                          b = k = 0; // dump bits                          mode = left != 0 ? InflateBlockMode.STORED : (last != 0 ? InflateBlockMode.DRY : InflateBlockMode.TYPE);                          break;                        case InflateBlockMode.STORED:                          if (n == 0)                          {                              bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                            if (m == 0)                          {                              if (q == end && readAt != 0)                              {                                  q = 0; m = (int)(q < readAt ? readAt - q - 1 : end - q);                              }                              if (m == 0)                              {                                  writeAt = q;                                  r = Flush(r);                                  q = writeAt; m = (int)(q < readAt ? readAt - q - 1 : end - q);                                  if (q == end && readAt != 0)                                  {                                      q = 0; m = (int)(q < readAt ? readAt - q - 1 : end - q);                                  }                                  if (m == 0)                                  {                                      bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                              }                          }                          r = ZlibConstants.Z_OK;                            t = left;                          if (t > n)                              t = n;                          if (t > m)                              t = m;                          Array.Copy(_codec.InputBuffer' p' window' q' t);                          p += t; n -= t;                          q += t; m -= t;                          if ((left -= t) != 0)                              break;                          mode = last != 0 ? InflateBlockMode.DRY : InflateBlockMode.TYPE;                          break;                        case InflateBlockMode.TABLE:                            while (k < (14))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                                n--;                              b |= (_codec.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            table = t = (b & 0x3fff);                          if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29)                          {                              mode = InflateBlockMode.BAD;                              _codec.Message = "too many length or distance symbols";                              r = ZlibConstants.Z_DATA_ERROR;                                bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                          t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);                          if (blens == null || blens.Length < t)                          {                              blens = new int[t];                          }                          else                          {                              Array.Clear(blens' 0' t);                              // for (int i = 0; i < t; i++)                              // {                              //     blens[i] = 0;                              // }                          }                            b >>= 14;                          k -= 14;                              index = 0;                          mode = InflateBlockMode.BTREE;                          goto case InflateBlockMode.BTREE;                        case InflateBlockMode.BTREE:                          while (index < 4 + (table >> 10))                          {                              while (k < (3))                              {                                  if (n != 0)                                  {                                      r = ZlibConstants.Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                                    n--;                                  b |= (_codec.InputBuffer[p++] & 0xff) << k;                                  k += 8;                              }                                blens[border[index++]] = b & 7;                                b >>= 3; k -= 3;                          }                            while (index < 19)                          {                              blens[border[index++]] = 0;                          }                            bb[0] = 7;                          t = inftree.inflate_trees_bits(blens' bb' tb' hufts' _codec);                          if (t != ZlibConstants.Z_OK)                          {                              r = t;                              if (r == ZlibConstants.Z_DATA_ERROR)                              {                                  blens = null;                                  mode = InflateBlockMode.BAD;                              }                                bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                            index = 0;                          mode = InflateBlockMode.DTREE;                          goto case InflateBlockMode.DTREE;                        case InflateBlockMode.DTREE:                          while (true)                          {                              t = table;                              if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)))                              {                                  break;                              }                                int i' j' c;                                t = bb[0];                                while (k < t)                              {                                  if (n != 0)                                  {                                      r = ZlibConstants.Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                                    n--;                                  b |= (_codec.InputBuffer[p++] & 0xff) << k;                                  k += 8;                              }                                t = hufts[(tb[0] + (b & InternalInflateConstants.InflateMask[t])) * 3 + 1];                              c = hufts[(tb[0] + (b & InternalInflateConstants.InflateMask[t])) * 3 + 2];                                if (c < 16)                              {                                  b >>= t; k -= t;                                  blens[index++] = c;                              }                              else                              {                                  // c == 16..18                                  i = c == 18 ? 7 : c - 14;                                  j = c == 18 ? 11 : 3;                                    while (k < (t + i))                                  {                                      if (n != 0)                                      {                                          r = ZlibConstants.Z_OK;                                      }                                      else                                      {                                          bitb = b; bitk = k;                                          _codec.AvailableBytesIn = n;                                          _codec.TotalBytesIn += p - _codec.NextIn;                                          _codec.NextIn = p;                                          writeAt = q;                                          return Flush(r);                                      }                                        n--;                                      b |= (_codec.InputBuffer[p++] & 0xff) << k;                                      k += 8;                                  }                                    b >>= t; k -= t;                                    j += (b & InternalInflateConstants.InflateMask[i]);                                    b >>= i; k -= i;                                    i = index;                                  t = table;                                  if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1))                                  {                                      blens = null;                                      mode = InflateBlockMode.BAD;                                      _codec.Message = "invalid bit length repeat";                                      r = ZlibConstants.Z_DATA_ERROR;                                        bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                                    c = (c == 16) ? blens[i-1] : 0;                                  do                                  {                                      blens[i++] = c;                                  }                                  while (--j != 0);                                  index = i;                              }                          }                            tb[0] = -1;                          {                              int[] bl = new int[] { 9 };  // must be <= 9 for lookahead assumptions                              int[] bd = new int[] { 6 }; // must be <= 9 for lookahead assumptions                              int[] tl = new int[1];                              int[] td = new int[1];                                t = table;                              t = inftree.inflate_trees_dynamic(257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' _codec);                                if (t != ZlibConstants.Z_OK)                              {                                  if (t == ZlibConstants.Z_DATA_ERROR)                                  {                                      blens = null;                                      mode = InflateBlockMode.BAD;                                  }                                  r = t;                                    bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                              codes.Init(bl[0]' bd[0]' hufts' tl[0]' hufts' td[0]);                          }                          mode = InflateBlockMode.CODES;                          goto case InflateBlockMode.CODES;                        case InflateBlockMode.CODES:                          bitb = b; bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                            r = codes.Process(this' r);                          if (r != ZlibConstants.Z_STREAM_END)                          {                              return Flush(r);                          }                            r = ZlibConstants.Z_OK;                          p = _codec.NextIn;                          n = _codec.AvailableBytesIn;                          b = bitb;                          k = bitk;                          q = writeAt;                          m = (int)(q < readAt ? readAt - q - 1 : end - q);                            if (last == 0)                          {                              mode = InflateBlockMode.TYPE;                              break;                          }                          mode = InflateBlockMode.DRY;                          goto case InflateBlockMode.DRY;                        case InflateBlockMode.DRY:                          writeAt = q;                          r = Flush(r);                          q = writeAt; m = (int)(q < readAt ? readAt - q - 1 : end - q);                          if (readAt != writeAt)                          {                              bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                          mode = InflateBlockMode.DONE;                          goto case InflateBlockMode.DONE;                        case InflateBlockMode.DONE:                          r = ZlibConstants.Z_STREAM_END;                          bitb = b;                          bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                          return Flush(r);                        case InflateBlockMode.BAD:                          r = ZlibConstants.Z_DATA_ERROR;                            bitb = b; bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                          return Flush(r);                          default:                          r = ZlibConstants.Z_STREAM_ERROR;                            bitb = b; bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                          return Flush(r);                  }
Magic Number,Ionic.Zlib,InflateBlocks,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zlib.Shared\Inflate.cs,Process,The following statement contains a magic number: switch (mode)                  {                      case InflateBlockMode.TYPE:                            while (k < (3))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                                n--;                              b |= (_codec.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                          t = (int)(b & 7);                          last = t & 1;                            switch ((uint)t >> 1)                          {                              case 0:  // stored                                  b >>= 3; k -= (3);                                  t = k & 7; // go to byte boundary                                  b >>= t; k -= t;                                  mode = InflateBlockMode.LENS; // get length of stored block                                  break;                                case 1:  // fixed                                  int[] bl = new int[1];                                  int[] bd = new int[1];                                  int[][] tl = new int[1][];                                  int[][] td = new int[1][];                                  InfTree.inflate_trees_fixed(bl' bd' tl' td' _codec);                                  codes.Init(bl[0]' bd[0]' tl[0]' 0' td[0]' 0);                                  b >>= 3; k -= 3;                                  mode = InflateBlockMode.CODES;                                  break;                                case 2:  // dynamic                                  b >>= 3; k -= 3;                                  mode = InflateBlockMode.TABLE;                                  break;                                case 3:  // illegal                                  b >>= 3; k -= 3;                                  mode = InflateBlockMode.BAD;                                  _codec.Message = "invalid block type";                                  r = ZlibConstants.Z_DATA_ERROR;                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                          }                          break;                        case InflateBlockMode.LENS:                            while (k < (32))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                              ;                              n--;                              b |= (_codec.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            if ( ( ((~b)>>16) & 0xffff) != (b & 0xffff))                          {                              mode = InflateBlockMode.BAD;                              _codec.Message = "invalid stored block lengths";                              r = ZlibConstants.Z_DATA_ERROR;                                bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                          left = (b & 0xffff);                          b = k = 0; // dump bits                          mode = left != 0 ? InflateBlockMode.STORED : (last != 0 ? InflateBlockMode.DRY : InflateBlockMode.TYPE);                          break;                        case InflateBlockMode.STORED:                          if (n == 0)                          {                              bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                            if (m == 0)                          {                              if (q == end && readAt != 0)                              {                                  q = 0; m = (int)(q < readAt ? readAt - q - 1 : end - q);                              }                              if (m == 0)                              {                                  writeAt = q;                                  r = Flush(r);                                  q = writeAt; m = (int)(q < readAt ? readAt - q - 1 : end - q);                                  if (q == end && readAt != 0)                                  {                                      q = 0; m = (int)(q < readAt ? readAt - q - 1 : end - q);                                  }                                  if (m == 0)                                  {                                      bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                              }                          }                          r = ZlibConstants.Z_OK;                            t = left;                          if (t > n)                              t = n;                          if (t > m)                              t = m;                          Array.Copy(_codec.InputBuffer' p' window' q' t);                          p += t; n -= t;                          q += t; m -= t;                          if ((left -= t) != 0)                              break;                          mode = last != 0 ? InflateBlockMode.DRY : InflateBlockMode.TYPE;                          break;                        case InflateBlockMode.TABLE:                            while (k < (14))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                                n--;                              b |= (_codec.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            table = t = (b & 0x3fff);                          if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29)                          {                              mode = InflateBlockMode.BAD;                              _codec.Message = "too many length or distance symbols";                              r = ZlibConstants.Z_DATA_ERROR;                                bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                          t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);                          if (blens == null || blens.Length < t)                          {                              blens = new int[t];                          }                          else                          {                              Array.Clear(blens' 0' t);                              // for (int i = 0; i < t; i++)                              // {                              //     blens[i] = 0;                              // }                          }                            b >>= 14;                          k -= 14;                              index = 0;                          mode = InflateBlockMode.BTREE;                          goto case InflateBlockMode.BTREE;                        case InflateBlockMode.BTREE:                          while (index < 4 + (table >> 10))                          {                              while (k < (3))                              {                                  if (n != 0)                                  {                                      r = ZlibConstants.Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                                    n--;                                  b |= (_codec.InputBuffer[p++] & 0xff) << k;                                  k += 8;                              }                                blens[border[index++]] = b & 7;                                b >>= 3; k -= 3;                          }                            while (index < 19)                          {                              blens[border[index++]] = 0;                          }                            bb[0] = 7;                          t = inftree.inflate_trees_bits(blens' bb' tb' hufts' _codec);                          if (t != ZlibConstants.Z_OK)                          {                              r = t;                              if (r == ZlibConstants.Z_DATA_ERROR)                              {                                  blens = null;                                  mode = InflateBlockMode.BAD;                              }                                bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                            index = 0;                          mode = InflateBlockMode.DTREE;                          goto case InflateBlockMode.DTREE;                        case InflateBlockMode.DTREE:                          while (true)                          {                              t = table;                              if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)))                              {                                  break;                              }                                int i' j' c;                                t = bb[0];                                while (k < t)                              {                                  if (n != 0)                                  {                                      r = ZlibConstants.Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                                    n--;                                  b |= (_codec.InputBuffer[p++] & 0xff) << k;                                  k += 8;                              }                                t = hufts[(tb[0] + (b & InternalInflateConstants.InflateMask[t])) * 3 + 1];                              c = hufts[(tb[0] + (b & InternalInflateConstants.InflateMask[t])) * 3 + 2];                                if (c < 16)                              {                                  b >>= t; k -= t;                                  blens[index++] = c;                              }                              else                              {                                  // c == 16..18                                  i = c == 18 ? 7 : c - 14;                                  j = c == 18 ? 11 : 3;                                    while (k < (t + i))                                  {                                      if (n != 0)                                      {                                          r = ZlibConstants.Z_OK;                                      }                                      else                                      {                                          bitb = b; bitk = k;                                          _codec.AvailableBytesIn = n;                                          _codec.TotalBytesIn += p - _codec.NextIn;                                          _codec.NextIn = p;                                          writeAt = q;                                          return Flush(r);                                      }                                        n--;                                      b |= (_codec.InputBuffer[p++] & 0xff) << k;                                      k += 8;                                  }                                    b >>= t; k -= t;                                    j += (b & InternalInflateConstants.InflateMask[i]);                                    b >>= i; k -= i;                                    i = index;                                  t = table;                                  if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1))                                  {                                      blens = null;                                      mode = InflateBlockMode.BAD;                                      _codec.Message = "invalid bit length repeat";                                      r = ZlibConstants.Z_DATA_ERROR;                                        bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                                    c = (c == 16) ? blens[i-1] : 0;                                  do                                  {                                      blens[i++] = c;                                  }                                  while (--j != 0);                                  index = i;                              }                          }                            tb[0] = -1;                          {                              int[] bl = new int[] { 9 };  // must be <= 9 for lookahead assumptions                              int[] bd = new int[] { 6 }; // must be <= 9 for lookahead assumptions                              int[] tl = new int[1];                              int[] td = new int[1];                                t = table;                              t = inftree.inflate_trees_dynamic(257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' _codec);                                if (t != ZlibConstants.Z_OK)                              {                                  if (t == ZlibConstants.Z_DATA_ERROR)                                  {                                      blens = null;                                      mode = InflateBlockMode.BAD;                                  }                                  r = t;                                    bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                              codes.Init(bl[0]' bd[0]' hufts' tl[0]' hufts' td[0]);                          }                          mode = InflateBlockMode.CODES;                          goto case InflateBlockMode.CODES;                        case InflateBlockMode.CODES:                          bitb = b; bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                            r = codes.Process(this' r);                          if (r != ZlibConstants.Z_STREAM_END)                          {                              return Flush(r);                          }                            r = ZlibConstants.Z_OK;                          p = _codec.NextIn;                          n = _codec.AvailableBytesIn;                          b = bitb;                          k = bitk;                          q = writeAt;                          m = (int)(q < readAt ? readAt - q - 1 : end - q);                            if (last == 0)                          {                              mode = InflateBlockMode.TYPE;                              break;                          }                          mode = InflateBlockMode.DRY;                          goto case InflateBlockMode.DRY;                        case InflateBlockMode.DRY:                          writeAt = q;                          r = Flush(r);                          q = writeAt; m = (int)(q < readAt ? readAt - q - 1 : end - q);                          if (readAt != writeAt)                          {                              bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                          mode = InflateBlockMode.DONE;                          goto case InflateBlockMode.DONE;                        case InflateBlockMode.DONE:                          r = ZlibConstants.Z_STREAM_END;                          bitb = b;                          bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                          return Flush(r);                        case InflateBlockMode.BAD:                          r = ZlibConstants.Z_DATA_ERROR;                            bitb = b; bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                          return Flush(r);                          default:                          r = ZlibConstants.Z_STREAM_ERROR;                            bitb = b; bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                          return Flush(r);                  }
Magic Number,Ionic.Zlib,InflateBlocks,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zlib.Shared\Inflate.cs,Process,The following statement contains a magic number: switch (mode)                  {                      case InflateBlockMode.TYPE:                            while (k < (3))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                                n--;                              b |= (_codec.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                          t = (int)(b & 7);                          last = t & 1;                            switch ((uint)t >> 1)                          {                              case 0:  // stored                                  b >>= 3; k -= (3);                                  t = k & 7; // go to byte boundary                                  b >>= t; k -= t;                                  mode = InflateBlockMode.LENS; // get length of stored block                                  break;                                case 1:  // fixed                                  int[] bl = new int[1];                                  int[] bd = new int[1];                                  int[][] tl = new int[1][];                                  int[][] td = new int[1][];                                  InfTree.inflate_trees_fixed(bl' bd' tl' td' _codec);                                  codes.Init(bl[0]' bd[0]' tl[0]' 0' td[0]' 0);                                  b >>= 3; k -= 3;                                  mode = InflateBlockMode.CODES;                                  break;                                case 2:  // dynamic                                  b >>= 3; k -= 3;                                  mode = InflateBlockMode.TABLE;                                  break;                                case 3:  // illegal                                  b >>= 3; k -= 3;                                  mode = InflateBlockMode.BAD;                                  _codec.Message = "invalid block type";                                  r = ZlibConstants.Z_DATA_ERROR;                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                          }                          break;                        case InflateBlockMode.LENS:                            while (k < (32))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                              ;                              n--;                              b |= (_codec.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            if ( ( ((~b)>>16) & 0xffff) != (b & 0xffff))                          {                              mode = InflateBlockMode.BAD;                              _codec.Message = "invalid stored block lengths";                              r = ZlibConstants.Z_DATA_ERROR;                                bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                          left = (b & 0xffff);                          b = k = 0; // dump bits                          mode = left != 0 ? InflateBlockMode.STORED : (last != 0 ? InflateBlockMode.DRY : InflateBlockMode.TYPE);                          break;                        case InflateBlockMode.STORED:                          if (n == 0)                          {                              bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                            if (m == 0)                          {                              if (q == end && readAt != 0)                              {                                  q = 0; m = (int)(q < readAt ? readAt - q - 1 : end - q);                              }                              if (m == 0)                              {                                  writeAt = q;                                  r = Flush(r);                                  q = writeAt; m = (int)(q < readAt ? readAt - q - 1 : end - q);                                  if (q == end && readAt != 0)                                  {                                      q = 0; m = (int)(q < readAt ? readAt - q - 1 : end - q);                                  }                                  if (m == 0)                                  {                                      bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                              }                          }                          r = ZlibConstants.Z_OK;                            t = left;                          if (t > n)                              t = n;                          if (t > m)                              t = m;                          Array.Copy(_codec.InputBuffer' p' window' q' t);                          p += t; n -= t;                          q += t; m -= t;                          if ((left -= t) != 0)                              break;                          mode = last != 0 ? InflateBlockMode.DRY : InflateBlockMode.TYPE;                          break;                        case InflateBlockMode.TABLE:                            while (k < (14))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                                n--;                              b |= (_codec.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            table = t = (b & 0x3fff);                          if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29)                          {                              mode = InflateBlockMode.BAD;                              _codec.Message = "too many length or distance symbols";                              r = ZlibConstants.Z_DATA_ERROR;                                bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                          t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);                          if (blens == null || blens.Length < t)                          {                              blens = new int[t];                          }                          else                          {                              Array.Clear(blens' 0' t);                              // for (int i = 0; i < t; i++)                              // {                              //     blens[i] = 0;                              // }                          }                            b >>= 14;                          k -= 14;                              index = 0;                          mode = InflateBlockMode.BTREE;                          goto case InflateBlockMode.BTREE;                        case InflateBlockMode.BTREE:                          while (index < 4 + (table >> 10))                          {                              while (k < (3))                              {                                  if (n != 0)                                  {                                      r = ZlibConstants.Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                                    n--;                                  b |= (_codec.InputBuffer[p++] & 0xff) << k;                                  k += 8;                              }                                blens[border[index++]] = b & 7;                                b >>= 3; k -= 3;                          }                            while (index < 19)                          {                              blens[border[index++]] = 0;                          }                            bb[0] = 7;                          t = inftree.inflate_trees_bits(blens' bb' tb' hufts' _codec);                          if (t != ZlibConstants.Z_OK)                          {                              r = t;                              if (r == ZlibConstants.Z_DATA_ERROR)                              {                                  blens = null;                                  mode = InflateBlockMode.BAD;                              }                                bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                            index = 0;                          mode = InflateBlockMode.DTREE;                          goto case InflateBlockMode.DTREE;                        case InflateBlockMode.DTREE:                          while (true)                          {                              t = table;                              if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)))                              {                                  break;                              }                                int i' j' c;                                t = bb[0];                                while (k < t)                              {                                  if (n != 0)                                  {                                      r = ZlibConstants.Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                                    n--;                                  b |= (_codec.InputBuffer[p++] & 0xff) << k;                                  k += 8;                              }                                t = hufts[(tb[0] + (b & InternalInflateConstants.InflateMask[t])) * 3 + 1];                              c = hufts[(tb[0] + (b & InternalInflateConstants.InflateMask[t])) * 3 + 2];                                if (c < 16)                              {                                  b >>= t; k -= t;                                  blens[index++] = c;                              }                              else                              {                                  // c == 16..18                                  i = c == 18 ? 7 : c - 14;                                  j = c == 18 ? 11 : 3;                                    while (k < (t + i))                                  {                                      if (n != 0)                                      {                                          r = ZlibConstants.Z_OK;                                      }                                      else                                      {                                          bitb = b; bitk = k;                                          _codec.AvailableBytesIn = n;                                          _codec.TotalBytesIn += p - _codec.NextIn;                                          _codec.NextIn = p;                                          writeAt = q;                                          return Flush(r);                                      }                                        n--;                                      b |= (_codec.InputBuffer[p++] & 0xff) << k;                                      k += 8;                                  }                                    b >>= t; k -= t;                                    j += (b & InternalInflateConstants.InflateMask[i]);                                    b >>= i; k -= i;                                    i = index;                                  t = table;                                  if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1))                                  {                                      blens = null;                                      mode = InflateBlockMode.BAD;                                      _codec.Message = "invalid bit length repeat";                                      r = ZlibConstants.Z_DATA_ERROR;                                        bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                                    c = (c == 16) ? blens[i-1] : 0;                                  do                                  {                                      blens[i++] = c;                                  }                                  while (--j != 0);                                  index = i;                              }                          }                            tb[0] = -1;                          {                              int[] bl = new int[] { 9 };  // must be <= 9 for lookahead assumptions                              int[] bd = new int[] { 6 }; // must be <= 9 for lookahead assumptions                              int[] tl = new int[1];                              int[] td = new int[1];                                t = table;                              t = inftree.inflate_trees_dynamic(257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' _codec);                                if (t != ZlibConstants.Z_OK)                              {                                  if (t == ZlibConstants.Z_DATA_ERROR)                                  {                                      blens = null;                                      mode = InflateBlockMode.BAD;                                  }                                  r = t;                                    bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                              codes.Init(bl[0]' bd[0]' hufts' tl[0]' hufts' td[0]);                          }                          mode = InflateBlockMode.CODES;                          goto case InflateBlockMode.CODES;                        case InflateBlockMode.CODES:                          bitb = b; bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                            r = codes.Process(this' r);                          if (r != ZlibConstants.Z_STREAM_END)                          {                              return Flush(r);                          }                            r = ZlibConstants.Z_OK;                          p = _codec.NextIn;                          n = _codec.AvailableBytesIn;                          b = bitb;                          k = bitk;                          q = writeAt;                          m = (int)(q < readAt ? readAt - q - 1 : end - q);                            if (last == 0)                          {                              mode = InflateBlockMode.TYPE;                              break;                          }                          mode = InflateBlockMode.DRY;                          goto case InflateBlockMode.DRY;                        case InflateBlockMode.DRY:                          writeAt = q;                          r = Flush(r);                          q = writeAt; m = (int)(q < readAt ? readAt - q - 1 : end - q);                          if (readAt != writeAt)                          {                              bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                          mode = InflateBlockMode.DONE;                          goto case InflateBlockMode.DONE;                        case InflateBlockMode.DONE:                          r = ZlibConstants.Z_STREAM_END;                          bitb = b;                          bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                          return Flush(r);                        case InflateBlockMode.BAD:                          r = ZlibConstants.Z_DATA_ERROR;                            bitb = b; bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                          return Flush(r);                          default:                          r = ZlibConstants.Z_STREAM_ERROR;                            bitb = b; bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                          return Flush(r);                  }
Magic Number,Ionic.Zlib,InflateBlocks,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zlib.Shared\Inflate.cs,Process,The following statement contains a magic number: switch (mode)                  {                      case InflateBlockMode.TYPE:                            while (k < (3))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                                n--;                              b |= (_codec.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                          t = (int)(b & 7);                          last = t & 1;                            switch ((uint)t >> 1)                          {                              case 0:  // stored                                  b >>= 3; k -= (3);                                  t = k & 7; // go to byte boundary                                  b >>= t; k -= t;                                  mode = InflateBlockMode.LENS; // get length of stored block                                  break;                                case 1:  // fixed                                  int[] bl = new int[1];                                  int[] bd = new int[1];                                  int[][] tl = new int[1][];                                  int[][] td = new int[1][];                                  InfTree.inflate_trees_fixed(bl' bd' tl' td' _codec);                                  codes.Init(bl[0]' bd[0]' tl[0]' 0' td[0]' 0);                                  b >>= 3; k -= 3;                                  mode = InflateBlockMode.CODES;                                  break;                                case 2:  // dynamic                                  b >>= 3; k -= 3;                                  mode = InflateBlockMode.TABLE;                                  break;                                case 3:  // illegal                                  b >>= 3; k -= 3;                                  mode = InflateBlockMode.BAD;                                  _codec.Message = "invalid block type";                                  r = ZlibConstants.Z_DATA_ERROR;                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                          }                          break;                        case InflateBlockMode.LENS:                            while (k < (32))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                              ;                              n--;                              b |= (_codec.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            if ( ( ((~b)>>16) & 0xffff) != (b & 0xffff))                          {                              mode = InflateBlockMode.BAD;                              _codec.Message = "invalid stored block lengths";                              r = ZlibConstants.Z_DATA_ERROR;                                bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                          left = (b & 0xffff);                          b = k = 0; // dump bits                          mode = left != 0 ? InflateBlockMode.STORED : (last != 0 ? InflateBlockMode.DRY : InflateBlockMode.TYPE);                          break;                        case InflateBlockMode.STORED:                          if (n == 0)                          {                              bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                            if (m == 0)                          {                              if (q == end && readAt != 0)                              {                                  q = 0; m = (int)(q < readAt ? readAt - q - 1 : end - q);                              }                              if (m == 0)                              {                                  writeAt = q;                                  r = Flush(r);                                  q = writeAt; m = (int)(q < readAt ? readAt - q - 1 : end - q);                                  if (q == end && readAt != 0)                                  {                                      q = 0; m = (int)(q < readAt ? readAt - q - 1 : end - q);                                  }                                  if (m == 0)                                  {                                      bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                              }                          }                          r = ZlibConstants.Z_OK;                            t = left;                          if (t > n)                              t = n;                          if (t > m)                              t = m;                          Array.Copy(_codec.InputBuffer' p' window' q' t);                          p += t; n -= t;                          q += t; m -= t;                          if ((left -= t) != 0)                              break;                          mode = last != 0 ? InflateBlockMode.DRY : InflateBlockMode.TYPE;                          break;                        case InflateBlockMode.TABLE:                            while (k < (14))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                                n--;                              b |= (_codec.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            table = t = (b & 0x3fff);                          if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29)                          {                              mode = InflateBlockMode.BAD;                              _codec.Message = "too many length or distance symbols";                              r = ZlibConstants.Z_DATA_ERROR;                                bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                          t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);                          if (blens == null || blens.Length < t)                          {                              blens = new int[t];                          }                          else                          {                              Array.Clear(blens' 0' t);                              // for (int i = 0; i < t; i++)                              // {                              //     blens[i] = 0;                              // }                          }                            b >>= 14;                          k -= 14;                              index = 0;                          mode = InflateBlockMode.BTREE;                          goto case InflateBlockMode.BTREE;                        case InflateBlockMode.BTREE:                          while (index < 4 + (table >> 10))                          {                              while (k < (3))                              {                                  if (n != 0)                                  {                                      r = ZlibConstants.Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                                    n--;                                  b |= (_codec.InputBuffer[p++] & 0xff) << k;                                  k += 8;                              }                                blens[border[index++]] = b & 7;                                b >>= 3; k -= 3;                          }                            while (index < 19)                          {                              blens[border[index++]] = 0;                          }                            bb[0] = 7;                          t = inftree.inflate_trees_bits(blens' bb' tb' hufts' _codec);                          if (t != ZlibConstants.Z_OK)                          {                              r = t;                              if (r == ZlibConstants.Z_DATA_ERROR)                              {                                  blens = null;                                  mode = InflateBlockMode.BAD;                              }                                bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                            index = 0;                          mode = InflateBlockMode.DTREE;                          goto case InflateBlockMode.DTREE;                        case InflateBlockMode.DTREE:                          while (true)                          {                              t = table;                              if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)))                              {                                  break;                              }                                int i' j' c;                                t = bb[0];                                while (k < t)                              {                                  if (n != 0)                                  {                                      r = ZlibConstants.Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                                    n--;                                  b |= (_codec.InputBuffer[p++] & 0xff) << k;                                  k += 8;                              }                                t = hufts[(tb[0] + (b & InternalInflateConstants.InflateMask[t])) * 3 + 1];                              c = hufts[(tb[0] + (b & InternalInflateConstants.InflateMask[t])) * 3 + 2];                                if (c < 16)                              {                                  b >>= t; k -= t;                                  blens[index++] = c;                              }                              else                              {                                  // c == 16..18                                  i = c == 18 ? 7 : c - 14;                                  j = c == 18 ? 11 : 3;                                    while (k < (t + i))                                  {                                      if (n != 0)                                      {                                          r = ZlibConstants.Z_OK;                                      }                                      else                                      {                                          bitb = b; bitk = k;                                          _codec.AvailableBytesIn = n;                                          _codec.TotalBytesIn += p - _codec.NextIn;                                          _codec.NextIn = p;                                          writeAt = q;                                          return Flush(r);                                      }                                        n--;                                      b |= (_codec.InputBuffer[p++] & 0xff) << k;                                      k += 8;                                  }                                    b >>= t; k -= t;                                    j += (b & InternalInflateConstants.InflateMask[i]);                                    b >>= i; k -= i;                                    i = index;                                  t = table;                                  if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1))                                  {                                      blens = null;                                      mode = InflateBlockMode.BAD;                                      _codec.Message = "invalid bit length repeat";                                      r = ZlibConstants.Z_DATA_ERROR;                                        bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                                    c = (c == 16) ? blens[i-1] : 0;                                  do                                  {                                      blens[i++] = c;                                  }                                  while (--j != 0);                                  index = i;                              }                          }                            tb[0] = -1;                          {                              int[] bl = new int[] { 9 };  // must be <= 9 for lookahead assumptions                              int[] bd = new int[] { 6 }; // must be <= 9 for lookahead assumptions                              int[] tl = new int[1];                              int[] td = new int[1];                                t = table;                              t = inftree.inflate_trees_dynamic(257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' _codec);                                if (t != ZlibConstants.Z_OK)                              {                                  if (t == ZlibConstants.Z_DATA_ERROR)                                  {                                      blens = null;                                      mode = InflateBlockMode.BAD;                                  }                                  r = t;                                    bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                              codes.Init(bl[0]' bd[0]' hufts' tl[0]' hufts' td[0]);                          }                          mode = InflateBlockMode.CODES;                          goto case InflateBlockMode.CODES;                        case InflateBlockMode.CODES:                          bitb = b; bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                            r = codes.Process(this' r);                          if (r != ZlibConstants.Z_STREAM_END)                          {                              return Flush(r);                          }                            r = ZlibConstants.Z_OK;                          p = _codec.NextIn;                          n = _codec.AvailableBytesIn;                          b = bitb;                          k = bitk;                          q = writeAt;                          m = (int)(q < readAt ? readAt - q - 1 : end - q);                            if (last == 0)                          {                              mode = InflateBlockMode.TYPE;                              break;                          }                          mode = InflateBlockMode.DRY;                          goto case InflateBlockMode.DRY;                        case InflateBlockMode.DRY:                          writeAt = q;                          r = Flush(r);                          q = writeAt; m = (int)(q < readAt ? readAt - q - 1 : end - q);                          if (readAt != writeAt)                          {                              bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                          mode = InflateBlockMode.DONE;                          goto case InflateBlockMode.DONE;                        case InflateBlockMode.DONE:                          r = ZlibConstants.Z_STREAM_END;                          bitb = b;                          bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                          return Flush(r);                        case InflateBlockMode.BAD:                          r = ZlibConstants.Z_DATA_ERROR;                            bitb = b; bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                          return Flush(r);                          default:                          r = ZlibConstants.Z_STREAM_ERROR;                            bitb = b; bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                          return Flush(r);                  }
Magic Number,Ionic.Zlib,InflateBlocks,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zlib.Shared\Inflate.cs,Process,The following statement contains a magic number: switch (mode)                  {                      case InflateBlockMode.TYPE:                            while (k < (3))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                                n--;                              b |= (_codec.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                          t = (int)(b & 7);                          last = t & 1;                            switch ((uint)t >> 1)                          {                              case 0:  // stored                                  b >>= 3; k -= (3);                                  t = k & 7; // go to byte boundary                                  b >>= t; k -= t;                                  mode = InflateBlockMode.LENS; // get length of stored block                                  break;                                case 1:  // fixed                                  int[] bl = new int[1];                                  int[] bd = new int[1];                                  int[][] tl = new int[1][];                                  int[][] td = new int[1][];                                  InfTree.inflate_trees_fixed(bl' bd' tl' td' _codec);                                  codes.Init(bl[0]' bd[0]' tl[0]' 0' td[0]' 0);                                  b >>= 3; k -= 3;                                  mode = InflateBlockMode.CODES;                                  break;                                case 2:  // dynamic                                  b >>= 3; k -= 3;                                  mode = InflateBlockMode.TABLE;                                  break;                                case 3:  // illegal                                  b >>= 3; k -= 3;                                  mode = InflateBlockMode.BAD;                                  _codec.Message = "invalid block type";                                  r = ZlibConstants.Z_DATA_ERROR;                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                          }                          break;                        case InflateBlockMode.LENS:                            while (k < (32))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                              ;                              n--;                              b |= (_codec.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            if ( ( ((~b)>>16) & 0xffff) != (b & 0xffff))                          {                              mode = InflateBlockMode.BAD;                              _codec.Message = "invalid stored block lengths";                              r = ZlibConstants.Z_DATA_ERROR;                                bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                          left = (b & 0xffff);                          b = k = 0; // dump bits                          mode = left != 0 ? InflateBlockMode.STORED : (last != 0 ? InflateBlockMode.DRY : InflateBlockMode.TYPE);                          break;                        case InflateBlockMode.STORED:                          if (n == 0)                          {                              bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                            if (m == 0)                          {                              if (q == end && readAt != 0)                              {                                  q = 0; m = (int)(q < readAt ? readAt - q - 1 : end - q);                              }                              if (m == 0)                              {                                  writeAt = q;                                  r = Flush(r);                                  q = writeAt; m = (int)(q < readAt ? readAt - q - 1 : end - q);                                  if (q == end && readAt != 0)                                  {                                      q = 0; m = (int)(q < readAt ? readAt - q - 1 : end - q);                                  }                                  if (m == 0)                                  {                                      bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                              }                          }                          r = ZlibConstants.Z_OK;                            t = left;                          if (t > n)                              t = n;                          if (t > m)                              t = m;                          Array.Copy(_codec.InputBuffer' p' window' q' t);                          p += t; n -= t;                          q += t; m -= t;                          if ((left -= t) != 0)                              break;                          mode = last != 0 ? InflateBlockMode.DRY : InflateBlockMode.TYPE;                          break;                        case InflateBlockMode.TABLE:                            while (k < (14))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                                n--;                              b |= (_codec.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            table = t = (b & 0x3fff);                          if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29)                          {                              mode = InflateBlockMode.BAD;                              _codec.Message = "too many length or distance symbols";                              r = ZlibConstants.Z_DATA_ERROR;                                bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                          t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);                          if (blens == null || blens.Length < t)                          {                              blens = new int[t];                          }                          else                          {                              Array.Clear(blens' 0' t);                              // for (int i = 0; i < t; i++)                              // {                              //     blens[i] = 0;                              // }                          }                            b >>= 14;                          k -= 14;                              index = 0;                          mode = InflateBlockMode.BTREE;                          goto case InflateBlockMode.BTREE;                        case InflateBlockMode.BTREE:                          while (index < 4 + (table >> 10))                          {                              while (k < (3))                              {                                  if (n != 0)                                  {                                      r = ZlibConstants.Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                                    n--;                                  b |= (_codec.InputBuffer[p++] & 0xff) << k;                                  k += 8;                              }                                blens[border[index++]] = b & 7;                                b >>= 3; k -= 3;                          }                            while (index < 19)                          {                              blens[border[index++]] = 0;                          }                            bb[0] = 7;                          t = inftree.inflate_trees_bits(blens' bb' tb' hufts' _codec);                          if (t != ZlibConstants.Z_OK)                          {                              r = t;                              if (r == ZlibConstants.Z_DATA_ERROR)                              {                                  blens = null;                                  mode = InflateBlockMode.BAD;                              }                                bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                            index = 0;                          mode = InflateBlockMode.DTREE;                          goto case InflateBlockMode.DTREE;                        case InflateBlockMode.DTREE:                          while (true)                          {                              t = table;                              if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)))                              {                                  break;                              }                                int i' j' c;                                t = bb[0];                                while (k < t)                              {                                  if (n != 0)                                  {                                      r = ZlibConstants.Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                                    n--;                                  b |= (_codec.InputBuffer[p++] & 0xff) << k;                                  k += 8;                              }                                t = hufts[(tb[0] + (b & InternalInflateConstants.InflateMask[t])) * 3 + 1];                              c = hufts[(tb[0] + (b & InternalInflateConstants.InflateMask[t])) * 3 + 2];                                if (c < 16)                              {                                  b >>= t; k -= t;                                  blens[index++] = c;                              }                              else                              {                                  // c == 16..18                                  i = c == 18 ? 7 : c - 14;                                  j = c == 18 ? 11 : 3;                                    while (k < (t + i))                                  {                                      if (n != 0)                                      {                                          r = ZlibConstants.Z_OK;                                      }                                      else                                      {                                          bitb = b; bitk = k;                                          _codec.AvailableBytesIn = n;                                          _codec.TotalBytesIn += p - _codec.NextIn;                                          _codec.NextIn = p;                                          writeAt = q;                                          return Flush(r);                                      }                                        n--;                                      b |= (_codec.InputBuffer[p++] & 0xff) << k;                                      k += 8;                                  }                                    b >>= t; k -= t;                                    j += (b & InternalInflateConstants.InflateMask[i]);                                    b >>= i; k -= i;                                    i = index;                                  t = table;                                  if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1))                                  {                                      blens = null;                                      mode = InflateBlockMode.BAD;                                      _codec.Message = "invalid bit length repeat";                                      r = ZlibConstants.Z_DATA_ERROR;                                        bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                                    c = (c == 16) ? blens[i-1] : 0;                                  do                                  {                                      blens[i++] = c;                                  }                                  while (--j != 0);                                  index = i;                              }                          }                            tb[0] = -1;                          {                              int[] bl = new int[] { 9 };  // must be <= 9 for lookahead assumptions                              int[] bd = new int[] { 6 }; // must be <= 9 for lookahead assumptions                              int[] tl = new int[1];                              int[] td = new int[1];                                t = table;                              t = inftree.inflate_trees_dynamic(257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' _codec);                                if (t != ZlibConstants.Z_OK)                              {                                  if (t == ZlibConstants.Z_DATA_ERROR)                                  {                                      blens = null;                                      mode = InflateBlockMode.BAD;                                  }                                  r = t;                                    bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                              codes.Init(bl[0]' bd[0]' hufts' tl[0]' hufts' td[0]);                          }                          mode = InflateBlockMode.CODES;                          goto case InflateBlockMode.CODES;                        case InflateBlockMode.CODES:                          bitb = b; bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                            r = codes.Process(this' r);                          if (r != ZlibConstants.Z_STREAM_END)                          {                              return Flush(r);                          }                            r = ZlibConstants.Z_OK;                          p = _codec.NextIn;                          n = _codec.AvailableBytesIn;                          b = bitb;                          k = bitk;                          q = writeAt;                          m = (int)(q < readAt ? readAt - q - 1 : end - q);                            if (last == 0)                          {                              mode = InflateBlockMode.TYPE;                              break;                          }                          mode = InflateBlockMode.DRY;                          goto case InflateBlockMode.DRY;                        case InflateBlockMode.DRY:                          writeAt = q;                          r = Flush(r);                          q = writeAt; m = (int)(q < readAt ? readAt - q - 1 : end - q);                          if (readAt != writeAt)                          {                              bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                          mode = InflateBlockMode.DONE;                          goto case InflateBlockMode.DONE;                        case InflateBlockMode.DONE:                          r = ZlibConstants.Z_STREAM_END;                          bitb = b;                          bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                          return Flush(r);                        case InflateBlockMode.BAD:                          r = ZlibConstants.Z_DATA_ERROR;                            bitb = b; bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                          return Flush(r);                          default:                          r = ZlibConstants.Z_STREAM_ERROR;                            bitb = b; bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                          return Flush(r);                  }
Magic Number,Ionic.Zlib,InflateBlocks,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zlib.Shared\Inflate.cs,Process,The following statement contains a magic number: switch (mode)                  {                      case InflateBlockMode.TYPE:                            while (k < (3))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                                n--;                              b |= (_codec.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                          t = (int)(b & 7);                          last = t & 1;                            switch ((uint)t >> 1)                          {                              case 0:  // stored                                  b >>= 3; k -= (3);                                  t = k & 7; // go to byte boundary                                  b >>= t; k -= t;                                  mode = InflateBlockMode.LENS; // get length of stored block                                  break;                                case 1:  // fixed                                  int[] bl = new int[1];                                  int[] bd = new int[1];                                  int[][] tl = new int[1][];                                  int[][] td = new int[1][];                                  InfTree.inflate_trees_fixed(bl' bd' tl' td' _codec);                                  codes.Init(bl[0]' bd[0]' tl[0]' 0' td[0]' 0);                                  b >>= 3; k -= 3;                                  mode = InflateBlockMode.CODES;                                  break;                                case 2:  // dynamic                                  b >>= 3; k -= 3;                                  mode = InflateBlockMode.TABLE;                                  break;                                case 3:  // illegal                                  b >>= 3; k -= 3;                                  mode = InflateBlockMode.BAD;                                  _codec.Message = "invalid block type";                                  r = ZlibConstants.Z_DATA_ERROR;                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                          }                          break;                        case InflateBlockMode.LENS:                            while (k < (32))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                              ;                              n--;                              b |= (_codec.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            if ( ( ((~b)>>16) & 0xffff) != (b & 0xffff))                          {                              mode = InflateBlockMode.BAD;                              _codec.Message = "invalid stored block lengths";                              r = ZlibConstants.Z_DATA_ERROR;                                bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                          left = (b & 0xffff);                          b = k = 0; // dump bits                          mode = left != 0 ? InflateBlockMode.STORED : (last != 0 ? InflateBlockMode.DRY : InflateBlockMode.TYPE);                          break;                        case InflateBlockMode.STORED:                          if (n == 0)                          {                              bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                            if (m == 0)                          {                              if (q == end && readAt != 0)                              {                                  q = 0; m = (int)(q < readAt ? readAt - q - 1 : end - q);                              }                              if (m == 0)                              {                                  writeAt = q;                                  r = Flush(r);                                  q = writeAt; m = (int)(q < readAt ? readAt - q - 1 : end - q);                                  if (q == end && readAt != 0)                                  {                                      q = 0; m = (int)(q < readAt ? readAt - q - 1 : end - q);                                  }                                  if (m == 0)                                  {                                      bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                              }                          }                          r = ZlibConstants.Z_OK;                            t = left;                          if (t > n)                              t = n;                          if (t > m)                              t = m;                          Array.Copy(_codec.InputBuffer' p' window' q' t);                          p += t; n -= t;                          q += t; m -= t;                          if ((left -= t) != 0)                              break;                          mode = last != 0 ? InflateBlockMode.DRY : InflateBlockMode.TYPE;                          break;                        case InflateBlockMode.TABLE:                            while (k < (14))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                                n--;                              b |= (_codec.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            table = t = (b & 0x3fff);                          if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29)                          {                              mode = InflateBlockMode.BAD;                              _codec.Message = "too many length or distance symbols";                              r = ZlibConstants.Z_DATA_ERROR;                                bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                          t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);                          if (blens == null || blens.Length < t)                          {                              blens = new int[t];                          }                          else                          {                              Array.Clear(blens' 0' t);                              // for (int i = 0; i < t; i++)                              // {                              //     blens[i] = 0;                              // }                          }                            b >>= 14;                          k -= 14;                              index = 0;                          mode = InflateBlockMode.BTREE;                          goto case InflateBlockMode.BTREE;                        case InflateBlockMode.BTREE:                          while (index < 4 + (table >> 10))                          {                              while (k < (3))                              {                                  if (n != 0)                                  {                                      r = ZlibConstants.Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                                    n--;                                  b |= (_codec.InputBuffer[p++] & 0xff) << k;                                  k += 8;                              }                                blens[border[index++]] = b & 7;                                b >>= 3; k -= 3;                          }                            while (index < 19)                          {                              blens[border[index++]] = 0;                          }                            bb[0] = 7;                          t = inftree.inflate_trees_bits(blens' bb' tb' hufts' _codec);                          if (t != ZlibConstants.Z_OK)                          {                              r = t;                              if (r == ZlibConstants.Z_DATA_ERROR)                              {                                  blens = null;                                  mode = InflateBlockMode.BAD;                              }                                bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                            index = 0;                          mode = InflateBlockMode.DTREE;                          goto case InflateBlockMode.DTREE;                        case InflateBlockMode.DTREE:                          while (true)                          {                              t = table;                              if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)))                              {                                  break;                              }                                int i' j' c;                                t = bb[0];                                while (k < t)                              {                                  if (n != 0)                                  {                                      r = ZlibConstants.Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                                    n--;                                  b |= (_codec.InputBuffer[p++] & 0xff) << k;                                  k += 8;                              }                                t = hufts[(tb[0] + (b & InternalInflateConstants.InflateMask[t])) * 3 + 1];                              c = hufts[(tb[0] + (b & InternalInflateConstants.InflateMask[t])) * 3 + 2];                                if (c < 16)                              {                                  b >>= t; k -= t;                                  blens[index++] = c;                              }                              else                              {                                  // c == 16..18                                  i = c == 18 ? 7 : c - 14;                                  j = c == 18 ? 11 : 3;                                    while (k < (t + i))                                  {                                      if (n != 0)                                      {                                          r = ZlibConstants.Z_OK;                                      }                                      else                                      {                                          bitb = b; bitk = k;                                          _codec.AvailableBytesIn = n;                                          _codec.TotalBytesIn += p - _codec.NextIn;                                          _codec.NextIn = p;                                          writeAt = q;                                          return Flush(r);                                      }                                        n--;                                      b |= (_codec.InputBuffer[p++] & 0xff) << k;                                      k += 8;                                  }                                    b >>= t; k -= t;                                    j += (b & InternalInflateConstants.InflateMask[i]);                                    b >>= i; k -= i;                                    i = index;                                  t = table;                                  if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1))                                  {                                      blens = null;                                      mode = InflateBlockMode.BAD;                                      _codec.Message = "invalid bit length repeat";                                      r = ZlibConstants.Z_DATA_ERROR;                                        bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                                    c = (c == 16) ? blens[i-1] : 0;                                  do                                  {                                      blens[i++] = c;                                  }                                  while (--j != 0);                                  index = i;                              }                          }                            tb[0] = -1;                          {                              int[] bl = new int[] { 9 };  // must be <= 9 for lookahead assumptions                              int[] bd = new int[] { 6 }; // must be <= 9 for lookahead assumptions                              int[] tl = new int[1];                              int[] td = new int[1];                                t = table;                              t = inftree.inflate_trees_dynamic(257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' _codec);                                if (t != ZlibConstants.Z_OK)                              {                                  if (t == ZlibConstants.Z_DATA_ERROR)                                  {                                      blens = null;                                      mode = InflateBlockMode.BAD;                                  }                                  r = t;                                    bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                              codes.Init(bl[0]' bd[0]' hufts' tl[0]' hufts' td[0]);                          }                          mode = InflateBlockMode.CODES;                          goto case InflateBlockMode.CODES;                        case InflateBlockMode.CODES:                          bitb = b; bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                            r = codes.Process(this' r);                          if (r != ZlibConstants.Z_STREAM_END)                          {                              return Flush(r);                          }                            r = ZlibConstants.Z_OK;                          p = _codec.NextIn;                          n = _codec.AvailableBytesIn;                          b = bitb;                          k = bitk;                          q = writeAt;                          m = (int)(q < readAt ? readAt - q - 1 : end - q);                            if (last == 0)                          {                              mode = InflateBlockMode.TYPE;                              break;                          }                          mode = InflateBlockMode.DRY;                          goto case InflateBlockMode.DRY;                        case InflateBlockMode.DRY:                          writeAt = q;                          r = Flush(r);                          q = writeAt; m = (int)(q < readAt ? readAt - q - 1 : end - q);                          if (readAt != writeAt)                          {                              bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                          mode = InflateBlockMode.DONE;                          goto case InflateBlockMode.DONE;                        case InflateBlockMode.DONE:                          r = ZlibConstants.Z_STREAM_END;                          bitb = b;                          bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                          return Flush(r);                        case InflateBlockMode.BAD:                          r = ZlibConstants.Z_DATA_ERROR;                            bitb = b; bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                          return Flush(r);                          default:                          r = ZlibConstants.Z_STREAM_ERROR;                            bitb = b; bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                          return Flush(r);                  }
Magic Number,Ionic.Zlib,InflateBlocks,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zlib.Shared\Inflate.cs,Process,The following statement contains a magic number: switch (mode)                  {                      case InflateBlockMode.TYPE:                            while (k < (3))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                                n--;                              b |= (_codec.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                          t = (int)(b & 7);                          last = t & 1;                            switch ((uint)t >> 1)                          {                              case 0:  // stored                                  b >>= 3; k -= (3);                                  t = k & 7; // go to byte boundary                                  b >>= t; k -= t;                                  mode = InflateBlockMode.LENS; // get length of stored block                                  break;                                case 1:  // fixed                                  int[] bl = new int[1];                                  int[] bd = new int[1];                                  int[][] tl = new int[1][];                                  int[][] td = new int[1][];                                  InfTree.inflate_trees_fixed(bl' bd' tl' td' _codec);                                  codes.Init(bl[0]' bd[0]' tl[0]' 0' td[0]' 0);                                  b >>= 3; k -= 3;                                  mode = InflateBlockMode.CODES;                                  break;                                case 2:  // dynamic                                  b >>= 3; k -= 3;                                  mode = InflateBlockMode.TABLE;                                  break;                                case 3:  // illegal                                  b >>= 3; k -= 3;                                  mode = InflateBlockMode.BAD;                                  _codec.Message = "invalid block type";                                  r = ZlibConstants.Z_DATA_ERROR;                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                          }                          break;                        case InflateBlockMode.LENS:                            while (k < (32))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                              ;                              n--;                              b |= (_codec.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            if ( ( ((~b)>>16) & 0xffff) != (b & 0xffff))                          {                              mode = InflateBlockMode.BAD;                              _codec.Message = "invalid stored block lengths";                              r = ZlibConstants.Z_DATA_ERROR;                                bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                          left = (b & 0xffff);                          b = k = 0; // dump bits                          mode = left != 0 ? InflateBlockMode.STORED : (last != 0 ? InflateBlockMode.DRY : InflateBlockMode.TYPE);                          break;                        case InflateBlockMode.STORED:                          if (n == 0)                          {                              bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                            if (m == 0)                          {                              if (q == end && readAt != 0)                              {                                  q = 0; m = (int)(q < readAt ? readAt - q - 1 : end - q);                              }                              if (m == 0)                              {                                  writeAt = q;                                  r = Flush(r);                                  q = writeAt; m = (int)(q < readAt ? readAt - q - 1 : end - q);                                  if (q == end && readAt != 0)                                  {                                      q = 0; m = (int)(q < readAt ? readAt - q - 1 : end - q);                                  }                                  if (m == 0)                                  {                                      bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                              }                          }                          r = ZlibConstants.Z_OK;                            t = left;                          if (t > n)                              t = n;                          if (t > m)                              t = m;                          Array.Copy(_codec.InputBuffer' p' window' q' t);                          p += t; n -= t;                          q += t; m -= t;                          if ((left -= t) != 0)                              break;                          mode = last != 0 ? InflateBlockMode.DRY : InflateBlockMode.TYPE;                          break;                        case InflateBlockMode.TABLE:                            while (k < (14))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                                n--;                              b |= (_codec.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            table = t = (b & 0x3fff);                          if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29)                          {                              mode = InflateBlockMode.BAD;                              _codec.Message = "too many length or distance symbols";                              r = ZlibConstants.Z_DATA_ERROR;                                bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                          t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);                          if (blens == null || blens.Length < t)                          {                              blens = new int[t];                          }                          else                          {                              Array.Clear(blens' 0' t);                              // for (int i = 0; i < t; i++)                              // {                              //     blens[i] = 0;                              // }                          }                            b >>= 14;                          k -= 14;                              index = 0;                          mode = InflateBlockMode.BTREE;                          goto case InflateBlockMode.BTREE;                        case InflateBlockMode.BTREE:                          while (index < 4 + (table >> 10))                          {                              while (k < (3))                              {                                  if (n != 0)                                  {                                      r = ZlibConstants.Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                                    n--;                                  b |= (_codec.InputBuffer[p++] & 0xff) << k;                                  k += 8;                              }                                blens[border[index++]] = b & 7;                                b >>= 3; k -= 3;                          }                            while (index < 19)                          {                              blens[border[index++]] = 0;                          }                            bb[0] = 7;                          t = inftree.inflate_trees_bits(blens' bb' tb' hufts' _codec);                          if (t != ZlibConstants.Z_OK)                          {                              r = t;                              if (r == ZlibConstants.Z_DATA_ERROR)                              {                                  blens = null;                                  mode = InflateBlockMode.BAD;                              }                                bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                            index = 0;                          mode = InflateBlockMode.DTREE;                          goto case InflateBlockMode.DTREE;                        case InflateBlockMode.DTREE:                          while (true)                          {                              t = table;                              if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)))                              {                                  break;                              }                                int i' j' c;                                t = bb[0];                                while (k < t)                              {                                  if (n != 0)                                  {                                      r = ZlibConstants.Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                                    n--;                                  b |= (_codec.InputBuffer[p++] & 0xff) << k;                                  k += 8;                              }                                t = hufts[(tb[0] + (b & InternalInflateConstants.InflateMask[t])) * 3 + 1];                              c = hufts[(tb[0] + (b & InternalInflateConstants.InflateMask[t])) * 3 + 2];                                if (c < 16)                              {                                  b >>= t; k -= t;                                  blens[index++] = c;                              }                              else                              {                                  // c == 16..18                                  i = c == 18 ? 7 : c - 14;                                  j = c == 18 ? 11 : 3;                                    while (k < (t + i))                                  {                                      if (n != 0)                                      {                                          r = ZlibConstants.Z_OK;                                      }                                      else                                      {                                          bitb = b; bitk = k;                                          _codec.AvailableBytesIn = n;                                          _codec.TotalBytesIn += p - _codec.NextIn;                                          _codec.NextIn = p;                                          writeAt = q;                                          return Flush(r);                                      }                                        n--;                                      b |= (_codec.InputBuffer[p++] & 0xff) << k;                                      k += 8;                                  }                                    b >>= t; k -= t;                                    j += (b & InternalInflateConstants.InflateMask[i]);                                    b >>= i; k -= i;                                    i = index;                                  t = table;                                  if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1))                                  {                                      blens = null;                                      mode = InflateBlockMode.BAD;                                      _codec.Message = "invalid bit length repeat";                                      r = ZlibConstants.Z_DATA_ERROR;                                        bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                                    c = (c == 16) ? blens[i-1] : 0;                                  do                                  {                                      blens[i++] = c;                                  }                                  while (--j != 0);                                  index = i;                              }                          }                            tb[0] = -1;                          {                              int[] bl = new int[] { 9 };  // must be <= 9 for lookahead assumptions                              int[] bd = new int[] { 6 }; // must be <= 9 for lookahead assumptions                              int[] tl = new int[1];                              int[] td = new int[1];                                t = table;                              t = inftree.inflate_trees_dynamic(257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' _codec);                                if (t != ZlibConstants.Z_OK)                              {                                  if (t == ZlibConstants.Z_DATA_ERROR)                                  {                                      blens = null;                                      mode = InflateBlockMode.BAD;                                  }                                  r = t;                                    bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                              codes.Init(bl[0]' bd[0]' hufts' tl[0]' hufts' td[0]);                          }                          mode = InflateBlockMode.CODES;                          goto case InflateBlockMode.CODES;                        case InflateBlockMode.CODES:                          bitb = b; bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                            r = codes.Process(this' r);                          if (r != ZlibConstants.Z_STREAM_END)                          {                              return Flush(r);                          }                            r = ZlibConstants.Z_OK;                          p = _codec.NextIn;                          n = _codec.AvailableBytesIn;                          b = bitb;                          k = bitk;                          q = writeAt;                          m = (int)(q < readAt ? readAt - q - 1 : end - q);                            if (last == 0)                          {                              mode = InflateBlockMode.TYPE;                              break;                          }                          mode = InflateBlockMode.DRY;                          goto case InflateBlockMode.DRY;                        case InflateBlockMode.DRY:                          writeAt = q;                          r = Flush(r);                          q = writeAt; m = (int)(q < readAt ? readAt - q - 1 : end - q);                          if (readAt != writeAt)                          {                              bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                          mode = InflateBlockMode.DONE;                          goto case InflateBlockMode.DONE;                        case InflateBlockMode.DONE:                          r = ZlibConstants.Z_STREAM_END;                          bitb = b;                          bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                          return Flush(r);                        case InflateBlockMode.BAD:                          r = ZlibConstants.Z_DATA_ERROR;                            bitb = b; bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                          return Flush(r);                          default:                          r = ZlibConstants.Z_STREAM_ERROR;                            bitb = b; bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                          return Flush(r);                  }
Magic Number,Ionic.Zlib,InflateBlocks,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zlib.Shared\Inflate.cs,Process,The following statement contains a magic number: switch (mode)                  {                      case InflateBlockMode.TYPE:                            while (k < (3))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                                n--;                              b |= (_codec.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                          t = (int)(b & 7);                          last = t & 1;                            switch ((uint)t >> 1)                          {                              case 0:  // stored                                  b >>= 3; k -= (3);                                  t = k & 7; // go to byte boundary                                  b >>= t; k -= t;                                  mode = InflateBlockMode.LENS; // get length of stored block                                  break;                                case 1:  // fixed                                  int[] bl = new int[1];                                  int[] bd = new int[1];                                  int[][] tl = new int[1][];                                  int[][] td = new int[1][];                                  InfTree.inflate_trees_fixed(bl' bd' tl' td' _codec);                                  codes.Init(bl[0]' bd[0]' tl[0]' 0' td[0]' 0);                                  b >>= 3; k -= 3;                                  mode = InflateBlockMode.CODES;                                  break;                                case 2:  // dynamic                                  b >>= 3; k -= 3;                                  mode = InflateBlockMode.TABLE;                                  break;                                case 3:  // illegal                                  b >>= 3; k -= 3;                                  mode = InflateBlockMode.BAD;                                  _codec.Message = "invalid block type";                                  r = ZlibConstants.Z_DATA_ERROR;                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                          }                          break;                        case InflateBlockMode.LENS:                            while (k < (32))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                              ;                              n--;                              b |= (_codec.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            if ( ( ((~b)>>16) & 0xffff) != (b & 0xffff))                          {                              mode = InflateBlockMode.BAD;                              _codec.Message = "invalid stored block lengths";                              r = ZlibConstants.Z_DATA_ERROR;                                bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                          left = (b & 0xffff);                          b = k = 0; // dump bits                          mode = left != 0 ? InflateBlockMode.STORED : (last != 0 ? InflateBlockMode.DRY : InflateBlockMode.TYPE);                          break;                        case InflateBlockMode.STORED:                          if (n == 0)                          {                              bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                            if (m == 0)                          {                              if (q == end && readAt != 0)                              {                                  q = 0; m = (int)(q < readAt ? readAt - q - 1 : end - q);                              }                              if (m == 0)                              {                                  writeAt = q;                                  r = Flush(r);                                  q = writeAt; m = (int)(q < readAt ? readAt - q - 1 : end - q);                                  if (q == end && readAt != 0)                                  {                                      q = 0; m = (int)(q < readAt ? readAt - q - 1 : end - q);                                  }                                  if (m == 0)                                  {                                      bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                              }                          }                          r = ZlibConstants.Z_OK;                            t = left;                          if (t > n)                              t = n;                          if (t > m)                              t = m;                          Array.Copy(_codec.InputBuffer' p' window' q' t);                          p += t; n -= t;                          q += t; m -= t;                          if ((left -= t) != 0)                              break;                          mode = last != 0 ? InflateBlockMode.DRY : InflateBlockMode.TYPE;                          break;                        case InflateBlockMode.TABLE:                            while (k < (14))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                                n--;                              b |= (_codec.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            table = t = (b & 0x3fff);                          if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29)                          {                              mode = InflateBlockMode.BAD;                              _codec.Message = "too many length or distance symbols";                              r = ZlibConstants.Z_DATA_ERROR;                                bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                          t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);                          if (blens == null || blens.Length < t)                          {                              blens = new int[t];                          }                          else                          {                              Array.Clear(blens' 0' t);                              // for (int i = 0; i < t; i++)                              // {                              //     blens[i] = 0;                              // }                          }                            b >>= 14;                          k -= 14;                              index = 0;                          mode = InflateBlockMode.BTREE;                          goto case InflateBlockMode.BTREE;                        case InflateBlockMode.BTREE:                          while (index < 4 + (table >> 10))                          {                              while (k < (3))                              {                                  if (n != 0)                                  {                                      r = ZlibConstants.Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                                    n--;                                  b |= (_codec.InputBuffer[p++] & 0xff) << k;                                  k += 8;                              }                                blens[border[index++]] = b & 7;                                b >>= 3; k -= 3;                          }                            while (index < 19)                          {                              blens[border[index++]] = 0;                          }                            bb[0] = 7;                          t = inftree.inflate_trees_bits(blens' bb' tb' hufts' _codec);                          if (t != ZlibConstants.Z_OK)                          {                              r = t;                              if (r == ZlibConstants.Z_DATA_ERROR)                              {                                  blens = null;                                  mode = InflateBlockMode.BAD;                              }                                bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                            index = 0;                          mode = InflateBlockMode.DTREE;                          goto case InflateBlockMode.DTREE;                        case InflateBlockMode.DTREE:                          while (true)                          {                              t = table;                              if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)))                              {                                  break;                              }                                int i' j' c;                                t = bb[0];                                while (k < t)                              {                                  if (n != 0)                                  {                                      r = ZlibConstants.Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                                    n--;                                  b |= (_codec.InputBuffer[p++] & 0xff) << k;                                  k += 8;                              }                                t = hufts[(tb[0] + (b & InternalInflateConstants.InflateMask[t])) * 3 + 1];                              c = hufts[(tb[0] + (b & InternalInflateConstants.InflateMask[t])) * 3 + 2];                                if (c < 16)                              {                                  b >>= t; k -= t;                                  blens[index++] = c;                              }                              else                              {                                  // c == 16..18                                  i = c == 18 ? 7 : c - 14;                                  j = c == 18 ? 11 : 3;                                    while (k < (t + i))                                  {                                      if (n != 0)                                      {                                          r = ZlibConstants.Z_OK;                                      }                                      else                                      {                                          bitb = b; bitk = k;                                          _codec.AvailableBytesIn = n;                                          _codec.TotalBytesIn += p - _codec.NextIn;                                          _codec.NextIn = p;                                          writeAt = q;                                          return Flush(r);                                      }                                        n--;                                      b |= (_codec.InputBuffer[p++] & 0xff) << k;                                      k += 8;                                  }                                    b >>= t; k -= t;                                    j += (b & InternalInflateConstants.InflateMask[i]);                                    b >>= i; k -= i;                                    i = index;                                  t = table;                                  if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1))                                  {                                      blens = null;                                      mode = InflateBlockMode.BAD;                                      _codec.Message = "invalid bit length repeat";                                      r = ZlibConstants.Z_DATA_ERROR;                                        bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                                    c = (c == 16) ? blens[i-1] : 0;                                  do                                  {                                      blens[i++] = c;                                  }                                  while (--j != 0);                                  index = i;                              }                          }                            tb[0] = -1;                          {                              int[] bl = new int[] { 9 };  // must be <= 9 for lookahead assumptions                              int[] bd = new int[] { 6 }; // must be <= 9 for lookahead assumptions                              int[] tl = new int[1];                              int[] td = new int[1];                                t = table;                              t = inftree.inflate_trees_dynamic(257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' _codec);                                if (t != ZlibConstants.Z_OK)                              {                                  if (t == ZlibConstants.Z_DATA_ERROR)                                  {                                      blens = null;                                      mode = InflateBlockMode.BAD;                                  }                                  r = t;                                    bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                              codes.Init(bl[0]' bd[0]' hufts' tl[0]' hufts' td[0]);                          }                          mode = InflateBlockMode.CODES;                          goto case InflateBlockMode.CODES;                        case InflateBlockMode.CODES:                          bitb = b; bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                            r = codes.Process(this' r);                          if (r != ZlibConstants.Z_STREAM_END)                          {                              return Flush(r);                          }                            r = ZlibConstants.Z_OK;                          p = _codec.NextIn;                          n = _codec.AvailableBytesIn;                          b = bitb;                          k = bitk;                          q = writeAt;                          m = (int)(q < readAt ? readAt - q - 1 : end - q);                            if (last == 0)                          {                              mode = InflateBlockMode.TYPE;                              break;                          }                          mode = InflateBlockMode.DRY;                          goto case InflateBlockMode.DRY;                        case InflateBlockMode.DRY:                          writeAt = q;                          r = Flush(r);                          q = writeAt; m = (int)(q < readAt ? readAt - q - 1 : end - q);                          if (readAt != writeAt)                          {                              bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                          mode = InflateBlockMode.DONE;                          goto case InflateBlockMode.DONE;                        case InflateBlockMode.DONE:                          r = ZlibConstants.Z_STREAM_END;                          bitb = b;                          bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                          return Flush(r);                        case InflateBlockMode.BAD:                          r = ZlibConstants.Z_DATA_ERROR;                            bitb = b; bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                          return Flush(r);                          default:                          r = ZlibConstants.Z_STREAM_ERROR;                            bitb = b; bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                          return Flush(r);                  }
Magic Number,Ionic.Zlib,InflateBlocks,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zlib.Shared\Inflate.cs,Process,The following statement contains a magic number: switch (mode)                  {                      case InflateBlockMode.TYPE:                            while (k < (3))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                                n--;                              b |= (_codec.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                          t = (int)(b & 7);                          last = t & 1;                            switch ((uint)t >> 1)                          {                              case 0:  // stored                                  b >>= 3; k -= (3);                                  t = k & 7; // go to byte boundary                                  b >>= t; k -= t;                                  mode = InflateBlockMode.LENS; // get length of stored block                                  break;                                case 1:  // fixed                                  int[] bl = new int[1];                                  int[] bd = new int[1];                                  int[][] tl = new int[1][];                                  int[][] td = new int[1][];                                  InfTree.inflate_trees_fixed(bl' bd' tl' td' _codec);                                  codes.Init(bl[0]' bd[0]' tl[0]' 0' td[0]' 0);                                  b >>= 3; k -= 3;                                  mode = InflateBlockMode.CODES;                                  break;                                case 2:  // dynamic                                  b >>= 3; k -= 3;                                  mode = InflateBlockMode.TABLE;                                  break;                                case 3:  // illegal                                  b >>= 3; k -= 3;                                  mode = InflateBlockMode.BAD;                                  _codec.Message = "invalid block type";                                  r = ZlibConstants.Z_DATA_ERROR;                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                          }                          break;                        case InflateBlockMode.LENS:                            while (k < (32))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                              ;                              n--;                              b |= (_codec.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            if ( ( ((~b)>>16) & 0xffff) != (b & 0xffff))                          {                              mode = InflateBlockMode.BAD;                              _codec.Message = "invalid stored block lengths";                              r = ZlibConstants.Z_DATA_ERROR;                                bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                          left = (b & 0xffff);                          b = k = 0; // dump bits                          mode = left != 0 ? InflateBlockMode.STORED : (last != 0 ? InflateBlockMode.DRY : InflateBlockMode.TYPE);                          break;                        case InflateBlockMode.STORED:                          if (n == 0)                          {                              bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                            if (m == 0)                          {                              if (q == end && readAt != 0)                              {                                  q = 0; m = (int)(q < readAt ? readAt - q - 1 : end - q);                              }                              if (m == 0)                              {                                  writeAt = q;                                  r = Flush(r);                                  q = writeAt; m = (int)(q < readAt ? readAt - q - 1 : end - q);                                  if (q == end && readAt != 0)                                  {                                      q = 0; m = (int)(q < readAt ? readAt - q - 1 : end - q);                                  }                                  if (m == 0)                                  {                                      bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                              }                          }                          r = ZlibConstants.Z_OK;                            t = left;                          if (t > n)                              t = n;                          if (t > m)                              t = m;                          Array.Copy(_codec.InputBuffer' p' window' q' t);                          p += t; n -= t;                          q += t; m -= t;                          if ((left -= t) != 0)                              break;                          mode = last != 0 ? InflateBlockMode.DRY : InflateBlockMode.TYPE;                          break;                        case InflateBlockMode.TABLE:                            while (k < (14))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                                n--;                              b |= (_codec.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            table = t = (b & 0x3fff);                          if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29)                          {                              mode = InflateBlockMode.BAD;                              _codec.Message = "too many length or distance symbols";                              r = ZlibConstants.Z_DATA_ERROR;                                bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                          t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);                          if (blens == null || blens.Length < t)                          {                              blens = new int[t];                          }                          else                          {                              Array.Clear(blens' 0' t);                              // for (int i = 0; i < t; i++)                              // {                              //     blens[i] = 0;                              // }                          }                            b >>= 14;                          k -= 14;                              index = 0;                          mode = InflateBlockMode.BTREE;                          goto case InflateBlockMode.BTREE;                        case InflateBlockMode.BTREE:                          while (index < 4 + (table >> 10))                          {                              while (k < (3))                              {                                  if (n != 0)                                  {                                      r = ZlibConstants.Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                                    n--;                                  b |= (_codec.InputBuffer[p++] & 0xff) << k;                                  k += 8;                              }                                blens[border[index++]] = b & 7;                                b >>= 3; k -= 3;                          }                            while (index < 19)                          {                              blens[border[index++]] = 0;                          }                            bb[0] = 7;                          t = inftree.inflate_trees_bits(blens' bb' tb' hufts' _codec);                          if (t != ZlibConstants.Z_OK)                          {                              r = t;                              if (r == ZlibConstants.Z_DATA_ERROR)                              {                                  blens = null;                                  mode = InflateBlockMode.BAD;                              }                                bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                            index = 0;                          mode = InflateBlockMode.DTREE;                          goto case InflateBlockMode.DTREE;                        case InflateBlockMode.DTREE:                          while (true)                          {                              t = table;                              if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)))                              {                                  break;                              }                                int i' j' c;                                t = bb[0];                                while (k < t)                              {                                  if (n != 0)                                  {                                      r = ZlibConstants.Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                                    n--;                                  b |= (_codec.InputBuffer[p++] & 0xff) << k;                                  k += 8;                              }                                t = hufts[(tb[0] + (b & InternalInflateConstants.InflateMask[t])) * 3 + 1];                              c = hufts[(tb[0] + (b & InternalInflateConstants.InflateMask[t])) * 3 + 2];                                if (c < 16)                              {                                  b >>= t; k -= t;                                  blens[index++] = c;                              }                              else                              {                                  // c == 16..18                                  i = c == 18 ? 7 : c - 14;                                  j = c == 18 ? 11 : 3;                                    while (k < (t + i))                                  {                                      if (n != 0)                                      {                                          r = ZlibConstants.Z_OK;                                      }                                      else                                      {                                          bitb = b; bitk = k;                                          _codec.AvailableBytesIn = n;                                          _codec.TotalBytesIn += p - _codec.NextIn;                                          _codec.NextIn = p;                                          writeAt = q;                                          return Flush(r);                                      }                                        n--;                                      b |= (_codec.InputBuffer[p++] & 0xff) << k;                                      k += 8;                                  }                                    b >>= t; k -= t;                                    j += (b & InternalInflateConstants.InflateMask[i]);                                    b >>= i; k -= i;                                    i = index;                                  t = table;                                  if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1))                                  {                                      blens = null;                                      mode = InflateBlockMode.BAD;                                      _codec.Message = "invalid bit length repeat";                                      r = ZlibConstants.Z_DATA_ERROR;                                        bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                                    c = (c == 16) ? blens[i-1] : 0;                                  do                                  {                                      blens[i++] = c;                                  }                                  while (--j != 0);                                  index = i;                              }                          }                            tb[0] = -1;                          {                              int[] bl = new int[] { 9 };  // must be <= 9 for lookahead assumptions                              int[] bd = new int[] { 6 }; // must be <= 9 for lookahead assumptions                              int[] tl = new int[1];                              int[] td = new int[1];                                t = table;                              t = inftree.inflate_trees_dynamic(257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' _codec);                                if (t != ZlibConstants.Z_OK)                              {                                  if (t == ZlibConstants.Z_DATA_ERROR)                                  {                                      blens = null;                                      mode = InflateBlockMode.BAD;                                  }                                  r = t;                                    bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                              codes.Init(bl[0]' bd[0]' hufts' tl[0]' hufts' td[0]);                          }                          mode = InflateBlockMode.CODES;                          goto case InflateBlockMode.CODES;                        case InflateBlockMode.CODES:                          bitb = b; bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                            r = codes.Process(this' r);                          if (r != ZlibConstants.Z_STREAM_END)                          {                              return Flush(r);                          }                            r = ZlibConstants.Z_OK;                          p = _codec.NextIn;                          n = _codec.AvailableBytesIn;                          b = bitb;                          k = bitk;                          q = writeAt;                          m = (int)(q < readAt ? readAt - q - 1 : end - q);                            if (last == 0)                          {                              mode = InflateBlockMode.TYPE;                              break;                          }                          mode = InflateBlockMode.DRY;                          goto case InflateBlockMode.DRY;                        case InflateBlockMode.DRY:                          writeAt = q;                          r = Flush(r);                          q = writeAt; m = (int)(q < readAt ? readAt - q - 1 : end - q);                          if (readAt != writeAt)                          {                              bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                          mode = InflateBlockMode.DONE;                          goto case InflateBlockMode.DONE;                        case InflateBlockMode.DONE:                          r = ZlibConstants.Z_STREAM_END;                          bitb = b;                          bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                          return Flush(r);                        case InflateBlockMode.BAD:                          r = ZlibConstants.Z_DATA_ERROR;                            bitb = b; bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                          return Flush(r);                          default:                          r = ZlibConstants.Z_STREAM_ERROR;                            bitb = b; bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                          return Flush(r);                  }
Magic Number,Ionic.Zlib,InflateBlocks,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zlib.Shared\Inflate.cs,Process,The following statement contains a magic number: switch (mode)                  {                      case InflateBlockMode.TYPE:                            while (k < (3))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                                n--;                              b |= (_codec.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                          t = (int)(b & 7);                          last = t & 1;                            switch ((uint)t >> 1)                          {                              case 0:  // stored                                  b >>= 3; k -= (3);                                  t = k & 7; // go to byte boundary                                  b >>= t; k -= t;                                  mode = InflateBlockMode.LENS; // get length of stored block                                  break;                                case 1:  // fixed                                  int[] bl = new int[1];                                  int[] bd = new int[1];                                  int[][] tl = new int[1][];                                  int[][] td = new int[1][];                                  InfTree.inflate_trees_fixed(bl' bd' tl' td' _codec);                                  codes.Init(bl[0]' bd[0]' tl[0]' 0' td[0]' 0);                                  b >>= 3; k -= 3;                                  mode = InflateBlockMode.CODES;                                  break;                                case 2:  // dynamic                                  b >>= 3; k -= 3;                                  mode = InflateBlockMode.TABLE;                                  break;                                case 3:  // illegal                                  b >>= 3; k -= 3;                                  mode = InflateBlockMode.BAD;                                  _codec.Message = "invalid block type";                                  r = ZlibConstants.Z_DATA_ERROR;                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                          }                          break;                        case InflateBlockMode.LENS:                            while (k < (32))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                              ;                              n--;                              b |= (_codec.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            if ( ( ((~b)>>16) & 0xffff) != (b & 0xffff))                          {                              mode = InflateBlockMode.BAD;                              _codec.Message = "invalid stored block lengths";                              r = ZlibConstants.Z_DATA_ERROR;                                bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                          left = (b & 0xffff);                          b = k = 0; // dump bits                          mode = left != 0 ? InflateBlockMode.STORED : (last != 0 ? InflateBlockMode.DRY : InflateBlockMode.TYPE);                          break;                        case InflateBlockMode.STORED:                          if (n == 0)                          {                              bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                            if (m == 0)                          {                              if (q == end && readAt != 0)                              {                                  q = 0; m = (int)(q < readAt ? readAt - q - 1 : end - q);                              }                              if (m == 0)                              {                                  writeAt = q;                                  r = Flush(r);                                  q = writeAt; m = (int)(q < readAt ? readAt - q - 1 : end - q);                                  if (q == end && readAt != 0)                                  {                                      q = 0; m = (int)(q < readAt ? readAt - q - 1 : end - q);                                  }                                  if (m == 0)                                  {                                      bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                              }                          }                          r = ZlibConstants.Z_OK;                            t = left;                          if (t > n)                              t = n;                          if (t > m)                              t = m;                          Array.Copy(_codec.InputBuffer' p' window' q' t);                          p += t; n -= t;                          q += t; m -= t;                          if ((left -= t) != 0)                              break;                          mode = last != 0 ? InflateBlockMode.DRY : InflateBlockMode.TYPE;                          break;                        case InflateBlockMode.TABLE:                            while (k < (14))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                                n--;                              b |= (_codec.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            table = t = (b & 0x3fff);                          if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29)                          {                              mode = InflateBlockMode.BAD;                              _codec.Message = "too many length or distance symbols";                              r = ZlibConstants.Z_DATA_ERROR;                                bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                          t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);                          if (blens == null || blens.Length < t)                          {                              blens = new int[t];                          }                          else                          {                              Array.Clear(blens' 0' t);                              // for (int i = 0; i < t; i++)                              // {                              //     blens[i] = 0;                              // }                          }                            b >>= 14;                          k -= 14;                              index = 0;                          mode = InflateBlockMode.BTREE;                          goto case InflateBlockMode.BTREE;                        case InflateBlockMode.BTREE:                          while (index < 4 + (table >> 10))                          {                              while (k < (3))                              {                                  if (n != 0)                                  {                                      r = ZlibConstants.Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                                    n--;                                  b |= (_codec.InputBuffer[p++] & 0xff) << k;                                  k += 8;                              }                                blens[border[index++]] = b & 7;                                b >>= 3; k -= 3;                          }                            while (index < 19)                          {                              blens[border[index++]] = 0;                          }                            bb[0] = 7;                          t = inftree.inflate_trees_bits(blens' bb' tb' hufts' _codec);                          if (t != ZlibConstants.Z_OK)                          {                              r = t;                              if (r == ZlibConstants.Z_DATA_ERROR)                              {                                  blens = null;                                  mode = InflateBlockMode.BAD;                              }                                bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                            index = 0;                          mode = InflateBlockMode.DTREE;                          goto case InflateBlockMode.DTREE;                        case InflateBlockMode.DTREE:                          while (true)                          {                              t = table;                              if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)))                              {                                  break;                              }                                int i' j' c;                                t = bb[0];                                while (k < t)                              {                                  if (n != 0)                                  {                                      r = ZlibConstants.Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                                    n--;                                  b |= (_codec.InputBuffer[p++] & 0xff) << k;                                  k += 8;                              }                                t = hufts[(tb[0] + (b & InternalInflateConstants.InflateMask[t])) * 3 + 1];                              c = hufts[(tb[0] + (b & InternalInflateConstants.InflateMask[t])) * 3 + 2];                                if (c < 16)                              {                                  b >>= t; k -= t;                                  blens[index++] = c;                              }                              else                              {                                  // c == 16..18                                  i = c == 18 ? 7 : c - 14;                                  j = c == 18 ? 11 : 3;                                    while (k < (t + i))                                  {                                      if (n != 0)                                      {                                          r = ZlibConstants.Z_OK;                                      }                                      else                                      {                                          bitb = b; bitk = k;                                          _codec.AvailableBytesIn = n;                                          _codec.TotalBytesIn += p - _codec.NextIn;                                          _codec.NextIn = p;                                          writeAt = q;                                          return Flush(r);                                      }                                        n--;                                      b |= (_codec.InputBuffer[p++] & 0xff) << k;                                      k += 8;                                  }                                    b >>= t; k -= t;                                    j += (b & InternalInflateConstants.InflateMask[i]);                                    b >>= i; k -= i;                                    i = index;                                  t = table;                                  if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1))                                  {                                      blens = null;                                      mode = InflateBlockMode.BAD;                                      _codec.Message = "invalid bit length repeat";                                      r = ZlibConstants.Z_DATA_ERROR;                                        bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                                    c = (c == 16) ? blens[i-1] : 0;                                  do                                  {                                      blens[i++] = c;                                  }                                  while (--j != 0);                                  index = i;                              }                          }                            tb[0] = -1;                          {                              int[] bl = new int[] { 9 };  // must be <= 9 for lookahead assumptions                              int[] bd = new int[] { 6 }; // must be <= 9 for lookahead assumptions                              int[] tl = new int[1];                              int[] td = new int[1];                                t = table;                              t = inftree.inflate_trees_dynamic(257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' _codec);                                if (t != ZlibConstants.Z_OK)                              {                                  if (t == ZlibConstants.Z_DATA_ERROR)                                  {                                      blens = null;                                      mode = InflateBlockMode.BAD;                                  }                                  r = t;                                    bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                              codes.Init(bl[0]' bd[0]' hufts' tl[0]' hufts' td[0]);                          }                          mode = InflateBlockMode.CODES;                          goto case InflateBlockMode.CODES;                        case InflateBlockMode.CODES:                          bitb = b; bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                            r = codes.Process(this' r);                          if (r != ZlibConstants.Z_STREAM_END)                          {                              return Flush(r);                          }                            r = ZlibConstants.Z_OK;                          p = _codec.NextIn;                          n = _codec.AvailableBytesIn;                          b = bitb;                          k = bitk;                          q = writeAt;                          m = (int)(q < readAt ? readAt - q - 1 : end - q);                            if (last == 0)                          {                              mode = InflateBlockMode.TYPE;                              break;                          }                          mode = InflateBlockMode.DRY;                          goto case InflateBlockMode.DRY;                        case InflateBlockMode.DRY:                          writeAt = q;                          r = Flush(r);                          q = writeAt; m = (int)(q < readAt ? readAt - q - 1 : end - q);                          if (readAt != writeAt)                          {                              bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                          mode = InflateBlockMode.DONE;                          goto case InflateBlockMode.DONE;                        case InflateBlockMode.DONE:                          r = ZlibConstants.Z_STREAM_END;                          bitb = b;                          bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                          return Flush(r);                        case InflateBlockMode.BAD:                          r = ZlibConstants.Z_DATA_ERROR;                            bitb = b; bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                          return Flush(r);                          default:                          r = ZlibConstants.Z_STREAM_ERROR;                            bitb = b; bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                          return Flush(r);                  }
Magic Number,Ionic.Zlib,InflateBlocks,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zlib.Shared\Inflate.cs,Process,The following statement contains a magic number: switch (mode)                  {                      case InflateBlockMode.TYPE:                            while (k < (3))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                                n--;                              b |= (_codec.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                          t = (int)(b & 7);                          last = t & 1;                            switch ((uint)t >> 1)                          {                              case 0:  // stored                                  b >>= 3; k -= (3);                                  t = k & 7; // go to byte boundary                                  b >>= t; k -= t;                                  mode = InflateBlockMode.LENS; // get length of stored block                                  break;                                case 1:  // fixed                                  int[] bl = new int[1];                                  int[] bd = new int[1];                                  int[][] tl = new int[1][];                                  int[][] td = new int[1][];                                  InfTree.inflate_trees_fixed(bl' bd' tl' td' _codec);                                  codes.Init(bl[0]' bd[0]' tl[0]' 0' td[0]' 0);                                  b >>= 3; k -= 3;                                  mode = InflateBlockMode.CODES;                                  break;                                case 2:  // dynamic                                  b >>= 3; k -= 3;                                  mode = InflateBlockMode.TABLE;                                  break;                                case 3:  // illegal                                  b >>= 3; k -= 3;                                  mode = InflateBlockMode.BAD;                                  _codec.Message = "invalid block type";                                  r = ZlibConstants.Z_DATA_ERROR;                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                          }                          break;                        case InflateBlockMode.LENS:                            while (k < (32))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                              ;                              n--;                              b |= (_codec.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            if ( ( ((~b)>>16) & 0xffff) != (b & 0xffff))                          {                              mode = InflateBlockMode.BAD;                              _codec.Message = "invalid stored block lengths";                              r = ZlibConstants.Z_DATA_ERROR;                                bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                          left = (b & 0xffff);                          b = k = 0; // dump bits                          mode = left != 0 ? InflateBlockMode.STORED : (last != 0 ? InflateBlockMode.DRY : InflateBlockMode.TYPE);                          break;                        case InflateBlockMode.STORED:                          if (n == 0)                          {                              bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                            if (m == 0)                          {                              if (q == end && readAt != 0)                              {                                  q = 0; m = (int)(q < readAt ? readAt - q - 1 : end - q);                              }                              if (m == 0)                              {                                  writeAt = q;                                  r = Flush(r);                                  q = writeAt; m = (int)(q < readAt ? readAt - q - 1 : end - q);                                  if (q == end && readAt != 0)                                  {                                      q = 0; m = (int)(q < readAt ? readAt - q - 1 : end - q);                                  }                                  if (m == 0)                                  {                                      bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                              }                          }                          r = ZlibConstants.Z_OK;                            t = left;                          if (t > n)                              t = n;                          if (t > m)                              t = m;                          Array.Copy(_codec.InputBuffer' p' window' q' t);                          p += t; n -= t;                          q += t; m -= t;                          if ((left -= t) != 0)                              break;                          mode = last != 0 ? InflateBlockMode.DRY : InflateBlockMode.TYPE;                          break;                        case InflateBlockMode.TABLE:                            while (k < (14))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                                n--;                              b |= (_codec.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            table = t = (b & 0x3fff);                          if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29)                          {                              mode = InflateBlockMode.BAD;                              _codec.Message = "too many length or distance symbols";                              r = ZlibConstants.Z_DATA_ERROR;                                bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                          t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);                          if (blens == null || blens.Length < t)                          {                              blens = new int[t];                          }                          else                          {                              Array.Clear(blens' 0' t);                              // for (int i = 0; i < t; i++)                              // {                              //     blens[i] = 0;                              // }                          }                            b >>= 14;                          k -= 14;                              index = 0;                          mode = InflateBlockMode.BTREE;                          goto case InflateBlockMode.BTREE;                        case InflateBlockMode.BTREE:                          while (index < 4 + (table >> 10))                          {                              while (k < (3))                              {                                  if (n != 0)                                  {                                      r = ZlibConstants.Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                                    n--;                                  b |= (_codec.InputBuffer[p++] & 0xff) << k;                                  k += 8;                              }                                blens[border[index++]] = b & 7;                                b >>= 3; k -= 3;                          }                            while (index < 19)                          {                              blens[border[index++]] = 0;                          }                            bb[0] = 7;                          t = inftree.inflate_trees_bits(blens' bb' tb' hufts' _codec);                          if (t != ZlibConstants.Z_OK)                          {                              r = t;                              if (r == ZlibConstants.Z_DATA_ERROR)                              {                                  blens = null;                                  mode = InflateBlockMode.BAD;                              }                                bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                            index = 0;                          mode = InflateBlockMode.DTREE;                          goto case InflateBlockMode.DTREE;                        case InflateBlockMode.DTREE:                          while (true)                          {                              t = table;                              if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)))                              {                                  break;                              }                                int i' j' c;                                t = bb[0];                                while (k < t)                              {                                  if (n != 0)                                  {                                      r = ZlibConstants.Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                                    n--;                                  b |= (_codec.InputBuffer[p++] & 0xff) << k;                                  k += 8;                              }                                t = hufts[(tb[0] + (b & InternalInflateConstants.InflateMask[t])) * 3 + 1];                              c = hufts[(tb[0] + (b & InternalInflateConstants.InflateMask[t])) * 3 + 2];                                if (c < 16)                              {                                  b >>= t; k -= t;                                  blens[index++] = c;                              }                              else                              {                                  // c == 16..18                                  i = c == 18 ? 7 : c - 14;                                  j = c == 18 ? 11 : 3;                                    while (k < (t + i))                                  {                                      if (n != 0)                                      {                                          r = ZlibConstants.Z_OK;                                      }                                      else                                      {                                          bitb = b; bitk = k;                                          _codec.AvailableBytesIn = n;                                          _codec.TotalBytesIn += p - _codec.NextIn;                                          _codec.NextIn = p;                                          writeAt = q;                                          return Flush(r);                                      }                                        n--;                                      b |= (_codec.InputBuffer[p++] & 0xff) << k;                                      k += 8;                                  }                                    b >>= t; k -= t;                                    j += (b & InternalInflateConstants.InflateMask[i]);                                    b >>= i; k -= i;                                    i = index;                                  t = table;                                  if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1))                                  {                                      blens = null;                                      mode = InflateBlockMode.BAD;                                      _codec.Message = "invalid bit length repeat";                                      r = ZlibConstants.Z_DATA_ERROR;                                        bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                                    c = (c == 16) ? blens[i-1] : 0;                                  do                                  {                                      blens[i++] = c;                                  }                                  while (--j != 0);                                  index = i;                              }                          }                            tb[0] = -1;                          {                              int[] bl = new int[] { 9 };  // must be <= 9 for lookahead assumptions                              int[] bd = new int[] { 6 }; // must be <= 9 for lookahead assumptions                              int[] tl = new int[1];                              int[] td = new int[1];                                t = table;                              t = inftree.inflate_trees_dynamic(257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' _codec);                                if (t != ZlibConstants.Z_OK)                              {                                  if (t == ZlibConstants.Z_DATA_ERROR)                                  {                                      blens = null;                                      mode = InflateBlockMode.BAD;                                  }                                  r = t;                                    bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                              codes.Init(bl[0]' bd[0]' hufts' tl[0]' hufts' td[0]);                          }                          mode = InflateBlockMode.CODES;                          goto case InflateBlockMode.CODES;                        case InflateBlockMode.CODES:                          bitb = b; bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                            r = codes.Process(this' r);                          if (r != ZlibConstants.Z_STREAM_END)                          {                              return Flush(r);                          }                            r = ZlibConstants.Z_OK;                          p = _codec.NextIn;                          n = _codec.AvailableBytesIn;                          b = bitb;                          k = bitk;                          q = writeAt;                          m = (int)(q < readAt ? readAt - q - 1 : end - q);                            if (last == 0)                          {                              mode = InflateBlockMode.TYPE;                              break;                          }                          mode = InflateBlockMode.DRY;                          goto case InflateBlockMode.DRY;                        case InflateBlockMode.DRY:                          writeAt = q;                          r = Flush(r);                          q = writeAt; m = (int)(q < readAt ? readAt - q - 1 : end - q);                          if (readAt != writeAt)                          {                              bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                          mode = InflateBlockMode.DONE;                          goto case InflateBlockMode.DONE;                        case InflateBlockMode.DONE:                          r = ZlibConstants.Z_STREAM_END;                          bitb = b;                          bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                          return Flush(r);                        case InflateBlockMode.BAD:                          r = ZlibConstants.Z_DATA_ERROR;                            bitb = b; bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                          return Flush(r);                          default:                          r = ZlibConstants.Z_STREAM_ERROR;                            bitb = b; bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                          return Flush(r);                  }
Magic Number,Ionic.Zlib,InflateBlocks,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zlib.Shared\Inflate.cs,Process,The following statement contains a magic number: switch (mode)                  {                      case InflateBlockMode.TYPE:                            while (k < (3))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                                n--;                              b |= (_codec.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                          t = (int)(b & 7);                          last = t & 1;                            switch ((uint)t >> 1)                          {                              case 0:  // stored                                  b >>= 3; k -= (3);                                  t = k & 7; // go to byte boundary                                  b >>= t; k -= t;                                  mode = InflateBlockMode.LENS; // get length of stored block                                  break;                                case 1:  // fixed                                  int[] bl = new int[1];                                  int[] bd = new int[1];                                  int[][] tl = new int[1][];                                  int[][] td = new int[1][];                                  InfTree.inflate_trees_fixed(bl' bd' tl' td' _codec);                                  codes.Init(bl[0]' bd[0]' tl[0]' 0' td[0]' 0);                                  b >>= 3; k -= 3;                                  mode = InflateBlockMode.CODES;                                  break;                                case 2:  // dynamic                                  b >>= 3; k -= 3;                                  mode = InflateBlockMode.TABLE;                                  break;                                case 3:  // illegal                                  b >>= 3; k -= 3;                                  mode = InflateBlockMode.BAD;                                  _codec.Message = "invalid block type";                                  r = ZlibConstants.Z_DATA_ERROR;                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                          }                          break;                        case InflateBlockMode.LENS:                            while (k < (32))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                              ;                              n--;                              b |= (_codec.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            if ( ( ((~b)>>16) & 0xffff) != (b & 0xffff))                          {                              mode = InflateBlockMode.BAD;                              _codec.Message = "invalid stored block lengths";                              r = ZlibConstants.Z_DATA_ERROR;                                bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                          left = (b & 0xffff);                          b = k = 0; // dump bits                          mode = left != 0 ? InflateBlockMode.STORED : (last != 0 ? InflateBlockMode.DRY : InflateBlockMode.TYPE);                          break;                        case InflateBlockMode.STORED:                          if (n == 0)                          {                              bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                            if (m == 0)                          {                              if (q == end && readAt != 0)                              {                                  q = 0; m = (int)(q < readAt ? readAt - q - 1 : end - q);                              }                              if (m == 0)                              {                                  writeAt = q;                                  r = Flush(r);                                  q = writeAt; m = (int)(q < readAt ? readAt - q - 1 : end - q);                                  if (q == end && readAt != 0)                                  {                                      q = 0; m = (int)(q < readAt ? readAt - q - 1 : end - q);                                  }                                  if (m == 0)                                  {                                      bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                              }                          }                          r = ZlibConstants.Z_OK;                            t = left;                          if (t > n)                              t = n;                          if (t > m)                              t = m;                          Array.Copy(_codec.InputBuffer' p' window' q' t);                          p += t; n -= t;                          q += t; m -= t;                          if ((left -= t) != 0)                              break;                          mode = last != 0 ? InflateBlockMode.DRY : InflateBlockMode.TYPE;                          break;                        case InflateBlockMode.TABLE:                            while (k < (14))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                                n--;                              b |= (_codec.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            table = t = (b & 0x3fff);                          if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29)                          {                              mode = InflateBlockMode.BAD;                              _codec.Message = "too many length or distance symbols";                              r = ZlibConstants.Z_DATA_ERROR;                                bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                          t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);                          if (blens == null || blens.Length < t)                          {                              blens = new int[t];                          }                          else                          {                              Array.Clear(blens' 0' t);                              // for (int i = 0; i < t; i++)                              // {                              //     blens[i] = 0;                              // }                          }                            b >>= 14;                          k -= 14;                              index = 0;                          mode = InflateBlockMode.BTREE;                          goto case InflateBlockMode.BTREE;                        case InflateBlockMode.BTREE:                          while (index < 4 + (table >> 10))                          {                              while (k < (3))                              {                                  if (n != 0)                                  {                                      r = ZlibConstants.Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                                    n--;                                  b |= (_codec.InputBuffer[p++] & 0xff) << k;                                  k += 8;                              }                                blens[border[index++]] = b & 7;                                b >>= 3; k -= 3;                          }                            while (index < 19)                          {                              blens[border[index++]] = 0;                          }                            bb[0] = 7;                          t = inftree.inflate_trees_bits(blens' bb' tb' hufts' _codec);                          if (t != ZlibConstants.Z_OK)                          {                              r = t;                              if (r == ZlibConstants.Z_DATA_ERROR)                              {                                  blens = null;                                  mode = InflateBlockMode.BAD;                              }                                bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                            index = 0;                          mode = InflateBlockMode.DTREE;                          goto case InflateBlockMode.DTREE;                        case InflateBlockMode.DTREE:                          while (true)                          {                              t = table;                              if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)))                              {                                  break;                              }                                int i' j' c;                                t = bb[0];                                while (k < t)                              {                                  if (n != 0)                                  {                                      r = ZlibConstants.Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                                    n--;                                  b |= (_codec.InputBuffer[p++] & 0xff) << k;                                  k += 8;                              }                                t = hufts[(tb[0] + (b & InternalInflateConstants.InflateMask[t])) * 3 + 1];                              c = hufts[(tb[0] + (b & InternalInflateConstants.InflateMask[t])) * 3 + 2];                                if (c < 16)                              {                                  b >>= t; k -= t;                                  blens[index++] = c;                              }                              else                              {                                  // c == 16..18                                  i = c == 18 ? 7 : c - 14;                                  j = c == 18 ? 11 : 3;                                    while (k < (t + i))                                  {                                      if (n != 0)                                      {                                          r = ZlibConstants.Z_OK;                                      }                                      else                                      {                                          bitb = b; bitk = k;                                          _codec.AvailableBytesIn = n;                                          _codec.TotalBytesIn += p - _codec.NextIn;                                          _codec.NextIn = p;                                          writeAt = q;                                          return Flush(r);                                      }                                        n--;                                      b |= (_codec.InputBuffer[p++] & 0xff) << k;                                      k += 8;                                  }                                    b >>= t; k -= t;                                    j += (b & InternalInflateConstants.InflateMask[i]);                                    b >>= i; k -= i;                                    i = index;                                  t = table;                                  if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1))                                  {                                      blens = null;                                      mode = InflateBlockMode.BAD;                                      _codec.Message = "invalid bit length repeat";                                      r = ZlibConstants.Z_DATA_ERROR;                                        bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                                    c = (c == 16) ? blens[i-1] : 0;                                  do                                  {                                      blens[i++] = c;                                  }                                  while (--j != 0);                                  index = i;                              }                          }                            tb[0] = -1;                          {                              int[] bl = new int[] { 9 };  // must be <= 9 for lookahead assumptions                              int[] bd = new int[] { 6 }; // must be <= 9 for lookahead assumptions                              int[] tl = new int[1];                              int[] td = new int[1];                                t = table;                              t = inftree.inflate_trees_dynamic(257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' _codec);                                if (t != ZlibConstants.Z_OK)                              {                                  if (t == ZlibConstants.Z_DATA_ERROR)                                  {                                      blens = null;                                      mode = InflateBlockMode.BAD;                                  }                                  r = t;                                    bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                              codes.Init(bl[0]' bd[0]' hufts' tl[0]' hufts' td[0]);                          }                          mode = InflateBlockMode.CODES;                          goto case InflateBlockMode.CODES;                        case InflateBlockMode.CODES:                          bitb = b; bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                            r = codes.Process(this' r);                          if (r != ZlibConstants.Z_STREAM_END)                          {                              return Flush(r);                          }                            r = ZlibConstants.Z_OK;                          p = _codec.NextIn;                          n = _codec.AvailableBytesIn;                          b = bitb;                          k = bitk;                          q = writeAt;                          m = (int)(q < readAt ? readAt - q - 1 : end - q);                            if (last == 0)                          {                              mode = InflateBlockMode.TYPE;                              break;                          }                          mode = InflateBlockMode.DRY;                          goto case InflateBlockMode.DRY;                        case InflateBlockMode.DRY:                          writeAt = q;                          r = Flush(r);                          q = writeAt; m = (int)(q < readAt ? readAt - q - 1 : end - q);                          if (readAt != writeAt)                          {                              bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                          mode = InflateBlockMode.DONE;                          goto case InflateBlockMode.DONE;                        case InflateBlockMode.DONE:                          r = ZlibConstants.Z_STREAM_END;                          bitb = b;                          bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                          return Flush(r);                        case InflateBlockMode.BAD:                          r = ZlibConstants.Z_DATA_ERROR;                            bitb = b; bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                          return Flush(r);                          default:                          r = ZlibConstants.Z_STREAM_ERROR;                            bitb = b; bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                          return Flush(r);                  }
Magic Number,Ionic.Zlib,InflateBlocks,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zlib.Shared\Inflate.cs,Process,The following statement contains a magic number: switch (mode)                  {                      case InflateBlockMode.TYPE:                            while (k < (3))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                                n--;                              b |= (_codec.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                          t = (int)(b & 7);                          last = t & 1;                            switch ((uint)t >> 1)                          {                              case 0:  // stored                                  b >>= 3; k -= (3);                                  t = k & 7; // go to byte boundary                                  b >>= t; k -= t;                                  mode = InflateBlockMode.LENS; // get length of stored block                                  break;                                case 1:  // fixed                                  int[] bl = new int[1];                                  int[] bd = new int[1];                                  int[][] tl = new int[1][];                                  int[][] td = new int[1][];                                  InfTree.inflate_trees_fixed(bl' bd' tl' td' _codec);                                  codes.Init(bl[0]' bd[0]' tl[0]' 0' td[0]' 0);                                  b >>= 3; k -= 3;                                  mode = InflateBlockMode.CODES;                                  break;                                case 2:  // dynamic                                  b >>= 3; k -= 3;                                  mode = InflateBlockMode.TABLE;                                  break;                                case 3:  // illegal                                  b >>= 3; k -= 3;                                  mode = InflateBlockMode.BAD;                                  _codec.Message = "invalid block type";                                  r = ZlibConstants.Z_DATA_ERROR;                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                          }                          break;                        case InflateBlockMode.LENS:                            while (k < (32))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                              ;                              n--;                              b |= (_codec.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            if ( ( ((~b)>>16) & 0xffff) != (b & 0xffff))                          {                              mode = InflateBlockMode.BAD;                              _codec.Message = "invalid stored block lengths";                              r = ZlibConstants.Z_DATA_ERROR;                                bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                          left = (b & 0xffff);                          b = k = 0; // dump bits                          mode = left != 0 ? InflateBlockMode.STORED : (last != 0 ? InflateBlockMode.DRY : InflateBlockMode.TYPE);                          break;                        case InflateBlockMode.STORED:                          if (n == 0)                          {                              bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                            if (m == 0)                          {                              if (q == end && readAt != 0)                              {                                  q = 0; m = (int)(q < readAt ? readAt - q - 1 : end - q);                              }                              if (m == 0)                              {                                  writeAt = q;                                  r = Flush(r);                                  q = writeAt; m = (int)(q < readAt ? readAt - q - 1 : end - q);                                  if (q == end && readAt != 0)                                  {                                      q = 0; m = (int)(q < readAt ? readAt - q - 1 : end - q);                                  }                                  if (m == 0)                                  {                                      bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                              }                          }                          r = ZlibConstants.Z_OK;                            t = left;                          if (t > n)                              t = n;                          if (t > m)                              t = m;                          Array.Copy(_codec.InputBuffer' p' window' q' t);                          p += t; n -= t;                          q += t; m -= t;                          if ((left -= t) != 0)                              break;                          mode = last != 0 ? InflateBlockMode.DRY : InflateBlockMode.TYPE;                          break;                        case InflateBlockMode.TABLE:                            while (k < (14))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                                n--;                              b |= (_codec.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            table = t = (b & 0x3fff);                          if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29)                          {                              mode = InflateBlockMode.BAD;                              _codec.Message = "too many length or distance symbols";                              r = ZlibConstants.Z_DATA_ERROR;                                bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                          t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);                          if (blens == null || blens.Length < t)                          {                              blens = new int[t];                          }                          else                          {                              Array.Clear(blens' 0' t);                              // for (int i = 0; i < t; i++)                              // {                              //     blens[i] = 0;                              // }                          }                            b >>= 14;                          k -= 14;                              index = 0;                          mode = InflateBlockMode.BTREE;                          goto case InflateBlockMode.BTREE;                        case InflateBlockMode.BTREE:                          while (index < 4 + (table >> 10))                          {                              while (k < (3))                              {                                  if (n != 0)                                  {                                      r = ZlibConstants.Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                                    n--;                                  b |= (_codec.InputBuffer[p++] & 0xff) << k;                                  k += 8;                              }                                blens[border[index++]] = b & 7;                                b >>= 3; k -= 3;                          }                            while (index < 19)                          {                              blens[border[index++]] = 0;                          }                            bb[0] = 7;                          t = inftree.inflate_trees_bits(blens' bb' tb' hufts' _codec);                          if (t != ZlibConstants.Z_OK)                          {                              r = t;                              if (r == ZlibConstants.Z_DATA_ERROR)                              {                                  blens = null;                                  mode = InflateBlockMode.BAD;                              }                                bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                            index = 0;                          mode = InflateBlockMode.DTREE;                          goto case InflateBlockMode.DTREE;                        case InflateBlockMode.DTREE:                          while (true)                          {                              t = table;                              if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)))                              {                                  break;                              }                                int i' j' c;                                t = bb[0];                                while (k < t)                              {                                  if (n != 0)                                  {                                      r = ZlibConstants.Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                                    n--;                                  b |= (_codec.InputBuffer[p++] & 0xff) << k;                                  k += 8;                              }                                t = hufts[(tb[0] + (b & InternalInflateConstants.InflateMask[t])) * 3 + 1];                              c = hufts[(tb[0] + (b & InternalInflateConstants.InflateMask[t])) * 3 + 2];                                if (c < 16)                              {                                  b >>= t; k -= t;                                  blens[index++] = c;                              }                              else                              {                                  // c == 16..18                                  i = c == 18 ? 7 : c - 14;                                  j = c == 18 ? 11 : 3;                                    while (k < (t + i))                                  {                                      if (n != 0)                                      {                                          r = ZlibConstants.Z_OK;                                      }                                      else                                      {                                          bitb = b; bitk = k;                                          _codec.AvailableBytesIn = n;                                          _codec.TotalBytesIn += p - _codec.NextIn;                                          _codec.NextIn = p;                                          writeAt = q;                                          return Flush(r);                                      }                                        n--;                                      b |= (_codec.InputBuffer[p++] & 0xff) << k;                                      k += 8;                                  }                                    b >>= t; k -= t;                                    j += (b & InternalInflateConstants.InflateMask[i]);                                    b >>= i; k -= i;                                    i = index;                                  t = table;                                  if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1))                                  {                                      blens = null;                                      mode = InflateBlockMode.BAD;                                      _codec.Message = "invalid bit length repeat";                                      r = ZlibConstants.Z_DATA_ERROR;                                        bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                                    c = (c == 16) ? blens[i-1] : 0;                                  do                                  {                                      blens[i++] = c;                                  }                                  while (--j != 0);                                  index = i;                              }                          }                            tb[0] = -1;                          {                              int[] bl = new int[] { 9 };  // must be <= 9 for lookahead assumptions                              int[] bd = new int[] { 6 }; // must be <= 9 for lookahead assumptions                              int[] tl = new int[1];                              int[] td = new int[1];                                t = table;                              t = inftree.inflate_trees_dynamic(257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' _codec);                                if (t != ZlibConstants.Z_OK)                              {                                  if (t == ZlibConstants.Z_DATA_ERROR)                                  {                                      blens = null;                                      mode = InflateBlockMode.BAD;                                  }                                  r = t;                                    bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                              codes.Init(bl[0]' bd[0]' hufts' tl[0]' hufts' td[0]);                          }                          mode = InflateBlockMode.CODES;                          goto case InflateBlockMode.CODES;                        case InflateBlockMode.CODES:                          bitb = b; bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                            r = codes.Process(this' r);                          if (r != ZlibConstants.Z_STREAM_END)                          {                              return Flush(r);                          }                            r = ZlibConstants.Z_OK;                          p = _codec.NextIn;                          n = _codec.AvailableBytesIn;                          b = bitb;                          k = bitk;                          q = writeAt;                          m = (int)(q < readAt ? readAt - q - 1 : end - q);                            if (last == 0)                          {                              mode = InflateBlockMode.TYPE;                              break;                          }                          mode = InflateBlockMode.DRY;                          goto case InflateBlockMode.DRY;                        case InflateBlockMode.DRY:                          writeAt = q;                          r = Flush(r);                          q = writeAt; m = (int)(q < readAt ? readAt - q - 1 : end - q);                          if (readAt != writeAt)                          {                              bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                          mode = InflateBlockMode.DONE;                          goto case InflateBlockMode.DONE;                        case InflateBlockMode.DONE:                          r = ZlibConstants.Z_STREAM_END;                          bitb = b;                          bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                          return Flush(r);                        case InflateBlockMode.BAD:                          r = ZlibConstants.Z_DATA_ERROR;                            bitb = b; bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                          return Flush(r);                          default:                          r = ZlibConstants.Z_STREAM_ERROR;                            bitb = b; bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                          return Flush(r);                  }
Magic Number,Ionic.Zlib,InflateBlocks,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zlib.Shared\Inflate.cs,Process,The following statement contains a magic number: switch (mode)                  {                      case InflateBlockMode.TYPE:                            while (k < (3))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                                n--;                              b |= (_codec.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                          t = (int)(b & 7);                          last = t & 1;                            switch ((uint)t >> 1)                          {                              case 0:  // stored                                  b >>= 3; k -= (3);                                  t = k & 7; // go to byte boundary                                  b >>= t; k -= t;                                  mode = InflateBlockMode.LENS; // get length of stored block                                  break;                                case 1:  // fixed                                  int[] bl = new int[1];                                  int[] bd = new int[1];                                  int[][] tl = new int[1][];                                  int[][] td = new int[1][];                                  InfTree.inflate_trees_fixed(bl' bd' tl' td' _codec);                                  codes.Init(bl[0]' bd[0]' tl[0]' 0' td[0]' 0);                                  b >>= 3; k -= 3;                                  mode = InflateBlockMode.CODES;                                  break;                                case 2:  // dynamic                                  b >>= 3; k -= 3;                                  mode = InflateBlockMode.TABLE;                                  break;                                case 3:  // illegal                                  b >>= 3; k -= 3;                                  mode = InflateBlockMode.BAD;                                  _codec.Message = "invalid block type";                                  r = ZlibConstants.Z_DATA_ERROR;                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                          }                          break;                        case InflateBlockMode.LENS:                            while (k < (32))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                              ;                              n--;                              b |= (_codec.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            if ( ( ((~b)>>16) & 0xffff) != (b & 0xffff))                          {                              mode = InflateBlockMode.BAD;                              _codec.Message = "invalid stored block lengths";                              r = ZlibConstants.Z_DATA_ERROR;                                bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                          left = (b & 0xffff);                          b = k = 0; // dump bits                          mode = left != 0 ? InflateBlockMode.STORED : (last != 0 ? InflateBlockMode.DRY : InflateBlockMode.TYPE);                          break;                        case InflateBlockMode.STORED:                          if (n == 0)                          {                              bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                            if (m == 0)                          {                              if (q == end && readAt != 0)                              {                                  q = 0; m = (int)(q < readAt ? readAt - q - 1 : end - q);                              }                              if (m == 0)                              {                                  writeAt = q;                                  r = Flush(r);                                  q = writeAt; m = (int)(q < readAt ? readAt - q - 1 : end - q);                                  if (q == end && readAt != 0)                                  {                                      q = 0; m = (int)(q < readAt ? readAt - q - 1 : end - q);                                  }                                  if (m == 0)                                  {                                      bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                              }                          }                          r = ZlibConstants.Z_OK;                            t = left;                          if (t > n)                              t = n;                          if (t > m)                              t = m;                          Array.Copy(_codec.InputBuffer' p' window' q' t);                          p += t; n -= t;                          q += t; m -= t;                          if ((left -= t) != 0)                              break;                          mode = last != 0 ? InflateBlockMode.DRY : InflateBlockMode.TYPE;                          break;                        case InflateBlockMode.TABLE:                            while (k < (14))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                                n--;                              b |= (_codec.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            table = t = (b & 0x3fff);                          if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29)                          {                              mode = InflateBlockMode.BAD;                              _codec.Message = "too many length or distance symbols";                              r = ZlibConstants.Z_DATA_ERROR;                                bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                          t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);                          if (blens == null || blens.Length < t)                          {                              blens = new int[t];                          }                          else                          {                              Array.Clear(blens' 0' t);                              // for (int i = 0; i < t; i++)                              // {                              //     blens[i] = 0;                              // }                          }                            b >>= 14;                          k -= 14;                              index = 0;                          mode = InflateBlockMode.BTREE;                          goto case InflateBlockMode.BTREE;                        case InflateBlockMode.BTREE:                          while (index < 4 + (table >> 10))                          {                              while (k < (3))                              {                                  if (n != 0)                                  {                                      r = ZlibConstants.Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                                    n--;                                  b |= (_codec.InputBuffer[p++] & 0xff) << k;                                  k += 8;                              }                                blens[border[index++]] = b & 7;                                b >>= 3; k -= 3;                          }                            while (index < 19)                          {                              blens[border[index++]] = 0;                          }                            bb[0] = 7;                          t = inftree.inflate_trees_bits(blens' bb' tb' hufts' _codec);                          if (t != ZlibConstants.Z_OK)                          {                              r = t;                              if (r == ZlibConstants.Z_DATA_ERROR)                              {                                  blens = null;                                  mode = InflateBlockMode.BAD;                              }                                bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                            index = 0;                          mode = InflateBlockMode.DTREE;                          goto case InflateBlockMode.DTREE;                        case InflateBlockMode.DTREE:                          while (true)                          {                              t = table;                              if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)))                              {                                  break;                              }                                int i' j' c;                                t = bb[0];                                while (k < t)                              {                                  if (n != 0)                                  {                                      r = ZlibConstants.Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                                    n--;                                  b |= (_codec.InputBuffer[p++] & 0xff) << k;                                  k += 8;                              }                                t = hufts[(tb[0] + (b & InternalInflateConstants.InflateMask[t])) * 3 + 1];                              c = hufts[(tb[0] + (b & InternalInflateConstants.InflateMask[t])) * 3 + 2];                                if (c < 16)                              {                                  b >>= t; k -= t;                                  blens[index++] = c;                              }                              else                              {                                  // c == 16..18                                  i = c == 18 ? 7 : c - 14;                                  j = c == 18 ? 11 : 3;                                    while (k < (t + i))                                  {                                      if (n != 0)                                      {                                          r = ZlibConstants.Z_OK;                                      }                                      else                                      {                                          bitb = b; bitk = k;                                          _codec.AvailableBytesIn = n;                                          _codec.TotalBytesIn += p - _codec.NextIn;                                          _codec.NextIn = p;                                          writeAt = q;                                          return Flush(r);                                      }                                        n--;                                      b |= (_codec.InputBuffer[p++] & 0xff) << k;                                      k += 8;                                  }                                    b >>= t; k -= t;                                    j += (b & InternalInflateConstants.InflateMask[i]);                                    b >>= i; k -= i;                                    i = index;                                  t = table;                                  if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1))                                  {                                      blens = null;                                      mode = InflateBlockMode.BAD;                                      _codec.Message = "invalid bit length repeat";                                      r = ZlibConstants.Z_DATA_ERROR;                                        bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                                    c = (c == 16) ? blens[i-1] : 0;                                  do                                  {                                      blens[i++] = c;                                  }                                  while (--j != 0);                                  index = i;                              }                          }                            tb[0] = -1;                          {                              int[] bl = new int[] { 9 };  // must be <= 9 for lookahead assumptions                              int[] bd = new int[] { 6 }; // must be <= 9 for lookahead assumptions                              int[] tl = new int[1];                              int[] td = new int[1];                                t = table;                              t = inftree.inflate_trees_dynamic(257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' _codec);                                if (t != ZlibConstants.Z_OK)                              {                                  if (t == ZlibConstants.Z_DATA_ERROR)                                  {                                      blens = null;                                      mode = InflateBlockMode.BAD;                                  }                                  r = t;                                    bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                              codes.Init(bl[0]' bd[0]' hufts' tl[0]' hufts' td[0]);                          }                          mode = InflateBlockMode.CODES;                          goto case InflateBlockMode.CODES;                        case InflateBlockMode.CODES:                          bitb = b; bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                            r = codes.Process(this' r);                          if (r != ZlibConstants.Z_STREAM_END)                          {                              return Flush(r);                          }                            r = ZlibConstants.Z_OK;                          p = _codec.NextIn;                          n = _codec.AvailableBytesIn;                          b = bitb;                          k = bitk;                          q = writeAt;                          m = (int)(q < readAt ? readAt - q - 1 : end - q);                            if (last == 0)                          {                              mode = InflateBlockMode.TYPE;                              break;                          }                          mode = InflateBlockMode.DRY;                          goto case InflateBlockMode.DRY;                        case InflateBlockMode.DRY:                          writeAt = q;                          r = Flush(r);                          q = writeAt; m = (int)(q < readAt ? readAt - q - 1 : end - q);                          if (readAt != writeAt)                          {                              bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                          mode = InflateBlockMode.DONE;                          goto case InflateBlockMode.DONE;                        case InflateBlockMode.DONE:                          r = ZlibConstants.Z_STREAM_END;                          bitb = b;                          bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                          return Flush(r);                        case InflateBlockMode.BAD:                          r = ZlibConstants.Z_DATA_ERROR;                            bitb = b; bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                          return Flush(r);                          default:                          r = ZlibConstants.Z_STREAM_ERROR;                            bitb = b; bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                          return Flush(r);                  }
Magic Number,Ionic.Zlib,InflateBlocks,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zlib.Shared\Inflate.cs,Process,The following statement contains a magic number: switch (mode)                  {                      case InflateBlockMode.TYPE:                            while (k < (3))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                                n--;                              b |= (_codec.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                          t = (int)(b & 7);                          last = t & 1;                            switch ((uint)t >> 1)                          {                              case 0:  // stored                                  b >>= 3; k -= (3);                                  t = k & 7; // go to byte boundary                                  b >>= t; k -= t;                                  mode = InflateBlockMode.LENS; // get length of stored block                                  break;                                case 1:  // fixed                                  int[] bl = new int[1];                                  int[] bd = new int[1];                                  int[][] tl = new int[1][];                                  int[][] td = new int[1][];                                  InfTree.inflate_trees_fixed(bl' bd' tl' td' _codec);                                  codes.Init(bl[0]' bd[0]' tl[0]' 0' td[0]' 0);                                  b >>= 3; k -= 3;                                  mode = InflateBlockMode.CODES;                                  break;                                case 2:  // dynamic                                  b >>= 3; k -= 3;                                  mode = InflateBlockMode.TABLE;                                  break;                                case 3:  // illegal                                  b >>= 3; k -= 3;                                  mode = InflateBlockMode.BAD;                                  _codec.Message = "invalid block type";                                  r = ZlibConstants.Z_DATA_ERROR;                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                          }                          break;                        case InflateBlockMode.LENS:                            while (k < (32))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                              ;                              n--;                              b |= (_codec.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            if ( ( ((~b)>>16) & 0xffff) != (b & 0xffff))                          {                              mode = InflateBlockMode.BAD;                              _codec.Message = "invalid stored block lengths";                              r = ZlibConstants.Z_DATA_ERROR;                                bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                          left = (b & 0xffff);                          b = k = 0; // dump bits                          mode = left != 0 ? InflateBlockMode.STORED : (last != 0 ? InflateBlockMode.DRY : InflateBlockMode.TYPE);                          break;                        case InflateBlockMode.STORED:                          if (n == 0)                          {                              bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                            if (m == 0)                          {                              if (q == end && readAt != 0)                              {                                  q = 0; m = (int)(q < readAt ? readAt - q - 1 : end - q);                              }                              if (m == 0)                              {                                  writeAt = q;                                  r = Flush(r);                                  q = writeAt; m = (int)(q < readAt ? readAt - q - 1 : end - q);                                  if (q == end && readAt != 0)                                  {                                      q = 0; m = (int)(q < readAt ? readAt - q - 1 : end - q);                                  }                                  if (m == 0)                                  {                                      bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                              }                          }                          r = ZlibConstants.Z_OK;                            t = left;                          if (t > n)                              t = n;                          if (t > m)                              t = m;                          Array.Copy(_codec.InputBuffer' p' window' q' t);                          p += t; n -= t;                          q += t; m -= t;                          if ((left -= t) != 0)                              break;                          mode = last != 0 ? InflateBlockMode.DRY : InflateBlockMode.TYPE;                          break;                        case InflateBlockMode.TABLE:                            while (k < (14))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                                n--;                              b |= (_codec.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            table = t = (b & 0x3fff);                          if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29)                          {                              mode = InflateBlockMode.BAD;                              _codec.Message = "too many length or distance symbols";                              r = ZlibConstants.Z_DATA_ERROR;                                bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                          t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);                          if (blens == null || blens.Length < t)                          {                              blens = new int[t];                          }                          else                          {                              Array.Clear(blens' 0' t);                              // for (int i = 0; i < t; i++)                              // {                              //     blens[i] = 0;                              // }                          }                            b >>= 14;                          k -= 14;                              index = 0;                          mode = InflateBlockMode.BTREE;                          goto case InflateBlockMode.BTREE;                        case InflateBlockMode.BTREE:                          while (index < 4 + (table >> 10))                          {                              while (k < (3))                              {                                  if (n != 0)                                  {                                      r = ZlibConstants.Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                                    n--;                                  b |= (_codec.InputBuffer[p++] & 0xff) << k;                                  k += 8;                              }                                blens[border[index++]] = b & 7;                                b >>= 3; k -= 3;                          }                            while (index < 19)                          {                              blens[border[index++]] = 0;                          }                            bb[0] = 7;                          t = inftree.inflate_trees_bits(blens' bb' tb' hufts' _codec);                          if (t != ZlibConstants.Z_OK)                          {                              r = t;                              if (r == ZlibConstants.Z_DATA_ERROR)                              {                                  blens = null;                                  mode = InflateBlockMode.BAD;                              }                                bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                            index = 0;                          mode = InflateBlockMode.DTREE;                          goto case InflateBlockMode.DTREE;                        case InflateBlockMode.DTREE:                          while (true)                          {                              t = table;                              if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)))                              {                                  break;                              }                                int i' j' c;                                t = bb[0];                                while (k < t)                              {                                  if (n != 0)                                  {                                      r = ZlibConstants.Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                                    n--;                                  b |= (_codec.InputBuffer[p++] & 0xff) << k;                                  k += 8;                              }                                t = hufts[(tb[0] + (b & InternalInflateConstants.InflateMask[t])) * 3 + 1];                              c = hufts[(tb[0] + (b & InternalInflateConstants.InflateMask[t])) * 3 + 2];                                if (c < 16)                              {                                  b >>= t; k -= t;                                  blens[index++] = c;                              }                              else                              {                                  // c == 16..18                                  i = c == 18 ? 7 : c - 14;                                  j = c == 18 ? 11 : 3;                                    while (k < (t + i))                                  {                                      if (n != 0)                                      {                                          r = ZlibConstants.Z_OK;                                      }                                      else                                      {                                          bitb = b; bitk = k;                                          _codec.AvailableBytesIn = n;                                          _codec.TotalBytesIn += p - _codec.NextIn;                                          _codec.NextIn = p;                                          writeAt = q;                                          return Flush(r);                                      }                                        n--;                                      b |= (_codec.InputBuffer[p++] & 0xff) << k;                                      k += 8;                                  }                                    b >>= t; k -= t;                                    j += (b & InternalInflateConstants.InflateMask[i]);                                    b >>= i; k -= i;                                    i = index;                                  t = table;                                  if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1))                                  {                                      blens = null;                                      mode = InflateBlockMode.BAD;                                      _codec.Message = "invalid bit length repeat";                                      r = ZlibConstants.Z_DATA_ERROR;                                        bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                                    c = (c == 16) ? blens[i-1] : 0;                                  do                                  {                                      blens[i++] = c;                                  }                                  while (--j != 0);                                  index = i;                              }                          }                            tb[0] = -1;                          {                              int[] bl = new int[] { 9 };  // must be <= 9 for lookahead assumptions                              int[] bd = new int[] { 6 }; // must be <= 9 for lookahead assumptions                              int[] tl = new int[1];                              int[] td = new int[1];                                t = table;                              t = inftree.inflate_trees_dynamic(257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' _codec);                                if (t != ZlibConstants.Z_OK)                              {                                  if (t == ZlibConstants.Z_DATA_ERROR)                                  {                                      blens = null;                                      mode = InflateBlockMode.BAD;                                  }                                  r = t;                                    bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                              codes.Init(bl[0]' bd[0]' hufts' tl[0]' hufts' td[0]);                          }                          mode = InflateBlockMode.CODES;                          goto case InflateBlockMode.CODES;                        case InflateBlockMode.CODES:                          bitb = b; bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                            r = codes.Process(this' r);                          if (r != ZlibConstants.Z_STREAM_END)                          {                              return Flush(r);                          }                            r = ZlibConstants.Z_OK;                          p = _codec.NextIn;                          n = _codec.AvailableBytesIn;                          b = bitb;                          k = bitk;                          q = writeAt;                          m = (int)(q < readAt ? readAt - q - 1 : end - q);                            if (last == 0)                          {                              mode = InflateBlockMode.TYPE;                              break;                          }                          mode = InflateBlockMode.DRY;                          goto case InflateBlockMode.DRY;                        case InflateBlockMode.DRY:                          writeAt = q;                          r = Flush(r);                          q = writeAt; m = (int)(q < readAt ? readAt - q - 1 : end - q);                          if (readAt != writeAt)                          {                              bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                          mode = InflateBlockMode.DONE;                          goto case InflateBlockMode.DONE;                        case InflateBlockMode.DONE:                          r = ZlibConstants.Z_STREAM_END;                          bitb = b;                          bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                          return Flush(r);                        case InflateBlockMode.BAD:                          r = ZlibConstants.Z_DATA_ERROR;                            bitb = b; bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                          return Flush(r);                          default:                          r = ZlibConstants.Z_STREAM_ERROR;                            bitb = b; bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                          return Flush(r);                  }
Magic Number,Ionic.Zlib,InflateBlocks,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zlib.Shared\Inflate.cs,Process,The following statement contains a magic number: switch (mode)                  {                      case InflateBlockMode.TYPE:                            while (k < (3))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                                n--;                              b |= (_codec.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                          t = (int)(b & 7);                          last = t & 1;                            switch ((uint)t >> 1)                          {                              case 0:  // stored                                  b >>= 3; k -= (3);                                  t = k & 7; // go to byte boundary                                  b >>= t; k -= t;                                  mode = InflateBlockMode.LENS; // get length of stored block                                  break;                                case 1:  // fixed                                  int[] bl = new int[1];                                  int[] bd = new int[1];                                  int[][] tl = new int[1][];                                  int[][] td = new int[1][];                                  InfTree.inflate_trees_fixed(bl' bd' tl' td' _codec);                                  codes.Init(bl[0]' bd[0]' tl[0]' 0' td[0]' 0);                                  b >>= 3; k -= 3;                                  mode = InflateBlockMode.CODES;                                  break;                                case 2:  // dynamic                                  b >>= 3; k -= 3;                                  mode = InflateBlockMode.TABLE;                                  break;                                case 3:  // illegal                                  b >>= 3; k -= 3;                                  mode = InflateBlockMode.BAD;                                  _codec.Message = "invalid block type";                                  r = ZlibConstants.Z_DATA_ERROR;                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                          }                          break;                        case InflateBlockMode.LENS:                            while (k < (32))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                              ;                              n--;                              b |= (_codec.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            if ( ( ((~b)>>16) & 0xffff) != (b & 0xffff))                          {                              mode = InflateBlockMode.BAD;                              _codec.Message = "invalid stored block lengths";                              r = ZlibConstants.Z_DATA_ERROR;                                bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                          left = (b & 0xffff);                          b = k = 0; // dump bits                          mode = left != 0 ? InflateBlockMode.STORED : (last != 0 ? InflateBlockMode.DRY : InflateBlockMode.TYPE);                          break;                        case InflateBlockMode.STORED:                          if (n == 0)                          {                              bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                            if (m == 0)                          {                              if (q == end && readAt != 0)                              {                                  q = 0; m = (int)(q < readAt ? readAt - q - 1 : end - q);                              }                              if (m == 0)                              {                                  writeAt = q;                                  r = Flush(r);                                  q = writeAt; m = (int)(q < readAt ? readAt - q - 1 : end - q);                                  if (q == end && readAt != 0)                                  {                                      q = 0; m = (int)(q < readAt ? readAt - q - 1 : end - q);                                  }                                  if (m == 0)                                  {                                      bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                              }                          }                          r = ZlibConstants.Z_OK;                            t = left;                          if (t > n)                              t = n;                          if (t > m)                              t = m;                          Array.Copy(_codec.InputBuffer' p' window' q' t);                          p += t; n -= t;                          q += t; m -= t;                          if ((left -= t) != 0)                              break;                          mode = last != 0 ? InflateBlockMode.DRY : InflateBlockMode.TYPE;                          break;                        case InflateBlockMode.TABLE:                            while (k < (14))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                                n--;                              b |= (_codec.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            table = t = (b & 0x3fff);                          if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29)                          {                              mode = InflateBlockMode.BAD;                              _codec.Message = "too many length or distance symbols";                              r = ZlibConstants.Z_DATA_ERROR;                                bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                          t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);                          if (blens == null || blens.Length < t)                          {                              blens = new int[t];                          }                          else                          {                              Array.Clear(blens' 0' t);                              // for (int i = 0; i < t; i++)                              // {                              //     blens[i] = 0;                              // }                          }                            b >>= 14;                          k -= 14;                              index = 0;                          mode = InflateBlockMode.BTREE;                          goto case InflateBlockMode.BTREE;                        case InflateBlockMode.BTREE:                          while (index < 4 + (table >> 10))                          {                              while (k < (3))                              {                                  if (n != 0)                                  {                                      r = ZlibConstants.Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                                    n--;                                  b |= (_codec.InputBuffer[p++] & 0xff) << k;                                  k += 8;                              }                                blens[border[index++]] = b & 7;                                b >>= 3; k -= 3;                          }                            while (index < 19)                          {                              blens[border[index++]] = 0;                          }                            bb[0] = 7;                          t = inftree.inflate_trees_bits(blens' bb' tb' hufts' _codec);                          if (t != ZlibConstants.Z_OK)                          {                              r = t;                              if (r == ZlibConstants.Z_DATA_ERROR)                              {                                  blens = null;                                  mode = InflateBlockMode.BAD;                              }                                bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                            index = 0;                          mode = InflateBlockMode.DTREE;                          goto case InflateBlockMode.DTREE;                        case InflateBlockMode.DTREE:                          while (true)                          {                              t = table;                              if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)))                              {                                  break;                              }                                int i' j' c;                                t = bb[0];                                while (k < t)                              {                                  if (n != 0)                                  {                                      r = ZlibConstants.Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                                    n--;                                  b |= (_codec.InputBuffer[p++] & 0xff) << k;                                  k += 8;                              }                                t = hufts[(tb[0] + (b & InternalInflateConstants.InflateMask[t])) * 3 + 1];                              c = hufts[(tb[0] + (b & InternalInflateConstants.InflateMask[t])) * 3 + 2];                                if (c < 16)                              {                                  b >>= t; k -= t;                                  blens[index++] = c;                              }                              else                              {                                  // c == 16..18                                  i = c == 18 ? 7 : c - 14;                                  j = c == 18 ? 11 : 3;                                    while (k < (t + i))                                  {                                      if (n != 0)                                      {                                          r = ZlibConstants.Z_OK;                                      }                                      else                                      {                                          bitb = b; bitk = k;                                          _codec.AvailableBytesIn = n;                                          _codec.TotalBytesIn += p - _codec.NextIn;                                          _codec.NextIn = p;                                          writeAt = q;                                          return Flush(r);                                      }                                        n--;                                      b |= (_codec.InputBuffer[p++] & 0xff) << k;                                      k += 8;                                  }                                    b >>= t; k -= t;                                    j += (b & InternalInflateConstants.InflateMask[i]);                                    b >>= i; k -= i;                                    i = index;                                  t = table;                                  if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1))                                  {                                      blens = null;                                      mode = InflateBlockMode.BAD;                                      _codec.Message = "invalid bit length repeat";                                      r = ZlibConstants.Z_DATA_ERROR;                                        bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                                    c = (c == 16) ? blens[i-1] : 0;                                  do                                  {                                      blens[i++] = c;                                  }                                  while (--j != 0);                                  index = i;                              }                          }                            tb[0] = -1;                          {                              int[] bl = new int[] { 9 };  // must be <= 9 for lookahead assumptions                              int[] bd = new int[] { 6 }; // must be <= 9 for lookahead assumptions                              int[] tl = new int[1];                              int[] td = new int[1];                                t = table;                              t = inftree.inflate_trees_dynamic(257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' _codec);                                if (t != ZlibConstants.Z_OK)                              {                                  if (t == ZlibConstants.Z_DATA_ERROR)                                  {                                      blens = null;                                      mode = InflateBlockMode.BAD;                                  }                                  r = t;                                    bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                              codes.Init(bl[0]' bd[0]' hufts' tl[0]' hufts' td[0]);                          }                          mode = InflateBlockMode.CODES;                          goto case InflateBlockMode.CODES;                        case InflateBlockMode.CODES:                          bitb = b; bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                            r = codes.Process(this' r);                          if (r != ZlibConstants.Z_STREAM_END)                          {                              return Flush(r);                          }                            r = ZlibConstants.Z_OK;                          p = _codec.NextIn;                          n = _codec.AvailableBytesIn;                          b = bitb;                          k = bitk;                          q = writeAt;                          m = (int)(q < readAt ? readAt - q - 1 : end - q);                            if (last == 0)                          {                              mode = InflateBlockMode.TYPE;                              break;                          }                          mode = InflateBlockMode.DRY;                          goto case InflateBlockMode.DRY;                        case InflateBlockMode.DRY:                          writeAt = q;                          r = Flush(r);                          q = writeAt; m = (int)(q < readAt ? readAt - q - 1 : end - q);                          if (readAt != writeAt)                          {                              bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                          mode = InflateBlockMode.DONE;                          goto case InflateBlockMode.DONE;                        case InflateBlockMode.DONE:                          r = ZlibConstants.Z_STREAM_END;                          bitb = b;                          bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                          return Flush(r);                        case InflateBlockMode.BAD:                          r = ZlibConstants.Z_DATA_ERROR;                            bitb = b; bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                          return Flush(r);                          default:                          r = ZlibConstants.Z_STREAM_ERROR;                            bitb = b; bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                          return Flush(r);                  }
Magic Number,Ionic.Zlib,InflateBlocks,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zlib.Shared\Inflate.cs,Process,The following statement contains a magic number: switch (mode)                  {                      case InflateBlockMode.TYPE:                            while (k < (3))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                                n--;                              b |= (_codec.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                          t = (int)(b & 7);                          last = t & 1;                            switch ((uint)t >> 1)                          {                              case 0:  // stored                                  b >>= 3; k -= (3);                                  t = k & 7; // go to byte boundary                                  b >>= t; k -= t;                                  mode = InflateBlockMode.LENS; // get length of stored block                                  break;                                case 1:  // fixed                                  int[] bl = new int[1];                                  int[] bd = new int[1];                                  int[][] tl = new int[1][];                                  int[][] td = new int[1][];                                  InfTree.inflate_trees_fixed(bl' bd' tl' td' _codec);                                  codes.Init(bl[0]' bd[0]' tl[0]' 0' td[0]' 0);                                  b >>= 3; k -= 3;                                  mode = InflateBlockMode.CODES;                                  break;                                case 2:  // dynamic                                  b >>= 3; k -= 3;                                  mode = InflateBlockMode.TABLE;                                  break;                                case 3:  // illegal                                  b >>= 3; k -= 3;                                  mode = InflateBlockMode.BAD;                                  _codec.Message = "invalid block type";                                  r = ZlibConstants.Z_DATA_ERROR;                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                          }                          break;                        case InflateBlockMode.LENS:                            while (k < (32))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                              ;                              n--;                              b |= (_codec.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            if ( ( ((~b)>>16) & 0xffff) != (b & 0xffff))                          {                              mode = InflateBlockMode.BAD;                              _codec.Message = "invalid stored block lengths";                              r = ZlibConstants.Z_DATA_ERROR;                                bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                          left = (b & 0xffff);                          b = k = 0; // dump bits                          mode = left != 0 ? InflateBlockMode.STORED : (last != 0 ? InflateBlockMode.DRY : InflateBlockMode.TYPE);                          break;                        case InflateBlockMode.STORED:                          if (n == 0)                          {                              bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                            if (m == 0)                          {                              if (q == end && readAt != 0)                              {                                  q = 0; m = (int)(q < readAt ? readAt - q - 1 : end - q);                              }                              if (m == 0)                              {                                  writeAt = q;                                  r = Flush(r);                                  q = writeAt; m = (int)(q < readAt ? readAt - q - 1 : end - q);                                  if (q == end && readAt != 0)                                  {                                      q = 0; m = (int)(q < readAt ? readAt - q - 1 : end - q);                                  }                                  if (m == 0)                                  {                                      bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                              }                          }                          r = ZlibConstants.Z_OK;                            t = left;                          if (t > n)                              t = n;                          if (t > m)                              t = m;                          Array.Copy(_codec.InputBuffer' p' window' q' t);                          p += t; n -= t;                          q += t; m -= t;                          if ((left -= t) != 0)                              break;                          mode = last != 0 ? InflateBlockMode.DRY : InflateBlockMode.TYPE;                          break;                        case InflateBlockMode.TABLE:                            while (k < (14))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                                n--;                              b |= (_codec.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            table = t = (b & 0x3fff);                          if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29)                          {                              mode = InflateBlockMode.BAD;                              _codec.Message = "too many length or distance symbols";                              r = ZlibConstants.Z_DATA_ERROR;                                bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                          t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);                          if (blens == null || blens.Length < t)                          {                              blens = new int[t];                          }                          else                          {                              Array.Clear(blens' 0' t);                              // for (int i = 0; i < t; i++)                              // {                              //     blens[i] = 0;                              // }                          }                            b >>= 14;                          k -= 14;                              index = 0;                          mode = InflateBlockMode.BTREE;                          goto case InflateBlockMode.BTREE;                        case InflateBlockMode.BTREE:                          while (index < 4 + (table >> 10))                          {                              while (k < (3))                              {                                  if (n != 0)                                  {                                      r = ZlibConstants.Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                                    n--;                                  b |= (_codec.InputBuffer[p++] & 0xff) << k;                                  k += 8;                              }                                blens[border[index++]] = b & 7;                                b >>= 3; k -= 3;                          }                            while (index < 19)                          {                              blens[border[index++]] = 0;                          }                            bb[0] = 7;                          t = inftree.inflate_trees_bits(blens' bb' tb' hufts' _codec);                          if (t != ZlibConstants.Z_OK)                          {                              r = t;                              if (r == ZlibConstants.Z_DATA_ERROR)                              {                                  blens = null;                                  mode = InflateBlockMode.BAD;                              }                                bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                            index = 0;                          mode = InflateBlockMode.DTREE;                          goto case InflateBlockMode.DTREE;                        case InflateBlockMode.DTREE:                          while (true)                          {                              t = table;                              if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)))                              {                                  break;                              }                                int i' j' c;                                t = bb[0];                                while (k < t)                              {                                  if (n != 0)                                  {                                      r = ZlibConstants.Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                                    n--;                                  b |= (_codec.InputBuffer[p++] & 0xff) << k;                                  k += 8;                              }                                t = hufts[(tb[0] + (b & InternalInflateConstants.InflateMask[t])) * 3 + 1];                              c = hufts[(tb[0] + (b & InternalInflateConstants.InflateMask[t])) * 3 + 2];                                if (c < 16)                              {                                  b >>= t; k -= t;                                  blens[index++] = c;                              }                              else                              {                                  // c == 16..18                                  i = c == 18 ? 7 : c - 14;                                  j = c == 18 ? 11 : 3;                                    while (k < (t + i))                                  {                                      if (n != 0)                                      {                                          r = ZlibConstants.Z_OK;                                      }                                      else                                      {                                          bitb = b; bitk = k;                                          _codec.AvailableBytesIn = n;                                          _codec.TotalBytesIn += p - _codec.NextIn;                                          _codec.NextIn = p;                                          writeAt = q;                                          return Flush(r);                                      }                                        n--;                                      b |= (_codec.InputBuffer[p++] & 0xff) << k;                                      k += 8;                                  }                                    b >>= t; k -= t;                                    j += (b & InternalInflateConstants.InflateMask[i]);                                    b >>= i; k -= i;                                    i = index;                                  t = table;                                  if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1))                                  {                                      blens = null;                                      mode = InflateBlockMode.BAD;                                      _codec.Message = "invalid bit length repeat";                                      r = ZlibConstants.Z_DATA_ERROR;                                        bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                                    c = (c == 16) ? blens[i-1] : 0;                                  do                                  {                                      blens[i++] = c;                                  }                                  while (--j != 0);                                  index = i;                              }                          }                            tb[0] = -1;                          {                              int[] bl = new int[] { 9 };  // must be <= 9 for lookahead assumptions                              int[] bd = new int[] { 6 }; // must be <= 9 for lookahead assumptions                              int[] tl = new int[1];                              int[] td = new int[1];                                t = table;                              t = inftree.inflate_trees_dynamic(257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' _codec);                                if (t != ZlibConstants.Z_OK)                              {                                  if (t == ZlibConstants.Z_DATA_ERROR)                                  {                                      blens = null;                                      mode = InflateBlockMode.BAD;                                  }                                  r = t;                                    bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                              codes.Init(bl[0]' bd[0]' hufts' tl[0]' hufts' td[0]);                          }                          mode = InflateBlockMode.CODES;                          goto case InflateBlockMode.CODES;                        case InflateBlockMode.CODES:                          bitb = b; bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                            r = codes.Process(this' r);                          if (r != ZlibConstants.Z_STREAM_END)                          {                              return Flush(r);                          }                            r = ZlibConstants.Z_OK;                          p = _codec.NextIn;                          n = _codec.AvailableBytesIn;                          b = bitb;                          k = bitk;                          q = writeAt;                          m = (int)(q < readAt ? readAt - q - 1 : end - q);                            if (last == 0)                          {                              mode = InflateBlockMode.TYPE;                              break;                          }                          mode = InflateBlockMode.DRY;                          goto case InflateBlockMode.DRY;                        case InflateBlockMode.DRY:                          writeAt = q;                          r = Flush(r);                          q = writeAt; m = (int)(q < readAt ? readAt - q - 1 : end - q);                          if (readAt != writeAt)                          {                              bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                          mode = InflateBlockMode.DONE;                          goto case InflateBlockMode.DONE;                        case InflateBlockMode.DONE:                          r = ZlibConstants.Z_STREAM_END;                          bitb = b;                          bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                          return Flush(r);                        case InflateBlockMode.BAD:                          r = ZlibConstants.Z_DATA_ERROR;                            bitb = b; bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                          return Flush(r);                          default:                          r = ZlibConstants.Z_STREAM_ERROR;                            bitb = b; bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                          return Flush(r);                  }
Magic Number,Ionic.Zlib,InflateBlocks,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zlib.Shared\Inflate.cs,Process,The following statement contains a magic number: switch (mode)                  {                      case InflateBlockMode.TYPE:                            while (k < (3))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                                n--;                              b |= (_codec.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                          t = (int)(b & 7);                          last = t & 1;                            switch ((uint)t >> 1)                          {                              case 0:  // stored                                  b >>= 3; k -= (3);                                  t = k & 7; // go to byte boundary                                  b >>= t; k -= t;                                  mode = InflateBlockMode.LENS; // get length of stored block                                  break;                                case 1:  // fixed                                  int[] bl = new int[1];                                  int[] bd = new int[1];                                  int[][] tl = new int[1][];                                  int[][] td = new int[1][];                                  InfTree.inflate_trees_fixed(bl' bd' tl' td' _codec);                                  codes.Init(bl[0]' bd[0]' tl[0]' 0' td[0]' 0);                                  b >>= 3; k -= 3;                                  mode = InflateBlockMode.CODES;                                  break;                                case 2:  // dynamic                                  b >>= 3; k -= 3;                                  mode = InflateBlockMode.TABLE;                                  break;                                case 3:  // illegal                                  b >>= 3; k -= 3;                                  mode = InflateBlockMode.BAD;                                  _codec.Message = "invalid block type";                                  r = ZlibConstants.Z_DATA_ERROR;                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                          }                          break;                        case InflateBlockMode.LENS:                            while (k < (32))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                              ;                              n--;                              b |= (_codec.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            if ( ( ((~b)>>16) & 0xffff) != (b & 0xffff))                          {                              mode = InflateBlockMode.BAD;                              _codec.Message = "invalid stored block lengths";                              r = ZlibConstants.Z_DATA_ERROR;                                bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                          left = (b & 0xffff);                          b = k = 0; // dump bits                          mode = left != 0 ? InflateBlockMode.STORED : (last != 0 ? InflateBlockMode.DRY : InflateBlockMode.TYPE);                          break;                        case InflateBlockMode.STORED:                          if (n == 0)                          {                              bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                            if (m == 0)                          {                              if (q == end && readAt != 0)                              {                                  q = 0; m = (int)(q < readAt ? readAt - q - 1 : end - q);                              }                              if (m == 0)                              {                                  writeAt = q;                                  r = Flush(r);                                  q = writeAt; m = (int)(q < readAt ? readAt - q - 1 : end - q);                                  if (q == end && readAt != 0)                                  {                                      q = 0; m = (int)(q < readAt ? readAt - q - 1 : end - q);                                  }                                  if (m == 0)                                  {                                      bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                              }                          }                          r = ZlibConstants.Z_OK;                            t = left;                          if (t > n)                              t = n;                          if (t > m)                              t = m;                          Array.Copy(_codec.InputBuffer' p' window' q' t);                          p += t; n -= t;                          q += t; m -= t;                          if ((left -= t) != 0)                              break;                          mode = last != 0 ? InflateBlockMode.DRY : InflateBlockMode.TYPE;                          break;                        case InflateBlockMode.TABLE:                            while (k < (14))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                                n--;                              b |= (_codec.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            table = t = (b & 0x3fff);                          if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29)                          {                              mode = InflateBlockMode.BAD;                              _codec.Message = "too many length or distance symbols";                              r = ZlibConstants.Z_DATA_ERROR;                                bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                          t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);                          if (blens == null || blens.Length < t)                          {                              blens = new int[t];                          }                          else                          {                              Array.Clear(blens' 0' t);                              // for (int i = 0; i < t; i++)                              // {                              //     blens[i] = 0;                              // }                          }                            b >>= 14;                          k -= 14;                              index = 0;                          mode = InflateBlockMode.BTREE;                          goto case InflateBlockMode.BTREE;                        case InflateBlockMode.BTREE:                          while (index < 4 + (table >> 10))                          {                              while (k < (3))                              {                                  if (n != 0)                                  {                                      r = ZlibConstants.Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                                    n--;                                  b |= (_codec.InputBuffer[p++] & 0xff) << k;                                  k += 8;                              }                                blens[border[index++]] = b & 7;                                b >>= 3; k -= 3;                          }                            while (index < 19)                          {                              blens[border[index++]] = 0;                          }                            bb[0] = 7;                          t = inftree.inflate_trees_bits(blens' bb' tb' hufts' _codec);                          if (t != ZlibConstants.Z_OK)                          {                              r = t;                              if (r == ZlibConstants.Z_DATA_ERROR)                              {                                  blens = null;                                  mode = InflateBlockMode.BAD;                              }                                bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                            index = 0;                          mode = InflateBlockMode.DTREE;                          goto case InflateBlockMode.DTREE;                        case InflateBlockMode.DTREE:                          while (true)                          {                              t = table;                              if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)))                              {                                  break;                              }                                int i' j' c;                                t = bb[0];                                while (k < t)                              {                                  if (n != 0)                                  {                                      r = ZlibConstants.Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                                    n--;                                  b |= (_codec.InputBuffer[p++] & 0xff) << k;                                  k += 8;                              }                                t = hufts[(tb[0] + (b & InternalInflateConstants.InflateMask[t])) * 3 + 1];                              c = hufts[(tb[0] + (b & InternalInflateConstants.InflateMask[t])) * 3 + 2];                                if (c < 16)                              {                                  b >>= t; k -= t;                                  blens[index++] = c;                              }                              else                              {                                  // c == 16..18                                  i = c == 18 ? 7 : c - 14;                                  j = c == 18 ? 11 : 3;                                    while (k < (t + i))                                  {                                      if (n != 0)                                      {                                          r = ZlibConstants.Z_OK;                                      }                                      else                                      {                                          bitb = b; bitk = k;                                          _codec.AvailableBytesIn = n;                                          _codec.TotalBytesIn += p - _codec.NextIn;                                          _codec.NextIn = p;                                          writeAt = q;                                          return Flush(r);                                      }                                        n--;                                      b |= (_codec.InputBuffer[p++] & 0xff) << k;                                      k += 8;                                  }                                    b >>= t; k -= t;                                    j += (b & InternalInflateConstants.InflateMask[i]);                                    b >>= i; k -= i;                                    i = index;                                  t = table;                                  if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1))                                  {                                      blens = null;                                      mode = InflateBlockMode.BAD;                                      _codec.Message = "invalid bit length repeat";                                      r = ZlibConstants.Z_DATA_ERROR;                                        bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                                    c = (c == 16) ? blens[i-1] : 0;                                  do                                  {                                      blens[i++] = c;                                  }                                  while (--j != 0);                                  index = i;                              }                          }                            tb[0] = -1;                          {                              int[] bl = new int[] { 9 };  // must be <= 9 for lookahead assumptions                              int[] bd = new int[] { 6 }; // must be <= 9 for lookahead assumptions                              int[] tl = new int[1];                              int[] td = new int[1];                                t = table;                              t = inftree.inflate_trees_dynamic(257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' _codec);                                if (t != ZlibConstants.Z_OK)                              {                                  if (t == ZlibConstants.Z_DATA_ERROR)                                  {                                      blens = null;                                      mode = InflateBlockMode.BAD;                                  }                                  r = t;                                    bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                              codes.Init(bl[0]' bd[0]' hufts' tl[0]' hufts' td[0]);                          }                          mode = InflateBlockMode.CODES;                          goto case InflateBlockMode.CODES;                        case InflateBlockMode.CODES:                          bitb = b; bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                            r = codes.Process(this' r);                          if (r != ZlibConstants.Z_STREAM_END)                          {                              return Flush(r);                          }                            r = ZlibConstants.Z_OK;                          p = _codec.NextIn;                          n = _codec.AvailableBytesIn;                          b = bitb;                          k = bitk;                          q = writeAt;                          m = (int)(q < readAt ? readAt - q - 1 : end - q);                            if (last == 0)                          {                              mode = InflateBlockMode.TYPE;                              break;                          }                          mode = InflateBlockMode.DRY;                          goto case InflateBlockMode.DRY;                        case InflateBlockMode.DRY:                          writeAt = q;                          r = Flush(r);                          q = writeAt; m = (int)(q < readAt ? readAt - q - 1 : end - q);                          if (readAt != writeAt)                          {                              bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                          mode = InflateBlockMode.DONE;                          goto case InflateBlockMode.DONE;                        case InflateBlockMode.DONE:                          r = ZlibConstants.Z_STREAM_END;                          bitb = b;                          bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                          return Flush(r);                        case InflateBlockMode.BAD:                          r = ZlibConstants.Z_DATA_ERROR;                            bitb = b; bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                          return Flush(r);                          default:                          r = ZlibConstants.Z_STREAM_ERROR;                            bitb = b; bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                          return Flush(r);                  }
Magic Number,Ionic.Zlib,InflateBlocks,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zlib.Shared\Inflate.cs,Process,The following statement contains a magic number: switch (mode)                  {                      case InflateBlockMode.TYPE:                            while (k < (3))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                                n--;                              b |= (_codec.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                          t = (int)(b & 7);                          last = t & 1;                            switch ((uint)t >> 1)                          {                              case 0:  // stored                                  b >>= 3; k -= (3);                                  t = k & 7; // go to byte boundary                                  b >>= t; k -= t;                                  mode = InflateBlockMode.LENS; // get length of stored block                                  break;                                case 1:  // fixed                                  int[] bl = new int[1];                                  int[] bd = new int[1];                                  int[][] tl = new int[1][];                                  int[][] td = new int[1][];                                  InfTree.inflate_trees_fixed(bl' bd' tl' td' _codec);                                  codes.Init(bl[0]' bd[0]' tl[0]' 0' td[0]' 0);                                  b >>= 3; k -= 3;                                  mode = InflateBlockMode.CODES;                                  break;                                case 2:  // dynamic                                  b >>= 3; k -= 3;                                  mode = InflateBlockMode.TABLE;                                  break;                                case 3:  // illegal                                  b >>= 3; k -= 3;                                  mode = InflateBlockMode.BAD;                                  _codec.Message = "invalid block type";                                  r = ZlibConstants.Z_DATA_ERROR;                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                          }                          break;                        case InflateBlockMode.LENS:                            while (k < (32))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                              ;                              n--;                              b |= (_codec.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            if ( ( ((~b)>>16) & 0xffff) != (b & 0xffff))                          {                              mode = InflateBlockMode.BAD;                              _codec.Message = "invalid stored block lengths";                              r = ZlibConstants.Z_DATA_ERROR;                                bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                          left = (b & 0xffff);                          b = k = 0; // dump bits                          mode = left != 0 ? InflateBlockMode.STORED : (last != 0 ? InflateBlockMode.DRY : InflateBlockMode.TYPE);                          break;                        case InflateBlockMode.STORED:                          if (n == 0)                          {                              bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                            if (m == 0)                          {                              if (q == end && readAt != 0)                              {                                  q = 0; m = (int)(q < readAt ? readAt - q - 1 : end - q);                              }                              if (m == 0)                              {                                  writeAt = q;                                  r = Flush(r);                                  q = writeAt; m = (int)(q < readAt ? readAt - q - 1 : end - q);                                  if (q == end && readAt != 0)                                  {                                      q = 0; m = (int)(q < readAt ? readAt - q - 1 : end - q);                                  }                                  if (m == 0)                                  {                                      bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                              }                          }                          r = ZlibConstants.Z_OK;                            t = left;                          if (t > n)                              t = n;                          if (t > m)                              t = m;                          Array.Copy(_codec.InputBuffer' p' window' q' t);                          p += t; n -= t;                          q += t; m -= t;                          if ((left -= t) != 0)                              break;                          mode = last != 0 ? InflateBlockMode.DRY : InflateBlockMode.TYPE;                          break;                        case InflateBlockMode.TABLE:                            while (k < (14))                          {                              if (n != 0)                              {                                  r = ZlibConstants.Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                                n--;                              b |= (_codec.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            table = t = (b & 0x3fff);                          if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29)                          {                              mode = InflateBlockMode.BAD;                              _codec.Message = "too many length or distance symbols";                              r = ZlibConstants.Z_DATA_ERROR;                                bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                          t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);                          if (blens == null || blens.Length < t)                          {                              blens = new int[t];                          }                          else                          {                              Array.Clear(blens' 0' t);                              // for (int i = 0; i < t; i++)                              // {                              //     blens[i] = 0;                              // }                          }                            b >>= 14;                          k -= 14;                              index = 0;                          mode = InflateBlockMode.BTREE;                          goto case InflateBlockMode.BTREE;                        case InflateBlockMode.BTREE:                          while (index < 4 + (table >> 10))                          {                              while (k < (3))                              {                                  if (n != 0)                                  {                                      r = ZlibConstants.Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                                    n--;                                  b |= (_codec.InputBuffer[p++] & 0xff) << k;                                  k += 8;                              }                                blens[border[index++]] = b & 7;                                b >>= 3; k -= 3;                          }                            while (index < 19)                          {                              blens[border[index++]] = 0;                          }                            bb[0] = 7;                          t = inftree.inflate_trees_bits(blens' bb' tb' hufts' _codec);                          if (t != ZlibConstants.Z_OK)                          {                              r = t;                              if (r == ZlibConstants.Z_DATA_ERROR)                              {                                  blens = null;                                  mode = InflateBlockMode.BAD;                              }                                bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                            index = 0;                          mode = InflateBlockMode.DTREE;                          goto case InflateBlockMode.DTREE;                        case InflateBlockMode.DTREE:                          while (true)                          {                              t = table;                              if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)))                              {                                  break;                              }                                int i' j' c;                                t = bb[0];                                while (k < t)                              {                                  if (n != 0)                                  {                                      r = ZlibConstants.Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                                    n--;                                  b |= (_codec.InputBuffer[p++] & 0xff) << k;                                  k += 8;                              }                                t = hufts[(tb[0] + (b & InternalInflateConstants.InflateMask[t])) * 3 + 1];                              c = hufts[(tb[0] + (b & InternalInflateConstants.InflateMask[t])) * 3 + 2];                                if (c < 16)                              {                                  b >>= t; k -= t;                                  blens[index++] = c;                              }                              else                              {                                  // c == 16..18                                  i = c == 18 ? 7 : c - 14;                                  j = c == 18 ? 11 : 3;                                    while (k < (t + i))                                  {                                      if (n != 0)                                      {                                          r = ZlibConstants.Z_OK;                                      }                                      else                                      {                                          bitb = b; bitk = k;                                          _codec.AvailableBytesIn = n;                                          _codec.TotalBytesIn += p - _codec.NextIn;                                          _codec.NextIn = p;                                          writeAt = q;                                          return Flush(r);                                      }                                        n--;                                      b |= (_codec.InputBuffer[p++] & 0xff) << k;                                      k += 8;                                  }                                    b >>= t; k -= t;                                    j += (b & InternalInflateConstants.InflateMask[i]);                                    b >>= i; k -= i;                                    i = index;                                  t = table;                                  if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1))                                  {                                      blens = null;                                      mode = InflateBlockMode.BAD;                                      _codec.Message = "invalid bit length repeat";                                      r = ZlibConstants.Z_DATA_ERROR;                                        bitb = b; bitk = k;                                      _codec.AvailableBytesIn = n;                                      _codec.TotalBytesIn += p - _codec.NextIn;                                      _codec.NextIn = p;                                      writeAt = q;                                      return Flush(r);                                  }                                    c = (c == 16) ? blens[i-1] : 0;                                  do                                  {                                      blens[i++] = c;                                  }                                  while (--j != 0);                                  index = i;                              }                          }                            tb[0] = -1;                          {                              int[] bl = new int[] { 9 };  // must be <= 9 for lookahead assumptions                              int[] bd = new int[] { 6 }; // must be <= 9 for lookahead assumptions                              int[] tl = new int[1];                              int[] td = new int[1];                                t = table;                              t = inftree.inflate_trees_dynamic(257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' _codec);                                if (t != ZlibConstants.Z_OK)                              {                                  if (t == ZlibConstants.Z_DATA_ERROR)                                  {                                      blens = null;                                      mode = InflateBlockMode.BAD;                                  }                                  r = t;                                    bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                              }                              codes.Init(bl[0]' bd[0]' hufts' tl[0]' hufts' td[0]);                          }                          mode = InflateBlockMode.CODES;                          goto case InflateBlockMode.CODES;                        case InflateBlockMode.CODES:                          bitb = b; bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                            r = codes.Process(this' r);                          if (r != ZlibConstants.Z_STREAM_END)                          {                              return Flush(r);                          }                            r = ZlibConstants.Z_OK;                          p = _codec.NextIn;                          n = _codec.AvailableBytesIn;                          b = bitb;                          k = bitk;                          q = writeAt;                          m = (int)(q < readAt ? readAt - q - 1 : end - q);                            if (last == 0)                          {                              mode = InflateBlockMode.TYPE;                              break;                          }                          mode = InflateBlockMode.DRY;                          goto case InflateBlockMode.DRY;                        case InflateBlockMode.DRY:                          writeAt = q;                          r = Flush(r);                          q = writeAt; m = (int)(q < readAt ? readAt - q - 1 : end - q);                          if (readAt != writeAt)                          {                              bitb = b; bitk = k;                              _codec.AvailableBytesIn = n;                              _codec.TotalBytesIn += p - _codec.NextIn;                              _codec.NextIn = p;                              writeAt = q;                              return Flush(r);                          }                          mode = InflateBlockMode.DONE;                          goto case InflateBlockMode.DONE;                        case InflateBlockMode.DONE:                          r = ZlibConstants.Z_STREAM_END;                          bitb = b;                          bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                          return Flush(r);                        case InflateBlockMode.BAD:                          r = ZlibConstants.Z_DATA_ERROR;                            bitb = b; bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                          return Flush(r);                          default:                          r = ZlibConstants.Z_STREAM_ERROR;                            bitb = b; bitk = k;                          _codec.AvailableBytesIn = n;                          _codec.TotalBytesIn += p - _codec.NextIn;                          _codec.NextIn = p;                          writeAt = q;                          return Flush(r);                  }
Magic Number,Ionic.Zlib,InflateBlocks,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zlib.Shared\Inflate.cs,Flush,The following statement contains a magic number: pass < 2
Magic Number,Ionic.Zlib,InflateCodes,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zlib.Shared\Inflate.cs,Process,The following statement contains a magic number: switch (mode)                  {                      // waiting for "i:"=input' "o:"=output' "x:"=nothing                      case START:  // x: set up for LEN                          if (m >= 258 && n >= 10)                          {                              blocks.bitb = b; blocks.bitk = k;                              z.AvailableBytesIn = n;                              z.TotalBytesIn += p - z.NextIn;                              z.NextIn = p;                              blocks.writeAt = q;                              r = InflateFast(lbits' dbits' ltree' ltree_index' dtree' dtree_index' blocks' z);                                p = z.NextIn;                              n = z.AvailableBytesIn;                              b = blocks.bitb;                              k = blocks.bitk;                              q = blocks.writeAt; m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;                                if (r != ZlibConstants.Z_OK)                              {                                  mode = (r == ZlibConstants.Z_STREAM_END) ? WASH : BADCODE;                                  break;                              }                          }                          need = lbits;                          tree = ltree;                          tree_index = ltree_index;                            mode = LEN;                          goto case LEN;                        case LEN:  // i: get length/literal/eob next                          j = need;                            while (k < j)                          {                              if (n != 0)                                  r = ZlibConstants.Z_OK;                              else                              {                                  blocks.bitb = b; blocks.bitk = k;                                  z.AvailableBytesIn = n;                                  z.TotalBytesIn += p - z.NextIn;                                  z.NextIn = p;                                  blocks.writeAt = q;                                  return blocks.Flush(r);                              }                              n--;                              b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            tindex = (tree_index + (b & InternalInflateConstants.InflateMask[j])) * 3;                            b >>= (tree[tindex + 1]);                          k -= (tree[tindex + 1]);                            e = tree[tindex];                            if (e == 0)                          {                              // literal                              lit = tree[tindex + 2];                              mode = LIT;                              break;                          }                          if ((e & 16) != 0)                          {                              // length                              bitsToGet = e & 15;                              len = tree[tindex + 2];                              mode = LENEXT;                              break;                          }                          if ((e & 64) == 0)                          {                              // next table                              need = e;                              tree_index = tindex / 3 + tree[tindex + 2];                              break;                          }                          if ((e & 32) != 0)                          {                              // end of block                              mode = WASH;                              break;                          }                          mode = BADCODE; // invalid code                          z.Message = "invalid literal/length code";                          r = ZlibConstants.Z_DATA_ERROR;                            blocks.bitb = b; blocks.bitk = k;                          z.AvailableBytesIn = n;                          z.TotalBytesIn += p - z.NextIn;                          z.NextIn = p;                          blocks.writeAt = q;                          return blocks.Flush(r);                          case LENEXT:  // i: getting length extra (have base)                          j = bitsToGet;                            while (k < j)                          {                              if (n != 0)                                  r = ZlibConstants.Z_OK;                              else                              {                                  blocks.bitb = b; blocks.bitk = k;                                  z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  blocks.writeAt = q;                                  return blocks.Flush(r);                              }                              n--; b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            len += (b & InternalInflateConstants.InflateMask[j]);                            b >>= j;                          k -= j;                            need = dbits;                          tree = dtree;                          tree_index = dtree_index;                          mode = DIST;                          goto case DIST;                        case DIST:  // i: get distance next                          j = need;                            while (k < j)                          {                              if (n != 0)                                  r = ZlibConstants.Z_OK;                              else                              {                                  blocks.bitb = b; blocks.bitk = k;                                  z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  blocks.writeAt = q;                                  return blocks.Flush(r);                              }                              n--; b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            tindex = (tree_index + (b & InternalInflateConstants.InflateMask[j])) * 3;                            b >>= tree[tindex + 1];                          k -= tree[tindex + 1];                            e = (tree[tindex]);                          if ((e & 0x10) != 0)                          {                              // distance                              bitsToGet = e & 15;                              dist = tree[tindex + 2];                              mode = DISTEXT;                              break;                          }                          if ((e & 64) == 0)                          {                              // next table                              need = e;                              tree_index = tindex / 3 + tree[tindex + 2];                              break;                          }                          mode = BADCODE; // invalid code                          z.Message = "invalid distance code";                          r = ZlibConstants.Z_DATA_ERROR;                            blocks.bitb = b; blocks.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          blocks.writeAt = q;                          return blocks.Flush(r);                          case DISTEXT:  // i: getting distance extra                          j = bitsToGet;                            while (k < j)                          {                              if (n != 0)                                  r = ZlibConstants.Z_OK;                              else                              {                                  blocks.bitb = b; blocks.bitk = k;                                  z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  blocks.writeAt = q;                                  return blocks.Flush(r);                              }                              n--; b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            dist += (b & InternalInflateConstants.InflateMask[j]);                            b >>= j;                          k -= j;                            mode = COPY;                          goto case COPY;                        case COPY:  // o: copying bytes in window' waiting for space                          f = q - dist;                          while (f < 0)                          {                              // modulo window size-"while" instead                              f += blocks.end; // of "if" handles invalid distances                          }                          while (len != 0)                          {                              if (m == 0)                              {                                  if (q == blocks.end && blocks.readAt != 0)                                  {                                      q = 0; m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;                                  }                                  if (m == 0)                                  {                                      blocks.writeAt = q; r = blocks.Flush(r);                                      q = blocks.writeAt; m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;                                        if (q == blocks.end && blocks.readAt != 0)                                      {                                          q = 0; m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;                                      }                                        if (m == 0)                                      {                                          blocks.bitb = b; blocks.bitk = k;                                          z.AvailableBytesIn = n;                                          z.TotalBytesIn += p - z.NextIn;                                          z.NextIn = p;                                          blocks.writeAt = q;                                          return blocks.Flush(r);                                      }                                  }                              }                                blocks.window[q++] = blocks.window[f++]; m--;                                if (f == blocks.end)                                  f = 0;                              len--;                          }                          mode = START;                          break;                        case LIT:  // o: got literal' waiting for output space                          if (m == 0)                          {                              if (q == blocks.end && blocks.readAt != 0)                              {                                  q = 0; m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;                              }                              if (m == 0)                              {                                  blocks.writeAt = q; r = blocks.Flush(r);                                  q = blocks.writeAt; m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;                                    if (q == blocks.end && blocks.readAt != 0)                                  {                                      q = 0; m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;                                  }                                  if (m == 0)                                  {                                      blocks.bitb = b; blocks.bitk = k;                                      z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                      blocks.writeAt = q;                                      return blocks.Flush(r);                                  }                              }                          }                          r = ZlibConstants.Z_OK;                            blocks.window[q++] = (byte)lit; m--;                            mode = START;                          break;                        case WASH:  // o: got eob' possibly more output                          if (k > 7)                          {                              // return unused byte' if any                              k -= 8;                              n++;                              p--; // can always return one                          }                            blocks.writeAt = q; r = blocks.Flush(r);                          q = blocks.writeAt; m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;                            if (blocks.readAt != blocks.writeAt)                          {                              blocks.bitb = b; blocks.bitk = k;                              z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                              blocks.writeAt = q;                              return blocks.Flush(r);                          }                          mode = END;                          goto case END;                        case END:                          r = ZlibConstants.Z_STREAM_END;                          blocks.bitb = b; blocks.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          blocks.writeAt = q;                          return blocks.Flush(r);                        case BADCODE:  // x: got error                            r = ZlibConstants.Z_DATA_ERROR;                            blocks.bitb = b; blocks.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          blocks.writeAt = q;                          return blocks.Flush(r);                        default:                          r = ZlibConstants.Z_STREAM_ERROR;                            blocks.bitb = b; blocks.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          blocks.writeAt = q;                          return blocks.Flush(r);                  }
Magic Number,Ionic.Zlib,InflateCodes,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zlib.Shared\Inflate.cs,Process,The following statement contains a magic number: switch (mode)                  {                      // waiting for "i:"=input' "o:"=output' "x:"=nothing                      case START:  // x: set up for LEN                          if (m >= 258 && n >= 10)                          {                              blocks.bitb = b; blocks.bitk = k;                              z.AvailableBytesIn = n;                              z.TotalBytesIn += p - z.NextIn;                              z.NextIn = p;                              blocks.writeAt = q;                              r = InflateFast(lbits' dbits' ltree' ltree_index' dtree' dtree_index' blocks' z);                                p = z.NextIn;                              n = z.AvailableBytesIn;                              b = blocks.bitb;                              k = blocks.bitk;                              q = blocks.writeAt; m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;                                if (r != ZlibConstants.Z_OK)                              {                                  mode = (r == ZlibConstants.Z_STREAM_END) ? WASH : BADCODE;                                  break;                              }                          }                          need = lbits;                          tree = ltree;                          tree_index = ltree_index;                            mode = LEN;                          goto case LEN;                        case LEN:  // i: get length/literal/eob next                          j = need;                            while (k < j)                          {                              if (n != 0)                                  r = ZlibConstants.Z_OK;                              else                              {                                  blocks.bitb = b; blocks.bitk = k;                                  z.AvailableBytesIn = n;                                  z.TotalBytesIn += p - z.NextIn;                                  z.NextIn = p;                                  blocks.writeAt = q;                                  return blocks.Flush(r);                              }                              n--;                              b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            tindex = (tree_index + (b & InternalInflateConstants.InflateMask[j])) * 3;                            b >>= (tree[tindex + 1]);                          k -= (tree[tindex + 1]);                            e = tree[tindex];                            if (e == 0)                          {                              // literal                              lit = tree[tindex + 2];                              mode = LIT;                              break;                          }                          if ((e & 16) != 0)                          {                              // length                              bitsToGet = e & 15;                              len = tree[tindex + 2];                              mode = LENEXT;                              break;                          }                          if ((e & 64) == 0)                          {                              // next table                              need = e;                              tree_index = tindex / 3 + tree[tindex + 2];                              break;                          }                          if ((e & 32) != 0)                          {                              // end of block                              mode = WASH;                              break;                          }                          mode = BADCODE; // invalid code                          z.Message = "invalid literal/length code";                          r = ZlibConstants.Z_DATA_ERROR;                            blocks.bitb = b; blocks.bitk = k;                          z.AvailableBytesIn = n;                          z.TotalBytesIn += p - z.NextIn;                          z.NextIn = p;                          blocks.writeAt = q;                          return blocks.Flush(r);                          case LENEXT:  // i: getting length extra (have base)                          j = bitsToGet;                            while (k < j)                          {                              if (n != 0)                                  r = ZlibConstants.Z_OK;                              else                              {                                  blocks.bitb = b; blocks.bitk = k;                                  z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  blocks.writeAt = q;                                  return blocks.Flush(r);                              }                              n--; b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            len += (b & InternalInflateConstants.InflateMask[j]);                            b >>= j;                          k -= j;                            need = dbits;                          tree = dtree;                          tree_index = dtree_index;                          mode = DIST;                          goto case DIST;                        case DIST:  // i: get distance next                          j = need;                            while (k < j)                          {                              if (n != 0)                                  r = ZlibConstants.Z_OK;                              else                              {                                  blocks.bitb = b; blocks.bitk = k;                                  z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  blocks.writeAt = q;                                  return blocks.Flush(r);                              }                              n--; b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            tindex = (tree_index + (b & InternalInflateConstants.InflateMask[j])) * 3;                            b >>= tree[tindex + 1];                          k -= tree[tindex + 1];                            e = (tree[tindex]);                          if ((e & 0x10) != 0)                          {                              // distance                              bitsToGet = e & 15;                              dist = tree[tindex + 2];                              mode = DISTEXT;                              break;                          }                          if ((e & 64) == 0)                          {                              // next table                              need = e;                              tree_index = tindex / 3 + tree[tindex + 2];                              break;                          }                          mode = BADCODE; // invalid code                          z.Message = "invalid distance code";                          r = ZlibConstants.Z_DATA_ERROR;                            blocks.bitb = b; blocks.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          blocks.writeAt = q;                          return blocks.Flush(r);                          case DISTEXT:  // i: getting distance extra                          j = bitsToGet;                            while (k < j)                          {                              if (n != 0)                                  r = ZlibConstants.Z_OK;                              else                              {                                  blocks.bitb = b; blocks.bitk = k;                                  z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  blocks.writeAt = q;                                  return blocks.Flush(r);                              }                              n--; b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            dist += (b & InternalInflateConstants.InflateMask[j]);                            b >>= j;                          k -= j;                            mode = COPY;                          goto case COPY;                        case COPY:  // o: copying bytes in window' waiting for space                          f = q - dist;                          while (f < 0)                          {                              // modulo window size-"while" instead                              f += blocks.end; // of "if" handles invalid distances                          }                          while (len != 0)                          {                              if (m == 0)                              {                                  if (q == blocks.end && blocks.readAt != 0)                                  {                                      q = 0; m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;                                  }                                  if (m == 0)                                  {                                      blocks.writeAt = q; r = blocks.Flush(r);                                      q = blocks.writeAt; m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;                                        if (q == blocks.end && blocks.readAt != 0)                                      {                                          q = 0; m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;                                      }                                        if (m == 0)                                      {                                          blocks.bitb = b; blocks.bitk = k;                                          z.AvailableBytesIn = n;                                          z.TotalBytesIn += p - z.NextIn;                                          z.NextIn = p;                                          blocks.writeAt = q;                                          return blocks.Flush(r);                                      }                                  }                              }                                blocks.window[q++] = blocks.window[f++]; m--;                                if (f == blocks.end)                                  f = 0;                              len--;                          }                          mode = START;                          break;                        case LIT:  // o: got literal' waiting for output space                          if (m == 0)                          {                              if (q == blocks.end && blocks.readAt != 0)                              {                                  q = 0; m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;                              }                              if (m == 0)                              {                                  blocks.writeAt = q; r = blocks.Flush(r);                                  q = blocks.writeAt; m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;                                    if (q == blocks.end && blocks.readAt != 0)                                  {                                      q = 0; m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;                                  }                                  if (m == 0)                                  {                                      blocks.bitb = b; blocks.bitk = k;                                      z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                      blocks.writeAt = q;                                      return blocks.Flush(r);                                  }                              }                          }                          r = ZlibConstants.Z_OK;                            blocks.window[q++] = (byte)lit; m--;                            mode = START;                          break;                        case WASH:  // o: got eob' possibly more output                          if (k > 7)                          {                              // return unused byte' if any                              k -= 8;                              n++;                              p--; // can always return one                          }                            blocks.writeAt = q; r = blocks.Flush(r);                          q = blocks.writeAt; m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;                            if (blocks.readAt != blocks.writeAt)                          {                              blocks.bitb = b; blocks.bitk = k;                              z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                              blocks.writeAt = q;                              return blocks.Flush(r);                          }                          mode = END;                          goto case END;                        case END:                          r = ZlibConstants.Z_STREAM_END;                          blocks.bitb = b; blocks.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          blocks.writeAt = q;                          return blocks.Flush(r);                        case BADCODE:  // x: got error                            r = ZlibConstants.Z_DATA_ERROR;                            blocks.bitb = b; blocks.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          blocks.writeAt = q;                          return blocks.Flush(r);                        default:                          r = ZlibConstants.Z_STREAM_ERROR;                            blocks.bitb = b; blocks.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          blocks.writeAt = q;                          return blocks.Flush(r);                  }
Magic Number,Ionic.Zlib,InflateCodes,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zlib.Shared\Inflate.cs,Process,The following statement contains a magic number: switch (mode)                  {                      // waiting for "i:"=input' "o:"=output' "x:"=nothing                      case START:  // x: set up for LEN                          if (m >= 258 && n >= 10)                          {                              blocks.bitb = b; blocks.bitk = k;                              z.AvailableBytesIn = n;                              z.TotalBytesIn += p - z.NextIn;                              z.NextIn = p;                              blocks.writeAt = q;                              r = InflateFast(lbits' dbits' ltree' ltree_index' dtree' dtree_index' blocks' z);                                p = z.NextIn;                              n = z.AvailableBytesIn;                              b = blocks.bitb;                              k = blocks.bitk;                              q = blocks.writeAt; m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;                                if (r != ZlibConstants.Z_OK)                              {                                  mode = (r == ZlibConstants.Z_STREAM_END) ? WASH : BADCODE;                                  break;                              }                          }                          need = lbits;                          tree = ltree;                          tree_index = ltree_index;                            mode = LEN;                          goto case LEN;                        case LEN:  // i: get length/literal/eob next                          j = need;                            while (k < j)                          {                              if (n != 0)                                  r = ZlibConstants.Z_OK;                              else                              {                                  blocks.bitb = b; blocks.bitk = k;                                  z.AvailableBytesIn = n;                                  z.TotalBytesIn += p - z.NextIn;                                  z.NextIn = p;                                  blocks.writeAt = q;                                  return blocks.Flush(r);                              }                              n--;                              b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            tindex = (tree_index + (b & InternalInflateConstants.InflateMask[j])) * 3;                            b >>= (tree[tindex + 1]);                          k -= (tree[tindex + 1]);                            e = tree[tindex];                            if (e == 0)                          {                              // literal                              lit = tree[tindex + 2];                              mode = LIT;                              break;                          }                          if ((e & 16) != 0)                          {                              // length                              bitsToGet = e & 15;                              len = tree[tindex + 2];                              mode = LENEXT;                              break;                          }                          if ((e & 64) == 0)                          {                              // next table                              need = e;                              tree_index = tindex / 3 + tree[tindex + 2];                              break;                          }                          if ((e & 32) != 0)                          {                              // end of block                              mode = WASH;                              break;                          }                          mode = BADCODE; // invalid code                          z.Message = "invalid literal/length code";                          r = ZlibConstants.Z_DATA_ERROR;                            blocks.bitb = b; blocks.bitk = k;                          z.AvailableBytesIn = n;                          z.TotalBytesIn += p - z.NextIn;                          z.NextIn = p;                          blocks.writeAt = q;                          return blocks.Flush(r);                          case LENEXT:  // i: getting length extra (have base)                          j = bitsToGet;                            while (k < j)                          {                              if (n != 0)                                  r = ZlibConstants.Z_OK;                              else                              {                                  blocks.bitb = b; blocks.bitk = k;                                  z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  blocks.writeAt = q;                                  return blocks.Flush(r);                              }                              n--; b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            len += (b & InternalInflateConstants.InflateMask[j]);                            b >>= j;                          k -= j;                            need = dbits;                          tree = dtree;                          tree_index = dtree_index;                          mode = DIST;                          goto case DIST;                        case DIST:  // i: get distance next                          j = need;                            while (k < j)                          {                              if (n != 0)                                  r = ZlibConstants.Z_OK;                              else                              {                                  blocks.bitb = b; blocks.bitk = k;                                  z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  blocks.writeAt = q;                                  return blocks.Flush(r);                              }                              n--; b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            tindex = (tree_index + (b & InternalInflateConstants.InflateMask[j])) * 3;                            b >>= tree[tindex + 1];                          k -= tree[tindex + 1];                            e = (tree[tindex]);                          if ((e & 0x10) != 0)                          {                              // distance                              bitsToGet = e & 15;                              dist = tree[tindex + 2];                              mode = DISTEXT;                              break;                          }                          if ((e & 64) == 0)                          {                              // next table                              need = e;                              tree_index = tindex / 3 + tree[tindex + 2];                              break;                          }                          mode = BADCODE; // invalid code                          z.Message = "invalid distance code";                          r = ZlibConstants.Z_DATA_ERROR;                            blocks.bitb = b; blocks.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          blocks.writeAt = q;                          return blocks.Flush(r);                          case DISTEXT:  // i: getting distance extra                          j = bitsToGet;                            while (k < j)                          {                              if (n != 0)                                  r = ZlibConstants.Z_OK;                              else                              {                                  blocks.bitb = b; blocks.bitk = k;                                  z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  blocks.writeAt = q;                                  return blocks.Flush(r);                              }                              n--; b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            dist += (b & InternalInflateConstants.InflateMask[j]);                            b >>= j;                          k -= j;                            mode = COPY;                          goto case COPY;                        case COPY:  // o: copying bytes in window' waiting for space                          f = q - dist;                          while (f < 0)                          {                              // modulo window size-"while" instead                              f += blocks.end; // of "if" handles invalid distances                          }                          while (len != 0)                          {                              if (m == 0)                              {                                  if (q == blocks.end && blocks.readAt != 0)                                  {                                      q = 0; m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;                                  }                                  if (m == 0)                                  {                                      blocks.writeAt = q; r = blocks.Flush(r);                                      q = blocks.writeAt; m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;                                        if (q == blocks.end && blocks.readAt != 0)                                      {                                          q = 0; m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;                                      }                                        if (m == 0)                                      {                                          blocks.bitb = b; blocks.bitk = k;                                          z.AvailableBytesIn = n;                                          z.TotalBytesIn += p - z.NextIn;                                          z.NextIn = p;                                          blocks.writeAt = q;                                          return blocks.Flush(r);                                      }                                  }                              }                                blocks.window[q++] = blocks.window[f++]; m--;                                if (f == blocks.end)                                  f = 0;                              len--;                          }                          mode = START;                          break;                        case LIT:  // o: got literal' waiting for output space                          if (m == 0)                          {                              if (q == blocks.end && blocks.readAt != 0)                              {                                  q = 0; m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;                              }                              if (m == 0)                              {                                  blocks.writeAt = q; r = blocks.Flush(r);                                  q = blocks.writeAt; m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;                                    if (q == blocks.end && blocks.readAt != 0)                                  {                                      q = 0; m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;                                  }                                  if (m == 0)                                  {                                      blocks.bitb = b; blocks.bitk = k;                                      z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                      blocks.writeAt = q;                                      return blocks.Flush(r);                                  }                              }                          }                          r = ZlibConstants.Z_OK;                            blocks.window[q++] = (byte)lit; m--;                            mode = START;                          break;                        case WASH:  // o: got eob' possibly more output                          if (k > 7)                          {                              // return unused byte' if any                              k -= 8;                              n++;                              p--; // can always return one                          }                            blocks.writeAt = q; r = blocks.Flush(r);                          q = blocks.writeAt; m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;                            if (blocks.readAt != blocks.writeAt)                          {                              blocks.bitb = b; blocks.bitk = k;                              z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                              blocks.writeAt = q;                              return blocks.Flush(r);                          }                          mode = END;                          goto case END;                        case END:                          r = ZlibConstants.Z_STREAM_END;                          blocks.bitb = b; blocks.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          blocks.writeAt = q;                          return blocks.Flush(r);                        case BADCODE:  // x: got error                            r = ZlibConstants.Z_DATA_ERROR;                            blocks.bitb = b; blocks.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          blocks.writeAt = q;                          return blocks.Flush(r);                        default:                          r = ZlibConstants.Z_STREAM_ERROR;                            blocks.bitb = b; blocks.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          blocks.writeAt = q;                          return blocks.Flush(r);                  }
Magic Number,Ionic.Zlib,InflateCodes,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zlib.Shared\Inflate.cs,Process,The following statement contains a magic number: switch (mode)                  {                      // waiting for "i:"=input' "o:"=output' "x:"=nothing                      case START:  // x: set up for LEN                          if (m >= 258 && n >= 10)                          {                              blocks.bitb = b; blocks.bitk = k;                              z.AvailableBytesIn = n;                              z.TotalBytesIn += p - z.NextIn;                              z.NextIn = p;                              blocks.writeAt = q;                              r = InflateFast(lbits' dbits' ltree' ltree_index' dtree' dtree_index' blocks' z);                                p = z.NextIn;                              n = z.AvailableBytesIn;                              b = blocks.bitb;                              k = blocks.bitk;                              q = blocks.writeAt; m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;                                if (r != ZlibConstants.Z_OK)                              {                                  mode = (r == ZlibConstants.Z_STREAM_END) ? WASH : BADCODE;                                  break;                              }                          }                          need = lbits;                          tree = ltree;                          tree_index = ltree_index;                            mode = LEN;                          goto case LEN;                        case LEN:  // i: get length/literal/eob next                          j = need;                            while (k < j)                          {                              if (n != 0)                                  r = ZlibConstants.Z_OK;                              else                              {                                  blocks.bitb = b; blocks.bitk = k;                                  z.AvailableBytesIn = n;                                  z.TotalBytesIn += p - z.NextIn;                                  z.NextIn = p;                                  blocks.writeAt = q;                                  return blocks.Flush(r);                              }                              n--;                              b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            tindex = (tree_index + (b & InternalInflateConstants.InflateMask[j])) * 3;                            b >>= (tree[tindex + 1]);                          k -= (tree[tindex + 1]);                            e = tree[tindex];                            if (e == 0)                          {                              // literal                              lit = tree[tindex + 2];                              mode = LIT;                              break;                          }                          if ((e & 16) != 0)                          {                              // length                              bitsToGet = e & 15;                              len = tree[tindex + 2];                              mode = LENEXT;                              break;                          }                          if ((e & 64) == 0)                          {                              // next table                              need = e;                              tree_index = tindex / 3 + tree[tindex + 2];                              break;                          }                          if ((e & 32) != 0)                          {                              // end of block                              mode = WASH;                              break;                          }                          mode = BADCODE; // invalid code                          z.Message = "invalid literal/length code";                          r = ZlibConstants.Z_DATA_ERROR;                            blocks.bitb = b; blocks.bitk = k;                          z.AvailableBytesIn = n;                          z.TotalBytesIn += p - z.NextIn;                          z.NextIn = p;                          blocks.writeAt = q;                          return blocks.Flush(r);                          case LENEXT:  // i: getting length extra (have base)                          j = bitsToGet;                            while (k < j)                          {                              if (n != 0)                                  r = ZlibConstants.Z_OK;                              else                              {                                  blocks.bitb = b; blocks.bitk = k;                                  z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  blocks.writeAt = q;                                  return blocks.Flush(r);                              }                              n--; b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            len += (b & InternalInflateConstants.InflateMask[j]);                            b >>= j;                          k -= j;                            need = dbits;                          tree = dtree;                          tree_index = dtree_index;                          mode = DIST;                          goto case DIST;                        case DIST:  // i: get distance next                          j = need;                            while (k < j)                          {                              if (n != 0)                                  r = ZlibConstants.Z_OK;                              else                              {                                  blocks.bitb = b; blocks.bitk = k;                                  z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  blocks.writeAt = q;                                  return blocks.Flush(r);                              }                              n--; b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            tindex = (tree_index + (b & InternalInflateConstants.InflateMask[j])) * 3;                            b >>= tree[tindex + 1];                          k -= tree[tindex + 1];                            e = (tree[tindex]);                          if ((e & 0x10) != 0)                          {                              // distance                              bitsToGet = e & 15;                              dist = tree[tindex + 2];                              mode = DISTEXT;                              break;                          }                          if ((e & 64) == 0)                          {                              // next table                              need = e;                              tree_index = tindex / 3 + tree[tindex + 2];                              break;                          }                          mode = BADCODE; // invalid code                          z.Message = "invalid distance code";                          r = ZlibConstants.Z_DATA_ERROR;                            blocks.bitb = b; blocks.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          blocks.writeAt = q;                          return blocks.Flush(r);                          case DISTEXT:  // i: getting distance extra                          j = bitsToGet;                            while (k < j)                          {                              if (n != 0)                                  r = ZlibConstants.Z_OK;                              else                              {                                  blocks.bitb = b; blocks.bitk = k;                                  z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  blocks.writeAt = q;                                  return blocks.Flush(r);                              }                              n--; b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            dist += (b & InternalInflateConstants.InflateMask[j]);                            b >>= j;                          k -= j;                            mode = COPY;                          goto case COPY;                        case COPY:  // o: copying bytes in window' waiting for space                          f = q - dist;                          while (f < 0)                          {                              // modulo window size-"while" instead                              f += blocks.end; // of "if" handles invalid distances                          }                          while (len != 0)                          {                              if (m == 0)                              {                                  if (q == blocks.end && blocks.readAt != 0)                                  {                                      q = 0; m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;                                  }                                  if (m == 0)                                  {                                      blocks.writeAt = q; r = blocks.Flush(r);                                      q = blocks.writeAt; m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;                                        if (q == blocks.end && blocks.readAt != 0)                                      {                                          q = 0; m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;                                      }                                        if (m == 0)                                      {                                          blocks.bitb = b; blocks.bitk = k;                                          z.AvailableBytesIn = n;                                          z.TotalBytesIn += p - z.NextIn;                                          z.NextIn = p;                                          blocks.writeAt = q;                                          return blocks.Flush(r);                                      }                                  }                              }                                blocks.window[q++] = blocks.window[f++]; m--;                                if (f == blocks.end)                                  f = 0;                              len--;                          }                          mode = START;                          break;                        case LIT:  // o: got literal' waiting for output space                          if (m == 0)                          {                              if (q == blocks.end && blocks.readAt != 0)                              {                                  q = 0; m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;                              }                              if (m == 0)                              {                                  blocks.writeAt = q; r = blocks.Flush(r);                                  q = blocks.writeAt; m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;                                    if (q == blocks.end && blocks.readAt != 0)                                  {                                      q = 0; m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;                                  }                                  if (m == 0)                                  {                                      blocks.bitb = b; blocks.bitk = k;                                      z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                      blocks.writeAt = q;                                      return blocks.Flush(r);                                  }                              }                          }                          r = ZlibConstants.Z_OK;                            blocks.window[q++] = (byte)lit; m--;                            mode = START;                          break;                        case WASH:  // o: got eob' possibly more output                          if (k > 7)                          {                              // return unused byte' if any                              k -= 8;                              n++;                              p--; // can always return one                          }                            blocks.writeAt = q; r = blocks.Flush(r);                          q = blocks.writeAt; m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;                            if (blocks.readAt != blocks.writeAt)                          {                              blocks.bitb = b; blocks.bitk = k;                              z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                              blocks.writeAt = q;                              return blocks.Flush(r);                          }                          mode = END;                          goto case END;                        case END:                          r = ZlibConstants.Z_STREAM_END;                          blocks.bitb = b; blocks.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          blocks.writeAt = q;                          return blocks.Flush(r);                        case BADCODE:  // x: got error                            r = ZlibConstants.Z_DATA_ERROR;                            blocks.bitb = b; blocks.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          blocks.writeAt = q;                          return blocks.Flush(r);                        default:                          r = ZlibConstants.Z_STREAM_ERROR;                            blocks.bitb = b; blocks.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          blocks.writeAt = q;                          return blocks.Flush(r);                  }
Magic Number,Ionic.Zlib,InflateCodes,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zlib.Shared\Inflate.cs,Process,The following statement contains a magic number: switch (mode)                  {                      // waiting for "i:"=input' "o:"=output' "x:"=nothing                      case START:  // x: set up for LEN                          if (m >= 258 && n >= 10)                          {                              blocks.bitb = b; blocks.bitk = k;                              z.AvailableBytesIn = n;                              z.TotalBytesIn += p - z.NextIn;                              z.NextIn = p;                              blocks.writeAt = q;                              r = InflateFast(lbits' dbits' ltree' ltree_index' dtree' dtree_index' blocks' z);                                p = z.NextIn;                              n = z.AvailableBytesIn;                              b = blocks.bitb;                              k = blocks.bitk;                              q = blocks.writeAt; m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;                                if (r != ZlibConstants.Z_OK)                              {                                  mode = (r == ZlibConstants.Z_STREAM_END) ? WASH : BADCODE;                                  break;                              }                          }                          need = lbits;                          tree = ltree;                          tree_index = ltree_index;                            mode = LEN;                          goto case LEN;                        case LEN:  // i: get length/literal/eob next                          j = need;                            while (k < j)                          {                              if (n != 0)                                  r = ZlibConstants.Z_OK;                              else                              {                                  blocks.bitb = b; blocks.bitk = k;                                  z.AvailableBytesIn = n;                                  z.TotalBytesIn += p - z.NextIn;                                  z.NextIn = p;                                  blocks.writeAt = q;                                  return blocks.Flush(r);                              }                              n--;                              b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            tindex = (tree_index + (b & InternalInflateConstants.InflateMask[j])) * 3;                            b >>= (tree[tindex + 1]);                          k -= (tree[tindex + 1]);                            e = tree[tindex];                            if (e == 0)                          {                              // literal                              lit = tree[tindex + 2];                              mode = LIT;                              break;                          }                          if ((e & 16) != 0)                          {                              // length                              bitsToGet = e & 15;                              len = tree[tindex + 2];                              mode = LENEXT;                              break;                          }                          if ((e & 64) == 0)                          {                              // next table                              need = e;                              tree_index = tindex / 3 + tree[tindex + 2];                              break;                          }                          if ((e & 32) != 0)                          {                              // end of block                              mode = WASH;                              break;                          }                          mode = BADCODE; // invalid code                          z.Message = "invalid literal/length code";                          r = ZlibConstants.Z_DATA_ERROR;                            blocks.bitb = b; blocks.bitk = k;                          z.AvailableBytesIn = n;                          z.TotalBytesIn += p - z.NextIn;                          z.NextIn = p;                          blocks.writeAt = q;                          return blocks.Flush(r);                          case LENEXT:  // i: getting length extra (have base)                          j = bitsToGet;                            while (k < j)                          {                              if (n != 0)                                  r = ZlibConstants.Z_OK;                              else                              {                                  blocks.bitb = b; blocks.bitk = k;                                  z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  blocks.writeAt = q;                                  return blocks.Flush(r);                              }                              n--; b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            len += (b & InternalInflateConstants.InflateMask[j]);                            b >>= j;                          k -= j;                            need = dbits;                          tree = dtree;                          tree_index = dtree_index;                          mode = DIST;                          goto case DIST;                        case DIST:  // i: get distance next                          j = need;                            while (k < j)                          {                              if (n != 0)                                  r = ZlibConstants.Z_OK;                              else                              {                                  blocks.bitb = b; blocks.bitk = k;                                  z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  blocks.writeAt = q;                                  return blocks.Flush(r);                              }                              n--; b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            tindex = (tree_index + (b & InternalInflateConstants.InflateMask[j])) * 3;                            b >>= tree[tindex + 1];                          k -= tree[tindex + 1];                            e = (tree[tindex]);                          if ((e & 0x10) != 0)                          {                              // distance                              bitsToGet = e & 15;                              dist = tree[tindex + 2];                              mode = DISTEXT;                              break;                          }                          if ((e & 64) == 0)                          {                              // next table                              need = e;                              tree_index = tindex / 3 + tree[tindex + 2];                              break;                          }                          mode = BADCODE; // invalid code                          z.Message = "invalid distance code";                          r = ZlibConstants.Z_DATA_ERROR;                            blocks.bitb = b; blocks.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          blocks.writeAt = q;                          return blocks.Flush(r);                          case DISTEXT:  // i: getting distance extra                          j = bitsToGet;                            while (k < j)                          {                              if (n != 0)                                  r = ZlibConstants.Z_OK;                              else                              {                                  blocks.bitb = b; blocks.bitk = k;                                  z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  blocks.writeAt = q;                                  return blocks.Flush(r);                              }                              n--; b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            dist += (b & InternalInflateConstants.InflateMask[j]);                            b >>= j;                          k -= j;                            mode = COPY;                          goto case COPY;                        case COPY:  // o: copying bytes in window' waiting for space                          f = q - dist;                          while (f < 0)                          {                              // modulo window size-"while" instead                              f += blocks.end; // of "if" handles invalid distances                          }                          while (len != 0)                          {                              if (m == 0)                              {                                  if (q == blocks.end && blocks.readAt != 0)                                  {                                      q = 0; m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;                                  }                                  if (m == 0)                                  {                                      blocks.writeAt = q; r = blocks.Flush(r);                                      q = blocks.writeAt; m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;                                        if (q == blocks.end && blocks.readAt != 0)                                      {                                          q = 0; m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;                                      }                                        if (m == 0)                                      {                                          blocks.bitb = b; blocks.bitk = k;                                          z.AvailableBytesIn = n;                                          z.TotalBytesIn += p - z.NextIn;                                          z.NextIn = p;                                          blocks.writeAt = q;                                          return blocks.Flush(r);                                      }                                  }                              }                                blocks.window[q++] = blocks.window[f++]; m--;                                if (f == blocks.end)                                  f = 0;                              len--;                          }                          mode = START;                          break;                        case LIT:  // o: got literal' waiting for output space                          if (m == 0)                          {                              if (q == blocks.end && blocks.readAt != 0)                              {                                  q = 0; m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;                              }                              if (m == 0)                              {                                  blocks.writeAt = q; r = blocks.Flush(r);                                  q = blocks.writeAt; m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;                                    if (q == blocks.end && blocks.readAt != 0)                                  {                                      q = 0; m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;                                  }                                  if (m == 0)                                  {                                      blocks.bitb = b; blocks.bitk = k;                                      z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                      blocks.writeAt = q;                                      return blocks.Flush(r);                                  }                              }                          }                          r = ZlibConstants.Z_OK;                            blocks.window[q++] = (byte)lit; m--;                            mode = START;                          break;                        case WASH:  // o: got eob' possibly more output                          if (k > 7)                          {                              // return unused byte' if any                              k -= 8;                              n++;                              p--; // can always return one                          }                            blocks.writeAt = q; r = blocks.Flush(r);                          q = blocks.writeAt; m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;                            if (blocks.readAt != blocks.writeAt)                          {                              blocks.bitb = b; blocks.bitk = k;                              z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                              blocks.writeAt = q;                              return blocks.Flush(r);                          }                          mode = END;                          goto case END;                        case END:                          r = ZlibConstants.Z_STREAM_END;                          blocks.bitb = b; blocks.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          blocks.writeAt = q;                          return blocks.Flush(r);                        case BADCODE:  // x: got error                            r = ZlibConstants.Z_DATA_ERROR;                            blocks.bitb = b; blocks.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          blocks.writeAt = q;                          return blocks.Flush(r);                        default:                          r = ZlibConstants.Z_STREAM_ERROR;                            blocks.bitb = b; blocks.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          blocks.writeAt = q;                          return blocks.Flush(r);                  }
Magic Number,Ionic.Zlib,InflateCodes,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zlib.Shared\Inflate.cs,Process,The following statement contains a magic number: switch (mode)                  {                      // waiting for "i:"=input' "o:"=output' "x:"=nothing                      case START:  // x: set up for LEN                          if (m >= 258 && n >= 10)                          {                              blocks.bitb = b; blocks.bitk = k;                              z.AvailableBytesIn = n;                              z.TotalBytesIn += p - z.NextIn;                              z.NextIn = p;                              blocks.writeAt = q;                              r = InflateFast(lbits' dbits' ltree' ltree_index' dtree' dtree_index' blocks' z);                                p = z.NextIn;                              n = z.AvailableBytesIn;                              b = blocks.bitb;                              k = blocks.bitk;                              q = blocks.writeAt; m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;                                if (r != ZlibConstants.Z_OK)                              {                                  mode = (r == ZlibConstants.Z_STREAM_END) ? WASH : BADCODE;                                  break;                              }                          }                          need = lbits;                          tree = ltree;                          tree_index = ltree_index;                            mode = LEN;                          goto case LEN;                        case LEN:  // i: get length/literal/eob next                          j = need;                            while (k < j)                          {                              if (n != 0)                                  r = ZlibConstants.Z_OK;                              else                              {                                  blocks.bitb = b; blocks.bitk = k;                                  z.AvailableBytesIn = n;                                  z.TotalBytesIn += p - z.NextIn;                                  z.NextIn = p;                                  blocks.writeAt = q;                                  return blocks.Flush(r);                              }                              n--;                              b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            tindex = (tree_index + (b & InternalInflateConstants.InflateMask[j])) * 3;                            b >>= (tree[tindex + 1]);                          k -= (tree[tindex + 1]);                            e = tree[tindex];                            if (e == 0)                          {                              // literal                              lit = tree[tindex + 2];                              mode = LIT;                              break;                          }                          if ((e & 16) != 0)                          {                              // length                              bitsToGet = e & 15;                              len = tree[tindex + 2];                              mode = LENEXT;                              break;                          }                          if ((e & 64) == 0)                          {                              // next table                              need = e;                              tree_index = tindex / 3 + tree[tindex + 2];                              break;                          }                          if ((e & 32) != 0)                          {                              // end of block                              mode = WASH;                              break;                          }                          mode = BADCODE; // invalid code                          z.Message = "invalid literal/length code";                          r = ZlibConstants.Z_DATA_ERROR;                            blocks.bitb = b; blocks.bitk = k;                          z.AvailableBytesIn = n;                          z.TotalBytesIn += p - z.NextIn;                          z.NextIn = p;                          blocks.writeAt = q;                          return blocks.Flush(r);                          case LENEXT:  // i: getting length extra (have base)                          j = bitsToGet;                            while (k < j)                          {                              if (n != 0)                                  r = ZlibConstants.Z_OK;                              else                              {                                  blocks.bitb = b; blocks.bitk = k;                                  z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  blocks.writeAt = q;                                  return blocks.Flush(r);                              }                              n--; b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            len += (b & InternalInflateConstants.InflateMask[j]);                            b >>= j;                          k -= j;                            need = dbits;                          tree = dtree;                          tree_index = dtree_index;                          mode = DIST;                          goto case DIST;                        case DIST:  // i: get distance next                          j = need;                            while (k < j)                          {                              if (n != 0)                                  r = ZlibConstants.Z_OK;                              else                              {                                  blocks.bitb = b; blocks.bitk = k;                                  z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  blocks.writeAt = q;                                  return blocks.Flush(r);                              }                              n--; b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            tindex = (tree_index + (b & InternalInflateConstants.InflateMask[j])) * 3;                            b >>= tree[tindex + 1];                          k -= tree[tindex + 1];                            e = (tree[tindex]);                          if ((e & 0x10) != 0)                          {                              // distance                              bitsToGet = e & 15;                              dist = tree[tindex + 2];                              mode = DISTEXT;                              break;                          }                          if ((e & 64) == 0)                          {                              // next table                              need = e;                              tree_index = tindex / 3 + tree[tindex + 2];                              break;                          }                          mode = BADCODE; // invalid code                          z.Message = "invalid distance code";                          r = ZlibConstants.Z_DATA_ERROR;                            blocks.bitb = b; blocks.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          blocks.writeAt = q;                          return blocks.Flush(r);                          case DISTEXT:  // i: getting distance extra                          j = bitsToGet;                            while (k < j)                          {                              if (n != 0)                                  r = ZlibConstants.Z_OK;                              else                              {                                  blocks.bitb = b; blocks.bitk = k;                                  z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  blocks.writeAt = q;                                  return blocks.Flush(r);                              }                              n--; b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            dist += (b & InternalInflateConstants.InflateMask[j]);                            b >>= j;                          k -= j;                            mode = COPY;                          goto case COPY;                        case COPY:  // o: copying bytes in window' waiting for space                          f = q - dist;                          while (f < 0)                          {                              // modulo window size-"while" instead                              f += blocks.end; // of "if" handles invalid distances                          }                          while (len != 0)                          {                              if (m == 0)                              {                                  if (q == blocks.end && blocks.readAt != 0)                                  {                                      q = 0; m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;                                  }                                  if (m == 0)                                  {                                      blocks.writeAt = q; r = blocks.Flush(r);                                      q = blocks.writeAt; m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;                                        if (q == blocks.end && blocks.readAt != 0)                                      {                                          q = 0; m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;                                      }                                        if (m == 0)                                      {                                          blocks.bitb = b; blocks.bitk = k;                                          z.AvailableBytesIn = n;                                          z.TotalBytesIn += p - z.NextIn;                                          z.NextIn = p;                                          blocks.writeAt = q;                                          return blocks.Flush(r);                                      }                                  }                              }                                blocks.window[q++] = blocks.window[f++]; m--;                                if (f == blocks.end)                                  f = 0;                              len--;                          }                          mode = START;                          break;                        case LIT:  // o: got literal' waiting for output space                          if (m == 0)                          {                              if (q == blocks.end && blocks.readAt != 0)                              {                                  q = 0; m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;                              }                              if (m == 0)                              {                                  blocks.writeAt = q; r = blocks.Flush(r);                                  q = blocks.writeAt; m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;                                    if (q == blocks.end && blocks.readAt != 0)                                  {                                      q = 0; m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;                                  }                                  if (m == 0)                                  {                                      blocks.bitb = b; blocks.bitk = k;                                      z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                      blocks.writeAt = q;                                      return blocks.Flush(r);                                  }                              }                          }                          r = ZlibConstants.Z_OK;                            blocks.window[q++] = (byte)lit; m--;                            mode = START;                          break;                        case WASH:  // o: got eob' possibly more output                          if (k > 7)                          {                              // return unused byte' if any                              k -= 8;                              n++;                              p--; // can always return one                          }                            blocks.writeAt = q; r = blocks.Flush(r);                          q = blocks.writeAt; m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;                            if (blocks.readAt != blocks.writeAt)                          {                              blocks.bitb = b; blocks.bitk = k;                              z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                              blocks.writeAt = q;                              return blocks.Flush(r);                          }                          mode = END;                          goto case END;                        case END:                          r = ZlibConstants.Z_STREAM_END;                          blocks.bitb = b; blocks.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          blocks.writeAt = q;                          return blocks.Flush(r);                        case BADCODE:  // x: got error                            r = ZlibConstants.Z_DATA_ERROR;                            blocks.bitb = b; blocks.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          blocks.writeAt = q;                          return blocks.Flush(r);                        default:                          r = ZlibConstants.Z_STREAM_ERROR;                            blocks.bitb = b; blocks.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          blocks.writeAt = q;                          return blocks.Flush(r);                  }
Magic Number,Ionic.Zlib,InflateCodes,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zlib.Shared\Inflate.cs,Process,The following statement contains a magic number: switch (mode)                  {                      // waiting for "i:"=input' "o:"=output' "x:"=nothing                      case START:  // x: set up for LEN                          if (m >= 258 && n >= 10)                          {                              blocks.bitb = b; blocks.bitk = k;                              z.AvailableBytesIn = n;                              z.TotalBytesIn += p - z.NextIn;                              z.NextIn = p;                              blocks.writeAt = q;                              r = InflateFast(lbits' dbits' ltree' ltree_index' dtree' dtree_index' blocks' z);                                p = z.NextIn;                              n = z.AvailableBytesIn;                              b = blocks.bitb;                              k = blocks.bitk;                              q = blocks.writeAt; m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;                                if (r != ZlibConstants.Z_OK)                              {                                  mode = (r == ZlibConstants.Z_STREAM_END) ? WASH : BADCODE;                                  break;                              }                          }                          need = lbits;                          tree = ltree;                          tree_index = ltree_index;                            mode = LEN;                          goto case LEN;                        case LEN:  // i: get length/literal/eob next                          j = need;                            while (k < j)                          {                              if (n != 0)                                  r = ZlibConstants.Z_OK;                              else                              {                                  blocks.bitb = b; blocks.bitk = k;                                  z.AvailableBytesIn = n;                                  z.TotalBytesIn += p - z.NextIn;                                  z.NextIn = p;                                  blocks.writeAt = q;                                  return blocks.Flush(r);                              }                              n--;                              b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            tindex = (tree_index + (b & InternalInflateConstants.InflateMask[j])) * 3;                            b >>= (tree[tindex + 1]);                          k -= (tree[tindex + 1]);                            e = tree[tindex];                            if (e == 0)                          {                              // literal                              lit = tree[tindex + 2];                              mode = LIT;                              break;                          }                          if ((e & 16) != 0)                          {                              // length                              bitsToGet = e & 15;                              len = tree[tindex + 2];                              mode = LENEXT;                              break;                          }                          if ((e & 64) == 0)                          {                              // next table                              need = e;                              tree_index = tindex / 3 + tree[tindex + 2];                              break;                          }                          if ((e & 32) != 0)                          {                              // end of block                              mode = WASH;                              break;                          }                          mode = BADCODE; // invalid code                          z.Message = "invalid literal/length code";                          r = ZlibConstants.Z_DATA_ERROR;                            blocks.bitb = b; blocks.bitk = k;                          z.AvailableBytesIn = n;                          z.TotalBytesIn += p - z.NextIn;                          z.NextIn = p;                          blocks.writeAt = q;                          return blocks.Flush(r);                          case LENEXT:  // i: getting length extra (have base)                          j = bitsToGet;                            while (k < j)                          {                              if (n != 0)                                  r = ZlibConstants.Z_OK;                              else                              {                                  blocks.bitb = b; blocks.bitk = k;                                  z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  blocks.writeAt = q;                                  return blocks.Flush(r);                              }                              n--; b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            len += (b & InternalInflateConstants.InflateMask[j]);                            b >>= j;                          k -= j;                            need = dbits;                          tree = dtree;                          tree_index = dtree_index;                          mode = DIST;                          goto case DIST;                        case DIST:  // i: get distance next                          j = need;                            while (k < j)                          {                              if (n != 0)                                  r = ZlibConstants.Z_OK;                              else                              {                                  blocks.bitb = b; blocks.bitk = k;                                  z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  blocks.writeAt = q;                                  return blocks.Flush(r);                              }                              n--; b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            tindex = (tree_index + (b & InternalInflateConstants.InflateMask[j])) * 3;                            b >>= tree[tindex + 1];                          k -= tree[tindex + 1];                            e = (tree[tindex]);                          if ((e & 0x10) != 0)                          {                              // distance                              bitsToGet = e & 15;                              dist = tree[tindex + 2];                              mode = DISTEXT;                              break;                          }                          if ((e & 64) == 0)                          {                              // next table                              need = e;                              tree_index = tindex / 3 + tree[tindex + 2];                              break;                          }                          mode = BADCODE; // invalid code                          z.Message = "invalid distance code";                          r = ZlibConstants.Z_DATA_ERROR;                            blocks.bitb = b; blocks.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          blocks.writeAt = q;                          return blocks.Flush(r);                          case DISTEXT:  // i: getting distance extra                          j = bitsToGet;                            while (k < j)                          {                              if (n != 0)                                  r = ZlibConstants.Z_OK;                              else                              {                                  blocks.bitb = b; blocks.bitk = k;                                  z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  blocks.writeAt = q;                                  return blocks.Flush(r);                              }                              n--; b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            dist += (b & InternalInflateConstants.InflateMask[j]);                            b >>= j;                          k -= j;                            mode = COPY;                          goto case COPY;                        case COPY:  // o: copying bytes in window' waiting for space                          f = q - dist;                          while (f < 0)                          {                              // modulo window size-"while" instead                              f += blocks.end; // of "if" handles invalid distances                          }                          while (len != 0)                          {                              if (m == 0)                              {                                  if (q == blocks.end && blocks.readAt != 0)                                  {                                      q = 0; m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;                                  }                                  if (m == 0)                                  {                                      blocks.writeAt = q; r = blocks.Flush(r);                                      q = blocks.writeAt; m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;                                        if (q == blocks.end && blocks.readAt != 0)                                      {                                          q = 0; m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;                                      }                                        if (m == 0)                                      {                                          blocks.bitb = b; blocks.bitk = k;                                          z.AvailableBytesIn = n;                                          z.TotalBytesIn += p - z.NextIn;                                          z.NextIn = p;                                          blocks.writeAt = q;                                          return blocks.Flush(r);                                      }                                  }                              }                                blocks.window[q++] = blocks.window[f++]; m--;                                if (f == blocks.end)                                  f = 0;                              len--;                          }                          mode = START;                          break;                        case LIT:  // o: got literal' waiting for output space                          if (m == 0)                          {                              if (q == blocks.end && blocks.readAt != 0)                              {                                  q = 0; m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;                              }                              if (m == 0)                              {                                  blocks.writeAt = q; r = blocks.Flush(r);                                  q = blocks.writeAt; m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;                                    if (q == blocks.end && blocks.readAt != 0)                                  {                                      q = 0; m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;                                  }                                  if (m == 0)                                  {                                      blocks.bitb = b; blocks.bitk = k;                                      z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                      blocks.writeAt = q;                                      return blocks.Flush(r);                                  }                              }                          }                          r = ZlibConstants.Z_OK;                            blocks.window[q++] = (byte)lit; m--;                            mode = START;                          break;                        case WASH:  // o: got eob' possibly more output                          if (k > 7)                          {                              // return unused byte' if any                              k -= 8;                              n++;                              p--; // can always return one                          }                            blocks.writeAt = q; r = blocks.Flush(r);                          q = blocks.writeAt; m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;                            if (blocks.readAt != blocks.writeAt)                          {                              blocks.bitb = b; blocks.bitk = k;                              z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                              blocks.writeAt = q;                              return blocks.Flush(r);                          }                          mode = END;                          goto case END;                        case END:                          r = ZlibConstants.Z_STREAM_END;                          blocks.bitb = b; blocks.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          blocks.writeAt = q;                          return blocks.Flush(r);                        case BADCODE:  // x: got error                            r = ZlibConstants.Z_DATA_ERROR;                            blocks.bitb = b; blocks.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          blocks.writeAt = q;                          return blocks.Flush(r);                        default:                          r = ZlibConstants.Z_STREAM_ERROR;                            blocks.bitb = b; blocks.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          blocks.writeAt = q;                          return blocks.Flush(r);                  }
Magic Number,Ionic.Zlib,InflateCodes,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zlib.Shared\Inflate.cs,Process,The following statement contains a magic number: switch (mode)                  {                      // waiting for "i:"=input' "o:"=output' "x:"=nothing                      case START:  // x: set up for LEN                          if (m >= 258 && n >= 10)                          {                              blocks.bitb = b; blocks.bitk = k;                              z.AvailableBytesIn = n;                              z.TotalBytesIn += p - z.NextIn;                              z.NextIn = p;                              blocks.writeAt = q;                              r = InflateFast(lbits' dbits' ltree' ltree_index' dtree' dtree_index' blocks' z);                                p = z.NextIn;                              n = z.AvailableBytesIn;                              b = blocks.bitb;                              k = blocks.bitk;                              q = blocks.writeAt; m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;                                if (r != ZlibConstants.Z_OK)                              {                                  mode = (r == ZlibConstants.Z_STREAM_END) ? WASH : BADCODE;                                  break;                              }                          }                          need = lbits;                          tree = ltree;                          tree_index = ltree_index;                            mode = LEN;                          goto case LEN;                        case LEN:  // i: get length/literal/eob next                          j = need;                            while (k < j)                          {                              if (n != 0)                                  r = ZlibConstants.Z_OK;                              else                              {                                  blocks.bitb = b; blocks.bitk = k;                                  z.AvailableBytesIn = n;                                  z.TotalBytesIn += p - z.NextIn;                                  z.NextIn = p;                                  blocks.writeAt = q;                                  return blocks.Flush(r);                              }                              n--;                              b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            tindex = (tree_index + (b & InternalInflateConstants.InflateMask[j])) * 3;                            b >>= (tree[tindex + 1]);                          k -= (tree[tindex + 1]);                            e = tree[tindex];                            if (e == 0)                          {                              // literal                              lit = tree[tindex + 2];                              mode = LIT;                              break;                          }                          if ((e & 16) != 0)                          {                              // length                              bitsToGet = e & 15;                              len = tree[tindex + 2];                              mode = LENEXT;                              break;                          }                          if ((e & 64) == 0)                          {                              // next table                              need = e;                              tree_index = tindex / 3 + tree[tindex + 2];                              break;                          }                          if ((e & 32) != 0)                          {                              // end of block                              mode = WASH;                              break;                          }                          mode = BADCODE; // invalid code                          z.Message = "invalid literal/length code";                          r = ZlibConstants.Z_DATA_ERROR;                            blocks.bitb = b; blocks.bitk = k;                          z.AvailableBytesIn = n;                          z.TotalBytesIn += p - z.NextIn;                          z.NextIn = p;                          blocks.writeAt = q;                          return blocks.Flush(r);                          case LENEXT:  // i: getting length extra (have base)                          j = bitsToGet;                            while (k < j)                          {                              if (n != 0)                                  r = ZlibConstants.Z_OK;                              else                              {                                  blocks.bitb = b; blocks.bitk = k;                                  z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  blocks.writeAt = q;                                  return blocks.Flush(r);                              }                              n--; b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            len += (b & InternalInflateConstants.InflateMask[j]);                            b >>= j;                          k -= j;                            need = dbits;                          tree = dtree;                          tree_index = dtree_index;                          mode = DIST;                          goto case DIST;                        case DIST:  // i: get distance next                          j = need;                            while (k < j)                          {                              if (n != 0)                                  r = ZlibConstants.Z_OK;                              else                              {                                  blocks.bitb = b; blocks.bitk = k;                                  z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  blocks.writeAt = q;                                  return blocks.Flush(r);                              }                              n--; b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            tindex = (tree_index + (b & InternalInflateConstants.InflateMask[j])) * 3;                            b >>= tree[tindex + 1];                          k -= tree[tindex + 1];                            e = (tree[tindex]);                          if ((e & 0x10) != 0)                          {                              // distance                              bitsToGet = e & 15;                              dist = tree[tindex + 2];                              mode = DISTEXT;                              break;                          }                          if ((e & 64) == 0)                          {                              // next table                              need = e;                              tree_index = tindex / 3 + tree[tindex + 2];                              break;                          }                          mode = BADCODE; // invalid code                          z.Message = "invalid distance code";                          r = ZlibConstants.Z_DATA_ERROR;                            blocks.bitb = b; blocks.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          blocks.writeAt = q;                          return blocks.Flush(r);                          case DISTEXT:  // i: getting distance extra                          j = bitsToGet;                            while (k < j)                          {                              if (n != 0)                                  r = ZlibConstants.Z_OK;                              else                              {                                  blocks.bitb = b; blocks.bitk = k;                                  z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  blocks.writeAt = q;                                  return blocks.Flush(r);                              }                              n--; b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            dist += (b & InternalInflateConstants.InflateMask[j]);                            b >>= j;                          k -= j;                            mode = COPY;                          goto case COPY;                        case COPY:  // o: copying bytes in window' waiting for space                          f = q - dist;                          while (f < 0)                          {                              // modulo window size-"while" instead                              f += blocks.end; // of "if" handles invalid distances                          }                          while (len != 0)                          {                              if (m == 0)                              {                                  if (q == blocks.end && blocks.readAt != 0)                                  {                                      q = 0; m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;                                  }                                  if (m == 0)                                  {                                      blocks.writeAt = q; r = blocks.Flush(r);                                      q = blocks.writeAt; m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;                                        if (q == blocks.end && blocks.readAt != 0)                                      {                                          q = 0; m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;                                      }                                        if (m == 0)                                      {                                          blocks.bitb = b; blocks.bitk = k;                                          z.AvailableBytesIn = n;                                          z.TotalBytesIn += p - z.NextIn;                                          z.NextIn = p;                                          blocks.writeAt = q;                                          return blocks.Flush(r);                                      }                                  }                              }                                blocks.window[q++] = blocks.window[f++]; m--;                                if (f == blocks.end)                                  f = 0;                              len--;                          }                          mode = START;                          break;                        case LIT:  // o: got literal' waiting for output space                          if (m == 0)                          {                              if (q == blocks.end && blocks.readAt != 0)                              {                                  q = 0; m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;                              }                              if (m == 0)                              {                                  blocks.writeAt = q; r = blocks.Flush(r);                                  q = blocks.writeAt; m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;                                    if (q == blocks.end && blocks.readAt != 0)                                  {                                      q = 0; m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;                                  }                                  if (m == 0)                                  {                                      blocks.bitb = b; blocks.bitk = k;                                      z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                      blocks.writeAt = q;                                      return blocks.Flush(r);                                  }                              }                          }                          r = ZlibConstants.Z_OK;                            blocks.window[q++] = (byte)lit; m--;                            mode = START;                          break;                        case WASH:  // o: got eob' possibly more output                          if (k > 7)                          {                              // return unused byte' if any                              k -= 8;                              n++;                              p--; // can always return one                          }                            blocks.writeAt = q; r = blocks.Flush(r);                          q = blocks.writeAt; m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;                            if (blocks.readAt != blocks.writeAt)                          {                              blocks.bitb = b; blocks.bitk = k;                              z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                              blocks.writeAt = q;                              return blocks.Flush(r);                          }                          mode = END;                          goto case END;                        case END:                          r = ZlibConstants.Z_STREAM_END;                          blocks.bitb = b; blocks.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          blocks.writeAt = q;                          return blocks.Flush(r);                        case BADCODE:  // x: got error                            r = ZlibConstants.Z_DATA_ERROR;                            blocks.bitb = b; blocks.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          blocks.writeAt = q;                          return blocks.Flush(r);                        default:                          r = ZlibConstants.Z_STREAM_ERROR;                            blocks.bitb = b; blocks.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          blocks.writeAt = q;                          return blocks.Flush(r);                  }
Magic Number,Ionic.Zlib,InflateCodes,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zlib.Shared\Inflate.cs,Process,The following statement contains a magic number: switch (mode)                  {                      // waiting for "i:"=input' "o:"=output' "x:"=nothing                      case START:  // x: set up for LEN                          if (m >= 258 && n >= 10)                          {                              blocks.bitb = b; blocks.bitk = k;                              z.AvailableBytesIn = n;                              z.TotalBytesIn += p - z.NextIn;                              z.NextIn = p;                              blocks.writeAt = q;                              r = InflateFast(lbits' dbits' ltree' ltree_index' dtree' dtree_index' blocks' z);                                p = z.NextIn;                              n = z.AvailableBytesIn;                              b = blocks.bitb;                              k = blocks.bitk;                              q = blocks.writeAt; m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;                                if (r != ZlibConstants.Z_OK)                              {                                  mode = (r == ZlibConstants.Z_STREAM_END) ? WASH : BADCODE;                                  break;                              }                          }                          need = lbits;                          tree = ltree;                          tree_index = ltree_index;                            mode = LEN;                          goto case LEN;                        case LEN:  // i: get length/literal/eob next                          j = need;                            while (k < j)                          {                              if (n != 0)                                  r = ZlibConstants.Z_OK;                              else                              {                                  blocks.bitb = b; blocks.bitk = k;                                  z.AvailableBytesIn = n;                                  z.TotalBytesIn += p - z.NextIn;                                  z.NextIn = p;                                  blocks.writeAt = q;                                  return blocks.Flush(r);                              }                              n--;                              b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            tindex = (tree_index + (b & InternalInflateConstants.InflateMask[j])) * 3;                            b >>= (tree[tindex + 1]);                          k -= (tree[tindex + 1]);                            e = tree[tindex];                            if (e == 0)                          {                              // literal                              lit = tree[tindex + 2];                              mode = LIT;                              break;                          }                          if ((e & 16) != 0)                          {                              // length                              bitsToGet = e & 15;                              len = tree[tindex + 2];                              mode = LENEXT;                              break;                          }                          if ((e & 64) == 0)                          {                              // next table                              need = e;                              tree_index = tindex / 3 + tree[tindex + 2];                              break;                          }                          if ((e & 32) != 0)                          {                              // end of block                              mode = WASH;                              break;                          }                          mode = BADCODE; // invalid code                          z.Message = "invalid literal/length code";                          r = ZlibConstants.Z_DATA_ERROR;                            blocks.bitb = b; blocks.bitk = k;                          z.AvailableBytesIn = n;                          z.TotalBytesIn += p - z.NextIn;                          z.NextIn = p;                          blocks.writeAt = q;                          return blocks.Flush(r);                          case LENEXT:  // i: getting length extra (have base)                          j = bitsToGet;                            while (k < j)                          {                              if (n != 0)                                  r = ZlibConstants.Z_OK;                              else                              {                                  blocks.bitb = b; blocks.bitk = k;                                  z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  blocks.writeAt = q;                                  return blocks.Flush(r);                              }                              n--; b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            len += (b & InternalInflateConstants.InflateMask[j]);                            b >>= j;                          k -= j;                            need = dbits;                          tree = dtree;                          tree_index = dtree_index;                          mode = DIST;                          goto case DIST;                        case DIST:  // i: get distance next                          j = need;                            while (k < j)                          {                              if (n != 0)                                  r = ZlibConstants.Z_OK;                              else                              {                                  blocks.bitb = b; blocks.bitk = k;                                  z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  blocks.writeAt = q;                                  return blocks.Flush(r);                              }                              n--; b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            tindex = (tree_index + (b & InternalInflateConstants.InflateMask[j])) * 3;                            b >>= tree[tindex + 1];                          k -= tree[tindex + 1];                            e = (tree[tindex]);                          if ((e & 0x10) != 0)                          {                              // distance                              bitsToGet = e & 15;                              dist = tree[tindex + 2];                              mode = DISTEXT;                              break;                          }                          if ((e & 64) == 0)                          {                              // next table                              need = e;                              tree_index = tindex / 3 + tree[tindex + 2];                              break;                          }                          mode = BADCODE; // invalid code                          z.Message = "invalid distance code";                          r = ZlibConstants.Z_DATA_ERROR;                            blocks.bitb = b; blocks.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          blocks.writeAt = q;                          return blocks.Flush(r);                          case DISTEXT:  // i: getting distance extra                          j = bitsToGet;                            while (k < j)                          {                              if (n != 0)                                  r = ZlibConstants.Z_OK;                              else                              {                                  blocks.bitb = b; blocks.bitk = k;                                  z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  blocks.writeAt = q;                                  return blocks.Flush(r);                              }                              n--; b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            dist += (b & InternalInflateConstants.InflateMask[j]);                            b >>= j;                          k -= j;                            mode = COPY;                          goto case COPY;                        case COPY:  // o: copying bytes in window' waiting for space                          f = q - dist;                          while (f < 0)                          {                              // modulo window size-"while" instead                              f += blocks.end; // of "if" handles invalid distances                          }                          while (len != 0)                          {                              if (m == 0)                              {                                  if (q == blocks.end && blocks.readAt != 0)                                  {                                      q = 0; m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;                                  }                                  if (m == 0)                                  {                                      blocks.writeAt = q; r = blocks.Flush(r);                                      q = blocks.writeAt; m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;                                        if (q == blocks.end && blocks.readAt != 0)                                      {                                          q = 0; m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;                                      }                                        if (m == 0)                                      {                                          blocks.bitb = b; blocks.bitk = k;                                          z.AvailableBytesIn = n;                                          z.TotalBytesIn += p - z.NextIn;                                          z.NextIn = p;                                          blocks.writeAt = q;                                          return blocks.Flush(r);                                      }                                  }                              }                                blocks.window[q++] = blocks.window[f++]; m--;                                if (f == blocks.end)                                  f = 0;                              len--;                          }                          mode = START;                          break;                        case LIT:  // o: got literal' waiting for output space                          if (m == 0)                          {                              if (q == blocks.end && blocks.readAt != 0)                              {                                  q = 0; m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;                              }                              if (m == 0)                              {                                  blocks.writeAt = q; r = blocks.Flush(r);                                  q = blocks.writeAt; m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;                                    if (q == blocks.end && blocks.readAt != 0)                                  {                                      q = 0; m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;                                  }                                  if (m == 0)                                  {                                      blocks.bitb = b; blocks.bitk = k;                                      z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                      blocks.writeAt = q;                                      return blocks.Flush(r);                                  }                              }                          }                          r = ZlibConstants.Z_OK;                            blocks.window[q++] = (byte)lit; m--;                            mode = START;                          break;                        case WASH:  // o: got eob' possibly more output                          if (k > 7)                          {                              // return unused byte' if any                              k -= 8;                              n++;                              p--; // can always return one                          }                            blocks.writeAt = q; r = blocks.Flush(r);                          q = blocks.writeAt; m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;                            if (blocks.readAt != blocks.writeAt)                          {                              blocks.bitb = b; blocks.bitk = k;                              z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                              blocks.writeAt = q;                              return blocks.Flush(r);                          }                          mode = END;                          goto case END;                        case END:                          r = ZlibConstants.Z_STREAM_END;                          blocks.bitb = b; blocks.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          blocks.writeAt = q;                          return blocks.Flush(r);                        case BADCODE:  // x: got error                            r = ZlibConstants.Z_DATA_ERROR;                            blocks.bitb = b; blocks.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          blocks.writeAt = q;                          return blocks.Flush(r);                        default:                          r = ZlibConstants.Z_STREAM_ERROR;                            blocks.bitb = b; blocks.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          blocks.writeAt = q;                          return blocks.Flush(r);                  }
Magic Number,Ionic.Zlib,InflateCodes,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zlib.Shared\Inflate.cs,Process,The following statement contains a magic number: switch (mode)                  {                      // waiting for "i:"=input' "o:"=output' "x:"=nothing                      case START:  // x: set up for LEN                          if (m >= 258 && n >= 10)                          {                              blocks.bitb = b; blocks.bitk = k;                              z.AvailableBytesIn = n;                              z.TotalBytesIn += p - z.NextIn;                              z.NextIn = p;                              blocks.writeAt = q;                              r = InflateFast(lbits' dbits' ltree' ltree_index' dtree' dtree_index' blocks' z);                                p = z.NextIn;                              n = z.AvailableBytesIn;                              b = blocks.bitb;                              k = blocks.bitk;                              q = blocks.writeAt; m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;                                if (r != ZlibConstants.Z_OK)                              {                                  mode = (r == ZlibConstants.Z_STREAM_END) ? WASH : BADCODE;                                  break;                              }                          }                          need = lbits;                          tree = ltree;                          tree_index = ltree_index;                            mode = LEN;                          goto case LEN;                        case LEN:  // i: get length/literal/eob next                          j = need;                            while (k < j)                          {                              if (n != 0)                                  r = ZlibConstants.Z_OK;                              else                              {                                  blocks.bitb = b; blocks.bitk = k;                                  z.AvailableBytesIn = n;                                  z.TotalBytesIn += p - z.NextIn;                                  z.NextIn = p;                                  blocks.writeAt = q;                                  return blocks.Flush(r);                              }                              n--;                              b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            tindex = (tree_index + (b & InternalInflateConstants.InflateMask[j])) * 3;                            b >>= (tree[tindex + 1]);                          k -= (tree[tindex + 1]);                            e = tree[tindex];                            if (e == 0)                          {                              // literal                              lit = tree[tindex + 2];                              mode = LIT;                              break;                          }                          if ((e & 16) != 0)                          {                              // length                              bitsToGet = e & 15;                              len = tree[tindex + 2];                              mode = LENEXT;                              break;                          }                          if ((e & 64) == 0)                          {                              // next table                              need = e;                              tree_index = tindex / 3 + tree[tindex + 2];                              break;                          }                          if ((e & 32) != 0)                          {                              // end of block                              mode = WASH;                              break;                          }                          mode = BADCODE; // invalid code                          z.Message = "invalid literal/length code";                          r = ZlibConstants.Z_DATA_ERROR;                            blocks.bitb = b; blocks.bitk = k;                          z.AvailableBytesIn = n;                          z.TotalBytesIn += p - z.NextIn;                          z.NextIn = p;                          blocks.writeAt = q;                          return blocks.Flush(r);                          case LENEXT:  // i: getting length extra (have base)                          j = bitsToGet;                            while (k < j)                          {                              if (n != 0)                                  r = ZlibConstants.Z_OK;                              else                              {                                  blocks.bitb = b; blocks.bitk = k;                                  z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  blocks.writeAt = q;                                  return blocks.Flush(r);                              }                              n--; b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            len += (b & InternalInflateConstants.InflateMask[j]);                            b >>= j;                          k -= j;                            need = dbits;                          tree = dtree;                          tree_index = dtree_index;                          mode = DIST;                          goto case DIST;                        case DIST:  // i: get distance next                          j = need;                            while (k < j)                          {                              if (n != 0)                                  r = ZlibConstants.Z_OK;                              else                              {                                  blocks.bitb = b; blocks.bitk = k;                                  z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  blocks.writeAt = q;                                  return blocks.Flush(r);                              }                              n--; b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            tindex = (tree_index + (b & InternalInflateConstants.InflateMask[j])) * 3;                            b >>= tree[tindex + 1];                          k -= tree[tindex + 1];                            e = (tree[tindex]);                          if ((e & 0x10) != 0)                          {                              // distance                              bitsToGet = e & 15;                              dist = tree[tindex + 2];                              mode = DISTEXT;                              break;                          }                          if ((e & 64) == 0)                          {                              // next table                              need = e;                              tree_index = tindex / 3 + tree[tindex + 2];                              break;                          }                          mode = BADCODE; // invalid code                          z.Message = "invalid distance code";                          r = ZlibConstants.Z_DATA_ERROR;                            blocks.bitb = b; blocks.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          blocks.writeAt = q;                          return blocks.Flush(r);                          case DISTEXT:  // i: getting distance extra                          j = bitsToGet;                            while (k < j)                          {                              if (n != 0)                                  r = ZlibConstants.Z_OK;                              else                              {                                  blocks.bitb = b; blocks.bitk = k;                                  z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  blocks.writeAt = q;                                  return blocks.Flush(r);                              }                              n--; b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            dist += (b & InternalInflateConstants.InflateMask[j]);                            b >>= j;                          k -= j;                            mode = COPY;                          goto case COPY;                        case COPY:  // o: copying bytes in window' waiting for space                          f = q - dist;                          while (f < 0)                          {                              // modulo window size-"while" instead                              f += blocks.end; // of "if" handles invalid distances                          }                          while (len != 0)                          {                              if (m == 0)                              {                                  if (q == blocks.end && blocks.readAt != 0)                                  {                                      q = 0; m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;                                  }                                  if (m == 0)                                  {                                      blocks.writeAt = q; r = blocks.Flush(r);                                      q = blocks.writeAt; m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;                                        if (q == blocks.end && blocks.readAt != 0)                                      {                                          q = 0; m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;                                      }                                        if (m == 0)                                      {                                          blocks.bitb = b; blocks.bitk = k;                                          z.AvailableBytesIn = n;                                          z.TotalBytesIn += p - z.NextIn;                                          z.NextIn = p;                                          blocks.writeAt = q;                                          return blocks.Flush(r);                                      }                                  }                              }                                blocks.window[q++] = blocks.window[f++]; m--;                                if (f == blocks.end)                                  f = 0;                              len--;                          }                          mode = START;                          break;                        case LIT:  // o: got literal' waiting for output space                          if (m == 0)                          {                              if (q == blocks.end && blocks.readAt != 0)                              {                                  q = 0; m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;                              }                              if (m == 0)                              {                                  blocks.writeAt = q; r = blocks.Flush(r);                                  q = blocks.writeAt; m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;                                    if (q == blocks.end && blocks.readAt != 0)                                  {                                      q = 0; m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;                                  }                                  if (m == 0)                                  {                                      blocks.bitb = b; blocks.bitk = k;                                      z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                      blocks.writeAt = q;                                      return blocks.Flush(r);                                  }                              }                          }                          r = ZlibConstants.Z_OK;                            blocks.window[q++] = (byte)lit; m--;                            mode = START;                          break;                        case WASH:  // o: got eob' possibly more output                          if (k > 7)                          {                              // return unused byte' if any                              k -= 8;                              n++;                              p--; // can always return one                          }                            blocks.writeAt = q; r = blocks.Flush(r);                          q = blocks.writeAt; m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;                            if (blocks.readAt != blocks.writeAt)                          {                              blocks.bitb = b; blocks.bitk = k;                              z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                              blocks.writeAt = q;                              return blocks.Flush(r);                          }                          mode = END;                          goto case END;                        case END:                          r = ZlibConstants.Z_STREAM_END;                          blocks.bitb = b; blocks.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          blocks.writeAt = q;                          return blocks.Flush(r);                        case BADCODE:  // x: got error                            r = ZlibConstants.Z_DATA_ERROR;                            blocks.bitb = b; blocks.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          blocks.writeAt = q;                          return blocks.Flush(r);                        default:                          r = ZlibConstants.Z_STREAM_ERROR;                            blocks.bitb = b; blocks.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          blocks.writeAt = q;                          return blocks.Flush(r);                  }
Magic Number,Ionic.Zlib,InflateCodes,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zlib.Shared\Inflate.cs,Process,The following statement contains a magic number: switch (mode)                  {                      // waiting for "i:"=input' "o:"=output' "x:"=nothing                      case START:  // x: set up for LEN                          if (m >= 258 && n >= 10)                          {                              blocks.bitb = b; blocks.bitk = k;                              z.AvailableBytesIn = n;                              z.TotalBytesIn += p - z.NextIn;                              z.NextIn = p;                              blocks.writeAt = q;                              r = InflateFast(lbits' dbits' ltree' ltree_index' dtree' dtree_index' blocks' z);                                p = z.NextIn;                              n = z.AvailableBytesIn;                              b = blocks.bitb;                              k = blocks.bitk;                              q = blocks.writeAt; m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;                                if (r != ZlibConstants.Z_OK)                              {                                  mode = (r == ZlibConstants.Z_STREAM_END) ? WASH : BADCODE;                                  break;                              }                          }                          need = lbits;                          tree = ltree;                          tree_index = ltree_index;                            mode = LEN;                          goto case LEN;                        case LEN:  // i: get length/literal/eob next                          j = need;                            while (k < j)                          {                              if (n != 0)                                  r = ZlibConstants.Z_OK;                              else                              {                                  blocks.bitb = b; blocks.bitk = k;                                  z.AvailableBytesIn = n;                                  z.TotalBytesIn += p - z.NextIn;                                  z.NextIn = p;                                  blocks.writeAt = q;                                  return blocks.Flush(r);                              }                              n--;                              b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            tindex = (tree_index + (b & InternalInflateConstants.InflateMask[j])) * 3;                            b >>= (tree[tindex + 1]);                          k -= (tree[tindex + 1]);                            e = tree[tindex];                            if (e == 0)                          {                              // literal                              lit = tree[tindex + 2];                              mode = LIT;                              break;                          }                          if ((e & 16) != 0)                          {                              // length                              bitsToGet = e & 15;                              len = tree[tindex + 2];                              mode = LENEXT;                              break;                          }                          if ((e & 64) == 0)                          {                              // next table                              need = e;                              tree_index = tindex / 3 + tree[tindex + 2];                              break;                          }                          if ((e & 32) != 0)                          {                              // end of block                              mode = WASH;                              break;                          }                          mode = BADCODE; // invalid code                          z.Message = "invalid literal/length code";                          r = ZlibConstants.Z_DATA_ERROR;                            blocks.bitb = b; blocks.bitk = k;                          z.AvailableBytesIn = n;                          z.TotalBytesIn += p - z.NextIn;                          z.NextIn = p;                          blocks.writeAt = q;                          return blocks.Flush(r);                          case LENEXT:  // i: getting length extra (have base)                          j = bitsToGet;                            while (k < j)                          {                              if (n != 0)                                  r = ZlibConstants.Z_OK;                              else                              {                                  blocks.bitb = b; blocks.bitk = k;                                  z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  blocks.writeAt = q;                                  return blocks.Flush(r);                              }                              n--; b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            len += (b & InternalInflateConstants.InflateMask[j]);                            b >>= j;                          k -= j;                            need = dbits;                          tree = dtree;                          tree_index = dtree_index;                          mode = DIST;                          goto case DIST;                        case DIST:  // i: get distance next                          j = need;                            while (k < j)                          {                              if (n != 0)                                  r = ZlibConstants.Z_OK;                              else                              {                                  blocks.bitb = b; blocks.bitk = k;                                  z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  blocks.writeAt = q;                                  return blocks.Flush(r);                              }                              n--; b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            tindex = (tree_index + (b & InternalInflateConstants.InflateMask[j])) * 3;                            b >>= tree[tindex + 1];                          k -= tree[tindex + 1];                            e = (tree[tindex]);                          if ((e & 0x10) != 0)                          {                              // distance                              bitsToGet = e & 15;                              dist = tree[tindex + 2];                              mode = DISTEXT;                              break;                          }                          if ((e & 64) == 0)                          {                              // next table                              need = e;                              tree_index = tindex / 3 + tree[tindex + 2];                              break;                          }                          mode = BADCODE; // invalid code                          z.Message = "invalid distance code";                          r = ZlibConstants.Z_DATA_ERROR;                            blocks.bitb = b; blocks.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          blocks.writeAt = q;                          return blocks.Flush(r);                          case DISTEXT:  // i: getting distance extra                          j = bitsToGet;                            while (k < j)                          {                              if (n != 0)                                  r = ZlibConstants.Z_OK;                              else                              {                                  blocks.bitb = b; blocks.bitk = k;                                  z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  blocks.writeAt = q;                                  return blocks.Flush(r);                              }                              n--; b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            dist += (b & InternalInflateConstants.InflateMask[j]);                            b >>= j;                          k -= j;                            mode = COPY;                          goto case COPY;                        case COPY:  // o: copying bytes in window' waiting for space                          f = q - dist;                          while (f < 0)                          {                              // modulo window size-"while" instead                              f += blocks.end; // of "if" handles invalid distances                          }                          while (len != 0)                          {                              if (m == 0)                              {                                  if (q == blocks.end && blocks.readAt != 0)                                  {                                      q = 0; m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;                                  }                                  if (m == 0)                                  {                                      blocks.writeAt = q; r = blocks.Flush(r);                                      q = blocks.writeAt; m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;                                        if (q == blocks.end && blocks.readAt != 0)                                      {                                          q = 0; m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;                                      }                                        if (m == 0)                                      {                                          blocks.bitb = b; blocks.bitk = k;                                          z.AvailableBytesIn = n;                                          z.TotalBytesIn += p - z.NextIn;                                          z.NextIn = p;                                          blocks.writeAt = q;                                          return blocks.Flush(r);                                      }                                  }                              }                                blocks.window[q++] = blocks.window[f++]; m--;                                if (f == blocks.end)                                  f = 0;                              len--;                          }                          mode = START;                          break;                        case LIT:  // o: got literal' waiting for output space                          if (m == 0)                          {                              if (q == blocks.end && blocks.readAt != 0)                              {                                  q = 0; m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;                              }                              if (m == 0)                              {                                  blocks.writeAt = q; r = blocks.Flush(r);                                  q = blocks.writeAt; m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;                                    if (q == blocks.end && blocks.readAt != 0)                                  {                                      q = 0; m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;                                  }                                  if (m == 0)                                  {                                      blocks.bitb = b; blocks.bitk = k;                                      z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                      blocks.writeAt = q;                                      return blocks.Flush(r);                                  }                              }                          }                          r = ZlibConstants.Z_OK;                            blocks.window[q++] = (byte)lit; m--;                            mode = START;                          break;                        case WASH:  // o: got eob' possibly more output                          if (k > 7)                          {                              // return unused byte' if any                              k -= 8;                              n++;                              p--; // can always return one                          }                            blocks.writeAt = q; r = blocks.Flush(r);                          q = blocks.writeAt; m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;                            if (blocks.readAt != blocks.writeAt)                          {                              blocks.bitb = b; blocks.bitk = k;                              z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                              blocks.writeAt = q;                              return blocks.Flush(r);                          }                          mode = END;                          goto case END;                        case END:                          r = ZlibConstants.Z_STREAM_END;                          blocks.bitb = b; blocks.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          blocks.writeAt = q;                          return blocks.Flush(r);                        case BADCODE:  // x: got error                            r = ZlibConstants.Z_DATA_ERROR;                            blocks.bitb = b; blocks.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          blocks.writeAt = q;                          return blocks.Flush(r);                        default:                          r = ZlibConstants.Z_STREAM_ERROR;                            blocks.bitb = b; blocks.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          blocks.writeAt = q;                          return blocks.Flush(r);                  }
Magic Number,Ionic.Zlib,InflateCodes,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zlib.Shared\Inflate.cs,Process,The following statement contains a magic number: switch (mode)                  {                      // waiting for "i:"=input' "o:"=output' "x:"=nothing                      case START:  // x: set up for LEN                          if (m >= 258 && n >= 10)                          {                              blocks.bitb = b; blocks.bitk = k;                              z.AvailableBytesIn = n;                              z.TotalBytesIn += p - z.NextIn;                              z.NextIn = p;                              blocks.writeAt = q;                              r = InflateFast(lbits' dbits' ltree' ltree_index' dtree' dtree_index' blocks' z);                                p = z.NextIn;                              n = z.AvailableBytesIn;                              b = blocks.bitb;                              k = blocks.bitk;                              q = blocks.writeAt; m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;                                if (r != ZlibConstants.Z_OK)                              {                                  mode = (r == ZlibConstants.Z_STREAM_END) ? WASH : BADCODE;                                  break;                              }                          }                          need = lbits;                          tree = ltree;                          tree_index = ltree_index;                            mode = LEN;                          goto case LEN;                        case LEN:  // i: get length/literal/eob next                          j = need;                            while (k < j)                          {                              if (n != 0)                                  r = ZlibConstants.Z_OK;                              else                              {                                  blocks.bitb = b; blocks.bitk = k;                                  z.AvailableBytesIn = n;                                  z.TotalBytesIn += p - z.NextIn;                                  z.NextIn = p;                                  blocks.writeAt = q;                                  return blocks.Flush(r);                              }                              n--;                              b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            tindex = (tree_index + (b & InternalInflateConstants.InflateMask[j])) * 3;                            b >>= (tree[tindex + 1]);                          k -= (tree[tindex + 1]);                            e = tree[tindex];                            if (e == 0)                          {                              // literal                              lit = tree[tindex + 2];                              mode = LIT;                              break;                          }                          if ((e & 16) != 0)                          {                              // length                              bitsToGet = e & 15;                              len = tree[tindex + 2];                              mode = LENEXT;                              break;                          }                          if ((e & 64) == 0)                          {                              // next table                              need = e;                              tree_index = tindex / 3 + tree[tindex + 2];                              break;                          }                          if ((e & 32) != 0)                          {                              // end of block                              mode = WASH;                              break;                          }                          mode = BADCODE; // invalid code                          z.Message = "invalid literal/length code";                          r = ZlibConstants.Z_DATA_ERROR;                            blocks.bitb = b; blocks.bitk = k;                          z.AvailableBytesIn = n;                          z.TotalBytesIn += p - z.NextIn;                          z.NextIn = p;                          blocks.writeAt = q;                          return blocks.Flush(r);                          case LENEXT:  // i: getting length extra (have base)                          j = bitsToGet;                            while (k < j)                          {                              if (n != 0)                                  r = ZlibConstants.Z_OK;                              else                              {                                  blocks.bitb = b; blocks.bitk = k;                                  z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  blocks.writeAt = q;                                  return blocks.Flush(r);                              }                              n--; b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            len += (b & InternalInflateConstants.InflateMask[j]);                            b >>= j;                          k -= j;                            need = dbits;                          tree = dtree;                          tree_index = dtree_index;                          mode = DIST;                          goto case DIST;                        case DIST:  // i: get distance next                          j = need;                            while (k < j)                          {                              if (n != 0)                                  r = ZlibConstants.Z_OK;                              else                              {                                  blocks.bitb = b; blocks.bitk = k;                                  z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  blocks.writeAt = q;                                  return blocks.Flush(r);                              }                              n--; b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            tindex = (tree_index + (b & InternalInflateConstants.InflateMask[j])) * 3;                            b >>= tree[tindex + 1];                          k -= tree[tindex + 1];                            e = (tree[tindex]);                          if ((e & 0x10) != 0)                          {                              // distance                              bitsToGet = e & 15;                              dist = tree[tindex + 2];                              mode = DISTEXT;                              break;                          }                          if ((e & 64) == 0)                          {                              // next table                              need = e;                              tree_index = tindex / 3 + tree[tindex + 2];                              break;                          }                          mode = BADCODE; // invalid code                          z.Message = "invalid distance code";                          r = ZlibConstants.Z_DATA_ERROR;                            blocks.bitb = b; blocks.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          blocks.writeAt = q;                          return blocks.Flush(r);                          case DISTEXT:  // i: getting distance extra                          j = bitsToGet;                            while (k < j)                          {                              if (n != 0)                                  r = ZlibConstants.Z_OK;                              else                              {                                  blocks.bitb = b; blocks.bitk = k;                                  z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  blocks.writeAt = q;                                  return blocks.Flush(r);                              }                              n--; b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            dist += (b & InternalInflateConstants.InflateMask[j]);                            b >>= j;                          k -= j;                            mode = COPY;                          goto case COPY;                        case COPY:  // o: copying bytes in window' waiting for space                          f = q - dist;                          while (f < 0)                          {                              // modulo window size-"while" instead                              f += blocks.end; // of "if" handles invalid distances                          }                          while (len != 0)                          {                              if (m == 0)                              {                                  if (q == blocks.end && blocks.readAt != 0)                                  {                                      q = 0; m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;                                  }                                  if (m == 0)                                  {                                      blocks.writeAt = q; r = blocks.Flush(r);                                      q = blocks.writeAt; m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;                                        if (q == blocks.end && blocks.readAt != 0)                                      {                                          q = 0; m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;                                      }                                        if (m == 0)                                      {                                          blocks.bitb = b; blocks.bitk = k;                                          z.AvailableBytesIn = n;                                          z.TotalBytesIn += p - z.NextIn;                                          z.NextIn = p;                                          blocks.writeAt = q;                                          return blocks.Flush(r);                                      }                                  }                              }                                blocks.window[q++] = blocks.window[f++]; m--;                                if (f == blocks.end)                                  f = 0;                              len--;                          }                          mode = START;                          break;                        case LIT:  // o: got literal' waiting for output space                          if (m == 0)                          {                              if (q == blocks.end && blocks.readAt != 0)                              {                                  q = 0; m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;                              }                              if (m == 0)                              {                                  blocks.writeAt = q; r = blocks.Flush(r);                                  q = blocks.writeAt; m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;                                    if (q == blocks.end && blocks.readAt != 0)                                  {                                      q = 0; m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;                                  }                                  if (m == 0)                                  {                                      blocks.bitb = b; blocks.bitk = k;                                      z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                      blocks.writeAt = q;                                      return blocks.Flush(r);                                  }                              }                          }                          r = ZlibConstants.Z_OK;                            blocks.window[q++] = (byte)lit; m--;                            mode = START;                          break;                        case WASH:  // o: got eob' possibly more output                          if (k > 7)                          {                              // return unused byte' if any                              k -= 8;                              n++;                              p--; // can always return one                          }                            blocks.writeAt = q; r = blocks.Flush(r);                          q = blocks.writeAt; m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;                            if (blocks.readAt != blocks.writeAt)                          {                              blocks.bitb = b; blocks.bitk = k;                              z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                              blocks.writeAt = q;                              return blocks.Flush(r);                          }                          mode = END;                          goto case END;                        case END:                          r = ZlibConstants.Z_STREAM_END;                          blocks.bitb = b; blocks.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          blocks.writeAt = q;                          return blocks.Flush(r);                        case BADCODE:  // x: got error                            r = ZlibConstants.Z_DATA_ERROR;                            blocks.bitb = b; blocks.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          blocks.writeAt = q;                          return blocks.Flush(r);                        default:                          r = ZlibConstants.Z_STREAM_ERROR;                            blocks.bitb = b; blocks.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          blocks.writeAt = q;                          return blocks.Flush(r);                  }
Magic Number,Ionic.Zlib,InflateCodes,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zlib.Shared\Inflate.cs,Process,The following statement contains a magic number: switch (mode)                  {                      // waiting for "i:"=input' "o:"=output' "x:"=nothing                      case START:  // x: set up for LEN                          if (m >= 258 && n >= 10)                          {                              blocks.bitb = b; blocks.bitk = k;                              z.AvailableBytesIn = n;                              z.TotalBytesIn += p - z.NextIn;                              z.NextIn = p;                              blocks.writeAt = q;                              r = InflateFast(lbits' dbits' ltree' ltree_index' dtree' dtree_index' blocks' z);                                p = z.NextIn;                              n = z.AvailableBytesIn;                              b = blocks.bitb;                              k = blocks.bitk;                              q = blocks.writeAt; m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;                                if (r != ZlibConstants.Z_OK)                              {                                  mode = (r == ZlibConstants.Z_STREAM_END) ? WASH : BADCODE;                                  break;                              }                          }                          need = lbits;                          tree = ltree;                          tree_index = ltree_index;                            mode = LEN;                          goto case LEN;                        case LEN:  // i: get length/literal/eob next                          j = need;                            while (k < j)                          {                              if (n != 0)                                  r = ZlibConstants.Z_OK;                              else                              {                                  blocks.bitb = b; blocks.bitk = k;                                  z.AvailableBytesIn = n;                                  z.TotalBytesIn += p - z.NextIn;                                  z.NextIn = p;                                  blocks.writeAt = q;                                  return blocks.Flush(r);                              }                              n--;                              b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            tindex = (tree_index + (b & InternalInflateConstants.InflateMask[j])) * 3;                            b >>= (tree[tindex + 1]);                          k -= (tree[tindex + 1]);                            e = tree[tindex];                            if (e == 0)                          {                              // literal                              lit = tree[tindex + 2];                              mode = LIT;                              break;                          }                          if ((e & 16) != 0)                          {                              // length                              bitsToGet = e & 15;                              len = tree[tindex + 2];                              mode = LENEXT;                              break;                          }                          if ((e & 64) == 0)                          {                              // next table                              need = e;                              tree_index = tindex / 3 + tree[tindex + 2];                              break;                          }                          if ((e & 32) != 0)                          {                              // end of block                              mode = WASH;                              break;                          }                          mode = BADCODE; // invalid code                          z.Message = "invalid literal/length code";                          r = ZlibConstants.Z_DATA_ERROR;                            blocks.bitb = b; blocks.bitk = k;                          z.AvailableBytesIn = n;                          z.TotalBytesIn += p - z.NextIn;                          z.NextIn = p;                          blocks.writeAt = q;                          return blocks.Flush(r);                          case LENEXT:  // i: getting length extra (have base)                          j = bitsToGet;                            while (k < j)                          {                              if (n != 0)                                  r = ZlibConstants.Z_OK;                              else                              {                                  blocks.bitb = b; blocks.bitk = k;                                  z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  blocks.writeAt = q;                                  return blocks.Flush(r);                              }                              n--; b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            len += (b & InternalInflateConstants.InflateMask[j]);                            b >>= j;                          k -= j;                            need = dbits;                          tree = dtree;                          tree_index = dtree_index;                          mode = DIST;                          goto case DIST;                        case DIST:  // i: get distance next                          j = need;                            while (k < j)                          {                              if (n != 0)                                  r = ZlibConstants.Z_OK;                              else                              {                                  blocks.bitb = b; blocks.bitk = k;                                  z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  blocks.writeAt = q;                                  return blocks.Flush(r);                              }                              n--; b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            tindex = (tree_index + (b & InternalInflateConstants.InflateMask[j])) * 3;                            b >>= tree[tindex + 1];                          k -= tree[tindex + 1];                            e = (tree[tindex]);                          if ((e & 0x10) != 0)                          {                              // distance                              bitsToGet = e & 15;                              dist = tree[tindex + 2];                              mode = DISTEXT;                              break;                          }                          if ((e & 64) == 0)                          {                              // next table                              need = e;                              tree_index = tindex / 3 + tree[tindex + 2];                              break;                          }                          mode = BADCODE; // invalid code                          z.Message = "invalid distance code";                          r = ZlibConstants.Z_DATA_ERROR;                            blocks.bitb = b; blocks.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          blocks.writeAt = q;                          return blocks.Flush(r);                          case DISTEXT:  // i: getting distance extra                          j = bitsToGet;                            while (k < j)                          {                              if (n != 0)                                  r = ZlibConstants.Z_OK;                              else                              {                                  blocks.bitb = b; blocks.bitk = k;                                  z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  blocks.writeAt = q;                                  return blocks.Flush(r);                              }                              n--; b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            dist += (b & InternalInflateConstants.InflateMask[j]);                            b >>= j;                          k -= j;                            mode = COPY;                          goto case COPY;                        case COPY:  // o: copying bytes in window' waiting for space                          f = q - dist;                          while (f < 0)                          {                              // modulo window size-"while" instead                              f += blocks.end; // of "if" handles invalid distances                          }                          while (len != 0)                          {                              if (m == 0)                              {                                  if (q == blocks.end && blocks.readAt != 0)                                  {                                      q = 0; m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;                                  }                                  if (m == 0)                                  {                                      blocks.writeAt = q; r = blocks.Flush(r);                                      q = blocks.writeAt; m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;                                        if (q == blocks.end && blocks.readAt != 0)                                      {                                          q = 0; m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;                                      }                                        if (m == 0)                                      {                                          blocks.bitb = b; blocks.bitk = k;                                          z.AvailableBytesIn = n;                                          z.TotalBytesIn += p - z.NextIn;                                          z.NextIn = p;                                          blocks.writeAt = q;                                          return blocks.Flush(r);                                      }                                  }                              }                                blocks.window[q++] = blocks.window[f++]; m--;                                if (f == blocks.end)                                  f = 0;                              len--;                          }                          mode = START;                          break;                        case LIT:  // o: got literal' waiting for output space                          if (m == 0)                          {                              if (q == blocks.end && blocks.readAt != 0)                              {                                  q = 0; m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;                              }                              if (m == 0)                              {                                  blocks.writeAt = q; r = blocks.Flush(r);                                  q = blocks.writeAt; m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;                                    if (q == blocks.end && blocks.readAt != 0)                                  {                                      q = 0; m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;                                  }                                  if (m == 0)                                  {                                      blocks.bitb = b; blocks.bitk = k;                                      z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                      blocks.writeAt = q;                                      return blocks.Flush(r);                                  }                              }                          }                          r = ZlibConstants.Z_OK;                            blocks.window[q++] = (byte)lit; m--;                            mode = START;                          break;                        case WASH:  // o: got eob' possibly more output                          if (k > 7)                          {                              // return unused byte' if any                              k -= 8;                              n++;                              p--; // can always return one                          }                            blocks.writeAt = q; r = blocks.Flush(r);                          q = blocks.writeAt; m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;                            if (blocks.readAt != blocks.writeAt)                          {                              blocks.bitb = b; blocks.bitk = k;                              z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                              blocks.writeAt = q;                              return blocks.Flush(r);                          }                          mode = END;                          goto case END;                        case END:                          r = ZlibConstants.Z_STREAM_END;                          blocks.bitb = b; blocks.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          blocks.writeAt = q;                          return blocks.Flush(r);                        case BADCODE:  // x: got error                            r = ZlibConstants.Z_DATA_ERROR;                            blocks.bitb = b; blocks.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          blocks.writeAt = q;                          return blocks.Flush(r);                        default:                          r = ZlibConstants.Z_STREAM_ERROR;                            blocks.bitb = b; blocks.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          blocks.writeAt = q;                          return blocks.Flush(r);                  }
Magic Number,Ionic.Zlib,InflateCodes,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zlib.Shared\Inflate.cs,Process,The following statement contains a magic number: switch (mode)                  {                      // waiting for "i:"=input' "o:"=output' "x:"=nothing                      case START:  // x: set up for LEN                          if (m >= 258 && n >= 10)                          {                              blocks.bitb = b; blocks.bitk = k;                              z.AvailableBytesIn = n;                              z.TotalBytesIn += p - z.NextIn;                              z.NextIn = p;                              blocks.writeAt = q;                              r = InflateFast(lbits' dbits' ltree' ltree_index' dtree' dtree_index' blocks' z);                                p = z.NextIn;                              n = z.AvailableBytesIn;                              b = blocks.bitb;                              k = blocks.bitk;                              q = blocks.writeAt; m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;                                if (r != ZlibConstants.Z_OK)                              {                                  mode = (r == ZlibConstants.Z_STREAM_END) ? WASH : BADCODE;                                  break;                              }                          }                          need = lbits;                          tree = ltree;                          tree_index = ltree_index;                            mode = LEN;                          goto case LEN;                        case LEN:  // i: get length/literal/eob next                          j = need;                            while (k < j)                          {                              if (n != 0)                                  r = ZlibConstants.Z_OK;                              else                              {                                  blocks.bitb = b; blocks.bitk = k;                                  z.AvailableBytesIn = n;                                  z.TotalBytesIn += p - z.NextIn;                                  z.NextIn = p;                                  blocks.writeAt = q;                                  return blocks.Flush(r);                              }                              n--;                              b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            tindex = (tree_index + (b & InternalInflateConstants.InflateMask[j])) * 3;                            b >>= (tree[tindex + 1]);                          k -= (tree[tindex + 1]);                            e = tree[tindex];                            if (e == 0)                          {                              // literal                              lit = tree[tindex + 2];                              mode = LIT;                              break;                          }                          if ((e & 16) != 0)                          {                              // length                              bitsToGet = e & 15;                              len = tree[tindex + 2];                              mode = LENEXT;                              break;                          }                          if ((e & 64) == 0)                          {                              // next table                              need = e;                              tree_index = tindex / 3 + tree[tindex + 2];                              break;                          }                          if ((e & 32) != 0)                          {                              // end of block                              mode = WASH;                              break;                          }                          mode = BADCODE; // invalid code                          z.Message = "invalid literal/length code";                          r = ZlibConstants.Z_DATA_ERROR;                            blocks.bitb = b; blocks.bitk = k;                          z.AvailableBytesIn = n;                          z.TotalBytesIn += p - z.NextIn;                          z.NextIn = p;                          blocks.writeAt = q;                          return blocks.Flush(r);                          case LENEXT:  // i: getting length extra (have base)                          j = bitsToGet;                            while (k < j)                          {                              if (n != 0)                                  r = ZlibConstants.Z_OK;                              else                              {                                  blocks.bitb = b; blocks.bitk = k;                                  z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  blocks.writeAt = q;                                  return blocks.Flush(r);                              }                              n--; b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            len += (b & InternalInflateConstants.InflateMask[j]);                            b >>= j;                          k -= j;                            need = dbits;                          tree = dtree;                          tree_index = dtree_index;                          mode = DIST;                          goto case DIST;                        case DIST:  // i: get distance next                          j = need;                            while (k < j)                          {                              if (n != 0)                                  r = ZlibConstants.Z_OK;                              else                              {                                  blocks.bitb = b; blocks.bitk = k;                                  z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  blocks.writeAt = q;                                  return blocks.Flush(r);                              }                              n--; b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            tindex = (tree_index + (b & InternalInflateConstants.InflateMask[j])) * 3;                            b >>= tree[tindex + 1];                          k -= tree[tindex + 1];                            e = (tree[tindex]);                          if ((e & 0x10) != 0)                          {                              // distance                              bitsToGet = e & 15;                              dist = tree[tindex + 2];                              mode = DISTEXT;                              break;                          }                          if ((e & 64) == 0)                          {                              // next table                              need = e;                              tree_index = tindex / 3 + tree[tindex + 2];                              break;                          }                          mode = BADCODE; // invalid code                          z.Message = "invalid distance code";                          r = ZlibConstants.Z_DATA_ERROR;                            blocks.bitb = b; blocks.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          blocks.writeAt = q;                          return blocks.Flush(r);                          case DISTEXT:  // i: getting distance extra                          j = bitsToGet;                            while (k < j)                          {                              if (n != 0)                                  r = ZlibConstants.Z_OK;                              else                              {                                  blocks.bitb = b; blocks.bitk = k;                                  z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  blocks.writeAt = q;                                  return blocks.Flush(r);                              }                              n--; b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            dist += (b & InternalInflateConstants.InflateMask[j]);                            b >>= j;                          k -= j;                            mode = COPY;                          goto case COPY;                        case COPY:  // o: copying bytes in window' waiting for space                          f = q - dist;                          while (f < 0)                          {                              // modulo window size-"while" instead                              f += blocks.end; // of "if" handles invalid distances                          }                          while (len != 0)                          {                              if (m == 0)                              {                                  if (q == blocks.end && blocks.readAt != 0)                                  {                                      q = 0; m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;                                  }                                  if (m == 0)                                  {                                      blocks.writeAt = q; r = blocks.Flush(r);                                      q = blocks.writeAt; m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;                                        if (q == blocks.end && blocks.readAt != 0)                                      {                                          q = 0; m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;                                      }                                        if (m == 0)                                      {                                          blocks.bitb = b; blocks.bitk = k;                                          z.AvailableBytesIn = n;                                          z.TotalBytesIn += p - z.NextIn;                                          z.NextIn = p;                                          blocks.writeAt = q;                                          return blocks.Flush(r);                                      }                                  }                              }                                blocks.window[q++] = blocks.window[f++]; m--;                                if (f == blocks.end)                                  f = 0;                              len--;                          }                          mode = START;                          break;                        case LIT:  // o: got literal' waiting for output space                          if (m == 0)                          {                              if (q == blocks.end && blocks.readAt != 0)                              {                                  q = 0; m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;                              }                              if (m == 0)                              {                                  blocks.writeAt = q; r = blocks.Flush(r);                                  q = blocks.writeAt; m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;                                    if (q == blocks.end && blocks.readAt != 0)                                  {                                      q = 0; m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;                                  }                                  if (m == 0)                                  {                                      blocks.bitb = b; blocks.bitk = k;                                      z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                      blocks.writeAt = q;                                      return blocks.Flush(r);                                  }                              }                          }                          r = ZlibConstants.Z_OK;                            blocks.window[q++] = (byte)lit; m--;                            mode = START;                          break;                        case WASH:  // o: got eob' possibly more output                          if (k > 7)                          {                              // return unused byte' if any                              k -= 8;                              n++;                              p--; // can always return one                          }                            blocks.writeAt = q; r = blocks.Flush(r);                          q = blocks.writeAt; m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;                            if (blocks.readAt != blocks.writeAt)                          {                              blocks.bitb = b; blocks.bitk = k;                              z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                              blocks.writeAt = q;                              return blocks.Flush(r);                          }                          mode = END;                          goto case END;                        case END:                          r = ZlibConstants.Z_STREAM_END;                          blocks.bitb = b; blocks.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          blocks.writeAt = q;                          return blocks.Flush(r);                        case BADCODE:  // x: got error                            r = ZlibConstants.Z_DATA_ERROR;                            blocks.bitb = b; blocks.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          blocks.writeAt = q;                          return blocks.Flush(r);                        default:                          r = ZlibConstants.Z_STREAM_ERROR;                            blocks.bitb = b; blocks.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          blocks.writeAt = q;                          return blocks.Flush(r);                  }
Magic Number,Ionic.Zlib,InflateCodes,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zlib.Shared\Inflate.cs,Process,The following statement contains a magic number: switch (mode)                  {                      // waiting for "i:"=input' "o:"=output' "x:"=nothing                      case START:  // x: set up for LEN                          if (m >= 258 && n >= 10)                          {                              blocks.bitb = b; blocks.bitk = k;                              z.AvailableBytesIn = n;                              z.TotalBytesIn += p - z.NextIn;                              z.NextIn = p;                              blocks.writeAt = q;                              r = InflateFast(lbits' dbits' ltree' ltree_index' dtree' dtree_index' blocks' z);                                p = z.NextIn;                              n = z.AvailableBytesIn;                              b = blocks.bitb;                              k = blocks.bitk;                              q = blocks.writeAt; m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;                                if (r != ZlibConstants.Z_OK)                              {                                  mode = (r == ZlibConstants.Z_STREAM_END) ? WASH : BADCODE;                                  break;                              }                          }                          need = lbits;                          tree = ltree;                          tree_index = ltree_index;                            mode = LEN;                          goto case LEN;                        case LEN:  // i: get length/literal/eob next                          j = need;                            while (k < j)                          {                              if (n != 0)                                  r = ZlibConstants.Z_OK;                              else                              {                                  blocks.bitb = b; blocks.bitk = k;                                  z.AvailableBytesIn = n;                                  z.TotalBytesIn += p - z.NextIn;                                  z.NextIn = p;                                  blocks.writeAt = q;                                  return blocks.Flush(r);                              }                              n--;                              b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            tindex = (tree_index + (b & InternalInflateConstants.InflateMask[j])) * 3;                            b >>= (tree[tindex + 1]);                          k -= (tree[tindex + 1]);                            e = tree[tindex];                            if (e == 0)                          {                              // literal                              lit = tree[tindex + 2];                              mode = LIT;                              break;                          }                          if ((e & 16) != 0)                          {                              // length                              bitsToGet = e & 15;                              len = tree[tindex + 2];                              mode = LENEXT;                              break;                          }                          if ((e & 64) == 0)                          {                              // next table                              need = e;                              tree_index = tindex / 3 + tree[tindex + 2];                              break;                          }                          if ((e & 32) != 0)                          {                              // end of block                              mode = WASH;                              break;                          }                          mode = BADCODE; // invalid code                          z.Message = "invalid literal/length code";                          r = ZlibConstants.Z_DATA_ERROR;                            blocks.bitb = b; blocks.bitk = k;                          z.AvailableBytesIn = n;                          z.TotalBytesIn += p - z.NextIn;                          z.NextIn = p;                          blocks.writeAt = q;                          return blocks.Flush(r);                          case LENEXT:  // i: getting length extra (have base)                          j = bitsToGet;                            while (k < j)                          {                              if (n != 0)                                  r = ZlibConstants.Z_OK;                              else                              {                                  blocks.bitb = b; blocks.bitk = k;                                  z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  blocks.writeAt = q;                                  return blocks.Flush(r);                              }                              n--; b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            len += (b & InternalInflateConstants.InflateMask[j]);                            b >>= j;                          k -= j;                            need = dbits;                          tree = dtree;                          tree_index = dtree_index;                          mode = DIST;                          goto case DIST;                        case DIST:  // i: get distance next                          j = need;                            while (k < j)                          {                              if (n != 0)                                  r = ZlibConstants.Z_OK;                              else                              {                                  blocks.bitb = b; blocks.bitk = k;                                  z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  blocks.writeAt = q;                                  return blocks.Flush(r);                              }                              n--; b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            tindex = (tree_index + (b & InternalInflateConstants.InflateMask[j])) * 3;                            b >>= tree[tindex + 1];                          k -= tree[tindex + 1];                            e = (tree[tindex]);                          if ((e & 0x10) != 0)                          {                              // distance                              bitsToGet = e & 15;                              dist = tree[tindex + 2];                              mode = DISTEXT;                              break;                          }                          if ((e & 64) == 0)                          {                              // next table                              need = e;                              tree_index = tindex / 3 + tree[tindex + 2];                              break;                          }                          mode = BADCODE; // invalid code                          z.Message = "invalid distance code";                          r = ZlibConstants.Z_DATA_ERROR;                            blocks.bitb = b; blocks.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          blocks.writeAt = q;                          return blocks.Flush(r);                          case DISTEXT:  // i: getting distance extra                          j = bitsToGet;                            while (k < j)                          {                              if (n != 0)                                  r = ZlibConstants.Z_OK;                              else                              {                                  blocks.bitb = b; blocks.bitk = k;                                  z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  blocks.writeAt = q;                                  return blocks.Flush(r);                              }                              n--; b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            dist += (b & InternalInflateConstants.InflateMask[j]);                            b >>= j;                          k -= j;                            mode = COPY;                          goto case COPY;                        case COPY:  // o: copying bytes in window' waiting for space                          f = q - dist;                          while (f < 0)                          {                              // modulo window size-"while" instead                              f += blocks.end; // of "if" handles invalid distances                          }                          while (len != 0)                          {                              if (m == 0)                              {                                  if (q == blocks.end && blocks.readAt != 0)                                  {                                      q = 0; m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;                                  }                                  if (m == 0)                                  {                                      blocks.writeAt = q; r = blocks.Flush(r);                                      q = blocks.writeAt; m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;                                        if (q == blocks.end && blocks.readAt != 0)                                      {                                          q = 0; m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;                                      }                                        if (m == 0)                                      {                                          blocks.bitb = b; blocks.bitk = k;                                          z.AvailableBytesIn = n;                                          z.TotalBytesIn += p - z.NextIn;                                          z.NextIn = p;                                          blocks.writeAt = q;                                          return blocks.Flush(r);                                      }                                  }                              }                                blocks.window[q++] = blocks.window[f++]; m--;                                if (f == blocks.end)                                  f = 0;                              len--;                          }                          mode = START;                          break;                        case LIT:  // o: got literal' waiting for output space                          if (m == 0)                          {                              if (q == blocks.end && blocks.readAt != 0)                              {                                  q = 0; m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;                              }                              if (m == 0)                              {                                  blocks.writeAt = q; r = blocks.Flush(r);                                  q = blocks.writeAt; m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;                                    if (q == blocks.end && blocks.readAt != 0)                                  {                                      q = 0; m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;                                  }                                  if (m == 0)                                  {                                      blocks.bitb = b; blocks.bitk = k;                                      z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                      blocks.writeAt = q;                                      return blocks.Flush(r);                                  }                              }                          }                          r = ZlibConstants.Z_OK;                            blocks.window[q++] = (byte)lit; m--;                            mode = START;                          break;                        case WASH:  // o: got eob' possibly more output                          if (k > 7)                          {                              // return unused byte' if any                              k -= 8;                              n++;                              p--; // can always return one                          }                            blocks.writeAt = q; r = blocks.Flush(r);                          q = blocks.writeAt; m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;                            if (blocks.readAt != blocks.writeAt)                          {                              blocks.bitb = b; blocks.bitk = k;                              z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                              blocks.writeAt = q;                              return blocks.Flush(r);                          }                          mode = END;                          goto case END;                        case END:                          r = ZlibConstants.Z_STREAM_END;                          blocks.bitb = b; blocks.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          blocks.writeAt = q;                          return blocks.Flush(r);                        case BADCODE:  // x: got error                            r = ZlibConstants.Z_DATA_ERROR;                            blocks.bitb = b; blocks.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          blocks.writeAt = q;                          return blocks.Flush(r);                        default:                          r = ZlibConstants.Z_STREAM_ERROR;                            blocks.bitb = b; blocks.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          blocks.writeAt = q;                          return blocks.Flush(r);                  }
Magic Number,Ionic.Zlib,InflateCodes,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zlib.Shared\Inflate.cs,Process,The following statement contains a magic number: switch (mode)                  {                      // waiting for "i:"=input' "o:"=output' "x:"=nothing                      case START:  // x: set up for LEN                          if (m >= 258 && n >= 10)                          {                              blocks.bitb = b; blocks.bitk = k;                              z.AvailableBytesIn = n;                              z.TotalBytesIn += p - z.NextIn;                              z.NextIn = p;                              blocks.writeAt = q;                              r = InflateFast(lbits' dbits' ltree' ltree_index' dtree' dtree_index' blocks' z);                                p = z.NextIn;                              n = z.AvailableBytesIn;                              b = blocks.bitb;                              k = blocks.bitk;                              q = blocks.writeAt; m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;                                if (r != ZlibConstants.Z_OK)                              {                                  mode = (r == ZlibConstants.Z_STREAM_END) ? WASH : BADCODE;                                  break;                              }                          }                          need = lbits;                          tree = ltree;                          tree_index = ltree_index;                            mode = LEN;                          goto case LEN;                        case LEN:  // i: get length/literal/eob next                          j = need;                            while (k < j)                          {                              if (n != 0)                                  r = ZlibConstants.Z_OK;                              else                              {                                  blocks.bitb = b; blocks.bitk = k;                                  z.AvailableBytesIn = n;                                  z.TotalBytesIn += p - z.NextIn;                                  z.NextIn = p;                                  blocks.writeAt = q;                                  return blocks.Flush(r);                              }                              n--;                              b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            tindex = (tree_index + (b & InternalInflateConstants.InflateMask[j])) * 3;                            b >>= (tree[tindex + 1]);                          k -= (tree[tindex + 1]);                            e = tree[tindex];                            if (e == 0)                          {                              // literal                              lit = tree[tindex + 2];                              mode = LIT;                              break;                          }                          if ((e & 16) != 0)                          {                              // length                              bitsToGet = e & 15;                              len = tree[tindex + 2];                              mode = LENEXT;                              break;                          }                          if ((e & 64) == 0)                          {                              // next table                              need = e;                              tree_index = tindex / 3 + tree[tindex + 2];                              break;                          }                          if ((e & 32) != 0)                          {                              // end of block                              mode = WASH;                              break;                          }                          mode = BADCODE; // invalid code                          z.Message = "invalid literal/length code";                          r = ZlibConstants.Z_DATA_ERROR;                            blocks.bitb = b; blocks.bitk = k;                          z.AvailableBytesIn = n;                          z.TotalBytesIn += p - z.NextIn;                          z.NextIn = p;                          blocks.writeAt = q;                          return blocks.Flush(r);                          case LENEXT:  // i: getting length extra (have base)                          j = bitsToGet;                            while (k < j)                          {                              if (n != 0)                                  r = ZlibConstants.Z_OK;                              else                              {                                  blocks.bitb = b; blocks.bitk = k;                                  z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  blocks.writeAt = q;                                  return blocks.Flush(r);                              }                              n--; b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            len += (b & InternalInflateConstants.InflateMask[j]);                            b >>= j;                          k -= j;                            need = dbits;                          tree = dtree;                          tree_index = dtree_index;                          mode = DIST;                          goto case DIST;                        case DIST:  // i: get distance next                          j = need;                            while (k < j)                          {                              if (n != 0)                                  r = ZlibConstants.Z_OK;                              else                              {                                  blocks.bitb = b; blocks.bitk = k;                                  z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  blocks.writeAt = q;                                  return blocks.Flush(r);                              }                              n--; b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            tindex = (tree_index + (b & InternalInflateConstants.InflateMask[j])) * 3;                            b >>= tree[tindex + 1];                          k -= tree[tindex + 1];                            e = (tree[tindex]);                          if ((e & 0x10) != 0)                          {                              // distance                              bitsToGet = e & 15;                              dist = tree[tindex + 2];                              mode = DISTEXT;                              break;                          }                          if ((e & 64) == 0)                          {                              // next table                              need = e;                              tree_index = tindex / 3 + tree[tindex + 2];                              break;                          }                          mode = BADCODE; // invalid code                          z.Message = "invalid distance code";                          r = ZlibConstants.Z_DATA_ERROR;                            blocks.bitb = b; blocks.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          blocks.writeAt = q;                          return blocks.Flush(r);                          case DISTEXT:  // i: getting distance extra                          j = bitsToGet;                            while (k < j)                          {                              if (n != 0)                                  r = ZlibConstants.Z_OK;                              else                              {                                  blocks.bitb = b; blocks.bitk = k;                                  z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  blocks.writeAt = q;                                  return blocks.Flush(r);                              }                              n--; b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            dist += (b & InternalInflateConstants.InflateMask[j]);                            b >>= j;                          k -= j;                            mode = COPY;                          goto case COPY;                        case COPY:  // o: copying bytes in window' waiting for space                          f = q - dist;                          while (f < 0)                          {                              // modulo window size-"while" instead                              f += blocks.end; // of "if" handles invalid distances                          }                          while (len != 0)                          {                              if (m == 0)                              {                                  if (q == blocks.end && blocks.readAt != 0)                                  {                                      q = 0; m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;                                  }                                  if (m == 0)                                  {                                      blocks.writeAt = q; r = blocks.Flush(r);                                      q = blocks.writeAt; m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;                                        if (q == blocks.end && blocks.readAt != 0)                                      {                                          q = 0; m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;                                      }                                        if (m == 0)                                      {                                          blocks.bitb = b; blocks.bitk = k;                                          z.AvailableBytesIn = n;                                          z.TotalBytesIn += p - z.NextIn;                                          z.NextIn = p;                                          blocks.writeAt = q;                                          return blocks.Flush(r);                                      }                                  }                              }                                blocks.window[q++] = blocks.window[f++]; m--;                                if (f == blocks.end)                                  f = 0;                              len--;                          }                          mode = START;                          break;                        case LIT:  // o: got literal' waiting for output space                          if (m == 0)                          {                              if (q == blocks.end && blocks.readAt != 0)                              {                                  q = 0; m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;                              }                              if (m == 0)                              {                                  blocks.writeAt = q; r = blocks.Flush(r);                                  q = blocks.writeAt; m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;                                    if (q == blocks.end && blocks.readAt != 0)                                  {                                      q = 0; m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;                                  }                                  if (m == 0)                                  {                                      blocks.bitb = b; blocks.bitk = k;                                      z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                      blocks.writeAt = q;                                      return blocks.Flush(r);                                  }                              }                          }                          r = ZlibConstants.Z_OK;                            blocks.window[q++] = (byte)lit; m--;                            mode = START;                          break;                        case WASH:  // o: got eob' possibly more output                          if (k > 7)                          {                              // return unused byte' if any                              k -= 8;                              n++;                              p--; // can always return one                          }                            blocks.writeAt = q; r = blocks.Flush(r);                          q = blocks.writeAt; m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;                            if (blocks.readAt != blocks.writeAt)                          {                              blocks.bitb = b; blocks.bitk = k;                              z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                              blocks.writeAt = q;                              return blocks.Flush(r);                          }                          mode = END;                          goto case END;                        case END:                          r = ZlibConstants.Z_STREAM_END;                          blocks.bitb = b; blocks.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          blocks.writeAt = q;                          return blocks.Flush(r);                        case BADCODE:  // x: got error                            r = ZlibConstants.Z_DATA_ERROR;                            blocks.bitb = b; blocks.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          blocks.writeAt = q;                          return blocks.Flush(r);                        default:                          r = ZlibConstants.Z_STREAM_ERROR;                            blocks.bitb = b; blocks.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          blocks.writeAt = q;                          return blocks.Flush(r);                  }
Magic Number,Ionic.Zlib,InflateCodes,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zlib.Shared\Inflate.cs,Process,The following statement contains a magic number: switch (mode)                  {                      // waiting for "i:"=input' "o:"=output' "x:"=nothing                      case START:  // x: set up for LEN                          if (m >= 258 && n >= 10)                          {                              blocks.bitb = b; blocks.bitk = k;                              z.AvailableBytesIn = n;                              z.TotalBytesIn += p - z.NextIn;                              z.NextIn = p;                              blocks.writeAt = q;                              r = InflateFast(lbits' dbits' ltree' ltree_index' dtree' dtree_index' blocks' z);                                p = z.NextIn;                              n = z.AvailableBytesIn;                              b = blocks.bitb;                              k = blocks.bitk;                              q = blocks.writeAt; m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;                                if (r != ZlibConstants.Z_OK)                              {                                  mode = (r == ZlibConstants.Z_STREAM_END) ? WASH : BADCODE;                                  break;                              }                          }                          need = lbits;                          tree = ltree;                          tree_index = ltree_index;                            mode = LEN;                          goto case LEN;                        case LEN:  // i: get length/literal/eob next                          j = need;                            while (k < j)                          {                              if (n != 0)                                  r = ZlibConstants.Z_OK;                              else                              {                                  blocks.bitb = b; blocks.bitk = k;                                  z.AvailableBytesIn = n;                                  z.TotalBytesIn += p - z.NextIn;                                  z.NextIn = p;                                  blocks.writeAt = q;                                  return blocks.Flush(r);                              }                              n--;                              b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            tindex = (tree_index + (b & InternalInflateConstants.InflateMask[j])) * 3;                            b >>= (tree[tindex + 1]);                          k -= (tree[tindex + 1]);                            e = tree[tindex];                            if (e == 0)                          {                              // literal                              lit = tree[tindex + 2];                              mode = LIT;                              break;                          }                          if ((e & 16) != 0)                          {                              // length                              bitsToGet = e & 15;                              len = tree[tindex + 2];                              mode = LENEXT;                              break;                          }                          if ((e & 64) == 0)                          {                              // next table                              need = e;                              tree_index = tindex / 3 + tree[tindex + 2];                              break;                          }                          if ((e & 32) != 0)                          {                              // end of block                              mode = WASH;                              break;                          }                          mode = BADCODE; // invalid code                          z.Message = "invalid literal/length code";                          r = ZlibConstants.Z_DATA_ERROR;                            blocks.bitb = b; blocks.bitk = k;                          z.AvailableBytesIn = n;                          z.TotalBytesIn += p - z.NextIn;                          z.NextIn = p;                          blocks.writeAt = q;                          return blocks.Flush(r);                          case LENEXT:  // i: getting length extra (have base)                          j = bitsToGet;                            while (k < j)                          {                              if (n != 0)                                  r = ZlibConstants.Z_OK;                              else                              {                                  blocks.bitb = b; blocks.bitk = k;                                  z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  blocks.writeAt = q;                                  return blocks.Flush(r);                              }                              n--; b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            len += (b & InternalInflateConstants.InflateMask[j]);                            b >>= j;                          k -= j;                            need = dbits;                          tree = dtree;                          tree_index = dtree_index;                          mode = DIST;                          goto case DIST;                        case DIST:  // i: get distance next                          j = need;                            while (k < j)                          {                              if (n != 0)                                  r = ZlibConstants.Z_OK;                              else                              {                                  blocks.bitb = b; blocks.bitk = k;                                  z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  blocks.writeAt = q;                                  return blocks.Flush(r);                              }                              n--; b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            tindex = (tree_index + (b & InternalInflateConstants.InflateMask[j])) * 3;                            b >>= tree[tindex + 1];                          k -= tree[tindex + 1];                            e = (tree[tindex]);                          if ((e & 0x10) != 0)                          {                              // distance                              bitsToGet = e & 15;                              dist = tree[tindex + 2];                              mode = DISTEXT;                              break;                          }                          if ((e & 64) == 0)                          {                              // next table                              need = e;                              tree_index = tindex / 3 + tree[tindex + 2];                              break;                          }                          mode = BADCODE; // invalid code                          z.Message = "invalid distance code";                          r = ZlibConstants.Z_DATA_ERROR;                            blocks.bitb = b; blocks.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          blocks.writeAt = q;                          return blocks.Flush(r);                          case DISTEXT:  // i: getting distance extra                          j = bitsToGet;                            while (k < j)                          {                              if (n != 0)                                  r = ZlibConstants.Z_OK;                              else                              {                                  blocks.bitb = b; blocks.bitk = k;                                  z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  blocks.writeAt = q;                                  return blocks.Flush(r);                              }                              n--; b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            dist += (b & InternalInflateConstants.InflateMask[j]);                            b >>= j;                          k -= j;                            mode = COPY;                          goto case COPY;                        case COPY:  // o: copying bytes in window' waiting for space                          f = q - dist;                          while (f < 0)                          {                              // modulo window size-"while" instead                              f += blocks.end; // of "if" handles invalid distances                          }                          while (len != 0)                          {                              if (m == 0)                              {                                  if (q == blocks.end && blocks.readAt != 0)                                  {                                      q = 0; m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;                                  }                                  if (m == 0)                                  {                                      blocks.writeAt = q; r = blocks.Flush(r);                                      q = blocks.writeAt; m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;                                        if (q == blocks.end && blocks.readAt != 0)                                      {                                          q = 0; m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;                                      }                                        if (m == 0)                                      {                                          blocks.bitb = b; blocks.bitk = k;                                          z.AvailableBytesIn = n;                                          z.TotalBytesIn += p - z.NextIn;                                          z.NextIn = p;                                          blocks.writeAt = q;                                          return blocks.Flush(r);                                      }                                  }                              }                                blocks.window[q++] = blocks.window[f++]; m--;                                if (f == blocks.end)                                  f = 0;                              len--;                          }                          mode = START;                          break;                        case LIT:  // o: got literal' waiting for output space                          if (m == 0)                          {                              if (q == blocks.end && blocks.readAt != 0)                              {                                  q = 0; m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;                              }                              if (m == 0)                              {                                  blocks.writeAt = q; r = blocks.Flush(r);                                  q = blocks.writeAt; m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;                                    if (q == blocks.end && blocks.readAt != 0)                                  {                                      q = 0; m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;                                  }                                  if (m == 0)                                  {                                      blocks.bitb = b; blocks.bitk = k;                                      z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                      blocks.writeAt = q;                                      return blocks.Flush(r);                                  }                              }                          }                          r = ZlibConstants.Z_OK;                            blocks.window[q++] = (byte)lit; m--;                            mode = START;                          break;                        case WASH:  // o: got eob' possibly more output                          if (k > 7)                          {                              // return unused byte' if any                              k -= 8;                              n++;                              p--; // can always return one                          }                            blocks.writeAt = q; r = blocks.Flush(r);                          q = blocks.writeAt; m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;                            if (blocks.readAt != blocks.writeAt)                          {                              blocks.bitb = b; blocks.bitk = k;                              z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                              blocks.writeAt = q;                              return blocks.Flush(r);                          }                          mode = END;                          goto case END;                        case END:                          r = ZlibConstants.Z_STREAM_END;                          blocks.bitb = b; blocks.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          blocks.writeAt = q;                          return blocks.Flush(r);                        case BADCODE:  // x: got error                            r = ZlibConstants.Z_DATA_ERROR;                            blocks.bitb = b; blocks.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          blocks.writeAt = q;                          return blocks.Flush(r);                        default:                          r = ZlibConstants.Z_STREAM_ERROR;                            blocks.bitb = b; blocks.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          blocks.writeAt = q;                          return blocks.Flush(r);                  }
Magic Number,Ionic.Zlib,InflateCodes,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zlib.Shared\Inflate.cs,Process,The following statement contains a magic number: switch (mode)                  {                      // waiting for "i:"=input' "o:"=output' "x:"=nothing                      case START:  // x: set up for LEN                          if (m >= 258 && n >= 10)                          {                              blocks.bitb = b; blocks.bitk = k;                              z.AvailableBytesIn = n;                              z.TotalBytesIn += p - z.NextIn;                              z.NextIn = p;                              blocks.writeAt = q;                              r = InflateFast(lbits' dbits' ltree' ltree_index' dtree' dtree_index' blocks' z);                                p = z.NextIn;                              n = z.AvailableBytesIn;                              b = blocks.bitb;                              k = blocks.bitk;                              q = blocks.writeAt; m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;                                if (r != ZlibConstants.Z_OK)                              {                                  mode = (r == ZlibConstants.Z_STREAM_END) ? WASH : BADCODE;                                  break;                              }                          }                          need = lbits;                          tree = ltree;                          tree_index = ltree_index;                            mode = LEN;                          goto case LEN;                        case LEN:  // i: get length/literal/eob next                          j = need;                            while (k < j)                          {                              if (n != 0)                                  r = ZlibConstants.Z_OK;                              else                              {                                  blocks.bitb = b; blocks.bitk = k;                                  z.AvailableBytesIn = n;                                  z.TotalBytesIn += p - z.NextIn;                                  z.NextIn = p;                                  blocks.writeAt = q;                                  return blocks.Flush(r);                              }                              n--;                              b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            tindex = (tree_index + (b & InternalInflateConstants.InflateMask[j])) * 3;                            b >>= (tree[tindex + 1]);                          k -= (tree[tindex + 1]);                            e = tree[tindex];                            if (e == 0)                          {                              // literal                              lit = tree[tindex + 2];                              mode = LIT;                              break;                          }                          if ((e & 16) != 0)                          {                              // length                              bitsToGet = e & 15;                              len = tree[tindex + 2];                              mode = LENEXT;                              break;                          }                          if ((e & 64) == 0)                          {                              // next table                              need = e;                              tree_index = tindex / 3 + tree[tindex + 2];                              break;                          }                          if ((e & 32) != 0)                          {                              // end of block                              mode = WASH;                              break;                          }                          mode = BADCODE; // invalid code                          z.Message = "invalid literal/length code";                          r = ZlibConstants.Z_DATA_ERROR;                            blocks.bitb = b; blocks.bitk = k;                          z.AvailableBytesIn = n;                          z.TotalBytesIn += p - z.NextIn;                          z.NextIn = p;                          blocks.writeAt = q;                          return blocks.Flush(r);                          case LENEXT:  // i: getting length extra (have base)                          j = bitsToGet;                            while (k < j)                          {                              if (n != 0)                                  r = ZlibConstants.Z_OK;                              else                              {                                  blocks.bitb = b; blocks.bitk = k;                                  z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  blocks.writeAt = q;                                  return blocks.Flush(r);                              }                              n--; b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            len += (b & InternalInflateConstants.InflateMask[j]);                            b >>= j;                          k -= j;                            need = dbits;                          tree = dtree;                          tree_index = dtree_index;                          mode = DIST;                          goto case DIST;                        case DIST:  // i: get distance next                          j = need;                            while (k < j)                          {                              if (n != 0)                                  r = ZlibConstants.Z_OK;                              else                              {                                  blocks.bitb = b; blocks.bitk = k;                                  z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  blocks.writeAt = q;                                  return blocks.Flush(r);                              }                              n--; b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            tindex = (tree_index + (b & InternalInflateConstants.InflateMask[j])) * 3;                            b >>= tree[tindex + 1];                          k -= tree[tindex + 1];                            e = (tree[tindex]);                          if ((e & 0x10) != 0)                          {                              // distance                              bitsToGet = e & 15;                              dist = tree[tindex + 2];                              mode = DISTEXT;                              break;                          }                          if ((e & 64) == 0)                          {                              // next table                              need = e;                              tree_index = tindex / 3 + tree[tindex + 2];                              break;                          }                          mode = BADCODE; // invalid code                          z.Message = "invalid distance code";                          r = ZlibConstants.Z_DATA_ERROR;                            blocks.bitb = b; blocks.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          blocks.writeAt = q;                          return blocks.Flush(r);                          case DISTEXT:  // i: getting distance extra                          j = bitsToGet;                            while (k < j)                          {                              if (n != 0)                                  r = ZlibConstants.Z_OK;                              else                              {                                  blocks.bitb = b; blocks.bitk = k;                                  z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  blocks.writeAt = q;                                  return blocks.Flush(r);                              }                              n--; b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            dist += (b & InternalInflateConstants.InflateMask[j]);                            b >>= j;                          k -= j;                            mode = COPY;                          goto case COPY;                        case COPY:  // o: copying bytes in window' waiting for space                          f = q - dist;                          while (f < 0)                          {                              // modulo window size-"while" instead                              f += blocks.end; // of "if" handles invalid distances                          }                          while (len != 0)                          {                              if (m == 0)                              {                                  if (q == blocks.end && blocks.readAt != 0)                                  {                                      q = 0; m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;                                  }                                  if (m == 0)                                  {                                      blocks.writeAt = q; r = blocks.Flush(r);                                      q = blocks.writeAt; m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;                                        if (q == blocks.end && blocks.readAt != 0)                                      {                                          q = 0; m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;                                      }                                        if (m == 0)                                      {                                          blocks.bitb = b; blocks.bitk = k;                                          z.AvailableBytesIn = n;                                          z.TotalBytesIn += p - z.NextIn;                                          z.NextIn = p;                                          blocks.writeAt = q;                                          return blocks.Flush(r);                                      }                                  }                              }                                blocks.window[q++] = blocks.window[f++]; m--;                                if (f == blocks.end)                                  f = 0;                              len--;                          }                          mode = START;                          break;                        case LIT:  // o: got literal' waiting for output space                          if (m == 0)                          {                              if (q == blocks.end && blocks.readAt != 0)                              {                                  q = 0; m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;                              }                              if (m == 0)                              {                                  blocks.writeAt = q; r = blocks.Flush(r);                                  q = blocks.writeAt; m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;                                    if (q == blocks.end && blocks.readAt != 0)                                  {                                      q = 0; m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;                                  }                                  if (m == 0)                                  {                                      blocks.bitb = b; blocks.bitk = k;                                      z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                      blocks.writeAt = q;                                      return blocks.Flush(r);                                  }                              }                          }                          r = ZlibConstants.Z_OK;                            blocks.window[q++] = (byte)lit; m--;                            mode = START;                          break;                        case WASH:  // o: got eob' possibly more output                          if (k > 7)                          {                              // return unused byte' if any                              k -= 8;                              n++;                              p--; // can always return one                          }                            blocks.writeAt = q; r = blocks.Flush(r);                          q = blocks.writeAt; m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;                            if (blocks.readAt != blocks.writeAt)                          {                              blocks.bitb = b; blocks.bitk = k;                              z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                              blocks.writeAt = q;                              return blocks.Flush(r);                          }                          mode = END;                          goto case END;                        case END:                          r = ZlibConstants.Z_STREAM_END;                          blocks.bitb = b; blocks.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          blocks.writeAt = q;                          return blocks.Flush(r);                        case BADCODE:  // x: got error                            r = ZlibConstants.Z_DATA_ERROR;                            blocks.bitb = b; blocks.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          blocks.writeAt = q;                          return blocks.Flush(r);                        default:                          r = ZlibConstants.Z_STREAM_ERROR;                            blocks.bitb = b; blocks.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          blocks.writeAt = q;                          return blocks.Flush(r);                  }
Magic Number,Ionic.Zlib,InflateCodes,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zlib.Shared\Inflate.cs,Process,The following statement contains a magic number: switch (mode)                  {                      // waiting for "i:"=input' "o:"=output' "x:"=nothing                      case START:  // x: set up for LEN                          if (m >= 258 && n >= 10)                          {                              blocks.bitb = b; blocks.bitk = k;                              z.AvailableBytesIn = n;                              z.TotalBytesIn += p - z.NextIn;                              z.NextIn = p;                              blocks.writeAt = q;                              r = InflateFast(lbits' dbits' ltree' ltree_index' dtree' dtree_index' blocks' z);                                p = z.NextIn;                              n = z.AvailableBytesIn;                              b = blocks.bitb;                              k = blocks.bitk;                              q = blocks.writeAt; m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;                                if (r != ZlibConstants.Z_OK)                              {                                  mode = (r == ZlibConstants.Z_STREAM_END) ? WASH : BADCODE;                                  break;                              }                          }                          need = lbits;                          tree = ltree;                          tree_index = ltree_index;                            mode = LEN;                          goto case LEN;                        case LEN:  // i: get length/literal/eob next                          j = need;                            while (k < j)                          {                              if (n != 0)                                  r = ZlibConstants.Z_OK;                              else                              {                                  blocks.bitb = b; blocks.bitk = k;                                  z.AvailableBytesIn = n;                                  z.TotalBytesIn += p - z.NextIn;                                  z.NextIn = p;                                  blocks.writeAt = q;                                  return blocks.Flush(r);                              }                              n--;                              b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            tindex = (tree_index + (b & InternalInflateConstants.InflateMask[j])) * 3;                            b >>= (tree[tindex + 1]);                          k -= (tree[tindex + 1]);                            e = tree[tindex];                            if (e == 0)                          {                              // literal                              lit = tree[tindex + 2];                              mode = LIT;                              break;                          }                          if ((e & 16) != 0)                          {                              // length                              bitsToGet = e & 15;                              len = tree[tindex + 2];                              mode = LENEXT;                              break;                          }                          if ((e & 64) == 0)                          {                              // next table                              need = e;                              tree_index = tindex / 3 + tree[tindex + 2];                              break;                          }                          if ((e & 32) != 0)                          {                              // end of block                              mode = WASH;                              break;                          }                          mode = BADCODE; // invalid code                          z.Message = "invalid literal/length code";                          r = ZlibConstants.Z_DATA_ERROR;                            blocks.bitb = b; blocks.bitk = k;                          z.AvailableBytesIn = n;                          z.TotalBytesIn += p - z.NextIn;                          z.NextIn = p;                          blocks.writeAt = q;                          return blocks.Flush(r);                          case LENEXT:  // i: getting length extra (have base)                          j = bitsToGet;                            while (k < j)                          {                              if (n != 0)                                  r = ZlibConstants.Z_OK;                              else                              {                                  blocks.bitb = b; blocks.bitk = k;                                  z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  blocks.writeAt = q;                                  return blocks.Flush(r);                              }                              n--; b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            len += (b & InternalInflateConstants.InflateMask[j]);                            b >>= j;                          k -= j;                            need = dbits;                          tree = dtree;                          tree_index = dtree_index;                          mode = DIST;                          goto case DIST;                        case DIST:  // i: get distance next                          j = need;                            while (k < j)                          {                              if (n != 0)                                  r = ZlibConstants.Z_OK;                              else                              {                                  blocks.bitb = b; blocks.bitk = k;                                  z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  blocks.writeAt = q;                                  return blocks.Flush(r);                              }                              n--; b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            tindex = (tree_index + (b & InternalInflateConstants.InflateMask[j])) * 3;                            b >>= tree[tindex + 1];                          k -= tree[tindex + 1];                            e = (tree[tindex]);                          if ((e & 0x10) != 0)                          {                              // distance                              bitsToGet = e & 15;                              dist = tree[tindex + 2];                              mode = DISTEXT;                              break;                          }                          if ((e & 64) == 0)                          {                              // next table                              need = e;                              tree_index = tindex / 3 + tree[tindex + 2];                              break;                          }                          mode = BADCODE; // invalid code                          z.Message = "invalid distance code";                          r = ZlibConstants.Z_DATA_ERROR;                            blocks.bitb = b; blocks.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          blocks.writeAt = q;                          return blocks.Flush(r);                          case DISTEXT:  // i: getting distance extra                          j = bitsToGet;                            while (k < j)                          {                              if (n != 0)                                  r = ZlibConstants.Z_OK;                              else                              {                                  blocks.bitb = b; blocks.bitk = k;                                  z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  blocks.writeAt = q;                                  return blocks.Flush(r);                              }                              n--; b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            dist += (b & InternalInflateConstants.InflateMask[j]);                            b >>= j;                          k -= j;                            mode = COPY;                          goto case COPY;                        case COPY:  // o: copying bytes in window' waiting for space                          f = q - dist;                          while (f < 0)                          {                              // modulo window size-"while" instead                              f += blocks.end; // of "if" handles invalid distances                          }                          while (len != 0)                          {                              if (m == 0)                              {                                  if (q == blocks.end && blocks.readAt != 0)                                  {                                      q = 0; m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;                                  }                                  if (m == 0)                                  {                                      blocks.writeAt = q; r = blocks.Flush(r);                                      q = blocks.writeAt; m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;                                        if (q == blocks.end && blocks.readAt != 0)                                      {                                          q = 0; m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;                                      }                                        if (m == 0)                                      {                                          blocks.bitb = b; blocks.bitk = k;                                          z.AvailableBytesIn = n;                                          z.TotalBytesIn += p - z.NextIn;                                          z.NextIn = p;                                          blocks.writeAt = q;                                          return blocks.Flush(r);                                      }                                  }                              }                                blocks.window[q++] = blocks.window[f++]; m--;                                if (f == blocks.end)                                  f = 0;                              len--;                          }                          mode = START;                          break;                        case LIT:  // o: got literal' waiting for output space                          if (m == 0)                          {                              if (q == blocks.end && blocks.readAt != 0)                              {                                  q = 0; m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;                              }                              if (m == 0)                              {                                  blocks.writeAt = q; r = blocks.Flush(r);                                  q = blocks.writeAt; m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;                                    if (q == blocks.end && blocks.readAt != 0)                                  {                                      q = 0; m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;                                  }                                  if (m == 0)                                  {                                      blocks.bitb = b; blocks.bitk = k;                                      z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                      blocks.writeAt = q;                                      return blocks.Flush(r);                                  }                              }                          }                          r = ZlibConstants.Z_OK;                            blocks.window[q++] = (byte)lit; m--;                            mode = START;                          break;                        case WASH:  // o: got eob' possibly more output                          if (k > 7)                          {                              // return unused byte' if any                              k -= 8;                              n++;                              p--; // can always return one                          }                            blocks.writeAt = q; r = blocks.Flush(r);                          q = blocks.writeAt; m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;                            if (blocks.readAt != blocks.writeAt)                          {                              blocks.bitb = b; blocks.bitk = k;                              z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                              blocks.writeAt = q;                              return blocks.Flush(r);                          }                          mode = END;                          goto case END;                        case END:                          r = ZlibConstants.Z_STREAM_END;                          blocks.bitb = b; blocks.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          blocks.writeAt = q;                          return blocks.Flush(r);                        case BADCODE:  // x: got error                            r = ZlibConstants.Z_DATA_ERROR;                            blocks.bitb = b; blocks.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          blocks.writeAt = q;                          return blocks.Flush(r);                        default:                          r = ZlibConstants.Z_STREAM_ERROR;                            blocks.bitb = b; blocks.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          blocks.writeAt = q;                          return blocks.Flush(r);                  }
Magic Number,Ionic.Zlib,InflateCodes,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zlib.Shared\Inflate.cs,Process,The following statement contains a magic number: switch (mode)                  {                      // waiting for "i:"=input' "o:"=output' "x:"=nothing                      case START:  // x: set up for LEN                          if (m >= 258 && n >= 10)                          {                              blocks.bitb = b; blocks.bitk = k;                              z.AvailableBytesIn = n;                              z.TotalBytesIn += p - z.NextIn;                              z.NextIn = p;                              blocks.writeAt = q;                              r = InflateFast(lbits' dbits' ltree' ltree_index' dtree' dtree_index' blocks' z);                                p = z.NextIn;                              n = z.AvailableBytesIn;                              b = blocks.bitb;                              k = blocks.bitk;                              q = blocks.writeAt; m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;                                if (r != ZlibConstants.Z_OK)                              {                                  mode = (r == ZlibConstants.Z_STREAM_END) ? WASH : BADCODE;                                  break;                              }                          }                          need = lbits;                          tree = ltree;                          tree_index = ltree_index;                            mode = LEN;                          goto case LEN;                        case LEN:  // i: get length/literal/eob next                          j = need;                            while (k < j)                          {                              if (n != 0)                                  r = ZlibConstants.Z_OK;                              else                              {                                  blocks.bitb = b; blocks.bitk = k;                                  z.AvailableBytesIn = n;                                  z.TotalBytesIn += p - z.NextIn;                                  z.NextIn = p;                                  blocks.writeAt = q;                                  return blocks.Flush(r);                              }                              n--;                              b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            tindex = (tree_index + (b & InternalInflateConstants.InflateMask[j])) * 3;                            b >>= (tree[tindex + 1]);                          k -= (tree[tindex + 1]);                            e = tree[tindex];                            if (e == 0)                          {                              // literal                              lit = tree[tindex + 2];                              mode = LIT;                              break;                          }                          if ((e & 16) != 0)                          {                              // length                              bitsToGet = e & 15;                              len = tree[tindex + 2];                              mode = LENEXT;                              break;                          }                          if ((e & 64) == 0)                          {                              // next table                              need = e;                              tree_index = tindex / 3 + tree[tindex + 2];                              break;                          }                          if ((e & 32) != 0)                          {                              // end of block                              mode = WASH;                              break;                          }                          mode = BADCODE; // invalid code                          z.Message = "invalid literal/length code";                          r = ZlibConstants.Z_DATA_ERROR;                            blocks.bitb = b; blocks.bitk = k;                          z.AvailableBytesIn = n;                          z.TotalBytesIn += p - z.NextIn;                          z.NextIn = p;                          blocks.writeAt = q;                          return blocks.Flush(r);                          case LENEXT:  // i: getting length extra (have base)                          j = bitsToGet;                            while (k < j)                          {                              if (n != 0)                                  r = ZlibConstants.Z_OK;                              else                              {                                  blocks.bitb = b; blocks.bitk = k;                                  z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  blocks.writeAt = q;                                  return blocks.Flush(r);                              }                              n--; b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            len += (b & InternalInflateConstants.InflateMask[j]);                            b >>= j;                          k -= j;                            need = dbits;                          tree = dtree;                          tree_index = dtree_index;                          mode = DIST;                          goto case DIST;                        case DIST:  // i: get distance next                          j = need;                            while (k < j)                          {                              if (n != 0)                                  r = ZlibConstants.Z_OK;                              else                              {                                  blocks.bitb = b; blocks.bitk = k;                                  z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  blocks.writeAt = q;                                  return blocks.Flush(r);                              }                              n--; b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            tindex = (tree_index + (b & InternalInflateConstants.InflateMask[j])) * 3;                            b >>= tree[tindex + 1];                          k -= tree[tindex + 1];                            e = (tree[tindex]);                          if ((e & 0x10) != 0)                          {                              // distance                              bitsToGet = e & 15;                              dist = tree[tindex + 2];                              mode = DISTEXT;                              break;                          }                          if ((e & 64) == 0)                          {                              // next table                              need = e;                              tree_index = tindex / 3 + tree[tindex + 2];                              break;                          }                          mode = BADCODE; // invalid code                          z.Message = "invalid distance code";                          r = ZlibConstants.Z_DATA_ERROR;                            blocks.bitb = b; blocks.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          blocks.writeAt = q;                          return blocks.Flush(r);                          case DISTEXT:  // i: getting distance extra                          j = bitsToGet;                            while (k < j)                          {                              if (n != 0)                                  r = ZlibConstants.Z_OK;                              else                              {                                  blocks.bitb = b; blocks.bitk = k;                                  z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  blocks.writeAt = q;                                  return blocks.Flush(r);                              }                              n--; b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            dist += (b & InternalInflateConstants.InflateMask[j]);                            b >>= j;                          k -= j;                            mode = COPY;                          goto case COPY;                        case COPY:  // o: copying bytes in window' waiting for space                          f = q - dist;                          while (f < 0)                          {                              // modulo window size-"while" instead                              f += blocks.end; // of "if" handles invalid distances                          }                          while (len != 0)                          {                              if (m == 0)                              {                                  if (q == blocks.end && blocks.readAt != 0)                                  {                                      q = 0; m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;                                  }                                  if (m == 0)                                  {                                      blocks.writeAt = q; r = blocks.Flush(r);                                      q = blocks.writeAt; m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;                                        if (q == blocks.end && blocks.readAt != 0)                                      {                                          q = 0; m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;                                      }                                        if (m == 0)                                      {                                          blocks.bitb = b; blocks.bitk = k;                                          z.AvailableBytesIn = n;                                          z.TotalBytesIn += p - z.NextIn;                                          z.NextIn = p;                                          blocks.writeAt = q;                                          return blocks.Flush(r);                                      }                                  }                              }                                blocks.window[q++] = blocks.window[f++]; m--;                                if (f == blocks.end)                                  f = 0;                              len--;                          }                          mode = START;                          break;                        case LIT:  // o: got literal' waiting for output space                          if (m == 0)                          {                              if (q == blocks.end && blocks.readAt != 0)                              {                                  q = 0; m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;                              }                              if (m == 0)                              {                                  blocks.writeAt = q; r = blocks.Flush(r);                                  q = blocks.writeAt; m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;                                    if (q == blocks.end && blocks.readAt != 0)                                  {                                      q = 0; m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;                                  }                                  if (m == 0)                                  {                                      blocks.bitb = b; blocks.bitk = k;                                      z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                      blocks.writeAt = q;                                      return blocks.Flush(r);                                  }                              }                          }                          r = ZlibConstants.Z_OK;                            blocks.window[q++] = (byte)lit; m--;                            mode = START;                          break;                        case WASH:  // o: got eob' possibly more output                          if (k > 7)                          {                              // return unused byte' if any                              k -= 8;                              n++;                              p--; // can always return one                          }                            blocks.writeAt = q; r = blocks.Flush(r);                          q = blocks.writeAt; m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;                            if (blocks.readAt != blocks.writeAt)                          {                              blocks.bitb = b; blocks.bitk = k;                              z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                              blocks.writeAt = q;                              return blocks.Flush(r);                          }                          mode = END;                          goto case END;                        case END:                          r = ZlibConstants.Z_STREAM_END;                          blocks.bitb = b; blocks.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          blocks.writeAt = q;                          return blocks.Flush(r);                        case BADCODE:  // x: got error                            r = ZlibConstants.Z_DATA_ERROR;                            blocks.bitb = b; blocks.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          blocks.writeAt = q;                          return blocks.Flush(r);                        default:                          r = ZlibConstants.Z_STREAM_ERROR;                            blocks.bitb = b; blocks.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          blocks.writeAt = q;                          return blocks.Flush(r);                  }
Magic Number,Ionic.Zlib,InflateCodes,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zlib.Shared\Inflate.cs,Process,The following statement contains a magic number: switch (mode)                  {                      // waiting for "i:"=input' "o:"=output' "x:"=nothing                      case START:  // x: set up for LEN                          if (m >= 258 && n >= 10)                          {                              blocks.bitb = b; blocks.bitk = k;                              z.AvailableBytesIn = n;                              z.TotalBytesIn += p - z.NextIn;                              z.NextIn = p;                              blocks.writeAt = q;                              r = InflateFast(lbits' dbits' ltree' ltree_index' dtree' dtree_index' blocks' z);                                p = z.NextIn;                              n = z.AvailableBytesIn;                              b = blocks.bitb;                              k = blocks.bitk;                              q = blocks.writeAt; m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;                                if (r != ZlibConstants.Z_OK)                              {                                  mode = (r == ZlibConstants.Z_STREAM_END) ? WASH : BADCODE;                                  break;                              }                          }                          need = lbits;                          tree = ltree;                          tree_index = ltree_index;                            mode = LEN;                          goto case LEN;                        case LEN:  // i: get length/literal/eob next                          j = need;                            while (k < j)                          {                              if (n != 0)                                  r = ZlibConstants.Z_OK;                              else                              {                                  blocks.bitb = b; blocks.bitk = k;                                  z.AvailableBytesIn = n;                                  z.TotalBytesIn += p - z.NextIn;                                  z.NextIn = p;                                  blocks.writeAt = q;                                  return blocks.Flush(r);                              }                              n--;                              b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            tindex = (tree_index + (b & InternalInflateConstants.InflateMask[j])) * 3;                            b >>= (tree[tindex + 1]);                          k -= (tree[tindex + 1]);                            e = tree[tindex];                            if (e == 0)                          {                              // literal                              lit = tree[tindex + 2];                              mode = LIT;                              break;                          }                          if ((e & 16) != 0)                          {                              // length                              bitsToGet = e & 15;                              len = tree[tindex + 2];                              mode = LENEXT;                              break;                          }                          if ((e & 64) == 0)                          {                              // next table                              need = e;                              tree_index = tindex / 3 + tree[tindex + 2];                              break;                          }                          if ((e & 32) != 0)                          {                              // end of block                              mode = WASH;                              break;                          }                          mode = BADCODE; // invalid code                          z.Message = "invalid literal/length code";                          r = ZlibConstants.Z_DATA_ERROR;                            blocks.bitb = b; blocks.bitk = k;                          z.AvailableBytesIn = n;                          z.TotalBytesIn += p - z.NextIn;                          z.NextIn = p;                          blocks.writeAt = q;                          return blocks.Flush(r);                          case LENEXT:  // i: getting length extra (have base)                          j = bitsToGet;                            while (k < j)                          {                              if (n != 0)                                  r = ZlibConstants.Z_OK;                              else                              {                                  blocks.bitb = b; blocks.bitk = k;                                  z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  blocks.writeAt = q;                                  return blocks.Flush(r);                              }                              n--; b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            len += (b & InternalInflateConstants.InflateMask[j]);                            b >>= j;                          k -= j;                            need = dbits;                          tree = dtree;                          tree_index = dtree_index;                          mode = DIST;                          goto case DIST;                        case DIST:  // i: get distance next                          j = need;                            while (k < j)                          {                              if (n != 0)                                  r = ZlibConstants.Z_OK;                              else                              {                                  blocks.bitb = b; blocks.bitk = k;                                  z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  blocks.writeAt = q;                                  return blocks.Flush(r);                              }                              n--; b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            tindex = (tree_index + (b & InternalInflateConstants.InflateMask[j])) * 3;                            b >>= tree[tindex + 1];                          k -= tree[tindex + 1];                            e = (tree[tindex]);                          if ((e & 0x10) != 0)                          {                              // distance                              bitsToGet = e & 15;                              dist = tree[tindex + 2];                              mode = DISTEXT;                              break;                          }                          if ((e & 64) == 0)                          {                              // next table                              need = e;                              tree_index = tindex / 3 + tree[tindex + 2];                              break;                          }                          mode = BADCODE; // invalid code                          z.Message = "invalid distance code";                          r = ZlibConstants.Z_DATA_ERROR;                            blocks.bitb = b; blocks.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          blocks.writeAt = q;                          return blocks.Flush(r);                          case DISTEXT:  // i: getting distance extra                          j = bitsToGet;                            while (k < j)                          {                              if (n != 0)                                  r = ZlibConstants.Z_OK;                              else                              {                                  blocks.bitb = b; blocks.bitk = k;                                  z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  blocks.writeAt = q;                                  return blocks.Flush(r);                              }                              n--; b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            dist += (b & InternalInflateConstants.InflateMask[j]);                            b >>= j;                          k -= j;                            mode = COPY;                          goto case COPY;                        case COPY:  // o: copying bytes in window' waiting for space                          f = q - dist;                          while (f < 0)                          {                              // modulo window size-"while" instead                              f += blocks.end; // of "if" handles invalid distances                          }                          while (len != 0)                          {                              if (m == 0)                              {                                  if (q == blocks.end && blocks.readAt != 0)                                  {                                      q = 0; m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;                                  }                                  if (m == 0)                                  {                                      blocks.writeAt = q; r = blocks.Flush(r);                                      q = blocks.writeAt; m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;                                        if (q == blocks.end && blocks.readAt != 0)                                      {                                          q = 0; m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;                                      }                                        if (m == 0)                                      {                                          blocks.bitb = b; blocks.bitk = k;                                          z.AvailableBytesIn = n;                                          z.TotalBytesIn += p - z.NextIn;                                          z.NextIn = p;                                          blocks.writeAt = q;                                          return blocks.Flush(r);                                      }                                  }                              }                                blocks.window[q++] = blocks.window[f++]; m--;                                if (f == blocks.end)                                  f = 0;                              len--;                          }                          mode = START;                          break;                        case LIT:  // o: got literal' waiting for output space                          if (m == 0)                          {                              if (q == blocks.end && blocks.readAt != 0)                              {                                  q = 0; m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;                              }                              if (m == 0)                              {                                  blocks.writeAt = q; r = blocks.Flush(r);                                  q = blocks.writeAt; m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;                                    if (q == blocks.end && blocks.readAt != 0)                                  {                                      q = 0; m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;                                  }                                  if (m == 0)                                  {                                      blocks.bitb = b; blocks.bitk = k;                                      z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                      blocks.writeAt = q;                                      return blocks.Flush(r);                                  }                              }                          }                          r = ZlibConstants.Z_OK;                            blocks.window[q++] = (byte)lit; m--;                            mode = START;                          break;                        case WASH:  // o: got eob' possibly more output                          if (k > 7)                          {                              // return unused byte' if any                              k -= 8;                              n++;                              p--; // can always return one                          }                            blocks.writeAt = q; r = blocks.Flush(r);                          q = blocks.writeAt; m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;                            if (blocks.readAt != blocks.writeAt)                          {                              blocks.bitb = b; blocks.bitk = k;                              z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                              blocks.writeAt = q;                              return blocks.Flush(r);                          }                          mode = END;                          goto case END;                        case END:                          r = ZlibConstants.Z_STREAM_END;                          blocks.bitb = b; blocks.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          blocks.writeAt = q;                          return blocks.Flush(r);                        case BADCODE:  // x: got error                            r = ZlibConstants.Z_DATA_ERROR;                            blocks.bitb = b; blocks.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          blocks.writeAt = q;                          return blocks.Flush(r);                        default:                          r = ZlibConstants.Z_STREAM_ERROR;                            blocks.bitb = b; blocks.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          blocks.writeAt = q;                          return blocks.Flush(r);                  }
Magic Number,Ionic.Zlib,InflateCodes,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zlib.Shared\Inflate.cs,Process,The following statement contains a magic number: switch (mode)                  {                      // waiting for "i:"=input' "o:"=output' "x:"=nothing                      case START:  // x: set up for LEN                          if (m >= 258 && n >= 10)                          {                              blocks.bitb = b; blocks.bitk = k;                              z.AvailableBytesIn = n;                              z.TotalBytesIn += p - z.NextIn;                              z.NextIn = p;                              blocks.writeAt = q;                              r = InflateFast(lbits' dbits' ltree' ltree_index' dtree' dtree_index' blocks' z);                                p = z.NextIn;                              n = z.AvailableBytesIn;                              b = blocks.bitb;                              k = blocks.bitk;                              q = blocks.writeAt; m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;                                if (r != ZlibConstants.Z_OK)                              {                                  mode = (r == ZlibConstants.Z_STREAM_END) ? WASH : BADCODE;                                  break;                              }                          }                          need = lbits;                          tree = ltree;                          tree_index = ltree_index;                            mode = LEN;                          goto case LEN;                        case LEN:  // i: get length/literal/eob next                          j = need;                            while (k < j)                          {                              if (n != 0)                                  r = ZlibConstants.Z_OK;                              else                              {                                  blocks.bitb = b; blocks.bitk = k;                                  z.AvailableBytesIn = n;                                  z.TotalBytesIn += p - z.NextIn;                                  z.NextIn = p;                                  blocks.writeAt = q;                                  return blocks.Flush(r);                              }                              n--;                              b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            tindex = (tree_index + (b & InternalInflateConstants.InflateMask[j])) * 3;                            b >>= (tree[tindex + 1]);                          k -= (tree[tindex + 1]);                            e = tree[tindex];                            if (e == 0)                          {                              // literal                              lit = tree[tindex + 2];                              mode = LIT;                              break;                          }                          if ((e & 16) != 0)                          {                              // length                              bitsToGet = e & 15;                              len = tree[tindex + 2];                              mode = LENEXT;                              break;                          }                          if ((e & 64) == 0)                          {                              // next table                              need = e;                              tree_index = tindex / 3 + tree[tindex + 2];                              break;                          }                          if ((e & 32) != 0)                          {                              // end of block                              mode = WASH;                              break;                          }                          mode = BADCODE; // invalid code                          z.Message = "invalid literal/length code";                          r = ZlibConstants.Z_DATA_ERROR;                            blocks.bitb = b; blocks.bitk = k;                          z.AvailableBytesIn = n;                          z.TotalBytesIn += p - z.NextIn;                          z.NextIn = p;                          blocks.writeAt = q;                          return blocks.Flush(r);                          case LENEXT:  // i: getting length extra (have base)                          j = bitsToGet;                            while (k < j)                          {                              if (n != 0)                                  r = ZlibConstants.Z_OK;                              else                              {                                  blocks.bitb = b; blocks.bitk = k;                                  z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  blocks.writeAt = q;                                  return blocks.Flush(r);                              }                              n--; b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            len += (b & InternalInflateConstants.InflateMask[j]);                            b >>= j;                          k -= j;                            need = dbits;                          tree = dtree;                          tree_index = dtree_index;                          mode = DIST;                          goto case DIST;                        case DIST:  // i: get distance next                          j = need;                            while (k < j)                          {                              if (n != 0)                                  r = ZlibConstants.Z_OK;                              else                              {                                  blocks.bitb = b; blocks.bitk = k;                                  z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  blocks.writeAt = q;                                  return blocks.Flush(r);                              }                              n--; b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            tindex = (tree_index + (b & InternalInflateConstants.InflateMask[j])) * 3;                            b >>= tree[tindex + 1];                          k -= tree[tindex + 1];                            e = (tree[tindex]);                          if ((e & 0x10) != 0)                          {                              // distance                              bitsToGet = e & 15;                              dist = tree[tindex + 2];                              mode = DISTEXT;                              break;                          }                          if ((e & 64) == 0)                          {                              // next table                              need = e;                              tree_index = tindex / 3 + tree[tindex + 2];                              break;                          }                          mode = BADCODE; // invalid code                          z.Message = "invalid distance code";                          r = ZlibConstants.Z_DATA_ERROR;                            blocks.bitb = b; blocks.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          blocks.writeAt = q;                          return blocks.Flush(r);                          case DISTEXT:  // i: getting distance extra                          j = bitsToGet;                            while (k < j)                          {                              if (n != 0)                                  r = ZlibConstants.Z_OK;                              else                              {                                  blocks.bitb = b; blocks.bitk = k;                                  z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  blocks.writeAt = q;                                  return blocks.Flush(r);                              }                              n--; b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            dist += (b & InternalInflateConstants.InflateMask[j]);                            b >>= j;                          k -= j;                            mode = COPY;                          goto case COPY;                        case COPY:  // o: copying bytes in window' waiting for space                          f = q - dist;                          while (f < 0)                          {                              // modulo window size-"while" instead                              f += blocks.end; // of "if" handles invalid distances                          }                          while (len != 0)                          {                              if (m == 0)                              {                                  if (q == blocks.end && blocks.readAt != 0)                                  {                                      q = 0; m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;                                  }                                  if (m == 0)                                  {                                      blocks.writeAt = q; r = blocks.Flush(r);                                      q = blocks.writeAt; m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;                                        if (q == blocks.end && blocks.readAt != 0)                                      {                                          q = 0; m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;                                      }                                        if (m == 0)                                      {                                          blocks.bitb = b; blocks.bitk = k;                                          z.AvailableBytesIn = n;                                          z.TotalBytesIn += p - z.NextIn;                                          z.NextIn = p;                                          blocks.writeAt = q;                                          return blocks.Flush(r);                                      }                                  }                              }                                blocks.window[q++] = blocks.window[f++]; m--;                                if (f == blocks.end)                                  f = 0;                              len--;                          }                          mode = START;                          break;                        case LIT:  // o: got literal' waiting for output space                          if (m == 0)                          {                              if (q == blocks.end && blocks.readAt != 0)                              {                                  q = 0; m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;                              }                              if (m == 0)                              {                                  blocks.writeAt = q; r = blocks.Flush(r);                                  q = blocks.writeAt; m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;                                    if (q == blocks.end && blocks.readAt != 0)                                  {                                      q = 0; m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;                                  }                                  if (m == 0)                                  {                                      blocks.bitb = b; blocks.bitk = k;                                      z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                      blocks.writeAt = q;                                      return blocks.Flush(r);                                  }                              }                          }                          r = ZlibConstants.Z_OK;                            blocks.window[q++] = (byte)lit; m--;                            mode = START;                          break;                        case WASH:  // o: got eob' possibly more output                          if (k > 7)                          {                              // return unused byte' if any                              k -= 8;                              n++;                              p--; // can always return one                          }                            blocks.writeAt = q; r = blocks.Flush(r);                          q = blocks.writeAt; m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;                            if (blocks.readAt != blocks.writeAt)                          {                              blocks.bitb = b; blocks.bitk = k;                              z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                              blocks.writeAt = q;                              return blocks.Flush(r);                          }                          mode = END;                          goto case END;                        case END:                          r = ZlibConstants.Z_STREAM_END;                          blocks.bitb = b; blocks.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          blocks.writeAt = q;                          return blocks.Flush(r);                        case BADCODE:  // x: got error                            r = ZlibConstants.Z_DATA_ERROR;                            blocks.bitb = b; blocks.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          blocks.writeAt = q;                          return blocks.Flush(r);                        default:                          r = ZlibConstants.Z_STREAM_ERROR;                            blocks.bitb = b; blocks.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          blocks.writeAt = q;                          return blocks.Flush(r);                  }
Magic Number,Ionic.Zlib,InflateCodes,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zlib.Shared\Inflate.cs,Process,The following statement contains a magic number: switch (mode)                  {                      // waiting for "i:"=input' "o:"=output' "x:"=nothing                      case START:  // x: set up for LEN                          if (m >= 258 && n >= 10)                          {                              blocks.bitb = b; blocks.bitk = k;                              z.AvailableBytesIn = n;                              z.TotalBytesIn += p - z.NextIn;                              z.NextIn = p;                              blocks.writeAt = q;                              r = InflateFast(lbits' dbits' ltree' ltree_index' dtree' dtree_index' blocks' z);                                p = z.NextIn;                              n = z.AvailableBytesIn;                              b = blocks.bitb;                              k = blocks.bitk;                              q = blocks.writeAt; m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;                                if (r != ZlibConstants.Z_OK)                              {                                  mode = (r == ZlibConstants.Z_STREAM_END) ? WASH : BADCODE;                                  break;                              }                          }                          need = lbits;                          tree = ltree;                          tree_index = ltree_index;                            mode = LEN;                          goto case LEN;                        case LEN:  // i: get length/literal/eob next                          j = need;                            while (k < j)                          {                              if (n != 0)                                  r = ZlibConstants.Z_OK;                              else                              {                                  blocks.bitb = b; blocks.bitk = k;                                  z.AvailableBytesIn = n;                                  z.TotalBytesIn += p - z.NextIn;                                  z.NextIn = p;                                  blocks.writeAt = q;                                  return blocks.Flush(r);                              }                              n--;                              b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            tindex = (tree_index + (b & InternalInflateConstants.InflateMask[j])) * 3;                            b >>= (tree[tindex + 1]);                          k -= (tree[tindex + 1]);                            e = tree[tindex];                            if (e == 0)                          {                              // literal                              lit = tree[tindex + 2];                              mode = LIT;                              break;                          }                          if ((e & 16) != 0)                          {                              // length                              bitsToGet = e & 15;                              len = tree[tindex + 2];                              mode = LENEXT;                              break;                          }                          if ((e & 64) == 0)                          {                              // next table                              need = e;                              tree_index = tindex / 3 + tree[tindex + 2];                              break;                          }                          if ((e & 32) != 0)                          {                              // end of block                              mode = WASH;                              break;                          }                          mode = BADCODE; // invalid code                          z.Message = "invalid literal/length code";                          r = ZlibConstants.Z_DATA_ERROR;                            blocks.bitb = b; blocks.bitk = k;                          z.AvailableBytesIn = n;                          z.TotalBytesIn += p - z.NextIn;                          z.NextIn = p;                          blocks.writeAt = q;                          return blocks.Flush(r);                          case LENEXT:  // i: getting length extra (have base)                          j = bitsToGet;                            while (k < j)                          {                              if (n != 0)                                  r = ZlibConstants.Z_OK;                              else                              {                                  blocks.bitb = b; blocks.bitk = k;                                  z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  blocks.writeAt = q;                                  return blocks.Flush(r);                              }                              n--; b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            len += (b & InternalInflateConstants.InflateMask[j]);                            b >>= j;                          k -= j;                            need = dbits;                          tree = dtree;                          tree_index = dtree_index;                          mode = DIST;                          goto case DIST;                        case DIST:  // i: get distance next                          j = need;                            while (k < j)                          {                              if (n != 0)                                  r = ZlibConstants.Z_OK;                              else                              {                                  blocks.bitb = b; blocks.bitk = k;                                  z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  blocks.writeAt = q;                                  return blocks.Flush(r);                              }                              n--; b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            tindex = (tree_index + (b & InternalInflateConstants.InflateMask[j])) * 3;                            b >>= tree[tindex + 1];                          k -= tree[tindex + 1];                            e = (tree[tindex]);                          if ((e & 0x10) != 0)                          {                              // distance                              bitsToGet = e & 15;                              dist = tree[tindex + 2];                              mode = DISTEXT;                              break;                          }                          if ((e & 64) == 0)                          {                              // next table                              need = e;                              tree_index = tindex / 3 + tree[tindex + 2];                              break;                          }                          mode = BADCODE; // invalid code                          z.Message = "invalid distance code";                          r = ZlibConstants.Z_DATA_ERROR;                            blocks.bitb = b; blocks.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          blocks.writeAt = q;                          return blocks.Flush(r);                          case DISTEXT:  // i: getting distance extra                          j = bitsToGet;                            while (k < j)                          {                              if (n != 0)                                  r = ZlibConstants.Z_OK;                              else                              {                                  blocks.bitb = b; blocks.bitk = k;                                  z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                  blocks.writeAt = q;                                  return blocks.Flush(r);                              }                              n--; b |= (z.InputBuffer[p++] & 0xff) << k;                              k += 8;                          }                            dist += (b & InternalInflateConstants.InflateMask[j]);                            b >>= j;                          k -= j;                            mode = COPY;                          goto case COPY;                        case COPY:  // o: copying bytes in window' waiting for space                          f = q - dist;                          while (f < 0)                          {                              // modulo window size-"while" instead                              f += blocks.end; // of "if" handles invalid distances                          }                          while (len != 0)                          {                              if (m == 0)                              {                                  if (q == blocks.end && blocks.readAt != 0)                                  {                                      q = 0; m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;                                  }                                  if (m == 0)                                  {                                      blocks.writeAt = q; r = blocks.Flush(r);                                      q = blocks.writeAt; m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;                                        if (q == blocks.end && blocks.readAt != 0)                                      {                                          q = 0; m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;                                      }                                        if (m == 0)                                      {                                          blocks.bitb = b; blocks.bitk = k;                                          z.AvailableBytesIn = n;                                          z.TotalBytesIn += p - z.NextIn;                                          z.NextIn = p;                                          blocks.writeAt = q;                                          return blocks.Flush(r);                                      }                                  }                              }                                blocks.window[q++] = blocks.window[f++]; m--;                                if (f == blocks.end)                                  f = 0;                              len--;                          }                          mode = START;                          break;                        case LIT:  // o: got literal' waiting for output space                          if (m == 0)                          {                              if (q == blocks.end && blocks.readAt != 0)                              {                                  q = 0; m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;                              }                              if (m == 0)                              {                                  blocks.writeAt = q; r = blocks.Flush(r);                                  q = blocks.writeAt; m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;                                    if (q == blocks.end && blocks.readAt != 0)                                  {                                      q = 0; m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;                                  }                                  if (m == 0)                                  {                                      blocks.bitb = b; blocks.bitk = k;                                      z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                                      blocks.writeAt = q;                                      return blocks.Flush(r);                                  }                              }                          }                          r = ZlibConstants.Z_OK;                            blocks.window[q++] = (byte)lit; m--;                            mode = START;                          break;                        case WASH:  // o: got eob' possibly more output                          if (k > 7)                          {                              // return unused byte' if any                              k -= 8;                              n++;                              p--; // can always return one                          }                            blocks.writeAt = q; r = blocks.Flush(r);                          q = blocks.writeAt; m = q < blocks.readAt ? blocks.readAt - q - 1 : blocks.end - q;                            if (blocks.readAt != blocks.writeAt)                          {                              blocks.bitb = b; blocks.bitk = k;                              z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                              blocks.writeAt = q;                              return blocks.Flush(r);                          }                          mode = END;                          goto case END;                        case END:                          r = ZlibConstants.Z_STREAM_END;                          blocks.bitb = b; blocks.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          blocks.writeAt = q;                          return blocks.Flush(r);                        case BADCODE:  // x: got error                            r = ZlibConstants.Z_DATA_ERROR;                            blocks.bitb = b; blocks.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          blocks.writeAt = q;                          return blocks.Flush(r);                        default:                          r = ZlibConstants.Z_STREAM_ERROR;                            blocks.bitb = b; blocks.bitk = k;                          z.AvailableBytesIn = n; z.TotalBytesIn += p - z.NextIn; z.NextIn = p;                          blocks.writeAt = q;                          return blocks.Flush(r);                  }
Magic Number,Ionic.Zlib,InflateCodes,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zlib.Shared\Inflate.cs,InflateFast,The following statement contains a magic number: k += 8;
Magic Number,Ionic.Zlib,InflateCodes,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zlib.Shared\Inflate.cs,InflateFast,The following statement contains a magic number: k < (20)
Magic Number,Ionic.Zlib,InflateCodes,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zlib.Shared\Inflate.cs,InflateFast,The following statement contains a magic number: tp_index_t_3 = (tp_index + t) * 3;
Magic Number,Ionic.Zlib,InflateCodes,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zlib.Shared\Inflate.cs,InflateFast,The following statement contains a magic number: s.window[q++] = (byte)tp[tp_index_t_3 + 2];
Magic Number,Ionic.Zlib,InflateCodes,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zlib.Shared\Inflate.cs,InflateFast,The following statement contains a magic number: e &= 15;
Magic Number,Ionic.Zlib,InflateCodes,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zlib.Shared\Inflate.cs,InflateFast,The following statement contains a magic number: c = tp[tp_index_t_3 + 2] + ((int)b & InternalInflateConstants.InflateMask[e]);
Magic Number,Ionic.Zlib,InflateCodes,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zlib.Shared\Inflate.cs,InflateFast,The following statement contains a magic number: k += 8;
Magic Number,Ionic.Zlib,InflateCodes,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zlib.Shared\Inflate.cs,InflateFast,The following statement contains a magic number: k < 15
Magic Number,Ionic.Zlib,InflateCodes,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zlib.Shared\Inflate.cs,InflateFast,The following statement contains a magic number: tp_index_t_3 = (tp_index + t) * 3;
Magic Number,Ionic.Zlib,InflateCodes,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zlib.Shared\Inflate.cs,InflateFast,The following statement contains a magic number: e &= 15;
Magic Number,Ionic.Zlib,InflateCodes,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zlib.Shared\Inflate.cs,InflateFast,The following statement contains a magic number: k += 8;
Magic Number,Ionic.Zlib,InflateCodes,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zlib.Shared\Inflate.cs,InflateFast,The following statement contains a magic number: d = tp[tp_index_t_3 + 2] + (b & InternalInflateConstants.InflateMask[e]);
Magic Number,Ionic.Zlib,InflateCodes,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zlib.Shared\Inflate.cs,InflateFast,The following statement contains a magic number: c -= 2;
Magic Number,Ionic.Zlib,InflateCodes,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zlib.Shared\Inflate.cs,InflateFast,The following statement contains a magic number: q - r > 0 && 2 > (q - r)
Magic Number,Ionic.Zlib,InflateCodes,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zlib.Shared\Inflate.cs,InflateFast,The following statement contains a magic number: (e & 16) != 0
Magic Number,Ionic.Zlib,InflateCodes,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zlib.Shared\Inflate.cs,InflateFast,The following statement contains a magic number: (e & 16) != 0
Magic Number,Ionic.Zlib,InflateCodes,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zlib.Shared\Inflate.cs,InflateFast,The following statement contains a magic number: t += tp[tp_index_t_3 + 2];
Magic Number,Ionic.Zlib,InflateCodes,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zlib.Shared\Inflate.cs,InflateFast,The following statement contains a magic number: tp_index_t_3 = (tp_index + t) * 3;
Magic Number,Ionic.Zlib,InflateCodes,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zlib.Shared\Inflate.cs,InflateFast,The following statement contains a magic number: s.window[q++] = (byte)tp[tp_index_t_3 + 2];
Magic Number,Ionic.Zlib,InflateCodes,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zlib.Shared\Inflate.cs,InflateFast,The following statement contains a magic number: (e & 64) == 0
Magic Number,Ionic.Zlib,InflateCodes,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zlib.Shared\Inflate.cs,InflateFast,The following statement contains a magic number: c = (k >> 3) < c ? k >> 3 : c;
Magic Number,Ionic.Zlib,InflateCodes,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zlib.Shared\Inflate.cs,InflateFast,The following statement contains a magic number: c = (k >> 3) < c ? k >> 3 : c;
Magic Number,Ionic.Zlib,InflateCodes,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zlib.Shared\Inflate.cs,InflateFast,The following statement contains a magic number: k -= (c << 3);
Magic Number,Ionic.Zlib,InflateManager,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zlib.Shared\Inflate.cs,Initialize,The following statement contains a magic number: w < 8 || w > 15
Magic Number,Ionic.Zlib,InflateManager,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zlib.Shared\Inflate.cs,Initialize,The following statement contains a magic number: w < 8 || w > 15
Magic Number,Ionic.Zlib,InflateManager,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zlib.Shared\Inflate.cs,Inflate,The following statement contains a magic number: switch (mode)                  {                      case InflateManagerMode.METHOD:                          if (_codec.AvailableBytesIn == 0) return r;                          r = f;                          _codec.AvailableBytesIn--;                          _codec.TotalBytesIn++;                          if (((method = _codec.InputBuffer[_codec.NextIn++]) & 0xf) != Z_DEFLATED)                          {                              mode = InflateManagerMode.BAD;                              _codec.Message = String.Format("unknown compression method (0x{0:X2})"' method);                              marker = 5; // can't try inflateSync                              break;                          }                          if ((method >> 4) + 8 > wbits)                          {                              mode = InflateManagerMode.BAD;                              _codec.Message = String.Format("invalid window size ({0})"' (method >> 4) + 8);                              marker = 5; // can't try inflateSync                              break;                          }                          mode = InflateManagerMode.FLAG;                          break;                          case InflateManagerMode.FLAG:                          if (_codec.AvailableBytesIn == 0) return r;                          r = f;                          _codec.AvailableBytesIn--;                          _codec.TotalBytesIn++;                          b = (_codec.InputBuffer[_codec.NextIn++]) & 0xff;                            if ((((method << 8) + b) % 31) != 0)                          {                              mode = InflateManagerMode.BAD;                              _codec.Message = "incorrect header check";                              marker = 5; // can't try inflateSync                              break;                          }                            mode = ((b & PRESET_DICT) == 0)                              ? InflateManagerMode.BLOCKS                              : InflateManagerMode.DICT4;                          break;                        case InflateManagerMode.DICT4:                          if (_codec.AvailableBytesIn == 0) return r;                          r = f;                          _codec.AvailableBytesIn--;                          _codec.TotalBytesIn++;                          expectedCheck = (uint)((_codec.InputBuffer[_codec.NextIn++] << 24) & 0xff000000);                          mode = InflateManagerMode.DICT3;                          break;                        case InflateManagerMode.DICT3:                          if (_codec.AvailableBytesIn == 0) return r;                          r = f;                          _codec.AvailableBytesIn--;                          _codec.TotalBytesIn++;                          expectedCheck += (uint)((_codec.InputBuffer[_codec.NextIn++] << 16) & 0x00ff0000);                          mode = InflateManagerMode.DICT2;                          break;                        case InflateManagerMode.DICT2:                            if (_codec.AvailableBytesIn == 0) return r;                          r = f;                          _codec.AvailableBytesIn--;                          _codec.TotalBytesIn++;                          expectedCheck += (uint)((_codec.InputBuffer[_codec.NextIn++] << 8) & 0x0000ff00);                          mode = InflateManagerMode.DICT1;                          break;                          case InflateManagerMode.DICT1:                          if (_codec.AvailableBytesIn == 0) return r;                          r = f;                          _codec.AvailableBytesIn--; _codec.TotalBytesIn++;                          expectedCheck += (uint)(_codec.InputBuffer[_codec.NextIn++] & 0x000000ff);                          _codec._Adler32 = expectedCheck;                          mode = InflateManagerMode.DICT0;                          return ZlibConstants.Z_NEED_DICT;                          case InflateManagerMode.DICT0:                          mode = InflateManagerMode.BAD;                          _codec.Message = "need dictionary";                          marker = 0; // can try inflateSync                          return ZlibConstants.Z_STREAM_ERROR;                          case InflateManagerMode.BLOCKS:                          r = blocks.Process(r);                          if (r == ZlibConstants.Z_DATA_ERROR)                          {                              mode = InflateManagerMode.BAD;                              marker = 0; // can try inflateSync                              break;                          }                            if (r == ZlibConstants.Z_OK) r = f;                            if (r != ZlibConstants.Z_STREAM_END)                              return r;                            r = f;                          computedCheck = blocks.Reset();                          if (!HandleRfc1950HeaderBytes)                          {                              mode = InflateManagerMode.DONE;                              return ZlibConstants.Z_STREAM_END;                          }                          mode = InflateManagerMode.CHECK4;                          break;                        case InflateManagerMode.CHECK4:                          if (_codec.AvailableBytesIn == 0) return r;                          r = f;                          _codec.AvailableBytesIn--;                          _codec.TotalBytesIn++;                          expectedCheck = (uint)((_codec.InputBuffer[_codec.NextIn++] << 24) & 0xff000000);                          mode = InflateManagerMode.CHECK3;                          break;                        case InflateManagerMode.CHECK3:                          if (_codec.AvailableBytesIn == 0) return r;                          r = f;                          _codec.AvailableBytesIn--; _codec.TotalBytesIn++;                          expectedCheck += (uint)((_codec.InputBuffer[_codec.NextIn++] << 16) & 0x00ff0000);                          mode = InflateManagerMode.CHECK2;                          break;                        case InflateManagerMode.CHECK2:                          if (_codec.AvailableBytesIn == 0) return r;                          r = f;                          _codec.AvailableBytesIn--;                          _codec.TotalBytesIn++;                          expectedCheck += (uint)((_codec.InputBuffer[_codec.NextIn++] << 8) & 0x0000ff00);                          mode = InflateManagerMode.CHECK1;                          break;                        case InflateManagerMode.CHECK1:                          if (_codec.AvailableBytesIn == 0) return r;                          r = f;                          _codec.AvailableBytesIn--; _codec.TotalBytesIn++;                          expectedCheck += (uint)(_codec.InputBuffer[_codec.NextIn++] & 0x000000ff);                          if (computedCheck != expectedCheck)                          {                              mode = InflateManagerMode.BAD;                              _codec.Message = "incorrect data check";                              marker = 5; // can't try inflateSync                              break;                          }                          mode = InflateManagerMode.DONE;                          return ZlibConstants.Z_STREAM_END;                        case InflateManagerMode.DONE:                          return ZlibConstants.Z_STREAM_END;                        case InflateManagerMode.BAD:                          throw new ZlibException(String.Format("Bad state ({0})"' _codec.Message));                        default:                          throw new ZlibException("Stream error.");                    }
Magic Number,Ionic.Zlib,InflateManager,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zlib.Shared\Inflate.cs,Inflate,The following statement contains a magic number: switch (mode)                  {                      case InflateManagerMode.METHOD:                          if (_codec.AvailableBytesIn == 0) return r;                          r = f;                          _codec.AvailableBytesIn--;                          _codec.TotalBytesIn++;                          if (((method = _codec.InputBuffer[_codec.NextIn++]) & 0xf) != Z_DEFLATED)                          {                              mode = InflateManagerMode.BAD;                              _codec.Message = String.Format("unknown compression method (0x{0:X2})"' method);                              marker = 5; // can't try inflateSync                              break;                          }                          if ((method >> 4) + 8 > wbits)                          {                              mode = InflateManagerMode.BAD;                              _codec.Message = String.Format("invalid window size ({0})"' (method >> 4) + 8);                              marker = 5; // can't try inflateSync                              break;                          }                          mode = InflateManagerMode.FLAG;                          break;                          case InflateManagerMode.FLAG:                          if (_codec.AvailableBytesIn == 0) return r;                          r = f;                          _codec.AvailableBytesIn--;                          _codec.TotalBytesIn++;                          b = (_codec.InputBuffer[_codec.NextIn++]) & 0xff;                            if ((((method << 8) + b) % 31) != 0)                          {                              mode = InflateManagerMode.BAD;                              _codec.Message = "incorrect header check";                              marker = 5; // can't try inflateSync                              break;                          }                            mode = ((b & PRESET_DICT) == 0)                              ? InflateManagerMode.BLOCKS                              : InflateManagerMode.DICT4;                          break;                        case InflateManagerMode.DICT4:                          if (_codec.AvailableBytesIn == 0) return r;                          r = f;                          _codec.AvailableBytesIn--;                          _codec.TotalBytesIn++;                          expectedCheck = (uint)((_codec.InputBuffer[_codec.NextIn++] << 24) & 0xff000000);                          mode = InflateManagerMode.DICT3;                          break;                        case InflateManagerMode.DICT3:                          if (_codec.AvailableBytesIn == 0) return r;                          r = f;                          _codec.AvailableBytesIn--;                          _codec.TotalBytesIn++;                          expectedCheck += (uint)((_codec.InputBuffer[_codec.NextIn++] << 16) & 0x00ff0000);                          mode = InflateManagerMode.DICT2;                          break;                        case InflateManagerMode.DICT2:                            if (_codec.AvailableBytesIn == 0) return r;                          r = f;                          _codec.AvailableBytesIn--;                          _codec.TotalBytesIn++;                          expectedCheck += (uint)((_codec.InputBuffer[_codec.NextIn++] << 8) & 0x0000ff00);                          mode = InflateManagerMode.DICT1;                          break;                          case InflateManagerMode.DICT1:                          if (_codec.AvailableBytesIn == 0) return r;                          r = f;                          _codec.AvailableBytesIn--; _codec.TotalBytesIn++;                          expectedCheck += (uint)(_codec.InputBuffer[_codec.NextIn++] & 0x000000ff);                          _codec._Adler32 = expectedCheck;                          mode = InflateManagerMode.DICT0;                          return ZlibConstants.Z_NEED_DICT;                          case InflateManagerMode.DICT0:                          mode = InflateManagerMode.BAD;                          _codec.Message = "need dictionary";                          marker = 0; // can try inflateSync                          return ZlibConstants.Z_STREAM_ERROR;                          case InflateManagerMode.BLOCKS:                          r = blocks.Process(r);                          if (r == ZlibConstants.Z_DATA_ERROR)                          {                              mode = InflateManagerMode.BAD;                              marker = 0; // can try inflateSync                              break;                          }                            if (r == ZlibConstants.Z_OK) r = f;                            if (r != ZlibConstants.Z_STREAM_END)                              return r;                            r = f;                          computedCheck = blocks.Reset();                          if (!HandleRfc1950HeaderBytes)                          {                              mode = InflateManagerMode.DONE;                              return ZlibConstants.Z_STREAM_END;                          }                          mode = InflateManagerMode.CHECK4;                          break;                        case InflateManagerMode.CHECK4:                          if (_codec.AvailableBytesIn == 0) return r;                          r = f;                          _codec.AvailableBytesIn--;                          _codec.TotalBytesIn++;                          expectedCheck = (uint)((_codec.InputBuffer[_codec.NextIn++] << 24) & 0xff000000);                          mode = InflateManagerMode.CHECK3;                          break;                        case InflateManagerMode.CHECK3:                          if (_codec.AvailableBytesIn == 0) return r;                          r = f;                          _codec.AvailableBytesIn--; _codec.TotalBytesIn++;                          expectedCheck += (uint)((_codec.InputBuffer[_codec.NextIn++] << 16) & 0x00ff0000);                          mode = InflateManagerMode.CHECK2;                          break;                        case InflateManagerMode.CHECK2:                          if (_codec.AvailableBytesIn == 0) return r;                          r = f;                          _codec.AvailableBytesIn--;                          _codec.TotalBytesIn++;                          expectedCheck += (uint)((_codec.InputBuffer[_codec.NextIn++] << 8) & 0x0000ff00);                          mode = InflateManagerMode.CHECK1;                          break;                        case InflateManagerMode.CHECK1:                          if (_codec.AvailableBytesIn == 0) return r;                          r = f;                          _codec.AvailableBytesIn--; _codec.TotalBytesIn++;                          expectedCheck += (uint)(_codec.InputBuffer[_codec.NextIn++] & 0x000000ff);                          if (computedCheck != expectedCheck)                          {                              mode = InflateManagerMode.BAD;                              _codec.Message = "incorrect data check";                              marker = 5; // can't try inflateSync                              break;                          }                          mode = InflateManagerMode.DONE;                          return ZlibConstants.Z_STREAM_END;                        case InflateManagerMode.DONE:                          return ZlibConstants.Z_STREAM_END;                        case InflateManagerMode.BAD:                          throw new ZlibException(String.Format("Bad state ({0})"' _codec.Message));                        default:                          throw new ZlibException("Stream error.");                    }
Magic Number,Ionic.Zlib,InflateManager,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zlib.Shared\Inflate.cs,Inflate,The following statement contains a magic number: switch (mode)                  {                      case InflateManagerMode.METHOD:                          if (_codec.AvailableBytesIn == 0) return r;                          r = f;                          _codec.AvailableBytesIn--;                          _codec.TotalBytesIn++;                          if (((method = _codec.InputBuffer[_codec.NextIn++]) & 0xf) != Z_DEFLATED)                          {                              mode = InflateManagerMode.BAD;                              _codec.Message = String.Format("unknown compression method (0x{0:X2})"' method);                              marker = 5; // can't try inflateSync                              break;                          }                          if ((method >> 4) + 8 > wbits)                          {                              mode = InflateManagerMode.BAD;                              _codec.Message = String.Format("invalid window size ({0})"' (method >> 4) + 8);                              marker = 5; // can't try inflateSync                              break;                          }                          mode = InflateManagerMode.FLAG;                          break;                          case InflateManagerMode.FLAG:                          if (_codec.AvailableBytesIn == 0) return r;                          r = f;                          _codec.AvailableBytesIn--;                          _codec.TotalBytesIn++;                          b = (_codec.InputBuffer[_codec.NextIn++]) & 0xff;                            if ((((method << 8) + b) % 31) != 0)                          {                              mode = InflateManagerMode.BAD;                              _codec.Message = "incorrect header check";                              marker = 5; // can't try inflateSync                              break;                          }                            mode = ((b & PRESET_DICT) == 0)                              ? InflateManagerMode.BLOCKS                              : InflateManagerMode.DICT4;                          break;                        case InflateManagerMode.DICT4:                          if (_codec.AvailableBytesIn == 0) return r;                          r = f;                          _codec.AvailableBytesIn--;                          _codec.TotalBytesIn++;                          expectedCheck = (uint)((_codec.InputBuffer[_codec.NextIn++] << 24) & 0xff000000);                          mode = InflateManagerMode.DICT3;                          break;                        case InflateManagerMode.DICT3:                          if (_codec.AvailableBytesIn == 0) return r;                          r = f;                          _codec.AvailableBytesIn--;                          _codec.TotalBytesIn++;                          expectedCheck += (uint)((_codec.InputBuffer[_codec.NextIn++] << 16) & 0x00ff0000);                          mode = InflateManagerMode.DICT2;                          break;                        case InflateManagerMode.DICT2:                            if (_codec.AvailableBytesIn == 0) return r;                          r = f;                          _codec.AvailableBytesIn--;                          _codec.TotalBytesIn++;                          expectedCheck += (uint)((_codec.InputBuffer[_codec.NextIn++] << 8) & 0x0000ff00);                          mode = InflateManagerMode.DICT1;                          break;                          case InflateManagerMode.DICT1:                          if (_codec.AvailableBytesIn == 0) return r;                          r = f;                          _codec.AvailableBytesIn--; _codec.TotalBytesIn++;                          expectedCheck += (uint)(_codec.InputBuffer[_codec.NextIn++] & 0x000000ff);                          _codec._Adler32 = expectedCheck;                          mode = InflateManagerMode.DICT0;                          return ZlibConstants.Z_NEED_DICT;                          case InflateManagerMode.DICT0:                          mode = InflateManagerMode.BAD;                          _codec.Message = "need dictionary";                          marker = 0; // can try inflateSync                          return ZlibConstants.Z_STREAM_ERROR;                          case InflateManagerMode.BLOCKS:                          r = blocks.Process(r);                          if (r == ZlibConstants.Z_DATA_ERROR)                          {                              mode = InflateManagerMode.BAD;                              marker = 0; // can try inflateSync                              break;                          }                            if (r == ZlibConstants.Z_OK) r = f;                            if (r != ZlibConstants.Z_STREAM_END)                              return r;                            r = f;                          computedCheck = blocks.Reset();                          if (!HandleRfc1950HeaderBytes)                          {                              mode = InflateManagerMode.DONE;                              return ZlibConstants.Z_STREAM_END;                          }                          mode = InflateManagerMode.CHECK4;                          break;                        case InflateManagerMode.CHECK4:                          if (_codec.AvailableBytesIn == 0) return r;                          r = f;                          _codec.AvailableBytesIn--;                          _codec.TotalBytesIn++;                          expectedCheck = (uint)((_codec.InputBuffer[_codec.NextIn++] << 24) & 0xff000000);                          mode = InflateManagerMode.CHECK3;                          break;                        case InflateManagerMode.CHECK3:                          if (_codec.AvailableBytesIn == 0) return r;                          r = f;                          _codec.AvailableBytesIn--; _codec.TotalBytesIn++;                          expectedCheck += (uint)((_codec.InputBuffer[_codec.NextIn++] << 16) & 0x00ff0000);                          mode = InflateManagerMode.CHECK2;                          break;                        case InflateManagerMode.CHECK2:                          if (_codec.AvailableBytesIn == 0) return r;                          r = f;                          _codec.AvailableBytesIn--;                          _codec.TotalBytesIn++;                          expectedCheck += (uint)((_codec.InputBuffer[_codec.NextIn++] << 8) & 0x0000ff00);                          mode = InflateManagerMode.CHECK1;                          break;                        case InflateManagerMode.CHECK1:                          if (_codec.AvailableBytesIn == 0) return r;                          r = f;                          _codec.AvailableBytesIn--; _codec.TotalBytesIn++;                          expectedCheck += (uint)(_codec.InputBuffer[_codec.NextIn++] & 0x000000ff);                          if (computedCheck != expectedCheck)                          {                              mode = InflateManagerMode.BAD;                              _codec.Message = "incorrect data check";                              marker = 5; // can't try inflateSync                              break;                          }                          mode = InflateManagerMode.DONE;                          return ZlibConstants.Z_STREAM_END;                        case InflateManagerMode.DONE:                          return ZlibConstants.Z_STREAM_END;                        case InflateManagerMode.BAD:                          throw new ZlibException(String.Format("Bad state ({0})"' _codec.Message));                        default:                          throw new ZlibException("Stream error.");                    }
Magic Number,Ionic.Zlib,InflateManager,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zlib.Shared\Inflate.cs,Inflate,The following statement contains a magic number: switch (mode)                  {                      case InflateManagerMode.METHOD:                          if (_codec.AvailableBytesIn == 0) return r;                          r = f;                          _codec.AvailableBytesIn--;                          _codec.TotalBytesIn++;                          if (((method = _codec.InputBuffer[_codec.NextIn++]) & 0xf) != Z_DEFLATED)                          {                              mode = InflateManagerMode.BAD;                              _codec.Message = String.Format("unknown compression method (0x{0:X2})"' method);                              marker = 5; // can't try inflateSync                              break;                          }                          if ((method >> 4) + 8 > wbits)                          {                              mode = InflateManagerMode.BAD;                              _codec.Message = String.Format("invalid window size ({0})"' (method >> 4) + 8);                              marker = 5; // can't try inflateSync                              break;                          }                          mode = InflateManagerMode.FLAG;                          break;                          case InflateManagerMode.FLAG:                          if (_codec.AvailableBytesIn == 0) return r;                          r = f;                          _codec.AvailableBytesIn--;                          _codec.TotalBytesIn++;                          b = (_codec.InputBuffer[_codec.NextIn++]) & 0xff;                            if ((((method << 8) + b) % 31) != 0)                          {                              mode = InflateManagerMode.BAD;                              _codec.Message = "incorrect header check";                              marker = 5; // can't try inflateSync                              break;                          }                            mode = ((b & PRESET_DICT) == 0)                              ? InflateManagerMode.BLOCKS                              : InflateManagerMode.DICT4;                          break;                        case InflateManagerMode.DICT4:                          if (_codec.AvailableBytesIn == 0) return r;                          r = f;                          _codec.AvailableBytesIn--;                          _codec.TotalBytesIn++;                          expectedCheck = (uint)((_codec.InputBuffer[_codec.NextIn++] << 24) & 0xff000000);                          mode = InflateManagerMode.DICT3;                          break;                        case InflateManagerMode.DICT3:                          if (_codec.AvailableBytesIn == 0) return r;                          r = f;                          _codec.AvailableBytesIn--;                          _codec.TotalBytesIn++;                          expectedCheck += (uint)((_codec.InputBuffer[_codec.NextIn++] << 16) & 0x00ff0000);                          mode = InflateManagerMode.DICT2;                          break;                        case InflateManagerMode.DICT2:                            if (_codec.AvailableBytesIn == 0) return r;                          r = f;                          _codec.AvailableBytesIn--;                          _codec.TotalBytesIn++;                          expectedCheck += (uint)((_codec.InputBuffer[_codec.NextIn++] << 8) & 0x0000ff00);                          mode = InflateManagerMode.DICT1;                          break;                          case InflateManagerMode.DICT1:                          if (_codec.AvailableBytesIn == 0) return r;                          r = f;                          _codec.AvailableBytesIn--; _codec.TotalBytesIn++;                          expectedCheck += (uint)(_codec.InputBuffer[_codec.NextIn++] & 0x000000ff);                          _codec._Adler32 = expectedCheck;                          mode = InflateManagerMode.DICT0;                          return ZlibConstants.Z_NEED_DICT;                          case InflateManagerMode.DICT0:                          mode = InflateManagerMode.BAD;                          _codec.Message = "need dictionary";                          marker = 0; // can try inflateSync                          return ZlibConstants.Z_STREAM_ERROR;                          case InflateManagerMode.BLOCKS:                          r = blocks.Process(r);                          if (r == ZlibConstants.Z_DATA_ERROR)                          {                              mode = InflateManagerMode.BAD;                              marker = 0; // can try inflateSync                              break;                          }                            if (r == ZlibConstants.Z_OK) r = f;                            if (r != ZlibConstants.Z_STREAM_END)                              return r;                            r = f;                          computedCheck = blocks.Reset();                          if (!HandleRfc1950HeaderBytes)                          {                              mode = InflateManagerMode.DONE;                              return ZlibConstants.Z_STREAM_END;                          }                          mode = InflateManagerMode.CHECK4;                          break;                        case InflateManagerMode.CHECK4:                          if (_codec.AvailableBytesIn == 0) return r;                          r = f;                          _codec.AvailableBytesIn--;                          _codec.TotalBytesIn++;                          expectedCheck = (uint)((_codec.InputBuffer[_codec.NextIn++] << 24) & 0xff000000);                          mode = InflateManagerMode.CHECK3;                          break;                        case InflateManagerMode.CHECK3:                          if (_codec.AvailableBytesIn == 0) return r;                          r = f;                          _codec.AvailableBytesIn--; _codec.TotalBytesIn++;                          expectedCheck += (uint)((_codec.InputBuffer[_codec.NextIn++] << 16) & 0x00ff0000);                          mode = InflateManagerMode.CHECK2;                          break;                        case InflateManagerMode.CHECK2:                          if (_codec.AvailableBytesIn == 0) return r;                          r = f;                          _codec.AvailableBytesIn--;                          _codec.TotalBytesIn++;                          expectedCheck += (uint)((_codec.InputBuffer[_codec.NextIn++] << 8) & 0x0000ff00);                          mode = InflateManagerMode.CHECK1;                          break;                        case InflateManagerMode.CHECK1:                          if (_codec.AvailableBytesIn == 0) return r;                          r = f;                          _codec.AvailableBytesIn--; _codec.TotalBytesIn++;                          expectedCheck += (uint)(_codec.InputBuffer[_codec.NextIn++] & 0x000000ff);                          if (computedCheck != expectedCheck)                          {                              mode = InflateManagerMode.BAD;                              _codec.Message = "incorrect data check";                              marker = 5; // can't try inflateSync                              break;                          }                          mode = InflateManagerMode.DONE;                          return ZlibConstants.Z_STREAM_END;                        case InflateManagerMode.DONE:                          return ZlibConstants.Z_STREAM_END;                        case InflateManagerMode.BAD:                          throw new ZlibException(String.Format("Bad state ({0})"' _codec.Message));                        default:                          throw new ZlibException("Stream error.");                    }
Magic Number,Ionic.Zlib,InflateManager,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zlib.Shared\Inflate.cs,Inflate,The following statement contains a magic number: switch (mode)                  {                      case InflateManagerMode.METHOD:                          if (_codec.AvailableBytesIn == 0) return r;                          r = f;                          _codec.AvailableBytesIn--;                          _codec.TotalBytesIn++;                          if (((method = _codec.InputBuffer[_codec.NextIn++]) & 0xf) != Z_DEFLATED)                          {                              mode = InflateManagerMode.BAD;                              _codec.Message = String.Format("unknown compression method (0x{0:X2})"' method);                              marker = 5; // can't try inflateSync                              break;                          }                          if ((method >> 4) + 8 > wbits)                          {                              mode = InflateManagerMode.BAD;                              _codec.Message = String.Format("invalid window size ({0})"' (method >> 4) + 8);                              marker = 5; // can't try inflateSync                              break;                          }                          mode = InflateManagerMode.FLAG;                          break;                          case InflateManagerMode.FLAG:                          if (_codec.AvailableBytesIn == 0) return r;                          r = f;                          _codec.AvailableBytesIn--;                          _codec.TotalBytesIn++;                          b = (_codec.InputBuffer[_codec.NextIn++]) & 0xff;                            if ((((method << 8) + b) % 31) != 0)                          {                              mode = InflateManagerMode.BAD;                              _codec.Message = "incorrect header check";                              marker = 5; // can't try inflateSync                              break;                          }                            mode = ((b & PRESET_DICT) == 0)                              ? InflateManagerMode.BLOCKS                              : InflateManagerMode.DICT4;                          break;                        case InflateManagerMode.DICT4:                          if (_codec.AvailableBytesIn == 0) return r;                          r = f;                          _codec.AvailableBytesIn--;                          _codec.TotalBytesIn++;                          expectedCheck = (uint)((_codec.InputBuffer[_codec.NextIn++] << 24) & 0xff000000);                          mode = InflateManagerMode.DICT3;                          break;                        case InflateManagerMode.DICT3:                          if (_codec.AvailableBytesIn == 0) return r;                          r = f;                          _codec.AvailableBytesIn--;                          _codec.TotalBytesIn++;                          expectedCheck += (uint)((_codec.InputBuffer[_codec.NextIn++] << 16) & 0x00ff0000);                          mode = InflateManagerMode.DICT2;                          break;                        case InflateManagerMode.DICT2:                            if (_codec.AvailableBytesIn == 0) return r;                          r = f;                          _codec.AvailableBytesIn--;                          _codec.TotalBytesIn++;                          expectedCheck += (uint)((_codec.InputBuffer[_codec.NextIn++] << 8) & 0x0000ff00);                          mode = InflateManagerMode.DICT1;                          break;                          case InflateManagerMode.DICT1:                          if (_codec.AvailableBytesIn == 0) return r;                          r = f;                          _codec.AvailableBytesIn--; _codec.TotalBytesIn++;                          expectedCheck += (uint)(_codec.InputBuffer[_codec.NextIn++] & 0x000000ff);                          _codec._Adler32 = expectedCheck;                          mode = InflateManagerMode.DICT0;                          return ZlibConstants.Z_NEED_DICT;                          case InflateManagerMode.DICT0:                          mode = InflateManagerMode.BAD;                          _codec.Message = "need dictionary";                          marker = 0; // can try inflateSync                          return ZlibConstants.Z_STREAM_ERROR;                          case InflateManagerMode.BLOCKS:                          r = blocks.Process(r);                          if (r == ZlibConstants.Z_DATA_ERROR)                          {                              mode = InflateManagerMode.BAD;                              marker = 0; // can try inflateSync                              break;                          }                            if (r == ZlibConstants.Z_OK) r = f;                            if (r != ZlibConstants.Z_STREAM_END)                              return r;                            r = f;                          computedCheck = blocks.Reset();                          if (!HandleRfc1950HeaderBytes)                          {                              mode = InflateManagerMode.DONE;                              return ZlibConstants.Z_STREAM_END;                          }                          mode = InflateManagerMode.CHECK4;                          break;                        case InflateManagerMode.CHECK4:                          if (_codec.AvailableBytesIn == 0) return r;                          r = f;                          _codec.AvailableBytesIn--;                          _codec.TotalBytesIn++;                          expectedCheck = (uint)((_codec.InputBuffer[_codec.NextIn++] << 24) & 0xff000000);                          mode = InflateManagerMode.CHECK3;                          break;                        case InflateManagerMode.CHECK3:                          if (_codec.AvailableBytesIn == 0) return r;                          r = f;                          _codec.AvailableBytesIn--; _codec.TotalBytesIn++;                          expectedCheck += (uint)((_codec.InputBuffer[_codec.NextIn++] << 16) & 0x00ff0000);                          mode = InflateManagerMode.CHECK2;                          break;                        case InflateManagerMode.CHECK2:                          if (_codec.AvailableBytesIn == 0) return r;                          r = f;                          _codec.AvailableBytesIn--;                          _codec.TotalBytesIn++;                          expectedCheck += (uint)((_codec.InputBuffer[_codec.NextIn++] << 8) & 0x0000ff00);                          mode = InflateManagerMode.CHECK1;                          break;                        case InflateManagerMode.CHECK1:                          if (_codec.AvailableBytesIn == 0) return r;                          r = f;                          _codec.AvailableBytesIn--; _codec.TotalBytesIn++;                          expectedCheck += (uint)(_codec.InputBuffer[_codec.NextIn++] & 0x000000ff);                          if (computedCheck != expectedCheck)                          {                              mode = InflateManagerMode.BAD;                              _codec.Message = "incorrect data check";                              marker = 5; // can't try inflateSync                              break;                          }                          mode = InflateManagerMode.DONE;                          return ZlibConstants.Z_STREAM_END;                        case InflateManagerMode.DONE:                          return ZlibConstants.Z_STREAM_END;                        case InflateManagerMode.BAD:                          throw new ZlibException(String.Format("Bad state ({0})"' _codec.Message));                        default:                          throw new ZlibException("Stream error.");                    }
Magic Number,Ionic.Zlib,InflateManager,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zlib.Shared\Inflate.cs,Inflate,The following statement contains a magic number: switch (mode)                  {                      case InflateManagerMode.METHOD:                          if (_codec.AvailableBytesIn == 0) return r;                          r = f;                          _codec.AvailableBytesIn--;                          _codec.TotalBytesIn++;                          if (((method = _codec.InputBuffer[_codec.NextIn++]) & 0xf) != Z_DEFLATED)                          {                              mode = InflateManagerMode.BAD;                              _codec.Message = String.Format("unknown compression method (0x{0:X2})"' method);                              marker = 5; // can't try inflateSync                              break;                          }                          if ((method >> 4) + 8 > wbits)                          {                              mode = InflateManagerMode.BAD;                              _codec.Message = String.Format("invalid window size ({0})"' (method >> 4) + 8);                              marker = 5; // can't try inflateSync                              break;                          }                          mode = InflateManagerMode.FLAG;                          break;                          case InflateManagerMode.FLAG:                          if (_codec.AvailableBytesIn == 0) return r;                          r = f;                          _codec.AvailableBytesIn--;                          _codec.TotalBytesIn++;                          b = (_codec.InputBuffer[_codec.NextIn++]) & 0xff;                            if ((((method << 8) + b) % 31) != 0)                          {                              mode = InflateManagerMode.BAD;                              _codec.Message = "incorrect header check";                              marker = 5; // can't try inflateSync                              break;                          }                            mode = ((b & PRESET_DICT) == 0)                              ? InflateManagerMode.BLOCKS                              : InflateManagerMode.DICT4;                          break;                        case InflateManagerMode.DICT4:                          if (_codec.AvailableBytesIn == 0) return r;                          r = f;                          _codec.AvailableBytesIn--;                          _codec.TotalBytesIn++;                          expectedCheck = (uint)((_codec.InputBuffer[_codec.NextIn++] << 24) & 0xff000000);                          mode = InflateManagerMode.DICT3;                          break;                        case InflateManagerMode.DICT3:                          if (_codec.AvailableBytesIn == 0) return r;                          r = f;                          _codec.AvailableBytesIn--;                          _codec.TotalBytesIn++;                          expectedCheck += (uint)((_codec.InputBuffer[_codec.NextIn++] << 16) & 0x00ff0000);                          mode = InflateManagerMode.DICT2;                          break;                        case InflateManagerMode.DICT2:                            if (_codec.AvailableBytesIn == 0) return r;                          r = f;                          _codec.AvailableBytesIn--;                          _codec.TotalBytesIn++;                          expectedCheck += (uint)((_codec.InputBuffer[_codec.NextIn++] << 8) & 0x0000ff00);                          mode = InflateManagerMode.DICT1;                          break;                          case InflateManagerMode.DICT1:                          if (_codec.AvailableBytesIn == 0) return r;                          r = f;                          _codec.AvailableBytesIn--; _codec.TotalBytesIn++;                          expectedCheck += (uint)(_codec.InputBuffer[_codec.NextIn++] & 0x000000ff);                          _codec._Adler32 = expectedCheck;                          mode = InflateManagerMode.DICT0;                          return ZlibConstants.Z_NEED_DICT;                          case InflateManagerMode.DICT0:                          mode = InflateManagerMode.BAD;                          _codec.Message = "need dictionary";                          marker = 0; // can try inflateSync                          return ZlibConstants.Z_STREAM_ERROR;                          case InflateManagerMode.BLOCKS:                          r = blocks.Process(r);                          if (r == ZlibConstants.Z_DATA_ERROR)                          {                              mode = InflateManagerMode.BAD;                              marker = 0; // can try inflateSync                              break;                          }                            if (r == ZlibConstants.Z_OK) r = f;                            if (r != ZlibConstants.Z_STREAM_END)                              return r;                            r = f;                          computedCheck = blocks.Reset();                          if (!HandleRfc1950HeaderBytes)                          {                              mode = InflateManagerMode.DONE;                              return ZlibConstants.Z_STREAM_END;                          }                          mode = InflateManagerMode.CHECK4;                          break;                        case InflateManagerMode.CHECK4:                          if (_codec.AvailableBytesIn == 0) return r;                          r = f;                          _codec.AvailableBytesIn--;                          _codec.TotalBytesIn++;                          expectedCheck = (uint)((_codec.InputBuffer[_codec.NextIn++] << 24) & 0xff000000);                          mode = InflateManagerMode.CHECK3;                          break;                        case InflateManagerMode.CHECK3:                          if (_codec.AvailableBytesIn == 0) return r;                          r = f;                          _codec.AvailableBytesIn--; _codec.TotalBytesIn++;                          expectedCheck += (uint)((_codec.InputBuffer[_codec.NextIn++] << 16) & 0x00ff0000);                          mode = InflateManagerMode.CHECK2;                          break;                        case InflateManagerMode.CHECK2:                          if (_codec.AvailableBytesIn == 0) return r;                          r = f;                          _codec.AvailableBytesIn--;                          _codec.TotalBytesIn++;                          expectedCheck += (uint)((_codec.InputBuffer[_codec.NextIn++] << 8) & 0x0000ff00);                          mode = InflateManagerMode.CHECK1;                          break;                        case InflateManagerMode.CHECK1:                          if (_codec.AvailableBytesIn == 0) return r;                          r = f;                          _codec.AvailableBytesIn--; _codec.TotalBytesIn++;                          expectedCheck += (uint)(_codec.InputBuffer[_codec.NextIn++] & 0x000000ff);                          if (computedCheck != expectedCheck)                          {                              mode = InflateManagerMode.BAD;                              _codec.Message = "incorrect data check";                              marker = 5; // can't try inflateSync                              break;                          }                          mode = InflateManagerMode.DONE;                          return ZlibConstants.Z_STREAM_END;                        case InflateManagerMode.DONE:                          return ZlibConstants.Z_STREAM_END;                        case InflateManagerMode.BAD:                          throw new ZlibException(String.Format("Bad state ({0})"' _codec.Message));                        default:                          throw new ZlibException("Stream error.");                    }
Magic Number,Ionic.Zlib,InflateManager,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zlib.Shared\Inflate.cs,Inflate,The following statement contains a magic number: switch (mode)                  {                      case InflateManagerMode.METHOD:                          if (_codec.AvailableBytesIn == 0) return r;                          r = f;                          _codec.AvailableBytesIn--;                          _codec.TotalBytesIn++;                          if (((method = _codec.InputBuffer[_codec.NextIn++]) & 0xf) != Z_DEFLATED)                          {                              mode = InflateManagerMode.BAD;                              _codec.Message = String.Format("unknown compression method (0x{0:X2})"' method);                              marker = 5; // can't try inflateSync                              break;                          }                          if ((method >> 4) + 8 > wbits)                          {                              mode = InflateManagerMode.BAD;                              _codec.Message = String.Format("invalid window size ({0})"' (method >> 4) + 8);                              marker = 5; // can't try inflateSync                              break;                          }                          mode = InflateManagerMode.FLAG;                          break;                          case InflateManagerMode.FLAG:                          if (_codec.AvailableBytesIn == 0) return r;                          r = f;                          _codec.AvailableBytesIn--;                          _codec.TotalBytesIn++;                          b = (_codec.InputBuffer[_codec.NextIn++]) & 0xff;                            if ((((method << 8) + b) % 31) != 0)                          {                              mode = InflateManagerMode.BAD;                              _codec.Message = "incorrect header check";                              marker = 5; // can't try inflateSync                              break;                          }                            mode = ((b & PRESET_DICT) == 0)                              ? InflateManagerMode.BLOCKS                              : InflateManagerMode.DICT4;                          break;                        case InflateManagerMode.DICT4:                          if (_codec.AvailableBytesIn == 0) return r;                          r = f;                          _codec.AvailableBytesIn--;                          _codec.TotalBytesIn++;                          expectedCheck = (uint)((_codec.InputBuffer[_codec.NextIn++] << 24) & 0xff000000);                          mode = InflateManagerMode.DICT3;                          break;                        case InflateManagerMode.DICT3:                          if (_codec.AvailableBytesIn == 0) return r;                          r = f;                          _codec.AvailableBytesIn--;                          _codec.TotalBytesIn++;                          expectedCheck += (uint)((_codec.InputBuffer[_codec.NextIn++] << 16) & 0x00ff0000);                          mode = InflateManagerMode.DICT2;                          break;                        case InflateManagerMode.DICT2:                            if (_codec.AvailableBytesIn == 0) return r;                          r = f;                          _codec.AvailableBytesIn--;                          _codec.TotalBytesIn++;                          expectedCheck += (uint)((_codec.InputBuffer[_codec.NextIn++] << 8) & 0x0000ff00);                          mode = InflateManagerMode.DICT1;                          break;                          case InflateManagerMode.DICT1:                          if (_codec.AvailableBytesIn == 0) return r;                          r = f;                          _codec.AvailableBytesIn--; _codec.TotalBytesIn++;                          expectedCheck += (uint)(_codec.InputBuffer[_codec.NextIn++] & 0x000000ff);                          _codec._Adler32 = expectedCheck;                          mode = InflateManagerMode.DICT0;                          return ZlibConstants.Z_NEED_DICT;                          case InflateManagerMode.DICT0:                          mode = InflateManagerMode.BAD;                          _codec.Message = "need dictionary";                          marker = 0; // can try inflateSync                          return ZlibConstants.Z_STREAM_ERROR;                          case InflateManagerMode.BLOCKS:                          r = blocks.Process(r);                          if (r == ZlibConstants.Z_DATA_ERROR)                          {                              mode = InflateManagerMode.BAD;                              marker = 0; // can try inflateSync                              break;                          }                            if (r == ZlibConstants.Z_OK) r = f;                            if (r != ZlibConstants.Z_STREAM_END)                              return r;                            r = f;                          computedCheck = blocks.Reset();                          if (!HandleRfc1950HeaderBytes)                          {                              mode = InflateManagerMode.DONE;                              return ZlibConstants.Z_STREAM_END;                          }                          mode = InflateManagerMode.CHECK4;                          break;                        case InflateManagerMode.CHECK4:                          if (_codec.AvailableBytesIn == 0) return r;                          r = f;                          _codec.AvailableBytesIn--;                          _codec.TotalBytesIn++;                          expectedCheck = (uint)((_codec.InputBuffer[_codec.NextIn++] << 24) & 0xff000000);                          mode = InflateManagerMode.CHECK3;                          break;                        case InflateManagerMode.CHECK3:                          if (_codec.AvailableBytesIn == 0) return r;                          r = f;                          _codec.AvailableBytesIn--; _codec.TotalBytesIn++;                          expectedCheck += (uint)((_codec.InputBuffer[_codec.NextIn++] << 16) & 0x00ff0000);                          mode = InflateManagerMode.CHECK2;                          break;                        case InflateManagerMode.CHECK2:                          if (_codec.AvailableBytesIn == 0) return r;                          r = f;                          _codec.AvailableBytesIn--;                          _codec.TotalBytesIn++;                          expectedCheck += (uint)((_codec.InputBuffer[_codec.NextIn++] << 8) & 0x0000ff00);                          mode = InflateManagerMode.CHECK1;                          break;                        case InflateManagerMode.CHECK1:                          if (_codec.AvailableBytesIn == 0) return r;                          r = f;                          _codec.AvailableBytesIn--; _codec.TotalBytesIn++;                          expectedCheck += (uint)(_codec.InputBuffer[_codec.NextIn++] & 0x000000ff);                          if (computedCheck != expectedCheck)                          {                              mode = InflateManagerMode.BAD;                              _codec.Message = "incorrect data check";                              marker = 5; // can't try inflateSync                              break;                          }                          mode = InflateManagerMode.DONE;                          return ZlibConstants.Z_STREAM_END;                        case InflateManagerMode.DONE:                          return ZlibConstants.Z_STREAM_END;                        case InflateManagerMode.BAD:                          throw new ZlibException(String.Format("Bad state ({0})"' _codec.Message));                        default:                          throw new ZlibException("Stream error.");                    }
Magic Number,Ionic.Zlib,InflateManager,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zlib.Shared\Inflate.cs,Inflate,The following statement contains a magic number: switch (mode)                  {                      case InflateManagerMode.METHOD:                          if (_codec.AvailableBytesIn == 0) return r;                          r = f;                          _codec.AvailableBytesIn--;                          _codec.TotalBytesIn++;                          if (((method = _codec.InputBuffer[_codec.NextIn++]) & 0xf) != Z_DEFLATED)                          {                              mode = InflateManagerMode.BAD;                              _codec.Message = String.Format("unknown compression method (0x{0:X2})"' method);                              marker = 5; // can't try inflateSync                              break;                          }                          if ((method >> 4) + 8 > wbits)                          {                              mode = InflateManagerMode.BAD;                              _codec.Message = String.Format("invalid window size ({0})"' (method >> 4) + 8);                              marker = 5; // can't try inflateSync                              break;                          }                          mode = InflateManagerMode.FLAG;                          break;                          case InflateManagerMode.FLAG:                          if (_codec.AvailableBytesIn == 0) return r;                          r = f;                          _codec.AvailableBytesIn--;                          _codec.TotalBytesIn++;                          b = (_codec.InputBuffer[_codec.NextIn++]) & 0xff;                            if ((((method << 8) + b) % 31) != 0)                          {                              mode = InflateManagerMode.BAD;                              _codec.Message = "incorrect header check";                              marker = 5; // can't try inflateSync                              break;                          }                            mode = ((b & PRESET_DICT) == 0)                              ? InflateManagerMode.BLOCKS                              : InflateManagerMode.DICT4;                          break;                        case InflateManagerMode.DICT4:                          if (_codec.AvailableBytesIn == 0) return r;                          r = f;                          _codec.AvailableBytesIn--;                          _codec.TotalBytesIn++;                          expectedCheck = (uint)((_codec.InputBuffer[_codec.NextIn++] << 24) & 0xff000000);                          mode = InflateManagerMode.DICT3;                          break;                        case InflateManagerMode.DICT3:                          if (_codec.AvailableBytesIn == 0) return r;                          r = f;                          _codec.AvailableBytesIn--;                          _codec.TotalBytesIn++;                          expectedCheck += (uint)((_codec.InputBuffer[_codec.NextIn++] << 16) & 0x00ff0000);                          mode = InflateManagerMode.DICT2;                          break;                        case InflateManagerMode.DICT2:                            if (_codec.AvailableBytesIn == 0) return r;                          r = f;                          _codec.AvailableBytesIn--;                          _codec.TotalBytesIn++;                          expectedCheck += (uint)((_codec.InputBuffer[_codec.NextIn++] << 8) & 0x0000ff00);                          mode = InflateManagerMode.DICT1;                          break;                          case InflateManagerMode.DICT1:                          if (_codec.AvailableBytesIn == 0) return r;                          r = f;                          _codec.AvailableBytesIn--; _codec.TotalBytesIn++;                          expectedCheck += (uint)(_codec.InputBuffer[_codec.NextIn++] & 0x000000ff);                          _codec._Adler32 = expectedCheck;                          mode = InflateManagerMode.DICT0;                          return ZlibConstants.Z_NEED_DICT;                          case InflateManagerMode.DICT0:                          mode = InflateManagerMode.BAD;                          _codec.Message = "need dictionary";                          marker = 0; // can try inflateSync                          return ZlibConstants.Z_STREAM_ERROR;                          case InflateManagerMode.BLOCKS:                          r = blocks.Process(r);                          if (r == ZlibConstants.Z_DATA_ERROR)                          {                              mode = InflateManagerMode.BAD;                              marker = 0; // can try inflateSync                              break;                          }                            if (r == ZlibConstants.Z_OK) r = f;                            if (r != ZlibConstants.Z_STREAM_END)                              return r;                            r = f;                          computedCheck = blocks.Reset();                          if (!HandleRfc1950HeaderBytes)                          {                              mode = InflateManagerMode.DONE;                              return ZlibConstants.Z_STREAM_END;                          }                          mode = InflateManagerMode.CHECK4;                          break;                        case InflateManagerMode.CHECK4:                          if (_codec.AvailableBytesIn == 0) return r;                          r = f;                          _codec.AvailableBytesIn--;                          _codec.TotalBytesIn++;                          expectedCheck = (uint)((_codec.InputBuffer[_codec.NextIn++] << 24) & 0xff000000);                          mode = InflateManagerMode.CHECK3;                          break;                        case InflateManagerMode.CHECK3:                          if (_codec.AvailableBytesIn == 0) return r;                          r = f;                          _codec.AvailableBytesIn--; _codec.TotalBytesIn++;                          expectedCheck += (uint)((_codec.InputBuffer[_codec.NextIn++] << 16) & 0x00ff0000);                          mode = InflateManagerMode.CHECK2;                          break;                        case InflateManagerMode.CHECK2:                          if (_codec.AvailableBytesIn == 0) return r;                          r = f;                          _codec.AvailableBytesIn--;                          _codec.TotalBytesIn++;                          expectedCheck += (uint)((_codec.InputBuffer[_codec.NextIn++] << 8) & 0x0000ff00);                          mode = InflateManagerMode.CHECK1;                          break;                        case InflateManagerMode.CHECK1:                          if (_codec.AvailableBytesIn == 0) return r;                          r = f;                          _codec.AvailableBytesIn--; _codec.TotalBytesIn++;                          expectedCheck += (uint)(_codec.InputBuffer[_codec.NextIn++] & 0x000000ff);                          if (computedCheck != expectedCheck)                          {                              mode = InflateManagerMode.BAD;                              _codec.Message = "incorrect data check";                              marker = 5; // can't try inflateSync                              break;                          }                          mode = InflateManagerMode.DONE;                          return ZlibConstants.Z_STREAM_END;                        case InflateManagerMode.DONE:                          return ZlibConstants.Z_STREAM_END;                        case InflateManagerMode.BAD:                          throw new ZlibException(String.Format("Bad state ({0})"' _codec.Message));                        default:                          throw new ZlibException("Stream error.");                    }
Magic Number,Ionic.Zlib,InflateManager,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zlib.Shared\Inflate.cs,Inflate,The following statement contains a magic number: switch (mode)                  {                      case InflateManagerMode.METHOD:                          if (_codec.AvailableBytesIn == 0) return r;                          r = f;                          _codec.AvailableBytesIn--;                          _codec.TotalBytesIn++;                          if (((method = _codec.InputBuffer[_codec.NextIn++]) & 0xf) != Z_DEFLATED)                          {                              mode = InflateManagerMode.BAD;                              _codec.Message = String.Format("unknown compression method (0x{0:X2})"' method);                              marker = 5; // can't try inflateSync                              break;                          }                          if ((method >> 4) + 8 > wbits)                          {                              mode = InflateManagerMode.BAD;                              _codec.Message = String.Format("invalid window size ({0})"' (method >> 4) + 8);                              marker = 5; // can't try inflateSync                              break;                          }                          mode = InflateManagerMode.FLAG;                          break;                          case InflateManagerMode.FLAG:                          if (_codec.AvailableBytesIn == 0) return r;                          r = f;                          _codec.AvailableBytesIn--;                          _codec.TotalBytesIn++;                          b = (_codec.InputBuffer[_codec.NextIn++]) & 0xff;                            if ((((method << 8) + b) % 31) != 0)                          {                              mode = InflateManagerMode.BAD;                              _codec.Message = "incorrect header check";                              marker = 5; // can't try inflateSync                              break;                          }                            mode = ((b & PRESET_DICT) == 0)                              ? InflateManagerMode.BLOCKS                              : InflateManagerMode.DICT4;                          break;                        case InflateManagerMode.DICT4:                          if (_codec.AvailableBytesIn == 0) return r;                          r = f;                          _codec.AvailableBytesIn--;                          _codec.TotalBytesIn++;                          expectedCheck = (uint)((_codec.InputBuffer[_codec.NextIn++] << 24) & 0xff000000);                          mode = InflateManagerMode.DICT3;                          break;                        case InflateManagerMode.DICT3:                          if (_codec.AvailableBytesIn == 0) return r;                          r = f;                          _codec.AvailableBytesIn--;                          _codec.TotalBytesIn++;                          expectedCheck += (uint)((_codec.InputBuffer[_codec.NextIn++] << 16) & 0x00ff0000);                          mode = InflateManagerMode.DICT2;                          break;                        case InflateManagerMode.DICT2:                            if (_codec.AvailableBytesIn == 0) return r;                          r = f;                          _codec.AvailableBytesIn--;                          _codec.TotalBytesIn++;                          expectedCheck += (uint)((_codec.InputBuffer[_codec.NextIn++] << 8) & 0x0000ff00);                          mode = InflateManagerMode.DICT1;                          break;                          case InflateManagerMode.DICT1:                          if (_codec.AvailableBytesIn == 0) return r;                          r = f;                          _codec.AvailableBytesIn--; _codec.TotalBytesIn++;                          expectedCheck += (uint)(_codec.InputBuffer[_codec.NextIn++] & 0x000000ff);                          _codec._Adler32 = expectedCheck;                          mode = InflateManagerMode.DICT0;                          return ZlibConstants.Z_NEED_DICT;                          case InflateManagerMode.DICT0:                          mode = InflateManagerMode.BAD;                          _codec.Message = "need dictionary";                          marker = 0; // can try inflateSync                          return ZlibConstants.Z_STREAM_ERROR;                          case InflateManagerMode.BLOCKS:                          r = blocks.Process(r);                          if (r == ZlibConstants.Z_DATA_ERROR)                          {                              mode = InflateManagerMode.BAD;                              marker = 0; // can try inflateSync                              break;                          }                            if (r == ZlibConstants.Z_OK) r = f;                            if (r != ZlibConstants.Z_STREAM_END)                              return r;                            r = f;                          computedCheck = blocks.Reset();                          if (!HandleRfc1950HeaderBytes)                          {                              mode = InflateManagerMode.DONE;                              return ZlibConstants.Z_STREAM_END;                          }                          mode = InflateManagerMode.CHECK4;                          break;                        case InflateManagerMode.CHECK4:                          if (_codec.AvailableBytesIn == 0) return r;                          r = f;                          _codec.AvailableBytesIn--;                          _codec.TotalBytesIn++;                          expectedCheck = (uint)((_codec.InputBuffer[_codec.NextIn++] << 24) & 0xff000000);                          mode = InflateManagerMode.CHECK3;                          break;                        case InflateManagerMode.CHECK3:                          if (_codec.AvailableBytesIn == 0) return r;                          r = f;                          _codec.AvailableBytesIn--; _codec.TotalBytesIn++;                          expectedCheck += (uint)((_codec.InputBuffer[_codec.NextIn++] << 16) & 0x00ff0000);                          mode = InflateManagerMode.CHECK2;                          break;                        case InflateManagerMode.CHECK2:                          if (_codec.AvailableBytesIn == 0) return r;                          r = f;                          _codec.AvailableBytesIn--;                          _codec.TotalBytesIn++;                          expectedCheck += (uint)((_codec.InputBuffer[_codec.NextIn++] << 8) & 0x0000ff00);                          mode = InflateManagerMode.CHECK1;                          break;                        case InflateManagerMode.CHECK1:                          if (_codec.AvailableBytesIn == 0) return r;                          r = f;                          _codec.AvailableBytesIn--; _codec.TotalBytesIn++;                          expectedCheck += (uint)(_codec.InputBuffer[_codec.NextIn++] & 0x000000ff);                          if (computedCheck != expectedCheck)                          {                              mode = InflateManagerMode.BAD;                              _codec.Message = "incorrect data check";                              marker = 5; // can't try inflateSync                              break;                          }                          mode = InflateManagerMode.DONE;                          return ZlibConstants.Z_STREAM_END;                        case InflateManagerMode.DONE:                          return ZlibConstants.Z_STREAM_END;                        case InflateManagerMode.BAD:                          throw new ZlibException(String.Format("Bad state ({0})"' _codec.Message));                        default:                          throw new ZlibException("Stream error.");                    }
Magic Number,Ionic.Zlib,InflateManager,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zlib.Shared\Inflate.cs,Inflate,The following statement contains a magic number: switch (mode)                  {                      case InflateManagerMode.METHOD:                          if (_codec.AvailableBytesIn == 0) return r;                          r = f;                          _codec.AvailableBytesIn--;                          _codec.TotalBytesIn++;                          if (((method = _codec.InputBuffer[_codec.NextIn++]) & 0xf) != Z_DEFLATED)                          {                              mode = InflateManagerMode.BAD;                              _codec.Message = String.Format("unknown compression method (0x{0:X2})"' method);                              marker = 5; // can't try inflateSync                              break;                          }                          if ((method >> 4) + 8 > wbits)                          {                              mode = InflateManagerMode.BAD;                              _codec.Message = String.Format("invalid window size ({0})"' (method >> 4) + 8);                              marker = 5; // can't try inflateSync                              break;                          }                          mode = InflateManagerMode.FLAG;                          break;                          case InflateManagerMode.FLAG:                          if (_codec.AvailableBytesIn == 0) return r;                          r = f;                          _codec.AvailableBytesIn--;                          _codec.TotalBytesIn++;                          b = (_codec.InputBuffer[_codec.NextIn++]) & 0xff;                            if ((((method << 8) + b) % 31) != 0)                          {                              mode = InflateManagerMode.BAD;                              _codec.Message = "incorrect header check";                              marker = 5; // can't try inflateSync                              break;                          }                            mode = ((b & PRESET_DICT) == 0)                              ? InflateManagerMode.BLOCKS                              : InflateManagerMode.DICT4;                          break;                        case InflateManagerMode.DICT4:                          if (_codec.AvailableBytesIn == 0) return r;                          r = f;                          _codec.AvailableBytesIn--;                          _codec.TotalBytesIn++;                          expectedCheck = (uint)((_codec.InputBuffer[_codec.NextIn++] << 24) & 0xff000000);                          mode = InflateManagerMode.DICT3;                          break;                        case InflateManagerMode.DICT3:                          if (_codec.AvailableBytesIn == 0) return r;                          r = f;                          _codec.AvailableBytesIn--;                          _codec.TotalBytesIn++;                          expectedCheck += (uint)((_codec.InputBuffer[_codec.NextIn++] << 16) & 0x00ff0000);                          mode = InflateManagerMode.DICT2;                          break;                        case InflateManagerMode.DICT2:                            if (_codec.AvailableBytesIn == 0) return r;                          r = f;                          _codec.AvailableBytesIn--;                          _codec.TotalBytesIn++;                          expectedCheck += (uint)((_codec.InputBuffer[_codec.NextIn++] << 8) & 0x0000ff00);                          mode = InflateManagerMode.DICT1;                          break;                          case InflateManagerMode.DICT1:                          if (_codec.AvailableBytesIn == 0) return r;                          r = f;                          _codec.AvailableBytesIn--; _codec.TotalBytesIn++;                          expectedCheck += (uint)(_codec.InputBuffer[_codec.NextIn++] & 0x000000ff);                          _codec._Adler32 = expectedCheck;                          mode = InflateManagerMode.DICT0;                          return ZlibConstants.Z_NEED_DICT;                          case InflateManagerMode.DICT0:                          mode = InflateManagerMode.BAD;                          _codec.Message = "need dictionary";                          marker = 0; // can try inflateSync                          return ZlibConstants.Z_STREAM_ERROR;                          case InflateManagerMode.BLOCKS:                          r = blocks.Process(r);                          if (r == ZlibConstants.Z_DATA_ERROR)                          {                              mode = InflateManagerMode.BAD;                              marker = 0; // can try inflateSync                              break;                          }                            if (r == ZlibConstants.Z_OK) r = f;                            if (r != ZlibConstants.Z_STREAM_END)                              return r;                            r = f;                          computedCheck = blocks.Reset();                          if (!HandleRfc1950HeaderBytes)                          {                              mode = InflateManagerMode.DONE;                              return ZlibConstants.Z_STREAM_END;                          }                          mode = InflateManagerMode.CHECK4;                          break;                        case InflateManagerMode.CHECK4:                          if (_codec.AvailableBytesIn == 0) return r;                          r = f;                          _codec.AvailableBytesIn--;                          _codec.TotalBytesIn++;                          expectedCheck = (uint)((_codec.InputBuffer[_codec.NextIn++] << 24) & 0xff000000);                          mode = InflateManagerMode.CHECK3;                          break;                        case InflateManagerMode.CHECK3:                          if (_codec.AvailableBytesIn == 0) return r;                          r = f;                          _codec.AvailableBytesIn--; _codec.TotalBytesIn++;                          expectedCheck += (uint)((_codec.InputBuffer[_codec.NextIn++] << 16) & 0x00ff0000);                          mode = InflateManagerMode.CHECK2;                          break;                        case InflateManagerMode.CHECK2:                          if (_codec.AvailableBytesIn == 0) return r;                          r = f;                          _codec.AvailableBytesIn--;                          _codec.TotalBytesIn++;                          expectedCheck += (uint)((_codec.InputBuffer[_codec.NextIn++] << 8) & 0x0000ff00);                          mode = InflateManagerMode.CHECK1;                          break;                        case InflateManagerMode.CHECK1:                          if (_codec.AvailableBytesIn == 0) return r;                          r = f;                          _codec.AvailableBytesIn--; _codec.TotalBytesIn++;                          expectedCheck += (uint)(_codec.InputBuffer[_codec.NextIn++] & 0x000000ff);                          if (computedCheck != expectedCheck)                          {                              mode = InflateManagerMode.BAD;                              _codec.Message = "incorrect data check";                              marker = 5; // can't try inflateSync                              break;                          }                          mode = InflateManagerMode.DONE;                          return ZlibConstants.Z_STREAM_END;                        case InflateManagerMode.DONE:                          return ZlibConstants.Z_STREAM_END;                        case InflateManagerMode.BAD:                          throw new ZlibException(String.Format("Bad state ({0})"' _codec.Message));                        default:                          throw new ZlibException("Stream error.");                    }
Magic Number,Ionic.Zlib,InflateManager,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zlib.Shared\Inflate.cs,Inflate,The following statement contains a magic number: switch (mode)                  {                      case InflateManagerMode.METHOD:                          if (_codec.AvailableBytesIn == 0) return r;                          r = f;                          _codec.AvailableBytesIn--;                          _codec.TotalBytesIn++;                          if (((method = _codec.InputBuffer[_codec.NextIn++]) & 0xf) != Z_DEFLATED)                          {                              mode = InflateManagerMode.BAD;                              _codec.Message = String.Format("unknown compression method (0x{0:X2})"' method);                              marker = 5; // can't try inflateSync                              break;                          }                          if ((method >> 4) + 8 > wbits)                          {                              mode = InflateManagerMode.BAD;                              _codec.Message = String.Format("invalid window size ({0})"' (method >> 4) + 8);                              marker = 5; // can't try inflateSync                              break;                          }                          mode = InflateManagerMode.FLAG;                          break;                          case InflateManagerMode.FLAG:                          if (_codec.AvailableBytesIn == 0) return r;                          r = f;                          _codec.AvailableBytesIn--;                          _codec.TotalBytesIn++;                          b = (_codec.InputBuffer[_codec.NextIn++]) & 0xff;                            if ((((method << 8) + b) % 31) != 0)                          {                              mode = InflateManagerMode.BAD;                              _codec.Message = "incorrect header check";                              marker = 5; // can't try inflateSync                              break;                          }                            mode = ((b & PRESET_DICT) == 0)                              ? InflateManagerMode.BLOCKS                              : InflateManagerMode.DICT4;                          break;                        case InflateManagerMode.DICT4:                          if (_codec.AvailableBytesIn == 0) return r;                          r = f;                          _codec.AvailableBytesIn--;                          _codec.TotalBytesIn++;                          expectedCheck = (uint)((_codec.InputBuffer[_codec.NextIn++] << 24) & 0xff000000);                          mode = InflateManagerMode.DICT3;                          break;                        case InflateManagerMode.DICT3:                          if (_codec.AvailableBytesIn == 0) return r;                          r = f;                          _codec.AvailableBytesIn--;                          _codec.TotalBytesIn++;                          expectedCheck += (uint)((_codec.InputBuffer[_codec.NextIn++] << 16) & 0x00ff0000);                          mode = InflateManagerMode.DICT2;                          break;                        case InflateManagerMode.DICT2:                            if (_codec.AvailableBytesIn == 0) return r;                          r = f;                          _codec.AvailableBytesIn--;                          _codec.TotalBytesIn++;                          expectedCheck += (uint)((_codec.InputBuffer[_codec.NextIn++] << 8) & 0x0000ff00);                          mode = InflateManagerMode.DICT1;                          break;                          case InflateManagerMode.DICT1:                          if (_codec.AvailableBytesIn == 0) return r;                          r = f;                          _codec.AvailableBytesIn--; _codec.TotalBytesIn++;                          expectedCheck += (uint)(_codec.InputBuffer[_codec.NextIn++] & 0x000000ff);                          _codec._Adler32 = expectedCheck;                          mode = InflateManagerMode.DICT0;                          return ZlibConstants.Z_NEED_DICT;                          case InflateManagerMode.DICT0:                          mode = InflateManagerMode.BAD;                          _codec.Message = "need dictionary";                          marker = 0; // can try inflateSync                          return ZlibConstants.Z_STREAM_ERROR;                          case InflateManagerMode.BLOCKS:                          r = blocks.Process(r);                          if (r == ZlibConstants.Z_DATA_ERROR)                          {                              mode = InflateManagerMode.BAD;                              marker = 0; // can try inflateSync                              break;                          }                            if (r == ZlibConstants.Z_OK) r = f;                            if (r != ZlibConstants.Z_STREAM_END)                              return r;                            r = f;                          computedCheck = blocks.Reset();                          if (!HandleRfc1950HeaderBytes)                          {                              mode = InflateManagerMode.DONE;                              return ZlibConstants.Z_STREAM_END;                          }                          mode = InflateManagerMode.CHECK4;                          break;                        case InflateManagerMode.CHECK4:                          if (_codec.AvailableBytesIn == 0) return r;                          r = f;                          _codec.AvailableBytesIn--;                          _codec.TotalBytesIn++;                          expectedCheck = (uint)((_codec.InputBuffer[_codec.NextIn++] << 24) & 0xff000000);                          mode = InflateManagerMode.CHECK3;                          break;                        case InflateManagerMode.CHECK3:                          if (_codec.AvailableBytesIn == 0) return r;                          r = f;                          _codec.AvailableBytesIn--; _codec.TotalBytesIn++;                          expectedCheck += (uint)((_codec.InputBuffer[_codec.NextIn++] << 16) & 0x00ff0000);                          mode = InflateManagerMode.CHECK2;                          break;                        case InflateManagerMode.CHECK2:                          if (_codec.AvailableBytesIn == 0) return r;                          r = f;                          _codec.AvailableBytesIn--;                          _codec.TotalBytesIn++;                          expectedCheck += (uint)((_codec.InputBuffer[_codec.NextIn++] << 8) & 0x0000ff00);                          mode = InflateManagerMode.CHECK1;                          break;                        case InflateManagerMode.CHECK1:                          if (_codec.AvailableBytesIn == 0) return r;                          r = f;                          _codec.AvailableBytesIn--; _codec.TotalBytesIn++;                          expectedCheck += (uint)(_codec.InputBuffer[_codec.NextIn++] & 0x000000ff);                          if (computedCheck != expectedCheck)                          {                              mode = InflateManagerMode.BAD;                              _codec.Message = "incorrect data check";                              marker = 5; // can't try inflateSync                              break;                          }                          mode = InflateManagerMode.DONE;                          return ZlibConstants.Z_STREAM_END;                        case InflateManagerMode.DONE:                          return ZlibConstants.Z_STREAM_END;                        case InflateManagerMode.BAD:                          throw new ZlibException(String.Format("Bad state ({0})"' _codec.Message));                        default:                          throw new ZlibException("Stream error.");                    }
Magic Number,Ionic.Zlib,InflateManager,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zlib.Shared\Inflate.cs,Inflate,The following statement contains a magic number: switch (mode)                  {                      case InflateManagerMode.METHOD:                          if (_codec.AvailableBytesIn == 0) return r;                          r = f;                          _codec.AvailableBytesIn--;                          _codec.TotalBytesIn++;                          if (((method = _codec.InputBuffer[_codec.NextIn++]) & 0xf) != Z_DEFLATED)                          {                              mode = InflateManagerMode.BAD;                              _codec.Message = String.Format("unknown compression method (0x{0:X2})"' method);                              marker = 5; // can't try inflateSync                              break;                          }                          if ((method >> 4) + 8 > wbits)                          {                              mode = InflateManagerMode.BAD;                              _codec.Message = String.Format("invalid window size ({0})"' (method >> 4) + 8);                              marker = 5; // can't try inflateSync                              break;                          }                          mode = InflateManagerMode.FLAG;                          break;                          case InflateManagerMode.FLAG:                          if (_codec.AvailableBytesIn == 0) return r;                          r = f;                          _codec.AvailableBytesIn--;                          _codec.TotalBytesIn++;                          b = (_codec.InputBuffer[_codec.NextIn++]) & 0xff;                            if ((((method << 8) + b) % 31) != 0)                          {                              mode = InflateManagerMode.BAD;                              _codec.Message = "incorrect header check";                              marker = 5; // can't try inflateSync                              break;                          }                            mode = ((b & PRESET_DICT) == 0)                              ? InflateManagerMode.BLOCKS                              : InflateManagerMode.DICT4;                          break;                        case InflateManagerMode.DICT4:                          if (_codec.AvailableBytesIn == 0) return r;                          r = f;                          _codec.AvailableBytesIn--;                          _codec.TotalBytesIn++;                          expectedCheck = (uint)((_codec.InputBuffer[_codec.NextIn++] << 24) & 0xff000000);                          mode = InflateManagerMode.DICT3;                          break;                        case InflateManagerMode.DICT3:                          if (_codec.AvailableBytesIn == 0) return r;                          r = f;                          _codec.AvailableBytesIn--;                          _codec.TotalBytesIn++;                          expectedCheck += (uint)((_codec.InputBuffer[_codec.NextIn++] << 16) & 0x00ff0000);                          mode = InflateManagerMode.DICT2;                          break;                        case InflateManagerMode.DICT2:                            if (_codec.AvailableBytesIn == 0) return r;                          r = f;                          _codec.AvailableBytesIn--;                          _codec.TotalBytesIn++;                          expectedCheck += (uint)((_codec.InputBuffer[_codec.NextIn++] << 8) & 0x0000ff00);                          mode = InflateManagerMode.DICT1;                          break;                          case InflateManagerMode.DICT1:                          if (_codec.AvailableBytesIn == 0) return r;                          r = f;                          _codec.AvailableBytesIn--; _codec.TotalBytesIn++;                          expectedCheck += (uint)(_codec.InputBuffer[_codec.NextIn++] & 0x000000ff);                          _codec._Adler32 = expectedCheck;                          mode = InflateManagerMode.DICT0;                          return ZlibConstants.Z_NEED_DICT;                          case InflateManagerMode.DICT0:                          mode = InflateManagerMode.BAD;                          _codec.Message = "need dictionary";                          marker = 0; // can try inflateSync                          return ZlibConstants.Z_STREAM_ERROR;                          case InflateManagerMode.BLOCKS:                          r = blocks.Process(r);                          if (r == ZlibConstants.Z_DATA_ERROR)                          {                              mode = InflateManagerMode.BAD;                              marker = 0; // can try inflateSync                              break;                          }                            if (r == ZlibConstants.Z_OK) r = f;                            if (r != ZlibConstants.Z_STREAM_END)                              return r;                            r = f;                          computedCheck = blocks.Reset();                          if (!HandleRfc1950HeaderBytes)                          {                              mode = InflateManagerMode.DONE;                              return ZlibConstants.Z_STREAM_END;                          }                          mode = InflateManagerMode.CHECK4;                          break;                        case InflateManagerMode.CHECK4:                          if (_codec.AvailableBytesIn == 0) return r;                          r = f;                          _codec.AvailableBytesIn--;                          _codec.TotalBytesIn++;                          expectedCheck = (uint)((_codec.InputBuffer[_codec.NextIn++] << 24) & 0xff000000);                          mode = InflateManagerMode.CHECK3;                          break;                        case InflateManagerMode.CHECK3:                          if (_codec.AvailableBytesIn == 0) return r;                          r = f;                          _codec.AvailableBytesIn--; _codec.TotalBytesIn++;                          expectedCheck += (uint)((_codec.InputBuffer[_codec.NextIn++] << 16) & 0x00ff0000);                          mode = InflateManagerMode.CHECK2;                          break;                        case InflateManagerMode.CHECK2:                          if (_codec.AvailableBytesIn == 0) return r;                          r = f;                          _codec.AvailableBytesIn--;                          _codec.TotalBytesIn++;                          expectedCheck += (uint)((_codec.InputBuffer[_codec.NextIn++] << 8) & 0x0000ff00);                          mode = InflateManagerMode.CHECK1;                          break;                        case InflateManagerMode.CHECK1:                          if (_codec.AvailableBytesIn == 0) return r;                          r = f;                          _codec.AvailableBytesIn--; _codec.TotalBytesIn++;                          expectedCheck += (uint)(_codec.InputBuffer[_codec.NextIn++] & 0x000000ff);                          if (computedCheck != expectedCheck)                          {                              mode = InflateManagerMode.BAD;                              _codec.Message = "incorrect data check";                              marker = 5; // can't try inflateSync                              break;                          }                          mode = InflateManagerMode.DONE;                          return ZlibConstants.Z_STREAM_END;                        case InflateManagerMode.DONE:                          return ZlibConstants.Z_STREAM_END;                        case InflateManagerMode.BAD:                          throw new ZlibException(String.Format("Bad state ({0})"' _codec.Message));                        default:                          throw new ZlibException("Stream error.");                    }
Magic Number,Ionic.Zlib,InflateManager,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zlib.Shared\Inflate.cs,Inflate,The following statement contains a magic number: switch (mode)                  {                      case InflateManagerMode.METHOD:                          if (_codec.AvailableBytesIn == 0) return r;                          r = f;                          _codec.AvailableBytesIn--;                          _codec.TotalBytesIn++;                          if (((method = _codec.InputBuffer[_codec.NextIn++]) & 0xf) != Z_DEFLATED)                          {                              mode = InflateManagerMode.BAD;                              _codec.Message = String.Format("unknown compression method (0x{0:X2})"' method);                              marker = 5; // can't try inflateSync                              break;                          }                          if ((method >> 4) + 8 > wbits)                          {                              mode = InflateManagerMode.BAD;                              _codec.Message = String.Format("invalid window size ({0})"' (method >> 4) + 8);                              marker = 5; // can't try inflateSync                              break;                          }                          mode = InflateManagerMode.FLAG;                          break;                          case InflateManagerMode.FLAG:                          if (_codec.AvailableBytesIn == 0) return r;                          r = f;                          _codec.AvailableBytesIn--;                          _codec.TotalBytesIn++;                          b = (_codec.InputBuffer[_codec.NextIn++]) & 0xff;                            if ((((method << 8) + b) % 31) != 0)                          {                              mode = InflateManagerMode.BAD;                              _codec.Message = "incorrect header check";                              marker = 5; // can't try inflateSync                              break;                          }                            mode = ((b & PRESET_DICT) == 0)                              ? InflateManagerMode.BLOCKS                              : InflateManagerMode.DICT4;                          break;                        case InflateManagerMode.DICT4:                          if (_codec.AvailableBytesIn == 0) return r;                          r = f;                          _codec.AvailableBytesIn--;                          _codec.TotalBytesIn++;                          expectedCheck = (uint)((_codec.InputBuffer[_codec.NextIn++] << 24) & 0xff000000);                          mode = InflateManagerMode.DICT3;                          break;                        case InflateManagerMode.DICT3:                          if (_codec.AvailableBytesIn == 0) return r;                          r = f;                          _codec.AvailableBytesIn--;                          _codec.TotalBytesIn++;                          expectedCheck += (uint)((_codec.InputBuffer[_codec.NextIn++] << 16) & 0x00ff0000);                          mode = InflateManagerMode.DICT2;                          break;                        case InflateManagerMode.DICT2:                            if (_codec.AvailableBytesIn == 0) return r;                          r = f;                          _codec.AvailableBytesIn--;                          _codec.TotalBytesIn++;                          expectedCheck += (uint)((_codec.InputBuffer[_codec.NextIn++] << 8) & 0x0000ff00);                          mode = InflateManagerMode.DICT1;                          break;                          case InflateManagerMode.DICT1:                          if (_codec.AvailableBytesIn == 0) return r;                          r = f;                          _codec.AvailableBytesIn--; _codec.TotalBytesIn++;                          expectedCheck += (uint)(_codec.InputBuffer[_codec.NextIn++] & 0x000000ff);                          _codec._Adler32 = expectedCheck;                          mode = InflateManagerMode.DICT0;                          return ZlibConstants.Z_NEED_DICT;                          case InflateManagerMode.DICT0:                          mode = InflateManagerMode.BAD;                          _codec.Message = "need dictionary";                          marker = 0; // can try inflateSync                          return ZlibConstants.Z_STREAM_ERROR;                          case InflateManagerMode.BLOCKS:                          r = blocks.Process(r);                          if (r == ZlibConstants.Z_DATA_ERROR)                          {                              mode = InflateManagerMode.BAD;                              marker = 0; // can try inflateSync                              break;                          }                            if (r == ZlibConstants.Z_OK) r = f;                            if (r != ZlibConstants.Z_STREAM_END)                              return r;                            r = f;                          computedCheck = blocks.Reset();                          if (!HandleRfc1950HeaderBytes)                          {                              mode = InflateManagerMode.DONE;                              return ZlibConstants.Z_STREAM_END;                          }                          mode = InflateManagerMode.CHECK4;                          break;                        case InflateManagerMode.CHECK4:                          if (_codec.AvailableBytesIn == 0) return r;                          r = f;                          _codec.AvailableBytesIn--;                          _codec.TotalBytesIn++;                          expectedCheck = (uint)((_codec.InputBuffer[_codec.NextIn++] << 24) & 0xff000000);                          mode = InflateManagerMode.CHECK3;                          break;                        case InflateManagerMode.CHECK3:                          if (_codec.AvailableBytesIn == 0) return r;                          r = f;                          _codec.AvailableBytesIn--; _codec.TotalBytesIn++;                          expectedCheck += (uint)((_codec.InputBuffer[_codec.NextIn++] << 16) & 0x00ff0000);                          mode = InflateManagerMode.CHECK2;                          break;                        case InflateManagerMode.CHECK2:                          if (_codec.AvailableBytesIn == 0) return r;                          r = f;                          _codec.AvailableBytesIn--;                          _codec.TotalBytesIn++;                          expectedCheck += (uint)((_codec.InputBuffer[_codec.NextIn++] << 8) & 0x0000ff00);                          mode = InflateManagerMode.CHECK1;                          break;                        case InflateManagerMode.CHECK1:                          if (_codec.AvailableBytesIn == 0) return r;                          r = f;                          _codec.AvailableBytesIn--; _codec.TotalBytesIn++;                          expectedCheck += (uint)(_codec.InputBuffer[_codec.NextIn++] & 0x000000ff);                          if (computedCheck != expectedCheck)                          {                              mode = InflateManagerMode.BAD;                              _codec.Message = "incorrect data check";                              marker = 5; // can't try inflateSync                              break;                          }                          mode = InflateManagerMode.DONE;                          return ZlibConstants.Z_STREAM_END;                        case InflateManagerMode.DONE:                          return ZlibConstants.Z_STREAM_END;                        case InflateManagerMode.BAD:                          throw new ZlibException(String.Format("Bad state ({0})"' _codec.Message));                        default:                          throw new ZlibException("Stream error.");                    }
Magic Number,Ionic.Zlib,InflateManager,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zlib.Shared\Inflate.cs,Inflate,The following statement contains a magic number: switch (mode)                  {                      case InflateManagerMode.METHOD:                          if (_codec.AvailableBytesIn == 0) return r;                          r = f;                          _codec.AvailableBytesIn--;                          _codec.TotalBytesIn++;                          if (((method = _codec.InputBuffer[_codec.NextIn++]) & 0xf) != Z_DEFLATED)                          {                              mode = InflateManagerMode.BAD;                              _codec.Message = String.Format("unknown compression method (0x{0:X2})"' method);                              marker = 5; // can't try inflateSync                              break;                          }                          if ((method >> 4) + 8 > wbits)                          {                              mode = InflateManagerMode.BAD;                              _codec.Message = String.Format("invalid window size ({0})"' (method >> 4) + 8);                              marker = 5; // can't try inflateSync                              break;                          }                          mode = InflateManagerMode.FLAG;                          break;                          case InflateManagerMode.FLAG:                          if (_codec.AvailableBytesIn == 0) return r;                          r = f;                          _codec.AvailableBytesIn--;                          _codec.TotalBytesIn++;                          b = (_codec.InputBuffer[_codec.NextIn++]) & 0xff;                            if ((((method << 8) + b) % 31) != 0)                          {                              mode = InflateManagerMode.BAD;                              _codec.Message = "incorrect header check";                              marker = 5; // can't try inflateSync                              break;                          }                            mode = ((b & PRESET_DICT) == 0)                              ? InflateManagerMode.BLOCKS                              : InflateManagerMode.DICT4;                          break;                        case InflateManagerMode.DICT4:                          if (_codec.AvailableBytesIn == 0) return r;                          r = f;                          _codec.AvailableBytesIn--;                          _codec.TotalBytesIn++;                          expectedCheck = (uint)((_codec.InputBuffer[_codec.NextIn++] << 24) & 0xff000000);                          mode = InflateManagerMode.DICT3;                          break;                        case InflateManagerMode.DICT3:                          if (_codec.AvailableBytesIn == 0) return r;                          r = f;                          _codec.AvailableBytesIn--;                          _codec.TotalBytesIn++;                          expectedCheck += (uint)((_codec.InputBuffer[_codec.NextIn++] << 16) & 0x00ff0000);                          mode = InflateManagerMode.DICT2;                          break;                        case InflateManagerMode.DICT2:                            if (_codec.AvailableBytesIn == 0) return r;                          r = f;                          _codec.AvailableBytesIn--;                          _codec.TotalBytesIn++;                          expectedCheck += (uint)((_codec.InputBuffer[_codec.NextIn++] << 8) & 0x0000ff00);                          mode = InflateManagerMode.DICT1;                          break;                          case InflateManagerMode.DICT1:                          if (_codec.AvailableBytesIn == 0) return r;                          r = f;                          _codec.AvailableBytesIn--; _codec.TotalBytesIn++;                          expectedCheck += (uint)(_codec.InputBuffer[_codec.NextIn++] & 0x000000ff);                          _codec._Adler32 = expectedCheck;                          mode = InflateManagerMode.DICT0;                          return ZlibConstants.Z_NEED_DICT;                          case InflateManagerMode.DICT0:                          mode = InflateManagerMode.BAD;                          _codec.Message = "need dictionary";                          marker = 0; // can try inflateSync                          return ZlibConstants.Z_STREAM_ERROR;                          case InflateManagerMode.BLOCKS:                          r = blocks.Process(r);                          if (r == ZlibConstants.Z_DATA_ERROR)                          {                              mode = InflateManagerMode.BAD;                              marker = 0; // can try inflateSync                              break;                          }                            if (r == ZlibConstants.Z_OK) r = f;                            if (r != ZlibConstants.Z_STREAM_END)                              return r;                            r = f;                          computedCheck = blocks.Reset();                          if (!HandleRfc1950HeaderBytes)                          {                              mode = InflateManagerMode.DONE;                              return ZlibConstants.Z_STREAM_END;                          }                          mode = InflateManagerMode.CHECK4;                          break;                        case InflateManagerMode.CHECK4:                          if (_codec.AvailableBytesIn == 0) return r;                          r = f;                          _codec.AvailableBytesIn--;                          _codec.TotalBytesIn++;                          expectedCheck = (uint)((_codec.InputBuffer[_codec.NextIn++] << 24) & 0xff000000);                          mode = InflateManagerMode.CHECK3;                          break;                        case InflateManagerMode.CHECK3:                          if (_codec.AvailableBytesIn == 0) return r;                          r = f;                          _codec.AvailableBytesIn--; _codec.TotalBytesIn++;                          expectedCheck += (uint)((_codec.InputBuffer[_codec.NextIn++] << 16) & 0x00ff0000);                          mode = InflateManagerMode.CHECK2;                          break;                        case InflateManagerMode.CHECK2:                          if (_codec.AvailableBytesIn == 0) return r;                          r = f;                          _codec.AvailableBytesIn--;                          _codec.TotalBytesIn++;                          expectedCheck += (uint)((_codec.InputBuffer[_codec.NextIn++] << 8) & 0x0000ff00);                          mode = InflateManagerMode.CHECK1;                          break;                        case InflateManagerMode.CHECK1:                          if (_codec.AvailableBytesIn == 0) return r;                          r = f;                          _codec.AvailableBytesIn--; _codec.TotalBytesIn++;                          expectedCheck += (uint)(_codec.InputBuffer[_codec.NextIn++] & 0x000000ff);                          if (computedCheck != expectedCheck)                          {                              mode = InflateManagerMode.BAD;                              _codec.Message = "incorrect data check";                              marker = 5; // can't try inflateSync                              break;                          }                          mode = InflateManagerMode.DONE;                          return ZlibConstants.Z_STREAM_END;                        case InflateManagerMode.DONE:                          return ZlibConstants.Z_STREAM_END;                        case InflateManagerMode.BAD:                          throw new ZlibException(String.Format("Bad state ({0})"' _codec.Message));                        default:                          throw new ZlibException("Stream error.");                    }
Magic Number,Ionic.Zlib,InflateManager,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zlib.Shared\Inflate.cs,Inflate,The following statement contains a magic number: switch (mode)                  {                      case InflateManagerMode.METHOD:                          if (_codec.AvailableBytesIn == 0) return r;                          r = f;                          _codec.AvailableBytesIn--;                          _codec.TotalBytesIn++;                          if (((method = _codec.InputBuffer[_codec.NextIn++]) & 0xf) != Z_DEFLATED)                          {                              mode = InflateManagerMode.BAD;                              _codec.Message = String.Format("unknown compression method (0x{0:X2})"' method);                              marker = 5; // can't try inflateSync                              break;                          }                          if ((method >> 4) + 8 > wbits)                          {                              mode = InflateManagerMode.BAD;                              _codec.Message = String.Format("invalid window size ({0})"' (method >> 4) + 8);                              marker = 5; // can't try inflateSync                              break;                          }                          mode = InflateManagerMode.FLAG;                          break;                          case InflateManagerMode.FLAG:                          if (_codec.AvailableBytesIn == 0) return r;                          r = f;                          _codec.AvailableBytesIn--;                          _codec.TotalBytesIn++;                          b = (_codec.InputBuffer[_codec.NextIn++]) & 0xff;                            if ((((method << 8) + b) % 31) != 0)                          {                              mode = InflateManagerMode.BAD;                              _codec.Message = "incorrect header check";                              marker = 5; // can't try inflateSync                              break;                          }                            mode = ((b & PRESET_DICT) == 0)                              ? InflateManagerMode.BLOCKS                              : InflateManagerMode.DICT4;                          break;                        case InflateManagerMode.DICT4:                          if (_codec.AvailableBytesIn == 0) return r;                          r = f;                          _codec.AvailableBytesIn--;                          _codec.TotalBytesIn++;                          expectedCheck = (uint)((_codec.InputBuffer[_codec.NextIn++] << 24) & 0xff000000);                          mode = InflateManagerMode.DICT3;                          break;                        case InflateManagerMode.DICT3:                          if (_codec.AvailableBytesIn == 0) return r;                          r = f;                          _codec.AvailableBytesIn--;                          _codec.TotalBytesIn++;                          expectedCheck += (uint)((_codec.InputBuffer[_codec.NextIn++] << 16) & 0x00ff0000);                          mode = InflateManagerMode.DICT2;                          break;                        case InflateManagerMode.DICT2:                            if (_codec.AvailableBytesIn == 0) return r;                          r = f;                          _codec.AvailableBytesIn--;                          _codec.TotalBytesIn++;                          expectedCheck += (uint)((_codec.InputBuffer[_codec.NextIn++] << 8) & 0x0000ff00);                          mode = InflateManagerMode.DICT1;                          break;                          case InflateManagerMode.DICT1:                          if (_codec.AvailableBytesIn == 0) return r;                          r = f;                          _codec.AvailableBytesIn--; _codec.TotalBytesIn++;                          expectedCheck += (uint)(_codec.InputBuffer[_codec.NextIn++] & 0x000000ff);                          _codec._Adler32 = expectedCheck;                          mode = InflateManagerMode.DICT0;                          return ZlibConstants.Z_NEED_DICT;                          case InflateManagerMode.DICT0:                          mode = InflateManagerMode.BAD;                          _codec.Message = "need dictionary";                          marker = 0; // can try inflateSync                          return ZlibConstants.Z_STREAM_ERROR;                          case InflateManagerMode.BLOCKS:                          r = blocks.Process(r);                          if (r == ZlibConstants.Z_DATA_ERROR)                          {                              mode = InflateManagerMode.BAD;                              marker = 0; // can try inflateSync                              break;                          }                            if (r == ZlibConstants.Z_OK) r = f;                            if (r != ZlibConstants.Z_STREAM_END)                              return r;                            r = f;                          computedCheck = blocks.Reset();                          if (!HandleRfc1950HeaderBytes)                          {                              mode = InflateManagerMode.DONE;                              return ZlibConstants.Z_STREAM_END;                          }                          mode = InflateManagerMode.CHECK4;                          break;                        case InflateManagerMode.CHECK4:                          if (_codec.AvailableBytesIn == 0) return r;                          r = f;                          _codec.AvailableBytesIn--;                          _codec.TotalBytesIn++;                          expectedCheck = (uint)((_codec.InputBuffer[_codec.NextIn++] << 24) & 0xff000000);                          mode = InflateManagerMode.CHECK3;                          break;                        case InflateManagerMode.CHECK3:                          if (_codec.AvailableBytesIn == 0) return r;                          r = f;                          _codec.AvailableBytesIn--; _codec.TotalBytesIn++;                          expectedCheck += (uint)((_codec.InputBuffer[_codec.NextIn++] << 16) & 0x00ff0000);                          mode = InflateManagerMode.CHECK2;                          break;                        case InflateManagerMode.CHECK2:                          if (_codec.AvailableBytesIn == 0) return r;                          r = f;                          _codec.AvailableBytesIn--;                          _codec.TotalBytesIn++;                          expectedCheck += (uint)((_codec.InputBuffer[_codec.NextIn++] << 8) & 0x0000ff00);                          mode = InflateManagerMode.CHECK1;                          break;                        case InflateManagerMode.CHECK1:                          if (_codec.AvailableBytesIn == 0) return r;                          r = f;                          _codec.AvailableBytesIn--; _codec.TotalBytesIn++;                          expectedCheck += (uint)(_codec.InputBuffer[_codec.NextIn++] & 0x000000ff);                          if (computedCheck != expectedCheck)                          {                              mode = InflateManagerMode.BAD;                              _codec.Message = "incorrect data check";                              marker = 5; // can't try inflateSync                              break;                          }                          mode = InflateManagerMode.DONE;                          return ZlibConstants.Z_STREAM_END;                        case InflateManagerMode.DONE:                          return ZlibConstants.Z_STREAM_END;                        case InflateManagerMode.BAD:                          throw new ZlibException(String.Format("Bad state ({0})"' _codec.Message));                        default:                          throw new ZlibException("Stream error.");                    }
Magic Number,Ionic.Zlib,InflateManager,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zlib.Shared\Inflate.cs,Inflate,The following statement contains a magic number: switch (mode)                  {                      case InflateManagerMode.METHOD:                          if (_codec.AvailableBytesIn == 0) return r;                          r = f;                          _codec.AvailableBytesIn--;                          _codec.TotalBytesIn++;                          if (((method = _codec.InputBuffer[_codec.NextIn++]) & 0xf) != Z_DEFLATED)                          {                              mode = InflateManagerMode.BAD;                              _codec.Message = String.Format("unknown compression method (0x{0:X2})"' method);                              marker = 5; // can't try inflateSync                              break;                          }                          if ((method >> 4) + 8 > wbits)                          {                              mode = InflateManagerMode.BAD;                              _codec.Message = String.Format("invalid window size ({0})"' (method >> 4) + 8);                              marker = 5; // can't try inflateSync                              break;                          }                          mode = InflateManagerMode.FLAG;                          break;                          case InflateManagerMode.FLAG:                          if (_codec.AvailableBytesIn == 0) return r;                          r = f;                          _codec.AvailableBytesIn--;                          _codec.TotalBytesIn++;                          b = (_codec.InputBuffer[_codec.NextIn++]) & 0xff;                            if ((((method << 8) + b) % 31) != 0)                          {                              mode = InflateManagerMode.BAD;                              _codec.Message = "incorrect header check";                              marker = 5; // can't try inflateSync                              break;                          }                            mode = ((b & PRESET_DICT) == 0)                              ? InflateManagerMode.BLOCKS                              : InflateManagerMode.DICT4;                          break;                        case InflateManagerMode.DICT4:                          if (_codec.AvailableBytesIn == 0) return r;                          r = f;                          _codec.AvailableBytesIn--;                          _codec.TotalBytesIn++;                          expectedCheck = (uint)((_codec.InputBuffer[_codec.NextIn++] << 24) & 0xff000000);                          mode = InflateManagerMode.DICT3;                          break;                        case InflateManagerMode.DICT3:                          if (_codec.AvailableBytesIn == 0) return r;                          r = f;                          _codec.AvailableBytesIn--;                          _codec.TotalBytesIn++;                          expectedCheck += (uint)((_codec.InputBuffer[_codec.NextIn++] << 16) & 0x00ff0000);                          mode = InflateManagerMode.DICT2;                          break;                        case InflateManagerMode.DICT2:                            if (_codec.AvailableBytesIn == 0) return r;                          r = f;                          _codec.AvailableBytesIn--;                          _codec.TotalBytesIn++;                          expectedCheck += (uint)((_codec.InputBuffer[_codec.NextIn++] << 8) & 0x0000ff00);                          mode = InflateManagerMode.DICT1;                          break;                          case InflateManagerMode.DICT1:                          if (_codec.AvailableBytesIn == 0) return r;                          r = f;                          _codec.AvailableBytesIn--; _codec.TotalBytesIn++;                          expectedCheck += (uint)(_codec.InputBuffer[_codec.NextIn++] & 0x000000ff);                          _codec._Adler32 = expectedCheck;                          mode = InflateManagerMode.DICT0;                          return ZlibConstants.Z_NEED_DICT;                          case InflateManagerMode.DICT0:                          mode = InflateManagerMode.BAD;                          _codec.Message = "need dictionary";                          marker = 0; // can try inflateSync                          return ZlibConstants.Z_STREAM_ERROR;                          case InflateManagerMode.BLOCKS:                          r = blocks.Process(r);                          if (r == ZlibConstants.Z_DATA_ERROR)                          {                              mode = InflateManagerMode.BAD;                              marker = 0; // can try inflateSync                              break;                          }                            if (r == ZlibConstants.Z_OK) r = f;                            if (r != ZlibConstants.Z_STREAM_END)                              return r;                            r = f;                          computedCheck = blocks.Reset();                          if (!HandleRfc1950HeaderBytes)                          {                              mode = InflateManagerMode.DONE;                              return ZlibConstants.Z_STREAM_END;                          }                          mode = InflateManagerMode.CHECK4;                          break;                        case InflateManagerMode.CHECK4:                          if (_codec.AvailableBytesIn == 0) return r;                          r = f;                          _codec.AvailableBytesIn--;                          _codec.TotalBytesIn++;                          expectedCheck = (uint)((_codec.InputBuffer[_codec.NextIn++] << 24) & 0xff000000);                          mode = InflateManagerMode.CHECK3;                          break;                        case InflateManagerMode.CHECK3:                          if (_codec.AvailableBytesIn == 0) return r;                          r = f;                          _codec.AvailableBytesIn--; _codec.TotalBytesIn++;                          expectedCheck += (uint)((_codec.InputBuffer[_codec.NextIn++] << 16) & 0x00ff0000);                          mode = InflateManagerMode.CHECK2;                          break;                        case InflateManagerMode.CHECK2:                          if (_codec.AvailableBytesIn == 0) return r;                          r = f;                          _codec.AvailableBytesIn--;                          _codec.TotalBytesIn++;                          expectedCheck += (uint)((_codec.InputBuffer[_codec.NextIn++] << 8) & 0x0000ff00);                          mode = InflateManagerMode.CHECK1;                          break;                        case InflateManagerMode.CHECK1:                          if (_codec.AvailableBytesIn == 0) return r;                          r = f;                          _codec.AvailableBytesIn--; _codec.TotalBytesIn++;                          expectedCheck += (uint)(_codec.InputBuffer[_codec.NextIn++] & 0x000000ff);                          if (computedCheck != expectedCheck)                          {                              mode = InflateManagerMode.BAD;                              _codec.Message = "incorrect data check";                              marker = 5; // can't try inflateSync                              break;                          }                          mode = InflateManagerMode.DONE;                          return ZlibConstants.Z_STREAM_END;                        case InflateManagerMode.DONE:                          return ZlibConstants.Z_STREAM_END;                        case InflateManagerMode.BAD:                          throw new ZlibException(String.Format("Bad state ({0})"' _codec.Message));                        default:                          throw new ZlibException("Stream error.");                    }
Magic Number,Ionic.Zlib,InflateManager,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zlib.Shared\Inflate.cs,Sync,The following statement contains a magic number: n != 0 && m < 4
Magic Number,Ionic.Zlib,InflateManager,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zlib.Shared\Inflate.cs,Sync,The following statement contains a magic number: m != 4
Magic Number,Ionic.Zlib,InfTree,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zlib.Shared\InfTree.cs,huft_build,The following statement contains a magic number: xp = 2;
Magic Number,Ionic.Zlib,InfTree,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zlib.Shared\InfTree.cs,huft_build,The following statement contains a magic number: r[2] = (int) (q - u[h - 1] - j);
Magic Number,Ionic.Zlib,InfTree,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zlib.Shared\InfTree.cs,huft_build,The following statement contains a magic number: Array.Copy(r' 0' hp' (u[h - 1] + j) * 3' 3);
Magic Number,Ionic.Zlib,InfTree,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zlib.Shared\InfTree.cs,huft_build,The following statement contains a magic number: Array.Copy(r' 0' hp' (u[h - 1] + j) * 3' 3);
Magic Number,Ionic.Zlib,InfTree,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zlib.Shared\InfTree.cs,huft_build,The following statement contains a magic number: r[0] = 128 + 64;
Magic Number,Ionic.Zlib,InfTree,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zlib.Shared\InfTree.cs,huft_build,The following statement contains a magic number: r[0] = 128 + 64;
Magic Number,Ionic.Zlib,InfTree,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zlib.Shared\InfTree.cs,huft_build,The following statement contains a magic number: Array.Copy(r' 0' hp' (q + j) * 3' 3);
Magic Number,Ionic.Zlib,InfTree,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zlib.Shared\InfTree.cs,huft_build,The following statement contains a magic number: Array.Copy(r' 0' hp' (q + j) * 3' 3);
Magic Number,Ionic.Zlib,InfTree,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zlib.Shared\InfTree.cs,inflate_trees_bits,The following statement contains a magic number: initWorkArea(19);
Magic Number,Ionic.Zlib,InfTree,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zlib.Shared\InfTree.cs,inflate_trees_bits,The following statement contains a magic number: result = huft_build(c' 0' 19' 19' null' null' tb' bb' hp' hn' v);
Magic Number,Ionic.Zlib,InfTree,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zlib.Shared\InfTree.cs,inflate_trees_bits,The following statement contains a magic number: result = huft_build(c' 0' 19' 19' null' null' tb' bb' hp' hn' v);
Magic Number,Ionic.Zlib,InfTree,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zlib.Shared\InfTree.cs,inflate_trees_dynamic,The following statement contains a magic number: initWorkArea(288);
Magic Number,Ionic.Zlib,InfTree,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zlib.Shared\InfTree.cs,inflate_trees_dynamic,The following statement contains a magic number: result = huft_build(c' 0' nl' 257' cplens' cplext' tl' bl' hp' hn' v);
Magic Number,Ionic.Zlib,InfTree,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zlib.Shared\InfTree.cs,inflate_trees_dynamic,The following statement contains a magic number: initWorkArea(288);
Magic Number,Ionic.Zlib,InfTree,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zlib.Shared\InfTree.cs,inflate_trees_dynamic,The following statement contains a magic number: result != Z_OK || (bd[0] == 0 && nl > 257)
Magic Number,Ionic.Zlib,InfTree,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zlib.Shared\InfTree.cs,initWorkArea,The following statement contains a magic number: r = new int[3];
Magic Number,Ionic.Zlib,WorkItem,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zlib.Shared\ParallelDeflateOutputStream.cs,WorkItem,The following statement contains a magic number: int n = size + ((size / 32768)+1) * 5 * 2;
Magic Number,Ionic.Zlib,WorkItem,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zlib.Shared\ParallelDeflateOutputStream.cs,WorkItem,The following statement contains a magic number: int n = size + ((size / 32768)+1) * 5 * 2;
Magic Number,Ionic.Zlib,WorkItem,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zlib.Shared\ParallelDeflateOutputStream.cs,WorkItem,The following statement contains a magic number: int n = size + ((size / 32768)+1) * 5 * 2;
Magic Number,Ionic.Zlib,ParallelDeflateOutputStream,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zlib.Shared\ParallelDeflateOutputStream.cs,ParallelDeflateOutputStream,The following statement contains a magic number: this.MaxBufferPairs = 16;
Magic Number,Ionic.Zlib,ParallelDeflateOutputStream,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zlib.Shared\ParallelDeflateOutputStream.cs,_FlushFinish,The following statement contains a magic number: byte[] buffer = new byte[128];
Magic Number,Ionic.Zlib,ParallelDeflateOutputStream,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zlib.Shared\ParallelDeflateOutputStream.cs,EmitPendingBuffers,The following statement contains a magic number: int millisecondsToWait = doAll ? 200 : (mustWait ? -1 : 0);
Magic Number,Ionic.Zlib,ParallelDeflateOutputStream,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zlib.Shared\ParallelDeflateOutputStream.cs,TraceOutput,The following statement contains a magic number: Console.ForegroundColor = (ConsoleColor) (tid % 8 + 8);
Magic Number,Ionic.Zlib,ParallelDeflateOutputStream,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zlib.Shared\ParallelDeflateOutputStream.cs,TraceOutput,The following statement contains a magic number: Console.ForegroundColor = (ConsoleColor) (tid % 8 + 8);
Magic Number,Ionic.Zlib,Tree,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zlib.Shared\Tree.cs,DistanceCode,The following statement contains a magic number: return (dist < 256)                  ? _dist_code[dist]                  : _dist_code[256 + SharedUtils.URShift(dist' 7)];
Magic Number,Ionic.Zlib,Tree,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zlib.Shared\Tree.cs,DistanceCode,The following statement contains a magic number: return (dist < 256)                  ? _dist_code[dist]                  : _dist_code[256 + SharedUtils.URShift(dist' 7)];
Magic Number,Ionic.Zlib,Tree,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zlib.Shared\Tree.cs,DistanceCode,The following statement contains a magic number: return (dist < 256)                  ? _dist_code[dist]                  : _dist_code[256 + SharedUtils.URShift(dist' 7)];
Magic Number,Ionic.Zlib,Tree,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zlib.Shared\Tree.cs,gen_bitlen,The following statement contains a magic number: tree[s.heap[s.heap_max] * 2 + 1] = 0;
Magic Number,Ionic.Zlib,Tree,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zlib.Shared\Tree.cs,gen_bitlen,The following statement contains a magic number: bits = tree[tree[n * 2 + 1] * 2 + 1] + 1;
Magic Number,Ionic.Zlib,Tree,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zlib.Shared\Tree.cs,gen_bitlen,The following statement contains a magic number: bits = tree[tree[n * 2 + 1] * 2 + 1] + 1;
Magic Number,Ionic.Zlib,Tree,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zlib.Shared\Tree.cs,gen_bitlen,The following statement contains a magic number: tree[n * 2 + 1] = (short) bits;
Magic Number,Ionic.Zlib,Tree,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zlib.Shared\Tree.cs,gen_bitlen,The following statement contains a magic number: f = tree[n * 2];
Magic Number,Ionic.Zlib,Tree,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zlib.Shared\Tree.cs,gen_bitlen,The following statement contains a magic number: s.static_len += f * (stree[n * 2 + 1] + xbits);
Magic Number,Ionic.Zlib,Tree,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zlib.Shared\Tree.cs,gen_bitlen,The following statement contains a magic number: s.bl_count[bits + 1] = (short) (s.bl_count[bits + 1] + 2);
Magic Number,Ionic.Zlib,Tree,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zlib.Shared\Tree.cs,gen_bitlen,The following statement contains a magic number: overflow -= 2;
Magic Number,Ionic.Zlib,Tree,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zlib.Shared\Tree.cs,gen_bitlen,The following statement contains a magic number: s.opt_len = (int) (s.opt_len + ((long) bits - (long) tree[m * 2 + 1]) * (long) tree[m * 2]);
Magic Number,Ionic.Zlib,Tree,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zlib.Shared\Tree.cs,gen_bitlen,The following statement contains a magic number: s.opt_len = (int) (s.opt_len + ((long) bits - (long) tree[m * 2 + 1]) * (long) tree[m * 2]);
Magic Number,Ionic.Zlib,Tree,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zlib.Shared\Tree.cs,gen_bitlen,The following statement contains a magic number: tree[m * 2 + 1] = (short) bits;
Magic Number,Ionic.Zlib,Tree,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zlib.Shared\Tree.cs,gen_bitlen,The following statement contains a magic number: tree[m * 2 + 1] != bits
Magic Number,Ionic.Zlib,Tree,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zlib.Shared\Tree.cs,build_tree,The following statement contains a magic number: tree[n * 2] != 0
Magic Number,Ionic.Zlib,Tree,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zlib.Shared\Tree.cs,build_tree,The following statement contains a magic number: node = s.heap[++s.heap_len] = (max_code < 2?++max_code:0);
Magic Number,Ionic.Zlib,Tree,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zlib.Shared\Tree.cs,build_tree,The following statement contains a magic number: tree[node * 2] = 1;
Magic Number,Ionic.Zlib,Tree,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zlib.Shared\Tree.cs,build_tree,The following statement contains a magic number: s.static_len -= stree[node * 2 + 1];
Magic Number,Ionic.Zlib,Tree,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zlib.Shared\Tree.cs,build_tree,The following statement contains a magic number: s.heap_len < 2
Magic Number,Ionic.Zlib,Tree,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zlib.Shared\Tree.cs,build_tree,The following statement contains a magic number: tree[node * 2] = unchecked((short) (tree[n * 2] + tree[m * 2]));
Magic Number,Ionic.Zlib,Tree,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zlib.Shared\Tree.cs,build_tree,The following statement contains a magic number: tree[node * 2] = unchecked((short) (tree[n * 2] + tree[m * 2]));
Magic Number,Ionic.Zlib,Tree,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zlib.Shared\Tree.cs,build_tree,The following statement contains a magic number: tree[node * 2] = unchecked((short) (tree[n * 2] + tree[m * 2]));
Magic Number,Ionic.Zlib,Tree,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zlib.Shared\Tree.cs,build_tree,The following statement contains a magic number: tree[n * 2 + 1] = tree[m * 2 + 1] = (short) node;
Magic Number,Ionic.Zlib,Tree,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zlib.Shared\Tree.cs,build_tree,The following statement contains a magic number: tree[n * 2 + 1] = tree[m * 2 + 1] = (short) node;
Magic Number,Ionic.Zlib,Tree,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zlib.Shared\Tree.cs,gen_codes,The following statement contains a magic number: int len = tree[n * 2 + 1];
Magic Number,Ionic.Zlib,Tree,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zlib.Shared\Tree.cs,gen_codes,The following statement contains a magic number: tree[n * 2] =  unchecked((short) (bi_reverse(next_code[len]++' len)));
Magic Number,Ionic.Zlib,Adler,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zlib.Shared\Zlib.cs,Adler32,The following statement contains a magic number: uint s2 = (uint) ((adler >> 16) & 0xffff);
Magic Number,Ionic.Zlib,Adler,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zlib.Shared\Zlib.cs,Adler32,The following statement contains a magic number: k -= 16;
Magic Number,Ionic.Zlib,Adler,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zlib.Shared\Zlib.cs,Adler32,The following statement contains a magic number: k >= 16
Magic Number,Ionic.Zlib,Adler,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zlib.Shared\Zlib.cs,Adler32,The following statement contains a magic number: return (uint)((s2 << 16) | s1);
Magic Number,Ionic.Zlib,ZlibBaseStream,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zlib.Shared\ZlibBaseStream.cs,Write,The following statement contains a magic number: done = (_z.AvailableBytesIn == 8 && _z.AvailableBytesOut != 0);
Magic Number,Ionic.Zlib,ZlibBaseStream,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zlib.Shared\ZlibBaseStream.cs,finish,The following statement contains a magic number: done = (_z.AvailableBytesIn == 8 && _z.AvailableBytesOut != 0);
Magic Number,Ionic.Zlib,ZlibBaseStream,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zlib.Shared\ZlibBaseStream.cs,finish,The following statement contains a magic number: _stream.Write(BitConverter.GetBytes(c1)' 0' 4);
Magic Number,Ionic.Zlib,ZlibBaseStream,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zlib.Shared\ZlibBaseStream.cs,finish,The following statement contains a magic number: _stream.Write(BitConverter.GetBytes(c2)' 0' 4);
Magic Number,Ionic.Zlib,ZlibBaseStream,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zlib.Shared\ZlibBaseStream.cs,_ReadAndValidateGzipHeader,The following statement contains a magic number: byte[] header = new byte[10];
Magic Number,Ionic.Zlib,ZlibBaseStream,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zlib.Shared\ZlibBaseStream.cs,_ReadAndValidateGzipHeader,The following statement contains a magic number: n != 10
Magic Number,Ionic.Zlib,ZlibBaseStream,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zlib.Shared\ZlibBaseStream.cs,_ReadAndValidateGzipHeader,The following statement contains a magic number: header[0] != 0x1F || header[1] != 0x8B || header[2] != 8
Magic Number,Ionic.Zlib,ZlibBaseStream,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zlib.Shared\ZlibBaseStream.cs,_ReadAndValidateGzipHeader,The following statement contains a magic number: header[0] != 0x1F || header[1] != 0x8B || header[2] != 8
Magic Number,Ionic.Zlib,ZlibBaseStream,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zlib.Shared\ZlibBaseStream.cs,_ReadAndValidateGzipHeader,The following statement contains a magic number: Int32 timet = BitConverter.ToInt32(header' 4);
Magic Number,Ionic.Zlib,ZlibBaseStream,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zlib.Shared\ZlibBaseStream.cs,_ReadAndValidateGzipHeader,The following statement contains a magic number: n = _stream.Read(header' 0' 2);
Magic Number,Ionic.Zlib,ZlibBaseStream,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zlib.Shared\ZlibBaseStream.cs,_ReadAndValidateGzipHeader,The following statement contains a magic number: Int16 extraLength = (Int16)(header[0] + header[1] * 256);
Magic Number,Ionic.Zlib,ZlibBaseStream,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zlib.Shared\ZlibBaseStream.cs,_ReadAndValidateGzipHeader,The following statement contains a magic number: (header[3] & 0x04) == 0x04
Magic Number,Ionic.Zlib,ZlibBaseStream,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zlib.Shared\ZlibBaseStream.cs,_ReadAndValidateGzipHeader,The following statement contains a magic number: (header[3] & 0x08) == 0x08
Magic Number,Ionic.Zlib,ZlibBaseStream,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zlib.Shared\ZlibBaseStream.cs,_ReadAndValidateGzipHeader,The following statement contains a magic number: (header[3] & 0x10) == 0x010
Magic Number,Ionic.Zlib,ZlibBaseStream,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zlib.Shared\ZlibBaseStream.cs,_ReadAndValidateGzipHeader,The following statement contains a magic number: (header[3] & 0x02) == 0x02
Magic Number,Ionic.Zlib,ZlibBaseStream,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zlib.Shared\ZlibBaseStream.cs,UncompressString,The following statement contains a magic number: byte[] working = new byte[1024];
Magic Number,Ionic.Zlib,ZlibBaseStream,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zlib.Shared\ZlibBaseStream.cs,UncompressBuffer,The following statement contains a magic number: byte[] working = new byte[1024];
Magic Number,Ionic.Zip,SharedUtilities,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\Shared.cs,SimplifyFwdSlashPath,The following statement contains a magic number: path = path.Substring(2);
Magic Number,Ionic.Zip,SharedUtilities,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\Shared.cs,NormalizePathForUseInZipFile,The following statement contains a magic number: pathName =  pathName.Substring(3);
Magic Number,Ionic.Zip,SharedUtilities,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\Shared.cs,NormalizePathForUseInZipFile,The following statement contains a magic number: (pathName.Length >= 2)  && ((pathName[1] == ':') && (pathName[2] == '\\'))
Magic Number,Ionic.Zip,SharedUtilities,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\Shared.cs,NormalizePathForUseInZipFile,The following statement contains a magic number: (pathName.Length >= 2)  && ((pathName[1] == ':') && (pathName[2] == '\\'))
Magic Number,Ionic.Zip,SharedUtilities,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\Shared.cs,StringToByteArray,The following statement contains a magic number: ibm437 = System.Text.CodePagesEncodingProvider.Instance.GetEncoding(1252);
Magic Number,Ionic.Zip,SharedUtilities,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\Shared.cs,ReadEntrySignature,The following statement contains a magic number: s.Seek(12' SeekOrigin.Current);
Magic Number,Ionic.Zip,SharedUtilities,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\Shared.cs,ReadEntrySignature,The following statement contains a magic number: s.Seek(8' SeekOrigin.Current);
Magic Number,Ionic.Zip,SharedUtilities,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\Shared.cs,ReadEntrySignature,The following statement contains a magic number: s.Seek(-24' SeekOrigin.Current);
Magic Number,Ionic.Zip,SharedUtilities,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\Shared.cs,_ReadFourBytes,The following statement contains a magic number: byte[] block = new byte[4];
Magic Number,Ionic.Zip,SharedUtilities,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\Shared.cs,_ReadFourBytes,The following statement contains a magic number: int data = unchecked((((block[3] * 256 + block[2]) * 256) + block[1]) * 256 + block[0]);
Magic Number,Ionic.Zip,SharedUtilities,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\Shared.cs,_ReadFourBytes,The following statement contains a magic number: int data = unchecked((((block[3] * 256 + block[2]) * 256) + block[1]) * 256 + block[0]);
Magic Number,Ionic.Zip,SharedUtilities,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\Shared.cs,_ReadFourBytes,The following statement contains a magic number: int data = unchecked((((block[3] * 256 + block[2]) * 256) + block[1]) * 256 + block[0]);
Magic Number,Ionic.Zip,SharedUtilities,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\Shared.cs,_ReadFourBytes,The following statement contains a magic number: int data = unchecked((((block[3] * 256 + block[2]) * 256) + block[1]) * 256 + block[0]);
Magic Number,Ionic.Zip,SharedUtilities,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\Shared.cs,_ReadFourBytes,The following statement contains a magic number: int data = unchecked((((block[3] * 256 + block[2]) * 256) + block[1]) * 256 + block[0]);
Magic Number,Ionic.Zip,SharedUtilities,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\Shared.cs,FindSignature,The following statement contains a magic number: int BATCH_SIZE = 65536;
Magic Number,Ionic.Zip,SharedUtilities,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\Shared.cs,FindSignature,The following statement contains a magic number: byte[] targetBytes = new byte[4];
Magic Number,Ionic.Zip,SharedUtilities,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\Shared.cs,FindSignature,The following statement contains a magic number: targetBytes[0] = (byte)(SignatureToFind >> 24);
Magic Number,Ionic.Zip,SharedUtilities,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\Shared.cs,FindSignature,The following statement contains a magic number: targetBytes[1] = (byte)((SignatureToFind & 0x00FF0000) >> 16);
Magic Number,Ionic.Zip,SharedUtilities,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\Shared.cs,FindSignature,The following statement contains a magic number: targetBytes[2] = (byte)((SignatureToFind & 0x0000FF00) >> 8);
Magic Number,Ionic.Zip,SharedUtilities,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\Shared.cs,FindSignature,The following statement contains a magic number: targetBytes[2] = (byte)((SignatureToFind & 0x0000FF00) >> 8);
Magic Number,Ionic.Zip,SharedUtilities,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\Shared.cs,FindSignature,The following statement contains a magic number: targetBytes[3] = (byte)(SignatureToFind & 0x000000FF);
Magic Number,Ionic.Zip,SharedUtilities,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\Shared.cs,FindSignature,The following statement contains a magic number: batch[i] == targetBytes[3]
Magic Number,Ionic.Zip,SharedUtilities,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\Shared.cs,FindSignature,The following statement contains a magic number: long bytesRead = (stream.Position - startingPosition) - 4;
Magic Number,Ionic.Zip,SharedUtilities,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\Shared.cs,PackedToDateTime,The following statement contains a magic number: return new System.DateTime(1995' 1' 1' 0' 0' 0' 0);
Magic Number,Ionic.Zip,SharedUtilities,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\Shared.cs,PackedToDateTime,The following statement contains a magic number: Int16 packedDate = unchecked((Int16)((packedDateTime & 0xffff0000) >> 16));
Magic Number,Ionic.Zip,SharedUtilities,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\Shared.cs,PackedToDateTime,The following statement contains a magic number: int year = 1980 + ((packedDate & 0xFE00) >> 9);
Magic Number,Ionic.Zip,SharedUtilities,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\Shared.cs,PackedToDateTime,The following statement contains a magic number: int year = 1980 + ((packedDate & 0xFE00) >> 9);
Magic Number,Ionic.Zip,SharedUtilities,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\Shared.cs,PackedToDateTime,The following statement contains a magic number: int month = (packedDate & 0x01E0) >> 5;
Magic Number,Ionic.Zip,SharedUtilities,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\Shared.cs,PackedToDateTime,The following statement contains a magic number: int hour = (packedTime & 0xF800) >> 11;
Magic Number,Ionic.Zip,SharedUtilities,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\Shared.cs,PackedToDateTime,The following statement contains a magic number: int minute = (packedTime & 0x07E0) >> 5;
Magic Number,Ionic.Zip,SharedUtilities,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\Shared.cs,PackedToDateTime,The following statement contains a magic number: int second = (packedTime & 0x001F) * 2;
Magic Number,Ionic.Zip,SharedUtilities,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\Shared.cs,PackedToDateTime,The following statement contains a magic number: second >= 60
Magic Number,Ionic.Zip,SharedUtilities,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\Shared.cs,PackedToDateTime,The following statement contains a magic number: minute >= 60
Magic Number,Ionic.Zip,SharedUtilities,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\Shared.cs,PackedToDateTime,The following statement contains a magic number: hour >= 24
Magic Number,Ionic.Zip,SharedUtilities,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\Shared.cs,DateTimeToPacked,The following statement contains a magic number: UInt16 packedDate = (UInt16)((time.Day & 0x0000001F) | ((time.Month << 5) & 0x000001E0) | (((time.Year - 1980) << 9) & 0x0000FE00));
Magic Number,Ionic.Zip,SharedUtilities,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\Shared.cs,DateTimeToPacked,The following statement contains a magic number: UInt16 packedDate = (UInt16)((time.Day & 0x0000001F) | ((time.Month << 5) & 0x000001E0) | (((time.Year - 1980) << 9) & 0x0000FE00));
Magic Number,Ionic.Zip,SharedUtilities,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\Shared.cs,DateTimeToPacked,The following statement contains a magic number: UInt16 packedDate = (UInt16)((time.Day & 0x0000001F) | ((time.Month << 5) & 0x000001E0) | (((time.Year - 1980) << 9) & 0x0000FE00));
Magic Number,Ionic.Zip,SharedUtilities,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\Shared.cs,DateTimeToPacked,The following statement contains a magic number: UInt16 packedTime = (UInt16)((time.Second / 2 & 0x0000001F) | ((time.Minute << 5) & 0x000007E0) | ((time.Hour << 11) & 0x0000F800));
Magic Number,Ionic.Zip,SharedUtilities,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\Shared.cs,DateTimeToPacked,The following statement contains a magic number: UInt16 packedTime = (UInt16)((time.Second / 2 & 0x0000001F) | ((time.Minute << 5) & 0x000007E0) | ((time.Hour << 11) & 0x0000F800));
Magic Number,Ionic.Zip,SharedUtilities,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\Shared.cs,DateTimeToPacked,The following statement contains a magic number: UInt16 packedTime = (UInt16)((time.Second / 2 & 0x0000001F) | ((time.Minute << 5) & 0x000007E0) | ((time.Hour << 11) & 0x0000F800));
Magic Number,Ionic.Zip,SharedUtilities,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\Shared.cs,DateTimeToPacked,The following statement contains a magic number: Int32 result = (Int32)(((UInt32)(packedDate << 16)) | packedTime);
Magic Number,Ionic.Zip,SharedUtilities,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\Shared.cs,CreateAndOpenUniqueTempFile,The following statement contains a magic number: i < 3
Magic Number,Ionic.Zip,SharedUtilities,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\Shared.cs,InternalGetTempFileName,The following statement contains a magic number: return "DotNetZip-" + Path.GetRandomFileName().Substring(0' 8) + ".tmp";
Magic Number,Ionic.Zip,WinZipAesCrypto,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\WinZipAes.cs,Generate,The following statement contains a magic number: int saltSizeInBytes = c._KeyStrengthInBytes / 2;
Magic Number,Ionic.Zip,WinZipAesCrypto,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\WinZipAes.cs,ReadFromStream,The following statement contains a magic number: int saltSizeInBytes = c._KeyStrengthInBytes / 2;
Magic Number,Ionic.Zip,WinZipAesCrypto,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\WinZipAes.cs,ReadFromStream,The following statement contains a magic number: c._providedPv = new byte[2];
Magic Number,Ionic.Zip,WinZipAesCrypto,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\WinZipAes.cs,ReadFromStream,The following statement contains a magic number: c.PasswordVerificationStored = (Int16)(c._providedPv[0] + c._providedPv[1] * 256);
Magic Number,Ionic.Zip,WinZipAesCrypto,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\WinZipAes.cs,ReadFromStream,The following statement contains a magic number: c.PasswordVerificationGenerated = (Int16)(c.GeneratedPV[0] + c.GeneratedPV[1] * 256);
Magic Number,Ionic.Zip,WinZipAesCrypto,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\WinZipAes.cs,_GenerateCryptoBytes,The following statement contains a magic number: _generatedPv = rfc2898.GetBytes(2);
Magic Number,Ionic.Zip,WinZipAesCrypto,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\WinZipAes.cs,ReadAndVerifyMac,The following statement contains a magic number: _StoredMac = new byte[10];
Magic Number,Ionic.Zip,WinZipAesCipherStream,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\WinZipAes.cs,WinZipAesCipherStream,The following statement contains a magic number: int keySizeInBits = _params.KeyBytes.Length * 8;
Magic Number,Ionic.Zip,WinZipAesCipherStream,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\WinZipAes.cs,WinZipAesCipherStream,The following statement contains a magic number: keySizeInBits != 256 && keySizeInBits != 128 && keySizeInBits != 192
Magic Number,Ionic.Zip,WinZipAesCipherStream,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\WinZipAes.cs,WinZipAesCipherStream,The following statement contains a magic number: keySizeInBits != 256 && keySizeInBits != 128 && keySizeInBits != 192
Magic Number,Ionic.Zip,WinZipAesCipherStream,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\WinZipAes.cs,WinZipAesCipherStream,The following statement contains a magic number: keySizeInBits != 256 && keySizeInBits != 128 && keySizeInBits != 192
Magic Number,Ionic.Zip,WinZipAesCipherStream,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\WinZipAes.cs,WinZipAesCipherStream,The following statement contains a magic number: _aesCipher.BlockSize = 128;
Magic Number,Ionic.Zip,WinZipAesCipherStream,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\WinZipAes.cs,WinZipAesCipherStream,The following statement contains a magic number: _iobuf = new byte[2048];
Magic Number,Ionic.Zip,WinZipAesCipherStream,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\WinZipAes.cs,WriteTransformOneBlock,The following statement contains a magic number: System.Array.Copy(BitConverter.GetBytes(_nonce++)' 0' counter' 0' 4);
Magic Number,Ionic.Zip,WinZipAesCipherStream,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\WinZipAes.cs,WriteTransformFinalBlock,The following statement contains a magic number: System.Array.Copy(BitConverter.GetBytes(_nonce++)' 0' counter' 0' 4);
Magic Number,Ionic.Zip,WinZipAesCipherStream,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\WinZipAes.cs,ReadTransformOneBlock,The following statement contains a magic number: System.Array.Copy(BitConverter.GetBytes(_nonce++)' 0' counter' 0' 4);
Magic Number,Ionic.Zip,WinZipAesCipherStream,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\WinZipAes.cs,TraceOutput,The following statement contains a magic number: Console.ForegroundColor = (ConsoleColor) (tid % 8 + 8);
Magic Number,Ionic.Zip,WinZipAesCipherStream,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\WinZipAes.cs,TraceOutput,The following statement contains a magic number: Console.ForegroundColor = (ConsoleColor) (tid % 8 + 8);
Magic Number,Ionic.Zip,ZipCrypto,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipCrypto.cs,ForRead,The following statement contains a magic number: e._WeakEncryptionHeader = new byte[12];
Magic Number,Ionic.Zip,ZipCrypto,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipCrypto.cs,ForRead,The following statement contains a magic number: DecryptedHeader[11] != (byte)((e._Crc32 >> 24) & 0xff)
Magic Number,Ionic.Zip,ZipCrypto,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipCrypto.cs,ForRead,The following statement contains a magic number: DecryptedHeader[11] != (byte)((e._Crc32 >> 24) & 0xff)
Magic Number,Ionic.Zip,ZipCrypto,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipCrypto.cs,UpdateKeys,The following statement contains a magic number: _Keys[2] = (UInt32)crc32.ComputeCrc32((int)_Keys[2]' (byte)(_Keys[1] >> 24));
Magic Number,Ionic.Zip,ZipCrypto,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipCrypto.cs,UpdateKeys,The following statement contains a magic number: _Keys[2] = (UInt32)crc32.ComputeCrc32((int)_Keys[2]' (byte)(_Keys[1] >> 24));
Magic Number,Ionic.Zip,ZipCrypto,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipCrypto.cs,UpdateKeys,The following statement contains a magic number: _Keys[2] = (UInt32)crc32.ComputeCrc32((int)_Keys[2]' (byte)(_Keys[1] >> 24));
Magic Number,Ionic.Zip,ZipEntry,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipDirEntry.cs,ReadDirEntry,The following statement contains a magic number: s.Seek(-4' System.IO.SeekOrigin.Current);
Magic Number,Ionic.Zip,ZipEntry,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipDirEntry.cs,ReadDirEntry,The following statement contains a magic number: int bytesRead = 42 + 4;
Magic Number,Ionic.Zip,ZipEntry,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipDirEntry.cs,ReadDirEntry,The following statement contains a magic number: int bytesRead = 42 + 4;
Magic Number,Ionic.Zip,ZipEntry,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipDirEntry.cs,ReadDirEntry,The following statement contains a magic number: byte[] block = new byte[42];
Magic Number,Ionic.Zip,ZipEntry,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipDirEntry.cs,ReadDirEntry,The following statement contains a magic number: zde._VersionMadeBy = (short)(block[i++] + block[i++] * 256);
Magic Number,Ionic.Zip,ZipEntry,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipDirEntry.cs,ReadDirEntry,The following statement contains a magic number: zde._VersionNeeded = (short)(block[i++] + block[i++] * 256);
Magic Number,Ionic.Zip,ZipEntry,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipDirEntry.cs,ReadDirEntry,The following statement contains a magic number: zde._BitField = (short)(block[i++] + block[i++] * 256);
Magic Number,Ionic.Zip,ZipEntry,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipDirEntry.cs,ReadDirEntry,The following statement contains a magic number: zde._CompressionMethod = (Int16)(block[i++] + block[i++] * 256);
Magic Number,Ionic.Zip,ZipEntry,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipDirEntry.cs,ReadDirEntry,The following statement contains a magic number: zde._TimeBlob = block[i++] + block[i++] * 256 + block[i++] * 256 * 256 + block[i++] * 256 * 256 * 256;
Magic Number,Ionic.Zip,ZipEntry,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipDirEntry.cs,ReadDirEntry,The following statement contains a magic number: zde._TimeBlob = block[i++] + block[i++] * 256 + block[i++] * 256 * 256 + block[i++] * 256 * 256 * 256;
Magic Number,Ionic.Zip,ZipEntry,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipDirEntry.cs,ReadDirEntry,The following statement contains a magic number: zde._TimeBlob = block[i++] + block[i++] * 256 + block[i++] * 256 * 256 + block[i++] * 256 * 256 * 256;
Magic Number,Ionic.Zip,ZipEntry,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipDirEntry.cs,ReadDirEntry,The following statement contains a magic number: zde._TimeBlob = block[i++] + block[i++] * 256 + block[i++] * 256 * 256 + block[i++] * 256 * 256 * 256;
Magic Number,Ionic.Zip,ZipEntry,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipDirEntry.cs,ReadDirEntry,The following statement contains a magic number: zde._TimeBlob = block[i++] + block[i++] * 256 + block[i++] * 256 * 256 + block[i++] * 256 * 256 * 256;
Magic Number,Ionic.Zip,ZipEntry,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipDirEntry.cs,ReadDirEntry,The following statement contains a magic number: zde._TimeBlob = block[i++] + block[i++] * 256 + block[i++] * 256 * 256 + block[i++] * 256 * 256 * 256;
Magic Number,Ionic.Zip,ZipEntry,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipDirEntry.cs,ReadDirEntry,The following statement contains a magic number: zde._Crc32 = block[i++] + block[i++] * 256 + block[i++] * 256 * 256 + block[i++] * 256 * 256 * 256;
Magic Number,Ionic.Zip,ZipEntry,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipDirEntry.cs,ReadDirEntry,The following statement contains a magic number: zde._Crc32 = block[i++] + block[i++] * 256 + block[i++] * 256 * 256 + block[i++] * 256 * 256 * 256;
Magic Number,Ionic.Zip,ZipEntry,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipDirEntry.cs,ReadDirEntry,The following statement contains a magic number: zde._Crc32 = block[i++] + block[i++] * 256 + block[i++] * 256 * 256 + block[i++] * 256 * 256 * 256;
Magic Number,Ionic.Zip,ZipEntry,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipDirEntry.cs,ReadDirEntry,The following statement contains a magic number: zde._Crc32 = block[i++] + block[i++] * 256 + block[i++] * 256 * 256 + block[i++] * 256 * 256 * 256;
Magic Number,Ionic.Zip,ZipEntry,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipDirEntry.cs,ReadDirEntry,The following statement contains a magic number: zde._Crc32 = block[i++] + block[i++] * 256 + block[i++] * 256 * 256 + block[i++] * 256 * 256 * 256;
Magic Number,Ionic.Zip,ZipEntry,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipDirEntry.cs,ReadDirEntry,The following statement contains a magic number: zde._Crc32 = block[i++] + block[i++] * 256 + block[i++] * 256 * 256 + block[i++] * 256 * 256 * 256;
Magic Number,Ionic.Zip,ZipEntry,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipDirEntry.cs,ReadDirEntry,The following statement contains a magic number: zde._CompressedSize = (uint)(block[i++] + block[i++] * 256 + block[i++] * 256 * 256 + block[i++] * 256 * 256 * 256);
Magic Number,Ionic.Zip,ZipEntry,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipDirEntry.cs,ReadDirEntry,The following statement contains a magic number: zde._CompressedSize = (uint)(block[i++] + block[i++] * 256 + block[i++] * 256 * 256 + block[i++] * 256 * 256 * 256);
Magic Number,Ionic.Zip,ZipEntry,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipDirEntry.cs,ReadDirEntry,The following statement contains a magic number: zde._CompressedSize = (uint)(block[i++] + block[i++] * 256 + block[i++] * 256 * 256 + block[i++] * 256 * 256 * 256);
Magic Number,Ionic.Zip,ZipEntry,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipDirEntry.cs,ReadDirEntry,The following statement contains a magic number: zde._CompressedSize = (uint)(block[i++] + block[i++] * 256 + block[i++] * 256 * 256 + block[i++] * 256 * 256 * 256);
Magic Number,Ionic.Zip,ZipEntry,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipDirEntry.cs,ReadDirEntry,The following statement contains a magic number: zde._CompressedSize = (uint)(block[i++] + block[i++] * 256 + block[i++] * 256 * 256 + block[i++] * 256 * 256 * 256);
Magic Number,Ionic.Zip,ZipEntry,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipDirEntry.cs,ReadDirEntry,The following statement contains a magic number: zde._CompressedSize = (uint)(block[i++] + block[i++] * 256 + block[i++] * 256 * 256 + block[i++] * 256 * 256 * 256);
Magic Number,Ionic.Zip,ZipEntry,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipDirEntry.cs,ReadDirEntry,The following statement contains a magic number: zde._UncompressedSize = (uint)(block[i++] + block[i++] * 256 + block[i++] * 256 * 256 + block[i++] * 256 * 256 * 256);
Magic Number,Ionic.Zip,ZipEntry,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipDirEntry.cs,ReadDirEntry,The following statement contains a magic number: zde._UncompressedSize = (uint)(block[i++] + block[i++] * 256 + block[i++] * 256 * 256 + block[i++] * 256 * 256 * 256);
Magic Number,Ionic.Zip,ZipEntry,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipDirEntry.cs,ReadDirEntry,The following statement contains a magic number: zde._UncompressedSize = (uint)(block[i++] + block[i++] * 256 + block[i++] * 256 * 256 + block[i++] * 256 * 256 * 256);
Magic Number,Ionic.Zip,ZipEntry,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipDirEntry.cs,ReadDirEntry,The following statement contains a magic number: zde._UncompressedSize = (uint)(block[i++] + block[i++] * 256 + block[i++] * 256 * 256 + block[i++] * 256 * 256 * 256);
Magic Number,Ionic.Zip,ZipEntry,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipDirEntry.cs,ReadDirEntry,The following statement contains a magic number: zde._UncompressedSize = (uint)(block[i++] + block[i++] * 256 + block[i++] * 256 * 256 + block[i++] * 256 * 256 * 256);
Magic Number,Ionic.Zip,ZipEntry,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipDirEntry.cs,ReadDirEntry,The following statement contains a magic number: zde._UncompressedSize = (uint)(block[i++] + block[i++] * 256 + block[i++] * 256 * 256 + block[i++] * 256 * 256 * 256);
Magic Number,Ionic.Zip,ZipEntry,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipDirEntry.cs,ReadDirEntry,The following statement contains a magic number: zde._filenameLength = (short)(block[i++] + block[i++] * 256);
Magic Number,Ionic.Zip,ZipEntry,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipDirEntry.cs,ReadDirEntry,The following statement contains a magic number: zde._extraFieldLength = (short)(block[i++] + block[i++] * 256);
Magic Number,Ionic.Zip,ZipEntry,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipDirEntry.cs,ReadDirEntry,The following statement contains a magic number: zde._commentLength = (short)(block[i++] + block[i++] * 256);
Magic Number,Ionic.Zip,ZipEntry,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipDirEntry.cs,ReadDirEntry,The following statement contains a magic number: zde._diskNumber = (UInt32)(block[i++] + block[i++] * 256);
Magic Number,Ionic.Zip,ZipEntry,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipDirEntry.cs,ReadDirEntry,The following statement contains a magic number: zde._InternalFileAttrs = (short)(block[i++] + block[i++] * 256);
Magic Number,Ionic.Zip,ZipEntry,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipDirEntry.cs,ReadDirEntry,The following statement contains a magic number: zde._ExternalFileAttrs = block[i++] + block[i++] * 256 + block[i++] * 256 * 256 + block[i++] * 256 * 256 * 256;
Magic Number,Ionic.Zip,ZipEntry,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipDirEntry.cs,ReadDirEntry,The following statement contains a magic number: zde._ExternalFileAttrs = block[i++] + block[i++] * 256 + block[i++] * 256 * 256 + block[i++] * 256 * 256 * 256;
Magic Number,Ionic.Zip,ZipEntry,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipDirEntry.cs,ReadDirEntry,The following statement contains a magic number: zde._ExternalFileAttrs = block[i++] + block[i++] * 256 + block[i++] * 256 * 256 + block[i++] * 256 * 256 * 256;
Magic Number,Ionic.Zip,ZipEntry,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipDirEntry.cs,ReadDirEntry,The following statement contains a magic number: zde._ExternalFileAttrs = block[i++] + block[i++] * 256 + block[i++] * 256 * 256 + block[i++] * 256 * 256 * 256;
Magic Number,Ionic.Zip,ZipEntry,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipDirEntry.cs,ReadDirEntry,The following statement contains a magic number: zde._ExternalFileAttrs = block[i++] + block[i++] * 256 + block[i++] * 256 * 256 + block[i++] * 256 * 256 * 256;
Magic Number,Ionic.Zip,ZipEntry,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipDirEntry.cs,ReadDirEntry,The following statement contains a magic number: zde._ExternalFileAttrs = block[i++] + block[i++] * 256 + block[i++] * 256 * 256 + block[i++] * 256 * 256 * 256;
Magic Number,Ionic.Zip,ZipEntry,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipDirEntry.cs,ReadDirEntry,The following statement contains a magic number: zde._RelativeOffsetOfLocalHeader = (uint)(block[i++] + block[i++] * 256 + block[i++] * 256 * 256 + block[i++] * 256 * 256 * 256);
Magic Number,Ionic.Zip,ZipEntry,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipDirEntry.cs,ReadDirEntry,The following statement contains a magic number: zde._RelativeOffsetOfLocalHeader = (uint)(block[i++] + block[i++] * 256 + block[i++] * 256 * 256 + block[i++] * 256 * 256 * 256);
Magic Number,Ionic.Zip,ZipEntry,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipDirEntry.cs,ReadDirEntry,The following statement contains a magic number: zde._RelativeOffsetOfLocalHeader = (uint)(block[i++] + block[i++] * 256 + block[i++] * 256 * 256 + block[i++] * 256 * 256 * 256);
Magic Number,Ionic.Zip,ZipEntry,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipDirEntry.cs,ReadDirEntry,The following statement contains a magic number: zde._RelativeOffsetOfLocalHeader = (uint)(block[i++] + block[i++] * 256 + block[i++] * 256 * 256 + block[i++] * 256 * 256 * 256);
Magic Number,Ionic.Zip,ZipEntry,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipDirEntry.cs,ReadDirEntry,The following statement contains a magic number: zde._RelativeOffsetOfLocalHeader = (uint)(block[i++] + block[i++] * 256 + block[i++] * 256 * 256 + block[i++] * 256 * 256 * 256);
Magic Number,Ionic.Zip,ZipEntry,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipDirEntry.cs,ReadDirEntry,The following statement contains a magic number: zde._RelativeOffsetOfLocalHeader = (uint)(block[i++] + block[i++] * 256 + block[i++] * 256 * 256 + block[i++] * 256 * 256 * 256);
Magic Number,Ionic.Zip,ZipEntry,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipDirEntry.cs,ReadDirEntry,The following statement contains a magic number: zde._CompressedFileDataSize -= 12;
Magic Number,Ionic.Zip,ZipEntry,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipDirEntry.cs,ReadDirEntry,The following statement contains a magic number: zde._LengthOfTrailer += 24;
Magic Number,Ionic.Zip,ZipEntry,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipDirEntry.cs,ZipEntry,The following statement contains a magic number: AlternateEncoding = System.Text.CodePagesEncodingProvider.Instance.GetEncoding(1252);
Magic Number,Ionic.Zip,ZipEntry,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipDirEntry.cs,Create,The following statement contains a magic number: entry._VersionMadeBy = (0 << 8) + 45;
Magic Number,Ionic.Zip,ZipEntry,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipDirEntry.cs,Create,The following statement contains a magic number: entry._VersionMadeBy = (0 << 8) + 45;
Magic Number,Ionic.Zip,ZipEntry,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipDirEntry.cs,SetFdpLoh,The following statement contains a magic number: byte[] block = new byte[30];
Magic Number,Ionic.Zip,ZipEntry,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipDirEntry.cs,SetFdpLoh,The following statement contains a magic number: Int16 filenameLength = (short)(block[26] + block[27] * 256);
Magic Number,Ionic.Zip,ZipEntry,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipDirEntry.cs,SetFdpLoh,The following statement contains a magic number: Int16 filenameLength = (short)(block[26] + block[27] * 256);
Magic Number,Ionic.Zip,ZipEntry,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipDirEntry.cs,SetFdpLoh,The following statement contains a magic number: Int16 filenameLength = (short)(block[26] + block[27] * 256);
Magic Number,Ionic.Zip,ZipEntry,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipDirEntry.cs,SetFdpLoh,The following statement contains a magic number: Int16 extraFieldLength = (short)(block[28] + block[29] * 256);
Magic Number,Ionic.Zip,ZipEntry,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipDirEntry.cs,SetFdpLoh,The following statement contains a magic number: Int16 extraFieldLength = (short)(block[28] + block[29] * 256);
Magic Number,Ionic.Zip,ZipEntry,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipDirEntry.cs,SetFdpLoh,The following statement contains a magic number: Int16 extraFieldLength = (short)(block[28] + block[29] * 256);
Magic Number,Ionic.Zip,ZipEntry,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipDirEntry.cs,SetFdpLoh,The following statement contains a magic number: this._LengthOfHeader = 30 + extraFieldLength + filenameLength +                  GetLengthOfCryptoHeaderBytes(_Encryption_FromZipFile);
Magic Number,Ionic.Zip,ZipEntry,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipDirEntry.cs,GetKeyStrengthInBits,The following statement contains a magic number: return 256;
Magic Number,Ionic.Zip,ZipEntry,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipDirEntry.cs,GetLengthOfCryptoHeaderBytes,The following statement contains a magic number: int sizeOfSaltAndPv = ((KeyStrengthInBits / 8 / 2) + 2);
Magic Number,Ionic.Zip,ZipEntry,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipDirEntry.cs,GetLengthOfCryptoHeaderBytes,The following statement contains a magic number: int sizeOfSaltAndPv = ((KeyStrengthInBits / 8 / 2) + 2);
Magic Number,Ionic.Zip,ZipEntry,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipDirEntry.cs,GetLengthOfCryptoHeaderBytes,The following statement contains a magic number: int sizeOfSaltAndPv = ((KeyStrengthInBits / 8 / 2) + 2);
Magic Number,Ionic.Zip,ZipEntry,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipDirEntry.cs,GetLengthOfCryptoHeaderBytes,The following statement contains a magic number: return 12;
Magic Number,Ionic.Zip,ZipEntry,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipDirEntry.cs,InternalExtractToBaseDir,The following statement contains a magic number: rc == 2
Magic Number,Ionic.Zip,ZipEntry,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipDirEntry.cs,CheckExtractExistingFile,The following statement contains a magic number: switch (ExtractExistingFile)                  {                      case ExtractExistingFileAction.OverwriteSilently:                          WriteStatus("the file {0} exists; will overwrite it..."' targetFileName);                          return 0;                        case ExtractExistingFileAction.DoNotOverwrite:                          WriteStatus("the file {0} exists; not extracting entry..."' FileName);                          OnAfterExtract(baseDir);                          return 1;                        case ExtractExistingFileAction.InvokeExtractProgressEvent:                          if (loop>0)                              throw new ZipException(String.Format("The file {0} already exists."' targetFileName));                          OnExtractExisting(baseDir);                          if (_ioOperationCanceled)                              return 2;                            // loop around                          break;                        case ExtractExistingFileAction.Throw:                      default:                          throw new ZipException(String.Format("The file {0} already exists."' targetFileName));                  }
Magic Number,Ionic.Zip,ZipEntry,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipDirEntry.cs,GetUnsupportedCompressionMethod,The following statement contains a magic number: switch ((int) compressionMethod)              {                  case 0:                      meth = "Store";                      break;                  case 1:                      meth = "Shrink";                      break;                  case 8:                      meth = "DEFLATE";                      break;                  case 9:                      meth = "Deflate64";                      break;                  case 12:                      meth = "BZIP2"; // only if BZIP not compiled in                      break;                  case 14:                      meth = "LZMA";                      break;                  case 19:                      meth = "LZ77";                      break;                  case 98:                      meth = "PPMd";                      break;                  default:                      meth = String.Format("Unknown (0x{0:X4})"' compressionMethod);                      break;              }
Magic Number,Ionic.Zip,ZipEntry,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipDirEntry.cs,GetUnsupportedCompressionMethod,The following statement contains a magic number: switch ((int) compressionMethod)              {                  case 0:                      meth = "Store";                      break;                  case 1:                      meth = "Shrink";                      break;                  case 8:                      meth = "DEFLATE";                      break;                  case 9:                      meth = "Deflate64";                      break;                  case 12:                      meth = "BZIP2"; // only if BZIP not compiled in                      break;                  case 14:                      meth = "LZMA";                      break;                  case 19:                      meth = "LZ77";                      break;                  case 98:                      meth = "PPMd";                      break;                  default:                      meth = String.Format("Unknown (0x{0:X4})"' compressionMethod);                      break;              }
Magic Number,Ionic.Zip,ZipEntry,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipDirEntry.cs,GetUnsupportedCompressionMethod,The following statement contains a magic number: switch ((int) compressionMethod)              {                  case 0:                      meth = "Store";                      break;                  case 1:                      meth = "Shrink";                      break;                  case 8:                      meth = "DEFLATE";                      break;                  case 9:                      meth = "Deflate64";                      break;                  case 12:                      meth = "BZIP2"; // only if BZIP not compiled in                      break;                  case 14:                      meth = "LZMA";                      break;                  case 19:                      meth = "LZ77";                      break;                  case 98:                      meth = "PPMd";                      break;                  default:                      meth = String.Format("Unknown (0x{0:X4})"' compressionMethod);                      break;              }
Magic Number,Ionic.Zip,ZipEntry,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipDirEntry.cs,GetUnsupportedCompressionMethod,The following statement contains a magic number: switch ((int) compressionMethod)              {                  case 0:                      meth = "Store";                      break;                  case 1:                      meth = "Shrink";                      break;                  case 8:                      meth = "DEFLATE";                      break;                  case 9:                      meth = "Deflate64";                      break;                  case 12:                      meth = "BZIP2"; // only if BZIP not compiled in                      break;                  case 14:                      meth = "LZMA";                      break;                  case 19:                      meth = "LZ77";                      break;                  case 98:                      meth = "PPMd";                      break;                  default:                      meth = String.Format("Unknown (0x{0:X4})"' compressionMethod);                      break;              }
Magic Number,Ionic.Zip,ZipEntry,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipDirEntry.cs,GetUnsupportedCompressionMethod,The following statement contains a magic number: switch ((int) compressionMethod)              {                  case 0:                      meth = "Store";                      break;                  case 1:                      meth = "Shrink";                      break;                  case 8:                      meth = "DEFLATE";                      break;                  case 9:                      meth = "Deflate64";                      break;                  case 12:                      meth = "BZIP2"; // only if BZIP not compiled in                      break;                  case 14:                      meth = "LZMA";                      break;                  case 19:                      meth = "LZ77";                      break;                  case 98:                      meth = "PPMd";                      break;                  default:                      meth = String.Format("Unknown (0x{0:X4})"' compressionMethod);                      break;              }
Magic Number,Ionic.Zip,ZipEntry,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipDirEntry.cs,GetUnsupportedCompressionMethod,The following statement contains a magic number: switch ((int) compressionMethod)              {                  case 0:                      meth = "Store";                      break;                  case 1:                      meth = "Shrink";                      break;                  case 8:                      meth = "DEFLATE";                      break;                  case 9:                      meth = "Deflate64";                      break;                  case 12:                      meth = "BZIP2"; // only if BZIP not compiled in                      break;                  case 14:                      meth = "LZMA";                      break;                  case 19:                      meth = "LZ77";                      break;                  case 98:                      meth = "PPMd";                      break;                  default:                      meth = String.Format("Unknown (0x{0:X4})"' compressionMethod);                      break;              }
Magic Number,Ionic.Zip,ZipEntry,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipDirEntry.cs,SetupCryptoForExtract,The following statement contains a magic number: this.ArchiveStream.Seek(this.FileDataPosition - 12' SeekOrigin.Begin);
Magic Number,Ionic.Zip,ZipEntry,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipDirEntry.cs,IsDoneWithOutputToBaseDir,The following statement contains a magic number: f = f.Substring(2);
Magic Number,Ionic.Zip,ZipEntry,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipDirEntry.cs,ReadExtraField,The following statement contains a magic number: byte[] block = new byte[30];
Magic Number,Ionic.Zip,ZipEntry,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipDirEntry.cs,ReadExtraField,The following statement contains a magic number: int i = 26;
Magic Number,Ionic.Zip,ZipEntry,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipDirEntry.cs,ReadExtraField,The following statement contains a magic number: Int16 filenameLength = (short)(block[i++] + block[i++] * 256);
Magic Number,Ionic.Zip,ZipEntry,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipDirEntry.cs,ReadExtraField,The following statement contains a magic number: Int16 extraFieldLength = (short)(block[i++] + block[i++] * 256);
Magic Number,Ionic.Zip,ZipEntry,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipDirEntry.cs,ReadHeader,The following statement contains a magic number: bytesRead += 4;
Magic Number,Ionic.Zip,ZipEntry,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipDirEntry.cs,ReadHeader,The following statement contains a magic number: ze.ArchiveStream.Seek(-4' SeekOrigin.Current);
Magic Number,Ionic.Zip,ZipEntry,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipDirEntry.cs,ReadHeader,The following statement contains a magic number: byte[] block = new byte[26];
Magic Number,Ionic.Zip,ZipEntry,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipDirEntry.cs,ReadHeader,The following statement contains a magic number: ze._VersionNeeded = (Int16)(block[i++] + block[i++] * 256);
Magic Number,Ionic.Zip,ZipEntry,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipDirEntry.cs,ReadHeader,The following statement contains a magic number: ze._BitField = (Int16)(block[i++] + block[i++] * 256);
Magic Number,Ionic.Zip,ZipEntry,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipDirEntry.cs,ReadHeader,The following statement contains a magic number: ze._CompressionMethod_FromZipFile = ze._CompressionMethod = (Int16)(block[i++] + block[i++] * 256);
Magic Number,Ionic.Zip,ZipEntry,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipDirEntry.cs,ReadHeader,The following statement contains a magic number: ze._TimeBlob = block[i++] + block[i++] * 256 + block[i++] * 256 * 256 + block[i++] * 256 * 256 * 256;
Magic Number,Ionic.Zip,ZipEntry,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipDirEntry.cs,ReadHeader,The following statement contains a magic number: ze._TimeBlob = block[i++] + block[i++] * 256 + block[i++] * 256 * 256 + block[i++] * 256 * 256 * 256;
Magic Number,Ionic.Zip,ZipEntry,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipDirEntry.cs,ReadHeader,The following statement contains a magic number: ze._TimeBlob = block[i++] + block[i++] * 256 + block[i++] * 256 * 256 + block[i++] * 256 * 256 * 256;
Magic Number,Ionic.Zip,ZipEntry,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipDirEntry.cs,ReadHeader,The following statement contains a magic number: ze._TimeBlob = block[i++] + block[i++] * 256 + block[i++] * 256 * 256 + block[i++] * 256 * 256 * 256;
Magic Number,Ionic.Zip,ZipEntry,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipDirEntry.cs,ReadHeader,The following statement contains a magic number: ze._TimeBlob = block[i++] + block[i++] * 256 + block[i++] * 256 * 256 + block[i++] * 256 * 256 * 256;
Magic Number,Ionic.Zip,ZipEntry,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipDirEntry.cs,ReadHeader,The following statement contains a magic number: ze._TimeBlob = block[i++] + block[i++] * 256 + block[i++] * 256 * 256 + block[i++] * 256 * 256 * 256;
Magic Number,Ionic.Zip,ZipEntry,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipDirEntry.cs,ReadHeader,The following statement contains a magic number: ze._Crc32 = (Int32)(block[i++] + block[i++] * 256 + block[i++] * 256 * 256 + block[i++] * 256 * 256 * 256);
Magic Number,Ionic.Zip,ZipEntry,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipDirEntry.cs,ReadHeader,The following statement contains a magic number: ze._Crc32 = (Int32)(block[i++] + block[i++] * 256 + block[i++] * 256 * 256 + block[i++] * 256 * 256 * 256);
Magic Number,Ionic.Zip,ZipEntry,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipDirEntry.cs,ReadHeader,The following statement contains a magic number: ze._Crc32 = (Int32)(block[i++] + block[i++] * 256 + block[i++] * 256 * 256 + block[i++] * 256 * 256 * 256);
Magic Number,Ionic.Zip,ZipEntry,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipDirEntry.cs,ReadHeader,The following statement contains a magic number: ze._Crc32 = (Int32)(block[i++] + block[i++] * 256 + block[i++] * 256 * 256 + block[i++] * 256 * 256 * 256);
Magic Number,Ionic.Zip,ZipEntry,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipDirEntry.cs,ReadHeader,The following statement contains a magic number: ze._Crc32 = (Int32)(block[i++] + block[i++] * 256 + block[i++] * 256 * 256 + block[i++] * 256 * 256 * 256);
Magic Number,Ionic.Zip,ZipEntry,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipDirEntry.cs,ReadHeader,The following statement contains a magic number: ze._Crc32 = (Int32)(block[i++] + block[i++] * 256 + block[i++] * 256 * 256 + block[i++] * 256 * 256 * 256);
Magic Number,Ionic.Zip,ZipEntry,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipDirEntry.cs,ReadHeader,The following statement contains a magic number: ze._CompressedSize = (uint)(block[i++] + block[i++] * 256 + block[i++] * 256 * 256 + block[i++] * 256 * 256 * 256);
Magic Number,Ionic.Zip,ZipEntry,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipDirEntry.cs,ReadHeader,The following statement contains a magic number: ze._CompressedSize = (uint)(block[i++] + block[i++] * 256 + block[i++] * 256 * 256 + block[i++] * 256 * 256 * 256);
Magic Number,Ionic.Zip,ZipEntry,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipDirEntry.cs,ReadHeader,The following statement contains a magic number: ze._CompressedSize = (uint)(block[i++] + block[i++] * 256 + block[i++] * 256 * 256 + block[i++] * 256 * 256 * 256);
Magic Number,Ionic.Zip,ZipEntry,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipDirEntry.cs,ReadHeader,The following statement contains a magic number: ze._CompressedSize = (uint)(block[i++] + block[i++] * 256 + block[i++] * 256 * 256 + block[i++] * 256 * 256 * 256);
Magic Number,Ionic.Zip,ZipEntry,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipDirEntry.cs,ReadHeader,The following statement contains a magic number: ze._CompressedSize = (uint)(block[i++] + block[i++] * 256 + block[i++] * 256 * 256 + block[i++] * 256 * 256 * 256);
Magic Number,Ionic.Zip,ZipEntry,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipDirEntry.cs,ReadHeader,The following statement contains a magic number: ze._CompressedSize = (uint)(block[i++] + block[i++] * 256 + block[i++] * 256 * 256 + block[i++] * 256 * 256 * 256);
Magic Number,Ionic.Zip,ZipEntry,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipDirEntry.cs,ReadHeader,The following statement contains a magic number: ze._UncompressedSize = (uint)(block[i++] + block[i++] * 256 + block[i++] * 256 * 256 + block[i++] * 256 * 256 * 256);
Magic Number,Ionic.Zip,ZipEntry,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipDirEntry.cs,ReadHeader,The following statement contains a magic number: ze._UncompressedSize = (uint)(block[i++] + block[i++] * 256 + block[i++] * 256 * 256 + block[i++] * 256 * 256 * 256);
Magic Number,Ionic.Zip,ZipEntry,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipDirEntry.cs,ReadHeader,The following statement contains a magic number: ze._UncompressedSize = (uint)(block[i++] + block[i++] * 256 + block[i++] * 256 * 256 + block[i++] * 256 * 256 * 256);
Magic Number,Ionic.Zip,ZipEntry,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipDirEntry.cs,ReadHeader,The following statement contains a magic number: ze._UncompressedSize = (uint)(block[i++] + block[i++] * 256 + block[i++] * 256 * 256 + block[i++] * 256 * 256 * 256);
Magic Number,Ionic.Zip,ZipEntry,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipDirEntry.cs,ReadHeader,The following statement contains a magic number: ze._UncompressedSize = (uint)(block[i++] + block[i++] * 256 + block[i++] * 256 * 256 + block[i++] * 256 * 256 * 256);
Magic Number,Ionic.Zip,ZipEntry,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipDirEntry.cs,ReadHeader,The following statement contains a magic number: ze._UncompressedSize = (uint)(block[i++] + block[i++] * 256 + block[i++] * 256 * 256 + block[i++] * 256 * 256 * 256);
Magic Number,Ionic.Zip,ZipEntry,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipDirEntry.cs,ReadHeader,The following statement contains a magic number: Int16 filenameLength = (short)(block[i++] + block[i++] * 256);
Magic Number,Ionic.Zip,ZipEntry,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipDirEntry.cs,ReadHeader,The following statement contains a magic number: Int16 extraFieldLength = (short)(block[i++] + block[i++] * 256);
Magic Number,Ionic.Zip,ZipEntry,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipDirEntry.cs,ReadHeader,The following statement contains a magic number: block = new byte[20];
Magic Number,Ionic.Zip,ZipEntry,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipDirEntry.cs,ReadHeader,The following statement contains a magic number: n != 20
Magic Number,Ionic.Zip,ZipEntry,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipDirEntry.cs,ReadHeader,The following statement contains a magic number: ze._Crc32 = (Int32)(block[i++] + block[i++] * 256 + block[i++] * 256 * 256 + block[i++] * 256 * 256 * 256);
Magic Number,Ionic.Zip,ZipEntry,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipDirEntry.cs,ReadHeader,The following statement contains a magic number: ze._Crc32 = (Int32)(block[i++] + block[i++] * 256 + block[i++] * 256 * 256 + block[i++] * 256 * 256 * 256);
Magic Number,Ionic.Zip,ZipEntry,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipDirEntry.cs,ReadHeader,The following statement contains a magic number: ze._Crc32 = (Int32)(block[i++] + block[i++] * 256 + block[i++] * 256 * 256 + block[i++] * 256 * 256 * 256);
Magic Number,Ionic.Zip,ZipEntry,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipDirEntry.cs,ReadHeader,The following statement contains a magic number: ze._Crc32 = (Int32)(block[i++] + block[i++] * 256 + block[i++] * 256 * 256 + block[i++] * 256 * 256 * 256);
Magic Number,Ionic.Zip,ZipEntry,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipDirEntry.cs,ReadHeader,The following statement contains a magic number: ze._Crc32 = (Int32)(block[i++] + block[i++] * 256 + block[i++] * 256 * 256 + block[i++] * 256 * 256 * 256);
Magic Number,Ionic.Zip,ZipEntry,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipDirEntry.cs,ReadHeader,The following statement contains a magic number: ze._Crc32 = (Int32)(block[i++] + block[i++] * 256 + block[i++] * 256 * 256 + block[i++] * 256 * 256 * 256);
Magic Number,Ionic.Zip,ZipEntry,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipDirEntry.cs,ReadHeader,The following statement contains a magic number: i += 8;
Magic Number,Ionic.Zip,ZipEntry,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipDirEntry.cs,ReadHeader,The following statement contains a magic number: i += 8;
Magic Number,Ionic.Zip,ZipEntry,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipDirEntry.cs,ReadHeader,The following statement contains a magic number: ze.ArchiveStream.Seek(-12' SeekOrigin.Current);
Magic Number,Ionic.Zip,ZipEntry,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipDirEntry.cs,ReadHeader,The following statement contains a magic number: SizeOfDataRead += 4;
Magic Number,Ionic.Zip,ZipEntry,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipDirEntry.cs,ReadHeader,The following statement contains a magic number: ze._LengthOfTrailer += ze._InputUsesZip64 ? 24 : 16;
Magic Number,Ionic.Zip,ZipEntry,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipDirEntry.cs,ReadHeader,The following statement contains a magic number: ze._LengthOfTrailer += ze._InputUsesZip64 ? 24 : 16;
Magic Number,Ionic.Zip,ZipEntry,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipDirEntry.cs,ReadHeader,The following statement contains a magic number: bytesRead += ze._aesCrypto_forExtract.SizeOfEncryptionMetadata - 10;
Magic Number,Ionic.Zip,ZipEntry,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipDirEntry.cs,ReadHeader,The following statement contains a magic number: ze._LengthOfTrailer += 10;
Magic Number,Ionic.Zip,ZipEntry,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipDirEntry.cs,ReadWeakEncryptionHeader,The following statement contains a magic number: int additionalBytesRead = s.Read(buffer' 0' 12);
Magic Number,Ionic.Zip,ZipEntry,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipDirEntry.cs,ReadWeakEncryptionHeader,The following statement contains a magic number: additionalBytesRead != 12
Magic Number,Ionic.Zip,ZipEntry,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipDirEntry.cs,HandlePK00Prefix,The following statement contains a magic number: s.Seek(-4' SeekOrigin.Current);
Magic Number,Ionic.Zip,ZipEntry,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipDirEntry.cs,FindExtraFieldSegment,The following statement contains a magic number: UInt16 headerId = (UInt16)(extra[j++] + extra[j++] * 256);
Magic Number,Ionic.Zip,ZipEntry,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipDirEntry.cs,FindExtraFieldSegment,The following statement contains a magic number: return j-2;
Magic Number,Ionic.Zip,ZipEntry,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipDirEntry.cs,FindExtraFieldSegment,The following statement contains a magic number: Int16 dataSize = (short)(extra[j++] + extra[j++] * 256);
Magic Number,Ionic.Zip,ZipEntry,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipDirEntry.cs,FindExtraFieldSegment,The following statement contains a magic number: j + 3 < extra.Length
Magic Number,Ionic.Zip,ZipEntry,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipDirEntry.cs,ProcessExtraField,The following statement contains a magic number: UInt16 headerId = (UInt16)(buffer[j++] + buffer[j++] * 256);
Magic Number,Ionic.Zip,ZipEntry,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipDirEntry.cs,ProcessExtraField,The following statement contains a magic number: UInt16 dataSize = (UInt16)(buffer[j++] + buffer[j++] * 256);
Magic Number,Ionic.Zip,ZipEntry,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipDirEntry.cs,ProcessExtraField,The following statement contains a magic number: j = start + dataSize + 4;
Magic Number,Ionic.Zip,ZipEntry,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipDirEntry.cs,ProcessExtraField,The following statement contains a magic number: j + 3 < buffer.Length
Magic Number,Ionic.Zip,ZipEntry,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipDirEntry.cs,ProcessExtraFieldPkwareStrongEncryption,The following statement contains a magic number: j += 2;
Magic Number,Ionic.Zip,ZipEntry,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipDirEntry.cs,ProcessExtraFieldPkwareStrongEncryption,The following statement contains a magic number: _UnsupportedAlgorithmId = (UInt16)(Buffer[j++] + Buffer[j++] * 256);
Magic Number,Ionic.Zip,ZipEntry,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipDirEntry.cs,ProcessExtraFieldWinZipAes,The following statement contains a magic number: dataSize != 7
Magic Number,Ionic.Zip,ZipEntry,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipDirEntry.cs,ProcessExtraFieldWinZipAes,The following statement contains a magic number: j += 2;
Magic Number,Ionic.Zip,ZipEntry,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipDirEntry.cs,ProcessExtraFieldWinZipAes,The following statement contains a magic number: j += 2;
Magic Number,Ionic.Zip,ZipEntry,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipDirEntry.cs,ProcessExtraFieldWinZipAes,The following statement contains a magic number: int keystrength = (buffer[j] == 1) ? 128 : (buffer[j] == 3) ? 256 : -1;
Magic Number,Ionic.Zip,ZipEntry,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipDirEntry.cs,ProcessExtraFieldWinZipAes,The following statement contains a magic number: int keystrength = (buffer[j] == 1) ? 128 : (buffer[j] == 3) ? 256 : -1;
Magic Number,Ionic.Zip,ZipEntry,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipDirEntry.cs,ProcessExtraFieldWinZipAes,The following statement contains a magic number: int keystrength = (buffer[j] == 1) ? 128 : (buffer[j] == 3) ? 256 : -1;
Magic Number,Ionic.Zip,ZipEntry,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipDirEntry.cs,ProcessExtraFieldWinZipAes,The following statement contains a magic number: _Encryption_FromZipFile = this._Encryption = (keystrength == 128)                      ? EncryptionAlgorithm.WinZipAes128                      : EncryptionAlgorithm.WinZipAes256;
Magic Number,Ionic.Zip,ZipEntry,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipDirEntry.cs,ProcessExtraFieldWinZipAes,The following statement contains a magic number: j += 2;
Magic Number,Ionic.Zip,ZipEntry,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipDirEntry.cs,ProcessExtraFieldZip64,The following statement contains a magic number: dataSize > 28
Magic Number,Ionic.Zip,ZipEntry,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipDirEntry.cs,ProcessExtraFieldZip64,The following statement contains a magic number: var slurp = new Func<Int64>( () => {                      if (remainingData < 8)                          throw new BadReadException(String.Format("  Missing data for ZIP64 extra field' position 0x{0:X16}"' posn));                      var x = BitConverter.ToInt64(buffer' j);                      j+= 8;                      remainingData -= 8;                      return x;                  });
Magic Number,Ionic.Zip,ZipEntry,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipDirEntry.cs,ProcessExtraFieldZip64,The following statement contains a magic number: var slurp = new Func<Int64>( () => {                      if (remainingData < 8)                          throw new BadReadException(String.Format("  Missing data for ZIP64 extra field' position 0x{0:X16}"' posn));                      var x = BitConverter.ToInt64(buffer' j);                      j+= 8;                      remainingData -= 8;                      return x;                  });
Magic Number,Ionic.Zip,ZipEntry,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipDirEntry.cs,ProcessExtraFieldZip64,The following statement contains a magic number: var slurp = new Func<Int64>( () => {                      if (remainingData < 8)                          throw new BadReadException(String.Format("  Missing data for ZIP64 extra field' position 0x{0:X16}"' posn));                      var x = BitConverter.ToInt64(buffer' j);                      j+= 8;                      remainingData -= 8;                      return x;                  });
Magic Number,Ionic.Zip,ZipEntry,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipDirEntry.cs,ProcessExtraFieldInfoZipTimes,The following statement contains a magic number: dataSize != 12 && dataSize != 8
Magic Number,Ionic.Zip,ZipEntry,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipDirEntry.cs,ProcessExtraFieldInfoZipTimes,The following statement contains a magic number: dataSize != 12 && dataSize != 8
Magic Number,Ionic.Zip,ZipEntry,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipDirEntry.cs,ProcessExtraFieldInfoZipTimes,The following statement contains a magic number: j += 4;
Magic Number,Ionic.Zip,ZipEntry,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipDirEntry.cs,ProcessExtraFieldInfoZipTimes,The following statement contains a magic number: j += 4;
Magic Number,Ionic.Zip,ZipEntry,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipDirEntry.cs,ProcessExtraFieldUnixTimes,The following statement contains a magic number: dataSize != 13 && dataSize != 9 && dataSize != 5
Magic Number,Ionic.Zip,ZipEntry,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipDirEntry.cs,ProcessExtraFieldUnixTimes,The following statement contains a magic number: dataSize != 13 && dataSize != 9 && dataSize != 5
Magic Number,Ionic.Zip,ZipEntry,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipDirEntry.cs,ProcessExtraFieldUnixTimes,The following statement contains a magic number: dataSize != 13 && dataSize != 9 && dataSize != 5
Magic Number,Ionic.Zip,ZipEntry,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipDirEntry.cs,ProcessExtraFieldUnixTimes,The following statement contains a magic number: var slurp = new Func<DateTime>( () => {                      Int32 timet = BitConverter.ToInt32(buffer' j);                      j += 4;                      remainingData -= 4;                      return _unixEpoch.AddSeconds(timet);                  });
Magic Number,Ionic.Zip,ZipEntry,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipDirEntry.cs,ProcessExtraFieldUnixTimes,The following statement contains a magic number: var slurp = new Func<DateTime>( () => {                      Int32 timet = BitConverter.ToInt32(buffer' j);                      j += 4;                      remainingData -= 4;                      return _unixEpoch.AddSeconds(timet);                  });
Magic Number,Ionic.Zip,ZipEntry,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipDirEntry.cs,ProcessExtraFieldUnixTimes,The following statement contains a magic number: (flag & 0x0001) != 0 && remainingData >= 4
Magic Number,Ionic.Zip,ZipEntry,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipDirEntry.cs,ProcessExtraFieldUnixTimes,The following statement contains a magic number: this._Atime = ((flag & 0x0002) != 0 && remainingData >= 4)                       ? slurp()                       : DateTime.UtcNow;
Magic Number,Ionic.Zip,ZipEntry,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipDirEntry.cs,ProcessExtraFieldUnixTimes,The following statement contains a magic number: this._Ctime =  ((flag & 0x0004) != 0 && remainingData >= 4)                       ? slurp()                       :DateTime.UtcNow;
Magic Number,Ionic.Zip,ZipEntry,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipDirEntry.cs,ProcessExtraFieldUnixTimes,The following statement contains a magic number: dataSize == 13 || _readExtraDepth > 0
Magic Number,Ionic.Zip,ZipEntry,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipDirEntry.cs,ProcessExtraFieldWindowsTimes,The following statement contains a magic number: dataSize != 32
Magic Number,Ionic.Zip,ZipEntry,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipDirEntry.cs,ProcessExtraFieldWindowsTimes,The following statement contains a magic number: j += 4;
Magic Number,Ionic.Zip,ZipEntry,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipDirEntry.cs,ProcessExtraFieldWindowsTimes,The following statement contains a magic number: Int16 timetag = (Int16)(buffer[j] + buffer[j + 1] * 256);
Magic Number,Ionic.Zip,ZipEntry,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipDirEntry.cs,ProcessExtraFieldWindowsTimes,The following statement contains a magic number: Int16 addlsize = (Int16)(buffer[j + 2] + buffer[j + 3] * 256);
Magic Number,Ionic.Zip,ZipEntry,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipDirEntry.cs,ProcessExtraFieldWindowsTimes,The following statement contains a magic number: Int16 addlsize = (Int16)(buffer[j + 2] + buffer[j + 3] * 256);
Magic Number,Ionic.Zip,ZipEntry,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipDirEntry.cs,ProcessExtraFieldWindowsTimes,The following statement contains a magic number: Int16 addlsize = (Int16)(buffer[j + 2] + buffer[j + 3] * 256);
Magic Number,Ionic.Zip,ZipEntry,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipDirEntry.cs,ProcessExtraFieldWindowsTimes,The following statement contains a magic number: j += 4;
Magic Number,Ionic.Zip,ZipEntry,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipDirEntry.cs,ProcessExtraFieldWindowsTimes,The following statement contains a magic number: j += 8;
Magic Number,Ionic.Zip,ZipEntry,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipDirEntry.cs,ProcessExtraFieldWindowsTimes,The following statement contains a magic number: j += 8;
Magic Number,Ionic.Zip,ZipEntry,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipDirEntry.cs,ProcessExtraFieldWindowsTimes,The following statement contains a magic number: j += 8;
Magic Number,Ionic.Zip,ZipEntry,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipDirEntry.cs,ProcessExtraFieldWindowsTimes,The following statement contains a magic number: timetag == 0x0001 && addlsize == 24
Magic Number,Ionic.Zip,ZipEntry,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipDirEntry.cs,WriteCentralDirectoryEntry,The following statement contains a magic number: byte[] bytes = new byte[8192];
Magic Number,Ionic.Zip,ZipEntry,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipDirEntry.cs,WriteCentralDirectoryEntry,The following statement contains a magic number: bytes[i++] = (byte)((ZipConstants.ZipDirEntrySignature & 0x0000FF00) >> 8);
Magic Number,Ionic.Zip,ZipEntry,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipDirEntry.cs,WriteCentralDirectoryEntry,The following statement contains a magic number: bytes[i++] = (byte)((ZipConstants.ZipDirEntrySignature & 0x00FF0000) >> 16);
Magic Number,Ionic.Zip,ZipEntry,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipDirEntry.cs,WriteCentralDirectoryEntry,The following statement contains a magic number: bytes[i++] = (byte)((ZipConstants.ZipDirEntrySignature & 0xFF000000) >> 24);
Magic Number,Ionic.Zip,ZipEntry,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipDirEntry.cs,WriteCentralDirectoryEntry,The following statement contains a magic number: bytes[i++] = (byte)((_VersionMadeBy & 0xFF00) >> 8);
Magic Number,Ionic.Zip,ZipEntry,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipDirEntry.cs,WriteCentralDirectoryEntry,The following statement contains a magic number: Int16 vNeeded = (Int16)(VersionNeeded != 0 ? VersionNeeded : 20);
Magic Number,Ionic.Zip,ZipEntry,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipDirEntry.cs,WriteCentralDirectoryEntry,The following statement contains a magic number: Int16 versionNeededToExtract = (Int16)(_OutputUsesZip64.Value ? 45 : vNeeded);
Magic Number,Ionic.Zip,ZipEntry,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipDirEntry.cs,WriteCentralDirectoryEntry,The following statement contains a magic number: versionNeededToExtract = 46;
Magic Number,Ionic.Zip,ZipEntry,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipDirEntry.cs,WriteCentralDirectoryEntry,The following statement contains a magic number: bytes[i++] = (byte)((versionNeededToExtract & 0xFF00) >> 8);
Magic Number,Ionic.Zip,ZipEntry,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipDirEntry.cs,WriteCentralDirectoryEntry,The following statement contains a magic number: bytes[i++] = (byte)((_BitField & 0xFF00) >> 8);
Magic Number,Ionic.Zip,ZipEntry,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipDirEntry.cs,WriteCentralDirectoryEntry,The following statement contains a magic number: bytes[i++] = (byte)((_CompressionMethod & 0xFF00) >> 8);
Magic Number,Ionic.Zip,ZipEntry,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipDirEntry.cs,WriteCentralDirectoryEntry,The following statement contains a magic number: i -= 2;
Magic Number,Ionic.Zip,ZipEntry,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipDirEntry.cs,WriteCentralDirectoryEntry,The following statement contains a magic number: bytes[i++] = (byte)((_TimeBlob & 0x0000FF00) >> 8);
Magic Number,Ionic.Zip,ZipEntry,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipDirEntry.cs,WriteCentralDirectoryEntry,The following statement contains a magic number: bytes[i++] = (byte)((_TimeBlob & 0x00FF0000) >> 16);
Magic Number,Ionic.Zip,ZipEntry,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipDirEntry.cs,WriteCentralDirectoryEntry,The following statement contains a magic number: bytes[i++] = (byte)((_TimeBlob & 0xFF000000) >> 24);
Magic Number,Ionic.Zip,ZipEntry,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipDirEntry.cs,WriteCentralDirectoryEntry,The following statement contains a magic number: bytes[i++] = (byte)((_Crc32 & 0x0000FF00) >> 8);
Magic Number,Ionic.Zip,ZipEntry,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipDirEntry.cs,WriteCentralDirectoryEntry,The following statement contains a magic number: bytes[i++] = (byte)((_Crc32 & 0x00FF0000) >> 16);
Magic Number,Ionic.Zip,ZipEntry,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipDirEntry.cs,WriteCentralDirectoryEntry,The following statement contains a magic number: bytes[i++] = (byte)((_Crc32 & 0xFF000000) >> 24);
Magic Number,Ionic.Zip,ZipEntry,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipDirEntry.cs,WriteCentralDirectoryEntry,The following statement contains a magic number: j < 8
Magic Number,Ionic.Zip,ZipEntry,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipDirEntry.cs,WriteCentralDirectoryEntry,The following statement contains a magic number: bytes[i++] = (byte)((filenameLength & 0xFF00) >> 8);
Magic Number,Ionic.Zip,ZipEntry,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipDirEntry.cs,WriteCentralDirectoryEntry,The following statement contains a magic number: bytes[i++] = (byte)((extraFieldLength & 0xFF00) >> 8);
Magic Number,Ionic.Zip,ZipEntry,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipDirEntry.cs,WriteCentralDirectoryEntry,The following statement contains a magic number: i += 2;
Magic Number,Ionic.Zip,ZipEntry,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipDirEntry.cs,WriteCentralDirectoryEntry,The following statement contains a magic number: bytes[i++] = (byte)((_diskNumber & 0xFF00) >> 8);
Magic Number,Ionic.Zip,ZipEntry,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipDirEntry.cs,WriteCentralDirectoryEntry,The following statement contains a magic number: bytes[i++] = (byte)((_ExternalFileAttrs & 0x0000FF00) >> 8);
Magic Number,Ionic.Zip,ZipEntry,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipDirEntry.cs,WriteCentralDirectoryEntry,The following statement contains a magic number: bytes[i++] = (byte)((_ExternalFileAttrs & 0x00FF0000) >> 16);
Magic Number,Ionic.Zip,ZipEntry,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipDirEntry.cs,WriteCentralDirectoryEntry,The following statement contains a magic number: bytes[i++] = (byte)((_ExternalFileAttrs & 0xFF000000) >> 24);
Magic Number,Ionic.Zip,ZipEntry,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipDirEntry.cs,WriteCentralDirectoryEntry,The following statement contains a magic number: bytes[32] = (byte)(commentLength & 0x00FF);
Magic Number,Ionic.Zip,ZipEntry,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipDirEntry.cs,WriteCentralDirectoryEntry,The following statement contains a magic number: bytes[33] = (byte)((commentLength & 0xFF00) >> 8);
Magic Number,Ionic.Zip,ZipEntry,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipDirEntry.cs,WriteCentralDirectoryEntry,The following statement contains a magic number: bytes[33] = (byte)((commentLength & 0xFF00) >> 8);
Magic Number,Ionic.Zip,ZipEntry,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipDirEntry.cs,ConstructExtraField,The following statement contains a magic number: int sz = 4 + (forCentralDirectory ? 28 : 16);
Magic Number,Ionic.Zip,ZipEntry,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipDirEntry.cs,ConstructExtraField,The following statement contains a magic number: int sz = 4 + (forCentralDirectory ? 28 : 16);
Magic Number,Ionic.Zip,ZipEntry,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipDirEntry.cs,ConstructExtraField,The following statement contains a magic number: int sz = 4 + (forCentralDirectory ? 28 : 16);
Magic Number,Ionic.Zip,ZipEntry,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipDirEntry.cs,ConstructExtraField,The following statement contains a magic number: block[i++] = (byte)(sz - 4);
Magic Number,Ionic.Zip,ZipEntry,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipDirEntry.cs,ConstructExtraField,The following statement contains a magic number: Array.Copy(BitConverter.GetBytes(_UncompressedSize)' 0' block' i' 8);
Magic Number,Ionic.Zip,ZipEntry,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipDirEntry.cs,ConstructExtraField,The following statement contains a magic number: i += 8;
Magic Number,Ionic.Zip,ZipEntry,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipDirEntry.cs,ConstructExtraField,The following statement contains a magic number: Array.Copy(BitConverter.GetBytes(_CompressedSize)' 0' block' i' 8);
Magic Number,Ionic.Zip,ZipEntry,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipDirEntry.cs,ConstructExtraField,The following statement contains a magic number: i += 8;
Magic Number,Ionic.Zip,ZipEntry,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipDirEntry.cs,ConstructExtraField,The following statement contains a magic number: Array.Copy(BitConverter.GetBytes(_RelativeOffsetOfLocalHeader)' 0' block' i' 8);
Magic Number,Ionic.Zip,ZipEntry,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipDirEntry.cs,ConstructExtraField,The following statement contains a magic number: i += 8;
Magic Number,Ionic.Zip,ZipEntry,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipDirEntry.cs,ConstructExtraField,The following statement contains a magic number: Array.Copy(BitConverter.GetBytes(0)' 0' block' i' 4);
Magic Number,Ionic.Zip,ZipEntry,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipDirEntry.cs,ConstructExtraField,The following statement contains a magic number: block = new byte[4 + 7];
Magic Number,Ionic.Zip,ZipEntry,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipDirEntry.cs,ConstructExtraField,The following statement contains a magic number: block = new byte[4 + 7];
Magic Number,Ionic.Zip,ZipEntry,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipDirEntry.cs,ConstructExtraField,The following statement contains a magic number: keystrength == 128
Magic Number,Ionic.Zip,ZipEntry,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipDirEntry.cs,ConstructExtraField,The following statement contains a magic number: block = new byte[32 + 4];
Magic Number,Ionic.Zip,ZipEntry,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipDirEntry.cs,ConstructExtraField,The following statement contains a magic number: block = new byte[32 + 4];
Magic Number,Ionic.Zip,ZipEntry,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipDirEntry.cs,ConstructExtraField,The following statement contains a magic number: block[i++] = 32;
Magic Number,Ionic.Zip,ZipEntry,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipDirEntry.cs,ConstructExtraField,The following statement contains a magic number: i += 4;
Magic Number,Ionic.Zip,ZipEntry,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipDirEntry.cs,ConstructExtraField,The following statement contains a magic number: block[i++] = 24;
Magic Number,Ionic.Zip,ZipEntry,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipDirEntry.cs,ConstructExtraField,The following statement contains a magic number: Array.Copy(BitConverter.GetBytes(z)' 0' block' i' 8);
Magic Number,Ionic.Zip,ZipEntry,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipDirEntry.cs,ConstructExtraField,The following statement contains a magic number: i += 8;
Magic Number,Ionic.Zip,ZipEntry,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipDirEntry.cs,ConstructExtraField,The following statement contains a magic number: Array.Copy(BitConverter.GetBytes(z)' 0' block' i' 8);
Magic Number,Ionic.Zip,ZipEntry,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipDirEntry.cs,ConstructExtraField,The following statement contains a magic number: i += 8;
Magic Number,Ionic.Zip,ZipEntry,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipDirEntry.cs,ConstructExtraField,The following statement contains a magic number: Array.Copy(BitConverter.GetBytes(z)' 0' block' i' 8);
Magic Number,Ionic.Zip,ZipEntry,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipDirEntry.cs,ConstructExtraField,The following statement contains a magic number: i += 8;
Magic Number,Ionic.Zip,ZipEntry,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipDirEntry.cs,ConstructExtraField,The following statement contains a magic number: int len = 5 + 4;
Magic Number,Ionic.Zip,ZipEntry,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipDirEntry.cs,ConstructExtraField,The following statement contains a magic number: int len = 5 + 4;
Magic Number,Ionic.Zip,ZipEntry,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipDirEntry.cs,ConstructExtraField,The following statement contains a magic number: len += 8;
Magic Number,Ionic.Zip,ZipEntry,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipDirEntry.cs,ConstructExtraField,The following statement contains a magic number: block[i++] = unchecked((byte)(len - 4));
Magic Number,Ionic.Zip,ZipEntry,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipDirEntry.cs,ConstructExtraField,The following statement contains a magic number: Array.Copy(BitConverter.GetBytes(z)' 0' block' i' 4);
Magic Number,Ionic.Zip,ZipEntry,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipDirEntry.cs,ConstructExtraField,The following statement contains a magic number: i += 4;
Magic Number,Ionic.Zip,ZipEntry,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipDirEntry.cs,ConstructExtraField,The following statement contains a magic number: Array.Copy(BitConverter.GetBytes(z)' 0' block' i' 4);
Magic Number,Ionic.Zip,ZipEntry,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipDirEntry.cs,ConstructExtraField,The following statement contains a magic number: i += 4;
Magic Number,Ionic.Zip,ZipEntry,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipDirEntry.cs,ConstructExtraField,The following statement contains a magic number: Array.Copy(BitConverter.GetBytes(z)' 0' block' i' 4);
Magic Number,Ionic.Zip,ZipEntry,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipDirEntry.cs,ConstructExtraField,The following statement contains a magic number: i += 4;
Magic Number,Ionic.Zip,ZipEntry,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipDirEntry.cs,NormalizeFileName,The following statement contains a magic number: s1 = SlashFixed.Substring(3);
Magic Number,Ionic.Zip,ZipEntry,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipDirEntry.cs,NormalizeFileName,The following statement contains a magic number: (_TrimVolumeFromFullyQualifiedPaths) && (FileName.Length >= 3)                  && (FileName[1] == ':') && (SlashFixed[2] == '/')
Magic Number,Ionic.Zip,ZipEntry,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipDirEntry.cs,NormalizeFileName,The following statement contains a magic number: (_TrimVolumeFromFullyQualifiedPaths) && (FileName.Length >= 3)                  && (FileName[1] == ':') && (SlashFixed[2] == '/')
Magic Number,Ionic.Zip,ZipEntry,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipDirEntry.cs,WantReadAgain,The following statement contains a magic number: _zipCrypto_forWrite != null && (CompressedSize - 12) <= UncompressedSize
Magic Number,Ionic.Zip,ZipEntry,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipDirEntry.cs,WriteHeader,The following statement contains a magic number: byte[] block = new byte[30];
Magic Number,Ionic.Zip,ZipEntry,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipDirEntry.cs,WriteHeader,The following statement contains a magic number: block[i++] = (byte)((ZipConstants.ZipEntrySignature & 0x0000FF00) >> 8);
Magic Number,Ionic.Zip,ZipEntry,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipDirEntry.cs,WriteHeader,The following statement contains a magic number: block[i++] = (byte)((ZipConstants.ZipEntrySignature & 0x00FF0000) >> 16);
Magic Number,Ionic.Zip,ZipEntry,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipDirEntry.cs,WriteHeader,The following statement contains a magic number: block[i++] = (byte)((ZipConstants.ZipEntrySignature & 0xFF000000) >> 24);
Magic Number,Ionic.Zip,ZipEntry,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipDirEntry.cs,WriteHeader,The following statement contains a magic number: Int16 VersionNeededToExtract = (Int16)(_presumeZip64 ? 45 : 20);
Magic Number,Ionic.Zip,ZipEntry,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipDirEntry.cs,WriteHeader,The following statement contains a magic number: Int16 VersionNeededToExtract = (Int16)(_presumeZip64 ? 45 : 20);
Magic Number,Ionic.Zip,ZipEntry,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipDirEntry.cs,WriteHeader,The following statement contains a magic number: VersionNeededToExtract = 46;
Magic Number,Ionic.Zip,ZipEntry,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipDirEntry.cs,WriteHeader,The following statement contains a magic number: block[i++] = (byte)((VersionNeededToExtract & 0xFF00) >> 8);
Magic Number,Ionic.Zip,ZipEntry,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipDirEntry.cs,WriteHeader,The following statement contains a magic number: IsDirectory || cycle == 99
Magic Number,Ionic.Zip,ZipEntry,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipDirEntry.cs,WriteHeader,The following statement contains a magic number: block[i++] = (byte)((_BitField & 0xFF00) >> 8);
Magic Number,Ionic.Zip,ZipEntry,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipDirEntry.cs,WriteHeader,The following statement contains a magic number: block[i++] = (byte)((_CompressionMethod & 0xFF00) >> 8);
Magic Number,Ionic.Zip,ZipEntry,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipDirEntry.cs,WriteHeader,The following statement contains a magic number: cycle == 99
Magic Number,Ionic.Zip,ZipEntry,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipDirEntry.cs,WriteHeader,The following statement contains a magic number: block[i++] = (byte)((_TimeBlob & 0x0000FF00) >> 8);
Magic Number,Ionic.Zip,ZipEntry,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipDirEntry.cs,WriteHeader,The following statement contains a magic number: block[i++] = (byte)((_TimeBlob & 0x00FF0000) >> 16);
Magic Number,Ionic.Zip,ZipEntry,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipDirEntry.cs,WriteHeader,The following statement contains a magic number: block[i++] = (byte)((_TimeBlob & 0xFF000000) >> 24);
Magic Number,Ionic.Zip,ZipEntry,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipDirEntry.cs,WriteHeader,The following statement contains a magic number: block[i++] = (byte)((_Crc32 & 0x0000FF00) >> 8);
Magic Number,Ionic.Zip,ZipEntry,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipDirEntry.cs,WriteHeader,The following statement contains a magic number: block[i++] = (byte)((_Crc32 & 0x00FF0000) >> 16);
Magic Number,Ionic.Zip,ZipEntry,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipDirEntry.cs,WriteHeader,The following statement contains a magic number: block[i++] = (byte)((_Crc32 & 0xFF000000) >> 24);
Magic Number,Ionic.Zip,ZipEntry,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipDirEntry.cs,WriteHeader,The following statement contains a magic number: j < 8
Magic Number,Ionic.Zip,ZipEntry,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipDirEntry.cs,WriteHeader,The following statement contains a magic number: block[i++] = (byte)((filenameLength & 0xFF00) >> 8);
Magic Number,Ionic.Zip,ZipEntry,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipDirEntry.cs,WriteHeader,The following statement contains a magic number: block[i++] = (byte)((extraFieldLength & 0xFF00) >> 8);
Magic Number,Ionic.Zip,ZipEntry,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipDirEntry.cs,FinishOutputStream,The following statement contains a magic number: s.Write(wzacs.FinalAuthentication' 0' 10);
Magic Number,Ionic.Zip,ZipEntry,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipDirEntry.cs,FinishOutputStream,The following statement contains a magic number: _LengthOfTrailer += 10;
Magic Number,Ionic.Zip,ZipEntry,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipDirEntry.cs,PostProcessOutput,The following statement contains a magic number: headerBytesToRetract = 12;
Magic Number,Ionic.Zip,ZipEntry,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipDirEntry.cs,PostProcessOutput,The following statement contains a magic number: int j = 6;
Magic Number,Ionic.Zip,ZipEntry,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipDirEntry.cs,PostProcessOutput,The following statement contains a magic number: _EntryHeader[j++] = (byte)((_BitField & 0xFF00) >> 8);
Magic Number,Ionic.Zip,ZipEntry,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipDirEntry.cs,PostProcessOutput,The following statement contains a magic number: Int16 fnLength = (short)(_EntryHeader[26] + _EntryHeader[27] * 256);
Magic Number,Ionic.Zip,ZipEntry,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipDirEntry.cs,PostProcessOutput,The following statement contains a magic number: Int16 fnLength = (short)(_EntryHeader[26] + _EntryHeader[27] * 256);
Magic Number,Ionic.Zip,ZipEntry,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipDirEntry.cs,PostProcessOutput,The following statement contains a magic number: Int16 fnLength = (short)(_EntryHeader[26] + _EntryHeader[27] * 256);
Magic Number,Ionic.Zip,ZipEntry,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipDirEntry.cs,PostProcessOutput,The following statement contains a magic number: int offx = 30 + fnLength;
Magic Number,Ionic.Zip,ZipEntry,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipDirEntry.cs,PostProcessOutput,The following statement contains a magic number: int i = 8;
Magic Number,Ionic.Zip,ZipEntry,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipDirEntry.cs,PostProcessOutput,The following statement contains a magic number: _EntryHeader[i++] = (byte)((_CompressionMethod & 0xFF00) >> 8);
Magic Number,Ionic.Zip,ZipEntry,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipDirEntry.cs,PostProcessOutput,The following statement contains a magic number: i = 14;
Magic Number,Ionic.Zip,ZipEntry,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipDirEntry.cs,PostProcessOutput,The following statement contains a magic number: _EntryHeader[i++] = (byte)((_Crc32 & 0x0000FF00) >> 8);
Magic Number,Ionic.Zip,ZipEntry,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipDirEntry.cs,PostProcessOutput,The following statement contains a magic number: _EntryHeader[i++] = (byte)((_Crc32 & 0x00FF0000) >> 16);
Magic Number,Ionic.Zip,ZipEntry,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipDirEntry.cs,PostProcessOutput,The following statement contains a magic number: _EntryHeader[i++] = (byte)((_Crc32 & 0xFF000000) >> 24);
Magic Number,Ionic.Zip,ZipEntry,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipDirEntry.cs,PostProcessOutput,The following statement contains a magic number: Int16 filenameLength = (short)(_EntryHeader[26] + _EntryHeader[27] * 256);
Magic Number,Ionic.Zip,ZipEntry,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipDirEntry.cs,PostProcessOutput,The following statement contains a magic number: Int16 filenameLength = (short)(_EntryHeader[26] + _EntryHeader[27] * 256);
Magic Number,Ionic.Zip,ZipEntry,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipDirEntry.cs,PostProcessOutput,The following statement contains a magic number: Int16 filenameLength = (short)(_EntryHeader[26] + _EntryHeader[27] * 256);
Magic Number,Ionic.Zip,ZipEntry,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipDirEntry.cs,PostProcessOutput,The following statement contains a magic number: Int16 extraFieldLength = (short)(_EntryHeader[28] + _EntryHeader[29] * 256);
Magic Number,Ionic.Zip,ZipEntry,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipDirEntry.cs,PostProcessOutput,The following statement contains a magic number: Int16 extraFieldLength = (short)(_EntryHeader[28] + _EntryHeader[29] * 256);
Magic Number,Ionic.Zip,ZipEntry,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipDirEntry.cs,PostProcessOutput,The following statement contains a magic number: Int16 extraFieldLength = (short)(_EntryHeader[28] + _EntryHeader[29] * 256);
Magic Number,Ionic.Zip,ZipEntry,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipDirEntry.cs,PostProcessOutput,The following statement contains a magic number: _EntryHeader[4] = (byte)(45 & 0x00FF);
Magic Number,Ionic.Zip,ZipEntry,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipDirEntry.cs,PostProcessOutput,The following statement contains a magic number: _EntryHeader[4] = (byte)(45 & 0x00FF);
Magic Number,Ionic.Zip,ZipEntry,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipDirEntry.cs,PostProcessOutput,The following statement contains a magic number: _EntryHeader[5] = 0x00;
Magic Number,Ionic.Zip,ZipEntry,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipDirEntry.cs,PostProcessOutput,The following statement contains a magic number: j < 8
Magic Number,Ionic.Zip,ZipEntry,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipDirEntry.cs,PostProcessOutput,The following statement contains a magic number: i = 30 + filenameLength;
Magic Number,Ionic.Zip,ZipEntry,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipDirEntry.cs,PostProcessOutput,The following statement contains a magic number: i += 2;
Magic Number,Ionic.Zip,ZipEntry,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipDirEntry.cs,PostProcessOutput,The following statement contains a magic number: Array.Copy(BitConverter.GetBytes(_UncompressedSize)' 0' _EntryHeader' i' 8);
Magic Number,Ionic.Zip,ZipEntry,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipDirEntry.cs,PostProcessOutput,The following statement contains a magic number: i += 8;
Magic Number,Ionic.Zip,ZipEntry,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipDirEntry.cs,PostProcessOutput,The following statement contains a magic number: Array.Copy(BitConverter.GetBytes(_CompressedSize)' 0' _EntryHeader' i' 8);
Magic Number,Ionic.Zip,ZipEntry,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipDirEntry.cs,PostProcessOutput,The following statement contains a magic number: i = 8;
Magic Number,Ionic.Zip,ZipEntry,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipDirEntry.cs,PostProcessOutput,The following statement contains a magic number: i = 30 + filenameLength;
Magic Number,Ionic.Zip,ZipEntry,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipDirEntry.cs,PostProcessOutput,The following statement contains a magic number: UInt16 HeaderId = (UInt16)(_EntryHeader[i] + _EntryHeader[i + 1] * 256);
Magic Number,Ionic.Zip,ZipEntry,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipDirEntry.cs,PostProcessOutput,The following statement contains a magic number: Int16 DataSize = (short)(_EntryHeader[i + 2] + _EntryHeader[i + 3] * 256);
Magic Number,Ionic.Zip,ZipEntry,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipDirEntry.cs,PostProcessOutput,The following statement contains a magic number: Int16 DataSize = (short)(_EntryHeader[i + 2] + _EntryHeader[i + 3] * 256);
Magic Number,Ionic.Zip,ZipEntry,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipDirEntry.cs,PostProcessOutput,The following statement contains a magic number: Int16 DataSize = (short)(_EntryHeader[i + 2] + _EntryHeader[i + 3] * 256);
Magic Number,Ionic.Zip,ZipEntry,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipDirEntry.cs,PostProcessOutput,The following statement contains a magic number: i += DataSize + 4;
Magic Number,Ionic.Zip,ZipEntry,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipDirEntry.cs,PostProcessOutput,The following statement contains a magic number: byte[] Descriptor = new byte[16 + (_OutputUsesZip64.Value ? 8 : 0)];
Magic Number,Ionic.Zip,ZipEntry,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipDirEntry.cs,PostProcessOutput,The following statement contains a magic number: byte[] Descriptor = new byte[16 + (_OutputUsesZip64.Value ? 8 : 0)];
Magic Number,Ionic.Zip,ZipEntry,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipDirEntry.cs,PostProcessOutput,The following statement contains a magic number: Array.Copy(BitConverter.GetBytes(ZipConstants.ZipEntryDataDescriptorSignature)' 0' Descriptor' i' 4);
Magic Number,Ionic.Zip,ZipEntry,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipDirEntry.cs,PostProcessOutput,The following statement contains a magic number: i += 4;
Magic Number,Ionic.Zip,ZipEntry,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipDirEntry.cs,PostProcessOutput,The following statement contains a magic number: Array.Copy(BitConverter.GetBytes(_Crc32)' 0' Descriptor' i' 4);
Magic Number,Ionic.Zip,ZipEntry,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipDirEntry.cs,PostProcessOutput,The following statement contains a magic number: i += 4;
Magic Number,Ionic.Zip,ZipEntry,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipDirEntry.cs,PostProcessOutput,The following statement contains a magic number: Array.Copy(BitConverter.GetBytes(_CompressedSize)' 0' Descriptor' i' 8);
Magic Number,Ionic.Zip,ZipEntry,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipDirEntry.cs,PostProcessOutput,The following statement contains a magic number: i += 8;
Magic Number,Ionic.Zip,ZipEntry,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipDirEntry.cs,PostProcessOutput,The following statement contains a magic number: Array.Copy(BitConverter.GetBytes(_UncompressedSize)' 0' Descriptor' i' 8);
Magic Number,Ionic.Zip,ZipEntry,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipDirEntry.cs,PostProcessOutput,The following statement contains a magic number: i += 8;
Magic Number,Ionic.Zip,ZipEntry,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipDirEntry.cs,WriteSecurityMetadata,The following statement contains a magic number: byte[] encryptionHeader = new byte[12];
Magic Number,Ionic.Zip,ZipEntry,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipDirEntry.cs,WriteSecurityMetadata,The following statement contains a magic number: encryptionHeader[11] = (byte)((this._TimeBlob >> 8) & 0xff);
Magic Number,Ionic.Zip,ZipEntry,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipDirEntry.cs,WriteSecurityMetadata,The following statement contains a magic number: encryptionHeader[11] = (byte)((this._TimeBlob >> 8) & 0xff);
Magic Number,Ionic.Zip,ZipEntry,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipDirEntry.cs,CopyThroughWithRecompute,The following statement contains a magic number: int size = 16;
Magic Number,Ionic.Zip,ZipEntry,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipDirEntry.cs,CopyThroughWithRecompute,The following statement contains a magic number: size += 8;
Magic Number,Ionic.Zip,ZipEntry,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipDirEntry.cs,CopyThroughWithRecompute,The following statement contains a magic number: outstream.Write(Descriptor' 0' 8);
Magic Number,Ionic.Zip,ZipEntry,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipDirEntry.cs,CopyThroughWithRecompute,The following statement contains a magic number: outstream.Write(Descriptor' 8' 4);
Magic Number,Ionic.Zip,ZipEntry,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipDirEntry.cs,CopyThroughWithRecompute,The following statement contains a magic number: outstream.Write(Descriptor' 8' 4);
Magic Number,Ionic.Zip,ZipEntry,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipDirEntry.cs,CopyThroughWithRecompute,The following statement contains a magic number: outstream.Write(Descriptor' 16' 4);
Magic Number,Ionic.Zip,ZipEntry,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipDirEntry.cs,CopyThroughWithRecompute,The following statement contains a magic number: outstream.Write(Descriptor' 16' 4);
Magic Number,Ionic.Zip,ZipEntry,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipDirEntry.cs,CopyThroughWithRecompute,The following statement contains a magic number: _LengthOfTrailer -= 8;
Magic Number,Ionic.Zip,ZipEntry,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipDirEntry.cs,TraceWriteLine,The following statement contains a magic number: Console.ForegroundColor = (ConsoleColor)(tid % 8 + 8);
Magic Number,Ionic.Zip,ZipEntry,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipDirEntry.cs,TraceWriteLine,The following statement contains a magic number: Console.ForegroundColor = (ConsoleColor)(tid % 8 + 8);
Magic Number,Ionic.Zip,CopyHelper,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipDirEntry.cs,AppendCopyToFileName,The following statement contains a magic number: callCount > 25
Magic Number,Ionic.Zip,ZipFile,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipFile.AddUpdate.cs,_InitInstance,The following statement contains a magic number: ParallelDeflateThreshold = 512 * 1024;
Magic Number,Ionic.Zip,ZipFile,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipFile.AddUpdate.cs,_InitInstance,The following statement contains a magic number: ParallelDeflateThreshold = 512 * 1024;
Magic Number,Ionic.Zip,ZipFile,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipFile.AddUpdate.cs,_InternalExtractAll,The following statement contains a magic number: StatusMessageTextWriter.WriteLine(new System.String('-'' 72));
Magic Number,Ionic.Zip,ZipFile,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipFile.AddUpdate.cs,ReadIntoInstance,The following statement contains a magic number: long posn = s.Length - 64;
Magic Number,Ionic.Zip,ZipFile,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipFile.AddUpdate.cs,ReadIntoInstance,The following statement contains a magic number: long maxSeekback = Math.Max(s.Length - 0x4000' 10);
Magic Number,Ionic.Zip,ZipFile,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipFile.AddUpdate.cs,ReadIntoInstance,The following statement contains a magic number: zf._locEndOfCDS = s.Position - 4;
Magic Number,Ionic.Zip,ZipFile,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipFile.AddUpdate.cs,ReadIntoInstance,The following statement contains a magic number: byte[] block = new byte[16];
Magic Number,Ionic.Zip,ZipFile,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipFile.AddUpdate.cs,ReadIntoInstance,The following statement contains a magic number: zf._diskNumberWithCd = BitConverter.ToUInt16(block' 2);
Magic Number,Ionic.Zip,ZipFile,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipFile.AddUpdate.cs,ReadIntoInstance,The following statement contains a magic number: int i = 12;
Magic Number,Ionic.Zip,ZipFile,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipFile.AddUpdate.cs,Zip64SeekToCentralDirectory,The following statement contains a magic number: byte[] block = new byte[16];
Magic Number,Ionic.Zip,ZipFile,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipFile.AddUpdate.cs,Zip64SeekToCentralDirectory,The following statement contains a magic number: s.Seek(-40' SeekOrigin.Current);
Magic Number,Ionic.Zip,ZipFile,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipFile.AddUpdate.cs,Zip64SeekToCentralDirectory,The following statement contains a magic number: s.Read(block' 0' 16);
Magic Number,Ionic.Zip,ZipFile,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipFile.AddUpdate.cs,Zip64SeekToCentralDirectory,The following statement contains a magic number: Int64 offset64 = BitConverter.ToInt64(block' 8);
Magic Number,Ionic.Zip,ZipFile,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipFile.AddUpdate.cs,Zip64SeekToCentralDirectory,The following statement contains a magic number: s.Read(block' 0' 8);
Magic Number,Ionic.Zip,ZipFile,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipFile.AddUpdate.cs,Zip64SeekToCentralDirectory,The following statement contains a magic number: offset64 = BitConverter.ToInt64(block' 36);
Magic Number,Ionic.Zip,ZipFile,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipFile.AddUpdate.cs,ReadCentralDirectoryFooter,The following statement contains a magic number: block = new byte[8 + 44];
Magic Number,Ionic.Zip,ZipFile,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipFile.AddUpdate.cs,ReadCentralDirectoryFooter,The following statement contains a magic number: block = new byte[8 + 44];
Magic Number,Ionic.Zip,ZipFile,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipFile.AddUpdate.cs,ReadCentralDirectoryFooter,The following statement contains a magic number: DataSize < 44
Magic Number,Ionic.Zip,ZipFile,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipFile.AddUpdate.cs,ReadCentralDirectoryFooter,The following statement contains a magic number: j += 2;
Magic Number,Ionic.Zip,ZipFile,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipFile.AddUpdate.cs,ReadCentralDirectoryFooter,The following statement contains a magic number: j += 2;
Magic Number,Ionic.Zip,ZipFile,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipFile.AddUpdate.cs,ReadCentralDirectoryFooter,The following statement contains a magic number: j += 2;
Magic Number,Ionic.Zip,ZipFile,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipFile.AddUpdate.cs,ReadCentralDirectoryFooter,The following statement contains a magic number: block = new byte[DataSize - 44];
Magic Number,Ionic.Zip,ZipFile,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipFile.AddUpdate.cs,ReadCentralDirectoryFooter,The following statement contains a magic number: block = new byte[16];
Magic Number,Ionic.Zip,ZipFile,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipFile.AddUpdate.cs,ReadCentralDirectoryFooter,The following statement contains a magic number: s.Seek(-4' SeekOrigin.Current);
Magic Number,Ionic.Zip,ZipFile,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipFile.AddUpdate.cs,ReadCentralDirectoryFooter,The following statement contains a magic number: block = new byte[16];
Magic Number,Ionic.Zip,ZipFile,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipFile.AddUpdate.cs,ReadCentralDirectoryFooter,The following statement contains a magic number: zf._diskNumberWithCd = BitConverter.ToUInt16(block' 2);
Magic Number,Ionic.Zip,ZipFile,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipFile.AddUpdate.cs,ReadZipFileComment,The following statement contains a magic number: byte[] block = new byte[2];
Magic Number,Ionic.Zip,ZipFile,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipFile.AddUpdate.cs,ReadZipFileComment,The following statement contains a magic number: Int16 commentLength = (short)(block[0] + block[1] * 256);
Magic Number,Ionic.Zip,ZipFile,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipFile.AddUpdate.cs,DeleteFileWithRetry,The following statement contains a magic number: int nRetries = 3;
Magic Number,Ionic.Zip,ZipFile,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipFile.AddUpdate.cs,ZipFile,The following statement contains a magic number: ibm437 = System.Text.CodePagesEncodingProvider.Instance.GetEncoding(1252);
Magic Number,Ionic.Zip,ZipOutput,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipFile.Save.cs,WriteCentralDirectoryStructure,The following statement contains a magic number: int i = 16;
Magic Number,Ionic.Zip,ZipOutput,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipFile.Save.cs,WriteCentralDirectoryStructure,The following statement contains a magic number: Array.Copy(BitConverter.GetBytes(thisSegment)' 0' a' i' 4);
Magic Number,Ionic.Zip,ZipOutput,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipFile.Save.cs,WriteCentralDirectoryStructure,The following statement contains a magic number: i += 4;
Magic Number,Ionic.Zip,ZipOutput,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipFile.Save.cs,WriteCentralDirectoryStructure,The following statement contains a magic number: Array.Copy(BitConverter.GetBytes(thisSegment)' 0' a' i' 4);
Magic Number,Ionic.Zip,ZipOutput,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipFile.Save.cs,WriteCentralDirectoryStructure,The following statement contains a magic number: i = 60;
Magic Number,Ionic.Zip,ZipOutput,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipFile.Save.cs,WriteCentralDirectoryStructure,The following statement contains a magic number: Array.Copy(BitConverter.GetBytes(thisSegment)' 0' a' i' 4);
Magic Number,Ionic.Zip,ZipOutput,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipFile.Save.cs,WriteCentralDirectoryStructure,The following statement contains a magic number: i += 4;
Magic Number,Ionic.Zip,ZipOutput,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipFile.Save.cs,WriteCentralDirectoryStructure,The following statement contains a magic number: i += 8;
Magic Number,Ionic.Zip,ZipOutput,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipFile.Save.cs,WriteCentralDirectoryStructure,The following statement contains a magic number: Array.Copy(BitConverter.GetBytes(thisSegment)' 0' a' i' 4);
Magic Number,Ionic.Zip,ZipOutput,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipFile.Save.cs,WriteCentralDirectoryStructure,The following statement contains a magic number: int i = 4;
Magic Number,Ionic.Zip,ZipOutput,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipFile.Save.cs,WriteCentralDirectoryStructure,The following statement contains a magic number: Array.Copy(BitConverter.GetBytes(thisSegment)' 0' a2' i' 2);
Magic Number,Ionic.Zip,ZipOutput,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipFile.Save.cs,WriteCentralDirectoryStructure,The following statement contains a magic number: i += 2;
Magic Number,Ionic.Zip,ZipOutput,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipFile.Save.cs,WriteCentralDirectoryStructure,The following statement contains a magic number: Array.Copy(BitConverter.GetBytes(thisSegment)' 0' a2' i' 2);
Magic Number,Ionic.Zip,ZipOutput,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipFile.Save.cs,WriteCentralDirectoryStructure,The following statement contains a magic number: i += 2;
Magic Number,Ionic.Zip,ZipOutput,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipFile.Save.cs,GenCentralDirectoryFooter,The following statement contains a magic number: int bufferLength = 22;
Magic Number,Ionic.Zip,ZipOutput,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipFile.Save.cs,GenCentralDirectoryFooter,The following statement contains a magic number: Array.Copy(sig' 0' bytes' i' 4);
Magic Number,Ionic.Zip,ZipOutput,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipFile.Save.cs,GenCentralDirectoryFooter,The following statement contains a magic number: i+=4;
Magic Number,Ionic.Zip,ZipOutput,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipFile.Save.cs,GenCentralDirectoryFooter,The following statement contains a magic number: j < 4
Magic Number,Ionic.Zip,ZipOutput,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipFile.Save.cs,GenCentralDirectoryFooter,The following statement contains a magic number: j < 8
Magic Number,Ionic.Zip,ZipOutput,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipFile.Save.cs,GenZip64EndOfCentralDirectory,The following statement contains a magic number: const int bufferLength = 12 + 44 + 20;
Magic Number,Ionic.Zip,ZipOutput,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipFile.Save.cs,GenZip64EndOfCentralDirectory,The following statement contains a magic number: const int bufferLength = 12 + 44 + 20;
Magic Number,Ionic.Zip,ZipOutput,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipFile.Save.cs,GenZip64EndOfCentralDirectory,The following statement contains a magic number: const int bufferLength = 12 + 44 + 20;
Magic Number,Ionic.Zip,ZipOutput,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipFile.Save.cs,GenZip64EndOfCentralDirectory,The following statement contains a magic number: Array.Copy(sig' 0' bytes' i' 4);
Magic Number,Ionic.Zip,ZipOutput,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipFile.Save.cs,GenZip64EndOfCentralDirectory,The following statement contains a magic number: i+=4;
Magic Number,Ionic.Zip,ZipOutput,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipFile.Save.cs,GenZip64EndOfCentralDirectory,The following statement contains a magic number: long DataSize = 44;
Magic Number,Ionic.Zip,ZipOutput,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipFile.Save.cs,GenZip64EndOfCentralDirectory,The following statement contains a magic number: Array.Copy(BitConverter.GetBytes(DataSize)' 0' bytes' i' 8);
Magic Number,Ionic.Zip,ZipOutput,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipFile.Save.cs,GenZip64EndOfCentralDirectory,The following statement contains a magic number: i += 8;
Magic Number,Ionic.Zip,ZipOutput,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipFile.Save.cs,GenZip64EndOfCentralDirectory,The following statement contains a magic number: bytes[i++] = 45;
Magic Number,Ionic.Zip,ZipOutput,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipFile.Save.cs,GenZip64EndOfCentralDirectory,The following statement contains a magic number: bytes[i++] = 45;
Magic Number,Ionic.Zip,ZipOutput,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipFile.Save.cs,GenZip64EndOfCentralDirectory,The following statement contains a magic number: j < 8
Magic Number,Ionic.Zip,ZipOutput,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipFile.Save.cs,GenZip64EndOfCentralDirectory,The following statement contains a magic number: Array.Copy(BitConverter.GetBytes(numberOfEntries)' 0' bytes' i' 8);
Magic Number,Ionic.Zip,ZipOutput,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipFile.Save.cs,GenZip64EndOfCentralDirectory,The following statement contains a magic number: i += 8;
Magic Number,Ionic.Zip,ZipOutput,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipFile.Save.cs,GenZip64EndOfCentralDirectory,The following statement contains a magic number: Array.Copy(BitConverter.GetBytes(numberOfEntries)' 0' bytes' i' 8);
Magic Number,Ionic.Zip,ZipOutput,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipFile.Save.cs,GenZip64EndOfCentralDirectory,The following statement contains a magic number: i += 8;
Magic Number,Ionic.Zip,ZipOutput,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipFile.Save.cs,GenZip64EndOfCentralDirectory,The following statement contains a magic number: Array.Copy(BitConverter.GetBytes(SizeofCentraldirectory)' 0' bytes' i' 8);
Magic Number,Ionic.Zip,ZipOutput,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipFile.Save.cs,GenZip64EndOfCentralDirectory,The following statement contains a magic number: i += 8;
Magic Number,Ionic.Zip,ZipOutput,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipFile.Save.cs,GenZip64EndOfCentralDirectory,The following statement contains a magic number: Array.Copy(BitConverter.GetBytes(StartOfCentralDirectory)' 0' bytes' i' 8);
Magic Number,Ionic.Zip,ZipOutput,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipFile.Save.cs,GenZip64EndOfCentralDirectory,The following statement contains a magic number: i += 8;
Magic Number,Ionic.Zip,ZipOutput,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipFile.Save.cs,GenZip64EndOfCentralDirectory,The following statement contains a magic number: Array.Copy(sig' 0' bytes' i' 4);
Magic Number,Ionic.Zip,ZipOutput,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipFile.Save.cs,GenZip64EndOfCentralDirectory,The following statement contains a magic number: i+=4;
Magic Number,Ionic.Zip,ZipOutput,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipFile.Save.cs,GenZip64EndOfCentralDirectory,The following statement contains a magic number: Array.Copy(BitConverter.GetBytes(x2)' 0' bytes' i' 4);
Magic Number,Ionic.Zip,ZipOutput,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipFile.Save.cs,GenZip64EndOfCentralDirectory,The following statement contains a magic number: i+=4;
Magic Number,Ionic.Zip,ZipOutput,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipFile.Save.cs,GenZip64EndOfCentralDirectory,The following statement contains a magic number: Array.Copy(BitConverter.GetBytes(EndOfCentralDirectory)' 0' bytes' i' 8);
Magic Number,Ionic.Zip,ZipOutput,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipFile.Save.cs,GenZip64EndOfCentralDirectory,The following statement contains a magic number: i += 8;
Magic Number,Ionic.Zip,ZipOutput,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipFile.Save.cs,GenZip64EndOfCentralDirectory,The following statement contains a magic number: Array.Copy(BitConverter.GetBytes(numSegments)' 0' bytes' i' 4);
Magic Number,Ionic.Zip,ZipOutput,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipFile.Save.cs,GenZip64EndOfCentralDirectory,The following statement contains a magic number: i+=4;
Magic Number,Ionic.Zip,ZipInputStream,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipInputStream.cs,GetNextEntry,The following statement contains a magic number: _inputStream.Seek(-4' SeekOrigin.Current);
Magic Number,Ionic.Zip,ZipOutputStream,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipOutputStream.cs,_InitiateCurrentEntry,The following statement contains a magic number: _entryCount > 65534 && _zip64 == Zip64Option.Never
Magic Number,Ionic.Zip,ZipOutputStream,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipOutputStream.cs,_InitiateCurrentEntry,The following statement contains a magic number: _currentEntry.WriteHeader(_outputStream' finishing ? 99 : 0);
Magic Number,Ionic.Zip,ZipSegmentedStream,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipSegmentedStream.cs,_SetWriteStream,The following statement contains a magic number: _innerStream.Write(BitConverter.GetBytes(ZipConstants.SplitArchiveSignature)' 0' 4);
Magic Number,Ionic.Zip,ZipSegmentedStream,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipSegmentedStream.cs,TruncateBackward,The following statement contains a magic number: i < 3
Magic Number,Ionic,FileSelector,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\FileSelector.cs,_ParseCriterion,The following statement contains a magic number: tokens.Length < 3
Magic Number,Ionic,FileSelector,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\FileSelector.cs,_ParseCriterion,The following statement contains a magic number: switch (tok1)                  {                      case "and":                      case "xor":                      case "or":                          state = stateStack.Peek();                          if (state != ParseState.CriterionDone)                              throw new ArgumentException(String.Join(" "' tokens' i' tokens.Length - i));                            if (tokens.Length <= i + 3)                              throw new ArgumentException(String.Join(" "' tokens' i' tokens.Length - i));                            pendingConjunction = (LogicalConjunction)Enum.Parse(typeof(LogicalConjunction)' tokens[i].ToUpper()' true);                          current = new CompoundCriterion { Left = current' Right = null' Conjunction = pendingConjunction };                          stateStack.Push(state);                          stateStack.Push(ParseState.ConjunctionPending);                          critStack.Push(current);                          break;                        case "(":                          state = stateStack.Peek();                          if (state != ParseState.Start && state != ParseState.ConjunctionPending && state != ParseState.OpenParen)                              throw new ArgumentException(String.Join(" "' tokens' i' tokens.Length - i));                            if (tokens.Length <= i + 4)                              throw new ArgumentException(String.Join(" "' tokens' i' tokens.Length - i));                            stateStack.Push(ParseState.OpenParen);                          break;                        case ")":                          state = stateStack.Pop();                          if (stateStack.Peek() != ParseState.OpenParen)                              throw new ArgumentException(String.Join(" "' tokens' i' tokens.Length - i));                            stateStack.Pop();                          stateStack.Push(ParseState.CriterionDone);                          break;                        case "atime":                      case "ctime":                      case "mtime":                          if (tokens.Length <= i + 2)                              throw new ArgumentException(String.Join(" "' tokens' i' tokens.Length - i));                            DateTime t;                          try                          {                              t = DateTime.ParseExact(tokens[i + 2]' "yyyy-MM-dd-HH:mm:ss"' null);                          }                          catch (FormatException)                          {                              try                              {                                  t = DateTime.ParseExact(tokens[i + 2]' "yyyy/MM/dd-HH:mm:ss"' null);                              }                              catch (FormatException)                              {                                  try                                  {                                      t = DateTime.ParseExact(tokens[i + 2]' "yyyy/MM/dd"' null);                                  }                                  catch (FormatException)                                  {                                      try                                      {                                          t = DateTime.ParseExact(tokens[i + 2]' "MM/dd/yyyy"' null);                                      }                                      catch (FormatException)                                      {                                          t = DateTime.ParseExact(tokens[i + 2]' "yyyy-MM-dd"' null);                                      }                                  }                              }                          }                          t= DateTime.SpecifyKind(t' DateTimeKind.Local).ToUniversalTime();                          current = new TimeCriterion                          {                              Which = (WhichTime)Enum.Parse(typeof(WhichTime)' tokens[i]' true)'                              Operator = (ComparisonOperator)EnumUtil.Parse(typeof(ComparisonOperator)' tokens[i + 1])'                              Time = t                          };                          i += 2;                          stateStack.Push(ParseState.CriterionDone);                          break;                          case "length":                      case "size":                          if (tokens.Length <= i + 2)                              throw new ArgumentException(String.Join(" "' tokens' i' tokens.Length - i));                            Int64 sz = 0;                          string v = tokens[i + 2];                          if (v.ToUpper().EndsWith("K"))                              sz = Int64.Parse(v.Substring(0' v.Length - 1)) * 1024;                          else if (v.ToUpper().EndsWith("KB"))                              sz = Int64.Parse(v.Substring(0' v.Length - 2)) * 1024;                          else if (v.ToUpper().EndsWith("M"))                              sz = Int64.Parse(v.Substring(0' v.Length - 1)) * 1024 * 1024;                          else if (v.ToUpper().EndsWith("MB"))                              sz = Int64.Parse(v.Substring(0' v.Length - 2)) * 1024 * 1024;                          else if (v.ToUpper().EndsWith("G"))                              sz = Int64.Parse(v.Substring(0' v.Length - 1)) * 1024 * 1024 * 1024;                          else if (v.ToUpper().EndsWith("GB"))                              sz = Int64.Parse(v.Substring(0' v.Length - 2)) * 1024 * 1024 * 1024;                          else sz = Int64.Parse(tokens[i + 2]);                            current = new SizeCriterion                          {                              Size = sz'                              Operator = (ComparisonOperator)EnumUtil.Parse(typeof(ComparisonOperator)' tokens[i + 1])                          };                          i += 2;                          stateStack.Push(ParseState.CriterionDone);                          break;                        case "filename":                      case "name":                          {                              if (tokens.Length <= i + 2)                                  throw new ArgumentException(String.Join(" "' tokens' i' tokens.Length - i));                                ComparisonOperator c =                                  (ComparisonOperator)EnumUtil.Parse(typeof(ComparisonOperator)' tokens[i + 1]);                                if (c != ComparisonOperator.NotEqualTo && c != ComparisonOperator.EqualTo)                                  throw new ArgumentException(String.Join(" "' tokens' i' tokens.Length - i));                                string m = tokens[i + 2];                                // handle single-quoted filespecs (used to include                              // spaces in filename patterns)                              if (m.StartsWith("'") && m.EndsWith("'"))                              {                                  // trim off leading and trailing single quotes and                                  // revert the control characters to spaces.                                  m = m.Substring(1' m.Length - 2)                                      .Replace("\u0006"' " ");                              }                                // if (m.StartsWith("'"))                              //     m = m.Replace("\u0006"' " ");                                //Fix for Unix -> NormalizeCriteriaExpression replaces all slashes with backslashes                              if (Path.DirectorySeparatorChar == '/')                                  m = m.Replace('\\'' Path.DirectorySeparatorChar);                                current = new NameCriterion                              {                                  MatchingFileSpec = m'                                  Operator = c                              };                              i += 2;                              stateStack.Push(ParseState.CriterionDone);                          }                          break;                        case "attrs":                      case "attributes":                      case "type":                          {                              if (tokens.Length <= i + 2)                                  throw new ArgumentException(String.Join(" "' tokens' i' tokens.Length - i));                                ComparisonOperator c =                                  (ComparisonOperator)EnumUtil.Parse(typeof(ComparisonOperator)' tokens[i + 1]);                                if (c != ComparisonOperator.NotEqualTo && c != ComparisonOperator.EqualTo)                                  throw new ArgumentException(String.Join(" "' tokens' i' tokens.Length - i));                                current = (tok1 == "type")                                  ? (SelectionCriterion) new TypeCriterion                                      {                                          AttributeString = tokens[i + 2]'                                          Operator = c                                      }                                  : (SelectionCriterion) new AttributesCriterion                                      {                                          AttributeString = tokens[i + 2]'                                          Operator = c                                      };                              i += 2;                              stateStack.Push(ParseState.CriterionDone);                          }                          break;                        case "":                          // NOP                          stateStack.Push(ParseState.Whitespace);                          break;                        default:                          throw new ArgumentException("'" + tokens[i] + "'");                  }
Magic Number,Ionic,FileSelector,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\FileSelector.cs,_ParseCriterion,The following statement contains a magic number: switch (tok1)                  {                      case "and":                      case "xor":                      case "or":                          state = stateStack.Peek();                          if (state != ParseState.CriterionDone)                              throw new ArgumentException(String.Join(" "' tokens' i' tokens.Length - i));                            if (tokens.Length <= i + 3)                              throw new ArgumentException(String.Join(" "' tokens' i' tokens.Length - i));                            pendingConjunction = (LogicalConjunction)Enum.Parse(typeof(LogicalConjunction)' tokens[i].ToUpper()' true);                          current = new CompoundCriterion { Left = current' Right = null' Conjunction = pendingConjunction };                          stateStack.Push(state);                          stateStack.Push(ParseState.ConjunctionPending);                          critStack.Push(current);                          break;                        case "(":                          state = stateStack.Peek();                          if (state != ParseState.Start && state != ParseState.ConjunctionPending && state != ParseState.OpenParen)                              throw new ArgumentException(String.Join(" "' tokens' i' tokens.Length - i));                            if (tokens.Length <= i + 4)                              throw new ArgumentException(String.Join(" "' tokens' i' tokens.Length - i));                            stateStack.Push(ParseState.OpenParen);                          break;                        case ")":                          state = stateStack.Pop();                          if (stateStack.Peek() != ParseState.OpenParen)                              throw new ArgumentException(String.Join(" "' tokens' i' tokens.Length - i));                            stateStack.Pop();                          stateStack.Push(ParseState.CriterionDone);                          break;                        case "atime":                      case "ctime":                      case "mtime":                          if (tokens.Length <= i + 2)                              throw new ArgumentException(String.Join(" "' tokens' i' tokens.Length - i));                            DateTime t;                          try                          {                              t = DateTime.ParseExact(tokens[i + 2]' "yyyy-MM-dd-HH:mm:ss"' null);                          }                          catch (FormatException)                          {                              try                              {                                  t = DateTime.ParseExact(tokens[i + 2]' "yyyy/MM/dd-HH:mm:ss"' null);                              }                              catch (FormatException)                              {                                  try                                  {                                      t = DateTime.ParseExact(tokens[i + 2]' "yyyy/MM/dd"' null);                                  }                                  catch (FormatException)                                  {                                      try                                      {                                          t = DateTime.ParseExact(tokens[i + 2]' "MM/dd/yyyy"' null);                                      }                                      catch (FormatException)                                      {                                          t = DateTime.ParseExact(tokens[i + 2]' "yyyy-MM-dd"' null);                                      }                                  }                              }                          }                          t= DateTime.SpecifyKind(t' DateTimeKind.Local).ToUniversalTime();                          current = new TimeCriterion                          {                              Which = (WhichTime)Enum.Parse(typeof(WhichTime)' tokens[i]' true)'                              Operator = (ComparisonOperator)EnumUtil.Parse(typeof(ComparisonOperator)' tokens[i + 1])'                              Time = t                          };                          i += 2;                          stateStack.Push(ParseState.CriterionDone);                          break;                          case "length":                      case "size":                          if (tokens.Length <= i + 2)                              throw new ArgumentException(String.Join(" "' tokens' i' tokens.Length - i));                            Int64 sz = 0;                          string v = tokens[i + 2];                          if (v.ToUpper().EndsWith("K"))                              sz = Int64.Parse(v.Substring(0' v.Length - 1)) * 1024;                          else if (v.ToUpper().EndsWith("KB"))                              sz = Int64.Parse(v.Substring(0' v.Length - 2)) * 1024;                          else if (v.ToUpper().EndsWith("M"))                              sz = Int64.Parse(v.Substring(0' v.Length - 1)) * 1024 * 1024;                          else if (v.ToUpper().EndsWith("MB"))                              sz = Int64.Parse(v.Substring(0' v.Length - 2)) * 1024 * 1024;                          else if (v.ToUpper().EndsWith("G"))                              sz = Int64.Parse(v.Substring(0' v.Length - 1)) * 1024 * 1024 * 1024;                          else if (v.ToUpper().EndsWith("GB"))                              sz = Int64.Parse(v.Substring(0' v.Length - 2)) * 1024 * 1024 * 1024;                          else sz = Int64.Parse(tokens[i + 2]);                            current = new SizeCriterion                          {                              Size = sz'                              Operator = (ComparisonOperator)EnumUtil.Parse(typeof(ComparisonOperator)' tokens[i + 1])                          };                          i += 2;                          stateStack.Push(ParseState.CriterionDone);                          break;                        case "filename":                      case "name":                          {                              if (tokens.Length <= i + 2)                                  throw new ArgumentException(String.Join(" "' tokens' i' tokens.Length - i));                                ComparisonOperator c =                                  (ComparisonOperator)EnumUtil.Parse(typeof(ComparisonOperator)' tokens[i + 1]);                                if (c != ComparisonOperator.NotEqualTo && c != ComparisonOperator.EqualTo)                                  throw new ArgumentException(String.Join(" "' tokens' i' tokens.Length - i));                                string m = tokens[i + 2];                                // handle single-quoted filespecs (used to include                              // spaces in filename patterns)                              if (m.StartsWith("'") && m.EndsWith("'"))                              {                                  // trim off leading and trailing single quotes and                                  // revert the control characters to spaces.                                  m = m.Substring(1' m.Length - 2)                                      .Replace("\u0006"' " ");                              }                                // if (m.StartsWith("'"))                              //     m = m.Replace("\u0006"' " ");                                //Fix for Unix -> NormalizeCriteriaExpression replaces all slashes with backslashes                              if (Path.DirectorySeparatorChar == '/')                                  m = m.Replace('\\'' Path.DirectorySeparatorChar);                                current = new NameCriterion                              {                                  MatchingFileSpec = m'                                  Operator = c                              };                              i += 2;                              stateStack.Push(ParseState.CriterionDone);                          }                          break;                        case "attrs":                      case "attributes":                      case "type":                          {                              if (tokens.Length <= i + 2)                                  throw new ArgumentException(String.Join(" "' tokens' i' tokens.Length - i));                                ComparisonOperator c =                                  (ComparisonOperator)EnumUtil.Parse(typeof(ComparisonOperator)' tokens[i + 1]);                                if (c != ComparisonOperator.NotEqualTo && c != ComparisonOperator.EqualTo)                                  throw new ArgumentException(String.Join(" "' tokens' i' tokens.Length - i));                                current = (tok1 == "type")                                  ? (SelectionCriterion) new TypeCriterion                                      {                                          AttributeString = tokens[i + 2]'                                          Operator = c                                      }                                  : (SelectionCriterion) new AttributesCriterion                                      {                                          AttributeString = tokens[i + 2]'                                          Operator = c                                      };                              i += 2;                              stateStack.Push(ParseState.CriterionDone);                          }                          break;                        case "":                          // NOP                          stateStack.Push(ParseState.Whitespace);                          break;                        default:                          throw new ArgumentException("'" + tokens[i] + "'");                  }
Magic Number,Ionic,FileSelector,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\FileSelector.cs,_ParseCriterion,The following statement contains a magic number: switch (tok1)                  {                      case "and":                      case "xor":                      case "or":                          state = stateStack.Peek();                          if (state != ParseState.CriterionDone)                              throw new ArgumentException(String.Join(" "' tokens' i' tokens.Length - i));                            if (tokens.Length <= i + 3)                              throw new ArgumentException(String.Join(" "' tokens' i' tokens.Length - i));                            pendingConjunction = (LogicalConjunction)Enum.Parse(typeof(LogicalConjunction)' tokens[i].ToUpper()' true);                          current = new CompoundCriterion { Left = current' Right = null' Conjunction = pendingConjunction };                          stateStack.Push(state);                          stateStack.Push(ParseState.ConjunctionPending);                          critStack.Push(current);                          break;                        case "(":                          state = stateStack.Peek();                          if (state != ParseState.Start && state != ParseState.ConjunctionPending && state != ParseState.OpenParen)                              throw new ArgumentException(String.Join(" "' tokens' i' tokens.Length - i));                            if (tokens.Length <= i + 4)                              throw new ArgumentException(String.Join(" "' tokens' i' tokens.Length - i));                            stateStack.Push(ParseState.OpenParen);                          break;                        case ")":                          state = stateStack.Pop();                          if (stateStack.Peek() != ParseState.OpenParen)                              throw new ArgumentException(String.Join(" "' tokens' i' tokens.Length - i));                            stateStack.Pop();                          stateStack.Push(ParseState.CriterionDone);                          break;                        case "atime":                      case "ctime":                      case "mtime":                          if (tokens.Length <= i + 2)                              throw new ArgumentException(String.Join(" "' tokens' i' tokens.Length - i));                            DateTime t;                          try                          {                              t = DateTime.ParseExact(tokens[i + 2]' "yyyy-MM-dd-HH:mm:ss"' null);                          }                          catch (FormatException)                          {                              try                              {                                  t = DateTime.ParseExact(tokens[i + 2]' "yyyy/MM/dd-HH:mm:ss"' null);                              }                              catch (FormatException)                              {                                  try                                  {                                      t = DateTime.ParseExact(tokens[i + 2]' "yyyy/MM/dd"' null);                                  }                                  catch (FormatException)                                  {                                      try                                      {                                          t = DateTime.ParseExact(tokens[i + 2]' "MM/dd/yyyy"' null);                                      }                                      catch (FormatException)                                      {                                          t = DateTime.ParseExact(tokens[i + 2]' "yyyy-MM-dd"' null);                                      }                                  }                              }                          }                          t= DateTime.SpecifyKind(t' DateTimeKind.Local).ToUniversalTime();                          current = new TimeCriterion                          {                              Which = (WhichTime)Enum.Parse(typeof(WhichTime)' tokens[i]' true)'                              Operator = (ComparisonOperator)EnumUtil.Parse(typeof(ComparisonOperator)' tokens[i + 1])'                              Time = t                          };                          i += 2;                          stateStack.Push(ParseState.CriterionDone);                          break;                          case "length":                      case "size":                          if (tokens.Length <= i + 2)                              throw new ArgumentException(String.Join(" "' tokens' i' tokens.Length - i));                            Int64 sz = 0;                          string v = tokens[i + 2];                          if (v.ToUpper().EndsWith("K"))                              sz = Int64.Parse(v.Substring(0' v.Length - 1)) * 1024;                          else if (v.ToUpper().EndsWith("KB"))                              sz = Int64.Parse(v.Substring(0' v.Length - 2)) * 1024;                          else if (v.ToUpper().EndsWith("M"))                              sz = Int64.Parse(v.Substring(0' v.Length - 1)) * 1024 * 1024;                          else if (v.ToUpper().EndsWith("MB"))                              sz = Int64.Parse(v.Substring(0' v.Length - 2)) * 1024 * 1024;                          else if (v.ToUpper().EndsWith("G"))                              sz = Int64.Parse(v.Substring(0' v.Length - 1)) * 1024 * 1024 * 1024;                          else if (v.ToUpper().EndsWith("GB"))                              sz = Int64.Parse(v.Substring(0' v.Length - 2)) * 1024 * 1024 * 1024;                          else sz = Int64.Parse(tokens[i + 2]);                            current = new SizeCriterion                          {                              Size = sz'                              Operator = (ComparisonOperator)EnumUtil.Parse(typeof(ComparisonOperator)' tokens[i + 1])                          };                          i += 2;                          stateStack.Push(ParseState.CriterionDone);                          break;                        case "filename":                      case "name":                          {                              if (tokens.Length <= i + 2)                                  throw new ArgumentException(String.Join(" "' tokens' i' tokens.Length - i));                                ComparisonOperator c =                                  (ComparisonOperator)EnumUtil.Parse(typeof(ComparisonOperator)' tokens[i + 1]);                                if (c != ComparisonOperator.NotEqualTo && c != ComparisonOperator.EqualTo)                                  throw new ArgumentException(String.Join(" "' tokens' i' tokens.Length - i));                                string m = tokens[i + 2];                                // handle single-quoted filespecs (used to include                              // spaces in filename patterns)                              if (m.StartsWith("'") && m.EndsWith("'"))                              {                                  // trim off leading and trailing single quotes and                                  // revert the control characters to spaces.                                  m = m.Substring(1' m.Length - 2)                                      .Replace("\u0006"' " ");                              }                                // if (m.StartsWith("'"))                              //     m = m.Replace("\u0006"' " ");                                //Fix for Unix -> NormalizeCriteriaExpression replaces all slashes with backslashes                              if (Path.DirectorySeparatorChar == '/')                                  m = m.Replace('\\'' Path.DirectorySeparatorChar);                                current = new NameCriterion                              {                                  MatchingFileSpec = m'                                  Operator = c                              };                              i += 2;                              stateStack.Push(ParseState.CriterionDone);                          }                          break;                        case "attrs":                      case "attributes":                      case "type":                          {                              if (tokens.Length <= i + 2)                                  throw new ArgumentException(String.Join(" "' tokens' i' tokens.Length - i));                                ComparisonOperator c =                                  (ComparisonOperator)EnumUtil.Parse(typeof(ComparisonOperator)' tokens[i + 1]);                                if (c != ComparisonOperator.NotEqualTo && c != ComparisonOperator.EqualTo)                                  throw new ArgumentException(String.Join(" "' tokens' i' tokens.Length - i));                                current = (tok1 == "type")                                  ? (SelectionCriterion) new TypeCriterion                                      {                                          AttributeString = tokens[i + 2]'                                          Operator = c                                      }                                  : (SelectionCriterion) new AttributesCriterion                                      {                                          AttributeString = tokens[i + 2]'                                          Operator = c                                      };                              i += 2;                              stateStack.Push(ParseState.CriterionDone);                          }                          break;                        case "":                          // NOP                          stateStack.Push(ParseState.Whitespace);                          break;                        default:                          throw new ArgumentException("'" + tokens[i] + "'");                  }
Magic Number,Ionic,FileSelector,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\FileSelector.cs,_ParseCriterion,The following statement contains a magic number: switch (tok1)                  {                      case "and":                      case "xor":                      case "or":                          state = stateStack.Peek();                          if (state != ParseState.CriterionDone)                              throw new ArgumentException(String.Join(" "' tokens' i' tokens.Length - i));                            if (tokens.Length <= i + 3)                              throw new ArgumentException(String.Join(" "' tokens' i' tokens.Length - i));                            pendingConjunction = (LogicalConjunction)Enum.Parse(typeof(LogicalConjunction)' tokens[i].ToUpper()' true);                          current = new CompoundCriterion { Left = current' Right = null' Conjunction = pendingConjunction };                          stateStack.Push(state);                          stateStack.Push(ParseState.ConjunctionPending);                          critStack.Push(current);                          break;                        case "(":                          state = stateStack.Peek();                          if (state != ParseState.Start && state != ParseState.ConjunctionPending && state != ParseState.OpenParen)                              throw new ArgumentException(String.Join(" "' tokens' i' tokens.Length - i));                            if (tokens.Length <= i + 4)                              throw new ArgumentException(String.Join(" "' tokens' i' tokens.Length - i));                            stateStack.Push(ParseState.OpenParen);                          break;                        case ")":                          state = stateStack.Pop();                          if (stateStack.Peek() != ParseState.OpenParen)                              throw new ArgumentException(String.Join(" "' tokens' i' tokens.Length - i));                            stateStack.Pop();                          stateStack.Push(ParseState.CriterionDone);                          break;                        case "atime":                      case "ctime":                      case "mtime":                          if (tokens.Length <= i + 2)                              throw new ArgumentException(String.Join(" "' tokens' i' tokens.Length - i));                            DateTime t;                          try                          {                              t = DateTime.ParseExact(tokens[i + 2]' "yyyy-MM-dd-HH:mm:ss"' null);                          }                          catch (FormatException)                          {                              try                              {                                  t = DateTime.ParseExact(tokens[i + 2]' "yyyy/MM/dd-HH:mm:ss"' null);                              }                              catch (FormatException)                              {                                  try                                  {                                      t = DateTime.ParseExact(tokens[i + 2]' "yyyy/MM/dd"' null);                                  }                                  catch (FormatException)                                  {                                      try                                      {                                          t = DateTime.ParseExact(tokens[i + 2]' "MM/dd/yyyy"' null);                                      }                                      catch (FormatException)                                      {                                          t = DateTime.ParseExact(tokens[i + 2]' "yyyy-MM-dd"' null);                                      }                                  }                              }                          }                          t= DateTime.SpecifyKind(t' DateTimeKind.Local).ToUniversalTime();                          current = new TimeCriterion                          {                              Which = (WhichTime)Enum.Parse(typeof(WhichTime)' tokens[i]' true)'                              Operator = (ComparisonOperator)EnumUtil.Parse(typeof(ComparisonOperator)' tokens[i + 1])'                              Time = t                          };                          i += 2;                          stateStack.Push(ParseState.CriterionDone);                          break;                          case "length":                      case "size":                          if (tokens.Length <= i + 2)                              throw new ArgumentException(String.Join(" "' tokens' i' tokens.Length - i));                            Int64 sz = 0;                          string v = tokens[i + 2];                          if (v.ToUpper().EndsWith("K"))                              sz = Int64.Parse(v.Substring(0' v.Length - 1)) * 1024;                          else if (v.ToUpper().EndsWith("KB"))                              sz = Int64.Parse(v.Substring(0' v.Length - 2)) * 1024;                          else if (v.ToUpper().EndsWith("M"))                              sz = Int64.Parse(v.Substring(0' v.Length - 1)) * 1024 * 1024;                          else if (v.ToUpper().EndsWith("MB"))                              sz = Int64.Parse(v.Substring(0' v.Length - 2)) * 1024 * 1024;                          else if (v.ToUpper().EndsWith("G"))                              sz = Int64.Parse(v.Substring(0' v.Length - 1)) * 1024 * 1024 * 1024;                          else if (v.ToUpper().EndsWith("GB"))                              sz = Int64.Parse(v.Substring(0' v.Length - 2)) * 1024 * 1024 * 1024;                          else sz = Int64.Parse(tokens[i + 2]);                            current = new SizeCriterion                          {                              Size = sz'                              Operator = (ComparisonOperator)EnumUtil.Parse(typeof(ComparisonOperator)' tokens[i + 1])                          };                          i += 2;                          stateStack.Push(ParseState.CriterionDone);                          break;                        case "filename":                      case "name":                          {                              if (tokens.Length <= i + 2)                                  throw new ArgumentException(String.Join(" "' tokens' i' tokens.Length - i));                                ComparisonOperator c =                                  (ComparisonOperator)EnumUtil.Parse(typeof(ComparisonOperator)' tokens[i + 1]);                                if (c != ComparisonOperator.NotEqualTo && c != ComparisonOperator.EqualTo)                                  throw new ArgumentException(String.Join(" "' tokens' i' tokens.Length - i));                                string m = tokens[i + 2];                                // handle single-quoted filespecs (used to include                              // spaces in filename patterns)                              if (m.StartsWith("'") && m.EndsWith("'"))                              {                                  // trim off leading and trailing single quotes and                                  // revert the control characters to spaces.                                  m = m.Substring(1' m.Length - 2)                                      .Replace("\u0006"' " ");                              }                                // if (m.StartsWith("'"))                              //     m = m.Replace("\u0006"' " ");                                //Fix for Unix -> NormalizeCriteriaExpression replaces all slashes with backslashes                              if (Path.DirectorySeparatorChar == '/')                                  m = m.Replace('\\'' Path.DirectorySeparatorChar);                                current = new NameCriterion                              {                                  MatchingFileSpec = m'                                  Operator = c                              };                              i += 2;                              stateStack.Push(ParseState.CriterionDone);                          }                          break;                        case "attrs":                      case "attributes":                      case "type":                          {                              if (tokens.Length <= i + 2)                                  throw new ArgumentException(String.Join(" "' tokens' i' tokens.Length - i));                                ComparisonOperator c =                                  (ComparisonOperator)EnumUtil.Parse(typeof(ComparisonOperator)' tokens[i + 1]);                                if (c != ComparisonOperator.NotEqualTo && c != ComparisonOperator.EqualTo)                                  throw new ArgumentException(String.Join(" "' tokens' i' tokens.Length - i));                                current = (tok1 == "type")                                  ? (SelectionCriterion) new TypeCriterion                                      {                                          AttributeString = tokens[i + 2]'                                          Operator = c                                      }                                  : (SelectionCriterion) new AttributesCriterion                                      {                                          AttributeString = tokens[i + 2]'                                          Operator = c                                      };                              i += 2;                              stateStack.Push(ParseState.CriterionDone);                          }                          break;                        case "":                          // NOP                          stateStack.Push(ParseState.Whitespace);                          break;                        default:                          throw new ArgumentException("'" + tokens[i] + "'");                  }
Magic Number,Ionic,FileSelector,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\FileSelector.cs,_ParseCriterion,The following statement contains a magic number: switch (tok1)                  {                      case "and":                      case "xor":                      case "or":                          state = stateStack.Peek();                          if (state != ParseState.CriterionDone)                              throw new ArgumentException(String.Join(" "' tokens' i' tokens.Length - i));                            if (tokens.Length <= i + 3)                              throw new ArgumentException(String.Join(" "' tokens' i' tokens.Length - i));                            pendingConjunction = (LogicalConjunction)Enum.Parse(typeof(LogicalConjunction)' tokens[i].ToUpper()' true);                          current = new CompoundCriterion { Left = current' Right = null' Conjunction = pendingConjunction };                          stateStack.Push(state);                          stateStack.Push(ParseState.ConjunctionPending);                          critStack.Push(current);                          break;                        case "(":                          state = stateStack.Peek();                          if (state != ParseState.Start && state != ParseState.ConjunctionPending && state != ParseState.OpenParen)                              throw new ArgumentException(String.Join(" "' tokens' i' tokens.Length - i));                            if (tokens.Length <= i + 4)                              throw new ArgumentException(String.Join(" "' tokens' i' tokens.Length - i));                            stateStack.Push(ParseState.OpenParen);                          break;                        case ")":                          state = stateStack.Pop();                          if (stateStack.Peek() != ParseState.OpenParen)                              throw new ArgumentException(String.Join(" "' tokens' i' tokens.Length - i));                            stateStack.Pop();                          stateStack.Push(ParseState.CriterionDone);                          break;                        case "atime":                      case "ctime":                      case "mtime":                          if (tokens.Length <= i + 2)                              throw new ArgumentException(String.Join(" "' tokens' i' tokens.Length - i));                            DateTime t;                          try                          {                              t = DateTime.ParseExact(tokens[i + 2]' "yyyy-MM-dd-HH:mm:ss"' null);                          }                          catch (FormatException)                          {                              try                              {                                  t = DateTime.ParseExact(tokens[i + 2]' "yyyy/MM/dd-HH:mm:ss"' null);                              }                              catch (FormatException)                              {                                  try                                  {                                      t = DateTime.ParseExact(tokens[i + 2]' "yyyy/MM/dd"' null);                                  }                                  catch (FormatException)                                  {                                      try                                      {                                          t = DateTime.ParseExact(tokens[i + 2]' "MM/dd/yyyy"' null);                                      }                                      catch (FormatException)                                      {                                          t = DateTime.ParseExact(tokens[i + 2]' "yyyy-MM-dd"' null);                                      }                                  }                              }                          }                          t= DateTime.SpecifyKind(t' DateTimeKind.Local).ToUniversalTime();                          current = new TimeCriterion                          {                              Which = (WhichTime)Enum.Parse(typeof(WhichTime)' tokens[i]' true)'                              Operator = (ComparisonOperator)EnumUtil.Parse(typeof(ComparisonOperator)' tokens[i + 1])'                              Time = t                          };                          i += 2;                          stateStack.Push(ParseState.CriterionDone);                          break;                          case "length":                      case "size":                          if (tokens.Length <= i + 2)                              throw new ArgumentException(String.Join(" "' tokens' i' tokens.Length - i));                            Int64 sz = 0;                          string v = tokens[i + 2];                          if (v.ToUpper().EndsWith("K"))                              sz = Int64.Parse(v.Substring(0' v.Length - 1)) * 1024;                          else if (v.ToUpper().EndsWith("KB"))                              sz = Int64.Parse(v.Substring(0' v.Length - 2)) * 1024;                          else if (v.ToUpper().EndsWith("M"))                              sz = Int64.Parse(v.Substring(0' v.Length - 1)) * 1024 * 1024;                          else if (v.ToUpper().EndsWith("MB"))                              sz = Int64.Parse(v.Substring(0' v.Length - 2)) * 1024 * 1024;                          else if (v.ToUpper().EndsWith("G"))                              sz = Int64.Parse(v.Substring(0' v.Length - 1)) * 1024 * 1024 * 1024;                          else if (v.ToUpper().EndsWith("GB"))                              sz = Int64.Parse(v.Substring(0' v.Length - 2)) * 1024 * 1024 * 1024;                          else sz = Int64.Parse(tokens[i + 2]);                            current = new SizeCriterion                          {                              Size = sz'                              Operator = (ComparisonOperator)EnumUtil.Parse(typeof(ComparisonOperator)' tokens[i + 1])                          };                          i += 2;                          stateStack.Push(ParseState.CriterionDone);                          break;                        case "filename":                      case "name":                          {                              if (tokens.Length <= i + 2)                                  throw new ArgumentException(String.Join(" "' tokens' i' tokens.Length - i));                                ComparisonOperator c =                                  (ComparisonOperator)EnumUtil.Parse(typeof(ComparisonOperator)' tokens[i + 1]);                                if (c != ComparisonOperator.NotEqualTo && c != ComparisonOperator.EqualTo)                                  throw new ArgumentException(String.Join(" "' tokens' i' tokens.Length - i));                                string m = tokens[i + 2];                                // handle single-quoted filespecs (used to include                              // spaces in filename patterns)                              if (m.StartsWith("'") && m.EndsWith("'"))                              {                                  // trim off leading and trailing single quotes and                                  // revert the control characters to spaces.                                  m = m.Substring(1' m.Length - 2)                                      .Replace("\u0006"' " ");                              }                                // if (m.StartsWith("'"))                              //     m = m.Replace("\u0006"' " ");                                //Fix for Unix -> NormalizeCriteriaExpression replaces all slashes with backslashes                              if (Path.DirectorySeparatorChar == '/')                                  m = m.Replace('\\'' Path.DirectorySeparatorChar);                                current = new NameCriterion                              {                                  MatchingFileSpec = m'                                  Operator = c                              };                              i += 2;                              stateStack.Push(ParseState.CriterionDone);                          }                          break;                        case "attrs":                      case "attributes":                      case "type":                          {                              if (tokens.Length <= i + 2)                                  throw new ArgumentException(String.Join(" "' tokens' i' tokens.Length - i));                                ComparisonOperator c =                                  (ComparisonOperator)EnumUtil.Parse(typeof(ComparisonOperator)' tokens[i + 1]);                                if (c != ComparisonOperator.NotEqualTo && c != ComparisonOperator.EqualTo)                                  throw new ArgumentException(String.Join(" "' tokens' i' tokens.Length - i));                                current = (tok1 == "type")                                  ? (SelectionCriterion) new TypeCriterion                                      {                                          AttributeString = tokens[i + 2]'                                          Operator = c                                      }                                  : (SelectionCriterion) new AttributesCriterion                                      {                                          AttributeString = tokens[i + 2]'                                          Operator = c                                      };                              i += 2;                              stateStack.Push(ParseState.CriterionDone);                          }                          break;                        case "":                          // NOP                          stateStack.Push(ParseState.Whitespace);                          break;                        default:                          throw new ArgumentException("'" + tokens[i] + "'");                  }
Magic Number,Ionic,FileSelector,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\FileSelector.cs,_ParseCriterion,The following statement contains a magic number: switch (tok1)                  {                      case "and":                      case "xor":                      case "or":                          state = stateStack.Peek();                          if (state != ParseState.CriterionDone)                              throw new ArgumentException(String.Join(" "' tokens' i' tokens.Length - i));                            if (tokens.Length <= i + 3)                              throw new ArgumentException(String.Join(" "' tokens' i' tokens.Length - i));                            pendingConjunction = (LogicalConjunction)Enum.Parse(typeof(LogicalConjunction)' tokens[i].ToUpper()' true);                          current = new CompoundCriterion { Left = current' Right = null' Conjunction = pendingConjunction };                          stateStack.Push(state);                          stateStack.Push(ParseState.ConjunctionPending);                          critStack.Push(current);                          break;                        case "(":                          state = stateStack.Peek();                          if (state != ParseState.Start && state != ParseState.ConjunctionPending && state != ParseState.OpenParen)                              throw new ArgumentException(String.Join(" "' tokens' i' tokens.Length - i));                            if (tokens.Length <= i + 4)                              throw new ArgumentException(String.Join(" "' tokens' i' tokens.Length - i));                            stateStack.Push(ParseState.OpenParen);                          break;                        case ")":                          state = stateStack.Pop();                          if (stateStack.Peek() != ParseState.OpenParen)                              throw new ArgumentException(String.Join(" "' tokens' i' tokens.Length - i));                            stateStack.Pop();                          stateStack.Push(ParseState.CriterionDone);                          break;                        case "atime":                      case "ctime":                      case "mtime":                          if (tokens.Length <= i + 2)                              throw new ArgumentException(String.Join(" "' tokens' i' tokens.Length - i));                            DateTime t;                          try                          {                              t = DateTime.ParseExact(tokens[i + 2]' "yyyy-MM-dd-HH:mm:ss"' null);                          }                          catch (FormatException)                          {                              try                              {                                  t = DateTime.ParseExact(tokens[i + 2]' "yyyy/MM/dd-HH:mm:ss"' null);                              }                              catch (FormatException)                              {                                  try                                  {                                      t = DateTime.ParseExact(tokens[i + 2]' "yyyy/MM/dd"' null);                                  }                                  catch (FormatException)                                  {                                      try                                      {                                          t = DateTime.ParseExact(tokens[i + 2]' "MM/dd/yyyy"' null);                                      }                                      catch (FormatException)                                      {                                          t = DateTime.ParseExact(tokens[i + 2]' "yyyy-MM-dd"' null);                                      }                                  }                              }                          }                          t= DateTime.SpecifyKind(t' DateTimeKind.Local).ToUniversalTime();                          current = new TimeCriterion                          {                              Which = (WhichTime)Enum.Parse(typeof(WhichTime)' tokens[i]' true)'                              Operator = (ComparisonOperator)EnumUtil.Parse(typeof(ComparisonOperator)' tokens[i + 1])'                              Time = t                          };                          i += 2;                          stateStack.Push(ParseState.CriterionDone);                          break;                          case "length":                      case "size":                          if (tokens.Length <= i + 2)                              throw new ArgumentException(String.Join(" "' tokens' i' tokens.Length - i));                            Int64 sz = 0;                          string v = tokens[i + 2];                          if (v.ToUpper().EndsWith("K"))                              sz = Int64.Parse(v.Substring(0' v.Length - 1)) * 1024;                          else if (v.ToUpper().EndsWith("KB"))                              sz = Int64.Parse(v.Substring(0' v.Length - 2)) * 1024;                          else if (v.ToUpper().EndsWith("M"))                              sz = Int64.Parse(v.Substring(0' v.Length - 1)) * 1024 * 1024;                          else if (v.ToUpper().EndsWith("MB"))                              sz = Int64.Parse(v.Substring(0' v.Length - 2)) * 1024 * 1024;                          else if (v.ToUpper().EndsWith("G"))                              sz = Int64.Parse(v.Substring(0' v.Length - 1)) * 1024 * 1024 * 1024;                          else if (v.ToUpper().EndsWith("GB"))                              sz = Int64.Parse(v.Substring(0' v.Length - 2)) * 1024 * 1024 * 1024;                          else sz = Int64.Parse(tokens[i + 2]);                            current = new SizeCriterion                          {                              Size = sz'                              Operator = (ComparisonOperator)EnumUtil.Parse(typeof(ComparisonOperator)' tokens[i + 1])                          };                          i += 2;                          stateStack.Push(ParseState.CriterionDone);                          break;                        case "filename":                      case "name":                          {                              if (tokens.Length <= i + 2)                                  throw new ArgumentException(String.Join(" "' tokens' i' tokens.Length - i));                                ComparisonOperator c =                                  (ComparisonOperator)EnumUtil.Parse(typeof(ComparisonOperator)' tokens[i + 1]);                                if (c != ComparisonOperator.NotEqualTo && c != ComparisonOperator.EqualTo)                                  throw new ArgumentException(String.Join(" "' tokens' i' tokens.Length - i));                                string m = tokens[i + 2];                                // handle single-quoted filespecs (used to include                              // spaces in filename patterns)                              if (m.StartsWith("'") && m.EndsWith("'"))                              {                                  // trim off leading and trailing single quotes and                                  // revert the control characters to spaces.                                  m = m.Substring(1' m.Length - 2)                                      .Replace("\u0006"' " ");                              }                                // if (m.StartsWith("'"))                              //     m = m.Replace("\u0006"' " ");                                //Fix for Unix -> NormalizeCriteriaExpression replaces all slashes with backslashes                              if (Path.DirectorySeparatorChar == '/')                                  m = m.Replace('\\'' Path.DirectorySeparatorChar);                                current = new NameCriterion                              {                                  MatchingFileSpec = m'                                  Operator = c                              };                              i += 2;                              stateStack.Push(ParseState.CriterionDone);                          }                          break;                        case "attrs":                      case "attributes":                      case "type":                          {                              if (tokens.Length <= i + 2)                                  throw new ArgumentException(String.Join(" "' tokens' i' tokens.Length - i));                                ComparisonOperator c =                                  (ComparisonOperator)EnumUtil.Parse(typeof(ComparisonOperator)' tokens[i + 1]);                                if (c != ComparisonOperator.NotEqualTo && c != ComparisonOperator.EqualTo)                                  throw new ArgumentException(String.Join(" "' tokens' i' tokens.Length - i));                                current = (tok1 == "type")                                  ? (SelectionCriterion) new TypeCriterion                                      {                                          AttributeString = tokens[i + 2]'                                          Operator = c                                      }                                  : (SelectionCriterion) new AttributesCriterion                                      {                                          AttributeString = tokens[i + 2]'                                          Operator = c                                      };                              i += 2;                              stateStack.Push(ParseState.CriterionDone);                          }                          break;                        case "":                          // NOP                          stateStack.Push(ParseState.Whitespace);                          break;                        default:                          throw new ArgumentException("'" + tokens[i] + "'");                  }
Magic Number,Ionic,FileSelector,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\FileSelector.cs,_ParseCriterion,The following statement contains a magic number: switch (tok1)                  {                      case "and":                      case "xor":                      case "or":                          state = stateStack.Peek();                          if (state != ParseState.CriterionDone)                              throw new ArgumentException(String.Join(" "' tokens' i' tokens.Length - i));                            if (tokens.Length <= i + 3)                              throw new ArgumentException(String.Join(" "' tokens' i' tokens.Length - i));                            pendingConjunction = (LogicalConjunction)Enum.Parse(typeof(LogicalConjunction)' tokens[i].ToUpper()' true);                          current = new CompoundCriterion { Left = current' Right = null' Conjunction = pendingConjunction };                          stateStack.Push(state);                          stateStack.Push(ParseState.ConjunctionPending);                          critStack.Push(current);                          break;                        case "(":                          state = stateStack.Peek();                          if (state != ParseState.Start && state != ParseState.ConjunctionPending && state != ParseState.OpenParen)                              throw new ArgumentException(String.Join(" "' tokens' i' tokens.Length - i));                            if (tokens.Length <= i + 4)                              throw new ArgumentException(String.Join(" "' tokens' i' tokens.Length - i));                            stateStack.Push(ParseState.OpenParen);                          break;                        case ")":                          state = stateStack.Pop();                          if (stateStack.Peek() != ParseState.OpenParen)                              throw new ArgumentException(String.Join(" "' tokens' i' tokens.Length - i));                            stateStack.Pop();                          stateStack.Push(ParseState.CriterionDone);                          break;                        case "atime":                      case "ctime":                      case "mtime":                          if (tokens.Length <= i + 2)                              throw new ArgumentException(String.Join(" "' tokens' i' tokens.Length - i));                            DateTime t;                          try                          {                              t = DateTime.ParseExact(tokens[i + 2]' "yyyy-MM-dd-HH:mm:ss"' null);                          }                          catch (FormatException)                          {                              try                              {                                  t = DateTime.ParseExact(tokens[i + 2]' "yyyy/MM/dd-HH:mm:ss"' null);                              }                              catch (FormatException)                              {                                  try                                  {                                      t = DateTime.ParseExact(tokens[i + 2]' "yyyy/MM/dd"' null);                                  }                                  catch (FormatException)                                  {                                      try                                      {                                          t = DateTime.ParseExact(tokens[i + 2]' "MM/dd/yyyy"' null);                                      }                                      catch (FormatException)                                      {                                          t = DateTime.ParseExact(tokens[i + 2]' "yyyy-MM-dd"' null);                                      }                                  }                              }                          }                          t= DateTime.SpecifyKind(t' DateTimeKind.Local).ToUniversalTime();                          current = new TimeCriterion                          {                              Which = (WhichTime)Enum.Parse(typeof(WhichTime)' tokens[i]' true)'                              Operator = (ComparisonOperator)EnumUtil.Parse(typeof(ComparisonOperator)' tokens[i + 1])'                              Time = t                          };                          i += 2;                          stateStack.Push(ParseState.CriterionDone);                          break;                          case "length":                      case "size":                          if (tokens.Length <= i + 2)                              throw new ArgumentException(String.Join(" "' tokens' i' tokens.Length - i));                            Int64 sz = 0;                          string v = tokens[i + 2];                          if (v.ToUpper().EndsWith("K"))                              sz = Int64.Parse(v.Substring(0' v.Length - 1)) * 1024;                          else if (v.ToUpper().EndsWith("KB"))                              sz = Int64.Parse(v.Substring(0' v.Length - 2)) * 1024;                          else if (v.ToUpper().EndsWith("M"))                              sz = Int64.Parse(v.Substring(0' v.Length - 1)) * 1024 * 1024;                          else if (v.ToUpper().EndsWith("MB"))                              sz = Int64.Parse(v.Substring(0' v.Length - 2)) * 1024 * 1024;                          else if (v.ToUpper().EndsWith("G"))                              sz = Int64.Parse(v.Substring(0' v.Length - 1)) * 1024 * 1024 * 1024;                          else if (v.ToUpper().EndsWith("GB"))                              sz = Int64.Parse(v.Substring(0' v.Length - 2)) * 1024 * 1024 * 1024;                          else sz = Int64.Parse(tokens[i + 2]);                            current = new SizeCriterion                          {                              Size = sz'                              Operator = (ComparisonOperator)EnumUtil.Parse(typeof(ComparisonOperator)' tokens[i + 1])                          };                          i += 2;                          stateStack.Push(ParseState.CriterionDone);                          break;                        case "filename":                      case "name":                          {                              if (tokens.Length <= i + 2)                                  throw new ArgumentException(String.Join(" "' tokens' i' tokens.Length - i));                                ComparisonOperator c =                                  (ComparisonOperator)EnumUtil.Parse(typeof(ComparisonOperator)' tokens[i + 1]);                                if (c != ComparisonOperator.NotEqualTo && c != ComparisonOperator.EqualTo)                                  throw new ArgumentException(String.Join(" "' tokens' i' tokens.Length - i));                                string m = tokens[i + 2];                                // handle single-quoted filespecs (used to include                              // spaces in filename patterns)                              if (m.StartsWith("'") && m.EndsWith("'"))                              {                                  // trim off leading and trailing single quotes and                                  // revert the control characters to spaces.                                  m = m.Substring(1' m.Length - 2)                                      .Replace("\u0006"' " ");                              }                                // if (m.StartsWith("'"))                              //     m = m.Replace("\u0006"' " ");                                //Fix for Unix -> NormalizeCriteriaExpression replaces all slashes with backslashes                              if (Path.DirectorySeparatorChar == '/')                                  m = m.Replace('\\'' Path.DirectorySeparatorChar);                                current = new NameCriterion                              {                                  MatchingFileSpec = m'                                  Operator = c                              };                              i += 2;                              stateStack.Push(ParseState.CriterionDone);                          }                          break;                        case "attrs":                      case "attributes":                      case "type":                          {                              if (tokens.Length <= i + 2)                                  throw new ArgumentException(String.Join(" "' tokens' i' tokens.Length - i));                                ComparisonOperator c =                                  (ComparisonOperator)EnumUtil.Parse(typeof(ComparisonOperator)' tokens[i + 1]);                                if (c != ComparisonOperator.NotEqualTo && c != ComparisonOperator.EqualTo)                                  throw new ArgumentException(String.Join(" "' tokens' i' tokens.Length - i));                                current = (tok1 == "type")                                  ? (SelectionCriterion) new TypeCriterion                                      {                                          AttributeString = tokens[i + 2]'                                          Operator = c                                      }                                  : (SelectionCriterion) new AttributesCriterion                                      {                                          AttributeString = tokens[i + 2]'                                          Operator = c                                      };                              i += 2;                              stateStack.Push(ParseState.CriterionDone);                          }                          break;                        case "":                          // NOP                          stateStack.Push(ParseState.Whitespace);                          break;                        default:                          throw new ArgumentException("'" + tokens[i] + "'");                  }
Magic Number,Ionic,FileSelector,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\FileSelector.cs,_ParseCriterion,The following statement contains a magic number: switch (tok1)                  {                      case "and":                      case "xor":                      case "or":                          state = stateStack.Peek();                          if (state != ParseState.CriterionDone)                              throw new ArgumentException(String.Join(" "' tokens' i' tokens.Length - i));                            if (tokens.Length <= i + 3)                              throw new ArgumentException(String.Join(" "' tokens' i' tokens.Length - i));                            pendingConjunction = (LogicalConjunction)Enum.Parse(typeof(LogicalConjunction)' tokens[i].ToUpper()' true);                          current = new CompoundCriterion { Left = current' Right = null' Conjunction = pendingConjunction };                          stateStack.Push(state);                          stateStack.Push(ParseState.ConjunctionPending);                          critStack.Push(current);                          break;                        case "(":                          state = stateStack.Peek();                          if (state != ParseState.Start && state != ParseState.ConjunctionPending && state != ParseState.OpenParen)                              throw new ArgumentException(String.Join(" "' tokens' i' tokens.Length - i));                            if (tokens.Length <= i + 4)                              throw new ArgumentException(String.Join(" "' tokens' i' tokens.Length - i));                            stateStack.Push(ParseState.OpenParen);                          break;                        case ")":                          state = stateStack.Pop();                          if (stateStack.Peek() != ParseState.OpenParen)                              throw new ArgumentException(String.Join(" "' tokens' i' tokens.Length - i));                            stateStack.Pop();                          stateStack.Push(ParseState.CriterionDone);                          break;                        case "atime":                      case "ctime":                      case "mtime":                          if (tokens.Length <= i + 2)                              throw new ArgumentException(String.Join(" "' tokens' i' tokens.Length - i));                            DateTime t;                          try                          {                              t = DateTime.ParseExact(tokens[i + 2]' "yyyy-MM-dd-HH:mm:ss"' null);                          }                          catch (FormatException)                          {                              try                              {                                  t = DateTime.ParseExact(tokens[i + 2]' "yyyy/MM/dd-HH:mm:ss"' null);                              }                              catch (FormatException)                              {                                  try                                  {                                      t = DateTime.ParseExact(tokens[i + 2]' "yyyy/MM/dd"' null);                                  }                                  catch (FormatException)                                  {                                      try                                      {                                          t = DateTime.ParseExact(tokens[i + 2]' "MM/dd/yyyy"' null);                                      }                                      catch (FormatException)                                      {                                          t = DateTime.ParseExact(tokens[i + 2]' "yyyy-MM-dd"' null);                                      }                                  }                              }                          }                          t= DateTime.SpecifyKind(t' DateTimeKind.Local).ToUniversalTime();                          current = new TimeCriterion                          {                              Which = (WhichTime)Enum.Parse(typeof(WhichTime)' tokens[i]' true)'                              Operator = (ComparisonOperator)EnumUtil.Parse(typeof(ComparisonOperator)' tokens[i + 1])'                              Time = t                          };                          i += 2;                          stateStack.Push(ParseState.CriterionDone);                          break;                          case "length":                      case "size":                          if (tokens.Length <= i + 2)                              throw new ArgumentException(String.Join(" "' tokens' i' tokens.Length - i));                            Int64 sz = 0;                          string v = tokens[i + 2];                          if (v.ToUpper().EndsWith("K"))                              sz = Int64.Parse(v.Substring(0' v.Length - 1)) * 1024;                          else if (v.ToUpper().EndsWith("KB"))                              sz = Int64.Parse(v.Substring(0' v.Length - 2)) * 1024;                          else if (v.ToUpper().EndsWith("M"))                              sz = Int64.Parse(v.Substring(0' v.Length - 1)) * 1024 * 1024;                          else if (v.ToUpper().EndsWith("MB"))                              sz = Int64.Parse(v.Substring(0' v.Length - 2)) * 1024 * 1024;                          else if (v.ToUpper().EndsWith("G"))                              sz = Int64.Parse(v.Substring(0' v.Length - 1)) * 1024 * 1024 * 1024;                          else if (v.ToUpper().EndsWith("GB"))                              sz = Int64.Parse(v.Substring(0' v.Length - 2)) * 1024 * 1024 * 1024;                          else sz = Int64.Parse(tokens[i + 2]);                            current = new SizeCriterion                          {                              Size = sz'                              Operator = (ComparisonOperator)EnumUtil.Parse(typeof(ComparisonOperator)' tokens[i + 1])                          };                          i += 2;                          stateStack.Push(ParseState.CriterionDone);                          break;                        case "filename":                      case "name":                          {                              if (tokens.Length <= i + 2)                                  throw new ArgumentException(String.Join(" "' tokens' i' tokens.Length - i));                                ComparisonOperator c =                                  (ComparisonOperator)EnumUtil.Parse(typeof(ComparisonOperator)' tokens[i + 1]);                                if (c != ComparisonOperator.NotEqualTo && c != ComparisonOperator.EqualTo)                                  throw new ArgumentException(String.Join(" "' tokens' i' tokens.Length - i));                                string m = tokens[i + 2];                                // handle single-quoted filespecs (used to include                              // spaces in filename patterns)                              if (m.StartsWith("'") && m.EndsWith("'"))                              {                                  // trim off leading and trailing single quotes and                                  // revert the control characters to spaces.                                  m = m.Substring(1' m.Length - 2)                                      .Replace("\u0006"' " ");                              }                                // if (m.StartsWith("'"))                              //     m = m.Replace("\u0006"' " ");                                //Fix for Unix -> NormalizeCriteriaExpression replaces all slashes with backslashes                              if (Path.DirectorySeparatorChar == '/')                                  m = m.Replace('\\'' Path.DirectorySeparatorChar);                                current = new NameCriterion                              {                                  MatchingFileSpec = m'                                  Operator = c                              };                              i += 2;                              stateStack.Push(ParseState.CriterionDone);                          }                          break;                        case "attrs":                      case "attributes":                      case "type":                          {                              if (tokens.Length <= i + 2)                                  throw new ArgumentException(String.Join(" "' tokens' i' tokens.Length - i));                                ComparisonOperator c =                                  (ComparisonOperator)EnumUtil.Parse(typeof(ComparisonOperator)' tokens[i + 1]);                                if (c != ComparisonOperator.NotEqualTo && c != ComparisonOperator.EqualTo)                                  throw new ArgumentException(String.Join(" "' tokens' i' tokens.Length - i));                                current = (tok1 == "type")                                  ? (SelectionCriterion) new TypeCriterion                                      {                                          AttributeString = tokens[i + 2]'                                          Operator = c                                      }                                  : (SelectionCriterion) new AttributesCriterion                                      {                                          AttributeString = tokens[i + 2]'                                          Operator = c                                      };                              i += 2;                              stateStack.Push(ParseState.CriterionDone);                          }                          break;                        case "":                          // NOP                          stateStack.Push(ParseState.Whitespace);                          break;                        default:                          throw new ArgumentException("'" + tokens[i] + "'");                  }
Magic Number,Ionic,FileSelector,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\FileSelector.cs,_ParseCriterion,The following statement contains a magic number: switch (tok1)                  {                      case "and":                      case "xor":                      case "or":                          state = stateStack.Peek();                          if (state != ParseState.CriterionDone)                              throw new ArgumentException(String.Join(" "' tokens' i' tokens.Length - i));                            if (tokens.Length <= i + 3)                              throw new ArgumentException(String.Join(" "' tokens' i' tokens.Length - i));                            pendingConjunction = (LogicalConjunction)Enum.Parse(typeof(LogicalConjunction)' tokens[i].ToUpper()' true);                          current = new CompoundCriterion { Left = current' Right = null' Conjunction = pendingConjunction };                          stateStack.Push(state);                          stateStack.Push(ParseState.ConjunctionPending);                          critStack.Push(current);                          break;                        case "(":                          state = stateStack.Peek();                          if (state != ParseState.Start && state != ParseState.ConjunctionPending && state != ParseState.OpenParen)                              throw new ArgumentException(String.Join(" "' tokens' i' tokens.Length - i));                            if (tokens.Length <= i + 4)                              throw new ArgumentException(String.Join(" "' tokens' i' tokens.Length - i));                            stateStack.Push(ParseState.OpenParen);                          break;                        case ")":                          state = stateStack.Pop();                          if (stateStack.Peek() != ParseState.OpenParen)                              throw new ArgumentException(String.Join(" "' tokens' i' tokens.Length - i));                            stateStack.Pop();                          stateStack.Push(ParseState.CriterionDone);                          break;                        case "atime":                      case "ctime":                      case "mtime":                          if (tokens.Length <= i + 2)                              throw new ArgumentException(String.Join(" "' tokens' i' tokens.Length - i));                            DateTime t;                          try                          {                              t = DateTime.ParseExact(tokens[i + 2]' "yyyy-MM-dd-HH:mm:ss"' null);                          }                          catch (FormatException)                          {                              try                              {                                  t = DateTime.ParseExact(tokens[i + 2]' "yyyy/MM/dd-HH:mm:ss"' null);                              }                              catch (FormatException)                              {                                  try                                  {                                      t = DateTime.ParseExact(tokens[i + 2]' "yyyy/MM/dd"' null);                                  }                                  catch (FormatException)                                  {                                      try                                      {                                          t = DateTime.ParseExact(tokens[i + 2]' "MM/dd/yyyy"' null);                                      }                                      catch (FormatException)                                      {                                          t = DateTime.ParseExact(tokens[i + 2]' "yyyy-MM-dd"' null);                                      }                                  }                              }                          }                          t= DateTime.SpecifyKind(t' DateTimeKind.Local).ToUniversalTime();                          current = new TimeCriterion                          {                              Which = (WhichTime)Enum.Parse(typeof(WhichTime)' tokens[i]' true)'                              Operator = (ComparisonOperator)EnumUtil.Parse(typeof(ComparisonOperator)' tokens[i + 1])'                              Time = t                          };                          i += 2;                          stateStack.Push(ParseState.CriterionDone);                          break;                          case "length":                      case "size":                          if (tokens.Length <= i + 2)                              throw new ArgumentException(String.Join(" "' tokens' i' tokens.Length - i));                            Int64 sz = 0;                          string v = tokens[i + 2];                          if (v.ToUpper().EndsWith("K"))                              sz = Int64.Parse(v.Substring(0' v.Length - 1)) * 1024;                          else if (v.ToUpper().EndsWith("KB"))                              sz = Int64.Parse(v.Substring(0' v.Length - 2)) * 1024;                          else if (v.ToUpper().EndsWith("M"))                              sz = Int64.Parse(v.Substring(0' v.Length - 1)) * 1024 * 1024;                          else if (v.ToUpper().EndsWith("MB"))                              sz = Int64.Parse(v.Substring(0' v.Length - 2)) * 1024 * 1024;                          else if (v.ToUpper().EndsWith("G"))                              sz = Int64.Parse(v.Substring(0' v.Length - 1)) * 1024 * 1024 * 1024;                          else if (v.ToUpper().EndsWith("GB"))                              sz = Int64.Parse(v.Substring(0' v.Length - 2)) * 1024 * 1024 * 1024;                          else sz = Int64.Parse(tokens[i + 2]);                            current = new SizeCriterion                          {                              Size = sz'                              Operator = (ComparisonOperator)EnumUtil.Parse(typeof(ComparisonOperator)' tokens[i + 1])                          };                          i += 2;                          stateStack.Push(ParseState.CriterionDone);                          break;                        case "filename":                      case "name":                          {                              if (tokens.Length <= i + 2)                                  throw new ArgumentException(String.Join(" "' tokens' i' tokens.Length - i));                                ComparisonOperator c =                                  (ComparisonOperator)EnumUtil.Parse(typeof(ComparisonOperator)' tokens[i + 1]);                                if (c != ComparisonOperator.NotEqualTo && c != ComparisonOperator.EqualTo)                                  throw new ArgumentException(String.Join(" "' tokens' i' tokens.Length - i));                                string m = tokens[i + 2];                                // handle single-quoted filespecs (used to include                              // spaces in filename patterns)                              if (m.StartsWith("'") && m.EndsWith("'"))                              {                                  // trim off leading and trailing single quotes and                                  // revert the control characters to spaces.                                  m = m.Substring(1' m.Length - 2)                                      .Replace("\u0006"' " ");                              }                                // if (m.StartsWith("'"))                              //     m = m.Replace("\u0006"' " ");                                //Fix for Unix -> NormalizeCriteriaExpression replaces all slashes with backslashes                              if (Path.DirectorySeparatorChar == '/')                                  m = m.Replace('\\'' Path.DirectorySeparatorChar);                                current = new NameCriterion                              {                                  MatchingFileSpec = m'                                  Operator = c                              };                              i += 2;                              stateStack.Push(ParseState.CriterionDone);                          }                          break;                        case "attrs":                      case "attributes":                      case "type":                          {                              if (tokens.Length <= i + 2)                                  throw new ArgumentException(String.Join(" "' tokens' i' tokens.Length - i));                                ComparisonOperator c =                                  (ComparisonOperator)EnumUtil.Parse(typeof(ComparisonOperator)' tokens[i + 1]);                                if (c != ComparisonOperator.NotEqualTo && c != ComparisonOperator.EqualTo)                                  throw new ArgumentException(String.Join(" "' tokens' i' tokens.Length - i));                                current = (tok1 == "type")                                  ? (SelectionCriterion) new TypeCriterion                                      {                                          AttributeString = tokens[i + 2]'                                          Operator = c                                      }                                  : (SelectionCriterion) new AttributesCriterion                                      {                                          AttributeString = tokens[i + 2]'                                          Operator = c                                      };                              i += 2;                              stateStack.Push(ParseState.CriterionDone);                          }                          break;                        case "":                          // NOP                          stateStack.Push(ParseState.Whitespace);                          break;                        default:                          throw new ArgumentException("'" + tokens[i] + "'");                  }
Magic Number,Ionic,FileSelector,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\FileSelector.cs,_ParseCriterion,The following statement contains a magic number: switch (tok1)                  {                      case "and":                      case "xor":                      case "or":                          state = stateStack.Peek();                          if (state != ParseState.CriterionDone)                              throw new ArgumentException(String.Join(" "' tokens' i' tokens.Length - i));                            if (tokens.Length <= i + 3)                              throw new ArgumentException(String.Join(" "' tokens' i' tokens.Length - i));                            pendingConjunction = (LogicalConjunction)Enum.Parse(typeof(LogicalConjunction)' tokens[i].ToUpper()' true);                          current = new CompoundCriterion { Left = current' Right = null' Conjunction = pendingConjunction };                          stateStack.Push(state);                          stateStack.Push(ParseState.ConjunctionPending);                          critStack.Push(current);                          break;                        case "(":                          state = stateStack.Peek();                          if (state != ParseState.Start && state != ParseState.ConjunctionPending && state != ParseState.OpenParen)                              throw new ArgumentException(String.Join(" "' tokens' i' tokens.Length - i));                            if (tokens.Length <= i + 4)                              throw new ArgumentException(String.Join(" "' tokens' i' tokens.Length - i));                            stateStack.Push(ParseState.OpenParen);                          break;                        case ")":                          state = stateStack.Pop();                          if (stateStack.Peek() != ParseState.OpenParen)                              throw new ArgumentException(String.Join(" "' tokens' i' tokens.Length - i));                            stateStack.Pop();                          stateStack.Push(ParseState.CriterionDone);                          break;                        case "atime":                      case "ctime":                      case "mtime":                          if (tokens.Length <= i + 2)                              throw new ArgumentException(String.Join(" "' tokens' i' tokens.Length - i));                            DateTime t;                          try                          {                              t = DateTime.ParseExact(tokens[i + 2]' "yyyy-MM-dd-HH:mm:ss"' null);                          }                          catch (FormatException)                          {                              try                              {                                  t = DateTime.ParseExact(tokens[i + 2]' "yyyy/MM/dd-HH:mm:ss"' null);                              }                              catch (FormatException)                              {                                  try                                  {                                      t = DateTime.ParseExact(tokens[i + 2]' "yyyy/MM/dd"' null);                                  }                                  catch (FormatException)                                  {                                      try                                      {                                          t = DateTime.ParseExact(tokens[i + 2]' "MM/dd/yyyy"' null);                                      }                                      catch (FormatException)                                      {                                          t = DateTime.ParseExact(tokens[i + 2]' "yyyy-MM-dd"' null);                                      }                                  }                              }                          }                          t= DateTime.SpecifyKind(t' DateTimeKind.Local).ToUniversalTime();                          current = new TimeCriterion                          {                              Which = (WhichTime)Enum.Parse(typeof(WhichTime)' tokens[i]' true)'                              Operator = (ComparisonOperator)EnumUtil.Parse(typeof(ComparisonOperator)' tokens[i + 1])'                              Time = t                          };                          i += 2;                          stateStack.Push(ParseState.CriterionDone);                          break;                          case "length":                      case "size":                          if (tokens.Length <= i + 2)                              throw new ArgumentException(String.Join(" "' tokens' i' tokens.Length - i));                            Int64 sz = 0;                          string v = tokens[i + 2];                          if (v.ToUpper().EndsWith("K"))                              sz = Int64.Parse(v.Substring(0' v.Length - 1)) * 1024;                          else if (v.ToUpper().EndsWith("KB"))                              sz = Int64.Parse(v.Substring(0' v.Length - 2)) * 1024;                          else if (v.ToUpper().EndsWith("M"))                              sz = Int64.Parse(v.Substring(0' v.Length - 1)) * 1024 * 1024;                          else if (v.ToUpper().EndsWith("MB"))                              sz = Int64.Parse(v.Substring(0' v.Length - 2)) * 1024 * 1024;                          else if (v.ToUpper().EndsWith("G"))                              sz = Int64.Parse(v.Substring(0' v.Length - 1)) * 1024 * 1024 * 1024;                          else if (v.ToUpper().EndsWith("GB"))                              sz = Int64.Parse(v.Substring(0' v.Length - 2)) * 1024 * 1024 * 1024;                          else sz = Int64.Parse(tokens[i + 2]);                            current = new SizeCriterion                          {                              Size = sz'                              Operator = (ComparisonOperator)EnumUtil.Parse(typeof(ComparisonOperator)' tokens[i + 1])                          };                          i += 2;                          stateStack.Push(ParseState.CriterionDone);                          break;                        case "filename":                      case "name":                          {                              if (tokens.Length <= i + 2)                                  throw new ArgumentException(String.Join(" "' tokens' i' tokens.Length - i));                                ComparisonOperator c =                                  (ComparisonOperator)EnumUtil.Parse(typeof(ComparisonOperator)' tokens[i + 1]);                                if (c != ComparisonOperator.NotEqualTo && c != ComparisonOperator.EqualTo)                                  throw new ArgumentException(String.Join(" "' tokens' i' tokens.Length - i));                                string m = tokens[i + 2];                                // handle single-quoted filespecs (used to include                              // spaces in filename patterns)                              if (m.StartsWith("'") && m.EndsWith("'"))                              {                                  // trim off leading and trailing single quotes and                                  // revert the control characters to spaces.                                  m = m.Substring(1' m.Length - 2)                                      .Replace("\u0006"' " ");                              }                                // if (m.StartsWith("'"))                              //     m = m.Replace("\u0006"' " ");                                //Fix for Unix -> NormalizeCriteriaExpression replaces all slashes with backslashes                              if (Path.DirectorySeparatorChar == '/')                                  m = m.Replace('\\'' Path.DirectorySeparatorChar);                                current = new NameCriterion                              {                                  MatchingFileSpec = m'                                  Operator = c                              };                              i += 2;                              stateStack.Push(ParseState.CriterionDone);                          }                          break;                        case "attrs":                      case "attributes":                      case "type":                          {                              if (tokens.Length <= i + 2)                                  throw new ArgumentException(String.Join(" "' tokens' i' tokens.Length - i));                                ComparisonOperator c =                                  (ComparisonOperator)EnumUtil.Parse(typeof(ComparisonOperator)' tokens[i + 1]);                                if (c != ComparisonOperator.NotEqualTo && c != ComparisonOperator.EqualTo)                                  throw new ArgumentException(String.Join(" "' tokens' i' tokens.Length - i));                                current = (tok1 == "type")                                  ? (SelectionCriterion) new TypeCriterion                                      {                                          AttributeString = tokens[i + 2]'                                          Operator = c                                      }                                  : (SelectionCriterion) new AttributesCriterion                                      {                                          AttributeString = tokens[i + 2]'                                          Operator = c                                      };                              i += 2;                              stateStack.Push(ParseState.CriterionDone);                          }                          break;                        case "":                          // NOP                          stateStack.Push(ParseState.Whitespace);                          break;                        default:                          throw new ArgumentException("'" + tokens[i] + "'");                  }
Magic Number,Ionic,FileSelector,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\FileSelector.cs,_ParseCriterion,The following statement contains a magic number: switch (tok1)                  {                      case "and":                      case "xor":                      case "or":                          state = stateStack.Peek();                          if (state != ParseState.CriterionDone)                              throw new ArgumentException(String.Join(" "' tokens' i' tokens.Length - i));                            if (tokens.Length <= i + 3)                              throw new ArgumentException(String.Join(" "' tokens' i' tokens.Length - i));                            pendingConjunction = (LogicalConjunction)Enum.Parse(typeof(LogicalConjunction)' tokens[i].ToUpper()' true);                          current = new CompoundCriterion { Left = current' Right = null' Conjunction = pendingConjunction };                          stateStack.Push(state);                          stateStack.Push(ParseState.ConjunctionPending);                          critStack.Push(current);                          break;                        case "(":                          state = stateStack.Peek();                          if (state != ParseState.Start && state != ParseState.ConjunctionPending && state != ParseState.OpenParen)                              throw new ArgumentException(String.Join(" "' tokens' i' tokens.Length - i));                            if (tokens.Length <= i + 4)                              throw new ArgumentException(String.Join(" "' tokens' i' tokens.Length - i));                            stateStack.Push(ParseState.OpenParen);                          break;                        case ")":                          state = stateStack.Pop();                          if (stateStack.Peek() != ParseState.OpenParen)                              throw new ArgumentException(String.Join(" "' tokens' i' tokens.Length - i));                            stateStack.Pop();                          stateStack.Push(ParseState.CriterionDone);                          break;                        case "atime":                      case "ctime":                      case "mtime":                          if (tokens.Length <= i + 2)                              throw new ArgumentException(String.Join(" "' tokens' i' tokens.Length - i));                            DateTime t;                          try                          {                              t = DateTime.ParseExact(tokens[i + 2]' "yyyy-MM-dd-HH:mm:ss"' null);                          }                          catch (FormatException)                          {                              try                              {                                  t = DateTime.ParseExact(tokens[i + 2]' "yyyy/MM/dd-HH:mm:ss"' null);                              }                              catch (FormatException)                              {                                  try                                  {                                      t = DateTime.ParseExact(tokens[i + 2]' "yyyy/MM/dd"' null);                                  }                                  catch (FormatException)                                  {                                      try                                      {                                          t = DateTime.ParseExact(tokens[i + 2]' "MM/dd/yyyy"' null);                                      }                                      catch (FormatException)                                      {                                          t = DateTime.ParseExact(tokens[i + 2]' "yyyy-MM-dd"' null);                                      }                                  }                              }                          }                          t= DateTime.SpecifyKind(t' DateTimeKind.Local).ToUniversalTime();                          current = new TimeCriterion                          {                              Which = (WhichTime)Enum.Parse(typeof(WhichTime)' tokens[i]' true)'                              Operator = (ComparisonOperator)EnumUtil.Parse(typeof(ComparisonOperator)' tokens[i + 1])'                              Time = t                          };                          i += 2;                          stateStack.Push(ParseState.CriterionDone);                          break;                          case "length":                      case "size":                          if (tokens.Length <= i + 2)                              throw new ArgumentException(String.Join(" "' tokens' i' tokens.Length - i));                            Int64 sz = 0;                          string v = tokens[i + 2];                          if (v.ToUpper().EndsWith("K"))                              sz = Int64.Parse(v.Substring(0' v.Length - 1)) * 1024;                          else if (v.ToUpper().EndsWith("KB"))                              sz = Int64.Parse(v.Substring(0' v.Length - 2)) * 1024;                          else if (v.ToUpper().EndsWith("M"))                              sz = Int64.Parse(v.Substring(0' v.Length - 1)) * 1024 * 1024;                          else if (v.ToUpper().EndsWith("MB"))                              sz = Int64.Parse(v.Substring(0' v.Length - 2)) * 1024 * 1024;                          else if (v.ToUpper().EndsWith("G"))                              sz = Int64.Parse(v.Substring(0' v.Length - 1)) * 1024 * 1024 * 1024;                          else if (v.ToUpper().EndsWith("GB"))                              sz = Int64.Parse(v.Substring(0' v.Length - 2)) * 1024 * 1024 * 1024;                          else sz = Int64.Parse(tokens[i + 2]);                            current = new SizeCriterion                          {                              Size = sz'                              Operator = (ComparisonOperator)EnumUtil.Parse(typeof(ComparisonOperator)' tokens[i + 1])                          };                          i += 2;                          stateStack.Push(ParseState.CriterionDone);                          break;                        case "filename":                      case "name":                          {                              if (tokens.Length <= i + 2)                                  throw new ArgumentException(String.Join(" "' tokens' i' tokens.Length - i));                                ComparisonOperator c =                                  (ComparisonOperator)EnumUtil.Parse(typeof(ComparisonOperator)' tokens[i + 1]);                                if (c != ComparisonOperator.NotEqualTo && c != ComparisonOperator.EqualTo)                                  throw new ArgumentException(String.Join(" "' tokens' i' tokens.Length - i));                                string m = tokens[i + 2];                                // handle single-quoted filespecs (used to include                              // spaces in filename patterns)                              if (m.StartsWith("'") && m.EndsWith("'"))                              {                                  // trim off leading and trailing single quotes and                                  // revert the control characters to spaces.                                  m = m.Substring(1' m.Length - 2)                                      .Replace("\u0006"' " ");                              }                                // if (m.StartsWith("'"))                              //     m = m.Replace("\u0006"' " ");                                //Fix for Unix -> NormalizeCriteriaExpression replaces all slashes with backslashes                              if (Path.DirectorySeparatorChar == '/')                                  m = m.Replace('\\'' Path.DirectorySeparatorChar);                                current = new NameCriterion                              {                                  MatchingFileSpec = m'                                  Operator = c                              };                              i += 2;                              stateStack.Push(ParseState.CriterionDone);                          }                          break;                        case "attrs":                      case "attributes":                      case "type":                          {                              if (tokens.Length <= i + 2)                                  throw new ArgumentException(String.Join(" "' tokens' i' tokens.Length - i));                                ComparisonOperator c =                                  (ComparisonOperator)EnumUtil.Parse(typeof(ComparisonOperator)' tokens[i + 1]);                                if (c != ComparisonOperator.NotEqualTo && c != ComparisonOperator.EqualTo)                                  throw new ArgumentException(String.Join(" "' tokens' i' tokens.Length - i));                                current = (tok1 == "type")                                  ? (SelectionCriterion) new TypeCriterion                                      {                                          AttributeString = tokens[i + 2]'                                          Operator = c                                      }                                  : (SelectionCriterion) new AttributesCriterion                                      {                                          AttributeString = tokens[i + 2]'                                          Operator = c                                      };                              i += 2;                              stateStack.Push(ParseState.CriterionDone);                          }                          break;                        case "":                          // NOP                          stateStack.Push(ParseState.Whitespace);                          break;                        default:                          throw new ArgumentException("'" + tokens[i] + "'");                  }
Magic Number,Ionic,FileSelector,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\FileSelector.cs,_ParseCriterion,The following statement contains a magic number: switch (tok1)                  {                      case "and":                      case "xor":                      case "or":                          state = stateStack.Peek();                          if (state != ParseState.CriterionDone)                              throw new ArgumentException(String.Join(" "' tokens' i' tokens.Length - i));                            if (tokens.Length <= i + 3)                              throw new ArgumentException(String.Join(" "' tokens' i' tokens.Length - i));                            pendingConjunction = (LogicalConjunction)Enum.Parse(typeof(LogicalConjunction)' tokens[i].ToUpper()' true);                          current = new CompoundCriterion { Left = current' Right = null' Conjunction = pendingConjunction };                          stateStack.Push(state);                          stateStack.Push(ParseState.ConjunctionPending);                          critStack.Push(current);                          break;                        case "(":                          state = stateStack.Peek();                          if (state != ParseState.Start && state != ParseState.ConjunctionPending && state != ParseState.OpenParen)                              throw new ArgumentException(String.Join(" "' tokens' i' tokens.Length - i));                            if (tokens.Length <= i + 4)                              throw new ArgumentException(String.Join(" "' tokens' i' tokens.Length - i));                            stateStack.Push(ParseState.OpenParen);                          break;                        case ")":                          state = stateStack.Pop();                          if (stateStack.Peek() != ParseState.OpenParen)                              throw new ArgumentException(String.Join(" "' tokens' i' tokens.Length - i));                            stateStack.Pop();                          stateStack.Push(ParseState.CriterionDone);                          break;                        case "atime":                      case "ctime":                      case "mtime":                          if (tokens.Length <= i + 2)                              throw new ArgumentException(String.Join(" "' tokens' i' tokens.Length - i));                            DateTime t;                          try                          {                              t = DateTime.ParseExact(tokens[i + 2]' "yyyy-MM-dd-HH:mm:ss"' null);                          }                          catch (FormatException)                          {                              try                              {                                  t = DateTime.ParseExact(tokens[i + 2]' "yyyy/MM/dd-HH:mm:ss"' null);                              }                              catch (FormatException)                              {                                  try                                  {                                      t = DateTime.ParseExact(tokens[i + 2]' "yyyy/MM/dd"' null);                                  }                                  catch (FormatException)                                  {                                      try                                      {                                          t = DateTime.ParseExact(tokens[i + 2]' "MM/dd/yyyy"' null);                                      }                                      catch (FormatException)                                      {                                          t = DateTime.ParseExact(tokens[i + 2]' "yyyy-MM-dd"' null);                                      }                                  }                              }                          }                          t= DateTime.SpecifyKind(t' DateTimeKind.Local).ToUniversalTime();                          current = new TimeCriterion                          {                              Which = (WhichTime)Enum.Parse(typeof(WhichTime)' tokens[i]' true)'                              Operator = (ComparisonOperator)EnumUtil.Parse(typeof(ComparisonOperator)' tokens[i + 1])'                              Time = t                          };                          i += 2;                          stateStack.Push(ParseState.CriterionDone);                          break;                          case "length":                      case "size":                          if (tokens.Length <= i + 2)                              throw new ArgumentException(String.Join(" "' tokens' i' tokens.Length - i));                            Int64 sz = 0;                          string v = tokens[i + 2];                          if (v.ToUpper().EndsWith("K"))                              sz = Int64.Parse(v.Substring(0' v.Length - 1)) * 1024;                          else if (v.ToUpper().EndsWith("KB"))                              sz = Int64.Parse(v.Substring(0' v.Length - 2)) * 1024;                          else if (v.ToUpper().EndsWith("M"))                              sz = Int64.Parse(v.Substring(0' v.Length - 1)) * 1024 * 1024;                          else if (v.ToUpper().EndsWith("MB"))                              sz = Int64.Parse(v.Substring(0' v.Length - 2)) * 1024 * 1024;                          else if (v.ToUpper().EndsWith("G"))                              sz = Int64.Parse(v.Substring(0' v.Length - 1)) * 1024 * 1024 * 1024;                          else if (v.ToUpper().EndsWith("GB"))                              sz = Int64.Parse(v.Substring(0' v.Length - 2)) * 1024 * 1024 * 1024;                          else sz = Int64.Parse(tokens[i + 2]);                            current = new SizeCriterion                          {                              Size = sz'                              Operator = (ComparisonOperator)EnumUtil.Parse(typeof(ComparisonOperator)' tokens[i + 1])                          };                          i += 2;                          stateStack.Push(ParseState.CriterionDone);                          break;                        case "filename":                      case "name":                          {                              if (tokens.Length <= i + 2)                                  throw new ArgumentException(String.Join(" "' tokens' i' tokens.Length - i));                                ComparisonOperator c =                                  (ComparisonOperator)EnumUtil.Parse(typeof(ComparisonOperator)' tokens[i + 1]);                                if (c != ComparisonOperator.NotEqualTo && c != ComparisonOperator.EqualTo)                                  throw new ArgumentException(String.Join(" "' tokens' i' tokens.Length - i));                                string m = tokens[i + 2];                                // handle single-quoted filespecs (used to include                              // spaces in filename patterns)                              if (m.StartsWith("'") && m.EndsWith("'"))                              {                                  // trim off leading and trailing single quotes and                                  // revert the control characters to spaces.                                  m = m.Substring(1' m.Length - 2)                                      .Replace("\u0006"' " ");                              }                                // if (m.StartsWith("'"))                              //     m = m.Replace("\u0006"' " ");                                //Fix for Unix -> NormalizeCriteriaExpression replaces all slashes with backslashes                              if (Path.DirectorySeparatorChar == '/')                                  m = m.Replace('\\'' Path.DirectorySeparatorChar);                                current = new NameCriterion                              {                                  MatchingFileSpec = m'                                  Operator = c                              };                              i += 2;                              stateStack.Push(ParseState.CriterionDone);                          }                          break;                        case "attrs":                      case "attributes":                      case "type":                          {                              if (tokens.Length <= i + 2)                                  throw new ArgumentException(String.Join(" "' tokens' i' tokens.Length - i));                                ComparisonOperator c =                                  (ComparisonOperator)EnumUtil.Parse(typeof(ComparisonOperator)' tokens[i + 1]);                                if (c != ComparisonOperator.NotEqualTo && c != ComparisonOperator.EqualTo)                                  throw new ArgumentException(String.Join(" "' tokens' i' tokens.Length - i));                                current = (tok1 == "type")                                  ? (SelectionCriterion) new TypeCriterion                                      {                                          AttributeString = tokens[i + 2]'                                          Operator = c                                      }                                  : (SelectionCriterion) new AttributesCriterion                                      {                                          AttributeString = tokens[i + 2]'                                          Operator = c                                      };                              i += 2;                              stateStack.Push(ParseState.CriterionDone);                          }                          break;                        case "":                          // NOP                          stateStack.Push(ParseState.Whitespace);                          break;                        default:                          throw new ArgumentException("'" + tokens[i] + "'");                  }
Magic Number,Ionic,FileSelector,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\FileSelector.cs,_ParseCriterion,The following statement contains a magic number: switch (tok1)                  {                      case "and":                      case "xor":                      case "or":                          state = stateStack.Peek();                          if (state != ParseState.CriterionDone)                              throw new ArgumentException(String.Join(" "' tokens' i' tokens.Length - i));                            if (tokens.Length <= i + 3)                              throw new ArgumentException(String.Join(" "' tokens' i' tokens.Length - i));                            pendingConjunction = (LogicalConjunction)Enum.Parse(typeof(LogicalConjunction)' tokens[i].ToUpper()' true);                          current = new CompoundCriterion { Left = current' Right = null' Conjunction = pendingConjunction };                          stateStack.Push(state);                          stateStack.Push(ParseState.ConjunctionPending);                          critStack.Push(current);                          break;                        case "(":                          state = stateStack.Peek();                          if (state != ParseState.Start && state != ParseState.ConjunctionPending && state != ParseState.OpenParen)                              throw new ArgumentException(String.Join(" "' tokens' i' tokens.Length - i));                            if (tokens.Length <= i + 4)                              throw new ArgumentException(String.Join(" "' tokens' i' tokens.Length - i));                            stateStack.Push(ParseState.OpenParen);                          break;                        case ")":                          state = stateStack.Pop();                          if (stateStack.Peek() != ParseState.OpenParen)                              throw new ArgumentException(String.Join(" "' tokens' i' tokens.Length - i));                            stateStack.Pop();                          stateStack.Push(ParseState.CriterionDone);                          break;                        case "atime":                      case "ctime":                      case "mtime":                          if (tokens.Length <= i + 2)                              throw new ArgumentException(String.Join(" "' tokens' i' tokens.Length - i));                            DateTime t;                          try                          {                              t = DateTime.ParseExact(tokens[i + 2]' "yyyy-MM-dd-HH:mm:ss"' null);                          }                          catch (FormatException)                          {                              try                              {                                  t = DateTime.ParseExact(tokens[i + 2]' "yyyy/MM/dd-HH:mm:ss"' null);                              }                              catch (FormatException)                              {                                  try                                  {                                      t = DateTime.ParseExact(tokens[i + 2]' "yyyy/MM/dd"' null);                                  }                                  catch (FormatException)                                  {                                      try                                      {                                          t = DateTime.ParseExact(tokens[i + 2]' "MM/dd/yyyy"' null);                                      }                                      catch (FormatException)                                      {                                          t = DateTime.ParseExact(tokens[i + 2]' "yyyy-MM-dd"' null);                                      }                                  }                              }                          }                          t= DateTime.SpecifyKind(t' DateTimeKind.Local).ToUniversalTime();                          current = new TimeCriterion                          {                              Which = (WhichTime)Enum.Parse(typeof(WhichTime)' tokens[i]' true)'                              Operator = (ComparisonOperator)EnumUtil.Parse(typeof(ComparisonOperator)' tokens[i + 1])'                              Time = t                          };                          i += 2;                          stateStack.Push(ParseState.CriterionDone);                          break;                          case "length":                      case "size":                          if (tokens.Length <= i + 2)                              throw new ArgumentException(String.Join(" "' tokens' i' tokens.Length - i));                            Int64 sz = 0;                          string v = tokens[i + 2];                          if (v.ToUpper().EndsWith("K"))                              sz = Int64.Parse(v.Substring(0' v.Length - 1)) * 1024;                          else if (v.ToUpper().EndsWith("KB"))                              sz = Int64.Parse(v.Substring(0' v.Length - 2)) * 1024;                          else if (v.ToUpper().EndsWith("M"))                              sz = Int64.Parse(v.Substring(0' v.Length - 1)) * 1024 * 1024;                          else if (v.ToUpper().EndsWith("MB"))                              sz = Int64.Parse(v.Substring(0' v.Length - 2)) * 1024 * 1024;                          else if (v.ToUpper().EndsWith("G"))                              sz = Int64.Parse(v.Substring(0' v.Length - 1)) * 1024 * 1024 * 1024;                          else if (v.ToUpper().EndsWith("GB"))                              sz = Int64.Parse(v.Substring(0' v.Length - 2)) * 1024 * 1024 * 1024;                          else sz = Int64.Parse(tokens[i + 2]);                            current = new SizeCriterion                          {                              Size = sz'                              Operator = (ComparisonOperator)EnumUtil.Parse(typeof(ComparisonOperator)' tokens[i + 1])                          };                          i += 2;                          stateStack.Push(ParseState.CriterionDone);                          break;                        case "filename":                      case "name":                          {                              if (tokens.Length <= i + 2)                                  throw new ArgumentException(String.Join(" "' tokens' i' tokens.Length - i));                                ComparisonOperator c =                                  (ComparisonOperator)EnumUtil.Parse(typeof(ComparisonOperator)' tokens[i + 1]);                                if (c != ComparisonOperator.NotEqualTo && c != ComparisonOperator.EqualTo)                                  throw new ArgumentException(String.Join(" "' tokens' i' tokens.Length - i));                                string m = tokens[i + 2];                                // handle single-quoted filespecs (used to include                              // spaces in filename patterns)                              if (m.StartsWith("'") && m.EndsWith("'"))                              {                                  // trim off leading and trailing single quotes and                                  // revert the control characters to spaces.                                  m = m.Substring(1' m.Length - 2)                                      .Replace("\u0006"' " ");                              }                                // if (m.StartsWith("'"))                              //     m = m.Replace("\u0006"' " ");                                //Fix for Unix -> NormalizeCriteriaExpression replaces all slashes with backslashes                              if (Path.DirectorySeparatorChar == '/')                                  m = m.Replace('\\'' Path.DirectorySeparatorChar);                                current = new NameCriterion                              {                                  MatchingFileSpec = m'                                  Operator = c                              };                              i += 2;                              stateStack.Push(ParseState.CriterionDone);                          }                          break;                        case "attrs":                      case "attributes":                      case "type":                          {                              if (tokens.Length <= i + 2)                                  throw new ArgumentException(String.Join(" "' tokens' i' tokens.Length - i));                                ComparisonOperator c =                                  (ComparisonOperator)EnumUtil.Parse(typeof(ComparisonOperator)' tokens[i + 1]);                                if (c != ComparisonOperator.NotEqualTo && c != ComparisonOperator.EqualTo)                                  throw new ArgumentException(String.Join(" "' tokens' i' tokens.Length - i));                                current = (tok1 == "type")                                  ? (SelectionCriterion) new TypeCriterion                                      {                                          AttributeString = tokens[i + 2]'                                          Operator = c                                      }                                  : (SelectionCriterion) new AttributesCriterion                                      {                                          AttributeString = tokens[i + 2]'                                          Operator = c                                      };                              i += 2;                              stateStack.Push(ParseState.CriterionDone);                          }                          break;                        case "":                          // NOP                          stateStack.Push(ParseState.Whitespace);                          break;                        default:                          throw new ArgumentException("'" + tokens[i] + "'");                  }
Magic Number,Ionic,FileSelector,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\FileSelector.cs,_ParseCriterion,The following statement contains a magic number: switch (tok1)                  {                      case "and":                      case "xor":                      case "or":                          state = stateStack.Peek();                          if (state != ParseState.CriterionDone)                              throw new ArgumentException(String.Join(" "' tokens' i' tokens.Length - i));                            if (tokens.Length <= i + 3)                              throw new ArgumentException(String.Join(" "' tokens' i' tokens.Length - i));                            pendingConjunction = (LogicalConjunction)Enum.Parse(typeof(LogicalConjunction)' tokens[i].ToUpper()' true);                          current = new CompoundCriterion { Left = current' Right = null' Conjunction = pendingConjunction };                          stateStack.Push(state);                          stateStack.Push(ParseState.ConjunctionPending);                          critStack.Push(current);                          break;                        case "(":                          state = stateStack.Peek();                          if (state != ParseState.Start && state != ParseState.ConjunctionPending && state != ParseState.OpenParen)                              throw new ArgumentException(String.Join(" "' tokens' i' tokens.Length - i));                            if (tokens.Length <= i + 4)                              throw new ArgumentException(String.Join(" "' tokens' i' tokens.Length - i));                            stateStack.Push(ParseState.OpenParen);                          break;                        case ")":                          state = stateStack.Pop();                          if (stateStack.Peek() != ParseState.OpenParen)                              throw new ArgumentException(String.Join(" "' tokens' i' tokens.Length - i));                            stateStack.Pop();                          stateStack.Push(ParseState.CriterionDone);                          break;                        case "atime":                      case "ctime":                      case "mtime":                          if (tokens.Length <= i + 2)                              throw new ArgumentException(String.Join(" "' tokens' i' tokens.Length - i));                            DateTime t;                          try                          {                              t = DateTime.ParseExact(tokens[i + 2]' "yyyy-MM-dd-HH:mm:ss"' null);                          }                          catch (FormatException)                          {                              try                              {                                  t = DateTime.ParseExact(tokens[i + 2]' "yyyy/MM/dd-HH:mm:ss"' null);                              }                              catch (FormatException)                              {                                  try                                  {                                      t = DateTime.ParseExact(tokens[i + 2]' "yyyy/MM/dd"' null);                                  }                                  catch (FormatException)                                  {                                      try                                      {                                          t = DateTime.ParseExact(tokens[i + 2]' "MM/dd/yyyy"' null);                                      }                                      catch (FormatException)                                      {                                          t = DateTime.ParseExact(tokens[i + 2]' "yyyy-MM-dd"' null);                                      }                                  }                              }                          }                          t= DateTime.SpecifyKind(t' DateTimeKind.Local).ToUniversalTime();                          current = new TimeCriterion                          {                              Which = (WhichTime)Enum.Parse(typeof(WhichTime)' tokens[i]' true)'                              Operator = (ComparisonOperator)EnumUtil.Parse(typeof(ComparisonOperator)' tokens[i + 1])'                              Time = t                          };                          i += 2;                          stateStack.Push(ParseState.CriterionDone);                          break;                          case "length":                      case "size":                          if (tokens.Length <= i + 2)                              throw new ArgumentException(String.Join(" "' tokens' i' tokens.Length - i));                            Int64 sz = 0;                          string v = tokens[i + 2];                          if (v.ToUpper().EndsWith("K"))                              sz = Int64.Parse(v.Substring(0' v.Length - 1)) * 1024;                          else if (v.ToUpper().EndsWith("KB"))                              sz = Int64.Parse(v.Substring(0' v.Length - 2)) * 1024;                          else if (v.ToUpper().EndsWith("M"))                              sz = Int64.Parse(v.Substring(0' v.Length - 1)) * 1024 * 1024;                          else if (v.ToUpper().EndsWith("MB"))                              sz = Int64.Parse(v.Substring(0' v.Length - 2)) * 1024 * 1024;                          else if (v.ToUpper().EndsWith("G"))                              sz = Int64.Parse(v.Substring(0' v.Length - 1)) * 1024 * 1024 * 1024;                          else if (v.ToUpper().EndsWith("GB"))                              sz = Int64.Parse(v.Substring(0' v.Length - 2)) * 1024 * 1024 * 1024;                          else sz = Int64.Parse(tokens[i + 2]);                            current = new SizeCriterion                          {                              Size = sz'                              Operator = (ComparisonOperator)EnumUtil.Parse(typeof(ComparisonOperator)' tokens[i + 1])                          };                          i += 2;                          stateStack.Push(ParseState.CriterionDone);                          break;                        case "filename":                      case "name":                          {                              if (tokens.Length <= i + 2)                                  throw new ArgumentException(String.Join(" "' tokens' i' tokens.Length - i));                                ComparisonOperator c =                                  (ComparisonOperator)EnumUtil.Parse(typeof(ComparisonOperator)' tokens[i + 1]);                                if (c != ComparisonOperator.NotEqualTo && c != ComparisonOperator.EqualTo)                                  throw new ArgumentException(String.Join(" "' tokens' i' tokens.Length - i));                                string m = tokens[i + 2];                                // handle single-quoted filespecs (used to include                              // spaces in filename patterns)                              if (m.StartsWith("'") && m.EndsWith("'"))                              {                                  // trim off leading and trailing single quotes and                                  // revert the control characters to spaces.                                  m = m.Substring(1' m.Length - 2)                                      .Replace("\u0006"' " ");                              }                                // if (m.StartsWith("'"))                              //     m = m.Replace("\u0006"' " ");                                //Fix for Unix -> NormalizeCriteriaExpression replaces all slashes with backslashes                              if (Path.DirectorySeparatorChar == '/')                                  m = m.Replace('\\'' Path.DirectorySeparatorChar);                                current = new NameCriterion                              {                                  MatchingFileSpec = m'                                  Operator = c                              };                              i += 2;                              stateStack.Push(ParseState.CriterionDone);                          }                          break;                        case "attrs":                      case "attributes":                      case "type":                          {                              if (tokens.Length <= i + 2)                                  throw new ArgumentException(String.Join(" "' tokens' i' tokens.Length - i));                                ComparisonOperator c =                                  (ComparisonOperator)EnumUtil.Parse(typeof(ComparisonOperator)' tokens[i + 1]);                                if (c != ComparisonOperator.NotEqualTo && c != ComparisonOperator.EqualTo)                                  throw new ArgumentException(String.Join(" "' tokens' i' tokens.Length - i));                                current = (tok1 == "type")                                  ? (SelectionCriterion) new TypeCriterion                                      {                                          AttributeString = tokens[i + 2]'                                          Operator = c                                      }                                  : (SelectionCriterion) new AttributesCriterion                                      {                                          AttributeString = tokens[i + 2]'                                          Operator = c                                      };                              i += 2;                              stateStack.Push(ParseState.CriterionDone);                          }                          break;                        case "":                          // NOP                          stateStack.Push(ParseState.Whitespace);                          break;                        default:                          throw new ArgumentException("'" + tokens[i] + "'");                  }
Magic Number,Ionic,FileSelector,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\FileSelector.cs,_ParseCriterion,The following statement contains a magic number: switch (tok1)                  {                      case "and":                      case "xor":                      case "or":                          state = stateStack.Peek();                          if (state != ParseState.CriterionDone)                              throw new ArgumentException(String.Join(" "' tokens' i' tokens.Length - i));                            if (tokens.Length <= i + 3)                              throw new ArgumentException(String.Join(" "' tokens' i' tokens.Length - i));                            pendingConjunction = (LogicalConjunction)Enum.Parse(typeof(LogicalConjunction)' tokens[i].ToUpper()' true);                          current = new CompoundCriterion { Left = current' Right = null' Conjunction = pendingConjunction };                          stateStack.Push(state);                          stateStack.Push(ParseState.ConjunctionPending);                          critStack.Push(current);                          break;                        case "(":                          state = stateStack.Peek();                          if (state != ParseState.Start && state != ParseState.ConjunctionPending && state != ParseState.OpenParen)                              throw new ArgumentException(String.Join(" "' tokens' i' tokens.Length - i));                            if (tokens.Length <= i + 4)                              throw new ArgumentException(String.Join(" "' tokens' i' tokens.Length - i));                            stateStack.Push(ParseState.OpenParen);                          break;                        case ")":                          state = stateStack.Pop();                          if (stateStack.Peek() != ParseState.OpenParen)                              throw new ArgumentException(String.Join(" "' tokens' i' tokens.Length - i));                            stateStack.Pop();                          stateStack.Push(ParseState.CriterionDone);                          break;                        case "atime":                      case "ctime":                      case "mtime":                          if (tokens.Length <= i + 2)                              throw new ArgumentException(String.Join(" "' tokens' i' tokens.Length - i));                            DateTime t;                          try                          {                              t = DateTime.ParseExact(tokens[i + 2]' "yyyy-MM-dd-HH:mm:ss"' null);                          }                          catch (FormatException)                          {                              try                              {                                  t = DateTime.ParseExact(tokens[i + 2]' "yyyy/MM/dd-HH:mm:ss"' null);                              }                              catch (FormatException)                              {                                  try                                  {                                      t = DateTime.ParseExact(tokens[i + 2]' "yyyy/MM/dd"' null);                                  }                                  catch (FormatException)                                  {                                      try                                      {                                          t = DateTime.ParseExact(tokens[i + 2]' "MM/dd/yyyy"' null);                                      }                                      catch (FormatException)                                      {                                          t = DateTime.ParseExact(tokens[i + 2]' "yyyy-MM-dd"' null);                                      }                                  }                              }                          }                          t= DateTime.SpecifyKind(t' DateTimeKind.Local).ToUniversalTime();                          current = new TimeCriterion                          {                              Which = (WhichTime)Enum.Parse(typeof(WhichTime)' tokens[i]' true)'                              Operator = (ComparisonOperator)EnumUtil.Parse(typeof(ComparisonOperator)' tokens[i + 1])'                              Time = t                          };                          i += 2;                          stateStack.Push(ParseState.CriterionDone);                          break;                          case "length":                      case "size":                          if (tokens.Length <= i + 2)                              throw new ArgumentException(String.Join(" "' tokens' i' tokens.Length - i));                            Int64 sz = 0;                          string v = tokens[i + 2];                          if (v.ToUpper().EndsWith("K"))                              sz = Int64.Parse(v.Substring(0' v.Length - 1)) * 1024;                          else if (v.ToUpper().EndsWith("KB"))                              sz = Int64.Parse(v.Substring(0' v.Length - 2)) * 1024;                          else if (v.ToUpper().EndsWith("M"))                              sz = Int64.Parse(v.Substring(0' v.Length - 1)) * 1024 * 1024;                          else if (v.ToUpper().EndsWith("MB"))                              sz = Int64.Parse(v.Substring(0' v.Length - 2)) * 1024 * 1024;                          else if (v.ToUpper().EndsWith("G"))                              sz = Int64.Parse(v.Substring(0' v.Length - 1)) * 1024 * 1024 * 1024;                          else if (v.ToUpper().EndsWith("GB"))                              sz = Int64.Parse(v.Substring(0' v.Length - 2)) * 1024 * 1024 * 1024;                          else sz = Int64.Parse(tokens[i + 2]);                            current = new SizeCriterion                          {                              Size = sz'                              Operator = (ComparisonOperator)EnumUtil.Parse(typeof(ComparisonOperator)' tokens[i + 1])                          };                          i += 2;                          stateStack.Push(ParseState.CriterionDone);                          break;                        case "filename":                      case "name":                          {                              if (tokens.Length <= i + 2)                                  throw new ArgumentException(String.Join(" "' tokens' i' tokens.Length - i));                                ComparisonOperator c =                                  (ComparisonOperator)EnumUtil.Parse(typeof(ComparisonOperator)' tokens[i + 1]);                                if (c != ComparisonOperator.NotEqualTo && c != ComparisonOperator.EqualTo)                                  throw new ArgumentException(String.Join(" "' tokens' i' tokens.Length - i));                                string m = tokens[i + 2];                                // handle single-quoted filespecs (used to include                              // spaces in filename patterns)                              if (m.StartsWith("'") && m.EndsWith("'"))                              {                                  // trim off leading and trailing single quotes and                                  // revert the control characters to spaces.                                  m = m.Substring(1' m.Length - 2)                                      .Replace("\u0006"' " ");                              }                                // if (m.StartsWith("'"))                              //     m = m.Replace("\u0006"' " ");                                //Fix for Unix -> NormalizeCriteriaExpression replaces all slashes with backslashes                              if (Path.DirectorySeparatorChar == '/')                                  m = m.Replace('\\'' Path.DirectorySeparatorChar);                                current = new NameCriterion                              {                                  MatchingFileSpec = m'                                  Operator = c                              };                              i += 2;                              stateStack.Push(ParseState.CriterionDone);                          }                          break;                        case "attrs":                      case "attributes":                      case "type":                          {                              if (tokens.Length <= i + 2)                                  throw new ArgumentException(String.Join(" "' tokens' i' tokens.Length - i));                                ComparisonOperator c =                                  (ComparisonOperator)EnumUtil.Parse(typeof(ComparisonOperator)' tokens[i + 1]);                                if (c != ComparisonOperator.NotEqualTo && c != ComparisonOperator.EqualTo)                                  throw new ArgumentException(String.Join(" "' tokens' i' tokens.Length - i));                                current = (tok1 == "type")                                  ? (SelectionCriterion) new TypeCriterion                                      {                                          AttributeString = tokens[i + 2]'                                          Operator = c                                      }                                  : (SelectionCriterion) new AttributesCriterion                                      {                                          AttributeString = tokens[i + 2]'                                          Operator = c                                      };                              i += 2;                              stateStack.Push(ParseState.CriterionDone);                          }                          break;                        case "":                          // NOP                          stateStack.Push(ParseState.Whitespace);                          break;                        default:                          throw new ArgumentException("'" + tokens[i] + "'");                  }
Magic Number,Ionic,FileSelector,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\FileSelector.cs,_ParseCriterion,The following statement contains a magic number: switch (tok1)                  {                      case "and":                      case "xor":                      case "or":                          state = stateStack.Peek();                          if (state != ParseState.CriterionDone)                              throw new ArgumentException(String.Join(" "' tokens' i' tokens.Length - i));                            if (tokens.Length <= i + 3)                              throw new ArgumentException(String.Join(" "' tokens' i' tokens.Length - i));                            pendingConjunction = (LogicalConjunction)Enum.Parse(typeof(LogicalConjunction)' tokens[i].ToUpper()' true);                          current = new CompoundCriterion { Left = current' Right = null' Conjunction = pendingConjunction };                          stateStack.Push(state);                          stateStack.Push(ParseState.ConjunctionPending);                          critStack.Push(current);                          break;                        case "(":                          state = stateStack.Peek();                          if (state != ParseState.Start && state != ParseState.ConjunctionPending && state != ParseState.OpenParen)                              throw new ArgumentException(String.Join(" "' tokens' i' tokens.Length - i));                            if (tokens.Length <= i + 4)                              throw new ArgumentException(String.Join(" "' tokens' i' tokens.Length - i));                            stateStack.Push(ParseState.OpenParen);                          break;                        case ")":                          state = stateStack.Pop();                          if (stateStack.Peek() != ParseState.OpenParen)                              throw new ArgumentException(String.Join(" "' tokens' i' tokens.Length - i));                            stateStack.Pop();                          stateStack.Push(ParseState.CriterionDone);                          break;                        case "atime":                      case "ctime":                      case "mtime":                          if (tokens.Length <= i + 2)                              throw new ArgumentException(String.Join(" "' tokens' i' tokens.Length - i));                            DateTime t;                          try                          {                              t = DateTime.ParseExact(tokens[i + 2]' "yyyy-MM-dd-HH:mm:ss"' null);                          }                          catch (FormatException)                          {                              try                              {                                  t = DateTime.ParseExact(tokens[i + 2]' "yyyy/MM/dd-HH:mm:ss"' null);                              }                              catch (FormatException)                              {                                  try                                  {                                      t = DateTime.ParseExact(tokens[i + 2]' "yyyy/MM/dd"' null);                                  }                                  catch (FormatException)                                  {                                      try                                      {                                          t = DateTime.ParseExact(tokens[i + 2]' "MM/dd/yyyy"' null);                                      }                                      catch (FormatException)                                      {                                          t = DateTime.ParseExact(tokens[i + 2]' "yyyy-MM-dd"' null);                                      }                                  }                              }                          }                          t= DateTime.SpecifyKind(t' DateTimeKind.Local).ToUniversalTime();                          current = new TimeCriterion                          {                              Which = (WhichTime)Enum.Parse(typeof(WhichTime)' tokens[i]' true)'                              Operator = (ComparisonOperator)EnumUtil.Parse(typeof(ComparisonOperator)' tokens[i + 1])'                              Time = t                          };                          i += 2;                          stateStack.Push(ParseState.CriterionDone);                          break;                          case "length":                      case "size":                          if (tokens.Length <= i + 2)                              throw new ArgumentException(String.Join(" "' tokens' i' tokens.Length - i));                            Int64 sz = 0;                          string v = tokens[i + 2];                          if (v.ToUpper().EndsWith("K"))                              sz = Int64.Parse(v.Substring(0' v.Length - 1)) * 1024;                          else if (v.ToUpper().EndsWith("KB"))                              sz = Int64.Parse(v.Substring(0' v.Length - 2)) * 1024;                          else if (v.ToUpper().EndsWith("M"))                              sz = Int64.Parse(v.Substring(0' v.Length - 1)) * 1024 * 1024;                          else if (v.ToUpper().EndsWith("MB"))                              sz = Int64.Parse(v.Substring(0' v.Length - 2)) * 1024 * 1024;                          else if (v.ToUpper().EndsWith("G"))                              sz = Int64.Parse(v.Substring(0' v.Length - 1)) * 1024 * 1024 * 1024;                          else if (v.ToUpper().EndsWith("GB"))                              sz = Int64.Parse(v.Substring(0' v.Length - 2)) * 1024 * 1024 * 1024;                          else sz = Int64.Parse(tokens[i + 2]);                            current = new SizeCriterion                          {                              Size = sz'                              Operator = (ComparisonOperator)EnumUtil.Parse(typeof(ComparisonOperator)' tokens[i + 1])                          };                          i += 2;                          stateStack.Push(ParseState.CriterionDone);                          break;                        case "filename":                      case "name":                          {                              if (tokens.Length <= i + 2)                                  throw new ArgumentException(String.Join(" "' tokens' i' tokens.Length - i));                                ComparisonOperator c =                                  (ComparisonOperator)EnumUtil.Parse(typeof(ComparisonOperator)' tokens[i + 1]);                                if (c != ComparisonOperator.NotEqualTo && c != ComparisonOperator.EqualTo)                                  throw new ArgumentException(String.Join(" "' tokens' i' tokens.Length - i));                                string m = tokens[i + 2];                                // handle single-quoted filespecs (used to include                              // spaces in filename patterns)                              if (m.StartsWith("'") && m.EndsWith("'"))                              {                                  // trim off leading and trailing single quotes and                                  // revert the control characters to spaces.                                  m = m.Substring(1' m.Length - 2)                                      .Replace("\u0006"' " ");                              }                                // if (m.StartsWith("'"))                              //     m = m.Replace("\u0006"' " ");                                //Fix for Unix -> NormalizeCriteriaExpression replaces all slashes with backslashes                              if (Path.DirectorySeparatorChar == '/')                                  m = m.Replace('\\'' Path.DirectorySeparatorChar);                                current = new NameCriterion                              {                                  MatchingFileSpec = m'                                  Operator = c                              };                              i += 2;                              stateStack.Push(ParseState.CriterionDone);                          }                          break;                        case "attrs":                      case "attributes":                      case "type":                          {                              if (tokens.Length <= i + 2)                                  throw new ArgumentException(String.Join(" "' tokens' i' tokens.Length - i));                                ComparisonOperator c =                                  (ComparisonOperator)EnumUtil.Parse(typeof(ComparisonOperator)' tokens[i + 1]);                                if (c != ComparisonOperator.NotEqualTo && c != ComparisonOperator.EqualTo)                                  throw new ArgumentException(String.Join(" "' tokens' i' tokens.Length - i));                                current = (tok1 == "type")                                  ? (SelectionCriterion) new TypeCriterion                                      {                                          AttributeString = tokens[i + 2]'                                          Operator = c                                      }                                  : (SelectionCriterion) new AttributesCriterion                                      {                                          AttributeString = tokens[i + 2]'                                          Operator = c                                      };                              i += 2;                              stateStack.Push(ParseState.CriterionDone);                          }                          break;                        case "":                          // NOP                          stateStack.Push(ParseState.Whitespace);                          break;                        default:                          throw new ArgumentException("'" + tokens[i] + "'");                  }
Magic Number,Ionic,FileSelector,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\FileSelector.cs,_ParseCriterion,The following statement contains a magic number: switch (tok1)                  {                      case "and":                      case "xor":                      case "or":                          state = stateStack.Peek();                          if (state != ParseState.CriterionDone)                              throw new ArgumentException(String.Join(" "' tokens' i' tokens.Length - i));                            if (tokens.Length <= i + 3)                              throw new ArgumentException(String.Join(" "' tokens' i' tokens.Length - i));                            pendingConjunction = (LogicalConjunction)Enum.Parse(typeof(LogicalConjunction)' tokens[i].ToUpper()' true);                          current = new CompoundCriterion { Left = current' Right = null' Conjunction = pendingConjunction };                          stateStack.Push(state);                          stateStack.Push(ParseState.ConjunctionPending);                          critStack.Push(current);                          break;                        case "(":                          state = stateStack.Peek();                          if (state != ParseState.Start && state != ParseState.ConjunctionPending && state != ParseState.OpenParen)                              throw new ArgumentException(String.Join(" "' tokens' i' tokens.Length - i));                            if (tokens.Length <= i + 4)                              throw new ArgumentException(String.Join(" "' tokens' i' tokens.Length - i));                            stateStack.Push(ParseState.OpenParen);                          break;                        case ")":                          state = stateStack.Pop();                          if (stateStack.Peek() != ParseState.OpenParen)                              throw new ArgumentException(String.Join(" "' tokens' i' tokens.Length - i));                            stateStack.Pop();                          stateStack.Push(ParseState.CriterionDone);                          break;                        case "atime":                      case "ctime":                      case "mtime":                          if (tokens.Length <= i + 2)                              throw new ArgumentException(String.Join(" "' tokens' i' tokens.Length - i));                            DateTime t;                          try                          {                              t = DateTime.ParseExact(tokens[i + 2]' "yyyy-MM-dd-HH:mm:ss"' null);                          }                          catch (FormatException)                          {                              try                              {                                  t = DateTime.ParseExact(tokens[i + 2]' "yyyy/MM/dd-HH:mm:ss"' null);                              }                              catch (FormatException)                              {                                  try                                  {                                      t = DateTime.ParseExact(tokens[i + 2]' "yyyy/MM/dd"' null);                                  }                                  catch (FormatException)                                  {                                      try                                      {                                          t = DateTime.ParseExact(tokens[i + 2]' "MM/dd/yyyy"' null);                                      }                                      catch (FormatException)                                      {                                          t = DateTime.ParseExact(tokens[i + 2]' "yyyy-MM-dd"' null);                                      }                                  }                              }                          }                          t= DateTime.SpecifyKind(t' DateTimeKind.Local).ToUniversalTime();                          current = new TimeCriterion                          {                              Which = (WhichTime)Enum.Parse(typeof(WhichTime)' tokens[i]' true)'                              Operator = (ComparisonOperator)EnumUtil.Parse(typeof(ComparisonOperator)' tokens[i + 1])'                              Time = t                          };                          i += 2;                          stateStack.Push(ParseState.CriterionDone);                          break;                          case "length":                      case "size":                          if (tokens.Length <= i + 2)                              throw new ArgumentException(String.Join(" "' tokens' i' tokens.Length - i));                            Int64 sz = 0;                          string v = tokens[i + 2];                          if (v.ToUpper().EndsWith("K"))                              sz = Int64.Parse(v.Substring(0' v.Length - 1)) * 1024;                          else if (v.ToUpper().EndsWith("KB"))                              sz = Int64.Parse(v.Substring(0' v.Length - 2)) * 1024;                          else if (v.ToUpper().EndsWith("M"))                              sz = Int64.Parse(v.Substring(0' v.Length - 1)) * 1024 * 1024;                          else if (v.ToUpper().EndsWith("MB"))                              sz = Int64.Parse(v.Substring(0' v.Length - 2)) * 1024 * 1024;                          else if (v.ToUpper().EndsWith("G"))                              sz = Int64.Parse(v.Substring(0' v.Length - 1)) * 1024 * 1024 * 1024;                          else if (v.ToUpper().EndsWith("GB"))                              sz = Int64.Parse(v.Substring(0' v.Length - 2)) * 1024 * 1024 * 1024;                          else sz = Int64.Parse(tokens[i + 2]);                            current = new SizeCriterion                          {                              Size = sz'                              Operator = (ComparisonOperator)EnumUtil.Parse(typeof(ComparisonOperator)' tokens[i + 1])                          };                          i += 2;                          stateStack.Push(ParseState.CriterionDone);                          break;                        case "filename":                      case "name":                          {                              if (tokens.Length <= i + 2)                                  throw new ArgumentException(String.Join(" "' tokens' i' tokens.Length - i));                                ComparisonOperator c =                                  (ComparisonOperator)EnumUtil.Parse(typeof(ComparisonOperator)' tokens[i + 1]);                                if (c != ComparisonOperator.NotEqualTo && c != ComparisonOperator.EqualTo)                                  throw new ArgumentException(String.Join(" "' tokens' i' tokens.Length - i));                                string m = tokens[i + 2];                                // handle single-quoted filespecs (used to include                              // spaces in filename patterns)                              if (m.StartsWith("'") && m.EndsWith("'"))                              {                                  // trim off leading and trailing single quotes and                                  // revert the control characters to spaces.                                  m = m.Substring(1' m.Length - 2)                                      .Replace("\u0006"' " ");                              }                                // if (m.StartsWith("'"))                              //     m = m.Replace("\u0006"' " ");                                //Fix for Unix -> NormalizeCriteriaExpression replaces all slashes with backslashes                              if (Path.DirectorySeparatorChar == '/')                                  m = m.Replace('\\'' Path.DirectorySeparatorChar);                                current = new NameCriterion                              {                                  MatchingFileSpec = m'                                  Operator = c                              };                              i += 2;                              stateStack.Push(ParseState.CriterionDone);                          }                          break;                        case "attrs":                      case "attributes":                      case "type":                          {                              if (tokens.Length <= i + 2)                                  throw new ArgumentException(String.Join(" "' tokens' i' tokens.Length - i));                                ComparisonOperator c =                                  (ComparisonOperator)EnumUtil.Parse(typeof(ComparisonOperator)' tokens[i + 1]);                                if (c != ComparisonOperator.NotEqualTo && c != ComparisonOperator.EqualTo)                                  throw new ArgumentException(String.Join(" "' tokens' i' tokens.Length - i));                                current = (tok1 == "type")                                  ? (SelectionCriterion) new TypeCriterion                                      {                                          AttributeString = tokens[i + 2]'                                          Operator = c                                      }                                  : (SelectionCriterion) new AttributesCriterion                                      {                                          AttributeString = tokens[i + 2]'                                          Operator = c                                      };                              i += 2;                              stateStack.Push(ParseState.CriterionDone);                          }                          break;                        case "":                          // NOP                          stateStack.Push(ParseState.Whitespace);                          break;                        default:                          throw new ArgumentException("'" + tokens[i] + "'");                  }
Magic Number,Ionic,FileSelector,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\FileSelector.cs,_ParseCriterion,The following statement contains a magic number: switch (tok1)                  {                      case "and":                      case "xor":                      case "or":                          state = stateStack.Peek();                          if (state != ParseState.CriterionDone)                              throw new ArgumentException(String.Join(" "' tokens' i' tokens.Length - i));                            if (tokens.Length <= i + 3)                              throw new ArgumentException(String.Join(" "' tokens' i' tokens.Length - i));                            pendingConjunction = (LogicalConjunction)Enum.Parse(typeof(LogicalConjunction)' tokens[i].ToUpper()' true);                          current = new CompoundCriterion { Left = current' Right = null' Conjunction = pendingConjunction };                          stateStack.Push(state);                          stateStack.Push(ParseState.ConjunctionPending);                          critStack.Push(current);                          break;                        case "(":                          state = stateStack.Peek();                          if (state != ParseState.Start && state != ParseState.ConjunctionPending && state != ParseState.OpenParen)                              throw new ArgumentException(String.Join(" "' tokens' i' tokens.Length - i));                            if (tokens.Length <= i + 4)                              throw new ArgumentException(String.Join(" "' tokens' i' tokens.Length - i));                            stateStack.Push(ParseState.OpenParen);                          break;                        case ")":                          state = stateStack.Pop();                          if (stateStack.Peek() != ParseState.OpenParen)                              throw new ArgumentException(String.Join(" "' tokens' i' tokens.Length - i));                            stateStack.Pop();                          stateStack.Push(ParseState.CriterionDone);                          break;                        case "atime":                      case "ctime":                      case "mtime":                          if (tokens.Length <= i + 2)                              throw new ArgumentException(String.Join(" "' tokens' i' tokens.Length - i));                            DateTime t;                          try                          {                              t = DateTime.ParseExact(tokens[i + 2]' "yyyy-MM-dd-HH:mm:ss"' null);                          }                          catch (FormatException)                          {                              try                              {                                  t = DateTime.ParseExact(tokens[i + 2]' "yyyy/MM/dd-HH:mm:ss"' null);                              }                              catch (FormatException)                              {                                  try                                  {                                      t = DateTime.ParseExact(tokens[i + 2]' "yyyy/MM/dd"' null);                                  }                                  catch (FormatException)                                  {                                      try                                      {                                          t = DateTime.ParseExact(tokens[i + 2]' "MM/dd/yyyy"' null);                                      }                                      catch (FormatException)                                      {                                          t = DateTime.ParseExact(tokens[i + 2]' "yyyy-MM-dd"' null);                                      }                                  }                              }                          }                          t= DateTime.SpecifyKind(t' DateTimeKind.Local).ToUniversalTime();                          current = new TimeCriterion                          {                              Which = (WhichTime)Enum.Parse(typeof(WhichTime)' tokens[i]' true)'                              Operator = (ComparisonOperator)EnumUtil.Parse(typeof(ComparisonOperator)' tokens[i + 1])'                              Time = t                          };                          i += 2;                          stateStack.Push(ParseState.CriterionDone);                          break;                          case "length":                      case "size":                          if (tokens.Length <= i + 2)                              throw new ArgumentException(String.Join(" "' tokens' i' tokens.Length - i));                            Int64 sz = 0;                          string v = tokens[i + 2];                          if (v.ToUpper().EndsWith("K"))                              sz = Int64.Parse(v.Substring(0' v.Length - 1)) * 1024;                          else if (v.ToUpper().EndsWith("KB"))                              sz = Int64.Parse(v.Substring(0' v.Length - 2)) * 1024;                          else if (v.ToUpper().EndsWith("M"))                              sz = Int64.Parse(v.Substring(0' v.Length - 1)) * 1024 * 1024;                          else if (v.ToUpper().EndsWith("MB"))                              sz = Int64.Parse(v.Substring(0' v.Length - 2)) * 1024 * 1024;                          else if (v.ToUpper().EndsWith("G"))                              sz = Int64.Parse(v.Substring(0' v.Length - 1)) * 1024 * 1024 * 1024;                          else if (v.ToUpper().EndsWith("GB"))                              sz = Int64.Parse(v.Substring(0' v.Length - 2)) * 1024 * 1024 * 1024;                          else sz = Int64.Parse(tokens[i + 2]);                            current = new SizeCriterion                          {                              Size = sz'                              Operator = (ComparisonOperator)EnumUtil.Parse(typeof(ComparisonOperator)' tokens[i + 1])                          };                          i += 2;                          stateStack.Push(ParseState.CriterionDone);                          break;                        case "filename":                      case "name":                          {                              if (tokens.Length <= i + 2)                                  throw new ArgumentException(String.Join(" "' tokens' i' tokens.Length - i));                                ComparisonOperator c =                                  (ComparisonOperator)EnumUtil.Parse(typeof(ComparisonOperator)' tokens[i + 1]);                                if (c != ComparisonOperator.NotEqualTo && c != ComparisonOperator.EqualTo)                                  throw new ArgumentException(String.Join(" "' tokens' i' tokens.Length - i));                                string m = tokens[i + 2];                                // handle single-quoted filespecs (used to include                              // spaces in filename patterns)                              if (m.StartsWith("'") && m.EndsWith("'"))                              {                                  // trim off leading and trailing single quotes and                                  // revert the control characters to spaces.                                  m = m.Substring(1' m.Length - 2)                                      .Replace("\u0006"' " ");                              }                                // if (m.StartsWith("'"))                              //     m = m.Replace("\u0006"' " ");                                //Fix for Unix -> NormalizeCriteriaExpression replaces all slashes with backslashes                              if (Path.DirectorySeparatorChar == '/')                                  m = m.Replace('\\'' Path.DirectorySeparatorChar);                                current = new NameCriterion                              {                                  MatchingFileSpec = m'                                  Operator = c                              };                              i += 2;                              stateStack.Push(ParseState.CriterionDone);                          }                          break;                        case "attrs":                      case "attributes":                      case "type":                          {                              if (tokens.Length <= i + 2)                                  throw new ArgumentException(String.Join(" "' tokens' i' tokens.Length - i));                                ComparisonOperator c =                                  (ComparisonOperator)EnumUtil.Parse(typeof(ComparisonOperator)' tokens[i + 1]);                                if (c != ComparisonOperator.NotEqualTo && c != ComparisonOperator.EqualTo)                                  throw new ArgumentException(String.Join(" "' tokens' i' tokens.Length - i));                                current = (tok1 == "type")                                  ? (SelectionCriterion) new TypeCriterion                                      {                                          AttributeString = tokens[i + 2]'                                          Operator = c                                      }                                  : (SelectionCriterion) new AttributesCriterion                                      {                                          AttributeString = tokens[i + 2]'                                          Operator = c                                      };                              i += 2;                              stateStack.Push(ParseState.CriterionDone);                          }                          break;                        case "":                          // NOP                          stateStack.Push(ParseState.Whitespace);                          break;                        default:                          throw new ArgumentException("'" + tokens[i] + "'");                  }
Magic Number,Ionic,FileSelector,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\FileSelector.cs,_ParseCriterion,The following statement contains a magic number: switch (tok1)                  {                      case "and":                      case "xor":                      case "or":                          state = stateStack.Peek();                          if (state != ParseState.CriterionDone)                              throw new ArgumentException(String.Join(" "' tokens' i' tokens.Length - i));                            if (tokens.Length <= i + 3)                              throw new ArgumentException(String.Join(" "' tokens' i' tokens.Length - i));                            pendingConjunction = (LogicalConjunction)Enum.Parse(typeof(LogicalConjunction)' tokens[i].ToUpper()' true);                          current = new CompoundCriterion { Left = current' Right = null' Conjunction = pendingConjunction };                          stateStack.Push(state);                          stateStack.Push(ParseState.ConjunctionPending);                          critStack.Push(current);                          break;                        case "(":                          state = stateStack.Peek();                          if (state != ParseState.Start && state != ParseState.ConjunctionPending && state != ParseState.OpenParen)                              throw new ArgumentException(String.Join(" "' tokens' i' tokens.Length - i));                            if (tokens.Length <= i + 4)                              throw new ArgumentException(String.Join(" "' tokens' i' tokens.Length - i));                            stateStack.Push(ParseState.OpenParen);                          break;                        case ")":                          state = stateStack.Pop();                          if (stateStack.Peek() != ParseState.OpenParen)                              throw new ArgumentException(String.Join(" "' tokens' i' tokens.Length - i));                            stateStack.Pop();                          stateStack.Push(ParseState.CriterionDone);                          break;                        case "atime":                      case "ctime":                      case "mtime":                          if (tokens.Length <= i + 2)                              throw new ArgumentException(String.Join(" "' tokens' i' tokens.Length - i));                            DateTime t;                          try                          {                              t = DateTime.ParseExact(tokens[i + 2]' "yyyy-MM-dd-HH:mm:ss"' null);                          }                          catch (FormatException)                          {                              try                              {                                  t = DateTime.ParseExact(tokens[i + 2]' "yyyy/MM/dd-HH:mm:ss"' null);                              }                              catch (FormatException)                              {                                  try                                  {                                      t = DateTime.ParseExact(tokens[i + 2]' "yyyy/MM/dd"' null);                                  }                                  catch (FormatException)                                  {                                      try                                      {                                          t = DateTime.ParseExact(tokens[i + 2]' "MM/dd/yyyy"' null);                                      }                                      catch (FormatException)                                      {                                          t = DateTime.ParseExact(tokens[i + 2]' "yyyy-MM-dd"' null);                                      }                                  }                              }                          }                          t= DateTime.SpecifyKind(t' DateTimeKind.Local).ToUniversalTime();                          current = new TimeCriterion                          {                              Which = (WhichTime)Enum.Parse(typeof(WhichTime)' tokens[i]' true)'                              Operator = (ComparisonOperator)EnumUtil.Parse(typeof(ComparisonOperator)' tokens[i + 1])'                              Time = t                          };                          i += 2;                          stateStack.Push(ParseState.CriterionDone);                          break;                          case "length":                      case "size":                          if (tokens.Length <= i + 2)                              throw new ArgumentException(String.Join(" "' tokens' i' tokens.Length - i));                            Int64 sz = 0;                          string v = tokens[i + 2];                          if (v.ToUpper().EndsWith("K"))                              sz = Int64.Parse(v.Substring(0' v.Length - 1)) * 1024;                          else if (v.ToUpper().EndsWith("KB"))                              sz = Int64.Parse(v.Substring(0' v.Length - 2)) * 1024;                          else if (v.ToUpper().EndsWith("M"))                              sz = Int64.Parse(v.Substring(0' v.Length - 1)) * 1024 * 1024;                          else if (v.ToUpper().EndsWith("MB"))                              sz = Int64.Parse(v.Substring(0' v.Length - 2)) * 1024 * 1024;                          else if (v.ToUpper().EndsWith("G"))                              sz = Int64.Parse(v.Substring(0' v.Length - 1)) * 1024 * 1024 * 1024;                          else if (v.ToUpper().EndsWith("GB"))                              sz = Int64.Parse(v.Substring(0' v.Length - 2)) * 1024 * 1024 * 1024;                          else sz = Int64.Parse(tokens[i + 2]);                            current = new SizeCriterion                          {                              Size = sz'                              Operator = (ComparisonOperator)EnumUtil.Parse(typeof(ComparisonOperator)' tokens[i + 1])                          };                          i += 2;                          stateStack.Push(ParseState.CriterionDone);                          break;                        case "filename":                      case "name":                          {                              if (tokens.Length <= i + 2)                                  throw new ArgumentException(String.Join(" "' tokens' i' tokens.Length - i));                                ComparisonOperator c =                                  (ComparisonOperator)EnumUtil.Parse(typeof(ComparisonOperator)' tokens[i + 1]);                                if (c != ComparisonOperator.NotEqualTo && c != ComparisonOperator.EqualTo)                                  throw new ArgumentException(String.Join(" "' tokens' i' tokens.Length - i));                                string m = tokens[i + 2];                                // handle single-quoted filespecs (used to include                              // spaces in filename patterns)                              if (m.StartsWith("'") && m.EndsWith("'"))                              {                                  // trim off leading and trailing single quotes and                                  // revert the control characters to spaces.                                  m = m.Substring(1' m.Length - 2)                                      .Replace("\u0006"' " ");                              }                                // if (m.StartsWith("'"))                              //     m = m.Replace("\u0006"' " ");                                //Fix for Unix -> NormalizeCriteriaExpression replaces all slashes with backslashes                              if (Path.DirectorySeparatorChar == '/')                                  m = m.Replace('\\'' Path.DirectorySeparatorChar);                                current = new NameCriterion                              {                                  MatchingFileSpec = m'                                  Operator = c                              };                              i += 2;                              stateStack.Push(ParseState.CriterionDone);                          }                          break;                        case "attrs":                      case "attributes":                      case "type":                          {                              if (tokens.Length <= i + 2)                                  throw new ArgumentException(String.Join(" "' tokens' i' tokens.Length - i));                                ComparisonOperator c =                                  (ComparisonOperator)EnumUtil.Parse(typeof(ComparisonOperator)' tokens[i + 1]);                                if (c != ComparisonOperator.NotEqualTo && c != ComparisonOperator.EqualTo)                                  throw new ArgumentException(String.Join(" "' tokens' i' tokens.Length - i));                                current = (tok1 == "type")                                  ? (SelectionCriterion) new TypeCriterion                                      {                                          AttributeString = tokens[i + 2]'                                          Operator = c                                      }                                  : (SelectionCriterion) new AttributesCriterion                                      {                                          AttributeString = tokens[i + 2]'                                          Operator = c                                      };                              i += 2;                              stateStack.Push(ParseState.CriterionDone);                          }                          break;                        case "":                          // NOP                          stateStack.Push(ParseState.Whitespace);                          break;                        default:                          throw new ArgumentException("'" + tokens[i] + "'");                  }
Magic Number,Ionic,FileSelector,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\FileSelector.cs,_ParseCriterion,The following statement contains a magic number: switch (tok1)                  {                      case "and":                      case "xor":                      case "or":                          state = stateStack.Peek();                          if (state != ParseState.CriterionDone)                              throw new ArgumentException(String.Join(" "' tokens' i' tokens.Length - i));                            if (tokens.Length <= i + 3)                              throw new ArgumentException(String.Join(" "' tokens' i' tokens.Length - i));                            pendingConjunction = (LogicalConjunction)Enum.Parse(typeof(LogicalConjunction)' tokens[i].ToUpper()' true);                          current = new CompoundCriterion { Left = current' Right = null' Conjunction = pendingConjunction };                          stateStack.Push(state);                          stateStack.Push(ParseState.ConjunctionPending);                          critStack.Push(current);                          break;                        case "(":                          state = stateStack.Peek();                          if (state != ParseState.Start && state != ParseState.ConjunctionPending && state != ParseState.OpenParen)                              throw new ArgumentException(String.Join(" "' tokens' i' tokens.Length - i));                            if (tokens.Length <= i + 4)                              throw new ArgumentException(String.Join(" "' tokens' i' tokens.Length - i));                            stateStack.Push(ParseState.OpenParen);                          break;                        case ")":                          state = stateStack.Pop();                          if (stateStack.Peek() != ParseState.OpenParen)                              throw new ArgumentException(String.Join(" "' tokens' i' tokens.Length - i));                            stateStack.Pop();                          stateStack.Push(ParseState.CriterionDone);                          break;                        case "atime":                      case "ctime":                      case "mtime":                          if (tokens.Length <= i + 2)                              throw new ArgumentException(String.Join(" "' tokens' i' tokens.Length - i));                            DateTime t;                          try                          {                              t = DateTime.ParseExact(tokens[i + 2]' "yyyy-MM-dd-HH:mm:ss"' null);                          }                          catch (FormatException)                          {                              try                              {                                  t = DateTime.ParseExact(tokens[i + 2]' "yyyy/MM/dd-HH:mm:ss"' null);                              }                              catch (FormatException)                              {                                  try                                  {                                      t = DateTime.ParseExact(tokens[i + 2]' "yyyy/MM/dd"' null);                                  }                                  catch (FormatException)                                  {                                      try                                      {                                          t = DateTime.ParseExact(tokens[i + 2]' "MM/dd/yyyy"' null);                                      }                                      catch (FormatException)                                      {                                          t = DateTime.ParseExact(tokens[i + 2]' "yyyy-MM-dd"' null);                                      }                                  }                              }                          }                          t= DateTime.SpecifyKind(t' DateTimeKind.Local).ToUniversalTime();                          current = new TimeCriterion                          {                              Which = (WhichTime)Enum.Parse(typeof(WhichTime)' tokens[i]' true)'                              Operator = (ComparisonOperator)EnumUtil.Parse(typeof(ComparisonOperator)' tokens[i + 1])'                              Time = t                          };                          i += 2;                          stateStack.Push(ParseState.CriterionDone);                          break;                          case "length":                      case "size":                          if (tokens.Length <= i + 2)                              throw new ArgumentException(String.Join(" "' tokens' i' tokens.Length - i));                            Int64 sz = 0;                          string v = tokens[i + 2];                          if (v.ToUpper().EndsWith("K"))                              sz = Int64.Parse(v.Substring(0' v.Length - 1)) * 1024;                          else if (v.ToUpper().EndsWith("KB"))                              sz = Int64.Parse(v.Substring(0' v.Length - 2)) * 1024;                          else if (v.ToUpper().EndsWith("M"))                              sz = Int64.Parse(v.Substring(0' v.Length - 1)) * 1024 * 1024;                          else if (v.ToUpper().EndsWith("MB"))                              sz = Int64.Parse(v.Substring(0' v.Length - 2)) * 1024 * 1024;                          else if (v.ToUpper().EndsWith("G"))                              sz = Int64.Parse(v.Substring(0' v.Length - 1)) * 1024 * 1024 * 1024;                          else if (v.ToUpper().EndsWith("GB"))                              sz = Int64.Parse(v.Substring(0' v.Length - 2)) * 1024 * 1024 * 1024;                          else sz = Int64.Parse(tokens[i + 2]);                            current = new SizeCriterion                          {                              Size = sz'                              Operator = (ComparisonOperator)EnumUtil.Parse(typeof(ComparisonOperator)' tokens[i + 1])                          };                          i += 2;                          stateStack.Push(ParseState.CriterionDone);                          break;                        case "filename":                      case "name":                          {                              if (tokens.Length <= i + 2)                                  throw new ArgumentException(String.Join(" "' tokens' i' tokens.Length - i));                                ComparisonOperator c =                                  (ComparisonOperator)EnumUtil.Parse(typeof(ComparisonOperator)' tokens[i + 1]);                                if (c != ComparisonOperator.NotEqualTo && c != ComparisonOperator.EqualTo)                                  throw new ArgumentException(String.Join(" "' tokens' i' tokens.Length - i));                                string m = tokens[i + 2];                                // handle single-quoted filespecs (used to include                              // spaces in filename patterns)                              if (m.StartsWith("'") && m.EndsWith("'"))                              {                                  // trim off leading and trailing single quotes and                                  // revert the control characters to spaces.                                  m = m.Substring(1' m.Length - 2)                                      .Replace("\u0006"' " ");                              }                                // if (m.StartsWith("'"))                              //     m = m.Replace("\u0006"' " ");                                //Fix for Unix -> NormalizeCriteriaExpression replaces all slashes with backslashes                              if (Path.DirectorySeparatorChar == '/')                                  m = m.Replace('\\'' Path.DirectorySeparatorChar);                                current = new NameCriterion                              {                                  MatchingFileSpec = m'                                  Operator = c                              };                              i += 2;                              stateStack.Push(ParseState.CriterionDone);                          }                          break;                        case "attrs":                      case "attributes":                      case "type":                          {                              if (tokens.Length <= i + 2)                                  throw new ArgumentException(String.Join(" "' tokens' i' tokens.Length - i));                                ComparisonOperator c =                                  (ComparisonOperator)EnumUtil.Parse(typeof(ComparisonOperator)' tokens[i + 1]);                                if (c != ComparisonOperator.NotEqualTo && c != ComparisonOperator.EqualTo)                                  throw new ArgumentException(String.Join(" "' tokens' i' tokens.Length - i));                                current = (tok1 == "type")                                  ? (SelectionCriterion) new TypeCriterion                                      {                                          AttributeString = tokens[i + 2]'                                          Operator = c                                      }                                  : (SelectionCriterion) new AttributesCriterion                                      {                                          AttributeString = tokens[i + 2]'                                          Operator = c                                      };                              i += 2;                              stateStack.Push(ParseState.CriterionDone);                          }                          break;                        case "":                          // NOP                          stateStack.Push(ParseState.Whitespace);                          break;                        default:                          throw new ArgumentException("'" + tokens[i] + "'");                  }
Magic Number,Ionic,FileSelector,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\FileSelector.cs,_ParseCriterion,The following statement contains a magic number: switch (tok1)                  {                      case "and":                      case "xor":                      case "or":                          state = stateStack.Peek();                          if (state != ParseState.CriterionDone)                              throw new ArgumentException(String.Join(" "' tokens' i' tokens.Length - i));                            if (tokens.Length <= i + 3)                              throw new ArgumentException(String.Join(" "' tokens' i' tokens.Length - i));                            pendingConjunction = (LogicalConjunction)Enum.Parse(typeof(LogicalConjunction)' tokens[i].ToUpper()' true);                          current = new CompoundCriterion { Left = current' Right = null' Conjunction = pendingConjunction };                          stateStack.Push(state);                          stateStack.Push(ParseState.ConjunctionPending);                          critStack.Push(current);                          break;                        case "(":                          state = stateStack.Peek();                          if (state != ParseState.Start && state != ParseState.ConjunctionPending && state != ParseState.OpenParen)                              throw new ArgumentException(String.Join(" "' tokens' i' tokens.Length - i));                            if (tokens.Length <= i + 4)                              throw new ArgumentException(String.Join(" "' tokens' i' tokens.Length - i));                            stateStack.Push(ParseState.OpenParen);                          break;                        case ")":                          state = stateStack.Pop();                          if (stateStack.Peek() != ParseState.OpenParen)                              throw new ArgumentException(String.Join(" "' tokens' i' tokens.Length - i));                            stateStack.Pop();                          stateStack.Push(ParseState.CriterionDone);                          break;                        case "atime":                      case "ctime":                      case "mtime":                          if (tokens.Length <= i + 2)                              throw new ArgumentException(String.Join(" "' tokens' i' tokens.Length - i));                            DateTime t;                          try                          {                              t = DateTime.ParseExact(tokens[i + 2]' "yyyy-MM-dd-HH:mm:ss"' null);                          }                          catch (FormatException)                          {                              try                              {                                  t = DateTime.ParseExact(tokens[i + 2]' "yyyy/MM/dd-HH:mm:ss"' null);                              }                              catch (FormatException)                              {                                  try                                  {                                      t = DateTime.ParseExact(tokens[i + 2]' "yyyy/MM/dd"' null);                                  }                                  catch (FormatException)                                  {                                      try                                      {                                          t = DateTime.ParseExact(tokens[i + 2]' "MM/dd/yyyy"' null);                                      }                                      catch (FormatException)                                      {                                          t = DateTime.ParseExact(tokens[i + 2]' "yyyy-MM-dd"' null);                                      }                                  }                              }                          }                          t= DateTime.SpecifyKind(t' DateTimeKind.Local).ToUniversalTime();                          current = new TimeCriterion                          {                              Which = (WhichTime)Enum.Parse(typeof(WhichTime)' tokens[i]' true)'                              Operator = (ComparisonOperator)EnumUtil.Parse(typeof(ComparisonOperator)' tokens[i + 1])'                              Time = t                          };                          i += 2;                          stateStack.Push(ParseState.CriterionDone);                          break;                          case "length":                      case "size":                          if (tokens.Length <= i + 2)                              throw new ArgumentException(String.Join(" "' tokens' i' tokens.Length - i));                            Int64 sz = 0;                          string v = tokens[i + 2];                          if (v.ToUpper().EndsWith("K"))                              sz = Int64.Parse(v.Substring(0' v.Length - 1)) * 1024;                          else if (v.ToUpper().EndsWith("KB"))                              sz = Int64.Parse(v.Substring(0' v.Length - 2)) * 1024;                          else if (v.ToUpper().EndsWith("M"))                              sz = Int64.Parse(v.Substring(0' v.Length - 1)) * 1024 * 1024;                          else if (v.ToUpper().EndsWith("MB"))                              sz = Int64.Parse(v.Substring(0' v.Length - 2)) * 1024 * 1024;                          else if (v.ToUpper().EndsWith("G"))                              sz = Int64.Parse(v.Substring(0' v.Length - 1)) * 1024 * 1024 * 1024;                          else if (v.ToUpper().EndsWith("GB"))                              sz = Int64.Parse(v.Substring(0' v.Length - 2)) * 1024 * 1024 * 1024;                          else sz = Int64.Parse(tokens[i + 2]);                            current = new SizeCriterion                          {                              Size = sz'                              Operator = (ComparisonOperator)EnumUtil.Parse(typeof(ComparisonOperator)' tokens[i + 1])                          };                          i += 2;                          stateStack.Push(ParseState.CriterionDone);                          break;                        case "filename":                      case "name":                          {                              if (tokens.Length <= i + 2)                                  throw new ArgumentException(String.Join(" "' tokens' i' tokens.Length - i));                                ComparisonOperator c =                                  (ComparisonOperator)EnumUtil.Parse(typeof(ComparisonOperator)' tokens[i + 1]);                                if (c != ComparisonOperator.NotEqualTo && c != ComparisonOperator.EqualTo)                                  throw new ArgumentException(String.Join(" "' tokens' i' tokens.Length - i));                                string m = tokens[i + 2];                                // handle single-quoted filespecs (used to include                              // spaces in filename patterns)                              if (m.StartsWith("'") && m.EndsWith("'"))                              {                                  // trim off leading and trailing single quotes and                                  // revert the control characters to spaces.                                  m = m.Substring(1' m.Length - 2)                                      .Replace("\u0006"' " ");                              }                                // if (m.StartsWith("'"))                              //     m = m.Replace("\u0006"' " ");                                //Fix for Unix -> NormalizeCriteriaExpression replaces all slashes with backslashes                              if (Path.DirectorySeparatorChar == '/')                                  m = m.Replace('\\'' Path.DirectorySeparatorChar);                                current = new NameCriterion                              {                                  MatchingFileSpec = m'                                  Operator = c                              };                              i += 2;                              stateStack.Push(ParseState.CriterionDone);                          }                          break;                        case "attrs":                      case "attributes":                      case "type":                          {                              if (tokens.Length <= i + 2)                                  throw new ArgumentException(String.Join(" "' tokens' i' tokens.Length - i));                                ComparisonOperator c =                                  (ComparisonOperator)EnumUtil.Parse(typeof(ComparisonOperator)' tokens[i + 1]);                                if (c != ComparisonOperator.NotEqualTo && c != ComparisonOperator.EqualTo)                                  throw new ArgumentException(String.Join(" "' tokens' i' tokens.Length - i));                                current = (tok1 == "type")                                  ? (SelectionCriterion) new TypeCriterion                                      {                                          AttributeString = tokens[i + 2]'                                          Operator = c                                      }                                  : (SelectionCriterion) new AttributesCriterion                                      {                                          AttributeString = tokens[i + 2]'                                          Operator = c                                      };                              i += 2;                              stateStack.Push(ParseState.CriterionDone);                          }                          break;                        case "":                          // NOP                          stateStack.Push(ParseState.Whitespace);                          break;                        default:                          throw new ArgumentException("'" + tokens[i] + "'");                  }
Magic Number,Ionic,FileSelector,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\FileSelector.cs,_ParseCriterion,The following statement contains a magic number: switch (tok1)                  {                      case "and":                      case "xor":                      case "or":                          state = stateStack.Peek();                          if (state != ParseState.CriterionDone)                              throw new ArgumentException(String.Join(" "' tokens' i' tokens.Length - i));                            if (tokens.Length <= i + 3)                              throw new ArgumentException(String.Join(" "' tokens' i' tokens.Length - i));                            pendingConjunction = (LogicalConjunction)Enum.Parse(typeof(LogicalConjunction)' tokens[i].ToUpper()' true);                          current = new CompoundCriterion { Left = current' Right = null' Conjunction = pendingConjunction };                          stateStack.Push(state);                          stateStack.Push(ParseState.ConjunctionPending);                          critStack.Push(current);                          break;                        case "(":                          state = stateStack.Peek();                          if (state != ParseState.Start && state != ParseState.ConjunctionPending && state != ParseState.OpenParen)                              throw new ArgumentException(String.Join(" "' tokens' i' tokens.Length - i));                            if (tokens.Length <= i + 4)                              throw new ArgumentException(String.Join(" "' tokens' i' tokens.Length - i));                            stateStack.Push(ParseState.OpenParen);                          break;                        case ")":                          state = stateStack.Pop();                          if (stateStack.Peek() != ParseState.OpenParen)                              throw new ArgumentException(String.Join(" "' tokens' i' tokens.Length - i));                            stateStack.Pop();                          stateStack.Push(ParseState.CriterionDone);                          break;                        case "atime":                      case "ctime":                      case "mtime":                          if (tokens.Length <= i + 2)                              throw new ArgumentException(String.Join(" "' tokens' i' tokens.Length - i));                            DateTime t;                          try                          {                              t = DateTime.ParseExact(tokens[i + 2]' "yyyy-MM-dd-HH:mm:ss"' null);                          }                          catch (FormatException)                          {                              try                              {                                  t = DateTime.ParseExact(tokens[i + 2]' "yyyy/MM/dd-HH:mm:ss"' null);                              }                              catch (FormatException)                              {                                  try                                  {                                      t = DateTime.ParseExact(tokens[i + 2]' "yyyy/MM/dd"' null);                                  }                                  catch (FormatException)                                  {                                      try                                      {                                          t = DateTime.ParseExact(tokens[i + 2]' "MM/dd/yyyy"' null);                                      }                                      catch (FormatException)                                      {                                          t = DateTime.ParseExact(tokens[i + 2]' "yyyy-MM-dd"' null);                                      }                                  }                              }                          }                          t= DateTime.SpecifyKind(t' DateTimeKind.Local).ToUniversalTime();                          current = new TimeCriterion                          {                              Which = (WhichTime)Enum.Parse(typeof(WhichTime)' tokens[i]' true)'                              Operator = (ComparisonOperator)EnumUtil.Parse(typeof(ComparisonOperator)' tokens[i + 1])'                              Time = t                          };                          i += 2;                          stateStack.Push(ParseState.CriterionDone);                          break;                          case "length":                      case "size":                          if (tokens.Length <= i + 2)                              throw new ArgumentException(String.Join(" "' tokens' i' tokens.Length - i));                            Int64 sz = 0;                          string v = tokens[i + 2];                          if (v.ToUpper().EndsWith("K"))                              sz = Int64.Parse(v.Substring(0' v.Length - 1)) * 1024;                          else if (v.ToUpper().EndsWith("KB"))                              sz = Int64.Parse(v.Substring(0' v.Length - 2)) * 1024;                          else if (v.ToUpper().EndsWith("M"))                              sz = Int64.Parse(v.Substring(0' v.Length - 1)) * 1024 * 1024;                          else if (v.ToUpper().EndsWith("MB"))                              sz = Int64.Parse(v.Substring(0' v.Length - 2)) * 1024 * 1024;                          else if (v.ToUpper().EndsWith("G"))                              sz = Int64.Parse(v.Substring(0' v.Length - 1)) * 1024 * 1024 * 1024;                          else if (v.ToUpper().EndsWith("GB"))                              sz = Int64.Parse(v.Substring(0' v.Length - 2)) * 1024 * 1024 * 1024;                          else sz = Int64.Parse(tokens[i + 2]);                            current = new SizeCriterion                          {                              Size = sz'                              Operator = (ComparisonOperator)EnumUtil.Parse(typeof(ComparisonOperator)' tokens[i + 1])                          };                          i += 2;                          stateStack.Push(ParseState.CriterionDone);                          break;                        case "filename":                      case "name":                          {                              if (tokens.Length <= i + 2)                                  throw new ArgumentException(String.Join(" "' tokens' i' tokens.Length - i));                                ComparisonOperator c =                                  (ComparisonOperator)EnumUtil.Parse(typeof(ComparisonOperator)' tokens[i + 1]);                                if (c != ComparisonOperator.NotEqualTo && c != ComparisonOperator.EqualTo)                                  throw new ArgumentException(String.Join(" "' tokens' i' tokens.Length - i));                                string m = tokens[i + 2];                                // handle single-quoted filespecs (used to include                              // spaces in filename patterns)                              if (m.StartsWith("'") && m.EndsWith("'"))                              {                                  // trim off leading and trailing single quotes and                                  // revert the control characters to spaces.                                  m = m.Substring(1' m.Length - 2)                                      .Replace("\u0006"' " ");                              }                                // if (m.StartsWith("'"))                              //     m = m.Replace("\u0006"' " ");                                //Fix for Unix -> NormalizeCriteriaExpression replaces all slashes with backslashes                              if (Path.DirectorySeparatorChar == '/')                                  m = m.Replace('\\'' Path.DirectorySeparatorChar);                                current = new NameCriterion                              {                                  MatchingFileSpec = m'                                  Operator = c                              };                              i += 2;                              stateStack.Push(ParseState.CriterionDone);                          }                          break;                        case "attrs":                      case "attributes":                      case "type":                          {                              if (tokens.Length <= i + 2)                                  throw new ArgumentException(String.Join(" "' tokens' i' tokens.Length - i));                                ComparisonOperator c =                                  (ComparisonOperator)EnumUtil.Parse(typeof(ComparisonOperator)' tokens[i + 1]);                                if (c != ComparisonOperator.NotEqualTo && c != ComparisonOperator.EqualTo)                                  throw new ArgumentException(String.Join(" "' tokens' i' tokens.Length - i));                                current = (tok1 == "type")                                  ? (SelectionCriterion) new TypeCriterion                                      {                                          AttributeString = tokens[i + 2]'                                          Operator = c                                      }                                  : (SelectionCriterion) new AttributesCriterion                                      {                                          AttributeString = tokens[i + 2]'                                          Operator = c                                      };                              i += 2;                              stateStack.Push(ParseState.CriterionDone);                          }                          break;                        case "":                          // NOP                          stateStack.Push(ParseState.Whitespace);                          break;                        default:                          throw new ArgumentException("'" + tokens[i] + "'");                  }
Magic Number,Ionic,FileSelector,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\FileSelector.cs,_ParseCriterion,The following statement contains a magic number: switch (tok1)                  {                      case "and":                      case "xor":                      case "or":                          state = stateStack.Peek();                          if (state != ParseState.CriterionDone)                              throw new ArgumentException(String.Join(" "' tokens' i' tokens.Length - i));                            if (tokens.Length <= i + 3)                              throw new ArgumentException(String.Join(" "' tokens' i' tokens.Length - i));                            pendingConjunction = (LogicalConjunction)Enum.Parse(typeof(LogicalConjunction)' tokens[i].ToUpper()' true);                          current = new CompoundCriterion { Left = current' Right = null' Conjunction = pendingConjunction };                          stateStack.Push(state);                          stateStack.Push(ParseState.ConjunctionPending);                          critStack.Push(current);                          break;                        case "(":                          state = stateStack.Peek();                          if (state != ParseState.Start && state != ParseState.ConjunctionPending && state != ParseState.OpenParen)                              throw new ArgumentException(String.Join(" "' tokens' i' tokens.Length - i));                            if (tokens.Length <= i + 4)                              throw new ArgumentException(String.Join(" "' tokens' i' tokens.Length - i));                            stateStack.Push(ParseState.OpenParen);                          break;                        case ")":                          state = stateStack.Pop();                          if (stateStack.Peek() != ParseState.OpenParen)                              throw new ArgumentException(String.Join(" "' tokens' i' tokens.Length - i));                            stateStack.Pop();                          stateStack.Push(ParseState.CriterionDone);                          break;                        case "atime":                      case "ctime":                      case "mtime":                          if (tokens.Length <= i + 2)                              throw new ArgumentException(String.Join(" "' tokens' i' tokens.Length - i));                            DateTime t;                          try                          {                              t = DateTime.ParseExact(tokens[i + 2]' "yyyy-MM-dd-HH:mm:ss"' null);                          }                          catch (FormatException)                          {                              try                              {                                  t = DateTime.ParseExact(tokens[i + 2]' "yyyy/MM/dd-HH:mm:ss"' null);                              }                              catch (FormatException)                              {                                  try                                  {                                      t = DateTime.ParseExact(tokens[i + 2]' "yyyy/MM/dd"' null);                                  }                                  catch (FormatException)                                  {                                      try                                      {                                          t = DateTime.ParseExact(tokens[i + 2]' "MM/dd/yyyy"' null);                                      }                                      catch (FormatException)                                      {                                          t = DateTime.ParseExact(tokens[i + 2]' "yyyy-MM-dd"' null);                                      }                                  }                              }                          }                          t= DateTime.SpecifyKind(t' DateTimeKind.Local).ToUniversalTime();                          current = new TimeCriterion                          {                              Which = (WhichTime)Enum.Parse(typeof(WhichTime)' tokens[i]' true)'                              Operator = (ComparisonOperator)EnumUtil.Parse(typeof(ComparisonOperator)' tokens[i + 1])'                              Time = t                          };                          i += 2;                          stateStack.Push(ParseState.CriterionDone);                          break;                          case "length":                      case "size":                          if (tokens.Length <= i + 2)                              throw new ArgumentException(String.Join(" "' tokens' i' tokens.Length - i));                            Int64 sz = 0;                          string v = tokens[i + 2];                          if (v.ToUpper().EndsWith("K"))                              sz = Int64.Parse(v.Substring(0' v.Length - 1)) * 1024;                          else if (v.ToUpper().EndsWith("KB"))                              sz = Int64.Parse(v.Substring(0' v.Length - 2)) * 1024;                          else if (v.ToUpper().EndsWith("M"))                              sz = Int64.Parse(v.Substring(0' v.Length - 1)) * 1024 * 1024;                          else if (v.ToUpper().EndsWith("MB"))                              sz = Int64.Parse(v.Substring(0' v.Length - 2)) * 1024 * 1024;                          else if (v.ToUpper().EndsWith("G"))                              sz = Int64.Parse(v.Substring(0' v.Length - 1)) * 1024 * 1024 * 1024;                          else if (v.ToUpper().EndsWith("GB"))                              sz = Int64.Parse(v.Substring(0' v.Length - 2)) * 1024 * 1024 * 1024;                          else sz = Int64.Parse(tokens[i + 2]);                            current = new SizeCriterion                          {                              Size = sz'                              Operator = (ComparisonOperator)EnumUtil.Parse(typeof(ComparisonOperator)' tokens[i + 1])                          };                          i += 2;                          stateStack.Push(ParseState.CriterionDone);                          break;                        case "filename":                      case "name":                          {                              if (tokens.Length <= i + 2)                                  throw new ArgumentException(String.Join(" "' tokens' i' tokens.Length - i));                                ComparisonOperator c =                                  (ComparisonOperator)EnumUtil.Parse(typeof(ComparisonOperator)' tokens[i + 1]);                                if (c != ComparisonOperator.NotEqualTo && c != ComparisonOperator.EqualTo)                                  throw new ArgumentException(String.Join(" "' tokens' i' tokens.Length - i));                                string m = tokens[i + 2];                                // handle single-quoted filespecs (used to include                              // spaces in filename patterns)                              if (m.StartsWith("'") && m.EndsWith("'"))                              {                                  // trim off leading and trailing single quotes and                                  // revert the control characters to spaces.                                  m = m.Substring(1' m.Length - 2)                                      .Replace("\u0006"' " ");                              }                                // if (m.StartsWith("'"))                              //     m = m.Replace("\u0006"' " ");                                //Fix for Unix -> NormalizeCriteriaExpression replaces all slashes with backslashes                              if (Path.DirectorySeparatorChar == '/')                                  m = m.Replace('\\'' Path.DirectorySeparatorChar);                                current = new NameCriterion                              {                                  MatchingFileSpec = m'                                  Operator = c                              };                              i += 2;                              stateStack.Push(ParseState.CriterionDone);                          }                          break;                        case "attrs":                      case "attributes":                      case "type":                          {                              if (tokens.Length <= i + 2)                                  throw new ArgumentException(String.Join(" "' tokens' i' tokens.Length - i));                                ComparisonOperator c =                                  (ComparisonOperator)EnumUtil.Parse(typeof(ComparisonOperator)' tokens[i + 1]);                                if (c != ComparisonOperator.NotEqualTo && c != ComparisonOperator.EqualTo)                                  throw new ArgumentException(String.Join(" "' tokens' i' tokens.Length - i));                                current = (tok1 == "type")                                  ? (SelectionCriterion) new TypeCriterion                                      {                                          AttributeString = tokens[i + 2]'                                          Operator = c                                      }                                  : (SelectionCriterion) new AttributesCriterion                                      {                                          AttributeString = tokens[i + 2]'                                          Operator = c                                      };                              i += 2;                              stateStack.Push(ParseState.CriterionDone);                          }                          break;                        case "":                          // NOP                          stateStack.Push(ParseState.Whitespace);                          break;                        default:                          throw new ArgumentException("'" + tokens[i] + "'");                  }
Magic Number,Ionic,FileSelector,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\FileSelector.cs,_ParseCriterion,The following statement contains a magic number: switch (tok1)                  {                      case "and":                      case "xor":                      case "or":                          state = stateStack.Peek();                          if (state != ParseState.CriterionDone)                              throw new ArgumentException(String.Join(" "' tokens' i' tokens.Length - i));                            if (tokens.Length <= i + 3)                              throw new ArgumentException(String.Join(" "' tokens' i' tokens.Length - i));                            pendingConjunction = (LogicalConjunction)Enum.Parse(typeof(LogicalConjunction)' tokens[i].ToUpper()' true);                          current = new CompoundCriterion { Left = current' Right = null' Conjunction = pendingConjunction };                          stateStack.Push(state);                          stateStack.Push(ParseState.ConjunctionPending);                          critStack.Push(current);                          break;                        case "(":                          state = stateStack.Peek();                          if (state != ParseState.Start && state != ParseState.ConjunctionPending && state != ParseState.OpenParen)                              throw new ArgumentException(String.Join(" "' tokens' i' tokens.Length - i));                            if (tokens.Length <= i + 4)                              throw new ArgumentException(String.Join(" "' tokens' i' tokens.Length - i));                            stateStack.Push(ParseState.OpenParen);                          break;                        case ")":                          state = stateStack.Pop();                          if (stateStack.Peek() != ParseState.OpenParen)                              throw new ArgumentException(String.Join(" "' tokens' i' tokens.Length - i));                            stateStack.Pop();                          stateStack.Push(ParseState.CriterionDone);                          break;                        case "atime":                      case "ctime":                      case "mtime":                          if (tokens.Length <= i + 2)                              throw new ArgumentException(String.Join(" "' tokens' i' tokens.Length - i));                            DateTime t;                          try                          {                              t = DateTime.ParseExact(tokens[i + 2]' "yyyy-MM-dd-HH:mm:ss"' null);                          }                          catch (FormatException)                          {                              try                              {                                  t = DateTime.ParseExact(tokens[i + 2]' "yyyy/MM/dd-HH:mm:ss"' null);                              }                              catch (FormatException)                              {                                  try                                  {                                      t = DateTime.ParseExact(tokens[i + 2]' "yyyy/MM/dd"' null);                                  }                                  catch (FormatException)                                  {                                      try                                      {                                          t = DateTime.ParseExact(tokens[i + 2]' "MM/dd/yyyy"' null);                                      }                                      catch (FormatException)                                      {                                          t = DateTime.ParseExact(tokens[i + 2]' "yyyy-MM-dd"' null);                                      }                                  }                              }                          }                          t= DateTime.SpecifyKind(t' DateTimeKind.Local).ToUniversalTime();                          current = new TimeCriterion                          {                              Which = (WhichTime)Enum.Parse(typeof(WhichTime)' tokens[i]' true)'                              Operator = (ComparisonOperator)EnumUtil.Parse(typeof(ComparisonOperator)' tokens[i + 1])'                              Time = t                          };                          i += 2;                          stateStack.Push(ParseState.CriterionDone);                          break;                          case "length":                      case "size":                          if (tokens.Length <= i + 2)                              throw new ArgumentException(String.Join(" "' tokens' i' tokens.Length - i));                            Int64 sz = 0;                          string v = tokens[i + 2];                          if (v.ToUpper().EndsWith("K"))                              sz = Int64.Parse(v.Substring(0' v.Length - 1)) * 1024;                          else if (v.ToUpper().EndsWith("KB"))                              sz = Int64.Parse(v.Substring(0' v.Length - 2)) * 1024;                          else if (v.ToUpper().EndsWith("M"))                              sz = Int64.Parse(v.Substring(0' v.Length - 1)) * 1024 * 1024;                          else if (v.ToUpper().EndsWith("MB"))                              sz = Int64.Parse(v.Substring(0' v.Length - 2)) * 1024 * 1024;                          else if (v.ToUpper().EndsWith("G"))                              sz = Int64.Parse(v.Substring(0' v.Length - 1)) * 1024 * 1024 * 1024;                          else if (v.ToUpper().EndsWith("GB"))                              sz = Int64.Parse(v.Substring(0' v.Length - 2)) * 1024 * 1024 * 1024;                          else sz = Int64.Parse(tokens[i + 2]);                            current = new SizeCriterion                          {                              Size = sz'                              Operator = (ComparisonOperator)EnumUtil.Parse(typeof(ComparisonOperator)' tokens[i + 1])                          };                          i += 2;                          stateStack.Push(ParseState.CriterionDone);                          break;                        case "filename":                      case "name":                          {                              if (tokens.Length <= i + 2)                                  throw new ArgumentException(String.Join(" "' tokens' i' tokens.Length - i));                                ComparisonOperator c =                                  (ComparisonOperator)EnumUtil.Parse(typeof(ComparisonOperator)' tokens[i + 1]);                                if (c != ComparisonOperator.NotEqualTo && c != ComparisonOperator.EqualTo)                                  throw new ArgumentException(String.Join(" "' tokens' i' tokens.Length - i));                                string m = tokens[i + 2];                                // handle single-quoted filespecs (used to include                              // spaces in filename patterns)                              if (m.StartsWith("'") && m.EndsWith("'"))                              {                                  // trim off leading and trailing single quotes and                                  // revert the control characters to spaces.                                  m = m.Substring(1' m.Length - 2)                                      .Replace("\u0006"' " ");                              }                                // if (m.StartsWith("'"))                              //     m = m.Replace("\u0006"' " ");                                //Fix for Unix -> NormalizeCriteriaExpression replaces all slashes with backslashes                              if (Path.DirectorySeparatorChar == '/')                                  m = m.Replace('\\'' Path.DirectorySeparatorChar);                                current = new NameCriterion                              {                                  MatchingFileSpec = m'                                  Operator = c                              };                              i += 2;                              stateStack.Push(ParseState.CriterionDone);                          }                          break;                        case "attrs":                      case "attributes":                      case "type":                          {                              if (tokens.Length <= i + 2)                                  throw new ArgumentException(String.Join(" "' tokens' i' tokens.Length - i));                                ComparisonOperator c =                                  (ComparisonOperator)EnumUtil.Parse(typeof(ComparisonOperator)' tokens[i + 1]);                                if (c != ComparisonOperator.NotEqualTo && c != ComparisonOperator.EqualTo)                                  throw new ArgumentException(String.Join(" "' tokens' i' tokens.Length - i));                                current = (tok1 == "type")                                  ? (SelectionCriterion) new TypeCriterion                                      {                                          AttributeString = tokens[i + 2]'                                          Operator = c                                      }                                  : (SelectionCriterion) new AttributesCriterion                                      {                                          AttributeString = tokens[i + 2]'                                          Operator = c                                      };                              i += 2;                              stateStack.Push(ParseState.CriterionDone);                          }                          break;                        case "":                          // NOP                          stateStack.Push(ParseState.Whitespace);                          break;                        default:                          throw new ArgumentException("'" + tokens[i] + "'");                  }
Magic Number,Ionic,FileSelector,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\FileSelector.cs,_ParseCriterion,The following statement contains a magic number: switch (tok1)                  {                      case "and":                      case "xor":                      case "or":                          state = stateStack.Peek();                          if (state != ParseState.CriterionDone)                              throw new ArgumentException(String.Join(" "' tokens' i' tokens.Length - i));                            if (tokens.Length <= i + 3)                              throw new ArgumentException(String.Join(" "' tokens' i' tokens.Length - i));                            pendingConjunction = (LogicalConjunction)Enum.Parse(typeof(LogicalConjunction)' tokens[i].ToUpper()' true);                          current = new CompoundCriterion { Left = current' Right = null' Conjunction = pendingConjunction };                          stateStack.Push(state);                          stateStack.Push(ParseState.ConjunctionPending);                          critStack.Push(current);                          break;                        case "(":                          state = stateStack.Peek();                          if (state != ParseState.Start && state != ParseState.ConjunctionPending && state != ParseState.OpenParen)                              throw new ArgumentException(String.Join(" "' tokens' i' tokens.Length - i));                            if (tokens.Length <= i + 4)                              throw new ArgumentException(String.Join(" "' tokens' i' tokens.Length - i));                            stateStack.Push(ParseState.OpenParen);                          break;                        case ")":                          state = stateStack.Pop();                          if (stateStack.Peek() != ParseState.OpenParen)                              throw new ArgumentException(String.Join(" "' tokens' i' tokens.Length - i));                            stateStack.Pop();                          stateStack.Push(ParseState.CriterionDone);                          break;                        case "atime":                      case "ctime":                      case "mtime":                          if (tokens.Length <= i + 2)                              throw new ArgumentException(String.Join(" "' tokens' i' tokens.Length - i));                            DateTime t;                          try                          {                              t = DateTime.ParseExact(tokens[i + 2]' "yyyy-MM-dd-HH:mm:ss"' null);                          }                          catch (FormatException)                          {                              try                              {                                  t = DateTime.ParseExact(tokens[i + 2]' "yyyy/MM/dd-HH:mm:ss"' null);                              }                              catch (FormatException)                              {                                  try                                  {                                      t = DateTime.ParseExact(tokens[i + 2]' "yyyy/MM/dd"' null);                                  }                                  catch (FormatException)                                  {                                      try                                      {                                          t = DateTime.ParseExact(tokens[i + 2]' "MM/dd/yyyy"' null);                                      }                                      catch (FormatException)                                      {                                          t = DateTime.ParseExact(tokens[i + 2]' "yyyy-MM-dd"' null);                                      }                                  }                              }                          }                          t= DateTime.SpecifyKind(t' DateTimeKind.Local).ToUniversalTime();                          current = new TimeCriterion                          {                              Which = (WhichTime)Enum.Parse(typeof(WhichTime)' tokens[i]' true)'                              Operator = (ComparisonOperator)EnumUtil.Parse(typeof(ComparisonOperator)' tokens[i + 1])'                              Time = t                          };                          i += 2;                          stateStack.Push(ParseState.CriterionDone);                          break;                          case "length":                      case "size":                          if (tokens.Length <= i + 2)                              throw new ArgumentException(String.Join(" "' tokens' i' tokens.Length - i));                            Int64 sz = 0;                          string v = tokens[i + 2];                          if (v.ToUpper().EndsWith("K"))                              sz = Int64.Parse(v.Substring(0' v.Length - 1)) * 1024;                          else if (v.ToUpper().EndsWith("KB"))                              sz = Int64.Parse(v.Substring(0' v.Length - 2)) * 1024;                          else if (v.ToUpper().EndsWith("M"))                              sz = Int64.Parse(v.Substring(0' v.Length - 1)) * 1024 * 1024;                          else if (v.ToUpper().EndsWith("MB"))                              sz = Int64.Parse(v.Substring(0' v.Length - 2)) * 1024 * 1024;                          else if (v.ToUpper().EndsWith("G"))                              sz = Int64.Parse(v.Substring(0' v.Length - 1)) * 1024 * 1024 * 1024;                          else if (v.ToUpper().EndsWith("GB"))                              sz = Int64.Parse(v.Substring(0' v.Length - 2)) * 1024 * 1024 * 1024;                          else sz = Int64.Parse(tokens[i + 2]);                            current = new SizeCriterion                          {                              Size = sz'                              Operator = (ComparisonOperator)EnumUtil.Parse(typeof(ComparisonOperator)' tokens[i + 1])                          };                          i += 2;                          stateStack.Push(ParseState.CriterionDone);                          break;                        case "filename":                      case "name":                          {                              if (tokens.Length <= i + 2)                                  throw new ArgumentException(String.Join(" "' tokens' i' tokens.Length - i));                                ComparisonOperator c =                                  (ComparisonOperator)EnumUtil.Parse(typeof(ComparisonOperator)' tokens[i + 1]);                                if (c != ComparisonOperator.NotEqualTo && c != ComparisonOperator.EqualTo)                                  throw new ArgumentException(String.Join(" "' tokens' i' tokens.Length - i));                                string m = tokens[i + 2];                                // handle single-quoted filespecs (used to include                              // spaces in filename patterns)                              if (m.StartsWith("'") && m.EndsWith("'"))                              {                                  // trim off leading and trailing single quotes and                                  // revert the control characters to spaces.                                  m = m.Substring(1' m.Length - 2)                                      .Replace("\u0006"' " ");                              }                                // if (m.StartsWith("'"))                              //     m = m.Replace("\u0006"' " ");                                //Fix for Unix -> NormalizeCriteriaExpression replaces all slashes with backslashes                              if (Path.DirectorySeparatorChar == '/')                                  m = m.Replace('\\'' Path.DirectorySeparatorChar);                                current = new NameCriterion                              {                                  MatchingFileSpec = m'                                  Operator = c                              };                              i += 2;                              stateStack.Push(ParseState.CriterionDone);                          }                          break;                        case "attrs":                      case "attributes":                      case "type":                          {                              if (tokens.Length <= i + 2)                                  throw new ArgumentException(String.Join(" "' tokens' i' tokens.Length - i));                                ComparisonOperator c =                                  (ComparisonOperator)EnumUtil.Parse(typeof(ComparisonOperator)' tokens[i + 1]);                                if (c != ComparisonOperator.NotEqualTo && c != ComparisonOperator.EqualTo)                                  throw new ArgumentException(String.Join(" "' tokens' i' tokens.Length - i));                                current = (tok1 == "type")                                  ? (SelectionCriterion) new TypeCriterion                                      {                                          AttributeString = tokens[i + 2]'                                          Operator = c                                      }                                  : (SelectionCriterion) new AttributesCriterion                                      {                                          AttributeString = tokens[i + 2]'                                          Operator = c                                      };                              i += 2;                              stateStack.Push(ParseState.CriterionDone);                          }                          break;                        case "":                          // NOP                          stateStack.Push(ParseState.Whitespace);                          break;                        default:                          throw new ArgumentException("'" + tokens[i] + "'");                  }
Magic Number,Ionic,FileSelector,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\FileSelector.cs,_ParseCriterion,The following statement contains a magic number: switch (tok1)                  {                      case "and":                      case "xor":                      case "or":                          state = stateStack.Peek();                          if (state != ParseState.CriterionDone)                              throw new ArgumentException(String.Join(" "' tokens' i' tokens.Length - i));                            if (tokens.Length <= i + 3)                              throw new ArgumentException(String.Join(" "' tokens' i' tokens.Length - i));                            pendingConjunction = (LogicalConjunction)Enum.Parse(typeof(LogicalConjunction)' tokens[i].ToUpper()' true);                          current = new CompoundCriterion { Left = current' Right = null' Conjunction = pendingConjunction };                          stateStack.Push(state);                          stateStack.Push(ParseState.ConjunctionPending);                          critStack.Push(current);                          break;                        case "(":                          state = stateStack.Peek();                          if (state != ParseState.Start && state != ParseState.ConjunctionPending && state != ParseState.OpenParen)                              throw new ArgumentException(String.Join(" "' tokens' i' tokens.Length - i));                            if (tokens.Length <= i + 4)                              throw new ArgumentException(String.Join(" "' tokens' i' tokens.Length - i));                            stateStack.Push(ParseState.OpenParen);                          break;                        case ")":                          state = stateStack.Pop();                          if (stateStack.Peek() != ParseState.OpenParen)                              throw new ArgumentException(String.Join(" "' tokens' i' tokens.Length - i));                            stateStack.Pop();                          stateStack.Push(ParseState.CriterionDone);                          break;                        case "atime":                      case "ctime":                      case "mtime":                          if (tokens.Length <= i + 2)                              throw new ArgumentException(String.Join(" "' tokens' i' tokens.Length - i));                            DateTime t;                          try                          {                              t = DateTime.ParseExact(tokens[i + 2]' "yyyy-MM-dd-HH:mm:ss"' null);                          }                          catch (FormatException)                          {                              try                              {                                  t = DateTime.ParseExact(tokens[i + 2]' "yyyy/MM/dd-HH:mm:ss"' null);                              }                              catch (FormatException)                              {                                  try                                  {                                      t = DateTime.ParseExact(tokens[i + 2]' "yyyy/MM/dd"' null);                                  }                                  catch (FormatException)                                  {                                      try                                      {                                          t = DateTime.ParseExact(tokens[i + 2]' "MM/dd/yyyy"' null);                                      }                                      catch (FormatException)                                      {                                          t = DateTime.ParseExact(tokens[i + 2]' "yyyy-MM-dd"' null);                                      }                                  }                              }                          }                          t= DateTime.SpecifyKind(t' DateTimeKind.Local).ToUniversalTime();                          current = new TimeCriterion                          {                              Which = (WhichTime)Enum.Parse(typeof(WhichTime)' tokens[i]' true)'                              Operator = (ComparisonOperator)EnumUtil.Parse(typeof(ComparisonOperator)' tokens[i + 1])'                              Time = t                          };                          i += 2;                          stateStack.Push(ParseState.CriterionDone);                          break;                          case "length":                      case "size":                          if (tokens.Length <= i + 2)                              throw new ArgumentException(String.Join(" "' tokens' i' tokens.Length - i));                            Int64 sz = 0;                          string v = tokens[i + 2];                          if (v.ToUpper().EndsWith("K"))                              sz = Int64.Parse(v.Substring(0' v.Length - 1)) * 1024;                          else if (v.ToUpper().EndsWith("KB"))                              sz = Int64.Parse(v.Substring(0' v.Length - 2)) * 1024;                          else if (v.ToUpper().EndsWith("M"))                              sz = Int64.Parse(v.Substring(0' v.Length - 1)) * 1024 * 1024;                          else if (v.ToUpper().EndsWith("MB"))                              sz = Int64.Parse(v.Substring(0' v.Length - 2)) * 1024 * 1024;                          else if (v.ToUpper().EndsWith("G"))                              sz = Int64.Parse(v.Substring(0' v.Length - 1)) * 1024 * 1024 * 1024;                          else if (v.ToUpper().EndsWith("GB"))                              sz = Int64.Parse(v.Substring(0' v.Length - 2)) * 1024 * 1024 * 1024;                          else sz = Int64.Parse(tokens[i + 2]);                            current = new SizeCriterion                          {                              Size = sz'                              Operator = (ComparisonOperator)EnumUtil.Parse(typeof(ComparisonOperator)' tokens[i + 1])                          };                          i += 2;                          stateStack.Push(ParseState.CriterionDone);                          break;                        case "filename":                      case "name":                          {                              if (tokens.Length <= i + 2)                                  throw new ArgumentException(String.Join(" "' tokens' i' tokens.Length - i));                                ComparisonOperator c =                                  (ComparisonOperator)EnumUtil.Parse(typeof(ComparisonOperator)' tokens[i + 1]);                                if (c != ComparisonOperator.NotEqualTo && c != ComparisonOperator.EqualTo)                                  throw new ArgumentException(String.Join(" "' tokens' i' tokens.Length - i));                                string m = tokens[i + 2];                                // handle single-quoted filespecs (used to include                              // spaces in filename patterns)                              if (m.StartsWith("'") && m.EndsWith("'"))                              {                                  // trim off leading and trailing single quotes and                                  // revert the control characters to spaces.                                  m = m.Substring(1' m.Length - 2)                                      .Replace("\u0006"' " ");                              }                                // if (m.StartsWith("'"))                              //     m = m.Replace("\u0006"' " ");                                //Fix for Unix -> NormalizeCriteriaExpression replaces all slashes with backslashes                              if (Path.DirectorySeparatorChar == '/')                                  m = m.Replace('\\'' Path.DirectorySeparatorChar);                                current = new NameCriterion                              {                                  MatchingFileSpec = m'                                  Operator = c                              };                              i += 2;                              stateStack.Push(ParseState.CriterionDone);                          }                          break;                        case "attrs":                      case "attributes":                      case "type":                          {                              if (tokens.Length <= i + 2)                                  throw new ArgumentException(String.Join(" "' tokens' i' tokens.Length - i));                                ComparisonOperator c =                                  (ComparisonOperator)EnumUtil.Parse(typeof(ComparisonOperator)' tokens[i + 1]);                                if (c != ComparisonOperator.NotEqualTo && c != ComparisonOperator.EqualTo)                                  throw new ArgumentException(String.Join(" "' tokens' i' tokens.Length - i));                                current = (tok1 == "type")                                  ? (SelectionCriterion) new TypeCriterion                                      {                                          AttributeString = tokens[i + 2]'                                          Operator = c                                      }                                  : (SelectionCriterion) new AttributesCriterion                                      {                                          AttributeString = tokens[i + 2]'                                          Operator = c                                      };                              i += 2;                              stateStack.Push(ParseState.CriterionDone);                          }                          break;                        case "":                          // NOP                          stateStack.Push(ParseState.Whitespace);                          break;                        default:                          throw new ArgumentException("'" + tokens[i] + "'");                  }
Magic Number,Ionic,FileSelector,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\FileSelector.cs,_ParseCriterion,The following statement contains a magic number: switch (tok1)                  {                      case "and":                      case "xor":                      case "or":                          state = stateStack.Peek();                          if (state != ParseState.CriterionDone)                              throw new ArgumentException(String.Join(" "' tokens' i' tokens.Length - i));                            if (tokens.Length <= i + 3)                              throw new ArgumentException(String.Join(" "' tokens' i' tokens.Length - i));                            pendingConjunction = (LogicalConjunction)Enum.Parse(typeof(LogicalConjunction)' tokens[i].ToUpper()' true);                          current = new CompoundCriterion { Left = current' Right = null' Conjunction = pendingConjunction };                          stateStack.Push(state);                          stateStack.Push(ParseState.ConjunctionPending);                          critStack.Push(current);                          break;                        case "(":                          state = stateStack.Peek();                          if (state != ParseState.Start && state != ParseState.ConjunctionPending && state != ParseState.OpenParen)                              throw new ArgumentException(String.Join(" "' tokens' i' tokens.Length - i));                            if (tokens.Length <= i + 4)                              throw new ArgumentException(String.Join(" "' tokens' i' tokens.Length - i));                            stateStack.Push(ParseState.OpenParen);                          break;                        case ")":                          state = stateStack.Pop();                          if (stateStack.Peek() != ParseState.OpenParen)                              throw new ArgumentException(String.Join(" "' tokens' i' tokens.Length - i));                            stateStack.Pop();                          stateStack.Push(ParseState.CriterionDone);                          break;                        case "atime":                      case "ctime":                      case "mtime":                          if (tokens.Length <= i + 2)                              throw new ArgumentException(String.Join(" "' tokens' i' tokens.Length - i));                            DateTime t;                          try                          {                              t = DateTime.ParseExact(tokens[i + 2]' "yyyy-MM-dd-HH:mm:ss"' null);                          }                          catch (FormatException)                          {                              try                              {                                  t = DateTime.ParseExact(tokens[i + 2]' "yyyy/MM/dd-HH:mm:ss"' null);                              }                              catch (FormatException)                              {                                  try                                  {                                      t = DateTime.ParseExact(tokens[i + 2]' "yyyy/MM/dd"' null);                                  }                                  catch (FormatException)                                  {                                      try                                      {                                          t = DateTime.ParseExact(tokens[i + 2]' "MM/dd/yyyy"' null);                                      }                                      catch (FormatException)                                      {                                          t = DateTime.ParseExact(tokens[i + 2]' "yyyy-MM-dd"' null);                                      }                                  }                              }                          }                          t= DateTime.SpecifyKind(t' DateTimeKind.Local).ToUniversalTime();                          current = new TimeCriterion                          {                              Which = (WhichTime)Enum.Parse(typeof(WhichTime)' tokens[i]' true)'                              Operator = (ComparisonOperator)EnumUtil.Parse(typeof(ComparisonOperator)' tokens[i + 1])'                              Time = t                          };                          i += 2;                          stateStack.Push(ParseState.CriterionDone);                          break;                          case "length":                      case "size":                          if (tokens.Length <= i + 2)                              throw new ArgumentException(String.Join(" "' tokens' i' tokens.Length - i));                            Int64 sz = 0;                          string v = tokens[i + 2];                          if (v.ToUpper().EndsWith("K"))                              sz = Int64.Parse(v.Substring(0' v.Length - 1)) * 1024;                          else if (v.ToUpper().EndsWith("KB"))                              sz = Int64.Parse(v.Substring(0' v.Length - 2)) * 1024;                          else if (v.ToUpper().EndsWith("M"))                              sz = Int64.Parse(v.Substring(0' v.Length - 1)) * 1024 * 1024;                          else if (v.ToUpper().EndsWith("MB"))                              sz = Int64.Parse(v.Substring(0' v.Length - 2)) * 1024 * 1024;                          else if (v.ToUpper().EndsWith("G"))                              sz = Int64.Parse(v.Substring(0' v.Length - 1)) * 1024 * 1024 * 1024;                          else if (v.ToUpper().EndsWith("GB"))                              sz = Int64.Parse(v.Substring(0' v.Length - 2)) * 1024 * 1024 * 1024;                          else sz = Int64.Parse(tokens[i + 2]);                            current = new SizeCriterion                          {                              Size = sz'                              Operator = (ComparisonOperator)EnumUtil.Parse(typeof(ComparisonOperator)' tokens[i + 1])                          };                          i += 2;                          stateStack.Push(ParseState.CriterionDone);                          break;                        case "filename":                      case "name":                          {                              if (tokens.Length <= i + 2)                                  throw new ArgumentException(String.Join(" "' tokens' i' tokens.Length - i));                                ComparisonOperator c =                                  (ComparisonOperator)EnumUtil.Parse(typeof(ComparisonOperator)' tokens[i + 1]);                                if (c != ComparisonOperator.NotEqualTo && c != ComparisonOperator.EqualTo)                                  throw new ArgumentException(String.Join(" "' tokens' i' tokens.Length - i));                                string m = tokens[i + 2];                                // handle single-quoted filespecs (used to include                              // spaces in filename patterns)                              if (m.StartsWith("'") && m.EndsWith("'"))                              {                                  // trim off leading and trailing single quotes and                                  // revert the control characters to spaces.                                  m = m.Substring(1' m.Length - 2)                                      .Replace("\u0006"' " ");                              }                                // if (m.StartsWith("'"))                              //     m = m.Replace("\u0006"' " ");                                //Fix for Unix -> NormalizeCriteriaExpression replaces all slashes with backslashes                              if (Path.DirectorySeparatorChar == '/')                                  m = m.Replace('\\'' Path.DirectorySeparatorChar);                                current = new NameCriterion                              {                                  MatchingFileSpec = m'                                  Operator = c                              };                              i += 2;                              stateStack.Push(ParseState.CriterionDone);                          }                          break;                        case "attrs":                      case "attributes":                      case "type":                          {                              if (tokens.Length <= i + 2)                                  throw new ArgumentException(String.Join(" "' tokens' i' tokens.Length - i));                                ComparisonOperator c =                                  (ComparisonOperator)EnumUtil.Parse(typeof(ComparisonOperator)' tokens[i + 1]);                                if (c != ComparisonOperator.NotEqualTo && c != ComparisonOperator.EqualTo)                                  throw new ArgumentException(String.Join(" "' tokens' i' tokens.Length - i));                                current = (tok1 == "type")                                  ? (SelectionCriterion) new TypeCriterion                                      {                                          AttributeString = tokens[i + 2]'                                          Operator = c                                      }                                  : (SelectionCriterion) new AttributesCriterion                                      {                                          AttributeString = tokens[i + 2]'                                          Operator = c                                      };                              i += 2;                              stateStack.Push(ParseState.CriterionDone);                          }                          break;                        case "":                          // NOP                          stateStack.Push(ParseState.Whitespace);                          break;                        default:                          throw new ArgumentException("'" + tokens[i] + "'");                  }
Magic Number,Ionic,FileSelector,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\FileSelector.cs,_ParseCriterion,The following statement contains a magic number: switch (tok1)                  {                      case "and":                      case "xor":                      case "or":                          state = stateStack.Peek();                          if (state != ParseState.CriterionDone)                              throw new ArgumentException(String.Join(" "' tokens' i' tokens.Length - i));                            if (tokens.Length <= i + 3)                              throw new ArgumentException(String.Join(" "' tokens' i' tokens.Length - i));                            pendingConjunction = (LogicalConjunction)Enum.Parse(typeof(LogicalConjunction)' tokens[i].ToUpper()' true);                          current = new CompoundCriterion { Left = current' Right = null' Conjunction = pendingConjunction };                          stateStack.Push(state);                          stateStack.Push(ParseState.ConjunctionPending);                          critStack.Push(current);                          break;                        case "(":                          state = stateStack.Peek();                          if (state != ParseState.Start && state != ParseState.ConjunctionPending && state != ParseState.OpenParen)                              throw new ArgumentException(String.Join(" "' tokens' i' tokens.Length - i));                            if (tokens.Length <= i + 4)                              throw new ArgumentException(String.Join(" "' tokens' i' tokens.Length - i));                            stateStack.Push(ParseState.OpenParen);                          break;                        case ")":                          state = stateStack.Pop();                          if (stateStack.Peek() != ParseState.OpenParen)                              throw new ArgumentException(String.Join(" "' tokens' i' tokens.Length - i));                            stateStack.Pop();                          stateStack.Push(ParseState.CriterionDone);                          break;                        case "atime":                      case "ctime":                      case "mtime":                          if (tokens.Length <= i + 2)                              throw new ArgumentException(String.Join(" "' tokens' i' tokens.Length - i));                            DateTime t;                          try                          {                              t = DateTime.ParseExact(tokens[i + 2]' "yyyy-MM-dd-HH:mm:ss"' null);                          }                          catch (FormatException)                          {                              try                              {                                  t = DateTime.ParseExact(tokens[i + 2]' "yyyy/MM/dd-HH:mm:ss"' null);                              }                              catch (FormatException)                              {                                  try                                  {                                      t = DateTime.ParseExact(tokens[i + 2]' "yyyy/MM/dd"' null);                                  }                                  catch (FormatException)                                  {                                      try                                      {                                          t = DateTime.ParseExact(tokens[i + 2]' "MM/dd/yyyy"' null);                                      }                                      catch (FormatException)                                      {                                          t = DateTime.ParseExact(tokens[i + 2]' "yyyy-MM-dd"' null);                                      }                                  }                              }                          }                          t= DateTime.SpecifyKind(t' DateTimeKind.Local).ToUniversalTime();                          current = new TimeCriterion                          {                              Which = (WhichTime)Enum.Parse(typeof(WhichTime)' tokens[i]' true)'                              Operator = (ComparisonOperator)EnumUtil.Parse(typeof(ComparisonOperator)' tokens[i + 1])'                              Time = t                          };                          i += 2;                          stateStack.Push(ParseState.CriterionDone);                          break;                          case "length":                      case "size":                          if (tokens.Length <= i + 2)                              throw new ArgumentException(String.Join(" "' tokens' i' tokens.Length - i));                            Int64 sz = 0;                          string v = tokens[i + 2];                          if (v.ToUpper().EndsWith("K"))                              sz = Int64.Parse(v.Substring(0' v.Length - 1)) * 1024;                          else if (v.ToUpper().EndsWith("KB"))                              sz = Int64.Parse(v.Substring(0' v.Length - 2)) * 1024;                          else if (v.ToUpper().EndsWith("M"))                              sz = Int64.Parse(v.Substring(0' v.Length - 1)) * 1024 * 1024;                          else if (v.ToUpper().EndsWith("MB"))                              sz = Int64.Parse(v.Substring(0' v.Length - 2)) * 1024 * 1024;                          else if (v.ToUpper().EndsWith("G"))                              sz = Int64.Parse(v.Substring(0' v.Length - 1)) * 1024 * 1024 * 1024;                          else if (v.ToUpper().EndsWith("GB"))                              sz = Int64.Parse(v.Substring(0' v.Length - 2)) * 1024 * 1024 * 1024;                          else sz = Int64.Parse(tokens[i + 2]);                            current = new SizeCriterion                          {                              Size = sz'                              Operator = (ComparisonOperator)EnumUtil.Parse(typeof(ComparisonOperator)' tokens[i + 1])                          };                          i += 2;                          stateStack.Push(ParseState.CriterionDone);                          break;                        case "filename":                      case "name":                          {                              if (tokens.Length <= i + 2)                                  throw new ArgumentException(String.Join(" "' tokens' i' tokens.Length - i));                                ComparisonOperator c =                                  (ComparisonOperator)EnumUtil.Parse(typeof(ComparisonOperator)' tokens[i + 1]);                                if (c != ComparisonOperator.NotEqualTo && c != ComparisonOperator.EqualTo)                                  throw new ArgumentException(String.Join(" "' tokens' i' tokens.Length - i));                                string m = tokens[i + 2];                                // handle single-quoted filespecs (used to include                              // spaces in filename patterns)                              if (m.StartsWith("'") && m.EndsWith("'"))                              {                                  // trim off leading and trailing single quotes and                                  // revert the control characters to spaces.                                  m = m.Substring(1' m.Length - 2)                                      .Replace("\u0006"' " ");                              }                                // if (m.StartsWith("'"))                              //     m = m.Replace("\u0006"' " ");                                //Fix for Unix -> NormalizeCriteriaExpression replaces all slashes with backslashes                              if (Path.DirectorySeparatorChar == '/')                                  m = m.Replace('\\'' Path.DirectorySeparatorChar);                                current = new NameCriterion                              {                                  MatchingFileSpec = m'                                  Operator = c                              };                              i += 2;                              stateStack.Push(ParseState.CriterionDone);                          }                          break;                        case "attrs":                      case "attributes":                      case "type":                          {                              if (tokens.Length <= i + 2)                                  throw new ArgumentException(String.Join(" "' tokens' i' tokens.Length - i));                                ComparisonOperator c =                                  (ComparisonOperator)EnumUtil.Parse(typeof(ComparisonOperator)' tokens[i + 1]);                                if (c != ComparisonOperator.NotEqualTo && c != ComparisonOperator.EqualTo)                                  throw new ArgumentException(String.Join(" "' tokens' i' tokens.Length - i));                                current = (tok1 == "type")                                  ? (SelectionCriterion) new TypeCriterion                                      {                                          AttributeString = tokens[i + 2]'                                          Operator = c                                      }                                  : (SelectionCriterion) new AttributesCriterion                                      {                                          AttributeString = tokens[i + 2]'                                          Operator = c                                      };                              i += 2;                              stateStack.Push(ParseState.CriterionDone);                          }                          break;                        case "":                          // NOP                          stateStack.Push(ParseState.Whitespace);                          break;                        default:                          throw new ArgumentException("'" + tokens[i] + "'");                  }
Magic Number,Ionic,FileSelector,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\FileSelector.cs,_ParseCriterion,The following statement contains a magic number: switch (tok1)                  {                      case "and":                      case "xor":                      case "or":                          state = stateStack.Peek();                          if (state != ParseState.CriterionDone)                              throw new ArgumentException(String.Join(" "' tokens' i' tokens.Length - i));                            if (tokens.Length <= i + 3)                              throw new ArgumentException(String.Join(" "' tokens' i' tokens.Length - i));                            pendingConjunction = (LogicalConjunction)Enum.Parse(typeof(LogicalConjunction)' tokens[i].ToUpper()' true);                          current = new CompoundCriterion { Left = current' Right = null' Conjunction = pendingConjunction };                          stateStack.Push(state);                          stateStack.Push(ParseState.ConjunctionPending);                          critStack.Push(current);                          break;                        case "(":                          state = stateStack.Peek();                          if (state != ParseState.Start && state != ParseState.ConjunctionPending && state != ParseState.OpenParen)                              throw new ArgumentException(String.Join(" "' tokens' i' tokens.Length - i));                            if (tokens.Length <= i + 4)                              throw new ArgumentException(String.Join(" "' tokens' i' tokens.Length - i));                            stateStack.Push(ParseState.OpenParen);                          break;                        case ")":                          state = stateStack.Pop();                          if (stateStack.Peek() != ParseState.OpenParen)                              throw new ArgumentException(String.Join(" "' tokens' i' tokens.Length - i));                            stateStack.Pop();                          stateStack.Push(ParseState.CriterionDone);                          break;                        case "atime":                      case "ctime":                      case "mtime":                          if (tokens.Length <= i + 2)                              throw new ArgumentException(String.Join(" "' tokens' i' tokens.Length - i));                            DateTime t;                          try                          {                              t = DateTime.ParseExact(tokens[i + 2]' "yyyy-MM-dd-HH:mm:ss"' null);                          }                          catch (FormatException)                          {                              try                              {                                  t = DateTime.ParseExact(tokens[i + 2]' "yyyy/MM/dd-HH:mm:ss"' null);                              }                              catch (FormatException)                              {                                  try                                  {                                      t = DateTime.ParseExact(tokens[i + 2]' "yyyy/MM/dd"' null);                                  }                                  catch (FormatException)                                  {                                      try                                      {                                          t = DateTime.ParseExact(tokens[i + 2]' "MM/dd/yyyy"' null);                                      }                                      catch (FormatException)                                      {                                          t = DateTime.ParseExact(tokens[i + 2]' "yyyy-MM-dd"' null);                                      }                                  }                              }                          }                          t= DateTime.SpecifyKind(t' DateTimeKind.Local).ToUniversalTime();                          current = new TimeCriterion                          {                              Which = (WhichTime)Enum.Parse(typeof(WhichTime)' tokens[i]' true)'                              Operator = (ComparisonOperator)EnumUtil.Parse(typeof(ComparisonOperator)' tokens[i + 1])'                              Time = t                          };                          i += 2;                          stateStack.Push(ParseState.CriterionDone);                          break;                          case "length":                      case "size":                          if (tokens.Length <= i + 2)                              throw new ArgumentException(String.Join(" "' tokens' i' tokens.Length - i));                            Int64 sz = 0;                          string v = tokens[i + 2];                          if (v.ToUpper().EndsWith("K"))                              sz = Int64.Parse(v.Substring(0' v.Length - 1)) * 1024;                          else if (v.ToUpper().EndsWith("KB"))                              sz = Int64.Parse(v.Substring(0' v.Length - 2)) * 1024;                          else if (v.ToUpper().EndsWith("M"))                              sz = Int64.Parse(v.Substring(0' v.Length - 1)) * 1024 * 1024;                          else if (v.ToUpper().EndsWith("MB"))                              sz = Int64.Parse(v.Substring(0' v.Length - 2)) * 1024 * 1024;                          else if (v.ToUpper().EndsWith("G"))                              sz = Int64.Parse(v.Substring(0' v.Length - 1)) * 1024 * 1024 * 1024;                          else if (v.ToUpper().EndsWith("GB"))                              sz = Int64.Parse(v.Substring(0' v.Length - 2)) * 1024 * 1024 * 1024;                          else sz = Int64.Parse(tokens[i + 2]);                            current = new SizeCriterion                          {                              Size = sz'                              Operator = (ComparisonOperator)EnumUtil.Parse(typeof(ComparisonOperator)' tokens[i + 1])                          };                          i += 2;                          stateStack.Push(ParseState.CriterionDone);                          break;                        case "filename":                      case "name":                          {                              if (tokens.Length <= i + 2)                                  throw new ArgumentException(String.Join(" "' tokens' i' tokens.Length - i));                                ComparisonOperator c =                                  (ComparisonOperator)EnumUtil.Parse(typeof(ComparisonOperator)' tokens[i + 1]);                                if (c != ComparisonOperator.NotEqualTo && c != ComparisonOperator.EqualTo)                                  throw new ArgumentException(String.Join(" "' tokens' i' tokens.Length - i));                                string m = tokens[i + 2];                                // handle single-quoted filespecs (used to include                              // spaces in filename patterns)                              if (m.StartsWith("'") && m.EndsWith("'"))                              {                                  // trim off leading and trailing single quotes and                                  // revert the control characters to spaces.                                  m = m.Substring(1' m.Length - 2)                                      .Replace("\u0006"' " ");                              }                                // if (m.StartsWith("'"))                              //     m = m.Replace("\u0006"' " ");                                //Fix for Unix -> NormalizeCriteriaExpression replaces all slashes with backslashes                              if (Path.DirectorySeparatorChar == '/')                                  m = m.Replace('\\'' Path.DirectorySeparatorChar);                                current = new NameCriterion                              {                                  MatchingFileSpec = m'                                  Operator = c                              };                              i += 2;                              stateStack.Push(ParseState.CriterionDone);                          }                          break;                        case "attrs":                      case "attributes":                      case "type":                          {                              if (tokens.Length <= i + 2)                                  throw new ArgumentException(String.Join(" "' tokens' i' tokens.Length - i));                                ComparisonOperator c =                                  (ComparisonOperator)EnumUtil.Parse(typeof(ComparisonOperator)' tokens[i + 1]);                                if (c != ComparisonOperator.NotEqualTo && c != ComparisonOperator.EqualTo)                                  throw new ArgumentException(String.Join(" "' tokens' i' tokens.Length - i));                                current = (tok1 == "type")                                  ? (SelectionCriterion) new TypeCriterion                                      {                                          AttributeString = tokens[i + 2]'                                          Operator = c                                      }                                  : (SelectionCriterion) new AttributesCriterion                                      {                                          AttributeString = tokens[i + 2]'                                          Operator = c                                      };                              i += 2;                              stateStack.Push(ParseState.CriterionDone);                          }                          break;                        case "":                          // NOP                          stateStack.Push(ParseState.Whitespace);                          break;                        default:                          throw new ArgumentException("'" + tokens[i] + "'");                  }
Magic Number,Ionic,FileSelector,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\FileSelector.cs,_ParseCriterion,The following statement contains a magic number: switch (tok1)                  {                      case "and":                      case "xor":                      case "or":                          state = stateStack.Peek();                          if (state != ParseState.CriterionDone)                              throw new ArgumentException(String.Join(" "' tokens' i' tokens.Length - i));                            if (tokens.Length <= i + 3)                              throw new ArgumentException(String.Join(" "' tokens' i' tokens.Length - i));                            pendingConjunction = (LogicalConjunction)Enum.Parse(typeof(LogicalConjunction)' tokens[i].ToUpper()' true);                          current = new CompoundCriterion { Left = current' Right = null' Conjunction = pendingConjunction };                          stateStack.Push(state);                          stateStack.Push(ParseState.ConjunctionPending);                          critStack.Push(current);                          break;                        case "(":                          state = stateStack.Peek();                          if (state != ParseState.Start && state != ParseState.ConjunctionPending && state != ParseState.OpenParen)                              throw new ArgumentException(String.Join(" "' tokens' i' tokens.Length - i));                            if (tokens.Length <= i + 4)                              throw new ArgumentException(String.Join(" "' tokens' i' tokens.Length - i));                            stateStack.Push(ParseState.OpenParen);                          break;                        case ")":                          state = stateStack.Pop();                          if (stateStack.Peek() != ParseState.OpenParen)                              throw new ArgumentException(String.Join(" "' tokens' i' tokens.Length - i));                            stateStack.Pop();                          stateStack.Push(ParseState.CriterionDone);                          break;                        case "atime":                      case "ctime":                      case "mtime":                          if (tokens.Length <= i + 2)                              throw new ArgumentException(String.Join(" "' tokens' i' tokens.Length - i));                            DateTime t;                          try                          {                              t = DateTime.ParseExact(tokens[i + 2]' "yyyy-MM-dd-HH:mm:ss"' null);                          }                          catch (FormatException)                          {                              try                              {                                  t = DateTime.ParseExact(tokens[i + 2]' "yyyy/MM/dd-HH:mm:ss"' null);                              }                              catch (FormatException)                              {                                  try                                  {                                      t = DateTime.ParseExact(tokens[i + 2]' "yyyy/MM/dd"' null);                                  }                                  catch (FormatException)                                  {                                      try                                      {                                          t = DateTime.ParseExact(tokens[i + 2]' "MM/dd/yyyy"' null);                                      }                                      catch (FormatException)                                      {                                          t = DateTime.ParseExact(tokens[i + 2]' "yyyy-MM-dd"' null);                                      }                                  }                              }                          }                          t= DateTime.SpecifyKind(t' DateTimeKind.Local).ToUniversalTime();                          current = new TimeCriterion                          {                              Which = (WhichTime)Enum.Parse(typeof(WhichTime)' tokens[i]' true)'                              Operator = (ComparisonOperator)EnumUtil.Parse(typeof(ComparisonOperator)' tokens[i + 1])'                              Time = t                          };                          i += 2;                          stateStack.Push(ParseState.CriterionDone);                          break;                          case "length":                      case "size":                          if (tokens.Length <= i + 2)                              throw new ArgumentException(String.Join(" "' tokens' i' tokens.Length - i));                            Int64 sz = 0;                          string v = tokens[i + 2];                          if (v.ToUpper().EndsWith("K"))                              sz = Int64.Parse(v.Substring(0' v.Length - 1)) * 1024;                          else if (v.ToUpper().EndsWith("KB"))                              sz = Int64.Parse(v.Substring(0' v.Length - 2)) * 1024;                          else if (v.ToUpper().EndsWith("M"))                              sz = Int64.Parse(v.Substring(0' v.Length - 1)) * 1024 * 1024;                          else if (v.ToUpper().EndsWith("MB"))                              sz = Int64.Parse(v.Substring(0' v.Length - 2)) * 1024 * 1024;                          else if (v.ToUpper().EndsWith("G"))                              sz = Int64.Parse(v.Substring(0' v.Length - 1)) * 1024 * 1024 * 1024;                          else if (v.ToUpper().EndsWith("GB"))                              sz = Int64.Parse(v.Substring(0' v.Length - 2)) * 1024 * 1024 * 1024;                          else sz = Int64.Parse(tokens[i + 2]);                            current = new SizeCriterion                          {                              Size = sz'                              Operator = (ComparisonOperator)EnumUtil.Parse(typeof(ComparisonOperator)' tokens[i + 1])                          };                          i += 2;                          stateStack.Push(ParseState.CriterionDone);                          break;                        case "filename":                      case "name":                          {                              if (tokens.Length <= i + 2)                                  throw new ArgumentException(String.Join(" "' tokens' i' tokens.Length - i));                                ComparisonOperator c =                                  (ComparisonOperator)EnumUtil.Parse(typeof(ComparisonOperator)' tokens[i + 1]);                                if (c != ComparisonOperator.NotEqualTo && c != ComparisonOperator.EqualTo)                                  throw new ArgumentException(String.Join(" "' tokens' i' tokens.Length - i));                                string m = tokens[i + 2];                                // handle single-quoted filespecs (used to include                              // spaces in filename patterns)                              if (m.StartsWith("'") && m.EndsWith("'"))                              {                                  // trim off leading and trailing single quotes and                                  // revert the control characters to spaces.                                  m = m.Substring(1' m.Length - 2)                                      .Replace("\u0006"' " ");                              }                                // if (m.StartsWith("'"))                              //     m = m.Replace("\u0006"' " ");                                //Fix for Unix -> NormalizeCriteriaExpression replaces all slashes with backslashes                              if (Path.DirectorySeparatorChar == '/')                                  m = m.Replace('\\'' Path.DirectorySeparatorChar);                                current = new NameCriterion                              {                                  MatchingFileSpec = m'                                  Operator = c                              };                              i += 2;                              stateStack.Push(ParseState.CriterionDone);                          }                          break;                        case "attrs":                      case "attributes":                      case "type":                          {                              if (tokens.Length <= i + 2)                                  throw new ArgumentException(String.Join(" "' tokens' i' tokens.Length - i));                                ComparisonOperator c =                                  (ComparisonOperator)EnumUtil.Parse(typeof(ComparisonOperator)' tokens[i + 1]);                                if (c != ComparisonOperator.NotEqualTo && c != ComparisonOperator.EqualTo)                                  throw new ArgumentException(String.Join(" "' tokens' i' tokens.Length - i));                                current = (tok1 == "type")                                  ? (SelectionCriterion) new TypeCriterion                                      {                                          AttributeString = tokens[i + 2]'                                          Operator = c                                      }                                  : (SelectionCriterion) new AttributesCriterion                                      {                                          AttributeString = tokens[i + 2]'                                          Operator = c                                      };                              i += 2;                              stateStack.Push(ParseState.CriterionDone);                          }                          break;                        case "":                          // NOP                          stateStack.Push(ParseState.Whitespace);                          break;                        default:                          throw new ArgumentException("'" + tokens[i] + "'");                  }
Magic Number,Ionic,FileSelector,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\FileSelector.cs,_ParseCriterion,The following statement contains a magic number: switch (tok1)                  {                      case "and":                      case "xor":                      case "or":                          state = stateStack.Peek();                          if (state != ParseState.CriterionDone)                              throw new ArgumentException(String.Join(" "' tokens' i' tokens.Length - i));                            if (tokens.Length <= i + 3)                              throw new ArgumentException(String.Join(" "' tokens' i' tokens.Length - i));                            pendingConjunction = (LogicalConjunction)Enum.Parse(typeof(LogicalConjunction)' tokens[i].ToUpper()' true);                          current = new CompoundCriterion { Left = current' Right = null' Conjunction = pendingConjunction };                          stateStack.Push(state);                          stateStack.Push(ParseState.ConjunctionPending);                          critStack.Push(current);                          break;                        case "(":                          state = stateStack.Peek();                          if (state != ParseState.Start && state != ParseState.ConjunctionPending && state != ParseState.OpenParen)                              throw new ArgumentException(String.Join(" "' tokens' i' tokens.Length - i));                            if (tokens.Length <= i + 4)                              throw new ArgumentException(String.Join(" "' tokens' i' tokens.Length - i));                            stateStack.Push(ParseState.OpenParen);                          break;                        case ")":                          state = stateStack.Pop();                          if (stateStack.Peek() != ParseState.OpenParen)                              throw new ArgumentException(String.Join(" "' tokens' i' tokens.Length - i));                            stateStack.Pop();                          stateStack.Push(ParseState.CriterionDone);                          break;                        case "atime":                      case "ctime":                      case "mtime":                          if (tokens.Length <= i + 2)                              throw new ArgumentException(String.Join(" "' tokens' i' tokens.Length - i));                            DateTime t;                          try                          {                              t = DateTime.ParseExact(tokens[i + 2]' "yyyy-MM-dd-HH:mm:ss"' null);                          }                          catch (FormatException)                          {                              try                              {                                  t = DateTime.ParseExact(tokens[i + 2]' "yyyy/MM/dd-HH:mm:ss"' null);                              }                              catch (FormatException)                              {                                  try                                  {                                      t = DateTime.ParseExact(tokens[i + 2]' "yyyy/MM/dd"' null);                                  }                                  catch (FormatException)                                  {                                      try                                      {                                          t = DateTime.ParseExact(tokens[i + 2]' "MM/dd/yyyy"' null);                                      }                                      catch (FormatException)                                      {                                          t = DateTime.ParseExact(tokens[i + 2]' "yyyy-MM-dd"' null);                                      }                                  }                              }                          }                          t= DateTime.SpecifyKind(t' DateTimeKind.Local).ToUniversalTime();                          current = new TimeCriterion                          {                              Which = (WhichTime)Enum.Parse(typeof(WhichTime)' tokens[i]' true)'                              Operator = (ComparisonOperator)EnumUtil.Parse(typeof(ComparisonOperator)' tokens[i + 1])'                              Time = t                          };                          i += 2;                          stateStack.Push(ParseState.CriterionDone);                          break;                          case "length":                      case "size":                          if (tokens.Length <= i + 2)                              throw new ArgumentException(String.Join(" "' tokens' i' tokens.Length - i));                            Int64 sz = 0;                          string v = tokens[i + 2];                          if (v.ToUpper().EndsWith("K"))                              sz = Int64.Parse(v.Substring(0' v.Length - 1)) * 1024;                          else if (v.ToUpper().EndsWith("KB"))                              sz = Int64.Parse(v.Substring(0' v.Length - 2)) * 1024;                          else if (v.ToUpper().EndsWith("M"))                              sz = Int64.Parse(v.Substring(0' v.Length - 1)) * 1024 * 1024;                          else if (v.ToUpper().EndsWith("MB"))                              sz = Int64.Parse(v.Substring(0' v.Length - 2)) * 1024 * 1024;                          else if (v.ToUpper().EndsWith("G"))                              sz = Int64.Parse(v.Substring(0' v.Length - 1)) * 1024 * 1024 * 1024;                          else if (v.ToUpper().EndsWith("GB"))                              sz = Int64.Parse(v.Substring(0' v.Length - 2)) * 1024 * 1024 * 1024;                          else sz = Int64.Parse(tokens[i + 2]);                            current = new SizeCriterion                          {                              Size = sz'                              Operator = (ComparisonOperator)EnumUtil.Parse(typeof(ComparisonOperator)' tokens[i + 1])                          };                          i += 2;                          stateStack.Push(ParseState.CriterionDone);                          break;                        case "filename":                      case "name":                          {                              if (tokens.Length <= i + 2)                                  throw new ArgumentException(String.Join(" "' tokens' i' tokens.Length - i));                                ComparisonOperator c =                                  (ComparisonOperator)EnumUtil.Parse(typeof(ComparisonOperator)' tokens[i + 1]);                                if (c != ComparisonOperator.NotEqualTo && c != ComparisonOperator.EqualTo)                                  throw new ArgumentException(String.Join(" "' tokens' i' tokens.Length - i));                                string m = tokens[i + 2];                                // handle single-quoted filespecs (used to include                              // spaces in filename patterns)                              if (m.StartsWith("'") && m.EndsWith("'"))                              {                                  // trim off leading and trailing single quotes and                                  // revert the control characters to spaces.                                  m = m.Substring(1' m.Length - 2)                                      .Replace("\u0006"' " ");                              }                                // if (m.StartsWith("'"))                              //     m = m.Replace("\u0006"' " ");                                //Fix for Unix -> NormalizeCriteriaExpression replaces all slashes with backslashes                              if (Path.DirectorySeparatorChar == '/')                                  m = m.Replace('\\'' Path.DirectorySeparatorChar);                                current = new NameCriterion                              {                                  MatchingFileSpec = m'                                  Operator = c                              };                              i += 2;                              stateStack.Push(ParseState.CriterionDone);                          }                          break;                        case "attrs":                      case "attributes":                      case "type":                          {                              if (tokens.Length <= i + 2)                                  throw new ArgumentException(String.Join(" "' tokens' i' tokens.Length - i));                                ComparisonOperator c =                                  (ComparisonOperator)EnumUtil.Parse(typeof(ComparisonOperator)' tokens[i + 1]);                                if (c != ComparisonOperator.NotEqualTo && c != ComparisonOperator.EqualTo)                                  throw new ArgumentException(String.Join(" "' tokens' i' tokens.Length - i));                                current = (tok1 == "type")                                  ? (SelectionCriterion) new TypeCriterion                                      {                                          AttributeString = tokens[i + 2]'                                          Operator = c                                      }                                  : (SelectionCriterion) new AttributesCriterion                                      {                                          AttributeString = tokens[i + 2]'                                          Operator = c                                      };                              i += 2;                              stateStack.Push(ParseState.CriterionDone);                          }                          break;                        case "":                          // NOP                          stateStack.Push(ParseState.Whitespace);                          break;                        default:                          throw new ArgumentException("'" + tokens[i] + "'");                  }
Magic Number,Ionic,FileSelector,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\FileSelector.cs,_ParseCriterion,The following statement contains a magic number: switch (tok1)                  {                      case "and":                      case "xor":                      case "or":                          state = stateStack.Peek();                          if (state != ParseState.CriterionDone)                              throw new ArgumentException(String.Join(" "' tokens' i' tokens.Length - i));                            if (tokens.Length <= i + 3)                              throw new ArgumentException(String.Join(" "' tokens' i' tokens.Length - i));                            pendingConjunction = (LogicalConjunction)Enum.Parse(typeof(LogicalConjunction)' tokens[i].ToUpper()' true);                          current = new CompoundCriterion { Left = current' Right = null' Conjunction = pendingConjunction };                          stateStack.Push(state);                          stateStack.Push(ParseState.ConjunctionPending);                          critStack.Push(current);                          break;                        case "(":                          state = stateStack.Peek();                          if (state != ParseState.Start && state != ParseState.ConjunctionPending && state != ParseState.OpenParen)                              throw new ArgumentException(String.Join(" "' tokens' i' tokens.Length - i));                            if (tokens.Length <= i + 4)                              throw new ArgumentException(String.Join(" "' tokens' i' tokens.Length - i));                            stateStack.Push(ParseState.OpenParen);                          break;                        case ")":                          state = stateStack.Pop();                          if (stateStack.Peek() != ParseState.OpenParen)                              throw new ArgumentException(String.Join(" "' tokens' i' tokens.Length - i));                            stateStack.Pop();                          stateStack.Push(ParseState.CriterionDone);                          break;                        case "atime":                      case "ctime":                      case "mtime":                          if (tokens.Length <= i + 2)                              throw new ArgumentException(String.Join(" "' tokens' i' tokens.Length - i));                            DateTime t;                          try                          {                              t = DateTime.ParseExact(tokens[i + 2]' "yyyy-MM-dd-HH:mm:ss"' null);                          }                          catch (FormatException)                          {                              try                              {                                  t = DateTime.ParseExact(tokens[i + 2]' "yyyy/MM/dd-HH:mm:ss"' null);                              }                              catch (FormatException)                              {                                  try                                  {                                      t = DateTime.ParseExact(tokens[i + 2]' "yyyy/MM/dd"' null);                                  }                                  catch (FormatException)                                  {                                      try                                      {                                          t = DateTime.ParseExact(tokens[i + 2]' "MM/dd/yyyy"' null);                                      }                                      catch (FormatException)                                      {                                          t = DateTime.ParseExact(tokens[i + 2]' "yyyy-MM-dd"' null);                                      }                                  }                              }                          }                          t= DateTime.SpecifyKind(t' DateTimeKind.Local).ToUniversalTime();                          current = new TimeCriterion                          {                              Which = (WhichTime)Enum.Parse(typeof(WhichTime)' tokens[i]' true)'                              Operator = (ComparisonOperator)EnumUtil.Parse(typeof(ComparisonOperator)' tokens[i + 1])'                              Time = t                          };                          i += 2;                          stateStack.Push(ParseState.CriterionDone);                          break;                          case "length":                      case "size":                          if (tokens.Length <= i + 2)                              throw new ArgumentException(String.Join(" "' tokens' i' tokens.Length - i));                            Int64 sz = 0;                          string v = tokens[i + 2];                          if (v.ToUpper().EndsWith("K"))                              sz = Int64.Parse(v.Substring(0' v.Length - 1)) * 1024;                          else if (v.ToUpper().EndsWith("KB"))                              sz = Int64.Parse(v.Substring(0' v.Length - 2)) * 1024;                          else if (v.ToUpper().EndsWith("M"))                              sz = Int64.Parse(v.Substring(0' v.Length - 1)) * 1024 * 1024;                          else if (v.ToUpper().EndsWith("MB"))                              sz = Int64.Parse(v.Substring(0' v.Length - 2)) * 1024 * 1024;                          else if (v.ToUpper().EndsWith("G"))                              sz = Int64.Parse(v.Substring(0' v.Length - 1)) * 1024 * 1024 * 1024;                          else if (v.ToUpper().EndsWith("GB"))                              sz = Int64.Parse(v.Substring(0' v.Length - 2)) * 1024 * 1024 * 1024;                          else sz = Int64.Parse(tokens[i + 2]);                            current = new SizeCriterion                          {                              Size = sz'                              Operator = (ComparisonOperator)EnumUtil.Parse(typeof(ComparisonOperator)' tokens[i + 1])                          };                          i += 2;                          stateStack.Push(ParseState.CriterionDone);                          break;                        case "filename":                      case "name":                          {                              if (tokens.Length <= i + 2)                                  throw new ArgumentException(String.Join(" "' tokens' i' tokens.Length - i));                                ComparisonOperator c =                                  (ComparisonOperator)EnumUtil.Parse(typeof(ComparisonOperator)' tokens[i + 1]);                                if (c != ComparisonOperator.NotEqualTo && c != ComparisonOperator.EqualTo)                                  throw new ArgumentException(String.Join(" "' tokens' i' tokens.Length - i));                                string m = tokens[i + 2];                                // handle single-quoted filespecs (used to include                              // spaces in filename patterns)                              if (m.StartsWith("'") && m.EndsWith("'"))                              {                                  // trim off leading and trailing single quotes and                                  // revert the control characters to spaces.                                  m = m.Substring(1' m.Length - 2)                                      .Replace("\u0006"' " ");                              }                                // if (m.StartsWith("'"))                              //     m = m.Replace("\u0006"' " ");                                //Fix for Unix -> NormalizeCriteriaExpression replaces all slashes with backslashes                              if (Path.DirectorySeparatorChar == '/')                                  m = m.Replace('\\'' Path.DirectorySeparatorChar);                                current = new NameCriterion                              {                                  MatchingFileSpec = m'                                  Operator = c                              };                              i += 2;                              stateStack.Push(ParseState.CriterionDone);                          }                          break;                        case "attrs":                      case "attributes":                      case "type":                          {                              if (tokens.Length <= i + 2)                                  throw new ArgumentException(String.Join(" "' tokens' i' tokens.Length - i));                                ComparisonOperator c =                                  (ComparisonOperator)EnumUtil.Parse(typeof(ComparisonOperator)' tokens[i + 1]);                                if (c != ComparisonOperator.NotEqualTo && c != ComparisonOperator.EqualTo)                                  throw new ArgumentException(String.Join(" "' tokens' i' tokens.Length - i));                                current = (tok1 == "type")                                  ? (SelectionCriterion) new TypeCriterion                                      {                                          AttributeString = tokens[i + 2]'                                          Operator = c                                      }                                  : (SelectionCriterion) new AttributesCriterion                                      {                                          AttributeString = tokens[i + 2]'                                          Operator = c                                      };                              i += 2;                              stateStack.Push(ParseState.CriterionDone);                          }                          break;                        case "":                          // NOP                          stateStack.Push(ParseState.Whitespace);                          break;                        default:                          throw new ArgumentException("'" + tokens[i] + "'");                  }
Magic Number,Ionic,FileSelector,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\FileSelector.cs,_ParseCriterion,The following statement contains a magic number: switch (tok1)                  {                      case "and":                      case "xor":                      case "or":                          state = stateStack.Peek();                          if (state != ParseState.CriterionDone)                              throw new ArgumentException(String.Join(" "' tokens' i' tokens.Length - i));                            if (tokens.Length <= i + 3)                              throw new ArgumentException(String.Join(" "' tokens' i' tokens.Length - i));                            pendingConjunction = (LogicalConjunction)Enum.Parse(typeof(LogicalConjunction)' tokens[i].ToUpper()' true);                          current = new CompoundCriterion { Left = current' Right = null' Conjunction = pendingConjunction };                          stateStack.Push(state);                          stateStack.Push(ParseState.ConjunctionPending);                          critStack.Push(current);                          break;                        case "(":                          state = stateStack.Peek();                          if (state != ParseState.Start && state != ParseState.ConjunctionPending && state != ParseState.OpenParen)                              throw new ArgumentException(String.Join(" "' tokens' i' tokens.Length - i));                            if (tokens.Length <= i + 4)                              throw new ArgumentException(String.Join(" "' tokens' i' tokens.Length - i));                            stateStack.Push(ParseState.OpenParen);                          break;                        case ")":                          state = stateStack.Pop();                          if (stateStack.Peek() != ParseState.OpenParen)                              throw new ArgumentException(String.Join(" "' tokens' i' tokens.Length - i));                            stateStack.Pop();                          stateStack.Push(ParseState.CriterionDone);                          break;                        case "atime":                      case "ctime":                      case "mtime":                          if (tokens.Length <= i + 2)                              throw new ArgumentException(String.Join(" "' tokens' i' tokens.Length - i));                            DateTime t;                          try                          {                              t = DateTime.ParseExact(tokens[i + 2]' "yyyy-MM-dd-HH:mm:ss"' null);                          }                          catch (FormatException)                          {                              try                              {                                  t = DateTime.ParseExact(tokens[i + 2]' "yyyy/MM/dd-HH:mm:ss"' null);                              }                              catch (FormatException)                              {                                  try                                  {                                      t = DateTime.ParseExact(tokens[i + 2]' "yyyy/MM/dd"' null);                                  }                                  catch (FormatException)                                  {                                      try                                      {                                          t = DateTime.ParseExact(tokens[i + 2]' "MM/dd/yyyy"' null);                                      }                                      catch (FormatException)                                      {                                          t = DateTime.ParseExact(tokens[i + 2]' "yyyy-MM-dd"' null);                                      }                                  }                              }                          }                          t= DateTime.SpecifyKind(t' DateTimeKind.Local).ToUniversalTime();                          current = new TimeCriterion                          {                              Which = (WhichTime)Enum.Parse(typeof(WhichTime)' tokens[i]' true)'                              Operator = (ComparisonOperator)EnumUtil.Parse(typeof(ComparisonOperator)' tokens[i + 1])'                              Time = t                          };                          i += 2;                          stateStack.Push(ParseState.CriterionDone);                          break;                          case "length":                      case "size":                          if (tokens.Length <= i + 2)                              throw new ArgumentException(String.Join(" "' tokens' i' tokens.Length - i));                            Int64 sz = 0;                          string v = tokens[i + 2];                          if (v.ToUpper().EndsWith("K"))                              sz = Int64.Parse(v.Substring(0' v.Length - 1)) * 1024;                          else if (v.ToUpper().EndsWith("KB"))                              sz = Int64.Parse(v.Substring(0' v.Length - 2)) * 1024;                          else if (v.ToUpper().EndsWith("M"))                              sz = Int64.Parse(v.Substring(0' v.Length - 1)) * 1024 * 1024;                          else if (v.ToUpper().EndsWith("MB"))                              sz = Int64.Parse(v.Substring(0' v.Length - 2)) * 1024 * 1024;                          else if (v.ToUpper().EndsWith("G"))                              sz = Int64.Parse(v.Substring(0' v.Length - 1)) * 1024 * 1024 * 1024;                          else if (v.ToUpper().EndsWith("GB"))                              sz = Int64.Parse(v.Substring(0' v.Length - 2)) * 1024 * 1024 * 1024;                          else sz = Int64.Parse(tokens[i + 2]);                            current = new SizeCriterion                          {                              Size = sz'                              Operator = (ComparisonOperator)EnumUtil.Parse(typeof(ComparisonOperator)' tokens[i + 1])                          };                          i += 2;                          stateStack.Push(ParseState.CriterionDone);                          break;                        case "filename":                      case "name":                          {                              if (tokens.Length <= i + 2)                                  throw new ArgumentException(String.Join(" "' tokens' i' tokens.Length - i));                                ComparisonOperator c =                                  (ComparisonOperator)EnumUtil.Parse(typeof(ComparisonOperator)' tokens[i + 1]);                                if (c != ComparisonOperator.NotEqualTo && c != ComparisonOperator.EqualTo)                                  throw new ArgumentException(String.Join(" "' tokens' i' tokens.Length - i));                                string m = tokens[i + 2];                                // handle single-quoted filespecs (used to include                              // spaces in filename patterns)                              if (m.StartsWith("'") && m.EndsWith("'"))                              {                                  // trim off leading and trailing single quotes and                                  // revert the control characters to spaces.                                  m = m.Substring(1' m.Length - 2)                                      .Replace("\u0006"' " ");                              }                                // if (m.StartsWith("'"))                              //     m = m.Replace("\u0006"' " ");                                //Fix for Unix -> NormalizeCriteriaExpression replaces all slashes with backslashes                              if (Path.DirectorySeparatorChar == '/')                                  m = m.Replace('\\'' Path.DirectorySeparatorChar);                                current = new NameCriterion                              {                                  MatchingFileSpec = m'                                  Operator = c                              };                              i += 2;                              stateStack.Push(ParseState.CriterionDone);                          }                          break;                        case "attrs":                      case "attributes":                      case "type":                          {                              if (tokens.Length <= i + 2)                                  throw new ArgumentException(String.Join(" "' tokens' i' tokens.Length - i));                                ComparisonOperator c =                                  (ComparisonOperator)EnumUtil.Parse(typeof(ComparisonOperator)' tokens[i + 1]);                                if (c != ComparisonOperator.NotEqualTo && c != ComparisonOperator.EqualTo)                                  throw new ArgumentException(String.Join(" "' tokens' i' tokens.Length - i));                                current = (tok1 == "type")                                  ? (SelectionCriterion) new TypeCriterion                                      {                                          AttributeString = tokens[i + 2]'                                          Operator = c                                      }                                  : (SelectionCriterion) new AttributesCriterion                                      {                                          AttributeString = tokens[i + 2]'                                          Operator = c                                      };                              i += 2;                              stateStack.Push(ParseState.CriterionDone);                          }                          break;                        case "":                          // NOP                          stateStack.Push(ParseState.Whitespace);                          break;                        default:                          throw new ArgumentException("'" + tokens[i] + "'");                  }
Magic Number,Ionic,FileSelector,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\FileSelector.cs,_ParseCriterion,The following statement contains a magic number: switch (tok1)                  {                      case "and":                      case "xor":                      case "or":                          state = stateStack.Peek();                          if (state != ParseState.CriterionDone)                              throw new ArgumentException(String.Join(" "' tokens' i' tokens.Length - i));                            if (tokens.Length <= i + 3)                              throw new ArgumentException(String.Join(" "' tokens' i' tokens.Length - i));                            pendingConjunction = (LogicalConjunction)Enum.Parse(typeof(LogicalConjunction)' tokens[i].ToUpper()' true);                          current = new CompoundCriterion { Left = current' Right = null' Conjunction = pendingConjunction };                          stateStack.Push(state);                          stateStack.Push(ParseState.ConjunctionPending);                          critStack.Push(current);                          break;                        case "(":                          state = stateStack.Peek();                          if (state != ParseState.Start && state != ParseState.ConjunctionPending && state != ParseState.OpenParen)                              throw new ArgumentException(String.Join(" "' tokens' i' tokens.Length - i));                            if (tokens.Length <= i + 4)                              throw new ArgumentException(String.Join(" "' tokens' i' tokens.Length - i));                            stateStack.Push(ParseState.OpenParen);                          break;                        case ")":                          state = stateStack.Pop();                          if (stateStack.Peek() != ParseState.OpenParen)                              throw new ArgumentException(String.Join(" "' tokens' i' tokens.Length - i));                            stateStack.Pop();                          stateStack.Push(ParseState.CriterionDone);                          break;                        case "atime":                      case "ctime":                      case "mtime":                          if (tokens.Length <= i + 2)                              throw new ArgumentException(String.Join(" "' tokens' i' tokens.Length - i));                            DateTime t;                          try                          {                              t = DateTime.ParseExact(tokens[i + 2]' "yyyy-MM-dd-HH:mm:ss"' null);                          }                          catch (FormatException)                          {                              try                              {                                  t = DateTime.ParseExact(tokens[i + 2]' "yyyy/MM/dd-HH:mm:ss"' null);                              }                              catch (FormatException)                              {                                  try                                  {                                      t = DateTime.ParseExact(tokens[i + 2]' "yyyy/MM/dd"' null);                                  }                                  catch (FormatException)                                  {                                      try                                      {                                          t = DateTime.ParseExact(tokens[i + 2]' "MM/dd/yyyy"' null);                                      }                                      catch (FormatException)                                      {                                          t = DateTime.ParseExact(tokens[i + 2]' "yyyy-MM-dd"' null);                                      }                                  }                              }                          }                          t= DateTime.SpecifyKind(t' DateTimeKind.Local).ToUniversalTime();                          current = new TimeCriterion                          {                              Which = (WhichTime)Enum.Parse(typeof(WhichTime)' tokens[i]' true)'                              Operator = (ComparisonOperator)EnumUtil.Parse(typeof(ComparisonOperator)' tokens[i + 1])'                              Time = t                          };                          i += 2;                          stateStack.Push(ParseState.CriterionDone);                          break;                          case "length":                      case "size":                          if (tokens.Length <= i + 2)                              throw new ArgumentException(String.Join(" "' tokens' i' tokens.Length - i));                            Int64 sz = 0;                          string v = tokens[i + 2];                          if (v.ToUpper().EndsWith("K"))                              sz = Int64.Parse(v.Substring(0' v.Length - 1)) * 1024;                          else if (v.ToUpper().EndsWith("KB"))                              sz = Int64.Parse(v.Substring(0' v.Length - 2)) * 1024;                          else if (v.ToUpper().EndsWith("M"))                              sz = Int64.Parse(v.Substring(0' v.Length - 1)) * 1024 * 1024;                          else if (v.ToUpper().EndsWith("MB"))                              sz = Int64.Parse(v.Substring(0' v.Length - 2)) * 1024 * 1024;                          else if (v.ToUpper().EndsWith("G"))                              sz = Int64.Parse(v.Substring(0' v.Length - 1)) * 1024 * 1024 * 1024;                          else if (v.ToUpper().EndsWith("GB"))                              sz = Int64.Parse(v.Substring(0' v.Length - 2)) * 1024 * 1024 * 1024;                          else sz = Int64.Parse(tokens[i + 2]);                            current = new SizeCriterion                          {                              Size = sz'                              Operator = (ComparisonOperator)EnumUtil.Parse(typeof(ComparisonOperator)' tokens[i + 1])                          };                          i += 2;                          stateStack.Push(ParseState.CriterionDone);                          break;                        case "filename":                      case "name":                          {                              if (tokens.Length <= i + 2)                                  throw new ArgumentException(String.Join(" "' tokens' i' tokens.Length - i));                                ComparisonOperator c =                                  (ComparisonOperator)EnumUtil.Parse(typeof(ComparisonOperator)' tokens[i + 1]);                                if (c != ComparisonOperator.NotEqualTo && c != ComparisonOperator.EqualTo)                                  throw new ArgumentException(String.Join(" "' tokens' i' tokens.Length - i));                                string m = tokens[i + 2];                                // handle single-quoted filespecs (used to include                              // spaces in filename patterns)                              if (m.StartsWith("'") && m.EndsWith("'"))                              {                                  // trim off leading and trailing single quotes and                                  // revert the control characters to spaces.                                  m = m.Substring(1' m.Length - 2)                                      .Replace("\u0006"' " ");                              }                                // if (m.StartsWith("'"))                              //     m = m.Replace("\u0006"' " ");                                //Fix for Unix -> NormalizeCriteriaExpression replaces all slashes with backslashes                              if (Path.DirectorySeparatorChar == '/')                                  m = m.Replace('\\'' Path.DirectorySeparatorChar);                                current = new NameCriterion                              {                                  MatchingFileSpec = m'                                  Operator = c                              };                              i += 2;                              stateStack.Push(ParseState.CriterionDone);                          }                          break;                        case "attrs":                      case "attributes":                      case "type":                          {                              if (tokens.Length <= i + 2)                                  throw new ArgumentException(String.Join(" "' tokens' i' tokens.Length - i));                                ComparisonOperator c =                                  (ComparisonOperator)EnumUtil.Parse(typeof(ComparisonOperator)' tokens[i + 1]);                                if (c != ComparisonOperator.NotEqualTo && c != ComparisonOperator.EqualTo)                                  throw new ArgumentException(String.Join(" "' tokens' i' tokens.Length - i));                                current = (tok1 == "type")                                  ? (SelectionCriterion) new TypeCriterion                                      {                                          AttributeString = tokens[i + 2]'                                          Operator = c                                      }                                  : (SelectionCriterion) new AttributesCriterion                                      {                                          AttributeString = tokens[i + 2]'                                          Operator = c                                      };                              i += 2;                              stateStack.Push(ParseState.CriterionDone);                          }                          break;                        case "":                          // NOP                          stateStack.Push(ParseState.Whitespace);                          break;                        default:                          throw new ArgumentException("'" + tokens[i] + "'");                  }
Magic Number,Ionic,FileSelector,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\FileSelector.cs,_ParseCriterion,The following statement contains a magic number: switch (tok1)                  {                      case "and":                      case "xor":                      case "or":                          state = stateStack.Peek();                          if (state != ParseState.CriterionDone)                              throw new ArgumentException(String.Join(" "' tokens' i' tokens.Length - i));                            if (tokens.Length <= i + 3)                              throw new ArgumentException(String.Join(" "' tokens' i' tokens.Length - i));                            pendingConjunction = (LogicalConjunction)Enum.Parse(typeof(LogicalConjunction)' tokens[i].ToUpper()' true);                          current = new CompoundCriterion { Left = current' Right = null' Conjunction = pendingConjunction };                          stateStack.Push(state);                          stateStack.Push(ParseState.ConjunctionPending);                          critStack.Push(current);                          break;                        case "(":                          state = stateStack.Peek();                          if (state != ParseState.Start && state != ParseState.ConjunctionPending && state != ParseState.OpenParen)                              throw new ArgumentException(String.Join(" "' tokens' i' tokens.Length - i));                            if (tokens.Length <= i + 4)                              throw new ArgumentException(String.Join(" "' tokens' i' tokens.Length - i));                            stateStack.Push(ParseState.OpenParen);                          break;                        case ")":                          state = stateStack.Pop();                          if (stateStack.Peek() != ParseState.OpenParen)                              throw new ArgumentException(String.Join(" "' tokens' i' tokens.Length - i));                            stateStack.Pop();                          stateStack.Push(ParseState.CriterionDone);                          break;                        case "atime":                      case "ctime":                      case "mtime":                          if (tokens.Length <= i + 2)                              throw new ArgumentException(String.Join(" "' tokens' i' tokens.Length - i));                            DateTime t;                          try                          {                              t = DateTime.ParseExact(tokens[i + 2]' "yyyy-MM-dd-HH:mm:ss"' null);                          }                          catch (FormatException)                          {                              try                              {                                  t = DateTime.ParseExact(tokens[i + 2]' "yyyy/MM/dd-HH:mm:ss"' null);                              }                              catch (FormatException)                              {                                  try                                  {                                      t = DateTime.ParseExact(tokens[i + 2]' "yyyy/MM/dd"' null);                                  }                                  catch (FormatException)                                  {                                      try                                      {                                          t = DateTime.ParseExact(tokens[i + 2]' "MM/dd/yyyy"' null);                                      }                                      catch (FormatException)                                      {                                          t = DateTime.ParseExact(tokens[i + 2]' "yyyy-MM-dd"' null);                                      }                                  }                              }                          }                          t= DateTime.SpecifyKind(t' DateTimeKind.Local).ToUniversalTime();                          current = new TimeCriterion                          {                              Which = (WhichTime)Enum.Parse(typeof(WhichTime)' tokens[i]' true)'                              Operator = (ComparisonOperator)EnumUtil.Parse(typeof(ComparisonOperator)' tokens[i + 1])'                              Time = t                          };                          i += 2;                          stateStack.Push(ParseState.CriterionDone);                          break;                          case "length":                      case "size":                          if (tokens.Length <= i + 2)                              throw new ArgumentException(String.Join(" "' tokens' i' tokens.Length - i));                            Int64 sz = 0;                          string v = tokens[i + 2];                          if (v.ToUpper().EndsWith("K"))                              sz = Int64.Parse(v.Substring(0' v.Length - 1)) * 1024;                          else if (v.ToUpper().EndsWith("KB"))                              sz = Int64.Parse(v.Substring(0' v.Length - 2)) * 1024;                          else if (v.ToUpper().EndsWith("M"))                              sz = Int64.Parse(v.Substring(0' v.Length - 1)) * 1024 * 1024;                          else if (v.ToUpper().EndsWith("MB"))                              sz = Int64.Parse(v.Substring(0' v.Length - 2)) * 1024 * 1024;                          else if (v.ToUpper().EndsWith("G"))                              sz = Int64.Parse(v.Substring(0' v.Length - 1)) * 1024 * 1024 * 1024;                          else if (v.ToUpper().EndsWith("GB"))                              sz = Int64.Parse(v.Substring(0' v.Length - 2)) * 1024 * 1024 * 1024;                          else sz = Int64.Parse(tokens[i + 2]);                            current = new SizeCriterion                          {                              Size = sz'                              Operator = (ComparisonOperator)EnumUtil.Parse(typeof(ComparisonOperator)' tokens[i + 1])                          };                          i += 2;                          stateStack.Push(ParseState.CriterionDone);                          break;                        case "filename":                      case "name":                          {                              if (tokens.Length <= i + 2)                                  throw new ArgumentException(String.Join(" "' tokens' i' tokens.Length - i));                                ComparisonOperator c =                                  (ComparisonOperator)EnumUtil.Parse(typeof(ComparisonOperator)' tokens[i + 1]);                                if (c != ComparisonOperator.NotEqualTo && c != ComparisonOperator.EqualTo)                                  throw new ArgumentException(String.Join(" "' tokens' i' tokens.Length - i));                                string m = tokens[i + 2];                                // handle single-quoted filespecs (used to include                              // spaces in filename patterns)                              if (m.StartsWith("'") && m.EndsWith("'"))                              {                                  // trim off leading and trailing single quotes and                                  // revert the control characters to spaces.                                  m = m.Substring(1' m.Length - 2)                                      .Replace("\u0006"' " ");                              }                                // if (m.StartsWith("'"))                              //     m = m.Replace("\u0006"' " ");                                //Fix for Unix -> NormalizeCriteriaExpression replaces all slashes with backslashes                              if (Path.DirectorySeparatorChar == '/')                                  m = m.Replace('\\'' Path.DirectorySeparatorChar);                                current = new NameCriterion                              {                                  MatchingFileSpec = m'                                  Operator = c                              };                              i += 2;                              stateStack.Push(ParseState.CriterionDone);                          }                          break;                        case "attrs":                      case "attributes":                      case "type":                          {                              if (tokens.Length <= i + 2)                                  throw new ArgumentException(String.Join(" "' tokens' i' tokens.Length - i));                                ComparisonOperator c =                                  (ComparisonOperator)EnumUtil.Parse(typeof(ComparisonOperator)' tokens[i + 1]);                                if (c != ComparisonOperator.NotEqualTo && c != ComparisonOperator.EqualTo)                                  throw new ArgumentException(String.Join(" "' tokens' i' tokens.Length - i));                                current = (tok1 == "type")                                  ? (SelectionCriterion) new TypeCriterion                                      {                                          AttributeString = tokens[i + 2]'                                          Operator = c                                      }                                  : (SelectionCriterion) new AttributesCriterion                                      {                                          AttributeString = tokens[i + 2]'                                          Operator = c                                      };                              i += 2;                              stateStack.Push(ParseState.CriterionDone);                          }                          break;                        case "":                          // NOP                          stateStack.Push(ParseState.Whitespace);                          break;                        default:                          throw new ArgumentException("'" + tokens[i] + "'");                  }
Magic Number,Ionic,FileSelector,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\FileSelector.cs,_ParseCriterion,The following statement contains a magic number: switch (tok1)                  {                      case "and":                      case "xor":                      case "or":                          state = stateStack.Peek();                          if (state != ParseState.CriterionDone)                              throw new ArgumentException(String.Join(" "' tokens' i' tokens.Length - i));                            if (tokens.Length <= i + 3)                              throw new ArgumentException(String.Join(" "' tokens' i' tokens.Length - i));                            pendingConjunction = (LogicalConjunction)Enum.Parse(typeof(LogicalConjunction)' tokens[i].ToUpper()' true);                          current = new CompoundCriterion { Left = current' Right = null' Conjunction = pendingConjunction };                          stateStack.Push(state);                          stateStack.Push(ParseState.ConjunctionPending);                          critStack.Push(current);                          break;                        case "(":                          state = stateStack.Peek();                          if (state != ParseState.Start && state != ParseState.ConjunctionPending && state != ParseState.OpenParen)                              throw new ArgumentException(String.Join(" "' tokens' i' tokens.Length - i));                            if (tokens.Length <= i + 4)                              throw new ArgumentException(String.Join(" "' tokens' i' tokens.Length - i));                            stateStack.Push(ParseState.OpenParen);                          break;                        case ")":                          state = stateStack.Pop();                          if (stateStack.Peek() != ParseState.OpenParen)                              throw new ArgumentException(String.Join(" "' tokens' i' tokens.Length - i));                            stateStack.Pop();                          stateStack.Push(ParseState.CriterionDone);                          break;                        case "atime":                      case "ctime":                      case "mtime":                          if (tokens.Length <= i + 2)                              throw new ArgumentException(String.Join(" "' tokens' i' tokens.Length - i));                            DateTime t;                          try                          {                              t = DateTime.ParseExact(tokens[i + 2]' "yyyy-MM-dd-HH:mm:ss"' null);                          }                          catch (FormatException)                          {                              try                              {                                  t = DateTime.ParseExact(tokens[i + 2]' "yyyy/MM/dd-HH:mm:ss"' null);                              }                              catch (FormatException)                              {                                  try                                  {                                      t = DateTime.ParseExact(tokens[i + 2]' "yyyy/MM/dd"' null);                                  }                                  catch (FormatException)                                  {                                      try                                      {                                          t = DateTime.ParseExact(tokens[i + 2]' "MM/dd/yyyy"' null);                                      }                                      catch (FormatException)                                      {                                          t = DateTime.ParseExact(tokens[i + 2]' "yyyy-MM-dd"' null);                                      }                                  }                              }                          }                          t= DateTime.SpecifyKind(t' DateTimeKind.Local).ToUniversalTime();                          current = new TimeCriterion                          {                              Which = (WhichTime)Enum.Parse(typeof(WhichTime)' tokens[i]' true)'                              Operator = (ComparisonOperator)EnumUtil.Parse(typeof(ComparisonOperator)' tokens[i + 1])'                              Time = t                          };                          i += 2;                          stateStack.Push(ParseState.CriterionDone);                          break;                          case "length":                      case "size":                          if (tokens.Length <= i + 2)                              throw new ArgumentException(String.Join(" "' tokens' i' tokens.Length - i));                            Int64 sz = 0;                          string v = tokens[i + 2];                          if (v.ToUpper().EndsWith("K"))                              sz = Int64.Parse(v.Substring(0' v.Length - 1)) * 1024;                          else if (v.ToUpper().EndsWith("KB"))                              sz = Int64.Parse(v.Substring(0' v.Length - 2)) * 1024;                          else if (v.ToUpper().EndsWith("M"))                              sz = Int64.Parse(v.Substring(0' v.Length - 1)) * 1024 * 1024;                          else if (v.ToUpper().EndsWith("MB"))                              sz = Int64.Parse(v.Substring(0' v.Length - 2)) * 1024 * 1024;                          else if (v.ToUpper().EndsWith("G"))                              sz = Int64.Parse(v.Substring(0' v.Length - 1)) * 1024 * 1024 * 1024;                          else if (v.ToUpper().EndsWith("GB"))                              sz = Int64.Parse(v.Substring(0' v.Length - 2)) * 1024 * 1024 * 1024;                          else sz = Int64.Parse(tokens[i + 2]);                            current = new SizeCriterion                          {                              Size = sz'                              Operator = (ComparisonOperator)EnumUtil.Parse(typeof(ComparisonOperator)' tokens[i + 1])                          };                          i += 2;                          stateStack.Push(ParseState.CriterionDone);                          break;                        case "filename":                      case "name":                          {                              if (tokens.Length <= i + 2)                                  throw new ArgumentException(String.Join(" "' tokens' i' tokens.Length - i));                                ComparisonOperator c =                                  (ComparisonOperator)EnumUtil.Parse(typeof(ComparisonOperator)' tokens[i + 1]);                                if (c != ComparisonOperator.NotEqualTo && c != ComparisonOperator.EqualTo)                                  throw new ArgumentException(String.Join(" "' tokens' i' tokens.Length - i));                                string m = tokens[i + 2];                                // handle single-quoted filespecs (used to include                              // spaces in filename patterns)                              if (m.StartsWith("'") && m.EndsWith("'"))                              {                                  // trim off leading and trailing single quotes and                                  // revert the control characters to spaces.                                  m = m.Substring(1' m.Length - 2)                                      .Replace("\u0006"' " ");                              }                                // if (m.StartsWith("'"))                              //     m = m.Replace("\u0006"' " ");                                //Fix for Unix -> NormalizeCriteriaExpression replaces all slashes with backslashes                              if (Path.DirectorySeparatorChar == '/')                                  m = m.Replace('\\'' Path.DirectorySeparatorChar);                                current = new NameCriterion                              {                                  MatchingFileSpec = m'                                  Operator = c                              };                              i += 2;                              stateStack.Push(ParseState.CriterionDone);                          }                          break;                        case "attrs":                      case "attributes":                      case "type":                          {                              if (tokens.Length <= i + 2)                                  throw new ArgumentException(String.Join(" "' tokens' i' tokens.Length - i));                                ComparisonOperator c =                                  (ComparisonOperator)EnumUtil.Parse(typeof(ComparisonOperator)' tokens[i + 1]);                                if (c != ComparisonOperator.NotEqualTo && c != ComparisonOperator.EqualTo)                                  throw new ArgumentException(String.Join(" "' tokens' i' tokens.Length - i));                                current = (tok1 == "type")                                  ? (SelectionCriterion) new TypeCriterion                                      {                                          AttributeString = tokens[i + 2]'                                          Operator = c                                      }                                  : (SelectionCriterion) new AttributesCriterion                                      {                                          AttributeString = tokens[i + 2]'                                          Operator = c                                      };                              i += 2;                              stateStack.Push(ParseState.CriterionDone);                          }                          break;                        case "":                          // NOP                          stateStack.Push(ParseState.Whitespace);                          break;                        default:                          throw new ArgumentException("'" + tokens[i] + "'");                  }
Duplicate Code,Ionic.BZip2,BZip2Compressor,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\BZip2\BZip2Compressor.cs,generateMTFValues,The method contains a code clone-set at the following line numbers (starting from the method definition): ((60' 86)' (95' 121))
Duplicate Code,Ionic.BZip2,BZip2Compressor,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\BZip2\BZip2Compressor.cs,hbMakeCodeLengths,The method contains a code clone-set at the following line numbers (starting from the method definition): ((50' 75)' (84' 109))
Duplicate Code,Ionic.BZip2,BZip2InputStream,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\BZip2\BZip2InputStream.cs,getAndMoveToFrontDecode,The method contains a code clone-set at the following line numbers (starting from the method definition): ((59' 113)' (158' 212))
Duplicate Code,Ionic.Zlib,InflateBlocks,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zlib.Shared\Inflate.cs,Process,The method contains a code clone-set at the following line numbers (starting from the method definition): ((28' 47)' (245' 264)' (186' 205)' (246' 265))
Duplicate Code,Ionic.Zlib,InflateBlocks,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zlib.Shared\Inflate.cs,Process,The method contains a code clone-set at the following line numbers (starting from the method definition): ((186' 205)' (313' 332)' (348' 367)' (246' 265))
Missing Default,Ionic.Zlib,DeflateManager,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zlib.Shared\Deflate.cs,SetDeflater,The following switch statement is missing a default case: switch (config.Flavor)              {                  case DeflateFlavor.Store:                      DeflateFunction = DeflateNone;                      break;                  case DeflateFlavor.Fast:                      DeflateFunction = DeflateFast;                      break;                  case DeflateFlavor.Slow:                      DeflateFunction = DeflateSlow;                      break;              }
Missing Default,Ionic.Zlib,InflateBlocks,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zlib.Shared\Inflate.cs,Process,The following switch statement is missing a default case: switch ((uint)t >> 1)                          {                              case 0:  // stored                                  b >>= 3; k -= (3);                                  t = k & 7; // go to byte boundary                                  b >>= t; k -= t;                                  mode = InflateBlockMode.LENS; // get length of stored block                                  break;                                case 1:  // fixed                                  int[] bl = new int[1];                                  int[] bd = new int[1];                                  int[][] tl = new int[1][];                                  int[][] td = new int[1][];                                  InfTree.inflate_trees_fixed(bl' bd' tl' td' _codec);                                  codes.Init(bl[0]' bd[0]' tl[0]' 0' td[0]' 0);                                  b >>= 3; k -= 3;                                  mode = InflateBlockMode.CODES;                                  break;                                case 2:  // dynamic                                  b >>= 3; k -= 3;                                  mode = InflateBlockMode.TABLE;                                  break;                                case 3:  // illegal                                  b >>= 3; k -= 3;                                  mode = InflateBlockMode.BAD;                                  _codec.Message = "invalid block type";                                  r = ZlibConstants.Z_DATA_ERROR;                                  bitb = b; bitk = k;                                  _codec.AvailableBytesIn = n;                                  _codec.TotalBytesIn += p - _codec.NextIn;                                  _codec.NextIn = p;                                  writeAt = q;                                  return Flush(r);                          }
Missing Default,Ionic.Zip,ZipEntry,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipDirEntry.cs,GetExtractDecompressor,The following switch statement is missing a default case: switch (_CompressionMethod_FromZipFile)              {                  case (short)CompressionMethod.None:                      return input2;                  case (short)CompressionMethod.Deflate:                      return new Zlib.DeflateStream(input2' Zlib.CompressionMode.Decompress' true);  #if BZIP                  case (short)CompressionMethod.BZip2:                      return new BZip2.BZip2InputStream(input2' true);  #endif              }
Missing Default,Ionic.Zip,ZipEntry,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipDirEntry.cs,ProcessExtraField,The following switch statement is missing a default case: switch (headerId)                      {                          case 0x000a:  // NTFS ctime' atime' mtime                              j = ProcessExtraFieldWindowsTimes(buffer' j' dataSize' posn);                              break;                            case 0x5455:  // Unix ctime' atime' mtime                              j = ProcessExtraFieldUnixTimes(buffer' j' dataSize' posn);                              break;                            case 0x5855:  // Info-zip Extra field (outdated)                              // This is outdated' so the field is supported on                              // read only.                              j = ProcessExtraFieldInfoZipTimes(buffer' j' dataSize' posn);                              break;                            case 0x7855:  // Unix uid/gid                              // ignored. DotNetZip does not handle this field.                              break;                            case 0x7875:  // ??                              // ignored.  I could not find documentation on this field'                              // though it appears in some zip files.                              break;                            case 0x0001: // ZIP64                              j = ProcessExtraFieldZip64(buffer' j' dataSize' posn);                              break;    #if AESCRYPTO                          case 0x9901: // WinZip AES encryption is in use.  (workitem 6834)                              // we will handle this extra field only  if compressionmethod is 0x63                              j = ProcessExtraFieldWinZipAes(buffer' j' dataSize' posn);                              break;  #endif                          case 0x0017: // workitem 7968: handle PKWare Strong encryption header                              j = ProcessExtraFieldPkwareStrongEncryption(buffer' j);                              break;                      }
Missing Default,Ionic.Zip,ZipEntry,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipDirEntry.cs,GetEncodedFileNameBytes,The following switch statement is missing a default case: switch(AlternateEncodingUsage)              {                  case ZipOption.Always:                      if (!(_Comment == null || _Comment.Length == 0))                          _CommentBytes = AlternateEncoding.GetBytes(_Comment);                      _actualEncoding = AlternateEncoding;                      return AlternateEncoding.GetBytes(s1);                    case ZipOption.Never:                      if (!(_Comment == null || _Comment.Length == 0))                          _CommentBytes = ibm437.GetBytes(_Comment);                      _actualEncoding = ibm437;                      return ibm437.GetBytes(s1);              }
Missing Default,Ionic.Zip,ZipOutput,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipFile.Save.cs,GetEncoding,The following switch statement is missing a default case: switch (container.AlternateEncodingUsage)              {                  case ZipOption.Always:                      return container.AlternateEncoding;                  case ZipOption.Never:                      return container.DefaultEncoding;              }
Missing Default,Ionic,CompoundCriterion,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\FileSelector.cs,Evaluate,The following switch statement is missing a default case: switch (Conjunction)              {                  case LogicalConjunction.AND:                      if (result)                          result = Right.Evaluate(entry);                      break;                  case LogicalConjunction.OR:                      if (!result)                          result = Right.Evaluate(entry);                      break;                  case LogicalConjunction.XOR:                      result ^= Right.Evaluate(entry);                      break;              }
