Implementation smell,Namespace,Class,File,Method,Description
Long Method,Ionic.Zip,ZipEntry,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipDirEntry.cs,ReadDirEntry,The method has 151 lines of code.
Long Method,Ionic.Zip,ZipEntry,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipDirEntry.cs,ReadHeader,The method has 195 lines of code.
Long Method,Ionic.Zip,ZipEntry,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipDirEntry.cs,WriteCentralDirectoryEntry,The method has 220 lines of code.
Long Method,Ionic.Zip,ZipEntry,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipDirEntry.cs,ConstructExtraField,The method has 195 lines of code.
Long Method,Ionic.Zip,ZipEntry,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipDirEntry.cs,WriteHeader,The method has 346 lines of code.
Long Method,Ionic.Zip,ZipEntry,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipDirEntry.cs,PostProcessOutput,The method has 270 lines of code.
Long Method,Ionic.Zip,ZipEntry,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipDirEntry.cs,Write,The method has 156 lines of code.
Long Method,Ionic.Zip,ZipFile,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipFile.AddUpdate.cs,Save,The method has 160 lines of code.
Long Method,Ionic.Zip,ZipOutput,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipFile.Save.cs,WriteCentralDirectoryStructure,The method has 109 lines of code.
Long Method,Ionic,FileSelector,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\FileSelector.cs,_ParseCriterion,The method has 212 lines of code.
Complex Method,Ionic.Zip,ZipEntry,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipDirEntry.cs,ReadDirEntry,Cyclomatic complexity of the method is 17
Complex Method,Ionic.Zip,ZipEntry,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipDirEntry.cs,Create,Cyclomatic complexity of the method is 9
Complex Method,Ionic.Zip,ZipEntry,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipDirEntry.cs,InternalExtractToBaseDir,Cyclomatic complexity of the method is 11
Complex Method,Ionic.Zip,ZipEntry,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipDirEntry.cs,GetUnsupportedAlgorithm,Cyclomatic complexity of the method is 13
Complex Method,Ionic.Zip,ZipEntry,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipDirEntry.cs,GetUnsupportedCompressionMethod,Cyclomatic complexity of the method is 9
Complex Method,Ionic.Zip,ZipEntry,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipDirEntry.cs,ReadHeader,Cyclomatic complexity of the method is 17
Complex Method,Ionic.Zip,ZipEntry,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipDirEntry.cs,ProcessExtraField,Cyclomatic complexity of the method is 9
Complex Method,Ionic.Zip,ZipEntry,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipDirEntry.cs,WriteCentralDirectoryEntry,Cyclomatic complexity of the method is 9
Complex Method,Ionic.Zip,ZipEntry,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipDirEntry.cs,ConstructExtraField,Cyclomatic complexity of the method is 11
Complex Method,Ionic.Zip,ZipEntry,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipDirEntry.cs,GetEncodedFileNameBytes,Cyclomatic complexity of the method is 8
Complex Method,Ionic.Zip,ZipEntry,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipDirEntry.cs,MaybeUnsetCompressionMethodForWriting,Cyclomatic complexity of the method is 10
Complex Method,Ionic.Zip,ZipEntry,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipDirEntry.cs,WriteHeader,Cyclomatic complexity of the method is 15
Complex Method,Ionic.Zip,ZipEntry,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipDirEntry.cs,FigureCrc32,Cyclomatic complexity of the method is 9
Complex Method,Ionic.Zip,ZipEntry,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipDirEntry.cs,PostProcessOutput,Cyclomatic complexity of the method is 19
Complex Method,Ionic.Zip,ZipEntry,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipDirEntry.cs,CopyThroughWithRecompute,Cyclomatic complexity of the method is 10
Complex Method,Ionic.Zip,ZipFile,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipFile.AddUpdate.cs,AddFiles,Cyclomatic complexity of the method is 9
Complex Method,Ionic.Zip,ZipFile,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipFile.AddUpdate.cs,AddOrUpdateDirectoryImpl,Cyclomatic complexity of the method is 17
Complex Method,Ionic.Zip,ZipFile,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipFile.AddUpdate.cs,CheckZip,Cyclomatic complexity of the method is 15
Complex Method,Ionic.Zip,ZipFile,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipFile.AddUpdate.cs,Dispose,Cyclomatic complexity of the method is 8
Complex Method,Ionic.Zip,ZipFile,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipFile.AddUpdate.cs,_InternalExtractAll,Cyclomatic complexity of the method is 10
Complex Method,Ionic.Zip,ZipFile,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipFile.AddUpdate.cs,ReadCentralDirectory,Cyclomatic complexity of the method is 9
Complex Method,Ionic.Zip,ZipFile,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipFile.AddUpdate.cs,ReadIntoInstance_Orig,Cyclomatic complexity of the method is 11
Complex Method,Ionic.Zip,ZipFile,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipFile.AddUpdate.cs,Save,Cyclomatic complexity of the method is 21
Complex Method,Ionic.Zip,ZipFile,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipFile.AddUpdate.cs,_AddOrUpdateSelectedFiles,Cyclomatic complexity of the method is 9
Complex Method,Ionic.Zip,ZipOutput,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipFile.Save.cs,WriteCentralDirectoryStructure,Cyclomatic complexity of the method is 10
Complex Method,Ionic.Zip,ZipOutput,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipFile.Save.cs,GenCentralDirectoryFooter,Cyclomatic complexity of the method is 10
Complex Method,Ionic.Zip,ZipSegmentedStream,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipSegmentedStream.cs,TruncateBackward,Cyclomatic complexity of the method is 8
Complex Method,Ionic,FileSelector,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\FileSelector.cs,_ParseCriterion,Cyclomatic complexity of the method is 37
Complex Method,Ionic,FileSelector,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\FileSelector.cs,SelectFiles,Cyclomatic complexity of the method is 9
Long Parameter List,Ionic.Zip,SaveProgressEventArgs,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\Events.cs,SaveProgressEventArgs,The method has 5 parameters. Parameters: archiveName' before' entriesTotal' entriesSaved' entry
Long Parameter List,Ionic.Zip,ExtractProgressEventArgs,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\Events.cs,ExtractProgressEventArgs,The method has 6 parameters. Parameters: archiveName' before' entriesTotal' entriesExtracted' entry' extractLocation
Long Parameter List,Ionic.Zip,SharedUtilities,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\Shared.cs,ReadWithRetry,The method has 5 parameters. Parameters: s' buffer' offset' count' FileName
Long Parameter List,Ionic.Zip,ZipEntry,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipDirEntry.cs,InternalExtractToBaseDir,The method has 5 parameters. Parameters: baseDir' password' zipContainer' zipEntrySource' fileName
Long Parameter List,Ionic.Zip,ZipEntry,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipDirEntry.cs,InternalExtractToStream,The method has 5 parameters. Parameters: outStream' password' zipContainer' zipEntrySource' fileName
Long Parameter List,Ionic.Zip,ZipEntry,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipDirEntry.cs,VerifyCrcAfterExtract,The method has 5 parameters. Parameters: calculatedCrc32' encryptionAlgorithm' expectedCrc32' archiveStream' uncompressedSize
Long Parameter List,Ionic.Zip,ZipEntry,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipDirEntry.cs,ExtractAndCrc,The method has 5 parameters. Parameters: archiveStream' targetOutput' compressionMethod' compressedFileDataSize' uncompressedSize
Long Parameter List,Ionic.Zip,ZipEntry,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipDirEntry.cs,FinishOutputStream,The method has 5 parameters. Parameters: s' entryCounter' encryptor' compressor' output
Long Parameter List,Ionic.Zip,ZipEntry,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipDirEntry.cs,PrepOutputStream,The method has 6 parameters. Parameters: s' streamLength' outputCounter' encryptor' compressor' output
Long Parameter List,Ionic.Zip,ZipFile,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipFile.AddUpdate.cs,AddOrUpdateDirectoryImpl,The method has 5 parameters. Parameters: directoryName' rootDirectoryPathInArchive' action' recurse' level
Long Parameter List,Ionic.Zip,ZipFile,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipFile.AddUpdate.cs,_AddOrUpdateSelectedFiles,The method has 5 parameters. Parameters: selectionCriteria' directoryOnDisk' directoryPathInArchive' recurseDirectories' wantUpdate
Long Parameter List,Ionic.Zip,ZipOutput,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipFile.Save.cs,WriteCentralDirectoryStructure,The method has 6 parameters. Parameters: s' entries' numSegments' zip64' comment' container
Long Parameter List,Ionic.Zip,ZipOutput,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipFile.Save.cs,GenCentralDirectoryFooter,The method has 6 parameters. Parameters: StartOfCentralDirectory' EndOfCentralDirectory' zip64' entryCount' comment' container
Long Identifier,Ionic.Zip,ZipConstants,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipConstants.cs,,The length of the parameter Zip64EndOfCentralDirectoryRecordSignature is 41.
Long Identifier,Ionic.Zip,ZipConstants,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipConstants.cs,,The length of the parameter Zip64EndOfCentralDirectoryLocatorSignature is 42.
Long Identifier,Ionic.Zip,ZipConstants,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipConstants.cs,,The length of the parameter EndOfCentralDirectorySignature is 30.
Long Identifier,Ionic.Zip,ZipConstants,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipConstants.cs,,The length of the parameter ZipEntryDataDescriptorSignature is 31.
Long Identifier,Ionic.Zip,ZipEntry,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipDirEntry.cs,,The length of the parameter _TrimVolumeFromFullyQualifiedPaths is 34.
Long Identifier,Ionic.Zip,ZipEntry,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipDirEntry.cs,,The length of the parameter _CompressionMethod_FromZipFile is 30.
Long Identifier,Ionic.Zip,ZipFile,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipFile.AddUpdate.cs,_InternalExtractAll,The length of the parameter overrideExtractExistingProperty is 31.
Long Identifier,Ionic.Zip,ZipFile,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipFile.AddUpdate.cs,,The length of the parameter _numberOfSegmentsForMostRecentSave is 34.
Long Identifier,Ionic,FileSelector,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\FileSelector.cs,FileSelector,The length of the parameter traverseDirectoryReparsePoints is 30.
Long Identifier,Ionic,RegexAssertions,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\FileSelector.cs,,The length of the parameter PrecededByOddNumberOfSingleQuotes is 33.
Long Identifier,Ionic,RegexAssertions,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\FileSelector.cs,,The length of the parameter FollowedByOddNumberOfSingleQuotesAndLineEnd is 43.
Long Identifier,Ionic,RegexAssertions,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\FileSelector.cs,,The length of the parameter PrecededByEvenNumberOfSingleQuotes is 34.
Long Identifier,Ionic,RegexAssertions,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\FileSelector.cs,,The length of the parameter FollowedByEvenNumberOfSingleQuotesAndLineEnd is 44.
Long Statement,Ionic.Zip,SharedUtilities,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\Shared.cs,DateTimeToPacked,The length of the statement  "            UInt16 packedDate = (UInt16)((time.Day & 0x0000001F) | ((time.Month << 5) & 0x000001E0) | (((time.Year - 1980) << 9) & 0x0000FE00)); " is 132.
Long Statement,Ionic.Zip,SharedUtilities,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\Shared.cs,DateTimeToPacked,The length of the statement  "            UInt16 packedTime = (UInt16)((time.Second / 2 & 0x0000001F) | ((time.Minute << 5) & 0x000007E0) | ((time.Hour << 11) & 0x0000F800)); " is 132.
Long Statement,Ionic.Zip,SharedUtilities,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\Shared.cs,ReadWithRetry,The length of the statement  "                            throw new System.IO.IOException(String.Format("Cannot read file {0}' at offset 0x{1:X8} after 10 retries"' FileName' offset)' ioexc1); " is 134.
Long Statement,Ionic.Zip,ZipCrypto,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipCrypto.cs,DecryptMessage,The length of the statement  "                                                      "Bad length during Decryption: the length parameter must be smaller than or equal to the size of the destination array."); " is 122.
Long Statement,Ionic.Zip,ZipCrypto,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipCrypto.cs,EncryptMessage,The length of the statement  "                                                      "Bad length during Encryption: The length parameter must be smaller than or equal to the size of the destination array."); " is 122.
Long Statement,Ionic.Zip,ZipEntry,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipDirEntry.cs,ReadDirEntry,The length of the statement  "                zde._RelativeOffsetOfLocalHeader = (uint)(block[i++] + block[i++] * 256 + block[i++] * 256 * 256 + block[i++] * 256 * 256 * 256); " is 129.
Long Statement,Ionic.Zip,ZipEntry,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipDirEntry.cs,ValidateEncryption,The length of the statement  "                    throw new ZipException(string.Format("Cannot extract: Entry {0} is encrypted with an algorithm not supported by DotNetZip: {1}"' " is 128.
Long Statement,Ionic.Zip,ZipEntry,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipDirEntry.cs,ReadHeader,The length of the statement  "                    throw new BadReadException(String.Format("  Bad signature (0x{0:X8}) at position  0x{1:X8}"' signature' ze.ArchiveStream.Position)); " is 132.
Long Statement,Ionic.Zip,ZipEntry,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipDirEntry.cs,ReadHeader,The length of the statement  "                ze._Encryption_FromZipFile = ze._Encryption = EncryptionAlgorithm.PkzipWeak; // this *may* change after processing the Extra field " is 130.
Long Statement,Ionic.Zip,ZipEntry,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipDirEntry.cs,ProcessExtraFieldInfoZipTimes,The length of the statement  "                throw new BadReadException(String.Format("  Unexpected size (0x{0:X4}) for InfoZip v1 extra field at position 0x{1:X16}"' dataSize' posn)); " is 139.
Long Statement,Ionic.Zip,ZipEntry,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipDirEntry.cs,ProcessExtraFieldUnixTimes,The length of the statement  "                throw new BadReadException(String.Format("  Unexpected size (0x{0:X4}) for Extended Timestamp extra field at position 0x{1:X16}"' dataSize' posn)); " is 147.
Long Statement,Ionic.Zip,ZipEntry,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipDirEntry.cs,ProcessExtraFieldWindowsTimes,The length of the statement  "                throw new BadReadException(String.Format("  Unexpected size (0x{0:X4}) for NTFS times extra field at position 0x{1:X16}"' dataSize' posn)); " is 139.
Long Statement,Ionic.Zip,ZipEntry,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipDirEntry.cs,WantReadAgain,The length of the statement  "            if (_aesCrypto_forWrite != null && (CompressedSize - _aesCrypto_forWrite.SizeOfEncryptionMetadata) <= UncompressedSize + 0x10) return false; " is 140.
Long Statement,Ionic.Zip,ZipEntry,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipDirEntry.cs,WriteHeader,The length of the statement  "                throw new ZipException("Offset within the zip archive exceeds 0xFFFFFFFF. Consider setting the UseZip64WhenSaving property on the ZipFile instance."); " is 150.
Long Statement,Ionic.Zip,ZipEntry,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipDirEntry.cs,SetInputAndFigureFileLength,The length of the statement  "                string pwd = (_Encryption_FromZipFile == EncryptionAlgorithm.None) ? null : (this._Password ?? this._container.Password); " is 121.
Long Statement,Ionic.Zip,ZipEntry,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipDirEntry.cs,SetZip64Flags,The length of the statement  "                throw new ZipException("Compressed or Uncompressed size' or offset exceeds the maximum value. Consider setting the UseZip64WhenSaving property on the ZipFile instance."); " is 170.
Long Statement,Ionic.Zip,ZipFile,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipFile.AddUpdate.cs,AnyCaseInsensitiveMatches,The length of the statement  "            // this has to search _entries rather than _caseInsensitiveEntries because it's used to determine whether to update the latter " is 126.
Long Statement,Ionic.Zip,ZipFile,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipFile.AddUpdate.cs,Zip64SeekToCentralDirectory,The length of the statement  "                throw new BadReadException(String.Format("  Bad signature (0x{0:X8}) looking for ZIP64 EoCD Record at position 0x{1:X8}"' datum' s.Position)); " is 142.
Long Statement,Ionic.Zip,ZipFile,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipFile.AddUpdate.cs,Save,The length of the statement  "                    throw new ZipException("The number of entries is 65535 or greater. Consider setting the UseZip64WhenSaving property on the ZipFile instance."); " is 143.
Long Statement,Ionic.Zip,ZipFile,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipFile.AddUpdate.cs,Save,The length of the statement  "                throw new ZipException("Bad Directory"' new System.ArgumentException("That name specifies an existing directory. Please specify a filename."' "fileName")); " is 155.
Long Statement,Ionic.Zip,ZipOutput,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipFile.Save.cs,WriteCentralDirectoryStructure,The length of the statement  "                        throw new ZipException("The archive requires a ZIP64 Central Directory. Consider setting the ZipFile.UseZip64WhenSaving property."); " is 132.
Long Statement,Ionic.Zip,ZipOutput,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipFile.Save.cs,WriteCentralDirectoryStructure,The length of the statement  "                        throw new ZipException("The archive requires a ZIP64 Central Directory. Consider setting the ZipOutputStream.EnableZip64 property."); " is 133.
Long Statement,Ionic.Zip,ZipInputStream,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipInputStream.cs,Read,The length of the statement  "                _currentEntry.VerifyCrcAfterExtract(CrcResult' _currentEntry.Encryption' _currentEntry._Crc32' _currentEntry.ArchiveStream' _currentEntry.UncompressedSize); " is 156.
Long Statement,Ionic,TimeCriterion,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\FileSelector.cs,ToString,The length of the statement  "            sb.Append(Which.ToString()).Append(" ").Append(EnumUtil.GetDescription(Operator)).Append(" ").Append(Time.ToString("yyyy-MM-dd-HH:mm:ss")); " is 139.
Long Statement,Ionic,NameCriterion,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\FileSelector.cs,Evaluate,The length of the statement  "            string transformedFileName = entry.FileName.Replace(Path.DirectorySeparatorChar == '/' ? '\\' : '/'' Path.DirectorySeparatorChar); " is 130.
Complex Conditional,Ionic.Zip,ZipEntry,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipDirEntry.cs,ConstructExtraField,The conditional expression  "_container.Zip64 == Zip64Option.Always ||                  (_container.Zip64 == Zip64Option.AsNecessary &&                   (!forCentralDirectory || _entryRequiresZip64.Value))"  is complex.
Complex Conditional,Ionic.Zip,ZipEntry,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipDirEntry.cs,NormalizeFileName,The conditional expression  "(_TrimVolumeFromFullyQualifiedPaths) && (FileName.Length >= 3)                  && (FileName[1] == ':') && (SlashFixed[2] == '/')"  is complex.
Empty Catch Block,Ionic.Zip,SharedUtilities,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\Shared.cs,StringToByteArray,The method has an empty catch block.
Empty Catch Block,Ionic.Zip,SharedUtilities,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\Shared.cs,StringToByteArray,The method has an empty catch block.
Empty Catch Block,Ionic.Zip,SharedUtilities,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\Shared.cs,ReadSignature,The method has an empty catch block.
Empty Catch Block,Ionic.Zip,SharedUtilities,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\Shared.cs,ReadEntrySignature,The method has an empty catch block.
Empty Catch Block,Ionic.Zip,SharedUtilities,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\Shared.cs,PackedToDateTime,The method has an empty catch block.
Empty Catch Block,Ionic.Zip,SharedUtilities,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\Shared.cs,PackedToDateTime,The method has an empty catch block.
Empty Catch Block,Ionic.Zip,ZipEntry,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipDirEntry.cs,_WriteEntryData,The method has an empty catch block.
Empty Catch Block,Ionic.Zip,ZipEntry,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipDirEntry.cs,SetInputAndFigureFileLength,The method has an empty catch block.
Empty Catch Block,Ionic.Zip,ZipEntry,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipDirEntry.cs,SetInputAndFigureFileLength,The method has an empty catch block.
Empty Catch Block,Ionic.Zip,ZipFile,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipFile.AddUpdate.cs,CheckZipPassword,The method has an empty catch block.
Empty Catch Block,Ionic.Zip,ZipFile,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipFile.AddUpdate.cs,ReadIntoInstance_Orig,The method has an empty catch block.
Empty Catch Block,Ionic.Zip,ZipFile,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipFile.AddUpdate.cs,ReadIntoInstance_Orig,The method has an empty catch block.
Empty Catch Block,Ionic.Zip,ZipFile,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipFile.AddUpdate.cs,IsZipFile,The method has an empty catch block.
Empty Catch Block,Ionic.Zip,ZipFile,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipFile.AddUpdate.cs,IsZipFile,The method has an empty catch block.
Empty Catch Block,Ionic.Zip,ZipFile,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipFile.AddUpdate.cs,IsZipFile,The method has an empty catch block.
Empty Catch Block,Ionic.Zip,ZipFile,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipFile.AddUpdate.cs,IsZipFile,The method has an empty catch block.
Empty Catch Block,Ionic.Zip,ZipFile,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipFile.AddUpdate.cs,Save,The method has an empty catch block.
Empty Catch Block,Ionic.Zip,ZipFile,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipFile.AddUpdate.cs,CleanupAfterSaveOperation,The method has an empty catch block.
Empty Catch Block,Ionic.Zip,ZipFile,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipFile.AddUpdate.cs,ZipFile,The method has an empty catch block.
Empty Catch Block,Ionic.Zip,ZipFile,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipFile.AddUpdate.cs,ZipFile,The method has an empty catch block.
Empty Catch Block,Ionic,FileSelector,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\FileSelector.cs,SelectFiles,The method has an empty catch block.
Empty Catch Block,Ionic,FileSelector,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\FileSelector.cs,SelectFiles,The method has an empty catch block.
Magic Number,Ionic.Zip,SharedUtilities,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\Shared.cs,SimplifyFwdSlashPath,The following statement contains a magic number: path = path.Substring(2);
Magic Number,Ionic.Zip,SharedUtilities,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\Shared.cs,NormalizePathForUseInZipFile,The following statement contains a magic number: pathName =  pathName.Substring(3);
Magic Number,Ionic.Zip,SharedUtilities,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\Shared.cs,NormalizePathForUseInZipFile,The following statement contains a magic number: (pathName.Length >= 2)  && ((pathName[1] == ':') && (pathName[2] == '\\'))
Magic Number,Ionic.Zip,SharedUtilities,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\Shared.cs,NormalizePathForUseInZipFile,The following statement contains a magic number: (pathName.Length >= 2)  && ((pathName[1] == ':') && (pathName[2] == '\\'))
Magic Number,Ionic.Zip,SharedUtilities,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\Shared.cs,StringToByteArray,The following statement contains a magic number: ibm437 = System.Text.Encoding.GetEncoding(1252);
Magic Number,Ionic.Zip,SharedUtilities,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\Shared.cs,ReadEntrySignature,The following statement contains a magic number: s.Seek(12' SeekOrigin.Current);
Magic Number,Ionic.Zip,SharedUtilities,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\Shared.cs,ReadEntrySignature,The following statement contains a magic number: s.Seek(8' SeekOrigin.Current);
Magic Number,Ionic.Zip,SharedUtilities,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\Shared.cs,ReadEntrySignature,The following statement contains a magic number: s.Seek(-24' SeekOrigin.Current);
Magic Number,Ionic.Zip,SharedUtilities,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\Shared.cs,_ReadFourBytes,The following statement contains a magic number: byte[] block = new byte[4];
Magic Number,Ionic.Zip,SharedUtilities,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\Shared.cs,_ReadFourBytes,The following statement contains a magic number: int data = unchecked((((block[3] * 256 + block[2]) * 256) + block[1]) * 256 + block[0]);
Magic Number,Ionic.Zip,SharedUtilities,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\Shared.cs,_ReadFourBytes,The following statement contains a magic number: int data = unchecked((((block[3] * 256 + block[2]) * 256) + block[1]) * 256 + block[0]);
Magic Number,Ionic.Zip,SharedUtilities,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\Shared.cs,_ReadFourBytes,The following statement contains a magic number: int data = unchecked((((block[3] * 256 + block[2]) * 256) + block[1]) * 256 + block[0]);
Magic Number,Ionic.Zip,SharedUtilities,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\Shared.cs,_ReadFourBytes,The following statement contains a magic number: int data = unchecked((((block[3] * 256 + block[2]) * 256) + block[1]) * 256 + block[0]);
Magic Number,Ionic.Zip,SharedUtilities,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\Shared.cs,_ReadFourBytes,The following statement contains a magic number: int data = unchecked((((block[3] * 256 + block[2]) * 256) + block[1]) * 256 + block[0]);
Magic Number,Ionic.Zip,SharedUtilities,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\Shared.cs,FindSignature,The following statement contains a magic number: int BATCH_SIZE = 65536;
Magic Number,Ionic.Zip,SharedUtilities,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\Shared.cs,FindSignature,The following statement contains a magic number: byte[] targetBytes = new byte[4];
Magic Number,Ionic.Zip,SharedUtilities,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\Shared.cs,FindSignature,The following statement contains a magic number: targetBytes[0] = (byte)(SignatureToFind >> 24);
Magic Number,Ionic.Zip,SharedUtilities,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\Shared.cs,FindSignature,The following statement contains a magic number: targetBytes[1] = (byte)((SignatureToFind & 0x00FF0000) >> 16);
Magic Number,Ionic.Zip,SharedUtilities,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\Shared.cs,FindSignature,The following statement contains a magic number: targetBytes[2] = (byte)((SignatureToFind & 0x0000FF00) >> 8);
Magic Number,Ionic.Zip,SharedUtilities,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\Shared.cs,FindSignature,The following statement contains a magic number: targetBytes[2] = (byte)((SignatureToFind & 0x0000FF00) >> 8);
Magic Number,Ionic.Zip,SharedUtilities,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\Shared.cs,FindSignature,The following statement contains a magic number: targetBytes[3] = (byte)(SignatureToFind & 0x000000FF);
Magic Number,Ionic.Zip,SharedUtilities,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\Shared.cs,FindSignature,The following statement contains a magic number: batch[i] == targetBytes[3]
Magic Number,Ionic.Zip,SharedUtilities,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\Shared.cs,FindSignature,The following statement contains a magic number: long bytesRead = (stream.Position - startingPosition) - 4;
Magic Number,Ionic.Zip,SharedUtilities,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\Shared.cs,PackedToDateTime,The following statement contains a magic number: return new System.DateTime(1995' 1' 1' 0' 0' 0' 0);
Magic Number,Ionic.Zip,SharedUtilities,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\Shared.cs,PackedToDateTime,The following statement contains a magic number: Int16 packedDate = unchecked((Int16)((packedDateTime & 0xffff0000) >> 16));
Magic Number,Ionic.Zip,SharedUtilities,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\Shared.cs,PackedToDateTime,The following statement contains a magic number: int year = 1980 + ((packedDate & 0xFE00) >> 9);
Magic Number,Ionic.Zip,SharedUtilities,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\Shared.cs,PackedToDateTime,The following statement contains a magic number: int year = 1980 + ((packedDate & 0xFE00) >> 9);
Magic Number,Ionic.Zip,SharedUtilities,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\Shared.cs,PackedToDateTime,The following statement contains a magic number: int month = (packedDate & 0x01E0) >> 5;
Magic Number,Ionic.Zip,SharedUtilities,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\Shared.cs,PackedToDateTime,The following statement contains a magic number: int hour = (packedTime & 0xF800) >> 11;
Magic Number,Ionic.Zip,SharedUtilities,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\Shared.cs,PackedToDateTime,The following statement contains a magic number: int minute = (packedTime & 0x07E0) >> 5;
Magic Number,Ionic.Zip,SharedUtilities,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\Shared.cs,PackedToDateTime,The following statement contains a magic number: int second = (packedTime & 0x001F) * 2;
Magic Number,Ionic.Zip,SharedUtilities,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\Shared.cs,PackedToDateTime,The following statement contains a magic number: second >= 60
Magic Number,Ionic.Zip,SharedUtilities,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\Shared.cs,PackedToDateTime,The following statement contains a magic number: minute >= 60
Magic Number,Ionic.Zip,SharedUtilities,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\Shared.cs,PackedToDateTime,The following statement contains a magic number: hour >= 24
Magic Number,Ionic.Zip,SharedUtilities,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\Shared.cs,DateTimeToPacked,The following statement contains a magic number: UInt16 packedDate = (UInt16)((time.Day & 0x0000001F) | ((time.Month << 5) & 0x000001E0) | (((time.Year - 1980) << 9) & 0x0000FE00));
Magic Number,Ionic.Zip,SharedUtilities,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\Shared.cs,DateTimeToPacked,The following statement contains a magic number: UInt16 packedDate = (UInt16)((time.Day & 0x0000001F) | ((time.Month << 5) & 0x000001E0) | (((time.Year - 1980) << 9) & 0x0000FE00));
Magic Number,Ionic.Zip,SharedUtilities,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\Shared.cs,DateTimeToPacked,The following statement contains a magic number: UInt16 packedDate = (UInt16)((time.Day & 0x0000001F) | ((time.Month << 5) & 0x000001E0) | (((time.Year - 1980) << 9) & 0x0000FE00));
Magic Number,Ionic.Zip,SharedUtilities,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\Shared.cs,DateTimeToPacked,The following statement contains a magic number: UInt16 packedTime = (UInt16)((time.Second / 2 & 0x0000001F) | ((time.Minute << 5) & 0x000007E0) | ((time.Hour << 11) & 0x0000F800));
Magic Number,Ionic.Zip,SharedUtilities,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\Shared.cs,DateTimeToPacked,The following statement contains a magic number: UInt16 packedTime = (UInt16)((time.Second / 2 & 0x0000001F) | ((time.Minute << 5) & 0x000007E0) | ((time.Hour << 11) & 0x0000F800));
Magic Number,Ionic.Zip,SharedUtilities,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\Shared.cs,DateTimeToPacked,The following statement contains a magic number: UInt16 packedTime = (UInt16)((time.Second / 2 & 0x0000001F) | ((time.Minute << 5) & 0x000007E0) | ((time.Hour << 11) & 0x0000F800));
Magic Number,Ionic.Zip,SharedUtilities,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\Shared.cs,DateTimeToPacked,The following statement contains a magic number: Int32 result = (Int32)(((UInt32)(packedDate << 16)) | packedTime);
Magic Number,Ionic.Zip,SharedUtilities,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\Shared.cs,CreateAndOpenUniqueTempFile,The following statement contains a magic number: i < 3
Magic Number,Ionic.Zip,SharedUtilities,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\Shared.cs,InternalGetTempFileName,The following statement contains a magic number: return "DotNetZip-" + Path.GetRandomFileName().Substring(0' 8) + ".tmp";
Magic Number,Ionic.Zip,ZipCrypto,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipCrypto.cs,ForRead,The following statement contains a magic number: e._WeakEncryptionHeader = new byte[12];
Magic Number,Ionic.Zip,ZipCrypto,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipCrypto.cs,ForRead,The following statement contains a magic number: DecryptedHeader[11] != (byte)((e._Crc32 >> 24) & 0xff)
Magic Number,Ionic.Zip,ZipCrypto,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipCrypto.cs,ForRead,The following statement contains a magic number: DecryptedHeader[11] != (byte)((e._Crc32 >> 24) & 0xff)
Magic Number,Ionic.Zip,ZipCrypto,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipCrypto.cs,UpdateKeys,The following statement contains a magic number: _Keys[2] = (UInt32)crc32.ComputeCrc32((int)_Keys[2]' (byte)(_Keys[1] >> 24));
Magic Number,Ionic.Zip,ZipCrypto,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipCrypto.cs,UpdateKeys,The following statement contains a magic number: _Keys[2] = (UInt32)crc32.ComputeCrc32((int)_Keys[2]' (byte)(_Keys[1] >> 24));
Magic Number,Ionic.Zip,ZipCrypto,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipCrypto.cs,UpdateKeys,The following statement contains a magic number: _Keys[2] = (UInt32)crc32.ComputeCrc32((int)_Keys[2]' (byte)(_Keys[1] >> 24));
Magic Number,Ionic.Zip,ZipEntry,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipDirEntry.cs,ReadDirEntry,The following statement contains a magic number: s.Seek(-4' System.IO.SeekOrigin.Current);
Magic Number,Ionic.Zip,ZipEntry,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipDirEntry.cs,ReadDirEntry,The following statement contains a magic number: int bytesRead = 42 + 4;
Magic Number,Ionic.Zip,ZipEntry,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipDirEntry.cs,ReadDirEntry,The following statement contains a magic number: int bytesRead = 42 + 4;
Magic Number,Ionic.Zip,ZipEntry,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipDirEntry.cs,ReadDirEntry,The following statement contains a magic number: byte[] block = new byte[42];
Magic Number,Ionic.Zip,ZipEntry,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipDirEntry.cs,ReadDirEntry,The following statement contains a magic number: zde._VersionMadeBy = (short)(block[i++] + block[i++] * 256);
Magic Number,Ionic.Zip,ZipEntry,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipDirEntry.cs,ReadDirEntry,The following statement contains a magic number: zde._VersionNeeded = (short)(block[i++] + block[i++] * 256);
Magic Number,Ionic.Zip,ZipEntry,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipDirEntry.cs,ReadDirEntry,The following statement contains a magic number: zde._BitField = (short)(block[i++] + block[i++] * 256);
Magic Number,Ionic.Zip,ZipEntry,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipDirEntry.cs,ReadDirEntry,The following statement contains a magic number: zde._CompressionMethod = (Int16)(block[i++] + block[i++] * 256);
Magic Number,Ionic.Zip,ZipEntry,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipDirEntry.cs,ReadDirEntry,The following statement contains a magic number: zde._TimeBlob = block[i++] + block[i++] * 256 + block[i++] * 256 * 256 + block[i++] * 256 * 256 * 256;
Magic Number,Ionic.Zip,ZipEntry,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipDirEntry.cs,ReadDirEntry,The following statement contains a magic number: zde._TimeBlob = block[i++] + block[i++] * 256 + block[i++] * 256 * 256 + block[i++] * 256 * 256 * 256;
Magic Number,Ionic.Zip,ZipEntry,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipDirEntry.cs,ReadDirEntry,The following statement contains a magic number: zde._TimeBlob = block[i++] + block[i++] * 256 + block[i++] * 256 * 256 + block[i++] * 256 * 256 * 256;
Magic Number,Ionic.Zip,ZipEntry,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipDirEntry.cs,ReadDirEntry,The following statement contains a magic number: zde._TimeBlob = block[i++] + block[i++] * 256 + block[i++] * 256 * 256 + block[i++] * 256 * 256 * 256;
Magic Number,Ionic.Zip,ZipEntry,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipDirEntry.cs,ReadDirEntry,The following statement contains a magic number: zde._TimeBlob = block[i++] + block[i++] * 256 + block[i++] * 256 * 256 + block[i++] * 256 * 256 * 256;
Magic Number,Ionic.Zip,ZipEntry,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipDirEntry.cs,ReadDirEntry,The following statement contains a magic number: zde._TimeBlob = block[i++] + block[i++] * 256 + block[i++] * 256 * 256 + block[i++] * 256 * 256 * 256;
Magic Number,Ionic.Zip,ZipEntry,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipDirEntry.cs,ReadDirEntry,The following statement contains a magic number: zde._Crc32 = block[i++] + block[i++] * 256 + block[i++] * 256 * 256 + block[i++] * 256 * 256 * 256;
Magic Number,Ionic.Zip,ZipEntry,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipDirEntry.cs,ReadDirEntry,The following statement contains a magic number: zde._Crc32 = block[i++] + block[i++] * 256 + block[i++] * 256 * 256 + block[i++] * 256 * 256 * 256;
Magic Number,Ionic.Zip,ZipEntry,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipDirEntry.cs,ReadDirEntry,The following statement contains a magic number: zde._Crc32 = block[i++] + block[i++] * 256 + block[i++] * 256 * 256 + block[i++] * 256 * 256 * 256;
Magic Number,Ionic.Zip,ZipEntry,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipDirEntry.cs,ReadDirEntry,The following statement contains a magic number: zde._Crc32 = block[i++] + block[i++] * 256 + block[i++] * 256 * 256 + block[i++] * 256 * 256 * 256;
Magic Number,Ionic.Zip,ZipEntry,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipDirEntry.cs,ReadDirEntry,The following statement contains a magic number: zde._Crc32 = block[i++] + block[i++] * 256 + block[i++] * 256 * 256 + block[i++] * 256 * 256 * 256;
Magic Number,Ionic.Zip,ZipEntry,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipDirEntry.cs,ReadDirEntry,The following statement contains a magic number: zde._Crc32 = block[i++] + block[i++] * 256 + block[i++] * 256 * 256 + block[i++] * 256 * 256 * 256;
Magic Number,Ionic.Zip,ZipEntry,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipDirEntry.cs,ReadDirEntry,The following statement contains a magic number: zde._CompressedSize = (uint)(block[i++] + block[i++] * 256 + block[i++] * 256 * 256 + block[i++] * 256 * 256 * 256);
Magic Number,Ionic.Zip,ZipEntry,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipDirEntry.cs,ReadDirEntry,The following statement contains a magic number: zde._CompressedSize = (uint)(block[i++] + block[i++] * 256 + block[i++] * 256 * 256 + block[i++] * 256 * 256 * 256);
Magic Number,Ionic.Zip,ZipEntry,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipDirEntry.cs,ReadDirEntry,The following statement contains a magic number: zde._CompressedSize = (uint)(block[i++] + block[i++] * 256 + block[i++] * 256 * 256 + block[i++] * 256 * 256 * 256);
Magic Number,Ionic.Zip,ZipEntry,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipDirEntry.cs,ReadDirEntry,The following statement contains a magic number: zde._CompressedSize = (uint)(block[i++] + block[i++] * 256 + block[i++] * 256 * 256 + block[i++] * 256 * 256 * 256);
Magic Number,Ionic.Zip,ZipEntry,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipDirEntry.cs,ReadDirEntry,The following statement contains a magic number: zde._CompressedSize = (uint)(block[i++] + block[i++] * 256 + block[i++] * 256 * 256 + block[i++] * 256 * 256 * 256);
Magic Number,Ionic.Zip,ZipEntry,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipDirEntry.cs,ReadDirEntry,The following statement contains a magic number: zde._CompressedSize = (uint)(block[i++] + block[i++] * 256 + block[i++] * 256 * 256 + block[i++] * 256 * 256 * 256);
Magic Number,Ionic.Zip,ZipEntry,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipDirEntry.cs,ReadDirEntry,The following statement contains a magic number: zde._UncompressedSize = (uint)(block[i++] + block[i++] * 256 + block[i++] * 256 * 256 + block[i++] * 256 * 256 * 256);
Magic Number,Ionic.Zip,ZipEntry,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipDirEntry.cs,ReadDirEntry,The following statement contains a magic number: zde._UncompressedSize = (uint)(block[i++] + block[i++] * 256 + block[i++] * 256 * 256 + block[i++] * 256 * 256 * 256);
Magic Number,Ionic.Zip,ZipEntry,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipDirEntry.cs,ReadDirEntry,The following statement contains a magic number: zde._UncompressedSize = (uint)(block[i++] + block[i++] * 256 + block[i++] * 256 * 256 + block[i++] * 256 * 256 * 256);
Magic Number,Ionic.Zip,ZipEntry,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipDirEntry.cs,ReadDirEntry,The following statement contains a magic number: zde._UncompressedSize = (uint)(block[i++] + block[i++] * 256 + block[i++] * 256 * 256 + block[i++] * 256 * 256 * 256);
Magic Number,Ionic.Zip,ZipEntry,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipDirEntry.cs,ReadDirEntry,The following statement contains a magic number: zde._UncompressedSize = (uint)(block[i++] + block[i++] * 256 + block[i++] * 256 * 256 + block[i++] * 256 * 256 * 256);
Magic Number,Ionic.Zip,ZipEntry,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipDirEntry.cs,ReadDirEntry,The following statement contains a magic number: zde._UncompressedSize = (uint)(block[i++] + block[i++] * 256 + block[i++] * 256 * 256 + block[i++] * 256 * 256 * 256);
Magic Number,Ionic.Zip,ZipEntry,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipDirEntry.cs,ReadDirEntry,The following statement contains a magic number: zde._filenameLength = (short)(block[i++] + block[i++] * 256);
Magic Number,Ionic.Zip,ZipEntry,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipDirEntry.cs,ReadDirEntry,The following statement contains a magic number: zde._extraFieldLength = (short)(block[i++] + block[i++] * 256);
Magic Number,Ionic.Zip,ZipEntry,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipDirEntry.cs,ReadDirEntry,The following statement contains a magic number: zde._commentLength = (short)(block[i++] + block[i++] * 256);
Magic Number,Ionic.Zip,ZipEntry,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipDirEntry.cs,ReadDirEntry,The following statement contains a magic number: zde._diskNumber = (UInt32)(block[i++] + block[i++] * 256);
Magic Number,Ionic.Zip,ZipEntry,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipDirEntry.cs,ReadDirEntry,The following statement contains a magic number: zde._InternalFileAttrs = (short)(block[i++] + block[i++] * 256);
Magic Number,Ionic.Zip,ZipEntry,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipDirEntry.cs,ReadDirEntry,The following statement contains a magic number: zde._ExternalFileAttrs = block[i++] + block[i++] * 256 + block[i++] * 256 * 256 + block[i++] * 256 * 256 * 256;
Magic Number,Ionic.Zip,ZipEntry,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipDirEntry.cs,ReadDirEntry,The following statement contains a magic number: zde._ExternalFileAttrs = block[i++] + block[i++] * 256 + block[i++] * 256 * 256 + block[i++] * 256 * 256 * 256;
Magic Number,Ionic.Zip,ZipEntry,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipDirEntry.cs,ReadDirEntry,The following statement contains a magic number: zde._ExternalFileAttrs = block[i++] + block[i++] * 256 + block[i++] * 256 * 256 + block[i++] * 256 * 256 * 256;
Magic Number,Ionic.Zip,ZipEntry,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipDirEntry.cs,ReadDirEntry,The following statement contains a magic number: zde._ExternalFileAttrs = block[i++] + block[i++] * 256 + block[i++] * 256 * 256 + block[i++] * 256 * 256 * 256;
Magic Number,Ionic.Zip,ZipEntry,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipDirEntry.cs,ReadDirEntry,The following statement contains a magic number: zde._ExternalFileAttrs = block[i++] + block[i++] * 256 + block[i++] * 256 * 256 + block[i++] * 256 * 256 * 256;
Magic Number,Ionic.Zip,ZipEntry,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipDirEntry.cs,ReadDirEntry,The following statement contains a magic number: zde._ExternalFileAttrs = block[i++] + block[i++] * 256 + block[i++] * 256 * 256 + block[i++] * 256 * 256 * 256;
Magic Number,Ionic.Zip,ZipEntry,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipDirEntry.cs,ReadDirEntry,The following statement contains a magic number: zde._RelativeOffsetOfLocalHeader = (uint)(block[i++] + block[i++] * 256 + block[i++] * 256 * 256 + block[i++] * 256 * 256 * 256);
Magic Number,Ionic.Zip,ZipEntry,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipDirEntry.cs,ReadDirEntry,The following statement contains a magic number: zde._RelativeOffsetOfLocalHeader = (uint)(block[i++] + block[i++] * 256 + block[i++] * 256 * 256 + block[i++] * 256 * 256 * 256);
Magic Number,Ionic.Zip,ZipEntry,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipDirEntry.cs,ReadDirEntry,The following statement contains a magic number: zde._RelativeOffsetOfLocalHeader = (uint)(block[i++] + block[i++] * 256 + block[i++] * 256 * 256 + block[i++] * 256 * 256 * 256);
Magic Number,Ionic.Zip,ZipEntry,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipDirEntry.cs,ReadDirEntry,The following statement contains a magic number: zde._RelativeOffsetOfLocalHeader = (uint)(block[i++] + block[i++] * 256 + block[i++] * 256 * 256 + block[i++] * 256 * 256 * 256);
Magic Number,Ionic.Zip,ZipEntry,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipDirEntry.cs,ReadDirEntry,The following statement contains a magic number: zde._RelativeOffsetOfLocalHeader = (uint)(block[i++] + block[i++] * 256 + block[i++] * 256 * 256 + block[i++] * 256 * 256 * 256);
Magic Number,Ionic.Zip,ZipEntry,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipDirEntry.cs,ReadDirEntry,The following statement contains a magic number: zde._RelativeOffsetOfLocalHeader = (uint)(block[i++] + block[i++] * 256 + block[i++] * 256 * 256 + block[i++] * 256 * 256 * 256);
Magic Number,Ionic.Zip,ZipEntry,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipDirEntry.cs,ReadDirEntry,The following statement contains a magic number: zde._CompressedFileDataSize -= 12;
Magic Number,Ionic.Zip,ZipEntry,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipDirEntry.cs,ReadDirEntry,The following statement contains a magic number: zde._LengthOfTrailer += 24;
Magic Number,Ionic.Zip,ZipEntry,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipDirEntry.cs,Create,The following statement contains a magic number: entry._VersionMadeBy = (0 << 8) + 45;
Magic Number,Ionic.Zip,ZipEntry,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipDirEntry.cs,Create,The following statement contains a magic number: entry._VersionMadeBy = (0 << 8) + 45;
Magic Number,Ionic.Zip,ZipEntry,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipDirEntry.cs,SetFdpLoh,The following statement contains a magic number: byte[] block = new byte[30];
Magic Number,Ionic.Zip,ZipEntry,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipDirEntry.cs,SetFdpLoh,The following statement contains a magic number: Int16 filenameLength = (short)(block[26] + block[27] * 256);
Magic Number,Ionic.Zip,ZipEntry,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipDirEntry.cs,SetFdpLoh,The following statement contains a magic number: Int16 filenameLength = (short)(block[26] + block[27] * 256);
Magic Number,Ionic.Zip,ZipEntry,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipDirEntry.cs,SetFdpLoh,The following statement contains a magic number: Int16 filenameLength = (short)(block[26] + block[27] * 256);
Magic Number,Ionic.Zip,ZipEntry,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipDirEntry.cs,SetFdpLoh,The following statement contains a magic number: Int16 extraFieldLength = (short)(block[28] + block[29] * 256);
Magic Number,Ionic.Zip,ZipEntry,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipDirEntry.cs,SetFdpLoh,The following statement contains a magic number: Int16 extraFieldLength = (short)(block[28] + block[29] * 256);
Magic Number,Ionic.Zip,ZipEntry,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipDirEntry.cs,SetFdpLoh,The following statement contains a magic number: Int16 extraFieldLength = (short)(block[28] + block[29] * 256);
Magic Number,Ionic.Zip,ZipEntry,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipDirEntry.cs,SetFdpLoh,The following statement contains a magic number: this._LengthOfHeader = 30 + extraFieldLength + filenameLength +                  GetLengthOfCryptoHeaderBytes(_Encryption_FromZipFile);
Magic Number,Ionic.Zip,ZipEntry,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipDirEntry.cs,GetLengthOfCryptoHeaderBytes,The following statement contains a magic number: return 12;
Magic Number,Ionic.Zip,ZipEntry,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipDirEntry.cs,InternalExtractToBaseDir,The following statement contains a magic number: rc == 2
Magic Number,Ionic.Zip,ZipEntry,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipDirEntry.cs,CheckExtractExistingFile,The following statement contains a magic number: switch (ExtractExistingFile)                  {                      case ExtractExistingFileAction.OverwriteSilently:                          WriteStatus("the file {0} exists; will overwrite it..."' targetFileName);                          return 0;                        case ExtractExistingFileAction.DoNotOverwrite:                          WriteStatus("the file {0} exists; not extracting entry..."' FileName);                          OnAfterExtract(baseDir);                          return 1;                        case ExtractExistingFileAction.InvokeExtractProgressEvent:                          if (loop>0)                              throw new ZipException(String.Format("The file {0} already exists."' targetFileName));                          OnExtractExisting(baseDir);                          if (_ioOperationCanceled)                              return 2;                            // loop around                          break;                        case ExtractExistingFileAction.Throw:                      default:                          throw new ZipException(String.Format("The file {0} already exists."' targetFileName));                  }
Magic Number,Ionic.Zip,ZipEntry,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipDirEntry.cs,GetUnsupportedCompressionMethod,The following statement contains a magic number: switch ((int) compressionMethod)              {                  case 0:                      meth = "Store";                      break;                  case 1:                      meth = "Shrink";                      break;                  case 8:                      meth = "DEFLATE";                      break;                  case 9:                      meth = "Deflate64";                      break;                  case 12:                      meth = "BZIP2"; // only if BZIP not compiled in                      break;                  case 14:                      meth = "LZMA";                      break;                  case 19:                      meth = "LZ77";                      break;                  case 98:                      meth = "PPMd";                      break;                  default:                      meth = String.Format("Unknown (0x{0:X4})"' compressionMethod);                      break;              }
Magic Number,Ionic.Zip,ZipEntry,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipDirEntry.cs,GetUnsupportedCompressionMethod,The following statement contains a magic number: switch ((int) compressionMethod)              {                  case 0:                      meth = "Store";                      break;                  case 1:                      meth = "Shrink";                      break;                  case 8:                      meth = "DEFLATE";                      break;                  case 9:                      meth = "Deflate64";                      break;                  case 12:                      meth = "BZIP2"; // only if BZIP not compiled in                      break;                  case 14:                      meth = "LZMA";                      break;                  case 19:                      meth = "LZ77";                      break;                  case 98:                      meth = "PPMd";                      break;                  default:                      meth = String.Format("Unknown (0x{0:X4})"' compressionMethod);                      break;              }
Magic Number,Ionic.Zip,ZipEntry,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipDirEntry.cs,GetUnsupportedCompressionMethod,The following statement contains a magic number: switch ((int) compressionMethod)              {                  case 0:                      meth = "Store";                      break;                  case 1:                      meth = "Shrink";                      break;                  case 8:                      meth = "DEFLATE";                      break;                  case 9:                      meth = "Deflate64";                      break;                  case 12:                      meth = "BZIP2"; // only if BZIP not compiled in                      break;                  case 14:                      meth = "LZMA";                      break;                  case 19:                      meth = "LZ77";                      break;                  case 98:                      meth = "PPMd";                      break;                  default:                      meth = String.Format("Unknown (0x{0:X4})"' compressionMethod);                      break;              }
Magic Number,Ionic.Zip,ZipEntry,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipDirEntry.cs,GetUnsupportedCompressionMethod,The following statement contains a magic number: switch ((int) compressionMethod)              {                  case 0:                      meth = "Store";                      break;                  case 1:                      meth = "Shrink";                      break;                  case 8:                      meth = "DEFLATE";                      break;                  case 9:                      meth = "Deflate64";                      break;                  case 12:                      meth = "BZIP2"; // only if BZIP not compiled in                      break;                  case 14:                      meth = "LZMA";                      break;                  case 19:                      meth = "LZ77";                      break;                  case 98:                      meth = "PPMd";                      break;                  default:                      meth = String.Format("Unknown (0x{0:X4})"' compressionMethod);                      break;              }
Magic Number,Ionic.Zip,ZipEntry,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipDirEntry.cs,GetUnsupportedCompressionMethod,The following statement contains a magic number: switch ((int) compressionMethod)              {                  case 0:                      meth = "Store";                      break;                  case 1:                      meth = "Shrink";                      break;                  case 8:                      meth = "DEFLATE";                      break;                  case 9:                      meth = "Deflate64";                      break;                  case 12:                      meth = "BZIP2"; // only if BZIP not compiled in                      break;                  case 14:                      meth = "LZMA";                      break;                  case 19:                      meth = "LZ77";                      break;                  case 98:                      meth = "PPMd";                      break;                  default:                      meth = String.Format("Unknown (0x{0:X4})"' compressionMethod);                      break;              }
Magic Number,Ionic.Zip,ZipEntry,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipDirEntry.cs,GetUnsupportedCompressionMethod,The following statement contains a magic number: switch ((int) compressionMethod)              {                  case 0:                      meth = "Store";                      break;                  case 1:                      meth = "Shrink";                      break;                  case 8:                      meth = "DEFLATE";                      break;                  case 9:                      meth = "Deflate64";                      break;                  case 12:                      meth = "BZIP2"; // only if BZIP not compiled in                      break;                  case 14:                      meth = "LZMA";                      break;                  case 19:                      meth = "LZ77";                      break;                  case 98:                      meth = "PPMd";                      break;                  default:                      meth = String.Format("Unknown (0x{0:X4})"' compressionMethod);                      break;              }
Magic Number,Ionic.Zip,ZipEntry,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipDirEntry.cs,SetupCryptoForExtract,The following statement contains a magic number: this.ArchiveStream.Seek(this.FileDataPosition - 12' SeekOrigin.Begin);
Magic Number,Ionic.Zip,ZipEntry,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipDirEntry.cs,IsDoneWithOutputToBaseDir,The following statement contains a magic number: f = f.Substring(2);
Magic Number,Ionic.Zip,ZipEntry,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipDirEntry.cs,ReadExtraField,The following statement contains a magic number: byte[] block = new byte[30];
Magic Number,Ionic.Zip,ZipEntry,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipDirEntry.cs,ReadExtraField,The following statement contains a magic number: int i = 26;
Magic Number,Ionic.Zip,ZipEntry,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipDirEntry.cs,ReadExtraField,The following statement contains a magic number: Int16 filenameLength = (short)(block[i++] + block[i++] * 256);
Magic Number,Ionic.Zip,ZipEntry,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipDirEntry.cs,ReadExtraField,The following statement contains a magic number: Int16 extraFieldLength = (short)(block[i++] + block[i++] * 256);
Magic Number,Ionic.Zip,ZipEntry,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipDirEntry.cs,ReadHeader,The following statement contains a magic number: bytesRead += 4;
Magic Number,Ionic.Zip,ZipEntry,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipDirEntry.cs,ReadHeader,The following statement contains a magic number: ze.ArchiveStream.Seek(-4' SeekOrigin.Current);
Magic Number,Ionic.Zip,ZipEntry,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipDirEntry.cs,ReadHeader,The following statement contains a magic number: byte[] block = new byte[26];
Magic Number,Ionic.Zip,ZipEntry,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipDirEntry.cs,ReadHeader,The following statement contains a magic number: ze._VersionNeeded = (Int16)(block[i++] + block[i++] * 256);
Magic Number,Ionic.Zip,ZipEntry,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipDirEntry.cs,ReadHeader,The following statement contains a magic number: ze._BitField = (Int16)(block[i++] + block[i++] * 256);
Magic Number,Ionic.Zip,ZipEntry,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipDirEntry.cs,ReadHeader,The following statement contains a magic number: ze._CompressionMethod_FromZipFile = ze._CompressionMethod = (Int16)(block[i++] + block[i++] * 256);
Magic Number,Ionic.Zip,ZipEntry,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipDirEntry.cs,ReadHeader,The following statement contains a magic number: ze._TimeBlob = block[i++] + block[i++] * 256 + block[i++] * 256 * 256 + block[i++] * 256 * 256 * 256;
Magic Number,Ionic.Zip,ZipEntry,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipDirEntry.cs,ReadHeader,The following statement contains a magic number: ze._TimeBlob = block[i++] + block[i++] * 256 + block[i++] * 256 * 256 + block[i++] * 256 * 256 * 256;
Magic Number,Ionic.Zip,ZipEntry,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipDirEntry.cs,ReadHeader,The following statement contains a magic number: ze._TimeBlob = block[i++] + block[i++] * 256 + block[i++] * 256 * 256 + block[i++] * 256 * 256 * 256;
Magic Number,Ionic.Zip,ZipEntry,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipDirEntry.cs,ReadHeader,The following statement contains a magic number: ze._TimeBlob = block[i++] + block[i++] * 256 + block[i++] * 256 * 256 + block[i++] * 256 * 256 * 256;
Magic Number,Ionic.Zip,ZipEntry,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipDirEntry.cs,ReadHeader,The following statement contains a magic number: ze._TimeBlob = block[i++] + block[i++] * 256 + block[i++] * 256 * 256 + block[i++] * 256 * 256 * 256;
Magic Number,Ionic.Zip,ZipEntry,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipDirEntry.cs,ReadHeader,The following statement contains a magic number: ze._TimeBlob = block[i++] + block[i++] * 256 + block[i++] * 256 * 256 + block[i++] * 256 * 256 * 256;
Magic Number,Ionic.Zip,ZipEntry,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipDirEntry.cs,ReadHeader,The following statement contains a magic number: ze._Crc32 = (Int32)(block[i++] + block[i++] * 256 + block[i++] * 256 * 256 + block[i++] * 256 * 256 * 256);
Magic Number,Ionic.Zip,ZipEntry,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipDirEntry.cs,ReadHeader,The following statement contains a magic number: ze._Crc32 = (Int32)(block[i++] + block[i++] * 256 + block[i++] * 256 * 256 + block[i++] * 256 * 256 * 256);
Magic Number,Ionic.Zip,ZipEntry,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipDirEntry.cs,ReadHeader,The following statement contains a magic number: ze._Crc32 = (Int32)(block[i++] + block[i++] * 256 + block[i++] * 256 * 256 + block[i++] * 256 * 256 * 256);
Magic Number,Ionic.Zip,ZipEntry,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipDirEntry.cs,ReadHeader,The following statement contains a magic number: ze._Crc32 = (Int32)(block[i++] + block[i++] * 256 + block[i++] * 256 * 256 + block[i++] * 256 * 256 * 256);
Magic Number,Ionic.Zip,ZipEntry,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipDirEntry.cs,ReadHeader,The following statement contains a magic number: ze._Crc32 = (Int32)(block[i++] + block[i++] * 256 + block[i++] * 256 * 256 + block[i++] * 256 * 256 * 256);
Magic Number,Ionic.Zip,ZipEntry,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipDirEntry.cs,ReadHeader,The following statement contains a magic number: ze._Crc32 = (Int32)(block[i++] + block[i++] * 256 + block[i++] * 256 * 256 + block[i++] * 256 * 256 * 256);
Magic Number,Ionic.Zip,ZipEntry,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipDirEntry.cs,ReadHeader,The following statement contains a magic number: ze._CompressedSize = (uint)(block[i++] + block[i++] * 256 + block[i++] * 256 * 256 + block[i++] * 256 * 256 * 256);
Magic Number,Ionic.Zip,ZipEntry,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipDirEntry.cs,ReadHeader,The following statement contains a magic number: ze._CompressedSize = (uint)(block[i++] + block[i++] * 256 + block[i++] * 256 * 256 + block[i++] * 256 * 256 * 256);
Magic Number,Ionic.Zip,ZipEntry,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipDirEntry.cs,ReadHeader,The following statement contains a magic number: ze._CompressedSize = (uint)(block[i++] + block[i++] * 256 + block[i++] * 256 * 256 + block[i++] * 256 * 256 * 256);
Magic Number,Ionic.Zip,ZipEntry,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipDirEntry.cs,ReadHeader,The following statement contains a magic number: ze._CompressedSize = (uint)(block[i++] + block[i++] * 256 + block[i++] * 256 * 256 + block[i++] * 256 * 256 * 256);
Magic Number,Ionic.Zip,ZipEntry,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipDirEntry.cs,ReadHeader,The following statement contains a magic number: ze._CompressedSize = (uint)(block[i++] + block[i++] * 256 + block[i++] * 256 * 256 + block[i++] * 256 * 256 * 256);
Magic Number,Ionic.Zip,ZipEntry,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipDirEntry.cs,ReadHeader,The following statement contains a magic number: ze._CompressedSize = (uint)(block[i++] + block[i++] * 256 + block[i++] * 256 * 256 + block[i++] * 256 * 256 * 256);
Magic Number,Ionic.Zip,ZipEntry,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipDirEntry.cs,ReadHeader,The following statement contains a magic number: ze._UncompressedSize = (uint)(block[i++] + block[i++] * 256 + block[i++] * 256 * 256 + block[i++] * 256 * 256 * 256);
Magic Number,Ionic.Zip,ZipEntry,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipDirEntry.cs,ReadHeader,The following statement contains a magic number: ze._UncompressedSize = (uint)(block[i++] + block[i++] * 256 + block[i++] * 256 * 256 + block[i++] * 256 * 256 * 256);
Magic Number,Ionic.Zip,ZipEntry,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipDirEntry.cs,ReadHeader,The following statement contains a magic number: ze._UncompressedSize = (uint)(block[i++] + block[i++] * 256 + block[i++] * 256 * 256 + block[i++] * 256 * 256 * 256);
Magic Number,Ionic.Zip,ZipEntry,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipDirEntry.cs,ReadHeader,The following statement contains a magic number: ze._UncompressedSize = (uint)(block[i++] + block[i++] * 256 + block[i++] * 256 * 256 + block[i++] * 256 * 256 * 256);
Magic Number,Ionic.Zip,ZipEntry,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipDirEntry.cs,ReadHeader,The following statement contains a magic number: ze._UncompressedSize = (uint)(block[i++] + block[i++] * 256 + block[i++] * 256 * 256 + block[i++] * 256 * 256 * 256);
Magic Number,Ionic.Zip,ZipEntry,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipDirEntry.cs,ReadHeader,The following statement contains a magic number: ze._UncompressedSize = (uint)(block[i++] + block[i++] * 256 + block[i++] * 256 * 256 + block[i++] * 256 * 256 * 256);
Magic Number,Ionic.Zip,ZipEntry,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipDirEntry.cs,ReadHeader,The following statement contains a magic number: Int16 filenameLength = (short)(block[i++] + block[i++] * 256);
Magic Number,Ionic.Zip,ZipEntry,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipDirEntry.cs,ReadHeader,The following statement contains a magic number: Int16 extraFieldLength = (short)(block[i++] + block[i++] * 256);
Magic Number,Ionic.Zip,ZipEntry,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipDirEntry.cs,ReadHeader,The following statement contains a magic number: block = new byte[20];
Magic Number,Ionic.Zip,ZipEntry,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipDirEntry.cs,ReadHeader,The following statement contains a magic number: n != 20
Magic Number,Ionic.Zip,ZipEntry,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipDirEntry.cs,ReadHeader,The following statement contains a magic number: ze._Crc32 = (Int32)(block[i++] + block[i++] * 256 + block[i++] * 256 * 256 + block[i++] * 256 * 256 * 256);
Magic Number,Ionic.Zip,ZipEntry,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipDirEntry.cs,ReadHeader,The following statement contains a magic number: ze._Crc32 = (Int32)(block[i++] + block[i++] * 256 + block[i++] * 256 * 256 + block[i++] * 256 * 256 * 256);
Magic Number,Ionic.Zip,ZipEntry,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipDirEntry.cs,ReadHeader,The following statement contains a magic number: ze._Crc32 = (Int32)(block[i++] + block[i++] * 256 + block[i++] * 256 * 256 + block[i++] * 256 * 256 * 256);
Magic Number,Ionic.Zip,ZipEntry,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipDirEntry.cs,ReadHeader,The following statement contains a magic number: ze._Crc32 = (Int32)(block[i++] + block[i++] * 256 + block[i++] * 256 * 256 + block[i++] * 256 * 256 * 256);
Magic Number,Ionic.Zip,ZipEntry,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipDirEntry.cs,ReadHeader,The following statement contains a magic number: ze._Crc32 = (Int32)(block[i++] + block[i++] * 256 + block[i++] * 256 * 256 + block[i++] * 256 * 256 * 256);
Magic Number,Ionic.Zip,ZipEntry,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipDirEntry.cs,ReadHeader,The following statement contains a magic number: ze._Crc32 = (Int32)(block[i++] + block[i++] * 256 + block[i++] * 256 * 256 + block[i++] * 256 * 256 * 256);
Magic Number,Ionic.Zip,ZipEntry,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipDirEntry.cs,ReadHeader,The following statement contains a magic number: i += 8;
Magic Number,Ionic.Zip,ZipEntry,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipDirEntry.cs,ReadHeader,The following statement contains a magic number: i += 8;
Magic Number,Ionic.Zip,ZipEntry,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipDirEntry.cs,ReadHeader,The following statement contains a magic number: ze.ArchiveStream.Seek(-12' SeekOrigin.Current);
Magic Number,Ionic.Zip,ZipEntry,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipDirEntry.cs,ReadHeader,The following statement contains a magic number: SizeOfDataRead += 4;
Magic Number,Ionic.Zip,ZipEntry,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipDirEntry.cs,ReadHeader,The following statement contains a magic number: ze._LengthOfTrailer += ze._InputUsesZip64 ? 24 : 16;
Magic Number,Ionic.Zip,ZipEntry,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipDirEntry.cs,ReadHeader,The following statement contains a magic number: ze._LengthOfTrailer += ze._InputUsesZip64 ? 24 : 16;
Magic Number,Ionic.Zip,ZipEntry,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipDirEntry.cs,ReadHeader,The following statement contains a magic number: ze._WeakEncryptionHeader = new byte[12];
Magic Number,Ionic.Zip,ZipEntry,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipDirEntry.cs,ReadHeader,The following statement contains a magic number: ze._CompressedFileDataSize -= 12;
Magic Number,Ionic.Zip,ZipEntry,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipDirEntry.cs,ReadWeakEncryptionHeader,The following statement contains a magic number: int additionalBytesRead = s.Read(buffer' 0' 12);
Magic Number,Ionic.Zip,ZipEntry,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipDirEntry.cs,ReadWeakEncryptionHeader,The following statement contains a magic number: additionalBytesRead != 12
Magic Number,Ionic.Zip,ZipEntry,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipDirEntry.cs,HandlePK00Prefix,The following statement contains a magic number: s.Seek(-4' SeekOrigin.Current);
Magic Number,Ionic.Zip,ZipEntry,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipDirEntry.cs,FindExtraFieldSegment,The following statement contains a magic number: UInt16 headerId = (UInt16)(extra[j++] + extra[j++] * 256);
Magic Number,Ionic.Zip,ZipEntry,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipDirEntry.cs,FindExtraFieldSegment,The following statement contains a magic number: return j-2;
Magic Number,Ionic.Zip,ZipEntry,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipDirEntry.cs,FindExtraFieldSegment,The following statement contains a magic number: Int16 dataSize = (short)(extra[j++] + extra[j++] * 256);
Magic Number,Ionic.Zip,ZipEntry,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipDirEntry.cs,FindExtraFieldSegment,The following statement contains a magic number: j + 3 < extra.Length
Magic Number,Ionic.Zip,ZipEntry,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipDirEntry.cs,ProcessExtraField,The following statement contains a magic number: UInt16 headerId = (UInt16)(buffer[j++] + buffer[j++] * 256);
Magic Number,Ionic.Zip,ZipEntry,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipDirEntry.cs,ProcessExtraField,The following statement contains a magic number: UInt16 dataSize = (UInt16)(buffer[j++] + buffer[j++] * 256);
Magic Number,Ionic.Zip,ZipEntry,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipDirEntry.cs,ProcessExtraField,The following statement contains a magic number: j = start + dataSize + 4;
Magic Number,Ionic.Zip,ZipEntry,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipDirEntry.cs,ProcessExtraField,The following statement contains a magic number: j + 3 < buffer.Length
Magic Number,Ionic.Zip,ZipEntry,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipDirEntry.cs,ProcessExtraFieldPkwareStrongEncryption,The following statement contains a magic number: j += 2;
Magic Number,Ionic.Zip,ZipEntry,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipDirEntry.cs,ProcessExtraFieldPkwareStrongEncryption,The following statement contains a magic number: _UnsupportedAlgorithmId = (UInt16)(Buffer[j++] + Buffer[j++] * 256);
Magic Number,Ionic.Zip,ZipEntry,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipDirEntry.cs,ProcessExtraFieldZip64,The following statement contains a magic number: dataSize > 28
Magic Number,Ionic.Zip,ZipEntry,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipDirEntry.cs,ProcessExtraFieldZip64,The following statement contains a magic number: var slurp = new Func<Int64>( () => {                      if (remainingData < 8)                          throw new BadReadException(String.Format("  Missing data for ZIP64 extra field' position 0x{0:X16}"' posn));                      var x = BitConverter.ToInt64(buffer' j);                      j+= 8;                      remainingData -= 8;                      return x;                  });
Magic Number,Ionic.Zip,ZipEntry,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipDirEntry.cs,ProcessExtraFieldZip64,The following statement contains a magic number: var slurp = new Func<Int64>( () => {                      if (remainingData < 8)                          throw new BadReadException(String.Format("  Missing data for ZIP64 extra field' position 0x{0:X16}"' posn));                      var x = BitConverter.ToInt64(buffer' j);                      j+= 8;                      remainingData -= 8;                      return x;                  });
Magic Number,Ionic.Zip,ZipEntry,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipDirEntry.cs,ProcessExtraFieldZip64,The following statement contains a magic number: var slurp = new Func<Int64>( () => {                      if (remainingData < 8)                          throw new BadReadException(String.Format("  Missing data for ZIP64 extra field' position 0x{0:X16}"' posn));                      var x = BitConverter.ToInt64(buffer' j);                      j+= 8;                      remainingData -= 8;                      return x;                  });
Magic Number,Ionic.Zip,ZipEntry,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipDirEntry.cs,ProcessExtraFieldInfoZipTimes,The following statement contains a magic number: dataSize != 12 && dataSize != 8
Magic Number,Ionic.Zip,ZipEntry,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipDirEntry.cs,ProcessExtraFieldInfoZipTimes,The following statement contains a magic number: dataSize != 12 && dataSize != 8
Magic Number,Ionic.Zip,ZipEntry,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipDirEntry.cs,ProcessExtraFieldInfoZipTimes,The following statement contains a magic number: j += 4;
Magic Number,Ionic.Zip,ZipEntry,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipDirEntry.cs,ProcessExtraFieldInfoZipTimes,The following statement contains a magic number: j += 4;
Magic Number,Ionic.Zip,ZipEntry,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipDirEntry.cs,ProcessExtraFieldUnixTimes,The following statement contains a magic number: dataSize != 13 && dataSize != 9 && dataSize != 5
Magic Number,Ionic.Zip,ZipEntry,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipDirEntry.cs,ProcessExtraFieldUnixTimes,The following statement contains a magic number: dataSize != 13 && dataSize != 9 && dataSize != 5
Magic Number,Ionic.Zip,ZipEntry,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipDirEntry.cs,ProcessExtraFieldUnixTimes,The following statement contains a magic number: dataSize != 13 && dataSize != 9 && dataSize != 5
Magic Number,Ionic.Zip,ZipEntry,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipDirEntry.cs,ProcessExtraFieldUnixTimes,The following statement contains a magic number: var slurp = new Func<DateTime>( () => {                      Int32 timet = BitConverter.ToInt32(buffer' j);                      j += 4;                      remainingData -= 4;                      return _unixEpoch.AddSeconds(timet);                  });
Magic Number,Ionic.Zip,ZipEntry,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipDirEntry.cs,ProcessExtraFieldUnixTimes,The following statement contains a magic number: var slurp = new Func<DateTime>( () => {                      Int32 timet = BitConverter.ToInt32(buffer' j);                      j += 4;                      remainingData -= 4;                      return _unixEpoch.AddSeconds(timet);                  });
Magic Number,Ionic.Zip,ZipEntry,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipDirEntry.cs,ProcessExtraFieldUnixTimes,The following statement contains a magic number: (flag & 0x0001) != 0 && remainingData >= 4
Magic Number,Ionic.Zip,ZipEntry,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipDirEntry.cs,ProcessExtraFieldUnixTimes,The following statement contains a magic number: this._Atime = ((flag & 0x0002) != 0 && remainingData >= 4)                       ? slurp()                       : DateTime.UtcNow;
Magic Number,Ionic.Zip,ZipEntry,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipDirEntry.cs,ProcessExtraFieldUnixTimes,The following statement contains a magic number: this._Ctime =  ((flag & 0x0004) != 0 && remainingData >= 4)                       ? slurp()                       :DateTime.UtcNow;
Magic Number,Ionic.Zip,ZipEntry,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipDirEntry.cs,ProcessExtraFieldUnixTimes,The following statement contains a magic number: dataSize == 13 || _readExtraDepth > 0
Magic Number,Ionic.Zip,ZipEntry,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipDirEntry.cs,ProcessExtraFieldWindowsTimes,The following statement contains a magic number: dataSize != 32
Magic Number,Ionic.Zip,ZipEntry,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipDirEntry.cs,ProcessExtraFieldWindowsTimes,The following statement contains a magic number: j += 4;
Magic Number,Ionic.Zip,ZipEntry,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipDirEntry.cs,ProcessExtraFieldWindowsTimes,The following statement contains a magic number: Int16 timetag = (Int16)(buffer[j] + buffer[j + 1] * 256);
Magic Number,Ionic.Zip,ZipEntry,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipDirEntry.cs,ProcessExtraFieldWindowsTimes,The following statement contains a magic number: Int16 addlsize = (Int16)(buffer[j + 2] + buffer[j + 3] * 256);
Magic Number,Ionic.Zip,ZipEntry,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipDirEntry.cs,ProcessExtraFieldWindowsTimes,The following statement contains a magic number: Int16 addlsize = (Int16)(buffer[j + 2] + buffer[j + 3] * 256);
Magic Number,Ionic.Zip,ZipEntry,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipDirEntry.cs,ProcessExtraFieldWindowsTimes,The following statement contains a magic number: Int16 addlsize = (Int16)(buffer[j + 2] + buffer[j + 3] * 256);
Magic Number,Ionic.Zip,ZipEntry,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipDirEntry.cs,ProcessExtraFieldWindowsTimes,The following statement contains a magic number: j += 4;
Magic Number,Ionic.Zip,ZipEntry,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipDirEntry.cs,ProcessExtraFieldWindowsTimes,The following statement contains a magic number: j += 8;
Magic Number,Ionic.Zip,ZipEntry,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipDirEntry.cs,ProcessExtraFieldWindowsTimes,The following statement contains a magic number: j += 8;
Magic Number,Ionic.Zip,ZipEntry,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipDirEntry.cs,ProcessExtraFieldWindowsTimes,The following statement contains a magic number: j += 8;
Magic Number,Ionic.Zip,ZipEntry,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipDirEntry.cs,ProcessExtraFieldWindowsTimes,The following statement contains a magic number: timetag == 0x0001 && addlsize == 24
Magic Number,Ionic.Zip,ZipEntry,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipDirEntry.cs,WriteCentralDirectoryEntry,The following statement contains a magic number: byte[] bytes = new byte[8192];
Magic Number,Ionic.Zip,ZipEntry,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipDirEntry.cs,WriteCentralDirectoryEntry,The following statement contains a magic number: bytes[i++] = (byte)((ZipConstants.ZipDirEntrySignature & 0x0000FF00) >> 8);
Magic Number,Ionic.Zip,ZipEntry,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipDirEntry.cs,WriteCentralDirectoryEntry,The following statement contains a magic number: bytes[i++] = (byte)((ZipConstants.ZipDirEntrySignature & 0x00FF0000) >> 16);
Magic Number,Ionic.Zip,ZipEntry,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipDirEntry.cs,WriteCentralDirectoryEntry,The following statement contains a magic number: bytes[i++] = (byte)((ZipConstants.ZipDirEntrySignature & 0xFF000000) >> 24);
Magic Number,Ionic.Zip,ZipEntry,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipDirEntry.cs,WriteCentralDirectoryEntry,The following statement contains a magic number: bytes[i++] = (byte)((_VersionMadeBy & 0xFF00) >> 8);
Magic Number,Ionic.Zip,ZipEntry,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipDirEntry.cs,WriteCentralDirectoryEntry,The following statement contains a magic number: Int16 vNeeded = (Int16)(VersionNeeded != 0 ? VersionNeeded : 20);
Magic Number,Ionic.Zip,ZipEntry,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipDirEntry.cs,WriteCentralDirectoryEntry,The following statement contains a magic number: Int16 versionNeededToExtract = (Int16)(_OutputUsesZip64.Value ? 45 : vNeeded);
Magic Number,Ionic.Zip,ZipEntry,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipDirEntry.cs,WriteCentralDirectoryEntry,The following statement contains a magic number: bytes[i++] = (byte)((versionNeededToExtract & 0xFF00) >> 8);
Magic Number,Ionic.Zip,ZipEntry,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipDirEntry.cs,WriteCentralDirectoryEntry,The following statement contains a magic number: bytes[i++] = (byte)((_BitField & 0xFF00) >> 8);
Magic Number,Ionic.Zip,ZipEntry,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipDirEntry.cs,WriteCentralDirectoryEntry,The following statement contains a magic number: bytes[i++] = (byte)((_CompressionMethod & 0xFF00) >> 8);
Magic Number,Ionic.Zip,ZipEntry,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipDirEntry.cs,WriteCentralDirectoryEntry,The following statement contains a magic number: bytes[i++] = (byte)((_TimeBlob & 0x0000FF00) >> 8);
Magic Number,Ionic.Zip,ZipEntry,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipDirEntry.cs,WriteCentralDirectoryEntry,The following statement contains a magic number: bytes[i++] = (byte)((_TimeBlob & 0x00FF0000) >> 16);
Magic Number,Ionic.Zip,ZipEntry,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipDirEntry.cs,WriteCentralDirectoryEntry,The following statement contains a magic number: bytes[i++] = (byte)((_TimeBlob & 0xFF000000) >> 24);
Magic Number,Ionic.Zip,ZipEntry,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipDirEntry.cs,WriteCentralDirectoryEntry,The following statement contains a magic number: bytes[i++] = (byte)((_Crc32 & 0x0000FF00) >> 8);
Magic Number,Ionic.Zip,ZipEntry,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipDirEntry.cs,WriteCentralDirectoryEntry,The following statement contains a magic number: bytes[i++] = (byte)((_Crc32 & 0x00FF0000) >> 16);
Magic Number,Ionic.Zip,ZipEntry,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipDirEntry.cs,WriteCentralDirectoryEntry,The following statement contains a magic number: bytes[i++] = (byte)((_Crc32 & 0xFF000000) >> 24);
Magic Number,Ionic.Zip,ZipEntry,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipDirEntry.cs,WriteCentralDirectoryEntry,The following statement contains a magic number: j < 8
Magic Number,Ionic.Zip,ZipEntry,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipDirEntry.cs,WriteCentralDirectoryEntry,The following statement contains a magic number: bytes[i++] = (byte)((filenameLength & 0xFF00) >> 8);
Magic Number,Ionic.Zip,ZipEntry,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipDirEntry.cs,WriteCentralDirectoryEntry,The following statement contains a magic number: bytes[i++] = (byte)((extraFieldLength & 0xFF00) >> 8);
Magic Number,Ionic.Zip,ZipEntry,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipDirEntry.cs,WriteCentralDirectoryEntry,The following statement contains a magic number: i += 2;
Magic Number,Ionic.Zip,ZipEntry,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipDirEntry.cs,WriteCentralDirectoryEntry,The following statement contains a magic number: bytes[i++] = (byte)((_diskNumber & 0xFF00) >> 8);
Magic Number,Ionic.Zip,ZipEntry,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipDirEntry.cs,WriteCentralDirectoryEntry,The following statement contains a magic number: bytes[i++] = (byte)((_ExternalFileAttrs & 0x0000FF00) >> 8);
Magic Number,Ionic.Zip,ZipEntry,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipDirEntry.cs,WriteCentralDirectoryEntry,The following statement contains a magic number: bytes[i++] = (byte)((_ExternalFileAttrs & 0x00FF0000) >> 16);
Magic Number,Ionic.Zip,ZipEntry,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipDirEntry.cs,WriteCentralDirectoryEntry,The following statement contains a magic number: bytes[i++] = (byte)((_ExternalFileAttrs & 0xFF000000) >> 24);
Magic Number,Ionic.Zip,ZipEntry,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipDirEntry.cs,WriteCentralDirectoryEntry,The following statement contains a magic number: bytes[32] = (byte)(commentLength & 0x00FF);
Magic Number,Ionic.Zip,ZipEntry,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipDirEntry.cs,WriteCentralDirectoryEntry,The following statement contains a magic number: bytes[33] = (byte)((commentLength & 0xFF00) >> 8);
Magic Number,Ionic.Zip,ZipEntry,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipDirEntry.cs,WriteCentralDirectoryEntry,The following statement contains a magic number: bytes[33] = (byte)((commentLength & 0xFF00) >> 8);
Magic Number,Ionic.Zip,ZipEntry,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipDirEntry.cs,ConstructExtraField,The following statement contains a magic number: int sz = 4 + (forCentralDirectory ? 28 : 16);
Magic Number,Ionic.Zip,ZipEntry,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipDirEntry.cs,ConstructExtraField,The following statement contains a magic number: int sz = 4 + (forCentralDirectory ? 28 : 16);
Magic Number,Ionic.Zip,ZipEntry,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipDirEntry.cs,ConstructExtraField,The following statement contains a magic number: int sz = 4 + (forCentralDirectory ? 28 : 16);
Magic Number,Ionic.Zip,ZipEntry,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipDirEntry.cs,ConstructExtraField,The following statement contains a magic number: block[i++] = (byte)(sz - 4);
Magic Number,Ionic.Zip,ZipEntry,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipDirEntry.cs,ConstructExtraField,The following statement contains a magic number: Array.Copy(BitConverter.GetBytes(_UncompressedSize)' 0' block' i' 8);
Magic Number,Ionic.Zip,ZipEntry,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipDirEntry.cs,ConstructExtraField,The following statement contains a magic number: i += 8;
Magic Number,Ionic.Zip,ZipEntry,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipDirEntry.cs,ConstructExtraField,The following statement contains a magic number: Array.Copy(BitConverter.GetBytes(_CompressedSize)' 0' block' i' 8);
Magic Number,Ionic.Zip,ZipEntry,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipDirEntry.cs,ConstructExtraField,The following statement contains a magic number: i += 8;
Magic Number,Ionic.Zip,ZipEntry,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipDirEntry.cs,ConstructExtraField,The following statement contains a magic number: Array.Copy(BitConverter.GetBytes(_RelativeOffsetOfLocalHeader)' 0' block' i' 8);
Magic Number,Ionic.Zip,ZipEntry,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipDirEntry.cs,ConstructExtraField,The following statement contains a magic number: i += 8;
Magic Number,Ionic.Zip,ZipEntry,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipDirEntry.cs,ConstructExtraField,The following statement contains a magic number: Array.Copy(BitConverter.GetBytes(0)' 0' block' i' 4);
Magic Number,Ionic.Zip,ZipEntry,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipDirEntry.cs,ConstructExtraField,The following statement contains a magic number: block = new byte[32 + 4];
Magic Number,Ionic.Zip,ZipEntry,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipDirEntry.cs,ConstructExtraField,The following statement contains a magic number: block = new byte[32 + 4];
Magic Number,Ionic.Zip,ZipEntry,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipDirEntry.cs,ConstructExtraField,The following statement contains a magic number: block[i++] = 32;
Magic Number,Ionic.Zip,ZipEntry,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipDirEntry.cs,ConstructExtraField,The following statement contains a magic number: i += 4;
Magic Number,Ionic.Zip,ZipEntry,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipDirEntry.cs,ConstructExtraField,The following statement contains a magic number: block[i++] = 24;
Magic Number,Ionic.Zip,ZipEntry,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipDirEntry.cs,ConstructExtraField,The following statement contains a magic number: Array.Copy(BitConverter.GetBytes(z)' 0' block' i' 8);
Magic Number,Ionic.Zip,ZipEntry,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipDirEntry.cs,ConstructExtraField,The following statement contains a magic number: i += 8;
Magic Number,Ionic.Zip,ZipEntry,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipDirEntry.cs,ConstructExtraField,The following statement contains a magic number: Array.Copy(BitConverter.GetBytes(z)' 0' block' i' 8);
Magic Number,Ionic.Zip,ZipEntry,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipDirEntry.cs,ConstructExtraField,The following statement contains a magic number: i += 8;
Magic Number,Ionic.Zip,ZipEntry,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipDirEntry.cs,ConstructExtraField,The following statement contains a magic number: Array.Copy(BitConverter.GetBytes(z)' 0' block' i' 8);
Magic Number,Ionic.Zip,ZipEntry,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipDirEntry.cs,ConstructExtraField,The following statement contains a magic number: i += 8;
Magic Number,Ionic.Zip,ZipEntry,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipDirEntry.cs,ConstructExtraField,The following statement contains a magic number: int len = 5 + 4;
Magic Number,Ionic.Zip,ZipEntry,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipDirEntry.cs,ConstructExtraField,The following statement contains a magic number: int len = 5 + 4;
Magic Number,Ionic.Zip,ZipEntry,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipDirEntry.cs,ConstructExtraField,The following statement contains a magic number: len += 8;
Magic Number,Ionic.Zip,ZipEntry,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipDirEntry.cs,ConstructExtraField,The following statement contains a magic number: block[i++] = unchecked((byte)(len - 4));
Magic Number,Ionic.Zip,ZipEntry,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipDirEntry.cs,ConstructExtraField,The following statement contains a magic number: Array.Copy(BitConverter.GetBytes(z)' 0' block' i' 4);
Magic Number,Ionic.Zip,ZipEntry,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipDirEntry.cs,ConstructExtraField,The following statement contains a magic number: i += 4;
Magic Number,Ionic.Zip,ZipEntry,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipDirEntry.cs,ConstructExtraField,The following statement contains a magic number: Array.Copy(BitConverter.GetBytes(z)' 0' block' i' 4);
Magic Number,Ionic.Zip,ZipEntry,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipDirEntry.cs,ConstructExtraField,The following statement contains a magic number: i += 4;
Magic Number,Ionic.Zip,ZipEntry,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipDirEntry.cs,ConstructExtraField,The following statement contains a magic number: Array.Copy(BitConverter.GetBytes(z)' 0' block' i' 4);
Magic Number,Ionic.Zip,ZipEntry,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipDirEntry.cs,ConstructExtraField,The following statement contains a magic number: i += 4;
Magic Number,Ionic.Zip,ZipEntry,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipDirEntry.cs,NormalizeFileName,The following statement contains a magic number: s1 = SlashFixed.Substring(3);
Magic Number,Ionic.Zip,ZipEntry,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipDirEntry.cs,NormalizeFileName,The following statement contains a magic number: (_TrimVolumeFromFullyQualifiedPaths) && (FileName.Length >= 3)                  && (FileName[1] == ':') && (SlashFixed[2] == '/')
Magic Number,Ionic.Zip,ZipEntry,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipDirEntry.cs,NormalizeFileName,The following statement contains a magic number: (_TrimVolumeFromFullyQualifiedPaths) && (FileName.Length >= 3)                  && (FileName[1] == ':') && (SlashFixed[2] == '/')
Magic Number,Ionic.Zip,ZipEntry,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipDirEntry.cs,WantReadAgain,The following statement contains a magic number: _zipCrypto_forWrite != null && (CompressedSize - 12) <= UncompressedSize
Magic Number,Ionic.Zip,ZipEntry,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipDirEntry.cs,WriteHeader,The following statement contains a magic number: byte[] block = new byte[30];
Magic Number,Ionic.Zip,ZipEntry,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipDirEntry.cs,WriteHeader,The following statement contains a magic number: block[i++] = (byte)((ZipConstants.ZipEntrySignature & 0x0000FF00) >> 8);
Magic Number,Ionic.Zip,ZipEntry,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipDirEntry.cs,WriteHeader,The following statement contains a magic number: block[i++] = (byte)((ZipConstants.ZipEntrySignature & 0x00FF0000) >> 16);
Magic Number,Ionic.Zip,ZipEntry,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipDirEntry.cs,WriteHeader,The following statement contains a magic number: block[i++] = (byte)((ZipConstants.ZipEntrySignature & 0xFF000000) >> 24);
Magic Number,Ionic.Zip,ZipEntry,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipDirEntry.cs,WriteHeader,The following statement contains a magic number: Int16 VersionNeededToExtract = (Int16)(_presumeZip64 ? 45 : 20);
Magic Number,Ionic.Zip,ZipEntry,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipDirEntry.cs,WriteHeader,The following statement contains a magic number: Int16 VersionNeededToExtract = (Int16)(_presumeZip64 ? 45 : 20);
Magic Number,Ionic.Zip,ZipEntry,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipDirEntry.cs,WriteHeader,The following statement contains a magic number: block[i++] = (byte)((VersionNeededToExtract & 0xFF00) >> 8);
Magic Number,Ionic.Zip,ZipEntry,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipDirEntry.cs,WriteHeader,The following statement contains a magic number: IsDirectory || cycle == 99
Magic Number,Ionic.Zip,ZipEntry,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipDirEntry.cs,WriteHeader,The following statement contains a magic number: block[i++] = (byte)((_BitField & 0xFF00) >> 8);
Magic Number,Ionic.Zip,ZipEntry,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipDirEntry.cs,WriteHeader,The following statement contains a magic number: block[i++] = (byte)((_CompressionMethod & 0xFF00) >> 8);
Magic Number,Ionic.Zip,ZipEntry,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipDirEntry.cs,WriteHeader,The following statement contains a magic number: cycle == 99
Magic Number,Ionic.Zip,ZipEntry,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipDirEntry.cs,WriteHeader,The following statement contains a magic number: block[i++] = (byte)((_TimeBlob & 0x0000FF00) >> 8);
Magic Number,Ionic.Zip,ZipEntry,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipDirEntry.cs,WriteHeader,The following statement contains a magic number: block[i++] = (byte)((_TimeBlob & 0x00FF0000) >> 16);
Magic Number,Ionic.Zip,ZipEntry,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipDirEntry.cs,WriteHeader,The following statement contains a magic number: block[i++] = (byte)((_TimeBlob & 0xFF000000) >> 24);
Magic Number,Ionic.Zip,ZipEntry,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipDirEntry.cs,WriteHeader,The following statement contains a magic number: block[i++] = (byte)((_Crc32 & 0x0000FF00) >> 8);
Magic Number,Ionic.Zip,ZipEntry,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipDirEntry.cs,WriteHeader,The following statement contains a magic number: block[i++] = (byte)((_Crc32 & 0x00FF0000) >> 16);
Magic Number,Ionic.Zip,ZipEntry,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipDirEntry.cs,WriteHeader,The following statement contains a magic number: block[i++] = (byte)((_Crc32 & 0xFF000000) >> 24);
Magic Number,Ionic.Zip,ZipEntry,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipDirEntry.cs,WriteHeader,The following statement contains a magic number: j < 8
Magic Number,Ionic.Zip,ZipEntry,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipDirEntry.cs,WriteHeader,The following statement contains a magic number: block[i++] = (byte)((filenameLength & 0xFF00) >> 8);
Magic Number,Ionic.Zip,ZipEntry,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipDirEntry.cs,WriteHeader,The following statement contains a magic number: block[i++] = (byte)((extraFieldLength & 0xFF00) >> 8);
Magic Number,Ionic.Zip,ZipEntry,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipDirEntry.cs,PostProcessOutput,The following statement contains a magic number: headerBytesToRetract = 12;
Magic Number,Ionic.Zip,ZipEntry,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipDirEntry.cs,PostProcessOutput,The following statement contains a magic number: int j = 6;
Magic Number,Ionic.Zip,ZipEntry,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipDirEntry.cs,PostProcessOutput,The following statement contains a magic number: _EntryHeader[j++] = (byte)((_BitField & 0xFF00) >> 8);
Magic Number,Ionic.Zip,ZipEntry,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipDirEntry.cs,PostProcessOutput,The following statement contains a magic number: int i = 8;
Magic Number,Ionic.Zip,ZipEntry,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipDirEntry.cs,PostProcessOutput,The following statement contains a magic number: _EntryHeader[i++] = (byte)((_CompressionMethod & 0xFF00) >> 8);
Magic Number,Ionic.Zip,ZipEntry,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipDirEntry.cs,PostProcessOutput,The following statement contains a magic number: i = 14;
Magic Number,Ionic.Zip,ZipEntry,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipDirEntry.cs,PostProcessOutput,The following statement contains a magic number: _EntryHeader[i++] = (byte)((_Crc32 & 0x0000FF00) >> 8);
Magic Number,Ionic.Zip,ZipEntry,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipDirEntry.cs,PostProcessOutput,The following statement contains a magic number: _EntryHeader[i++] = (byte)((_Crc32 & 0x00FF0000) >> 16);
Magic Number,Ionic.Zip,ZipEntry,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipDirEntry.cs,PostProcessOutput,The following statement contains a magic number: _EntryHeader[i++] = (byte)((_Crc32 & 0xFF000000) >> 24);
Magic Number,Ionic.Zip,ZipEntry,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipDirEntry.cs,PostProcessOutput,The following statement contains a magic number: Int16 filenameLength = (short)(_EntryHeader[26] + _EntryHeader[27] * 256);
Magic Number,Ionic.Zip,ZipEntry,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipDirEntry.cs,PostProcessOutput,The following statement contains a magic number: Int16 filenameLength = (short)(_EntryHeader[26] + _EntryHeader[27] * 256);
Magic Number,Ionic.Zip,ZipEntry,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipDirEntry.cs,PostProcessOutput,The following statement contains a magic number: Int16 filenameLength = (short)(_EntryHeader[26] + _EntryHeader[27] * 256);
Magic Number,Ionic.Zip,ZipEntry,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipDirEntry.cs,PostProcessOutput,The following statement contains a magic number: Int16 extraFieldLength = (short)(_EntryHeader[28] + _EntryHeader[29] * 256);
Magic Number,Ionic.Zip,ZipEntry,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipDirEntry.cs,PostProcessOutput,The following statement contains a magic number: Int16 extraFieldLength = (short)(_EntryHeader[28] + _EntryHeader[29] * 256);
Magic Number,Ionic.Zip,ZipEntry,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipDirEntry.cs,PostProcessOutput,The following statement contains a magic number: Int16 extraFieldLength = (short)(_EntryHeader[28] + _EntryHeader[29] * 256);
Magic Number,Ionic.Zip,ZipEntry,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipDirEntry.cs,PostProcessOutput,The following statement contains a magic number: _EntryHeader[4] = (byte)(45 & 0x00FF);
Magic Number,Ionic.Zip,ZipEntry,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipDirEntry.cs,PostProcessOutput,The following statement contains a magic number: _EntryHeader[4] = (byte)(45 & 0x00FF);
Magic Number,Ionic.Zip,ZipEntry,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipDirEntry.cs,PostProcessOutput,The following statement contains a magic number: _EntryHeader[5] = 0x00;
Magic Number,Ionic.Zip,ZipEntry,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipDirEntry.cs,PostProcessOutput,The following statement contains a magic number: j < 8
Magic Number,Ionic.Zip,ZipEntry,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipDirEntry.cs,PostProcessOutput,The following statement contains a magic number: i = 30 + filenameLength;
Magic Number,Ionic.Zip,ZipEntry,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipDirEntry.cs,PostProcessOutput,The following statement contains a magic number: i += 2;
Magic Number,Ionic.Zip,ZipEntry,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipDirEntry.cs,PostProcessOutput,The following statement contains a magic number: Array.Copy(BitConverter.GetBytes(_UncompressedSize)' 0' _EntryHeader' i' 8);
Magic Number,Ionic.Zip,ZipEntry,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipDirEntry.cs,PostProcessOutput,The following statement contains a magic number: i += 8;
Magic Number,Ionic.Zip,ZipEntry,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipDirEntry.cs,PostProcessOutput,The following statement contains a magic number: Array.Copy(BitConverter.GetBytes(_CompressedSize)' 0' _EntryHeader' i' 8);
Magic Number,Ionic.Zip,ZipEntry,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipDirEntry.cs,PostProcessOutput,The following statement contains a magic number: byte[] Descriptor = new byte[16 + (_OutputUsesZip64.Value ? 8 : 0)];
Magic Number,Ionic.Zip,ZipEntry,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipDirEntry.cs,PostProcessOutput,The following statement contains a magic number: byte[] Descriptor = new byte[16 + (_OutputUsesZip64.Value ? 8 : 0)];
Magic Number,Ionic.Zip,ZipEntry,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipDirEntry.cs,PostProcessOutput,The following statement contains a magic number: Array.Copy(BitConverter.GetBytes(ZipConstants.ZipEntryDataDescriptorSignature)' 0' Descriptor' i' 4);
Magic Number,Ionic.Zip,ZipEntry,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipDirEntry.cs,PostProcessOutput,The following statement contains a magic number: i += 4;
Magic Number,Ionic.Zip,ZipEntry,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipDirEntry.cs,PostProcessOutput,The following statement contains a magic number: Array.Copy(BitConverter.GetBytes(_Crc32)' 0' Descriptor' i' 4);
Magic Number,Ionic.Zip,ZipEntry,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipDirEntry.cs,PostProcessOutput,The following statement contains a magic number: i += 4;
Magic Number,Ionic.Zip,ZipEntry,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipDirEntry.cs,PostProcessOutput,The following statement contains a magic number: Array.Copy(BitConverter.GetBytes(_CompressedSize)' 0' Descriptor' i' 8);
Magic Number,Ionic.Zip,ZipEntry,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipDirEntry.cs,PostProcessOutput,The following statement contains a magic number: i += 8;
Magic Number,Ionic.Zip,ZipEntry,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipDirEntry.cs,PostProcessOutput,The following statement contains a magic number: Array.Copy(BitConverter.GetBytes(_UncompressedSize)' 0' Descriptor' i' 8);
Magic Number,Ionic.Zip,ZipEntry,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipDirEntry.cs,PostProcessOutput,The following statement contains a magic number: i += 8;
Magic Number,Ionic.Zip,ZipEntry,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipDirEntry.cs,WriteSecurityMetadata,The following statement contains a magic number: byte[] encryptionHeader = new byte[12];
Magic Number,Ionic.Zip,ZipEntry,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipDirEntry.cs,WriteSecurityMetadata,The following statement contains a magic number: encryptionHeader[11] = (byte)((this._TimeBlob >> 8) & 0xff);
Magic Number,Ionic.Zip,ZipEntry,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipDirEntry.cs,WriteSecurityMetadata,The following statement contains a magic number: encryptionHeader[11] = (byte)((this._TimeBlob >> 8) & 0xff);
Magic Number,Ionic.Zip,ZipEntry,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipDirEntry.cs,CopyThroughWithRecompute,The following statement contains a magic number: int size = 16;
Magic Number,Ionic.Zip,ZipEntry,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipDirEntry.cs,CopyThroughWithRecompute,The following statement contains a magic number: size += 8;
Magic Number,Ionic.Zip,ZipEntry,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipDirEntry.cs,CopyThroughWithRecompute,The following statement contains a magic number: outstream.Write(Descriptor' 0' 8);
Magic Number,Ionic.Zip,ZipEntry,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipDirEntry.cs,CopyThroughWithRecompute,The following statement contains a magic number: outstream.Write(Descriptor' 8' 4);
Magic Number,Ionic.Zip,ZipEntry,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipDirEntry.cs,CopyThroughWithRecompute,The following statement contains a magic number: outstream.Write(Descriptor' 8' 4);
Magic Number,Ionic.Zip,ZipEntry,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipDirEntry.cs,CopyThroughWithRecompute,The following statement contains a magic number: outstream.Write(Descriptor' 16' 4);
Magic Number,Ionic.Zip,ZipEntry,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipDirEntry.cs,CopyThroughWithRecompute,The following statement contains a magic number: outstream.Write(Descriptor' 16' 4);
Magic Number,Ionic.Zip,ZipEntry,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipDirEntry.cs,CopyThroughWithRecompute,The following statement contains a magic number: _LengthOfTrailer -= 8;
Magic Number,Ionic.Zip,CopyHelper,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipDirEntry.cs,AppendCopyToFileName,The following statement contains a magic number: callCount > 25
Magic Number,Ionic.Zip,ZipFile,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipFile.AddUpdate.cs,_InitInstance,The following statement contains a magic number: ParallelDeflateThreshold = 512 * 1024;
Magic Number,Ionic.Zip,ZipFile,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipFile.AddUpdate.cs,_InitInstance,The following statement contains a magic number: ParallelDeflateThreshold = 512 * 1024;
Magic Number,Ionic.Zip,ZipFile,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipFile.AddUpdate.cs,_InternalExtractAll,The following statement contains a magic number: StatusMessageTextWriter.WriteLine(new System.String('-'' 72));
Magic Number,Ionic.Zip,ZipFile,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipFile.AddUpdate.cs,ReadIntoInstance,The following statement contains a magic number: long posn = s.Length - 64;
Magic Number,Ionic.Zip,ZipFile,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipFile.AddUpdate.cs,ReadIntoInstance,The following statement contains a magic number: long maxSeekback = Math.Max(s.Length - 0x4000' 10);
Magic Number,Ionic.Zip,ZipFile,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipFile.AddUpdate.cs,ReadIntoInstance,The following statement contains a magic number: zf._locEndOfCDS = s.Position - 4;
Magic Number,Ionic.Zip,ZipFile,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipFile.AddUpdate.cs,ReadIntoInstance,The following statement contains a magic number: byte[] block = new byte[16];
Magic Number,Ionic.Zip,ZipFile,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipFile.AddUpdate.cs,ReadIntoInstance,The following statement contains a magic number: zf._diskNumberWithCd = BitConverter.ToUInt16(block' 2);
Magic Number,Ionic.Zip,ZipFile,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipFile.AddUpdate.cs,ReadIntoInstance,The following statement contains a magic number: int i = 12;
Magic Number,Ionic.Zip,ZipFile,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipFile.AddUpdate.cs,Zip64SeekToCentralDirectory,The following statement contains a magic number: byte[] block = new byte[16];
Magic Number,Ionic.Zip,ZipFile,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipFile.AddUpdate.cs,Zip64SeekToCentralDirectory,The following statement contains a magic number: s.Seek(-40' SeekOrigin.Current);
Magic Number,Ionic.Zip,ZipFile,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipFile.AddUpdate.cs,Zip64SeekToCentralDirectory,The following statement contains a magic number: s.Read(block' 0' 16);
Magic Number,Ionic.Zip,ZipFile,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipFile.AddUpdate.cs,Zip64SeekToCentralDirectory,The following statement contains a magic number: Int64 offset64 = BitConverter.ToInt64(block' 8);
Magic Number,Ionic.Zip,ZipFile,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipFile.AddUpdate.cs,Zip64SeekToCentralDirectory,The following statement contains a magic number: s.Read(block' 0' 8);
Magic Number,Ionic.Zip,ZipFile,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipFile.AddUpdate.cs,Zip64SeekToCentralDirectory,The following statement contains a magic number: offset64 = BitConverter.ToInt64(block' 36);
Magic Number,Ionic.Zip,ZipFile,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipFile.AddUpdate.cs,ReadCentralDirectoryFooter,The following statement contains a magic number: block = new byte[8 + 44];
Magic Number,Ionic.Zip,ZipFile,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipFile.AddUpdate.cs,ReadCentralDirectoryFooter,The following statement contains a magic number: block = new byte[8 + 44];
Magic Number,Ionic.Zip,ZipFile,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipFile.AddUpdate.cs,ReadCentralDirectoryFooter,The following statement contains a magic number: DataSize < 44
Magic Number,Ionic.Zip,ZipFile,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipFile.AddUpdate.cs,ReadCentralDirectoryFooter,The following statement contains a magic number: j += 2;
Magic Number,Ionic.Zip,ZipFile,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipFile.AddUpdate.cs,ReadCentralDirectoryFooter,The following statement contains a magic number: j += 2;
Magic Number,Ionic.Zip,ZipFile,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipFile.AddUpdate.cs,ReadCentralDirectoryFooter,The following statement contains a magic number: j += 2;
Magic Number,Ionic.Zip,ZipFile,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipFile.AddUpdate.cs,ReadCentralDirectoryFooter,The following statement contains a magic number: block = new byte[DataSize - 44];
Magic Number,Ionic.Zip,ZipFile,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipFile.AddUpdate.cs,ReadCentralDirectoryFooter,The following statement contains a magic number: block = new byte[16];
Magic Number,Ionic.Zip,ZipFile,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipFile.AddUpdate.cs,ReadCentralDirectoryFooter,The following statement contains a magic number: s.Seek(-4' SeekOrigin.Current);
Magic Number,Ionic.Zip,ZipFile,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipFile.AddUpdate.cs,ReadCentralDirectoryFooter,The following statement contains a magic number: block = new byte[16];
Magic Number,Ionic.Zip,ZipFile,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipFile.AddUpdate.cs,ReadCentralDirectoryFooter,The following statement contains a magic number: zf._diskNumberWithCd = BitConverter.ToUInt16(block' 2);
Magic Number,Ionic.Zip,ZipFile,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipFile.AddUpdate.cs,ReadZipFileComment,The following statement contains a magic number: byte[] block = new byte[2];
Magic Number,Ionic.Zip,ZipFile,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipFile.AddUpdate.cs,ReadZipFileComment,The following statement contains a magic number: Int16 commentLength = (short)(block[0] + block[1] * 256);
Magic Number,Ionic.Zip,ZipFile,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipFile.AddUpdate.cs,DeleteFileWithRetry,The following statement contains a magic number: int nRetries = 3;
Magic Number,Ionic.Zip,ZipFile,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipFile.AddUpdate.cs,ZipFile,The following statement contains a magic number: ibm437 = System.Text.Encoding.GetEncoding(1252);
Magic Number,Ionic.Zip,ZipOutput,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipFile.Save.cs,WriteCentralDirectoryStructure,The following statement contains a magic number: int i = 16;
Magic Number,Ionic.Zip,ZipOutput,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipFile.Save.cs,WriteCentralDirectoryStructure,The following statement contains a magic number: Array.Copy(BitConverter.GetBytes(thisSegment)' 0' a' i' 4);
Magic Number,Ionic.Zip,ZipOutput,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipFile.Save.cs,WriteCentralDirectoryStructure,The following statement contains a magic number: i += 4;
Magic Number,Ionic.Zip,ZipOutput,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipFile.Save.cs,WriteCentralDirectoryStructure,The following statement contains a magic number: Array.Copy(BitConverter.GetBytes(thisSegment)' 0' a' i' 4);
Magic Number,Ionic.Zip,ZipOutput,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipFile.Save.cs,WriteCentralDirectoryStructure,The following statement contains a magic number: i = 60;
Magic Number,Ionic.Zip,ZipOutput,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipFile.Save.cs,WriteCentralDirectoryStructure,The following statement contains a magic number: Array.Copy(BitConverter.GetBytes(thisSegment)' 0' a' i' 4);
Magic Number,Ionic.Zip,ZipOutput,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipFile.Save.cs,WriteCentralDirectoryStructure,The following statement contains a magic number: i += 4;
Magic Number,Ionic.Zip,ZipOutput,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipFile.Save.cs,WriteCentralDirectoryStructure,The following statement contains a magic number: i += 8;
Magic Number,Ionic.Zip,ZipOutput,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipFile.Save.cs,WriteCentralDirectoryStructure,The following statement contains a magic number: Array.Copy(BitConverter.GetBytes(thisSegment)' 0' a' i' 4);
Magic Number,Ionic.Zip,ZipOutput,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipFile.Save.cs,WriteCentralDirectoryStructure,The following statement contains a magic number: int i = 4;
Magic Number,Ionic.Zip,ZipOutput,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipFile.Save.cs,WriteCentralDirectoryStructure,The following statement contains a magic number: Array.Copy(BitConverter.GetBytes(thisSegment)' 0' a2' i' 2);
Magic Number,Ionic.Zip,ZipOutput,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipFile.Save.cs,WriteCentralDirectoryStructure,The following statement contains a magic number: i += 2;
Magic Number,Ionic.Zip,ZipOutput,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipFile.Save.cs,WriteCentralDirectoryStructure,The following statement contains a magic number: Array.Copy(BitConverter.GetBytes(thisSegment)' 0' a2' i' 2);
Magic Number,Ionic.Zip,ZipOutput,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipFile.Save.cs,WriteCentralDirectoryStructure,The following statement contains a magic number: i += 2;
Magic Number,Ionic.Zip,ZipOutput,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipFile.Save.cs,GenCentralDirectoryFooter,The following statement contains a magic number: int bufferLength = 22;
Magic Number,Ionic.Zip,ZipOutput,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipFile.Save.cs,GenCentralDirectoryFooter,The following statement contains a magic number: Array.Copy(sig' 0' bytes' i' 4);
Magic Number,Ionic.Zip,ZipOutput,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipFile.Save.cs,GenCentralDirectoryFooter,The following statement contains a magic number: i+=4;
Magic Number,Ionic.Zip,ZipOutput,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipFile.Save.cs,GenCentralDirectoryFooter,The following statement contains a magic number: j < 4
Magic Number,Ionic.Zip,ZipOutput,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipFile.Save.cs,GenCentralDirectoryFooter,The following statement contains a magic number: j < 8
Magic Number,Ionic.Zip,ZipOutput,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipFile.Save.cs,GenZip64EndOfCentralDirectory,The following statement contains a magic number: const int bufferLength = 12 + 44 + 20;
Magic Number,Ionic.Zip,ZipOutput,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipFile.Save.cs,GenZip64EndOfCentralDirectory,The following statement contains a magic number: const int bufferLength = 12 + 44 + 20;
Magic Number,Ionic.Zip,ZipOutput,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipFile.Save.cs,GenZip64EndOfCentralDirectory,The following statement contains a magic number: const int bufferLength = 12 + 44 + 20;
Magic Number,Ionic.Zip,ZipOutput,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipFile.Save.cs,GenZip64EndOfCentralDirectory,The following statement contains a magic number: Array.Copy(sig' 0' bytes' i' 4);
Magic Number,Ionic.Zip,ZipOutput,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipFile.Save.cs,GenZip64EndOfCentralDirectory,The following statement contains a magic number: i+=4;
Magic Number,Ionic.Zip,ZipOutput,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipFile.Save.cs,GenZip64EndOfCentralDirectory,The following statement contains a magic number: long DataSize = 44;
Magic Number,Ionic.Zip,ZipOutput,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipFile.Save.cs,GenZip64EndOfCentralDirectory,The following statement contains a magic number: Array.Copy(BitConverter.GetBytes(DataSize)' 0' bytes' i' 8);
Magic Number,Ionic.Zip,ZipOutput,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipFile.Save.cs,GenZip64EndOfCentralDirectory,The following statement contains a magic number: i += 8;
Magic Number,Ionic.Zip,ZipOutput,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipFile.Save.cs,GenZip64EndOfCentralDirectory,The following statement contains a magic number: bytes[i++] = 45;
Magic Number,Ionic.Zip,ZipOutput,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipFile.Save.cs,GenZip64EndOfCentralDirectory,The following statement contains a magic number: bytes[i++] = 45;
Magic Number,Ionic.Zip,ZipOutput,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipFile.Save.cs,GenZip64EndOfCentralDirectory,The following statement contains a magic number: j < 8
Magic Number,Ionic.Zip,ZipOutput,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipFile.Save.cs,GenZip64EndOfCentralDirectory,The following statement contains a magic number: Array.Copy(BitConverter.GetBytes(numberOfEntries)' 0' bytes' i' 8);
Magic Number,Ionic.Zip,ZipOutput,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipFile.Save.cs,GenZip64EndOfCentralDirectory,The following statement contains a magic number: i += 8;
Magic Number,Ionic.Zip,ZipOutput,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipFile.Save.cs,GenZip64EndOfCentralDirectory,The following statement contains a magic number: Array.Copy(BitConverter.GetBytes(numberOfEntries)' 0' bytes' i' 8);
Magic Number,Ionic.Zip,ZipOutput,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipFile.Save.cs,GenZip64EndOfCentralDirectory,The following statement contains a magic number: i += 8;
Magic Number,Ionic.Zip,ZipOutput,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipFile.Save.cs,GenZip64EndOfCentralDirectory,The following statement contains a magic number: Array.Copy(BitConverter.GetBytes(SizeofCentraldirectory)' 0' bytes' i' 8);
Magic Number,Ionic.Zip,ZipOutput,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipFile.Save.cs,GenZip64EndOfCentralDirectory,The following statement contains a magic number: i += 8;
Magic Number,Ionic.Zip,ZipOutput,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipFile.Save.cs,GenZip64EndOfCentralDirectory,The following statement contains a magic number: Array.Copy(BitConverter.GetBytes(StartOfCentralDirectory)' 0' bytes' i' 8);
Magic Number,Ionic.Zip,ZipOutput,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipFile.Save.cs,GenZip64EndOfCentralDirectory,The following statement contains a magic number: i += 8;
Magic Number,Ionic.Zip,ZipOutput,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipFile.Save.cs,GenZip64EndOfCentralDirectory,The following statement contains a magic number: Array.Copy(sig' 0' bytes' i' 4);
Magic Number,Ionic.Zip,ZipOutput,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipFile.Save.cs,GenZip64EndOfCentralDirectory,The following statement contains a magic number: i+=4;
Magic Number,Ionic.Zip,ZipOutput,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipFile.Save.cs,GenZip64EndOfCentralDirectory,The following statement contains a magic number: Array.Copy(BitConverter.GetBytes(x2)' 0' bytes' i' 4);
Magic Number,Ionic.Zip,ZipOutput,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipFile.Save.cs,GenZip64EndOfCentralDirectory,The following statement contains a magic number: i+=4;
Magic Number,Ionic.Zip,ZipOutput,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipFile.Save.cs,GenZip64EndOfCentralDirectory,The following statement contains a magic number: Array.Copy(BitConverter.GetBytes(EndOfCentralDirectory)' 0' bytes' i' 8);
Magic Number,Ionic.Zip,ZipOutput,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipFile.Save.cs,GenZip64EndOfCentralDirectory,The following statement contains a magic number: i += 8;
Magic Number,Ionic.Zip,ZipOutput,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipFile.Save.cs,GenZip64EndOfCentralDirectory,The following statement contains a magic number: Array.Copy(BitConverter.GetBytes(numSegments)' 0' bytes' i' 4);
Magic Number,Ionic.Zip,ZipOutput,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipFile.Save.cs,GenZip64EndOfCentralDirectory,The following statement contains a magic number: i+=4;
Magic Number,Ionic.Zip,ZipInputStream,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipInputStream.cs,GetNextEntry,The following statement contains a magic number: _inputStream.Seek(-4' SeekOrigin.Current);
Magic Number,Ionic.Zip,ZipOutputStream,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipOutputStream.cs,_InitiateCurrentEntry,The following statement contains a magic number: _entryCount > 65534 && _zip64 == Zip64Option.Never
Magic Number,Ionic.Zip,ZipOutputStream,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipOutputStream.cs,_InitiateCurrentEntry,The following statement contains a magic number: _currentEntry.WriteHeader(_outputStream' finishing ? 99 : 0);
Magic Number,Ionic.Zip,ZipSegmentedStream,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipSegmentedStream.cs,_SetWriteStream,The following statement contains a magic number: _innerStream.Write(BitConverter.GetBytes(ZipConstants.SplitArchiveSignature)' 0' 4);
Magic Number,Ionic.Zip,ZipSegmentedStream,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipSegmentedStream.cs,TruncateBackward,The following statement contains a magic number: i < 3
Magic Number,Ionic,FileSelector,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\FileSelector.cs,_ParseCriterion,The following statement contains a magic number: tokens.Length < 3
Magic Number,Ionic,FileSelector,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\FileSelector.cs,_ParseCriterion,The following statement contains a magic number: switch (tok1)                  {                      case "and":                      case "xor":                      case "or":                          state = stateStack.Peek();                          if (state != ParseState.CriterionDone)                              throw new ArgumentException(String.Join(" "' tokens' i' tokens.Length - i));                            if (tokens.Length <= i + 3)                              throw new ArgumentException(String.Join(" "' tokens' i' tokens.Length - i));                            pendingConjunction = (LogicalConjunction)Enum.Parse(typeof(LogicalConjunction)' tokens[i].ToUpper()' true);                          current = new CompoundCriterion { Left = current' Right = null' Conjunction = pendingConjunction };                          stateStack.Push(state);                          stateStack.Push(ParseState.ConjunctionPending);                          critStack.Push(current);                          break;                        case "(":                          state = stateStack.Peek();                          if (state != ParseState.Start && state != ParseState.ConjunctionPending && state != ParseState.OpenParen)                              throw new ArgumentException(String.Join(" "' tokens' i' tokens.Length - i));                            if (tokens.Length <= i + 4)                              throw new ArgumentException(String.Join(" "' tokens' i' tokens.Length - i));                            stateStack.Push(ParseState.OpenParen);                          break;                        case ")":                          state = stateStack.Pop();                          if (stateStack.Peek() != ParseState.OpenParen)                              throw new ArgumentException(String.Join(" "' tokens' i' tokens.Length - i));                            stateStack.Pop();                          stateStack.Push(ParseState.CriterionDone);                          break;                        case "atime":                      case "ctime":                      case "mtime":                          if (tokens.Length <= i + 2)                              throw new ArgumentException(String.Join(" "' tokens' i' tokens.Length - i));                            DateTime t;                          try                          {                              t = DateTime.ParseExact(tokens[i + 2]' "yyyy-MM-dd-HH:mm:ss"' null);                          }                          catch (FormatException)                          {                              try                              {                                  t = DateTime.ParseExact(tokens[i + 2]' "yyyy/MM/dd-HH:mm:ss"' null);                              }                              catch (FormatException)                              {                                  try                                  {                                      t = DateTime.ParseExact(tokens[i + 2]' "yyyy/MM/dd"' null);                                  }                                  catch (FormatException)                                  {                                      try                                      {                                          t = DateTime.ParseExact(tokens[i + 2]' "MM/dd/yyyy"' null);                                      }                                      catch (FormatException)                                      {                                          t = DateTime.ParseExact(tokens[i + 2]' "yyyy-MM-dd"' null);                                      }                                  }                              }                          }                          t= DateTime.SpecifyKind(t' DateTimeKind.Local).ToUniversalTime();                          current = new TimeCriterion                          {                              Which = (WhichTime)Enum.Parse(typeof(WhichTime)' tokens[i]' true)'                              Operator = (ComparisonOperator)EnumUtil.Parse(typeof(ComparisonOperator)' tokens[i + 1])'                              Time = t                          };                          i += 2;                          stateStack.Push(ParseState.CriterionDone);                          break;                          case "length":                      case "size":                          if (tokens.Length <= i + 2)                              throw new ArgumentException(String.Join(" "' tokens' i' tokens.Length - i));                            Int64 sz = 0;                          string v = tokens[i + 2];                          if (v.ToUpper().EndsWith("K"))                              sz = Int64.Parse(v.Substring(0' v.Length - 1)) * 1024;                          else if (v.ToUpper().EndsWith("KB"))                              sz = Int64.Parse(v.Substring(0' v.Length - 2)) * 1024;                          else if (v.ToUpper().EndsWith("M"))                              sz = Int64.Parse(v.Substring(0' v.Length - 1)) * 1024 * 1024;                          else if (v.ToUpper().EndsWith("MB"))                              sz = Int64.Parse(v.Substring(0' v.Length - 2)) * 1024 * 1024;                          else if (v.ToUpper().EndsWith("G"))                              sz = Int64.Parse(v.Substring(0' v.Length - 1)) * 1024 * 1024 * 1024;                          else if (v.ToUpper().EndsWith("GB"))                              sz = Int64.Parse(v.Substring(0' v.Length - 2)) * 1024 * 1024 * 1024;                          else sz = Int64.Parse(tokens[i + 2]);                            current = new SizeCriterion                          {                              Size = sz'                              Operator = (ComparisonOperator)EnumUtil.Parse(typeof(ComparisonOperator)' tokens[i + 1])                          };                          i += 2;                          stateStack.Push(ParseState.CriterionDone);                          break;                        case "filename":                      case "name":                          {                              if (tokens.Length <= i + 2)                                  throw new ArgumentException(String.Join(" "' tokens' i' tokens.Length - i));                                ComparisonOperator c =                                  (ComparisonOperator)EnumUtil.Parse(typeof(ComparisonOperator)' tokens[i + 1]);                                if (c != ComparisonOperator.NotEqualTo && c != ComparisonOperator.EqualTo)                                  throw new ArgumentException(String.Join(" "' tokens' i' tokens.Length - i));                                string m = tokens[i + 2];                                // handle single-quoted filespecs (used to include                              // spaces in filename patterns)                              if (m.StartsWith("'") && m.EndsWith("'"))                              {                                  // trim off leading and trailing single quotes and                                  // revert the control characters to spaces.                                  m = m.Substring(1' m.Length - 2)                                      .Replace("\u0006"' " ");                              }                                // if (m.StartsWith("'"))                              //     m = m.Replace("\u0006"' " ");                                //Fix for Unix -> NormalizeCriteriaExpression replaces all slashes with backslashes                              if (Path.DirectorySeparatorChar == '/')                                  m = m.Replace('\\'' Path.DirectorySeparatorChar);                                current = new NameCriterion                              {                                  MatchingFileSpec = m'                                  Operator = c                              };                              i += 2;                              stateStack.Push(ParseState.CriterionDone);                          }                          break;                        case "attrs":                      case "attributes":                      case "type":                          {                              if (tokens.Length <= i + 2)                                  throw new ArgumentException(String.Join(" "' tokens' i' tokens.Length - i));                                ComparisonOperator c =                                  (ComparisonOperator)EnumUtil.Parse(typeof(ComparisonOperator)' tokens[i + 1]);                                if (c != ComparisonOperator.NotEqualTo && c != ComparisonOperator.EqualTo)                                  throw new ArgumentException(String.Join(" "' tokens' i' tokens.Length - i));                                current = (tok1 == "type")                                  ? (SelectionCriterion) new TypeCriterion                                      {                                          AttributeString = tokens[i + 2]'                                          Operator = c                                      }                                  : (SelectionCriterion) new AttributesCriterion                                      {                                          AttributeString = tokens[i + 2]'                                          Operator = c                                      };                              i += 2;                              stateStack.Push(ParseState.CriterionDone);                          }                          break;                        case "":                          // NOP                          stateStack.Push(ParseState.Whitespace);                          break;                        default:                          throw new ArgumentException("'" + tokens[i] + "'");                  }
Magic Number,Ionic,FileSelector,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\FileSelector.cs,_ParseCriterion,The following statement contains a magic number: switch (tok1)                  {                      case "and":                      case "xor":                      case "or":                          state = stateStack.Peek();                          if (state != ParseState.CriterionDone)                              throw new ArgumentException(String.Join(" "' tokens' i' tokens.Length - i));                            if (tokens.Length <= i + 3)                              throw new ArgumentException(String.Join(" "' tokens' i' tokens.Length - i));                            pendingConjunction = (LogicalConjunction)Enum.Parse(typeof(LogicalConjunction)' tokens[i].ToUpper()' true);                          current = new CompoundCriterion { Left = current' Right = null' Conjunction = pendingConjunction };                          stateStack.Push(state);                          stateStack.Push(ParseState.ConjunctionPending);                          critStack.Push(current);                          break;                        case "(":                          state = stateStack.Peek();                          if (state != ParseState.Start && state != ParseState.ConjunctionPending && state != ParseState.OpenParen)                              throw new ArgumentException(String.Join(" "' tokens' i' tokens.Length - i));                            if (tokens.Length <= i + 4)                              throw new ArgumentException(String.Join(" "' tokens' i' tokens.Length - i));                            stateStack.Push(ParseState.OpenParen);                          break;                        case ")":                          state = stateStack.Pop();                          if (stateStack.Peek() != ParseState.OpenParen)                              throw new ArgumentException(String.Join(" "' tokens' i' tokens.Length - i));                            stateStack.Pop();                          stateStack.Push(ParseState.CriterionDone);                          break;                        case "atime":                      case "ctime":                      case "mtime":                          if (tokens.Length <= i + 2)                              throw new ArgumentException(String.Join(" "' tokens' i' tokens.Length - i));                            DateTime t;                          try                          {                              t = DateTime.ParseExact(tokens[i + 2]' "yyyy-MM-dd-HH:mm:ss"' null);                          }                          catch (FormatException)                          {                              try                              {                                  t = DateTime.ParseExact(tokens[i + 2]' "yyyy/MM/dd-HH:mm:ss"' null);                              }                              catch (FormatException)                              {                                  try                                  {                                      t = DateTime.ParseExact(tokens[i + 2]' "yyyy/MM/dd"' null);                                  }                                  catch (FormatException)                                  {                                      try                                      {                                          t = DateTime.ParseExact(tokens[i + 2]' "MM/dd/yyyy"' null);                                      }                                      catch (FormatException)                                      {                                          t = DateTime.ParseExact(tokens[i + 2]' "yyyy-MM-dd"' null);                                      }                                  }                              }                          }                          t= DateTime.SpecifyKind(t' DateTimeKind.Local).ToUniversalTime();                          current = new TimeCriterion                          {                              Which = (WhichTime)Enum.Parse(typeof(WhichTime)' tokens[i]' true)'                              Operator = (ComparisonOperator)EnumUtil.Parse(typeof(ComparisonOperator)' tokens[i + 1])'                              Time = t                          };                          i += 2;                          stateStack.Push(ParseState.CriterionDone);                          break;                          case "length":                      case "size":                          if (tokens.Length <= i + 2)                              throw new ArgumentException(String.Join(" "' tokens' i' tokens.Length - i));                            Int64 sz = 0;                          string v = tokens[i + 2];                          if (v.ToUpper().EndsWith("K"))                              sz = Int64.Parse(v.Substring(0' v.Length - 1)) * 1024;                          else if (v.ToUpper().EndsWith("KB"))                              sz = Int64.Parse(v.Substring(0' v.Length - 2)) * 1024;                          else if (v.ToUpper().EndsWith("M"))                              sz = Int64.Parse(v.Substring(0' v.Length - 1)) * 1024 * 1024;                          else if (v.ToUpper().EndsWith("MB"))                              sz = Int64.Parse(v.Substring(0' v.Length - 2)) * 1024 * 1024;                          else if (v.ToUpper().EndsWith("G"))                              sz = Int64.Parse(v.Substring(0' v.Length - 1)) * 1024 * 1024 * 1024;                          else if (v.ToUpper().EndsWith("GB"))                              sz = Int64.Parse(v.Substring(0' v.Length - 2)) * 1024 * 1024 * 1024;                          else sz = Int64.Parse(tokens[i + 2]);                            current = new SizeCriterion                          {                              Size = sz'                              Operator = (ComparisonOperator)EnumUtil.Parse(typeof(ComparisonOperator)' tokens[i + 1])                          };                          i += 2;                          stateStack.Push(ParseState.CriterionDone);                          break;                        case "filename":                      case "name":                          {                              if (tokens.Length <= i + 2)                                  throw new ArgumentException(String.Join(" "' tokens' i' tokens.Length - i));                                ComparisonOperator c =                                  (ComparisonOperator)EnumUtil.Parse(typeof(ComparisonOperator)' tokens[i + 1]);                                if (c != ComparisonOperator.NotEqualTo && c != ComparisonOperator.EqualTo)                                  throw new ArgumentException(String.Join(" "' tokens' i' tokens.Length - i));                                string m = tokens[i + 2];                                // handle single-quoted filespecs (used to include                              // spaces in filename patterns)                              if (m.StartsWith("'") && m.EndsWith("'"))                              {                                  // trim off leading and trailing single quotes and                                  // revert the control characters to spaces.                                  m = m.Substring(1' m.Length - 2)                                      .Replace("\u0006"' " ");                              }                                // if (m.StartsWith("'"))                              //     m = m.Replace("\u0006"' " ");                                //Fix for Unix -> NormalizeCriteriaExpression replaces all slashes with backslashes                              if (Path.DirectorySeparatorChar == '/')                                  m = m.Replace('\\'' Path.DirectorySeparatorChar);                                current = new NameCriterion                              {                                  MatchingFileSpec = m'                                  Operator = c                              };                              i += 2;                              stateStack.Push(ParseState.CriterionDone);                          }                          break;                        case "attrs":                      case "attributes":                      case "type":                          {                              if (tokens.Length <= i + 2)                                  throw new ArgumentException(String.Join(" "' tokens' i' tokens.Length - i));                                ComparisonOperator c =                                  (ComparisonOperator)EnumUtil.Parse(typeof(ComparisonOperator)' tokens[i + 1]);                                if (c != ComparisonOperator.NotEqualTo && c != ComparisonOperator.EqualTo)                                  throw new ArgumentException(String.Join(" "' tokens' i' tokens.Length - i));                                current = (tok1 == "type")                                  ? (SelectionCriterion) new TypeCriterion                                      {                                          AttributeString = tokens[i + 2]'                                          Operator = c                                      }                                  : (SelectionCriterion) new AttributesCriterion                                      {                                          AttributeString = tokens[i + 2]'                                          Operator = c                                      };                              i += 2;                              stateStack.Push(ParseState.CriterionDone);                          }                          break;                        case "":                          // NOP                          stateStack.Push(ParseState.Whitespace);                          break;                        default:                          throw new ArgumentException("'" + tokens[i] + "'");                  }
Magic Number,Ionic,FileSelector,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\FileSelector.cs,_ParseCriterion,The following statement contains a magic number: switch (tok1)                  {                      case "and":                      case "xor":                      case "or":                          state = stateStack.Peek();                          if (state != ParseState.CriterionDone)                              throw new ArgumentException(String.Join(" "' tokens' i' tokens.Length - i));                            if (tokens.Length <= i + 3)                              throw new ArgumentException(String.Join(" "' tokens' i' tokens.Length - i));                            pendingConjunction = (LogicalConjunction)Enum.Parse(typeof(LogicalConjunction)' tokens[i].ToUpper()' true);                          current = new CompoundCriterion { Left = current' Right = null' Conjunction = pendingConjunction };                          stateStack.Push(state);                          stateStack.Push(ParseState.ConjunctionPending);                          critStack.Push(current);                          break;                        case "(":                          state = stateStack.Peek();                          if (state != ParseState.Start && state != ParseState.ConjunctionPending && state != ParseState.OpenParen)                              throw new ArgumentException(String.Join(" "' tokens' i' tokens.Length - i));                            if (tokens.Length <= i + 4)                              throw new ArgumentException(String.Join(" "' tokens' i' tokens.Length - i));                            stateStack.Push(ParseState.OpenParen);                          break;                        case ")":                          state = stateStack.Pop();                          if (stateStack.Peek() != ParseState.OpenParen)                              throw new ArgumentException(String.Join(" "' tokens' i' tokens.Length - i));                            stateStack.Pop();                          stateStack.Push(ParseState.CriterionDone);                          break;                        case "atime":                      case "ctime":                      case "mtime":                          if (tokens.Length <= i + 2)                              throw new ArgumentException(String.Join(" "' tokens' i' tokens.Length - i));                            DateTime t;                          try                          {                              t = DateTime.ParseExact(tokens[i + 2]' "yyyy-MM-dd-HH:mm:ss"' null);                          }                          catch (FormatException)                          {                              try                              {                                  t = DateTime.ParseExact(tokens[i + 2]' "yyyy/MM/dd-HH:mm:ss"' null);                              }                              catch (FormatException)                              {                                  try                                  {                                      t = DateTime.ParseExact(tokens[i + 2]' "yyyy/MM/dd"' null);                                  }                                  catch (FormatException)                                  {                                      try                                      {                                          t = DateTime.ParseExact(tokens[i + 2]' "MM/dd/yyyy"' null);                                      }                                      catch (FormatException)                                      {                                          t = DateTime.ParseExact(tokens[i + 2]' "yyyy-MM-dd"' null);                                      }                                  }                              }                          }                          t= DateTime.SpecifyKind(t' DateTimeKind.Local).ToUniversalTime();                          current = new TimeCriterion                          {                              Which = (WhichTime)Enum.Parse(typeof(WhichTime)' tokens[i]' true)'                              Operator = (ComparisonOperator)EnumUtil.Parse(typeof(ComparisonOperator)' tokens[i + 1])'                              Time = t                          };                          i += 2;                          stateStack.Push(ParseState.CriterionDone);                          break;                          case "length":                      case "size":                          if (tokens.Length <= i + 2)                              throw new ArgumentException(String.Join(" "' tokens' i' tokens.Length - i));                            Int64 sz = 0;                          string v = tokens[i + 2];                          if (v.ToUpper().EndsWith("K"))                              sz = Int64.Parse(v.Substring(0' v.Length - 1)) * 1024;                          else if (v.ToUpper().EndsWith("KB"))                              sz = Int64.Parse(v.Substring(0' v.Length - 2)) * 1024;                          else if (v.ToUpper().EndsWith("M"))                              sz = Int64.Parse(v.Substring(0' v.Length - 1)) * 1024 * 1024;                          else if (v.ToUpper().EndsWith("MB"))                              sz = Int64.Parse(v.Substring(0' v.Length - 2)) * 1024 * 1024;                          else if (v.ToUpper().EndsWith("G"))                              sz = Int64.Parse(v.Substring(0' v.Length - 1)) * 1024 * 1024 * 1024;                          else if (v.ToUpper().EndsWith("GB"))                              sz = Int64.Parse(v.Substring(0' v.Length - 2)) * 1024 * 1024 * 1024;                          else sz = Int64.Parse(tokens[i + 2]);                            current = new SizeCriterion                          {                              Size = sz'                              Operator = (ComparisonOperator)EnumUtil.Parse(typeof(ComparisonOperator)' tokens[i + 1])                          };                          i += 2;                          stateStack.Push(ParseState.CriterionDone);                          break;                        case "filename":                      case "name":                          {                              if (tokens.Length <= i + 2)                                  throw new ArgumentException(String.Join(" "' tokens' i' tokens.Length - i));                                ComparisonOperator c =                                  (ComparisonOperator)EnumUtil.Parse(typeof(ComparisonOperator)' tokens[i + 1]);                                if (c != ComparisonOperator.NotEqualTo && c != ComparisonOperator.EqualTo)                                  throw new ArgumentException(String.Join(" "' tokens' i' tokens.Length - i));                                string m = tokens[i + 2];                                // handle single-quoted filespecs (used to include                              // spaces in filename patterns)                              if (m.StartsWith("'") && m.EndsWith("'"))                              {                                  // trim off leading and trailing single quotes and                                  // revert the control characters to spaces.                                  m = m.Substring(1' m.Length - 2)                                      .Replace("\u0006"' " ");                              }                                // if (m.StartsWith("'"))                              //     m = m.Replace("\u0006"' " ");                                //Fix for Unix -> NormalizeCriteriaExpression replaces all slashes with backslashes                              if (Path.DirectorySeparatorChar == '/')                                  m = m.Replace('\\'' Path.DirectorySeparatorChar);                                current = new NameCriterion                              {                                  MatchingFileSpec = m'                                  Operator = c                              };                              i += 2;                              stateStack.Push(ParseState.CriterionDone);                          }                          break;                        case "attrs":                      case "attributes":                      case "type":                          {                              if (tokens.Length <= i + 2)                                  throw new ArgumentException(String.Join(" "' tokens' i' tokens.Length - i));                                ComparisonOperator c =                                  (ComparisonOperator)EnumUtil.Parse(typeof(ComparisonOperator)' tokens[i + 1]);                                if (c != ComparisonOperator.NotEqualTo && c != ComparisonOperator.EqualTo)                                  throw new ArgumentException(String.Join(" "' tokens' i' tokens.Length - i));                                current = (tok1 == "type")                                  ? (SelectionCriterion) new TypeCriterion                                      {                                          AttributeString = tokens[i + 2]'                                          Operator = c                                      }                                  : (SelectionCriterion) new AttributesCriterion                                      {                                          AttributeString = tokens[i + 2]'                                          Operator = c                                      };                              i += 2;                              stateStack.Push(ParseState.CriterionDone);                          }                          break;                        case "":                          // NOP                          stateStack.Push(ParseState.Whitespace);                          break;                        default:                          throw new ArgumentException("'" + tokens[i] + "'");                  }
Magic Number,Ionic,FileSelector,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\FileSelector.cs,_ParseCriterion,The following statement contains a magic number: switch (tok1)                  {                      case "and":                      case "xor":                      case "or":                          state = stateStack.Peek();                          if (state != ParseState.CriterionDone)                              throw new ArgumentException(String.Join(" "' tokens' i' tokens.Length - i));                            if (tokens.Length <= i + 3)                              throw new ArgumentException(String.Join(" "' tokens' i' tokens.Length - i));                            pendingConjunction = (LogicalConjunction)Enum.Parse(typeof(LogicalConjunction)' tokens[i].ToUpper()' true);                          current = new CompoundCriterion { Left = current' Right = null' Conjunction = pendingConjunction };                          stateStack.Push(state);                          stateStack.Push(ParseState.ConjunctionPending);                          critStack.Push(current);                          break;                        case "(":                          state = stateStack.Peek();                          if (state != ParseState.Start && state != ParseState.ConjunctionPending && state != ParseState.OpenParen)                              throw new ArgumentException(String.Join(" "' tokens' i' tokens.Length - i));                            if (tokens.Length <= i + 4)                              throw new ArgumentException(String.Join(" "' tokens' i' tokens.Length - i));                            stateStack.Push(ParseState.OpenParen);                          break;                        case ")":                          state = stateStack.Pop();                          if (stateStack.Peek() != ParseState.OpenParen)                              throw new ArgumentException(String.Join(" "' tokens' i' tokens.Length - i));                            stateStack.Pop();                          stateStack.Push(ParseState.CriterionDone);                          break;                        case "atime":                      case "ctime":                      case "mtime":                          if (tokens.Length <= i + 2)                              throw new ArgumentException(String.Join(" "' tokens' i' tokens.Length - i));                            DateTime t;                          try                          {                              t = DateTime.ParseExact(tokens[i + 2]' "yyyy-MM-dd-HH:mm:ss"' null);                          }                          catch (FormatException)                          {                              try                              {                                  t = DateTime.ParseExact(tokens[i + 2]' "yyyy/MM/dd-HH:mm:ss"' null);                              }                              catch (FormatException)                              {                                  try                                  {                                      t = DateTime.ParseExact(tokens[i + 2]' "yyyy/MM/dd"' null);                                  }                                  catch (FormatException)                                  {                                      try                                      {                                          t = DateTime.ParseExact(tokens[i + 2]' "MM/dd/yyyy"' null);                                      }                                      catch (FormatException)                                      {                                          t = DateTime.ParseExact(tokens[i + 2]' "yyyy-MM-dd"' null);                                      }                                  }                              }                          }                          t= DateTime.SpecifyKind(t' DateTimeKind.Local).ToUniversalTime();                          current = new TimeCriterion                          {                              Which = (WhichTime)Enum.Parse(typeof(WhichTime)' tokens[i]' true)'                              Operator = (ComparisonOperator)EnumUtil.Parse(typeof(ComparisonOperator)' tokens[i + 1])'                              Time = t                          };                          i += 2;                          stateStack.Push(ParseState.CriterionDone);                          break;                          case "length":                      case "size":                          if (tokens.Length <= i + 2)                              throw new ArgumentException(String.Join(" "' tokens' i' tokens.Length - i));                            Int64 sz = 0;                          string v = tokens[i + 2];                          if (v.ToUpper().EndsWith("K"))                              sz = Int64.Parse(v.Substring(0' v.Length - 1)) * 1024;                          else if (v.ToUpper().EndsWith("KB"))                              sz = Int64.Parse(v.Substring(0' v.Length - 2)) * 1024;                          else if (v.ToUpper().EndsWith("M"))                              sz = Int64.Parse(v.Substring(0' v.Length - 1)) * 1024 * 1024;                          else if (v.ToUpper().EndsWith("MB"))                              sz = Int64.Parse(v.Substring(0' v.Length - 2)) * 1024 * 1024;                          else if (v.ToUpper().EndsWith("G"))                              sz = Int64.Parse(v.Substring(0' v.Length - 1)) * 1024 * 1024 * 1024;                          else if (v.ToUpper().EndsWith("GB"))                              sz = Int64.Parse(v.Substring(0' v.Length - 2)) * 1024 * 1024 * 1024;                          else sz = Int64.Parse(tokens[i + 2]);                            current = new SizeCriterion                          {                              Size = sz'                              Operator = (ComparisonOperator)EnumUtil.Parse(typeof(ComparisonOperator)' tokens[i + 1])                          };                          i += 2;                          stateStack.Push(ParseState.CriterionDone);                          break;                        case "filename":                      case "name":                          {                              if (tokens.Length <= i + 2)                                  throw new ArgumentException(String.Join(" "' tokens' i' tokens.Length - i));                                ComparisonOperator c =                                  (ComparisonOperator)EnumUtil.Parse(typeof(ComparisonOperator)' tokens[i + 1]);                                if (c != ComparisonOperator.NotEqualTo && c != ComparisonOperator.EqualTo)                                  throw new ArgumentException(String.Join(" "' tokens' i' tokens.Length - i));                                string m = tokens[i + 2];                                // handle single-quoted filespecs (used to include                              // spaces in filename patterns)                              if (m.StartsWith("'") && m.EndsWith("'"))                              {                                  // trim off leading and trailing single quotes and                                  // revert the control characters to spaces.                                  m = m.Substring(1' m.Length - 2)                                      .Replace("\u0006"' " ");                              }                                // if (m.StartsWith("'"))                              //     m = m.Replace("\u0006"' " ");                                //Fix for Unix -> NormalizeCriteriaExpression replaces all slashes with backslashes                              if (Path.DirectorySeparatorChar == '/')                                  m = m.Replace('\\'' Path.DirectorySeparatorChar);                                current = new NameCriterion                              {                                  MatchingFileSpec = m'                                  Operator = c                              };                              i += 2;                              stateStack.Push(ParseState.CriterionDone);                          }                          break;                        case "attrs":                      case "attributes":                      case "type":                          {                              if (tokens.Length <= i + 2)                                  throw new ArgumentException(String.Join(" "' tokens' i' tokens.Length - i));                                ComparisonOperator c =                                  (ComparisonOperator)EnumUtil.Parse(typeof(ComparisonOperator)' tokens[i + 1]);                                if (c != ComparisonOperator.NotEqualTo && c != ComparisonOperator.EqualTo)                                  throw new ArgumentException(String.Join(" "' tokens' i' tokens.Length - i));                                current = (tok1 == "type")                                  ? (SelectionCriterion) new TypeCriterion                                      {                                          AttributeString = tokens[i + 2]'                                          Operator = c                                      }                                  : (SelectionCriterion) new AttributesCriterion                                      {                                          AttributeString = tokens[i + 2]'                                          Operator = c                                      };                              i += 2;                              stateStack.Push(ParseState.CriterionDone);                          }                          break;                        case "":                          // NOP                          stateStack.Push(ParseState.Whitespace);                          break;                        default:                          throw new ArgumentException("'" + tokens[i] + "'");                  }
Magic Number,Ionic,FileSelector,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\FileSelector.cs,_ParseCriterion,The following statement contains a magic number: switch (tok1)                  {                      case "and":                      case "xor":                      case "or":                          state = stateStack.Peek();                          if (state != ParseState.CriterionDone)                              throw new ArgumentException(String.Join(" "' tokens' i' tokens.Length - i));                            if (tokens.Length <= i + 3)                              throw new ArgumentException(String.Join(" "' tokens' i' tokens.Length - i));                            pendingConjunction = (LogicalConjunction)Enum.Parse(typeof(LogicalConjunction)' tokens[i].ToUpper()' true);                          current = new CompoundCriterion { Left = current' Right = null' Conjunction = pendingConjunction };                          stateStack.Push(state);                          stateStack.Push(ParseState.ConjunctionPending);                          critStack.Push(current);                          break;                        case "(":                          state = stateStack.Peek();                          if (state != ParseState.Start && state != ParseState.ConjunctionPending && state != ParseState.OpenParen)                              throw new ArgumentException(String.Join(" "' tokens' i' tokens.Length - i));                            if (tokens.Length <= i + 4)                              throw new ArgumentException(String.Join(" "' tokens' i' tokens.Length - i));                            stateStack.Push(ParseState.OpenParen);                          break;                        case ")":                          state = stateStack.Pop();                          if (stateStack.Peek() != ParseState.OpenParen)                              throw new ArgumentException(String.Join(" "' tokens' i' tokens.Length - i));                            stateStack.Pop();                          stateStack.Push(ParseState.CriterionDone);                          break;                        case "atime":                      case "ctime":                      case "mtime":                          if (tokens.Length <= i + 2)                              throw new ArgumentException(String.Join(" "' tokens' i' tokens.Length - i));                            DateTime t;                          try                          {                              t = DateTime.ParseExact(tokens[i + 2]' "yyyy-MM-dd-HH:mm:ss"' null);                          }                          catch (FormatException)                          {                              try                              {                                  t = DateTime.ParseExact(tokens[i + 2]' "yyyy/MM/dd-HH:mm:ss"' null);                              }                              catch (FormatException)                              {                                  try                                  {                                      t = DateTime.ParseExact(tokens[i + 2]' "yyyy/MM/dd"' null);                                  }                                  catch (FormatException)                                  {                                      try                                      {                                          t = DateTime.ParseExact(tokens[i + 2]' "MM/dd/yyyy"' null);                                      }                                      catch (FormatException)                                      {                                          t = DateTime.ParseExact(tokens[i + 2]' "yyyy-MM-dd"' null);                                      }                                  }                              }                          }                          t= DateTime.SpecifyKind(t' DateTimeKind.Local).ToUniversalTime();                          current = new TimeCriterion                          {                              Which = (WhichTime)Enum.Parse(typeof(WhichTime)' tokens[i]' true)'                              Operator = (ComparisonOperator)EnumUtil.Parse(typeof(ComparisonOperator)' tokens[i + 1])'                              Time = t                          };                          i += 2;                          stateStack.Push(ParseState.CriterionDone);                          break;                          case "length":                      case "size":                          if (tokens.Length <= i + 2)                              throw new ArgumentException(String.Join(" "' tokens' i' tokens.Length - i));                            Int64 sz = 0;                          string v = tokens[i + 2];                          if (v.ToUpper().EndsWith("K"))                              sz = Int64.Parse(v.Substring(0' v.Length - 1)) * 1024;                          else if (v.ToUpper().EndsWith("KB"))                              sz = Int64.Parse(v.Substring(0' v.Length - 2)) * 1024;                          else if (v.ToUpper().EndsWith("M"))                              sz = Int64.Parse(v.Substring(0' v.Length - 1)) * 1024 * 1024;                          else if (v.ToUpper().EndsWith("MB"))                              sz = Int64.Parse(v.Substring(0' v.Length - 2)) * 1024 * 1024;                          else if (v.ToUpper().EndsWith("G"))                              sz = Int64.Parse(v.Substring(0' v.Length - 1)) * 1024 * 1024 * 1024;                          else if (v.ToUpper().EndsWith("GB"))                              sz = Int64.Parse(v.Substring(0' v.Length - 2)) * 1024 * 1024 * 1024;                          else sz = Int64.Parse(tokens[i + 2]);                            current = new SizeCriterion                          {                              Size = sz'                              Operator = (ComparisonOperator)EnumUtil.Parse(typeof(ComparisonOperator)' tokens[i + 1])                          };                          i += 2;                          stateStack.Push(ParseState.CriterionDone);                          break;                        case "filename":                      case "name":                          {                              if (tokens.Length <= i + 2)                                  throw new ArgumentException(String.Join(" "' tokens' i' tokens.Length - i));                                ComparisonOperator c =                                  (ComparisonOperator)EnumUtil.Parse(typeof(ComparisonOperator)' tokens[i + 1]);                                if (c != ComparisonOperator.NotEqualTo && c != ComparisonOperator.EqualTo)                                  throw new ArgumentException(String.Join(" "' tokens' i' tokens.Length - i));                                string m = tokens[i + 2];                                // handle single-quoted filespecs (used to include                              // spaces in filename patterns)                              if (m.StartsWith("'") && m.EndsWith("'"))                              {                                  // trim off leading and trailing single quotes and                                  // revert the control characters to spaces.                                  m = m.Substring(1' m.Length - 2)                                      .Replace("\u0006"' " ");                              }                                // if (m.StartsWith("'"))                              //     m = m.Replace("\u0006"' " ");                                //Fix for Unix -> NormalizeCriteriaExpression replaces all slashes with backslashes                              if (Path.DirectorySeparatorChar == '/')                                  m = m.Replace('\\'' Path.DirectorySeparatorChar);                                current = new NameCriterion                              {                                  MatchingFileSpec = m'                                  Operator = c                              };                              i += 2;                              stateStack.Push(ParseState.CriterionDone);                          }                          break;                        case "attrs":                      case "attributes":                      case "type":                          {                              if (tokens.Length <= i + 2)                                  throw new ArgumentException(String.Join(" "' tokens' i' tokens.Length - i));                                ComparisonOperator c =                                  (ComparisonOperator)EnumUtil.Parse(typeof(ComparisonOperator)' tokens[i + 1]);                                if (c != ComparisonOperator.NotEqualTo && c != ComparisonOperator.EqualTo)                                  throw new ArgumentException(String.Join(" "' tokens' i' tokens.Length - i));                                current = (tok1 == "type")                                  ? (SelectionCriterion) new TypeCriterion                                      {                                          AttributeString = tokens[i + 2]'                                          Operator = c                                      }                                  : (SelectionCriterion) new AttributesCriterion                                      {                                          AttributeString = tokens[i + 2]'                                          Operator = c                                      };                              i += 2;                              stateStack.Push(ParseState.CriterionDone);                          }                          break;                        case "":                          // NOP                          stateStack.Push(ParseState.Whitespace);                          break;                        default:                          throw new ArgumentException("'" + tokens[i] + "'");                  }
Magic Number,Ionic,FileSelector,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\FileSelector.cs,_ParseCriterion,The following statement contains a magic number: switch (tok1)                  {                      case "and":                      case "xor":                      case "or":                          state = stateStack.Peek();                          if (state != ParseState.CriterionDone)                              throw new ArgumentException(String.Join(" "' tokens' i' tokens.Length - i));                            if (tokens.Length <= i + 3)                              throw new ArgumentException(String.Join(" "' tokens' i' tokens.Length - i));                            pendingConjunction = (LogicalConjunction)Enum.Parse(typeof(LogicalConjunction)' tokens[i].ToUpper()' true);                          current = new CompoundCriterion { Left = current' Right = null' Conjunction = pendingConjunction };                          stateStack.Push(state);                          stateStack.Push(ParseState.ConjunctionPending);                          critStack.Push(current);                          break;                        case "(":                          state = stateStack.Peek();                          if (state != ParseState.Start && state != ParseState.ConjunctionPending && state != ParseState.OpenParen)                              throw new ArgumentException(String.Join(" "' tokens' i' tokens.Length - i));                            if (tokens.Length <= i + 4)                              throw new ArgumentException(String.Join(" "' tokens' i' tokens.Length - i));                            stateStack.Push(ParseState.OpenParen);                          break;                        case ")":                          state = stateStack.Pop();                          if (stateStack.Peek() != ParseState.OpenParen)                              throw new ArgumentException(String.Join(" "' tokens' i' tokens.Length - i));                            stateStack.Pop();                          stateStack.Push(ParseState.CriterionDone);                          break;                        case "atime":                      case "ctime":                      case "mtime":                          if (tokens.Length <= i + 2)                              throw new ArgumentException(String.Join(" "' tokens' i' tokens.Length - i));                            DateTime t;                          try                          {                              t = DateTime.ParseExact(tokens[i + 2]' "yyyy-MM-dd-HH:mm:ss"' null);                          }                          catch (FormatException)                          {                              try                              {                                  t = DateTime.ParseExact(tokens[i + 2]' "yyyy/MM/dd-HH:mm:ss"' null);                              }                              catch (FormatException)                              {                                  try                                  {                                      t = DateTime.ParseExact(tokens[i + 2]' "yyyy/MM/dd"' null);                                  }                                  catch (FormatException)                                  {                                      try                                      {                                          t = DateTime.ParseExact(tokens[i + 2]' "MM/dd/yyyy"' null);                                      }                                      catch (FormatException)                                      {                                          t = DateTime.ParseExact(tokens[i + 2]' "yyyy-MM-dd"' null);                                      }                                  }                              }                          }                          t= DateTime.SpecifyKind(t' DateTimeKind.Local).ToUniversalTime();                          current = new TimeCriterion                          {                              Which = (WhichTime)Enum.Parse(typeof(WhichTime)' tokens[i]' true)'                              Operator = (ComparisonOperator)EnumUtil.Parse(typeof(ComparisonOperator)' tokens[i + 1])'                              Time = t                          };                          i += 2;                          stateStack.Push(ParseState.CriterionDone);                          break;                          case "length":                      case "size":                          if (tokens.Length <= i + 2)                              throw new ArgumentException(String.Join(" "' tokens' i' tokens.Length - i));                            Int64 sz = 0;                          string v = tokens[i + 2];                          if (v.ToUpper().EndsWith("K"))                              sz = Int64.Parse(v.Substring(0' v.Length - 1)) * 1024;                          else if (v.ToUpper().EndsWith("KB"))                              sz = Int64.Parse(v.Substring(0' v.Length - 2)) * 1024;                          else if (v.ToUpper().EndsWith("M"))                              sz = Int64.Parse(v.Substring(0' v.Length - 1)) * 1024 * 1024;                          else if (v.ToUpper().EndsWith("MB"))                              sz = Int64.Parse(v.Substring(0' v.Length - 2)) * 1024 * 1024;                          else if (v.ToUpper().EndsWith("G"))                              sz = Int64.Parse(v.Substring(0' v.Length - 1)) * 1024 * 1024 * 1024;                          else if (v.ToUpper().EndsWith("GB"))                              sz = Int64.Parse(v.Substring(0' v.Length - 2)) * 1024 * 1024 * 1024;                          else sz = Int64.Parse(tokens[i + 2]);                            current = new SizeCriterion                          {                              Size = sz'                              Operator = (ComparisonOperator)EnumUtil.Parse(typeof(ComparisonOperator)' tokens[i + 1])                          };                          i += 2;                          stateStack.Push(ParseState.CriterionDone);                          break;                        case "filename":                      case "name":                          {                              if (tokens.Length <= i + 2)                                  throw new ArgumentException(String.Join(" "' tokens' i' tokens.Length - i));                                ComparisonOperator c =                                  (ComparisonOperator)EnumUtil.Parse(typeof(ComparisonOperator)' tokens[i + 1]);                                if (c != ComparisonOperator.NotEqualTo && c != ComparisonOperator.EqualTo)                                  throw new ArgumentException(String.Join(" "' tokens' i' tokens.Length - i));                                string m = tokens[i + 2];                                // handle single-quoted filespecs (used to include                              // spaces in filename patterns)                              if (m.StartsWith("'") && m.EndsWith("'"))                              {                                  // trim off leading and trailing single quotes and                                  // revert the control characters to spaces.                                  m = m.Substring(1' m.Length - 2)                                      .Replace("\u0006"' " ");                              }                                // if (m.StartsWith("'"))                              //     m = m.Replace("\u0006"' " ");                                //Fix for Unix -> NormalizeCriteriaExpression replaces all slashes with backslashes                              if (Path.DirectorySeparatorChar == '/')                                  m = m.Replace('\\'' Path.DirectorySeparatorChar);                                current = new NameCriterion                              {                                  MatchingFileSpec = m'                                  Operator = c                              };                              i += 2;                              stateStack.Push(ParseState.CriterionDone);                          }                          break;                        case "attrs":                      case "attributes":                      case "type":                          {                              if (tokens.Length <= i + 2)                                  throw new ArgumentException(String.Join(" "' tokens' i' tokens.Length - i));                                ComparisonOperator c =                                  (ComparisonOperator)EnumUtil.Parse(typeof(ComparisonOperator)' tokens[i + 1]);                                if (c != ComparisonOperator.NotEqualTo && c != ComparisonOperator.EqualTo)                                  throw new ArgumentException(String.Join(" "' tokens' i' tokens.Length - i));                                current = (tok1 == "type")                                  ? (SelectionCriterion) new TypeCriterion                                      {                                          AttributeString = tokens[i + 2]'                                          Operator = c                                      }                                  : (SelectionCriterion) new AttributesCriterion                                      {                                          AttributeString = tokens[i + 2]'                                          Operator = c                                      };                              i += 2;                              stateStack.Push(ParseState.CriterionDone);                          }                          break;                        case "":                          // NOP                          stateStack.Push(ParseState.Whitespace);                          break;                        default:                          throw new ArgumentException("'" + tokens[i] + "'");                  }
Magic Number,Ionic,FileSelector,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\FileSelector.cs,_ParseCriterion,The following statement contains a magic number: switch (tok1)                  {                      case "and":                      case "xor":                      case "or":                          state = stateStack.Peek();                          if (state != ParseState.CriterionDone)                              throw new ArgumentException(String.Join(" "' tokens' i' tokens.Length - i));                            if (tokens.Length <= i + 3)                              throw new ArgumentException(String.Join(" "' tokens' i' tokens.Length - i));                            pendingConjunction = (LogicalConjunction)Enum.Parse(typeof(LogicalConjunction)' tokens[i].ToUpper()' true);                          current = new CompoundCriterion { Left = current' Right = null' Conjunction = pendingConjunction };                          stateStack.Push(state);                          stateStack.Push(ParseState.ConjunctionPending);                          critStack.Push(current);                          break;                        case "(":                          state = stateStack.Peek();                          if (state != ParseState.Start && state != ParseState.ConjunctionPending && state != ParseState.OpenParen)                              throw new ArgumentException(String.Join(" "' tokens' i' tokens.Length - i));                            if (tokens.Length <= i + 4)                              throw new ArgumentException(String.Join(" "' tokens' i' tokens.Length - i));                            stateStack.Push(ParseState.OpenParen);                          break;                        case ")":                          state = stateStack.Pop();                          if (stateStack.Peek() != ParseState.OpenParen)                              throw new ArgumentException(String.Join(" "' tokens' i' tokens.Length - i));                            stateStack.Pop();                          stateStack.Push(ParseState.CriterionDone);                          break;                        case "atime":                      case "ctime":                      case "mtime":                          if (tokens.Length <= i + 2)                              throw new ArgumentException(String.Join(" "' tokens' i' tokens.Length - i));                            DateTime t;                          try                          {                              t = DateTime.ParseExact(tokens[i + 2]' "yyyy-MM-dd-HH:mm:ss"' null);                          }                          catch (FormatException)                          {                              try                              {                                  t = DateTime.ParseExact(tokens[i + 2]' "yyyy/MM/dd-HH:mm:ss"' null);                              }                              catch (FormatException)                              {                                  try                                  {                                      t = DateTime.ParseExact(tokens[i + 2]' "yyyy/MM/dd"' null);                                  }                                  catch (FormatException)                                  {                                      try                                      {                                          t = DateTime.ParseExact(tokens[i + 2]' "MM/dd/yyyy"' null);                                      }                                      catch (FormatException)                                      {                                          t = DateTime.ParseExact(tokens[i + 2]' "yyyy-MM-dd"' null);                                      }                                  }                              }                          }                          t= DateTime.SpecifyKind(t' DateTimeKind.Local).ToUniversalTime();                          current = new TimeCriterion                          {                              Which = (WhichTime)Enum.Parse(typeof(WhichTime)' tokens[i]' true)'                              Operator = (ComparisonOperator)EnumUtil.Parse(typeof(ComparisonOperator)' tokens[i + 1])'                              Time = t                          };                          i += 2;                          stateStack.Push(ParseState.CriterionDone);                          break;                          case "length":                      case "size":                          if (tokens.Length <= i + 2)                              throw new ArgumentException(String.Join(" "' tokens' i' tokens.Length - i));                            Int64 sz = 0;                          string v = tokens[i + 2];                          if (v.ToUpper().EndsWith("K"))                              sz = Int64.Parse(v.Substring(0' v.Length - 1)) * 1024;                          else if (v.ToUpper().EndsWith("KB"))                              sz = Int64.Parse(v.Substring(0' v.Length - 2)) * 1024;                          else if (v.ToUpper().EndsWith("M"))                              sz = Int64.Parse(v.Substring(0' v.Length - 1)) * 1024 * 1024;                          else if (v.ToUpper().EndsWith("MB"))                              sz = Int64.Parse(v.Substring(0' v.Length - 2)) * 1024 * 1024;                          else if (v.ToUpper().EndsWith("G"))                              sz = Int64.Parse(v.Substring(0' v.Length - 1)) * 1024 * 1024 * 1024;                          else if (v.ToUpper().EndsWith("GB"))                              sz = Int64.Parse(v.Substring(0' v.Length - 2)) * 1024 * 1024 * 1024;                          else sz = Int64.Parse(tokens[i + 2]);                            current = new SizeCriterion                          {                              Size = sz'                              Operator = (ComparisonOperator)EnumUtil.Parse(typeof(ComparisonOperator)' tokens[i + 1])                          };                          i += 2;                          stateStack.Push(ParseState.CriterionDone);                          break;                        case "filename":                      case "name":                          {                              if (tokens.Length <= i + 2)                                  throw new ArgumentException(String.Join(" "' tokens' i' tokens.Length - i));                                ComparisonOperator c =                                  (ComparisonOperator)EnumUtil.Parse(typeof(ComparisonOperator)' tokens[i + 1]);                                if (c != ComparisonOperator.NotEqualTo && c != ComparisonOperator.EqualTo)                                  throw new ArgumentException(String.Join(" "' tokens' i' tokens.Length - i));                                string m = tokens[i + 2];                                // handle single-quoted filespecs (used to include                              // spaces in filename patterns)                              if (m.StartsWith("'") && m.EndsWith("'"))                              {                                  // trim off leading and trailing single quotes and                                  // revert the control characters to spaces.                                  m = m.Substring(1' m.Length - 2)                                      .Replace("\u0006"' " ");                              }                                // if (m.StartsWith("'"))                              //     m = m.Replace("\u0006"' " ");                                //Fix for Unix -> NormalizeCriteriaExpression replaces all slashes with backslashes                              if (Path.DirectorySeparatorChar == '/')                                  m = m.Replace('\\'' Path.DirectorySeparatorChar);                                current = new NameCriterion                              {                                  MatchingFileSpec = m'                                  Operator = c                              };                              i += 2;                              stateStack.Push(ParseState.CriterionDone);                          }                          break;                        case "attrs":                      case "attributes":                      case "type":                          {                              if (tokens.Length <= i + 2)                                  throw new ArgumentException(String.Join(" "' tokens' i' tokens.Length - i));                                ComparisonOperator c =                                  (ComparisonOperator)EnumUtil.Parse(typeof(ComparisonOperator)' tokens[i + 1]);                                if (c != ComparisonOperator.NotEqualTo && c != ComparisonOperator.EqualTo)                                  throw new ArgumentException(String.Join(" "' tokens' i' tokens.Length - i));                                current = (tok1 == "type")                                  ? (SelectionCriterion) new TypeCriterion                                      {                                          AttributeString = tokens[i + 2]'                                          Operator = c                                      }                                  : (SelectionCriterion) new AttributesCriterion                                      {                                          AttributeString = tokens[i + 2]'                                          Operator = c                                      };                              i += 2;                              stateStack.Push(ParseState.CriterionDone);                          }                          break;                        case "":                          // NOP                          stateStack.Push(ParseState.Whitespace);                          break;                        default:                          throw new ArgumentException("'" + tokens[i] + "'");                  }
Magic Number,Ionic,FileSelector,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\FileSelector.cs,_ParseCriterion,The following statement contains a magic number: switch (tok1)                  {                      case "and":                      case "xor":                      case "or":                          state = stateStack.Peek();                          if (state != ParseState.CriterionDone)                              throw new ArgumentException(String.Join(" "' tokens' i' tokens.Length - i));                            if (tokens.Length <= i + 3)                              throw new ArgumentException(String.Join(" "' tokens' i' tokens.Length - i));                            pendingConjunction = (LogicalConjunction)Enum.Parse(typeof(LogicalConjunction)' tokens[i].ToUpper()' true);                          current = new CompoundCriterion { Left = current' Right = null' Conjunction = pendingConjunction };                          stateStack.Push(state);                          stateStack.Push(ParseState.ConjunctionPending);                          critStack.Push(current);                          break;                        case "(":                          state = stateStack.Peek();                          if (state != ParseState.Start && state != ParseState.ConjunctionPending && state != ParseState.OpenParen)                              throw new ArgumentException(String.Join(" "' tokens' i' tokens.Length - i));                            if (tokens.Length <= i + 4)                              throw new ArgumentException(String.Join(" "' tokens' i' tokens.Length - i));                            stateStack.Push(ParseState.OpenParen);                          break;                        case ")":                          state = stateStack.Pop();                          if (stateStack.Peek() != ParseState.OpenParen)                              throw new ArgumentException(String.Join(" "' tokens' i' tokens.Length - i));                            stateStack.Pop();                          stateStack.Push(ParseState.CriterionDone);                          break;                        case "atime":                      case "ctime":                      case "mtime":                          if (tokens.Length <= i + 2)                              throw new ArgumentException(String.Join(" "' tokens' i' tokens.Length - i));                            DateTime t;                          try                          {                              t = DateTime.ParseExact(tokens[i + 2]' "yyyy-MM-dd-HH:mm:ss"' null);                          }                          catch (FormatException)                          {                              try                              {                                  t = DateTime.ParseExact(tokens[i + 2]' "yyyy/MM/dd-HH:mm:ss"' null);                              }                              catch (FormatException)                              {                                  try                                  {                                      t = DateTime.ParseExact(tokens[i + 2]' "yyyy/MM/dd"' null);                                  }                                  catch (FormatException)                                  {                                      try                                      {                                          t = DateTime.ParseExact(tokens[i + 2]' "MM/dd/yyyy"' null);                                      }                                      catch (FormatException)                                      {                                          t = DateTime.ParseExact(tokens[i + 2]' "yyyy-MM-dd"' null);                                      }                                  }                              }                          }                          t= DateTime.SpecifyKind(t' DateTimeKind.Local).ToUniversalTime();                          current = new TimeCriterion                          {                              Which = (WhichTime)Enum.Parse(typeof(WhichTime)' tokens[i]' true)'                              Operator = (ComparisonOperator)EnumUtil.Parse(typeof(ComparisonOperator)' tokens[i + 1])'                              Time = t                          };                          i += 2;                          stateStack.Push(ParseState.CriterionDone);                          break;                          case "length":                      case "size":                          if (tokens.Length <= i + 2)                              throw new ArgumentException(String.Join(" "' tokens' i' tokens.Length - i));                            Int64 sz = 0;                          string v = tokens[i + 2];                          if (v.ToUpper().EndsWith("K"))                              sz = Int64.Parse(v.Substring(0' v.Length - 1)) * 1024;                          else if (v.ToUpper().EndsWith("KB"))                              sz = Int64.Parse(v.Substring(0' v.Length - 2)) * 1024;                          else if (v.ToUpper().EndsWith("M"))                              sz = Int64.Parse(v.Substring(0' v.Length - 1)) * 1024 * 1024;                          else if (v.ToUpper().EndsWith("MB"))                              sz = Int64.Parse(v.Substring(0' v.Length - 2)) * 1024 * 1024;                          else if (v.ToUpper().EndsWith("G"))                              sz = Int64.Parse(v.Substring(0' v.Length - 1)) * 1024 * 1024 * 1024;                          else if (v.ToUpper().EndsWith("GB"))                              sz = Int64.Parse(v.Substring(0' v.Length - 2)) * 1024 * 1024 * 1024;                          else sz = Int64.Parse(tokens[i + 2]);                            current = new SizeCriterion                          {                              Size = sz'                              Operator = (ComparisonOperator)EnumUtil.Parse(typeof(ComparisonOperator)' tokens[i + 1])                          };                          i += 2;                          stateStack.Push(ParseState.CriterionDone);                          break;                        case "filename":                      case "name":                          {                              if (tokens.Length <= i + 2)                                  throw new ArgumentException(String.Join(" "' tokens' i' tokens.Length - i));                                ComparisonOperator c =                                  (ComparisonOperator)EnumUtil.Parse(typeof(ComparisonOperator)' tokens[i + 1]);                                if (c != ComparisonOperator.NotEqualTo && c != ComparisonOperator.EqualTo)                                  throw new ArgumentException(String.Join(" "' tokens' i' tokens.Length - i));                                string m = tokens[i + 2];                                // handle single-quoted filespecs (used to include                              // spaces in filename patterns)                              if (m.StartsWith("'") && m.EndsWith("'"))                              {                                  // trim off leading and trailing single quotes and                                  // revert the control characters to spaces.                                  m = m.Substring(1' m.Length - 2)                                      .Replace("\u0006"' " ");                              }                                // if (m.StartsWith("'"))                              //     m = m.Replace("\u0006"' " ");                                //Fix for Unix -> NormalizeCriteriaExpression replaces all slashes with backslashes                              if (Path.DirectorySeparatorChar == '/')                                  m = m.Replace('\\'' Path.DirectorySeparatorChar);                                current = new NameCriterion                              {                                  MatchingFileSpec = m'                                  Operator = c                              };                              i += 2;                              stateStack.Push(ParseState.CriterionDone);                          }                          break;                        case "attrs":                      case "attributes":                      case "type":                          {                              if (tokens.Length <= i + 2)                                  throw new ArgumentException(String.Join(" "' tokens' i' tokens.Length - i));                                ComparisonOperator c =                                  (ComparisonOperator)EnumUtil.Parse(typeof(ComparisonOperator)' tokens[i + 1]);                                if (c != ComparisonOperator.NotEqualTo && c != ComparisonOperator.EqualTo)                                  throw new ArgumentException(String.Join(" "' tokens' i' tokens.Length - i));                                current = (tok1 == "type")                                  ? (SelectionCriterion) new TypeCriterion                                      {                                          AttributeString = tokens[i + 2]'                                          Operator = c                                      }                                  : (SelectionCriterion) new AttributesCriterion                                      {                                          AttributeString = tokens[i + 2]'                                          Operator = c                                      };                              i += 2;                              stateStack.Push(ParseState.CriterionDone);                          }                          break;                        case "":                          // NOP                          stateStack.Push(ParseState.Whitespace);                          break;                        default:                          throw new ArgumentException("'" + tokens[i] + "'");                  }
Magic Number,Ionic,FileSelector,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\FileSelector.cs,_ParseCriterion,The following statement contains a magic number: switch (tok1)                  {                      case "and":                      case "xor":                      case "or":                          state = stateStack.Peek();                          if (state != ParseState.CriterionDone)                              throw new ArgumentException(String.Join(" "' tokens' i' tokens.Length - i));                            if (tokens.Length <= i + 3)                              throw new ArgumentException(String.Join(" "' tokens' i' tokens.Length - i));                            pendingConjunction = (LogicalConjunction)Enum.Parse(typeof(LogicalConjunction)' tokens[i].ToUpper()' true);                          current = new CompoundCriterion { Left = current' Right = null' Conjunction = pendingConjunction };                          stateStack.Push(state);                          stateStack.Push(ParseState.ConjunctionPending);                          critStack.Push(current);                          break;                        case "(":                          state = stateStack.Peek();                          if (state != ParseState.Start && state != ParseState.ConjunctionPending && state != ParseState.OpenParen)                              throw new ArgumentException(String.Join(" "' tokens' i' tokens.Length - i));                            if (tokens.Length <= i + 4)                              throw new ArgumentException(String.Join(" "' tokens' i' tokens.Length - i));                            stateStack.Push(ParseState.OpenParen);                          break;                        case ")":                          state = stateStack.Pop();                          if (stateStack.Peek() != ParseState.OpenParen)                              throw new ArgumentException(String.Join(" "' tokens' i' tokens.Length - i));                            stateStack.Pop();                          stateStack.Push(ParseState.CriterionDone);                          break;                        case "atime":                      case "ctime":                      case "mtime":                          if (tokens.Length <= i + 2)                              throw new ArgumentException(String.Join(" "' tokens' i' tokens.Length - i));                            DateTime t;                          try                          {                              t = DateTime.ParseExact(tokens[i + 2]' "yyyy-MM-dd-HH:mm:ss"' null);                          }                          catch (FormatException)                          {                              try                              {                                  t = DateTime.ParseExact(tokens[i + 2]' "yyyy/MM/dd-HH:mm:ss"' null);                              }                              catch (FormatException)                              {                                  try                                  {                                      t = DateTime.ParseExact(tokens[i + 2]' "yyyy/MM/dd"' null);                                  }                                  catch (FormatException)                                  {                                      try                                      {                                          t = DateTime.ParseExact(tokens[i + 2]' "MM/dd/yyyy"' null);                                      }                                      catch (FormatException)                                      {                                          t = DateTime.ParseExact(tokens[i + 2]' "yyyy-MM-dd"' null);                                      }                                  }                              }                          }                          t= DateTime.SpecifyKind(t' DateTimeKind.Local).ToUniversalTime();                          current = new TimeCriterion                          {                              Which = (WhichTime)Enum.Parse(typeof(WhichTime)' tokens[i]' true)'                              Operator = (ComparisonOperator)EnumUtil.Parse(typeof(ComparisonOperator)' tokens[i + 1])'                              Time = t                          };                          i += 2;                          stateStack.Push(ParseState.CriterionDone);                          break;                          case "length":                      case "size":                          if (tokens.Length <= i + 2)                              throw new ArgumentException(String.Join(" "' tokens' i' tokens.Length - i));                            Int64 sz = 0;                          string v = tokens[i + 2];                          if (v.ToUpper().EndsWith("K"))                              sz = Int64.Parse(v.Substring(0' v.Length - 1)) * 1024;                          else if (v.ToUpper().EndsWith("KB"))                              sz = Int64.Parse(v.Substring(0' v.Length - 2)) * 1024;                          else if (v.ToUpper().EndsWith("M"))                              sz = Int64.Parse(v.Substring(0' v.Length - 1)) * 1024 * 1024;                          else if (v.ToUpper().EndsWith("MB"))                              sz = Int64.Parse(v.Substring(0' v.Length - 2)) * 1024 * 1024;                          else if (v.ToUpper().EndsWith("G"))                              sz = Int64.Parse(v.Substring(0' v.Length - 1)) * 1024 * 1024 * 1024;                          else if (v.ToUpper().EndsWith("GB"))                              sz = Int64.Parse(v.Substring(0' v.Length - 2)) * 1024 * 1024 * 1024;                          else sz = Int64.Parse(tokens[i + 2]);                            current = new SizeCriterion                          {                              Size = sz'                              Operator = (ComparisonOperator)EnumUtil.Parse(typeof(ComparisonOperator)' tokens[i + 1])                          };                          i += 2;                          stateStack.Push(ParseState.CriterionDone);                          break;                        case "filename":                      case "name":                          {                              if (tokens.Length <= i + 2)                                  throw new ArgumentException(String.Join(" "' tokens' i' tokens.Length - i));                                ComparisonOperator c =                                  (ComparisonOperator)EnumUtil.Parse(typeof(ComparisonOperator)' tokens[i + 1]);                                if (c != ComparisonOperator.NotEqualTo && c != ComparisonOperator.EqualTo)                                  throw new ArgumentException(String.Join(" "' tokens' i' tokens.Length - i));                                string m = tokens[i + 2];                                // handle single-quoted filespecs (used to include                              // spaces in filename patterns)                              if (m.StartsWith("'") && m.EndsWith("'"))                              {                                  // trim off leading and trailing single quotes and                                  // revert the control characters to spaces.                                  m = m.Substring(1' m.Length - 2)                                      .Replace("\u0006"' " ");                              }                                // if (m.StartsWith("'"))                              //     m = m.Replace("\u0006"' " ");                                //Fix for Unix -> NormalizeCriteriaExpression replaces all slashes with backslashes                              if (Path.DirectorySeparatorChar == '/')                                  m = m.Replace('\\'' Path.DirectorySeparatorChar);                                current = new NameCriterion                              {                                  MatchingFileSpec = m'                                  Operator = c                              };                              i += 2;                              stateStack.Push(ParseState.CriterionDone);                          }                          break;                        case "attrs":                      case "attributes":                      case "type":                          {                              if (tokens.Length <= i + 2)                                  throw new ArgumentException(String.Join(" "' tokens' i' tokens.Length - i));                                ComparisonOperator c =                                  (ComparisonOperator)EnumUtil.Parse(typeof(ComparisonOperator)' tokens[i + 1]);                                if (c != ComparisonOperator.NotEqualTo && c != ComparisonOperator.EqualTo)                                  throw new ArgumentException(String.Join(" "' tokens' i' tokens.Length - i));                                current = (tok1 == "type")                                  ? (SelectionCriterion) new TypeCriterion                                      {                                          AttributeString = tokens[i + 2]'                                          Operator = c                                      }                                  : (SelectionCriterion) new AttributesCriterion                                      {                                          AttributeString = tokens[i + 2]'                                          Operator = c                                      };                              i += 2;                              stateStack.Push(ParseState.CriterionDone);                          }                          break;                        case "":                          // NOP                          stateStack.Push(ParseState.Whitespace);                          break;                        default:                          throw new ArgumentException("'" + tokens[i] + "'");                  }
Magic Number,Ionic,FileSelector,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\FileSelector.cs,_ParseCriterion,The following statement contains a magic number: switch (tok1)                  {                      case "and":                      case "xor":                      case "or":                          state = stateStack.Peek();                          if (state != ParseState.CriterionDone)                              throw new ArgumentException(String.Join(" "' tokens' i' tokens.Length - i));                            if (tokens.Length <= i + 3)                              throw new ArgumentException(String.Join(" "' tokens' i' tokens.Length - i));                            pendingConjunction = (LogicalConjunction)Enum.Parse(typeof(LogicalConjunction)' tokens[i].ToUpper()' true);                          current = new CompoundCriterion { Left = current' Right = null' Conjunction = pendingConjunction };                          stateStack.Push(state);                          stateStack.Push(ParseState.ConjunctionPending);                          critStack.Push(current);                          break;                        case "(":                          state = stateStack.Peek();                          if (state != ParseState.Start && state != ParseState.ConjunctionPending && state != ParseState.OpenParen)                              throw new ArgumentException(String.Join(" "' tokens' i' tokens.Length - i));                            if (tokens.Length <= i + 4)                              throw new ArgumentException(String.Join(" "' tokens' i' tokens.Length - i));                            stateStack.Push(ParseState.OpenParen);                          break;                        case ")":                          state = stateStack.Pop();                          if (stateStack.Peek() != ParseState.OpenParen)                              throw new ArgumentException(String.Join(" "' tokens' i' tokens.Length - i));                            stateStack.Pop();                          stateStack.Push(ParseState.CriterionDone);                          break;                        case "atime":                      case "ctime":                      case "mtime":                          if (tokens.Length <= i + 2)                              throw new ArgumentException(String.Join(" "' tokens' i' tokens.Length - i));                            DateTime t;                          try                          {                              t = DateTime.ParseExact(tokens[i + 2]' "yyyy-MM-dd-HH:mm:ss"' null);                          }                          catch (FormatException)                          {                              try                              {                                  t = DateTime.ParseExact(tokens[i + 2]' "yyyy/MM/dd-HH:mm:ss"' null);                              }                              catch (FormatException)                              {                                  try                                  {                                      t = DateTime.ParseExact(tokens[i + 2]' "yyyy/MM/dd"' null);                                  }                                  catch (FormatException)                                  {                                      try                                      {                                          t = DateTime.ParseExact(tokens[i + 2]' "MM/dd/yyyy"' null);                                      }                                      catch (FormatException)                                      {                                          t = DateTime.ParseExact(tokens[i + 2]' "yyyy-MM-dd"' null);                                      }                                  }                              }                          }                          t= DateTime.SpecifyKind(t' DateTimeKind.Local).ToUniversalTime();                          current = new TimeCriterion                          {                              Which = (WhichTime)Enum.Parse(typeof(WhichTime)' tokens[i]' true)'                              Operator = (ComparisonOperator)EnumUtil.Parse(typeof(ComparisonOperator)' tokens[i + 1])'                              Time = t                          };                          i += 2;                          stateStack.Push(ParseState.CriterionDone);                          break;                          case "length":                      case "size":                          if (tokens.Length <= i + 2)                              throw new ArgumentException(String.Join(" "' tokens' i' tokens.Length - i));                            Int64 sz = 0;                          string v = tokens[i + 2];                          if (v.ToUpper().EndsWith("K"))                              sz = Int64.Parse(v.Substring(0' v.Length - 1)) * 1024;                          else if (v.ToUpper().EndsWith("KB"))                              sz = Int64.Parse(v.Substring(0' v.Length - 2)) * 1024;                          else if (v.ToUpper().EndsWith("M"))                              sz = Int64.Parse(v.Substring(0' v.Length - 1)) * 1024 * 1024;                          else if (v.ToUpper().EndsWith("MB"))                              sz = Int64.Parse(v.Substring(0' v.Length - 2)) * 1024 * 1024;                          else if (v.ToUpper().EndsWith("G"))                              sz = Int64.Parse(v.Substring(0' v.Length - 1)) * 1024 * 1024 * 1024;                          else if (v.ToUpper().EndsWith("GB"))                              sz = Int64.Parse(v.Substring(0' v.Length - 2)) * 1024 * 1024 * 1024;                          else sz = Int64.Parse(tokens[i + 2]);                            current = new SizeCriterion                          {                              Size = sz'                              Operator = (ComparisonOperator)EnumUtil.Parse(typeof(ComparisonOperator)' tokens[i + 1])                          };                          i += 2;                          stateStack.Push(ParseState.CriterionDone);                          break;                        case "filename":                      case "name":                          {                              if (tokens.Length <= i + 2)                                  throw new ArgumentException(String.Join(" "' tokens' i' tokens.Length - i));                                ComparisonOperator c =                                  (ComparisonOperator)EnumUtil.Parse(typeof(ComparisonOperator)' tokens[i + 1]);                                if (c != ComparisonOperator.NotEqualTo && c != ComparisonOperator.EqualTo)                                  throw new ArgumentException(String.Join(" "' tokens' i' tokens.Length - i));                                string m = tokens[i + 2];                                // handle single-quoted filespecs (used to include                              // spaces in filename patterns)                              if (m.StartsWith("'") && m.EndsWith("'"))                              {                                  // trim off leading and trailing single quotes and                                  // revert the control characters to spaces.                                  m = m.Substring(1' m.Length - 2)                                      .Replace("\u0006"' " ");                              }                                // if (m.StartsWith("'"))                              //     m = m.Replace("\u0006"' " ");                                //Fix for Unix -> NormalizeCriteriaExpression replaces all slashes with backslashes                              if (Path.DirectorySeparatorChar == '/')                                  m = m.Replace('\\'' Path.DirectorySeparatorChar);                                current = new NameCriterion                              {                                  MatchingFileSpec = m'                                  Operator = c                              };                              i += 2;                              stateStack.Push(ParseState.CriterionDone);                          }                          break;                        case "attrs":                      case "attributes":                      case "type":                          {                              if (tokens.Length <= i + 2)                                  throw new ArgumentException(String.Join(" "' tokens' i' tokens.Length - i));                                ComparisonOperator c =                                  (ComparisonOperator)EnumUtil.Parse(typeof(ComparisonOperator)' tokens[i + 1]);                                if (c != ComparisonOperator.NotEqualTo && c != ComparisonOperator.EqualTo)                                  throw new ArgumentException(String.Join(" "' tokens' i' tokens.Length - i));                                current = (tok1 == "type")                                  ? (SelectionCriterion) new TypeCriterion                                      {                                          AttributeString = tokens[i + 2]'                                          Operator = c                                      }                                  : (SelectionCriterion) new AttributesCriterion                                      {                                          AttributeString = tokens[i + 2]'                                          Operator = c                                      };                              i += 2;                              stateStack.Push(ParseState.CriterionDone);                          }                          break;                        case "":                          // NOP                          stateStack.Push(ParseState.Whitespace);                          break;                        default:                          throw new ArgumentException("'" + tokens[i] + "'");                  }
Magic Number,Ionic,FileSelector,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\FileSelector.cs,_ParseCriterion,The following statement contains a magic number: switch (tok1)                  {                      case "and":                      case "xor":                      case "or":                          state = stateStack.Peek();                          if (state != ParseState.CriterionDone)                              throw new ArgumentException(String.Join(" "' tokens' i' tokens.Length - i));                            if (tokens.Length <= i + 3)                              throw new ArgumentException(String.Join(" "' tokens' i' tokens.Length - i));                            pendingConjunction = (LogicalConjunction)Enum.Parse(typeof(LogicalConjunction)' tokens[i].ToUpper()' true);                          current = new CompoundCriterion { Left = current' Right = null' Conjunction = pendingConjunction };                          stateStack.Push(state);                          stateStack.Push(ParseState.ConjunctionPending);                          critStack.Push(current);                          break;                        case "(":                          state = stateStack.Peek();                          if (state != ParseState.Start && state != ParseState.ConjunctionPending && state != ParseState.OpenParen)                              throw new ArgumentException(String.Join(" "' tokens' i' tokens.Length - i));                            if (tokens.Length <= i + 4)                              throw new ArgumentException(String.Join(" "' tokens' i' tokens.Length - i));                            stateStack.Push(ParseState.OpenParen);                          break;                        case ")":                          state = stateStack.Pop();                          if (stateStack.Peek() != ParseState.OpenParen)                              throw new ArgumentException(String.Join(" "' tokens' i' tokens.Length - i));                            stateStack.Pop();                          stateStack.Push(ParseState.CriterionDone);                          break;                        case "atime":                      case "ctime":                      case "mtime":                          if (tokens.Length <= i + 2)                              throw new ArgumentException(String.Join(" "' tokens' i' tokens.Length - i));                            DateTime t;                          try                          {                              t = DateTime.ParseExact(tokens[i + 2]' "yyyy-MM-dd-HH:mm:ss"' null);                          }                          catch (FormatException)                          {                              try                              {                                  t = DateTime.ParseExact(tokens[i + 2]' "yyyy/MM/dd-HH:mm:ss"' null);                              }                              catch (FormatException)                              {                                  try                                  {                                      t = DateTime.ParseExact(tokens[i + 2]' "yyyy/MM/dd"' null);                                  }                                  catch (FormatException)                                  {                                      try                                      {                                          t = DateTime.ParseExact(tokens[i + 2]' "MM/dd/yyyy"' null);                                      }                                      catch (FormatException)                                      {                                          t = DateTime.ParseExact(tokens[i + 2]' "yyyy-MM-dd"' null);                                      }                                  }                              }                          }                          t= DateTime.SpecifyKind(t' DateTimeKind.Local).ToUniversalTime();                          current = new TimeCriterion                          {                              Which = (WhichTime)Enum.Parse(typeof(WhichTime)' tokens[i]' true)'                              Operator = (ComparisonOperator)EnumUtil.Parse(typeof(ComparisonOperator)' tokens[i + 1])'                              Time = t                          };                          i += 2;                          stateStack.Push(ParseState.CriterionDone);                          break;                          case "length":                      case "size":                          if (tokens.Length <= i + 2)                              throw new ArgumentException(String.Join(" "' tokens' i' tokens.Length - i));                            Int64 sz = 0;                          string v = tokens[i + 2];                          if (v.ToUpper().EndsWith("K"))                              sz = Int64.Parse(v.Substring(0' v.Length - 1)) * 1024;                          else if (v.ToUpper().EndsWith("KB"))                              sz = Int64.Parse(v.Substring(0' v.Length - 2)) * 1024;                          else if (v.ToUpper().EndsWith("M"))                              sz = Int64.Parse(v.Substring(0' v.Length - 1)) * 1024 * 1024;                          else if (v.ToUpper().EndsWith("MB"))                              sz = Int64.Parse(v.Substring(0' v.Length - 2)) * 1024 * 1024;                          else if (v.ToUpper().EndsWith("G"))                              sz = Int64.Parse(v.Substring(0' v.Length - 1)) * 1024 * 1024 * 1024;                          else if (v.ToUpper().EndsWith("GB"))                              sz = Int64.Parse(v.Substring(0' v.Length - 2)) * 1024 * 1024 * 1024;                          else sz = Int64.Parse(tokens[i + 2]);                            current = new SizeCriterion                          {                              Size = sz'                              Operator = (ComparisonOperator)EnumUtil.Parse(typeof(ComparisonOperator)' tokens[i + 1])                          };                          i += 2;                          stateStack.Push(ParseState.CriterionDone);                          break;                        case "filename":                      case "name":                          {                              if (tokens.Length <= i + 2)                                  throw new ArgumentException(String.Join(" "' tokens' i' tokens.Length - i));                                ComparisonOperator c =                                  (ComparisonOperator)EnumUtil.Parse(typeof(ComparisonOperator)' tokens[i + 1]);                                if (c != ComparisonOperator.NotEqualTo && c != ComparisonOperator.EqualTo)                                  throw new ArgumentException(String.Join(" "' tokens' i' tokens.Length - i));                                string m = tokens[i + 2];                                // handle single-quoted filespecs (used to include                              // spaces in filename patterns)                              if (m.StartsWith("'") && m.EndsWith("'"))                              {                                  // trim off leading and trailing single quotes and                                  // revert the control characters to spaces.                                  m = m.Substring(1' m.Length - 2)                                      .Replace("\u0006"' " ");                              }                                // if (m.StartsWith("'"))                              //     m = m.Replace("\u0006"' " ");                                //Fix for Unix -> NormalizeCriteriaExpression replaces all slashes with backslashes                              if (Path.DirectorySeparatorChar == '/')                                  m = m.Replace('\\'' Path.DirectorySeparatorChar);                                current = new NameCriterion                              {                                  MatchingFileSpec = m'                                  Operator = c                              };                              i += 2;                              stateStack.Push(ParseState.CriterionDone);                          }                          break;                        case "attrs":                      case "attributes":                      case "type":                          {                              if (tokens.Length <= i + 2)                                  throw new ArgumentException(String.Join(" "' tokens' i' tokens.Length - i));                                ComparisonOperator c =                                  (ComparisonOperator)EnumUtil.Parse(typeof(ComparisonOperator)' tokens[i + 1]);                                if (c != ComparisonOperator.NotEqualTo && c != ComparisonOperator.EqualTo)                                  throw new ArgumentException(String.Join(" "' tokens' i' tokens.Length - i));                                current = (tok1 == "type")                                  ? (SelectionCriterion) new TypeCriterion                                      {                                          AttributeString = tokens[i + 2]'                                          Operator = c                                      }                                  : (SelectionCriterion) new AttributesCriterion                                      {                                          AttributeString = tokens[i + 2]'                                          Operator = c                                      };                              i += 2;                              stateStack.Push(ParseState.CriterionDone);                          }                          break;                        case "":                          // NOP                          stateStack.Push(ParseState.Whitespace);                          break;                        default:                          throw new ArgumentException("'" + tokens[i] + "'");                  }
Magic Number,Ionic,FileSelector,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\FileSelector.cs,_ParseCriterion,The following statement contains a magic number: switch (tok1)                  {                      case "and":                      case "xor":                      case "or":                          state = stateStack.Peek();                          if (state != ParseState.CriterionDone)                              throw new ArgumentException(String.Join(" "' tokens' i' tokens.Length - i));                            if (tokens.Length <= i + 3)                              throw new ArgumentException(String.Join(" "' tokens' i' tokens.Length - i));                            pendingConjunction = (LogicalConjunction)Enum.Parse(typeof(LogicalConjunction)' tokens[i].ToUpper()' true);                          current = new CompoundCriterion { Left = current' Right = null' Conjunction = pendingConjunction };                          stateStack.Push(state);                          stateStack.Push(ParseState.ConjunctionPending);                          critStack.Push(current);                          break;                        case "(":                          state = stateStack.Peek();                          if (state != ParseState.Start && state != ParseState.ConjunctionPending && state != ParseState.OpenParen)                              throw new ArgumentException(String.Join(" "' tokens' i' tokens.Length - i));                            if (tokens.Length <= i + 4)                              throw new ArgumentException(String.Join(" "' tokens' i' tokens.Length - i));                            stateStack.Push(ParseState.OpenParen);                          break;                        case ")":                          state = stateStack.Pop();                          if (stateStack.Peek() != ParseState.OpenParen)                              throw new ArgumentException(String.Join(" "' tokens' i' tokens.Length - i));                            stateStack.Pop();                          stateStack.Push(ParseState.CriterionDone);                          break;                        case "atime":                      case "ctime":                      case "mtime":                          if (tokens.Length <= i + 2)                              throw new ArgumentException(String.Join(" "' tokens' i' tokens.Length - i));                            DateTime t;                          try                          {                              t = DateTime.ParseExact(tokens[i + 2]' "yyyy-MM-dd-HH:mm:ss"' null);                          }                          catch (FormatException)                          {                              try                              {                                  t = DateTime.ParseExact(tokens[i + 2]' "yyyy/MM/dd-HH:mm:ss"' null);                              }                              catch (FormatException)                              {                                  try                                  {                                      t = DateTime.ParseExact(tokens[i + 2]' "yyyy/MM/dd"' null);                                  }                                  catch (FormatException)                                  {                                      try                                      {                                          t = DateTime.ParseExact(tokens[i + 2]' "MM/dd/yyyy"' null);                                      }                                      catch (FormatException)                                      {                                          t = DateTime.ParseExact(tokens[i + 2]' "yyyy-MM-dd"' null);                                      }                                  }                              }                          }                          t= DateTime.SpecifyKind(t' DateTimeKind.Local).ToUniversalTime();                          current = new TimeCriterion                          {                              Which = (WhichTime)Enum.Parse(typeof(WhichTime)' tokens[i]' true)'                              Operator = (ComparisonOperator)EnumUtil.Parse(typeof(ComparisonOperator)' tokens[i + 1])'                              Time = t                          };                          i += 2;                          stateStack.Push(ParseState.CriterionDone);                          break;                          case "length":                      case "size":                          if (tokens.Length <= i + 2)                              throw new ArgumentException(String.Join(" "' tokens' i' tokens.Length - i));                            Int64 sz = 0;                          string v = tokens[i + 2];                          if (v.ToUpper().EndsWith("K"))                              sz = Int64.Parse(v.Substring(0' v.Length - 1)) * 1024;                          else if (v.ToUpper().EndsWith("KB"))                              sz = Int64.Parse(v.Substring(0' v.Length - 2)) * 1024;                          else if (v.ToUpper().EndsWith("M"))                              sz = Int64.Parse(v.Substring(0' v.Length - 1)) * 1024 * 1024;                          else if (v.ToUpper().EndsWith("MB"))                              sz = Int64.Parse(v.Substring(0' v.Length - 2)) * 1024 * 1024;                          else if (v.ToUpper().EndsWith("G"))                              sz = Int64.Parse(v.Substring(0' v.Length - 1)) * 1024 * 1024 * 1024;                          else if (v.ToUpper().EndsWith("GB"))                              sz = Int64.Parse(v.Substring(0' v.Length - 2)) * 1024 * 1024 * 1024;                          else sz = Int64.Parse(tokens[i + 2]);                            current = new SizeCriterion                          {                              Size = sz'                              Operator = (ComparisonOperator)EnumUtil.Parse(typeof(ComparisonOperator)' tokens[i + 1])                          };                          i += 2;                          stateStack.Push(ParseState.CriterionDone);                          break;                        case "filename":                      case "name":                          {                              if (tokens.Length <= i + 2)                                  throw new ArgumentException(String.Join(" "' tokens' i' tokens.Length - i));                                ComparisonOperator c =                                  (ComparisonOperator)EnumUtil.Parse(typeof(ComparisonOperator)' tokens[i + 1]);                                if (c != ComparisonOperator.NotEqualTo && c != ComparisonOperator.EqualTo)                                  throw new ArgumentException(String.Join(" "' tokens' i' tokens.Length - i));                                string m = tokens[i + 2];                                // handle single-quoted filespecs (used to include                              // spaces in filename patterns)                              if (m.StartsWith("'") && m.EndsWith("'"))                              {                                  // trim off leading and trailing single quotes and                                  // revert the control characters to spaces.                                  m = m.Substring(1' m.Length - 2)                                      .Replace("\u0006"' " ");                              }                                // if (m.StartsWith("'"))                              //     m = m.Replace("\u0006"' " ");                                //Fix for Unix -> NormalizeCriteriaExpression replaces all slashes with backslashes                              if (Path.DirectorySeparatorChar == '/')                                  m = m.Replace('\\'' Path.DirectorySeparatorChar);                                current = new NameCriterion                              {                                  MatchingFileSpec = m'                                  Operator = c                              };                              i += 2;                              stateStack.Push(ParseState.CriterionDone);                          }                          break;                        case "attrs":                      case "attributes":                      case "type":                          {                              if (tokens.Length <= i + 2)                                  throw new ArgumentException(String.Join(" "' tokens' i' tokens.Length - i));                                ComparisonOperator c =                                  (ComparisonOperator)EnumUtil.Parse(typeof(ComparisonOperator)' tokens[i + 1]);                                if (c != ComparisonOperator.NotEqualTo && c != ComparisonOperator.EqualTo)                                  throw new ArgumentException(String.Join(" "' tokens' i' tokens.Length - i));                                current = (tok1 == "type")                                  ? (SelectionCriterion) new TypeCriterion                                      {                                          AttributeString = tokens[i + 2]'                                          Operator = c                                      }                                  : (SelectionCriterion) new AttributesCriterion                                      {                                          AttributeString = tokens[i + 2]'                                          Operator = c                                      };                              i += 2;                              stateStack.Push(ParseState.CriterionDone);                          }                          break;                        case "":                          // NOP                          stateStack.Push(ParseState.Whitespace);                          break;                        default:                          throw new ArgumentException("'" + tokens[i] + "'");                  }
Magic Number,Ionic,FileSelector,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\FileSelector.cs,_ParseCriterion,The following statement contains a magic number: switch (tok1)                  {                      case "and":                      case "xor":                      case "or":                          state = stateStack.Peek();                          if (state != ParseState.CriterionDone)                              throw new ArgumentException(String.Join(" "' tokens' i' tokens.Length - i));                            if (tokens.Length <= i + 3)                              throw new ArgumentException(String.Join(" "' tokens' i' tokens.Length - i));                            pendingConjunction = (LogicalConjunction)Enum.Parse(typeof(LogicalConjunction)' tokens[i].ToUpper()' true);                          current = new CompoundCriterion { Left = current' Right = null' Conjunction = pendingConjunction };                          stateStack.Push(state);                          stateStack.Push(ParseState.ConjunctionPending);                          critStack.Push(current);                          break;                        case "(":                          state = stateStack.Peek();                          if (state != ParseState.Start && state != ParseState.ConjunctionPending && state != ParseState.OpenParen)                              throw new ArgumentException(String.Join(" "' tokens' i' tokens.Length - i));                            if (tokens.Length <= i + 4)                              throw new ArgumentException(String.Join(" "' tokens' i' tokens.Length - i));                            stateStack.Push(ParseState.OpenParen);                          break;                        case ")":                          state = stateStack.Pop();                          if (stateStack.Peek() != ParseState.OpenParen)                              throw new ArgumentException(String.Join(" "' tokens' i' tokens.Length - i));                            stateStack.Pop();                          stateStack.Push(ParseState.CriterionDone);                          break;                        case "atime":                      case "ctime":                      case "mtime":                          if (tokens.Length <= i + 2)                              throw new ArgumentException(String.Join(" "' tokens' i' tokens.Length - i));                            DateTime t;                          try                          {                              t = DateTime.ParseExact(tokens[i + 2]' "yyyy-MM-dd-HH:mm:ss"' null);                          }                          catch (FormatException)                          {                              try                              {                                  t = DateTime.ParseExact(tokens[i + 2]' "yyyy/MM/dd-HH:mm:ss"' null);                              }                              catch (FormatException)                              {                                  try                                  {                                      t = DateTime.ParseExact(tokens[i + 2]' "yyyy/MM/dd"' null);                                  }                                  catch (FormatException)                                  {                                      try                                      {                                          t = DateTime.ParseExact(tokens[i + 2]' "MM/dd/yyyy"' null);                                      }                                      catch (FormatException)                                      {                                          t = DateTime.ParseExact(tokens[i + 2]' "yyyy-MM-dd"' null);                                      }                                  }                              }                          }                          t= DateTime.SpecifyKind(t' DateTimeKind.Local).ToUniversalTime();                          current = new TimeCriterion                          {                              Which = (WhichTime)Enum.Parse(typeof(WhichTime)' tokens[i]' true)'                              Operator = (ComparisonOperator)EnumUtil.Parse(typeof(ComparisonOperator)' tokens[i + 1])'                              Time = t                          };                          i += 2;                          stateStack.Push(ParseState.CriterionDone);                          break;                          case "length":                      case "size":                          if (tokens.Length <= i + 2)                              throw new ArgumentException(String.Join(" "' tokens' i' tokens.Length - i));                            Int64 sz = 0;                          string v = tokens[i + 2];                          if (v.ToUpper().EndsWith("K"))                              sz = Int64.Parse(v.Substring(0' v.Length - 1)) * 1024;                          else if (v.ToUpper().EndsWith("KB"))                              sz = Int64.Parse(v.Substring(0' v.Length - 2)) * 1024;                          else if (v.ToUpper().EndsWith("M"))                              sz = Int64.Parse(v.Substring(0' v.Length - 1)) * 1024 * 1024;                          else if (v.ToUpper().EndsWith("MB"))                              sz = Int64.Parse(v.Substring(0' v.Length - 2)) * 1024 * 1024;                          else if (v.ToUpper().EndsWith("G"))                              sz = Int64.Parse(v.Substring(0' v.Length - 1)) * 1024 * 1024 * 1024;                          else if (v.ToUpper().EndsWith("GB"))                              sz = Int64.Parse(v.Substring(0' v.Length - 2)) * 1024 * 1024 * 1024;                          else sz = Int64.Parse(tokens[i + 2]);                            current = new SizeCriterion                          {                              Size = sz'                              Operator = (ComparisonOperator)EnumUtil.Parse(typeof(ComparisonOperator)' tokens[i + 1])                          };                          i += 2;                          stateStack.Push(ParseState.CriterionDone);                          break;                        case "filename":                      case "name":                          {                              if (tokens.Length <= i + 2)                                  throw new ArgumentException(String.Join(" "' tokens' i' tokens.Length - i));                                ComparisonOperator c =                                  (ComparisonOperator)EnumUtil.Parse(typeof(ComparisonOperator)' tokens[i + 1]);                                if (c != ComparisonOperator.NotEqualTo && c != ComparisonOperator.EqualTo)                                  throw new ArgumentException(String.Join(" "' tokens' i' tokens.Length - i));                                string m = tokens[i + 2];                                // handle single-quoted filespecs (used to include                              // spaces in filename patterns)                              if (m.StartsWith("'") && m.EndsWith("'"))                              {                                  // trim off leading and trailing single quotes and                                  // revert the control characters to spaces.                                  m = m.Substring(1' m.Length - 2)                                      .Replace("\u0006"' " ");                              }                                // if (m.StartsWith("'"))                              //     m = m.Replace("\u0006"' " ");                                //Fix for Unix -> NormalizeCriteriaExpression replaces all slashes with backslashes                              if (Path.DirectorySeparatorChar == '/')                                  m = m.Replace('\\'' Path.DirectorySeparatorChar);                                current = new NameCriterion                              {                                  MatchingFileSpec = m'                                  Operator = c                              };                              i += 2;                              stateStack.Push(ParseState.CriterionDone);                          }                          break;                        case "attrs":                      case "attributes":                      case "type":                          {                              if (tokens.Length <= i + 2)                                  throw new ArgumentException(String.Join(" "' tokens' i' tokens.Length - i));                                ComparisonOperator c =                                  (ComparisonOperator)EnumUtil.Parse(typeof(ComparisonOperator)' tokens[i + 1]);                                if (c != ComparisonOperator.NotEqualTo && c != ComparisonOperator.EqualTo)                                  throw new ArgumentException(String.Join(" "' tokens' i' tokens.Length - i));                                current = (tok1 == "type")                                  ? (SelectionCriterion) new TypeCriterion                                      {                                          AttributeString = tokens[i + 2]'                                          Operator = c                                      }                                  : (SelectionCriterion) new AttributesCriterion                                      {                                          AttributeString = tokens[i + 2]'                                          Operator = c                                      };                              i += 2;                              stateStack.Push(ParseState.CriterionDone);                          }                          break;                        case "":                          // NOP                          stateStack.Push(ParseState.Whitespace);                          break;                        default:                          throw new ArgumentException("'" + tokens[i] + "'");                  }
Magic Number,Ionic,FileSelector,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\FileSelector.cs,_ParseCriterion,The following statement contains a magic number: switch (tok1)                  {                      case "and":                      case "xor":                      case "or":                          state = stateStack.Peek();                          if (state != ParseState.CriterionDone)                              throw new ArgumentException(String.Join(" "' tokens' i' tokens.Length - i));                            if (tokens.Length <= i + 3)                              throw new ArgumentException(String.Join(" "' tokens' i' tokens.Length - i));                            pendingConjunction = (LogicalConjunction)Enum.Parse(typeof(LogicalConjunction)' tokens[i].ToUpper()' true);                          current = new CompoundCriterion { Left = current' Right = null' Conjunction = pendingConjunction };                          stateStack.Push(state);                          stateStack.Push(ParseState.ConjunctionPending);                          critStack.Push(current);                          break;                        case "(":                          state = stateStack.Peek();                          if (state != ParseState.Start && state != ParseState.ConjunctionPending && state != ParseState.OpenParen)                              throw new ArgumentException(String.Join(" "' tokens' i' tokens.Length - i));                            if (tokens.Length <= i + 4)                              throw new ArgumentException(String.Join(" "' tokens' i' tokens.Length - i));                            stateStack.Push(ParseState.OpenParen);                          break;                        case ")":                          state = stateStack.Pop();                          if (stateStack.Peek() != ParseState.OpenParen)                              throw new ArgumentException(String.Join(" "' tokens' i' tokens.Length - i));                            stateStack.Pop();                          stateStack.Push(ParseState.CriterionDone);                          break;                        case "atime":                      case "ctime":                      case "mtime":                          if (tokens.Length <= i + 2)                              throw new ArgumentException(String.Join(" "' tokens' i' tokens.Length - i));                            DateTime t;                          try                          {                              t = DateTime.ParseExact(tokens[i + 2]' "yyyy-MM-dd-HH:mm:ss"' null);                          }                          catch (FormatException)                          {                              try                              {                                  t = DateTime.ParseExact(tokens[i + 2]' "yyyy/MM/dd-HH:mm:ss"' null);                              }                              catch (FormatException)                              {                                  try                                  {                                      t = DateTime.ParseExact(tokens[i + 2]' "yyyy/MM/dd"' null);                                  }                                  catch (FormatException)                                  {                                      try                                      {                                          t = DateTime.ParseExact(tokens[i + 2]' "MM/dd/yyyy"' null);                                      }                                      catch (FormatException)                                      {                                          t = DateTime.ParseExact(tokens[i + 2]' "yyyy-MM-dd"' null);                                      }                                  }                              }                          }                          t= DateTime.SpecifyKind(t' DateTimeKind.Local).ToUniversalTime();                          current = new TimeCriterion                          {                              Which = (WhichTime)Enum.Parse(typeof(WhichTime)' tokens[i]' true)'                              Operator = (ComparisonOperator)EnumUtil.Parse(typeof(ComparisonOperator)' tokens[i + 1])'                              Time = t                          };                          i += 2;                          stateStack.Push(ParseState.CriterionDone);                          break;                          case "length":                      case "size":                          if (tokens.Length <= i + 2)                              throw new ArgumentException(String.Join(" "' tokens' i' tokens.Length - i));                            Int64 sz = 0;                          string v = tokens[i + 2];                          if (v.ToUpper().EndsWith("K"))                              sz = Int64.Parse(v.Substring(0' v.Length - 1)) * 1024;                          else if (v.ToUpper().EndsWith("KB"))                              sz = Int64.Parse(v.Substring(0' v.Length - 2)) * 1024;                          else if (v.ToUpper().EndsWith("M"))                              sz = Int64.Parse(v.Substring(0' v.Length - 1)) * 1024 * 1024;                          else if (v.ToUpper().EndsWith("MB"))                              sz = Int64.Parse(v.Substring(0' v.Length - 2)) * 1024 * 1024;                          else if (v.ToUpper().EndsWith("G"))                              sz = Int64.Parse(v.Substring(0' v.Length - 1)) * 1024 * 1024 * 1024;                          else if (v.ToUpper().EndsWith("GB"))                              sz = Int64.Parse(v.Substring(0' v.Length - 2)) * 1024 * 1024 * 1024;                          else sz = Int64.Parse(tokens[i + 2]);                            current = new SizeCriterion                          {                              Size = sz'                              Operator = (ComparisonOperator)EnumUtil.Parse(typeof(ComparisonOperator)' tokens[i + 1])                          };                          i += 2;                          stateStack.Push(ParseState.CriterionDone);                          break;                        case "filename":                      case "name":                          {                              if (tokens.Length <= i + 2)                                  throw new ArgumentException(String.Join(" "' tokens' i' tokens.Length - i));                                ComparisonOperator c =                                  (ComparisonOperator)EnumUtil.Parse(typeof(ComparisonOperator)' tokens[i + 1]);                                if (c != ComparisonOperator.NotEqualTo && c != ComparisonOperator.EqualTo)                                  throw new ArgumentException(String.Join(" "' tokens' i' tokens.Length - i));                                string m = tokens[i + 2];                                // handle single-quoted filespecs (used to include                              // spaces in filename patterns)                              if (m.StartsWith("'") && m.EndsWith("'"))                              {                                  // trim off leading and trailing single quotes and                                  // revert the control characters to spaces.                                  m = m.Substring(1' m.Length - 2)                                      .Replace("\u0006"' " ");                              }                                // if (m.StartsWith("'"))                              //     m = m.Replace("\u0006"' " ");                                //Fix for Unix -> NormalizeCriteriaExpression replaces all slashes with backslashes                              if (Path.DirectorySeparatorChar == '/')                                  m = m.Replace('\\'' Path.DirectorySeparatorChar);                                current = new NameCriterion                              {                                  MatchingFileSpec = m'                                  Operator = c                              };                              i += 2;                              stateStack.Push(ParseState.CriterionDone);                          }                          break;                        case "attrs":                      case "attributes":                      case "type":                          {                              if (tokens.Length <= i + 2)                                  throw new ArgumentException(String.Join(" "' tokens' i' tokens.Length - i));                                ComparisonOperator c =                                  (ComparisonOperator)EnumUtil.Parse(typeof(ComparisonOperator)' tokens[i + 1]);                                if (c != ComparisonOperator.NotEqualTo && c != ComparisonOperator.EqualTo)                                  throw new ArgumentException(String.Join(" "' tokens' i' tokens.Length - i));                                current = (tok1 == "type")                                  ? (SelectionCriterion) new TypeCriterion                                      {                                          AttributeString = tokens[i + 2]'                                          Operator = c                                      }                                  : (SelectionCriterion) new AttributesCriterion                                      {                                          AttributeString = tokens[i + 2]'                                          Operator = c                                      };                              i += 2;                              stateStack.Push(ParseState.CriterionDone);                          }                          break;                        case "":                          // NOP                          stateStack.Push(ParseState.Whitespace);                          break;                        default:                          throw new ArgumentException("'" + tokens[i] + "'");                  }
Magic Number,Ionic,FileSelector,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\FileSelector.cs,_ParseCriterion,The following statement contains a magic number: switch (tok1)                  {                      case "and":                      case "xor":                      case "or":                          state = stateStack.Peek();                          if (state != ParseState.CriterionDone)                              throw new ArgumentException(String.Join(" "' tokens' i' tokens.Length - i));                            if (tokens.Length <= i + 3)                              throw new ArgumentException(String.Join(" "' tokens' i' tokens.Length - i));                            pendingConjunction = (LogicalConjunction)Enum.Parse(typeof(LogicalConjunction)' tokens[i].ToUpper()' true);                          current = new CompoundCriterion { Left = current' Right = null' Conjunction = pendingConjunction };                          stateStack.Push(state);                          stateStack.Push(ParseState.ConjunctionPending);                          critStack.Push(current);                          break;                        case "(":                          state = stateStack.Peek();                          if (state != ParseState.Start && state != ParseState.ConjunctionPending && state != ParseState.OpenParen)                              throw new ArgumentException(String.Join(" "' tokens' i' tokens.Length - i));                            if (tokens.Length <= i + 4)                              throw new ArgumentException(String.Join(" "' tokens' i' tokens.Length - i));                            stateStack.Push(ParseState.OpenParen);                          break;                        case ")":                          state = stateStack.Pop();                          if (stateStack.Peek() != ParseState.OpenParen)                              throw new ArgumentException(String.Join(" "' tokens' i' tokens.Length - i));                            stateStack.Pop();                          stateStack.Push(ParseState.CriterionDone);                          break;                        case "atime":                      case "ctime":                      case "mtime":                          if (tokens.Length <= i + 2)                              throw new ArgumentException(String.Join(" "' tokens' i' tokens.Length - i));                            DateTime t;                          try                          {                              t = DateTime.ParseExact(tokens[i + 2]' "yyyy-MM-dd-HH:mm:ss"' null);                          }                          catch (FormatException)                          {                              try                              {                                  t = DateTime.ParseExact(tokens[i + 2]' "yyyy/MM/dd-HH:mm:ss"' null);                              }                              catch (FormatException)                              {                                  try                                  {                                      t = DateTime.ParseExact(tokens[i + 2]' "yyyy/MM/dd"' null);                                  }                                  catch (FormatException)                                  {                                      try                                      {                                          t = DateTime.ParseExact(tokens[i + 2]' "MM/dd/yyyy"' null);                                      }                                      catch (FormatException)                                      {                                          t = DateTime.ParseExact(tokens[i + 2]' "yyyy-MM-dd"' null);                                      }                                  }                              }                          }                          t= DateTime.SpecifyKind(t' DateTimeKind.Local).ToUniversalTime();                          current = new TimeCriterion                          {                              Which = (WhichTime)Enum.Parse(typeof(WhichTime)' tokens[i]' true)'                              Operator = (ComparisonOperator)EnumUtil.Parse(typeof(ComparisonOperator)' tokens[i + 1])'                              Time = t                          };                          i += 2;                          stateStack.Push(ParseState.CriterionDone);                          break;                          case "length":                      case "size":                          if (tokens.Length <= i + 2)                              throw new ArgumentException(String.Join(" "' tokens' i' tokens.Length - i));                            Int64 sz = 0;                          string v = tokens[i + 2];                          if (v.ToUpper().EndsWith("K"))                              sz = Int64.Parse(v.Substring(0' v.Length - 1)) * 1024;                          else if (v.ToUpper().EndsWith("KB"))                              sz = Int64.Parse(v.Substring(0' v.Length - 2)) * 1024;                          else if (v.ToUpper().EndsWith("M"))                              sz = Int64.Parse(v.Substring(0' v.Length - 1)) * 1024 * 1024;                          else if (v.ToUpper().EndsWith("MB"))                              sz = Int64.Parse(v.Substring(0' v.Length - 2)) * 1024 * 1024;                          else if (v.ToUpper().EndsWith("G"))                              sz = Int64.Parse(v.Substring(0' v.Length - 1)) * 1024 * 1024 * 1024;                          else if (v.ToUpper().EndsWith("GB"))                              sz = Int64.Parse(v.Substring(0' v.Length - 2)) * 1024 * 1024 * 1024;                          else sz = Int64.Parse(tokens[i + 2]);                            current = new SizeCriterion                          {                              Size = sz'                              Operator = (ComparisonOperator)EnumUtil.Parse(typeof(ComparisonOperator)' tokens[i + 1])                          };                          i += 2;                          stateStack.Push(ParseState.CriterionDone);                          break;                        case "filename":                      case "name":                          {                              if (tokens.Length <= i + 2)                                  throw new ArgumentException(String.Join(" "' tokens' i' tokens.Length - i));                                ComparisonOperator c =                                  (ComparisonOperator)EnumUtil.Parse(typeof(ComparisonOperator)' tokens[i + 1]);                                if (c != ComparisonOperator.NotEqualTo && c != ComparisonOperator.EqualTo)                                  throw new ArgumentException(String.Join(" "' tokens' i' tokens.Length - i));                                string m = tokens[i + 2];                                // handle single-quoted filespecs (used to include                              // spaces in filename patterns)                              if (m.StartsWith("'") && m.EndsWith("'"))                              {                                  // trim off leading and trailing single quotes and                                  // revert the control characters to spaces.                                  m = m.Substring(1' m.Length - 2)                                      .Replace("\u0006"' " ");                              }                                // if (m.StartsWith("'"))                              //     m = m.Replace("\u0006"' " ");                                //Fix for Unix -> NormalizeCriteriaExpression replaces all slashes with backslashes                              if (Path.DirectorySeparatorChar == '/')                                  m = m.Replace('\\'' Path.DirectorySeparatorChar);                                current = new NameCriterion                              {                                  MatchingFileSpec = m'                                  Operator = c                              };                              i += 2;                              stateStack.Push(ParseState.CriterionDone);                          }                          break;                        case "attrs":                      case "attributes":                      case "type":                          {                              if (tokens.Length <= i + 2)                                  throw new ArgumentException(String.Join(" "' tokens' i' tokens.Length - i));                                ComparisonOperator c =                                  (ComparisonOperator)EnumUtil.Parse(typeof(ComparisonOperator)' tokens[i + 1]);                                if (c != ComparisonOperator.NotEqualTo && c != ComparisonOperator.EqualTo)                                  throw new ArgumentException(String.Join(" "' tokens' i' tokens.Length - i));                                current = (tok1 == "type")                                  ? (SelectionCriterion) new TypeCriterion                                      {                                          AttributeString = tokens[i + 2]'                                          Operator = c                                      }                                  : (SelectionCriterion) new AttributesCriterion                                      {                                          AttributeString = tokens[i + 2]'                                          Operator = c                                      };                              i += 2;                              stateStack.Push(ParseState.CriterionDone);                          }                          break;                        case "":                          // NOP                          stateStack.Push(ParseState.Whitespace);                          break;                        default:                          throw new ArgumentException("'" + tokens[i] + "'");                  }
Magic Number,Ionic,FileSelector,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\FileSelector.cs,_ParseCriterion,The following statement contains a magic number: switch (tok1)                  {                      case "and":                      case "xor":                      case "or":                          state = stateStack.Peek();                          if (state != ParseState.CriterionDone)                              throw new ArgumentException(String.Join(" "' tokens' i' tokens.Length - i));                            if (tokens.Length <= i + 3)                              throw new ArgumentException(String.Join(" "' tokens' i' tokens.Length - i));                            pendingConjunction = (LogicalConjunction)Enum.Parse(typeof(LogicalConjunction)' tokens[i].ToUpper()' true);                          current = new CompoundCriterion { Left = current' Right = null' Conjunction = pendingConjunction };                          stateStack.Push(state);                          stateStack.Push(ParseState.ConjunctionPending);                          critStack.Push(current);                          break;                        case "(":                          state = stateStack.Peek();                          if (state != ParseState.Start && state != ParseState.ConjunctionPending && state != ParseState.OpenParen)                              throw new ArgumentException(String.Join(" "' tokens' i' tokens.Length - i));                            if (tokens.Length <= i + 4)                              throw new ArgumentException(String.Join(" "' tokens' i' tokens.Length - i));                            stateStack.Push(ParseState.OpenParen);                          break;                        case ")":                          state = stateStack.Pop();                          if (stateStack.Peek() != ParseState.OpenParen)                              throw new ArgumentException(String.Join(" "' tokens' i' tokens.Length - i));                            stateStack.Pop();                          stateStack.Push(ParseState.CriterionDone);                          break;                        case "atime":                      case "ctime":                      case "mtime":                          if (tokens.Length <= i + 2)                              throw new ArgumentException(String.Join(" "' tokens' i' tokens.Length - i));                            DateTime t;                          try                          {                              t = DateTime.ParseExact(tokens[i + 2]' "yyyy-MM-dd-HH:mm:ss"' null);                          }                          catch (FormatException)                          {                              try                              {                                  t = DateTime.ParseExact(tokens[i + 2]' "yyyy/MM/dd-HH:mm:ss"' null);                              }                              catch (FormatException)                              {                                  try                                  {                                      t = DateTime.ParseExact(tokens[i + 2]' "yyyy/MM/dd"' null);                                  }                                  catch (FormatException)                                  {                                      try                                      {                                          t = DateTime.ParseExact(tokens[i + 2]' "MM/dd/yyyy"' null);                                      }                                      catch (FormatException)                                      {                                          t = DateTime.ParseExact(tokens[i + 2]' "yyyy-MM-dd"' null);                                      }                                  }                              }                          }                          t= DateTime.SpecifyKind(t' DateTimeKind.Local).ToUniversalTime();                          current = new TimeCriterion                          {                              Which = (WhichTime)Enum.Parse(typeof(WhichTime)' tokens[i]' true)'                              Operator = (ComparisonOperator)EnumUtil.Parse(typeof(ComparisonOperator)' tokens[i + 1])'                              Time = t                          };                          i += 2;                          stateStack.Push(ParseState.CriterionDone);                          break;                          case "length":                      case "size":                          if (tokens.Length <= i + 2)                              throw new ArgumentException(String.Join(" "' tokens' i' tokens.Length - i));                            Int64 sz = 0;                          string v = tokens[i + 2];                          if (v.ToUpper().EndsWith("K"))                              sz = Int64.Parse(v.Substring(0' v.Length - 1)) * 1024;                          else if (v.ToUpper().EndsWith("KB"))                              sz = Int64.Parse(v.Substring(0' v.Length - 2)) * 1024;                          else if (v.ToUpper().EndsWith("M"))                              sz = Int64.Parse(v.Substring(0' v.Length - 1)) * 1024 * 1024;                          else if (v.ToUpper().EndsWith("MB"))                              sz = Int64.Parse(v.Substring(0' v.Length - 2)) * 1024 * 1024;                          else if (v.ToUpper().EndsWith("G"))                              sz = Int64.Parse(v.Substring(0' v.Length - 1)) * 1024 * 1024 * 1024;                          else if (v.ToUpper().EndsWith("GB"))                              sz = Int64.Parse(v.Substring(0' v.Length - 2)) * 1024 * 1024 * 1024;                          else sz = Int64.Parse(tokens[i + 2]);                            current = new SizeCriterion                          {                              Size = sz'                              Operator = (ComparisonOperator)EnumUtil.Parse(typeof(ComparisonOperator)' tokens[i + 1])                          };                          i += 2;                          stateStack.Push(ParseState.CriterionDone);                          break;                        case "filename":                      case "name":                          {                              if (tokens.Length <= i + 2)                                  throw new ArgumentException(String.Join(" "' tokens' i' tokens.Length - i));                                ComparisonOperator c =                                  (ComparisonOperator)EnumUtil.Parse(typeof(ComparisonOperator)' tokens[i + 1]);                                if (c != ComparisonOperator.NotEqualTo && c != ComparisonOperator.EqualTo)                                  throw new ArgumentException(String.Join(" "' tokens' i' tokens.Length - i));                                string m = tokens[i + 2];                                // handle single-quoted filespecs (used to include                              // spaces in filename patterns)                              if (m.StartsWith("'") && m.EndsWith("'"))                              {                                  // trim off leading and trailing single quotes and                                  // revert the control characters to spaces.                                  m = m.Substring(1' m.Length - 2)                                      .Replace("\u0006"' " ");                              }                                // if (m.StartsWith("'"))                              //     m = m.Replace("\u0006"' " ");                                //Fix for Unix -> NormalizeCriteriaExpression replaces all slashes with backslashes                              if (Path.DirectorySeparatorChar == '/')                                  m = m.Replace('\\'' Path.DirectorySeparatorChar);                                current = new NameCriterion                              {                                  MatchingFileSpec = m'                                  Operator = c                              };                              i += 2;                              stateStack.Push(ParseState.CriterionDone);                          }                          break;                        case "attrs":                      case "attributes":                      case "type":                          {                              if (tokens.Length <= i + 2)                                  throw new ArgumentException(String.Join(" "' tokens' i' tokens.Length - i));                                ComparisonOperator c =                                  (ComparisonOperator)EnumUtil.Parse(typeof(ComparisonOperator)' tokens[i + 1]);                                if (c != ComparisonOperator.NotEqualTo && c != ComparisonOperator.EqualTo)                                  throw new ArgumentException(String.Join(" "' tokens' i' tokens.Length - i));                                current = (tok1 == "type")                                  ? (SelectionCriterion) new TypeCriterion                                      {                                          AttributeString = tokens[i + 2]'                                          Operator = c                                      }                                  : (SelectionCriterion) new AttributesCriterion                                      {                                          AttributeString = tokens[i + 2]'                                          Operator = c                                      };                              i += 2;                              stateStack.Push(ParseState.CriterionDone);                          }                          break;                        case "":                          // NOP                          stateStack.Push(ParseState.Whitespace);                          break;                        default:                          throw new ArgumentException("'" + tokens[i] + "'");                  }
Magic Number,Ionic,FileSelector,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\FileSelector.cs,_ParseCriterion,The following statement contains a magic number: switch (tok1)                  {                      case "and":                      case "xor":                      case "or":                          state = stateStack.Peek();                          if (state != ParseState.CriterionDone)                              throw new ArgumentException(String.Join(" "' tokens' i' tokens.Length - i));                            if (tokens.Length <= i + 3)                              throw new ArgumentException(String.Join(" "' tokens' i' tokens.Length - i));                            pendingConjunction = (LogicalConjunction)Enum.Parse(typeof(LogicalConjunction)' tokens[i].ToUpper()' true);                          current = new CompoundCriterion { Left = current' Right = null' Conjunction = pendingConjunction };                          stateStack.Push(state);                          stateStack.Push(ParseState.ConjunctionPending);                          critStack.Push(current);                          break;                        case "(":                          state = stateStack.Peek();                          if (state != ParseState.Start && state != ParseState.ConjunctionPending && state != ParseState.OpenParen)                              throw new ArgumentException(String.Join(" "' tokens' i' tokens.Length - i));                            if (tokens.Length <= i + 4)                              throw new ArgumentException(String.Join(" "' tokens' i' tokens.Length - i));                            stateStack.Push(ParseState.OpenParen);                          break;                        case ")":                          state = stateStack.Pop();                          if (stateStack.Peek() != ParseState.OpenParen)                              throw new ArgumentException(String.Join(" "' tokens' i' tokens.Length - i));                            stateStack.Pop();                          stateStack.Push(ParseState.CriterionDone);                          break;                        case "atime":                      case "ctime":                      case "mtime":                          if (tokens.Length <= i + 2)                              throw new ArgumentException(String.Join(" "' tokens' i' tokens.Length - i));                            DateTime t;                          try                          {                              t = DateTime.ParseExact(tokens[i + 2]' "yyyy-MM-dd-HH:mm:ss"' null);                          }                          catch (FormatException)                          {                              try                              {                                  t = DateTime.ParseExact(tokens[i + 2]' "yyyy/MM/dd-HH:mm:ss"' null);                              }                              catch (FormatException)                              {                                  try                                  {                                      t = DateTime.ParseExact(tokens[i + 2]' "yyyy/MM/dd"' null);                                  }                                  catch (FormatException)                                  {                                      try                                      {                                          t = DateTime.ParseExact(tokens[i + 2]' "MM/dd/yyyy"' null);                                      }                                      catch (FormatException)                                      {                                          t = DateTime.ParseExact(tokens[i + 2]' "yyyy-MM-dd"' null);                                      }                                  }                              }                          }                          t= DateTime.SpecifyKind(t' DateTimeKind.Local).ToUniversalTime();                          current = new TimeCriterion                          {                              Which = (WhichTime)Enum.Parse(typeof(WhichTime)' tokens[i]' true)'                              Operator = (ComparisonOperator)EnumUtil.Parse(typeof(ComparisonOperator)' tokens[i + 1])'                              Time = t                          };                          i += 2;                          stateStack.Push(ParseState.CriterionDone);                          break;                          case "length":                      case "size":                          if (tokens.Length <= i + 2)                              throw new ArgumentException(String.Join(" "' tokens' i' tokens.Length - i));                            Int64 sz = 0;                          string v = tokens[i + 2];                          if (v.ToUpper().EndsWith("K"))                              sz = Int64.Parse(v.Substring(0' v.Length - 1)) * 1024;                          else if (v.ToUpper().EndsWith("KB"))                              sz = Int64.Parse(v.Substring(0' v.Length - 2)) * 1024;                          else if (v.ToUpper().EndsWith("M"))                              sz = Int64.Parse(v.Substring(0' v.Length - 1)) * 1024 * 1024;                          else if (v.ToUpper().EndsWith("MB"))                              sz = Int64.Parse(v.Substring(0' v.Length - 2)) * 1024 * 1024;                          else if (v.ToUpper().EndsWith("G"))                              sz = Int64.Parse(v.Substring(0' v.Length - 1)) * 1024 * 1024 * 1024;                          else if (v.ToUpper().EndsWith("GB"))                              sz = Int64.Parse(v.Substring(0' v.Length - 2)) * 1024 * 1024 * 1024;                          else sz = Int64.Parse(tokens[i + 2]);                            current = new SizeCriterion                          {                              Size = sz'                              Operator = (ComparisonOperator)EnumUtil.Parse(typeof(ComparisonOperator)' tokens[i + 1])                          };                          i += 2;                          stateStack.Push(ParseState.CriterionDone);                          break;                        case "filename":                      case "name":                          {                              if (tokens.Length <= i + 2)                                  throw new ArgumentException(String.Join(" "' tokens' i' tokens.Length - i));                                ComparisonOperator c =                                  (ComparisonOperator)EnumUtil.Parse(typeof(ComparisonOperator)' tokens[i + 1]);                                if (c != ComparisonOperator.NotEqualTo && c != ComparisonOperator.EqualTo)                                  throw new ArgumentException(String.Join(" "' tokens' i' tokens.Length - i));                                string m = tokens[i + 2];                                // handle single-quoted filespecs (used to include                              // spaces in filename patterns)                              if (m.StartsWith("'") && m.EndsWith("'"))                              {                                  // trim off leading and trailing single quotes and                                  // revert the control characters to spaces.                                  m = m.Substring(1' m.Length - 2)                                      .Replace("\u0006"' " ");                              }                                // if (m.StartsWith("'"))                              //     m = m.Replace("\u0006"' " ");                                //Fix for Unix -> NormalizeCriteriaExpression replaces all slashes with backslashes                              if (Path.DirectorySeparatorChar == '/')                                  m = m.Replace('\\'' Path.DirectorySeparatorChar);                                current = new NameCriterion                              {                                  MatchingFileSpec = m'                                  Operator = c                              };                              i += 2;                              stateStack.Push(ParseState.CriterionDone);                          }                          break;                        case "attrs":                      case "attributes":                      case "type":                          {                              if (tokens.Length <= i + 2)                                  throw new ArgumentException(String.Join(" "' tokens' i' tokens.Length - i));                                ComparisonOperator c =                                  (ComparisonOperator)EnumUtil.Parse(typeof(ComparisonOperator)' tokens[i + 1]);                                if (c != ComparisonOperator.NotEqualTo && c != ComparisonOperator.EqualTo)                                  throw new ArgumentException(String.Join(" "' tokens' i' tokens.Length - i));                                current = (tok1 == "type")                                  ? (SelectionCriterion) new TypeCriterion                                      {                                          AttributeString = tokens[i + 2]'                                          Operator = c                                      }                                  : (SelectionCriterion) new AttributesCriterion                                      {                                          AttributeString = tokens[i + 2]'                                          Operator = c                                      };                              i += 2;                              stateStack.Push(ParseState.CriterionDone);                          }                          break;                        case "":                          // NOP                          stateStack.Push(ParseState.Whitespace);                          break;                        default:                          throw new ArgumentException("'" + tokens[i] + "'");                  }
Magic Number,Ionic,FileSelector,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\FileSelector.cs,_ParseCriterion,The following statement contains a magic number: switch (tok1)                  {                      case "and":                      case "xor":                      case "or":                          state = stateStack.Peek();                          if (state != ParseState.CriterionDone)                              throw new ArgumentException(String.Join(" "' tokens' i' tokens.Length - i));                            if (tokens.Length <= i + 3)                              throw new ArgumentException(String.Join(" "' tokens' i' tokens.Length - i));                            pendingConjunction = (LogicalConjunction)Enum.Parse(typeof(LogicalConjunction)' tokens[i].ToUpper()' true);                          current = new CompoundCriterion { Left = current' Right = null' Conjunction = pendingConjunction };                          stateStack.Push(state);                          stateStack.Push(ParseState.ConjunctionPending);                          critStack.Push(current);                          break;                        case "(":                          state = stateStack.Peek();                          if (state != ParseState.Start && state != ParseState.ConjunctionPending && state != ParseState.OpenParen)                              throw new ArgumentException(String.Join(" "' tokens' i' tokens.Length - i));                            if (tokens.Length <= i + 4)                              throw new ArgumentException(String.Join(" "' tokens' i' tokens.Length - i));                            stateStack.Push(ParseState.OpenParen);                          break;                        case ")":                          state = stateStack.Pop();                          if (stateStack.Peek() != ParseState.OpenParen)                              throw new ArgumentException(String.Join(" "' tokens' i' tokens.Length - i));                            stateStack.Pop();                          stateStack.Push(ParseState.CriterionDone);                          break;                        case "atime":                      case "ctime":                      case "mtime":                          if (tokens.Length <= i + 2)                              throw new ArgumentException(String.Join(" "' tokens' i' tokens.Length - i));                            DateTime t;                          try                          {                              t = DateTime.ParseExact(tokens[i + 2]' "yyyy-MM-dd-HH:mm:ss"' null);                          }                          catch (FormatException)                          {                              try                              {                                  t = DateTime.ParseExact(tokens[i + 2]' "yyyy/MM/dd-HH:mm:ss"' null);                              }                              catch (FormatException)                              {                                  try                                  {                                      t = DateTime.ParseExact(tokens[i + 2]' "yyyy/MM/dd"' null);                                  }                                  catch (FormatException)                                  {                                      try                                      {                                          t = DateTime.ParseExact(tokens[i + 2]' "MM/dd/yyyy"' null);                                      }                                      catch (FormatException)                                      {                                          t = DateTime.ParseExact(tokens[i + 2]' "yyyy-MM-dd"' null);                                      }                                  }                              }                          }                          t= DateTime.SpecifyKind(t' DateTimeKind.Local).ToUniversalTime();                          current = new TimeCriterion                          {                              Which = (WhichTime)Enum.Parse(typeof(WhichTime)' tokens[i]' true)'                              Operator = (ComparisonOperator)EnumUtil.Parse(typeof(ComparisonOperator)' tokens[i + 1])'                              Time = t                          };                          i += 2;                          stateStack.Push(ParseState.CriterionDone);                          break;                          case "length":                      case "size":                          if (tokens.Length <= i + 2)                              throw new ArgumentException(String.Join(" "' tokens' i' tokens.Length - i));                            Int64 sz = 0;                          string v = tokens[i + 2];                          if (v.ToUpper().EndsWith("K"))                              sz = Int64.Parse(v.Substring(0' v.Length - 1)) * 1024;                          else if (v.ToUpper().EndsWith("KB"))                              sz = Int64.Parse(v.Substring(0' v.Length - 2)) * 1024;                          else if (v.ToUpper().EndsWith("M"))                              sz = Int64.Parse(v.Substring(0' v.Length - 1)) * 1024 * 1024;                          else if (v.ToUpper().EndsWith("MB"))                              sz = Int64.Parse(v.Substring(0' v.Length - 2)) * 1024 * 1024;                          else if (v.ToUpper().EndsWith("G"))                              sz = Int64.Parse(v.Substring(0' v.Length - 1)) * 1024 * 1024 * 1024;                          else if (v.ToUpper().EndsWith("GB"))                              sz = Int64.Parse(v.Substring(0' v.Length - 2)) * 1024 * 1024 * 1024;                          else sz = Int64.Parse(tokens[i + 2]);                            current = new SizeCriterion                          {                              Size = sz'                              Operator = (ComparisonOperator)EnumUtil.Parse(typeof(ComparisonOperator)' tokens[i + 1])                          };                          i += 2;                          stateStack.Push(ParseState.CriterionDone);                          break;                        case "filename":                      case "name":                          {                              if (tokens.Length <= i + 2)                                  throw new ArgumentException(String.Join(" "' tokens' i' tokens.Length - i));                                ComparisonOperator c =                                  (ComparisonOperator)EnumUtil.Parse(typeof(ComparisonOperator)' tokens[i + 1]);                                if (c != ComparisonOperator.NotEqualTo && c != ComparisonOperator.EqualTo)                                  throw new ArgumentException(String.Join(" "' tokens' i' tokens.Length - i));                                string m = tokens[i + 2];                                // handle single-quoted filespecs (used to include                              // spaces in filename patterns)                              if (m.StartsWith("'") && m.EndsWith("'"))                              {                                  // trim off leading and trailing single quotes and                                  // revert the control characters to spaces.                                  m = m.Substring(1' m.Length - 2)                                      .Replace("\u0006"' " ");                              }                                // if (m.StartsWith("'"))                              //     m = m.Replace("\u0006"' " ");                                //Fix for Unix -> NormalizeCriteriaExpression replaces all slashes with backslashes                              if (Path.DirectorySeparatorChar == '/')                                  m = m.Replace('\\'' Path.DirectorySeparatorChar);                                current = new NameCriterion                              {                                  MatchingFileSpec = m'                                  Operator = c                              };                              i += 2;                              stateStack.Push(ParseState.CriterionDone);                          }                          break;                        case "attrs":                      case "attributes":                      case "type":                          {                              if (tokens.Length <= i + 2)                                  throw new ArgumentException(String.Join(" "' tokens' i' tokens.Length - i));                                ComparisonOperator c =                                  (ComparisonOperator)EnumUtil.Parse(typeof(ComparisonOperator)' tokens[i + 1]);                                if (c != ComparisonOperator.NotEqualTo && c != ComparisonOperator.EqualTo)                                  throw new ArgumentException(String.Join(" "' tokens' i' tokens.Length - i));                                current = (tok1 == "type")                                  ? (SelectionCriterion) new TypeCriterion                                      {                                          AttributeString = tokens[i + 2]'                                          Operator = c                                      }                                  : (SelectionCriterion) new AttributesCriterion                                      {                                          AttributeString = tokens[i + 2]'                                          Operator = c                                      };                              i += 2;                              stateStack.Push(ParseState.CriterionDone);                          }                          break;                        case "":                          // NOP                          stateStack.Push(ParseState.Whitespace);                          break;                        default:                          throw new ArgumentException("'" + tokens[i] + "'");                  }
Magic Number,Ionic,FileSelector,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\FileSelector.cs,_ParseCriterion,The following statement contains a magic number: switch (tok1)                  {                      case "and":                      case "xor":                      case "or":                          state = stateStack.Peek();                          if (state != ParseState.CriterionDone)                              throw new ArgumentException(String.Join(" "' tokens' i' tokens.Length - i));                            if (tokens.Length <= i + 3)                              throw new ArgumentException(String.Join(" "' tokens' i' tokens.Length - i));                            pendingConjunction = (LogicalConjunction)Enum.Parse(typeof(LogicalConjunction)' tokens[i].ToUpper()' true);                          current = new CompoundCriterion { Left = current' Right = null' Conjunction = pendingConjunction };                          stateStack.Push(state);                          stateStack.Push(ParseState.ConjunctionPending);                          critStack.Push(current);                          break;                        case "(":                          state = stateStack.Peek();                          if (state != ParseState.Start && state != ParseState.ConjunctionPending && state != ParseState.OpenParen)                              throw new ArgumentException(String.Join(" "' tokens' i' tokens.Length - i));                            if (tokens.Length <= i + 4)                              throw new ArgumentException(String.Join(" "' tokens' i' tokens.Length - i));                            stateStack.Push(ParseState.OpenParen);                          break;                        case ")":                          state = stateStack.Pop();                          if (stateStack.Peek() != ParseState.OpenParen)                              throw new ArgumentException(String.Join(" "' tokens' i' tokens.Length - i));                            stateStack.Pop();                          stateStack.Push(ParseState.CriterionDone);                          break;                        case "atime":                      case "ctime":                      case "mtime":                          if (tokens.Length <= i + 2)                              throw new ArgumentException(String.Join(" "' tokens' i' tokens.Length - i));                            DateTime t;                          try                          {                              t = DateTime.ParseExact(tokens[i + 2]' "yyyy-MM-dd-HH:mm:ss"' null);                          }                          catch (FormatException)                          {                              try                              {                                  t = DateTime.ParseExact(tokens[i + 2]' "yyyy/MM/dd-HH:mm:ss"' null);                              }                              catch (FormatException)                              {                                  try                                  {                                      t = DateTime.ParseExact(tokens[i + 2]' "yyyy/MM/dd"' null);                                  }                                  catch (FormatException)                                  {                                      try                                      {                                          t = DateTime.ParseExact(tokens[i + 2]' "MM/dd/yyyy"' null);                                      }                                      catch (FormatException)                                      {                                          t = DateTime.ParseExact(tokens[i + 2]' "yyyy-MM-dd"' null);                                      }                                  }                              }                          }                          t= DateTime.SpecifyKind(t' DateTimeKind.Local).ToUniversalTime();                          current = new TimeCriterion                          {                              Which = (WhichTime)Enum.Parse(typeof(WhichTime)' tokens[i]' true)'                              Operator = (ComparisonOperator)EnumUtil.Parse(typeof(ComparisonOperator)' tokens[i + 1])'                              Time = t                          };                          i += 2;                          stateStack.Push(ParseState.CriterionDone);                          break;                          case "length":                      case "size":                          if (tokens.Length <= i + 2)                              throw new ArgumentException(String.Join(" "' tokens' i' tokens.Length - i));                            Int64 sz = 0;                          string v = tokens[i + 2];                          if (v.ToUpper().EndsWith("K"))                              sz = Int64.Parse(v.Substring(0' v.Length - 1)) * 1024;                          else if (v.ToUpper().EndsWith("KB"))                              sz = Int64.Parse(v.Substring(0' v.Length - 2)) * 1024;                          else if (v.ToUpper().EndsWith("M"))                              sz = Int64.Parse(v.Substring(0' v.Length - 1)) * 1024 * 1024;                          else if (v.ToUpper().EndsWith("MB"))                              sz = Int64.Parse(v.Substring(0' v.Length - 2)) * 1024 * 1024;                          else if (v.ToUpper().EndsWith("G"))                              sz = Int64.Parse(v.Substring(0' v.Length - 1)) * 1024 * 1024 * 1024;                          else if (v.ToUpper().EndsWith("GB"))                              sz = Int64.Parse(v.Substring(0' v.Length - 2)) * 1024 * 1024 * 1024;                          else sz = Int64.Parse(tokens[i + 2]);                            current = new SizeCriterion                          {                              Size = sz'                              Operator = (ComparisonOperator)EnumUtil.Parse(typeof(ComparisonOperator)' tokens[i + 1])                          };                          i += 2;                          stateStack.Push(ParseState.CriterionDone);                          break;                        case "filename":                      case "name":                          {                              if (tokens.Length <= i + 2)                                  throw new ArgumentException(String.Join(" "' tokens' i' tokens.Length - i));                                ComparisonOperator c =                                  (ComparisonOperator)EnumUtil.Parse(typeof(ComparisonOperator)' tokens[i + 1]);                                if (c != ComparisonOperator.NotEqualTo && c != ComparisonOperator.EqualTo)                                  throw new ArgumentException(String.Join(" "' tokens' i' tokens.Length - i));                                string m = tokens[i + 2];                                // handle single-quoted filespecs (used to include                              // spaces in filename patterns)                              if (m.StartsWith("'") && m.EndsWith("'"))                              {                                  // trim off leading and trailing single quotes and                                  // revert the control characters to spaces.                                  m = m.Substring(1' m.Length - 2)                                      .Replace("\u0006"' " ");                              }                                // if (m.StartsWith("'"))                              //     m = m.Replace("\u0006"' " ");                                //Fix for Unix -> NormalizeCriteriaExpression replaces all slashes with backslashes                              if (Path.DirectorySeparatorChar == '/')                                  m = m.Replace('\\'' Path.DirectorySeparatorChar);                                current = new NameCriterion                              {                                  MatchingFileSpec = m'                                  Operator = c                              };                              i += 2;                              stateStack.Push(ParseState.CriterionDone);                          }                          break;                        case "attrs":                      case "attributes":                      case "type":                          {                              if (tokens.Length <= i + 2)                                  throw new ArgumentException(String.Join(" "' tokens' i' tokens.Length - i));                                ComparisonOperator c =                                  (ComparisonOperator)EnumUtil.Parse(typeof(ComparisonOperator)' tokens[i + 1]);                                if (c != ComparisonOperator.NotEqualTo && c != ComparisonOperator.EqualTo)                                  throw new ArgumentException(String.Join(" "' tokens' i' tokens.Length - i));                                current = (tok1 == "type")                                  ? (SelectionCriterion) new TypeCriterion                                      {                                          AttributeString = tokens[i + 2]'                                          Operator = c                                      }                                  : (SelectionCriterion) new AttributesCriterion                                      {                                          AttributeString = tokens[i + 2]'                                          Operator = c                                      };                              i += 2;                              stateStack.Push(ParseState.CriterionDone);                          }                          break;                        case "":                          // NOP                          stateStack.Push(ParseState.Whitespace);                          break;                        default:                          throw new ArgumentException("'" + tokens[i] + "'");                  }
Magic Number,Ionic,FileSelector,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\FileSelector.cs,_ParseCriterion,The following statement contains a magic number: switch (tok1)                  {                      case "and":                      case "xor":                      case "or":                          state = stateStack.Peek();                          if (state != ParseState.CriterionDone)                              throw new ArgumentException(String.Join(" "' tokens' i' tokens.Length - i));                            if (tokens.Length <= i + 3)                              throw new ArgumentException(String.Join(" "' tokens' i' tokens.Length - i));                            pendingConjunction = (LogicalConjunction)Enum.Parse(typeof(LogicalConjunction)' tokens[i].ToUpper()' true);                          current = new CompoundCriterion { Left = current' Right = null' Conjunction = pendingConjunction };                          stateStack.Push(state);                          stateStack.Push(ParseState.ConjunctionPending);                          critStack.Push(current);                          break;                        case "(":                          state = stateStack.Peek();                          if (state != ParseState.Start && state != ParseState.ConjunctionPending && state != ParseState.OpenParen)                              throw new ArgumentException(String.Join(" "' tokens' i' tokens.Length - i));                            if (tokens.Length <= i + 4)                              throw new ArgumentException(String.Join(" "' tokens' i' tokens.Length - i));                            stateStack.Push(ParseState.OpenParen);                          break;                        case ")":                          state = stateStack.Pop();                          if (stateStack.Peek() != ParseState.OpenParen)                              throw new ArgumentException(String.Join(" "' tokens' i' tokens.Length - i));                            stateStack.Pop();                          stateStack.Push(ParseState.CriterionDone);                          break;                        case "atime":                      case "ctime":                      case "mtime":                          if (tokens.Length <= i + 2)                              throw new ArgumentException(String.Join(" "' tokens' i' tokens.Length - i));                            DateTime t;                          try                          {                              t = DateTime.ParseExact(tokens[i + 2]' "yyyy-MM-dd-HH:mm:ss"' null);                          }                          catch (FormatException)                          {                              try                              {                                  t = DateTime.ParseExact(tokens[i + 2]' "yyyy/MM/dd-HH:mm:ss"' null);                              }                              catch (FormatException)                              {                                  try                                  {                                      t = DateTime.ParseExact(tokens[i + 2]' "yyyy/MM/dd"' null);                                  }                                  catch (FormatException)                                  {                                      try                                      {                                          t = DateTime.ParseExact(tokens[i + 2]' "MM/dd/yyyy"' null);                                      }                                      catch (FormatException)                                      {                                          t = DateTime.ParseExact(tokens[i + 2]' "yyyy-MM-dd"' null);                                      }                                  }                              }                          }                          t= DateTime.SpecifyKind(t' DateTimeKind.Local).ToUniversalTime();                          current = new TimeCriterion                          {                              Which = (WhichTime)Enum.Parse(typeof(WhichTime)' tokens[i]' true)'                              Operator = (ComparisonOperator)EnumUtil.Parse(typeof(ComparisonOperator)' tokens[i + 1])'                              Time = t                          };                          i += 2;                          stateStack.Push(ParseState.CriterionDone);                          break;                          case "length":                      case "size":                          if (tokens.Length <= i + 2)                              throw new ArgumentException(String.Join(" "' tokens' i' tokens.Length - i));                            Int64 sz = 0;                          string v = tokens[i + 2];                          if (v.ToUpper().EndsWith("K"))                              sz = Int64.Parse(v.Substring(0' v.Length - 1)) * 1024;                          else if (v.ToUpper().EndsWith("KB"))                              sz = Int64.Parse(v.Substring(0' v.Length - 2)) * 1024;                          else if (v.ToUpper().EndsWith("M"))                              sz = Int64.Parse(v.Substring(0' v.Length - 1)) * 1024 * 1024;                          else if (v.ToUpper().EndsWith("MB"))                              sz = Int64.Parse(v.Substring(0' v.Length - 2)) * 1024 * 1024;                          else if (v.ToUpper().EndsWith("G"))                              sz = Int64.Parse(v.Substring(0' v.Length - 1)) * 1024 * 1024 * 1024;                          else if (v.ToUpper().EndsWith("GB"))                              sz = Int64.Parse(v.Substring(0' v.Length - 2)) * 1024 * 1024 * 1024;                          else sz = Int64.Parse(tokens[i + 2]);                            current = new SizeCriterion                          {                              Size = sz'                              Operator = (ComparisonOperator)EnumUtil.Parse(typeof(ComparisonOperator)' tokens[i + 1])                          };                          i += 2;                          stateStack.Push(ParseState.CriterionDone);                          break;                        case "filename":                      case "name":                          {                              if (tokens.Length <= i + 2)                                  throw new ArgumentException(String.Join(" "' tokens' i' tokens.Length - i));                                ComparisonOperator c =                                  (ComparisonOperator)EnumUtil.Parse(typeof(ComparisonOperator)' tokens[i + 1]);                                if (c != ComparisonOperator.NotEqualTo && c != ComparisonOperator.EqualTo)                                  throw new ArgumentException(String.Join(" "' tokens' i' tokens.Length - i));                                string m = tokens[i + 2];                                // handle single-quoted filespecs (used to include                              // spaces in filename patterns)                              if (m.StartsWith("'") && m.EndsWith("'"))                              {                                  // trim off leading and trailing single quotes and                                  // revert the control characters to spaces.                                  m = m.Substring(1' m.Length - 2)                                      .Replace("\u0006"' " ");                              }                                // if (m.StartsWith("'"))                              //     m = m.Replace("\u0006"' " ");                                //Fix for Unix -> NormalizeCriteriaExpression replaces all slashes with backslashes                              if (Path.DirectorySeparatorChar == '/')                                  m = m.Replace('\\'' Path.DirectorySeparatorChar);                                current = new NameCriterion                              {                                  MatchingFileSpec = m'                                  Operator = c                              };                              i += 2;                              stateStack.Push(ParseState.CriterionDone);                          }                          break;                        case "attrs":                      case "attributes":                      case "type":                          {                              if (tokens.Length <= i + 2)                                  throw new ArgumentException(String.Join(" "' tokens' i' tokens.Length - i));                                ComparisonOperator c =                                  (ComparisonOperator)EnumUtil.Parse(typeof(ComparisonOperator)' tokens[i + 1]);                                if (c != ComparisonOperator.NotEqualTo && c != ComparisonOperator.EqualTo)                                  throw new ArgumentException(String.Join(" "' tokens' i' tokens.Length - i));                                current = (tok1 == "type")                                  ? (SelectionCriterion) new TypeCriterion                                      {                                          AttributeString = tokens[i + 2]'                                          Operator = c                                      }                                  : (SelectionCriterion) new AttributesCriterion                                      {                                          AttributeString = tokens[i + 2]'                                          Operator = c                                      };                              i += 2;                              stateStack.Push(ParseState.CriterionDone);                          }                          break;                        case "":                          // NOP                          stateStack.Push(ParseState.Whitespace);                          break;                        default:                          throw new ArgumentException("'" + tokens[i] + "'");                  }
Magic Number,Ionic,FileSelector,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\FileSelector.cs,_ParseCriterion,The following statement contains a magic number: switch (tok1)                  {                      case "and":                      case "xor":                      case "or":                          state = stateStack.Peek();                          if (state != ParseState.CriterionDone)                              throw new ArgumentException(String.Join(" "' tokens' i' tokens.Length - i));                            if (tokens.Length <= i + 3)                              throw new ArgumentException(String.Join(" "' tokens' i' tokens.Length - i));                            pendingConjunction = (LogicalConjunction)Enum.Parse(typeof(LogicalConjunction)' tokens[i].ToUpper()' true);                          current = new CompoundCriterion { Left = current' Right = null' Conjunction = pendingConjunction };                          stateStack.Push(state);                          stateStack.Push(ParseState.ConjunctionPending);                          critStack.Push(current);                          break;                        case "(":                          state = stateStack.Peek();                          if (state != ParseState.Start && state != ParseState.ConjunctionPending && state != ParseState.OpenParen)                              throw new ArgumentException(String.Join(" "' tokens' i' tokens.Length - i));                            if (tokens.Length <= i + 4)                              throw new ArgumentException(String.Join(" "' tokens' i' tokens.Length - i));                            stateStack.Push(ParseState.OpenParen);                          break;                        case ")":                          state = stateStack.Pop();                          if (stateStack.Peek() != ParseState.OpenParen)                              throw new ArgumentException(String.Join(" "' tokens' i' tokens.Length - i));                            stateStack.Pop();                          stateStack.Push(ParseState.CriterionDone);                          break;                        case "atime":                      case "ctime":                      case "mtime":                          if (tokens.Length <= i + 2)                              throw new ArgumentException(String.Join(" "' tokens' i' tokens.Length - i));                            DateTime t;                          try                          {                              t = DateTime.ParseExact(tokens[i + 2]' "yyyy-MM-dd-HH:mm:ss"' null);                          }                          catch (FormatException)                          {                              try                              {                                  t = DateTime.ParseExact(tokens[i + 2]' "yyyy/MM/dd-HH:mm:ss"' null);                              }                              catch (FormatException)                              {                                  try                                  {                                      t = DateTime.ParseExact(tokens[i + 2]' "yyyy/MM/dd"' null);                                  }                                  catch (FormatException)                                  {                                      try                                      {                                          t = DateTime.ParseExact(tokens[i + 2]' "MM/dd/yyyy"' null);                                      }                                      catch (FormatException)                                      {                                          t = DateTime.ParseExact(tokens[i + 2]' "yyyy-MM-dd"' null);                                      }                                  }                              }                          }                          t= DateTime.SpecifyKind(t' DateTimeKind.Local).ToUniversalTime();                          current = new TimeCriterion                          {                              Which = (WhichTime)Enum.Parse(typeof(WhichTime)' tokens[i]' true)'                              Operator = (ComparisonOperator)EnumUtil.Parse(typeof(ComparisonOperator)' tokens[i + 1])'                              Time = t                          };                          i += 2;                          stateStack.Push(ParseState.CriterionDone);                          break;                          case "length":                      case "size":                          if (tokens.Length <= i + 2)                              throw new ArgumentException(String.Join(" "' tokens' i' tokens.Length - i));                            Int64 sz = 0;                          string v = tokens[i + 2];                          if (v.ToUpper().EndsWith("K"))                              sz = Int64.Parse(v.Substring(0' v.Length - 1)) * 1024;                          else if (v.ToUpper().EndsWith("KB"))                              sz = Int64.Parse(v.Substring(0' v.Length - 2)) * 1024;                          else if (v.ToUpper().EndsWith("M"))                              sz = Int64.Parse(v.Substring(0' v.Length - 1)) * 1024 * 1024;                          else if (v.ToUpper().EndsWith("MB"))                              sz = Int64.Parse(v.Substring(0' v.Length - 2)) * 1024 * 1024;                          else if (v.ToUpper().EndsWith("G"))                              sz = Int64.Parse(v.Substring(0' v.Length - 1)) * 1024 * 1024 * 1024;                          else if (v.ToUpper().EndsWith("GB"))                              sz = Int64.Parse(v.Substring(0' v.Length - 2)) * 1024 * 1024 * 1024;                          else sz = Int64.Parse(tokens[i + 2]);                            current = new SizeCriterion                          {                              Size = sz'                              Operator = (ComparisonOperator)EnumUtil.Parse(typeof(ComparisonOperator)' tokens[i + 1])                          };                          i += 2;                          stateStack.Push(ParseState.CriterionDone);                          break;                        case "filename":                      case "name":                          {                              if (tokens.Length <= i + 2)                                  throw new ArgumentException(String.Join(" "' tokens' i' tokens.Length - i));                                ComparisonOperator c =                                  (ComparisonOperator)EnumUtil.Parse(typeof(ComparisonOperator)' tokens[i + 1]);                                if (c != ComparisonOperator.NotEqualTo && c != ComparisonOperator.EqualTo)                                  throw new ArgumentException(String.Join(" "' tokens' i' tokens.Length - i));                                string m = tokens[i + 2];                                // handle single-quoted filespecs (used to include                              // spaces in filename patterns)                              if (m.StartsWith("'") && m.EndsWith("'"))                              {                                  // trim off leading and trailing single quotes and                                  // revert the control characters to spaces.                                  m = m.Substring(1' m.Length - 2)                                      .Replace("\u0006"' " ");                              }                                // if (m.StartsWith("'"))                              //     m = m.Replace("\u0006"' " ");                                //Fix for Unix -> NormalizeCriteriaExpression replaces all slashes with backslashes                              if (Path.DirectorySeparatorChar == '/')                                  m = m.Replace('\\'' Path.DirectorySeparatorChar);                                current = new NameCriterion                              {                                  MatchingFileSpec = m'                                  Operator = c                              };                              i += 2;                              stateStack.Push(ParseState.CriterionDone);                          }                          break;                        case "attrs":                      case "attributes":                      case "type":                          {                              if (tokens.Length <= i + 2)                                  throw new ArgumentException(String.Join(" "' tokens' i' tokens.Length - i));                                ComparisonOperator c =                                  (ComparisonOperator)EnumUtil.Parse(typeof(ComparisonOperator)' tokens[i + 1]);                                if (c != ComparisonOperator.NotEqualTo && c != ComparisonOperator.EqualTo)                                  throw new ArgumentException(String.Join(" "' tokens' i' tokens.Length - i));                                current = (tok1 == "type")                                  ? (SelectionCriterion) new TypeCriterion                                      {                                          AttributeString = tokens[i + 2]'                                          Operator = c                                      }                                  : (SelectionCriterion) new AttributesCriterion                                      {                                          AttributeString = tokens[i + 2]'                                          Operator = c                                      };                              i += 2;                              stateStack.Push(ParseState.CriterionDone);                          }                          break;                        case "":                          // NOP                          stateStack.Push(ParseState.Whitespace);                          break;                        default:                          throw new ArgumentException("'" + tokens[i] + "'");                  }
Magic Number,Ionic,FileSelector,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\FileSelector.cs,_ParseCriterion,The following statement contains a magic number: switch (tok1)                  {                      case "and":                      case "xor":                      case "or":                          state = stateStack.Peek();                          if (state != ParseState.CriterionDone)                              throw new ArgumentException(String.Join(" "' tokens' i' tokens.Length - i));                            if (tokens.Length <= i + 3)                              throw new ArgumentException(String.Join(" "' tokens' i' tokens.Length - i));                            pendingConjunction = (LogicalConjunction)Enum.Parse(typeof(LogicalConjunction)' tokens[i].ToUpper()' true);                          current = new CompoundCriterion { Left = current' Right = null' Conjunction = pendingConjunction };                          stateStack.Push(state);                          stateStack.Push(ParseState.ConjunctionPending);                          critStack.Push(current);                          break;                        case "(":                          state = stateStack.Peek();                          if (state != ParseState.Start && state != ParseState.ConjunctionPending && state != ParseState.OpenParen)                              throw new ArgumentException(String.Join(" "' tokens' i' tokens.Length - i));                            if (tokens.Length <= i + 4)                              throw new ArgumentException(String.Join(" "' tokens' i' tokens.Length - i));                            stateStack.Push(ParseState.OpenParen);                          break;                        case ")":                          state = stateStack.Pop();                          if (stateStack.Peek() != ParseState.OpenParen)                              throw new ArgumentException(String.Join(" "' tokens' i' tokens.Length - i));                            stateStack.Pop();                          stateStack.Push(ParseState.CriterionDone);                          break;                        case "atime":                      case "ctime":                      case "mtime":                          if (tokens.Length <= i + 2)                              throw new ArgumentException(String.Join(" "' tokens' i' tokens.Length - i));                            DateTime t;                          try                          {                              t = DateTime.ParseExact(tokens[i + 2]' "yyyy-MM-dd-HH:mm:ss"' null);                          }                          catch (FormatException)                          {                              try                              {                                  t = DateTime.ParseExact(tokens[i + 2]' "yyyy/MM/dd-HH:mm:ss"' null);                              }                              catch (FormatException)                              {                                  try                                  {                                      t = DateTime.ParseExact(tokens[i + 2]' "yyyy/MM/dd"' null);                                  }                                  catch (FormatException)                                  {                                      try                                      {                                          t = DateTime.ParseExact(tokens[i + 2]' "MM/dd/yyyy"' null);                                      }                                      catch (FormatException)                                      {                                          t = DateTime.ParseExact(tokens[i + 2]' "yyyy-MM-dd"' null);                                      }                                  }                              }                          }                          t= DateTime.SpecifyKind(t' DateTimeKind.Local).ToUniversalTime();                          current = new TimeCriterion                          {                              Which = (WhichTime)Enum.Parse(typeof(WhichTime)' tokens[i]' true)'                              Operator = (ComparisonOperator)EnumUtil.Parse(typeof(ComparisonOperator)' tokens[i + 1])'                              Time = t                          };                          i += 2;                          stateStack.Push(ParseState.CriterionDone);                          break;                          case "length":                      case "size":                          if (tokens.Length <= i + 2)                              throw new ArgumentException(String.Join(" "' tokens' i' tokens.Length - i));                            Int64 sz = 0;                          string v = tokens[i + 2];                          if (v.ToUpper().EndsWith("K"))                              sz = Int64.Parse(v.Substring(0' v.Length - 1)) * 1024;                          else if (v.ToUpper().EndsWith("KB"))                              sz = Int64.Parse(v.Substring(0' v.Length - 2)) * 1024;                          else if (v.ToUpper().EndsWith("M"))                              sz = Int64.Parse(v.Substring(0' v.Length - 1)) * 1024 * 1024;                          else if (v.ToUpper().EndsWith("MB"))                              sz = Int64.Parse(v.Substring(0' v.Length - 2)) * 1024 * 1024;                          else if (v.ToUpper().EndsWith("G"))                              sz = Int64.Parse(v.Substring(0' v.Length - 1)) * 1024 * 1024 * 1024;                          else if (v.ToUpper().EndsWith("GB"))                              sz = Int64.Parse(v.Substring(0' v.Length - 2)) * 1024 * 1024 * 1024;                          else sz = Int64.Parse(tokens[i + 2]);                            current = new SizeCriterion                          {                              Size = sz'                              Operator = (ComparisonOperator)EnumUtil.Parse(typeof(ComparisonOperator)' tokens[i + 1])                          };                          i += 2;                          stateStack.Push(ParseState.CriterionDone);                          break;                        case "filename":                      case "name":                          {                              if (tokens.Length <= i + 2)                                  throw new ArgumentException(String.Join(" "' tokens' i' tokens.Length - i));                                ComparisonOperator c =                                  (ComparisonOperator)EnumUtil.Parse(typeof(ComparisonOperator)' tokens[i + 1]);                                if (c != ComparisonOperator.NotEqualTo && c != ComparisonOperator.EqualTo)                                  throw new ArgumentException(String.Join(" "' tokens' i' tokens.Length - i));                                string m = tokens[i + 2];                                // handle single-quoted filespecs (used to include                              // spaces in filename patterns)                              if (m.StartsWith("'") && m.EndsWith("'"))                              {                                  // trim off leading and trailing single quotes and                                  // revert the control characters to spaces.                                  m = m.Substring(1' m.Length - 2)                                      .Replace("\u0006"' " ");                              }                                // if (m.StartsWith("'"))                              //     m = m.Replace("\u0006"' " ");                                //Fix for Unix -> NormalizeCriteriaExpression replaces all slashes with backslashes                              if (Path.DirectorySeparatorChar == '/')                                  m = m.Replace('\\'' Path.DirectorySeparatorChar);                                current = new NameCriterion                              {                                  MatchingFileSpec = m'                                  Operator = c                              };                              i += 2;                              stateStack.Push(ParseState.CriterionDone);                          }                          break;                        case "attrs":                      case "attributes":                      case "type":                          {                              if (tokens.Length <= i + 2)                                  throw new ArgumentException(String.Join(" "' tokens' i' tokens.Length - i));                                ComparisonOperator c =                                  (ComparisonOperator)EnumUtil.Parse(typeof(ComparisonOperator)' tokens[i + 1]);                                if (c != ComparisonOperator.NotEqualTo && c != ComparisonOperator.EqualTo)                                  throw new ArgumentException(String.Join(" "' tokens' i' tokens.Length - i));                                current = (tok1 == "type")                                  ? (SelectionCriterion) new TypeCriterion                                      {                                          AttributeString = tokens[i + 2]'                                          Operator = c                                      }                                  : (SelectionCriterion) new AttributesCriterion                                      {                                          AttributeString = tokens[i + 2]'                                          Operator = c                                      };                              i += 2;                              stateStack.Push(ParseState.CriterionDone);                          }                          break;                        case "":                          // NOP                          stateStack.Push(ParseState.Whitespace);                          break;                        default:                          throw new ArgumentException("'" + tokens[i] + "'");                  }
Magic Number,Ionic,FileSelector,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\FileSelector.cs,_ParseCriterion,The following statement contains a magic number: switch (tok1)                  {                      case "and":                      case "xor":                      case "or":                          state = stateStack.Peek();                          if (state != ParseState.CriterionDone)                              throw new ArgumentException(String.Join(" "' tokens' i' tokens.Length - i));                            if (tokens.Length <= i + 3)                              throw new ArgumentException(String.Join(" "' tokens' i' tokens.Length - i));                            pendingConjunction = (LogicalConjunction)Enum.Parse(typeof(LogicalConjunction)' tokens[i].ToUpper()' true);                          current = new CompoundCriterion { Left = current' Right = null' Conjunction = pendingConjunction };                          stateStack.Push(state);                          stateStack.Push(ParseState.ConjunctionPending);                          critStack.Push(current);                          break;                        case "(":                          state = stateStack.Peek();                          if (state != ParseState.Start && state != ParseState.ConjunctionPending && state != ParseState.OpenParen)                              throw new ArgumentException(String.Join(" "' tokens' i' tokens.Length - i));                            if (tokens.Length <= i + 4)                              throw new ArgumentException(String.Join(" "' tokens' i' tokens.Length - i));                            stateStack.Push(ParseState.OpenParen);                          break;                        case ")":                          state = stateStack.Pop();                          if (stateStack.Peek() != ParseState.OpenParen)                              throw new ArgumentException(String.Join(" "' tokens' i' tokens.Length - i));                            stateStack.Pop();                          stateStack.Push(ParseState.CriterionDone);                          break;                        case "atime":                      case "ctime":                      case "mtime":                          if (tokens.Length <= i + 2)                              throw new ArgumentException(String.Join(" "' tokens' i' tokens.Length - i));                            DateTime t;                          try                          {                              t = DateTime.ParseExact(tokens[i + 2]' "yyyy-MM-dd-HH:mm:ss"' null);                          }                          catch (FormatException)                          {                              try                              {                                  t = DateTime.ParseExact(tokens[i + 2]' "yyyy/MM/dd-HH:mm:ss"' null);                              }                              catch (FormatException)                              {                                  try                                  {                                      t = DateTime.ParseExact(tokens[i + 2]' "yyyy/MM/dd"' null);                                  }                                  catch (FormatException)                                  {                                      try                                      {                                          t = DateTime.ParseExact(tokens[i + 2]' "MM/dd/yyyy"' null);                                      }                                      catch (FormatException)                                      {                                          t = DateTime.ParseExact(tokens[i + 2]' "yyyy-MM-dd"' null);                                      }                                  }                              }                          }                          t= DateTime.SpecifyKind(t' DateTimeKind.Local).ToUniversalTime();                          current = new TimeCriterion                          {                              Which = (WhichTime)Enum.Parse(typeof(WhichTime)' tokens[i]' true)'                              Operator = (ComparisonOperator)EnumUtil.Parse(typeof(ComparisonOperator)' tokens[i + 1])'                              Time = t                          };                          i += 2;                          stateStack.Push(ParseState.CriterionDone);                          break;                          case "length":                      case "size":                          if (tokens.Length <= i + 2)                              throw new ArgumentException(String.Join(" "' tokens' i' tokens.Length - i));                            Int64 sz = 0;                          string v = tokens[i + 2];                          if (v.ToUpper().EndsWith("K"))                              sz = Int64.Parse(v.Substring(0' v.Length - 1)) * 1024;                          else if (v.ToUpper().EndsWith("KB"))                              sz = Int64.Parse(v.Substring(0' v.Length - 2)) * 1024;                          else if (v.ToUpper().EndsWith("M"))                              sz = Int64.Parse(v.Substring(0' v.Length - 1)) * 1024 * 1024;                          else if (v.ToUpper().EndsWith("MB"))                              sz = Int64.Parse(v.Substring(0' v.Length - 2)) * 1024 * 1024;                          else if (v.ToUpper().EndsWith("G"))                              sz = Int64.Parse(v.Substring(0' v.Length - 1)) * 1024 * 1024 * 1024;                          else if (v.ToUpper().EndsWith("GB"))                              sz = Int64.Parse(v.Substring(0' v.Length - 2)) * 1024 * 1024 * 1024;                          else sz = Int64.Parse(tokens[i + 2]);                            current = new SizeCriterion                          {                              Size = sz'                              Operator = (ComparisonOperator)EnumUtil.Parse(typeof(ComparisonOperator)' tokens[i + 1])                          };                          i += 2;                          stateStack.Push(ParseState.CriterionDone);                          break;                        case "filename":                      case "name":                          {                              if (tokens.Length <= i + 2)                                  throw new ArgumentException(String.Join(" "' tokens' i' tokens.Length - i));                                ComparisonOperator c =                                  (ComparisonOperator)EnumUtil.Parse(typeof(ComparisonOperator)' tokens[i + 1]);                                if (c != ComparisonOperator.NotEqualTo && c != ComparisonOperator.EqualTo)                                  throw new ArgumentException(String.Join(" "' tokens' i' tokens.Length - i));                                string m = tokens[i + 2];                                // handle single-quoted filespecs (used to include                              // spaces in filename patterns)                              if (m.StartsWith("'") && m.EndsWith("'"))                              {                                  // trim off leading and trailing single quotes and                                  // revert the control characters to spaces.                                  m = m.Substring(1' m.Length - 2)                                      .Replace("\u0006"' " ");                              }                                // if (m.StartsWith("'"))                              //     m = m.Replace("\u0006"' " ");                                //Fix for Unix -> NormalizeCriteriaExpression replaces all slashes with backslashes                              if (Path.DirectorySeparatorChar == '/')                                  m = m.Replace('\\'' Path.DirectorySeparatorChar);                                current = new NameCriterion                              {                                  MatchingFileSpec = m'                                  Operator = c                              };                              i += 2;                              stateStack.Push(ParseState.CriterionDone);                          }                          break;                        case "attrs":                      case "attributes":                      case "type":                          {                              if (tokens.Length <= i + 2)                                  throw new ArgumentException(String.Join(" "' tokens' i' tokens.Length - i));                                ComparisonOperator c =                                  (ComparisonOperator)EnumUtil.Parse(typeof(ComparisonOperator)' tokens[i + 1]);                                if (c != ComparisonOperator.NotEqualTo && c != ComparisonOperator.EqualTo)                                  throw new ArgumentException(String.Join(" "' tokens' i' tokens.Length - i));                                current = (tok1 == "type")                                  ? (SelectionCriterion) new TypeCriterion                                      {                                          AttributeString = tokens[i + 2]'                                          Operator = c                                      }                                  : (SelectionCriterion) new AttributesCriterion                                      {                                          AttributeString = tokens[i + 2]'                                          Operator = c                                      };                              i += 2;                              stateStack.Push(ParseState.CriterionDone);                          }                          break;                        case "":                          // NOP                          stateStack.Push(ParseState.Whitespace);                          break;                        default:                          throw new ArgumentException("'" + tokens[i] + "'");                  }
Magic Number,Ionic,FileSelector,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\FileSelector.cs,_ParseCriterion,The following statement contains a magic number: switch (tok1)                  {                      case "and":                      case "xor":                      case "or":                          state = stateStack.Peek();                          if (state != ParseState.CriterionDone)                              throw new ArgumentException(String.Join(" "' tokens' i' tokens.Length - i));                            if (tokens.Length <= i + 3)                              throw new ArgumentException(String.Join(" "' tokens' i' tokens.Length - i));                            pendingConjunction = (LogicalConjunction)Enum.Parse(typeof(LogicalConjunction)' tokens[i].ToUpper()' true);                          current = new CompoundCriterion { Left = current' Right = null' Conjunction = pendingConjunction };                          stateStack.Push(state);                          stateStack.Push(ParseState.ConjunctionPending);                          critStack.Push(current);                          break;                        case "(":                          state = stateStack.Peek();                          if (state != ParseState.Start && state != ParseState.ConjunctionPending && state != ParseState.OpenParen)                              throw new ArgumentException(String.Join(" "' tokens' i' tokens.Length - i));                            if (tokens.Length <= i + 4)                              throw new ArgumentException(String.Join(" "' tokens' i' tokens.Length - i));                            stateStack.Push(ParseState.OpenParen);                          break;                        case ")":                          state = stateStack.Pop();                          if (stateStack.Peek() != ParseState.OpenParen)                              throw new ArgumentException(String.Join(" "' tokens' i' tokens.Length - i));                            stateStack.Pop();                          stateStack.Push(ParseState.CriterionDone);                          break;                        case "atime":                      case "ctime":                      case "mtime":                          if (tokens.Length <= i + 2)                              throw new ArgumentException(String.Join(" "' tokens' i' tokens.Length - i));                            DateTime t;                          try                          {                              t = DateTime.ParseExact(tokens[i + 2]' "yyyy-MM-dd-HH:mm:ss"' null);                          }                          catch (FormatException)                          {                              try                              {                                  t = DateTime.ParseExact(tokens[i + 2]' "yyyy/MM/dd-HH:mm:ss"' null);                              }                              catch (FormatException)                              {                                  try                                  {                                      t = DateTime.ParseExact(tokens[i + 2]' "yyyy/MM/dd"' null);                                  }                                  catch (FormatException)                                  {                                      try                                      {                                          t = DateTime.ParseExact(tokens[i + 2]' "MM/dd/yyyy"' null);                                      }                                      catch (FormatException)                                      {                                          t = DateTime.ParseExact(tokens[i + 2]' "yyyy-MM-dd"' null);                                      }                                  }                              }                          }                          t= DateTime.SpecifyKind(t' DateTimeKind.Local).ToUniversalTime();                          current = new TimeCriterion                          {                              Which = (WhichTime)Enum.Parse(typeof(WhichTime)' tokens[i]' true)'                              Operator = (ComparisonOperator)EnumUtil.Parse(typeof(ComparisonOperator)' tokens[i + 1])'                              Time = t                          };                          i += 2;                          stateStack.Push(ParseState.CriterionDone);                          break;                          case "length":                      case "size":                          if (tokens.Length <= i + 2)                              throw new ArgumentException(String.Join(" "' tokens' i' tokens.Length - i));                            Int64 sz = 0;                          string v = tokens[i + 2];                          if (v.ToUpper().EndsWith("K"))                              sz = Int64.Parse(v.Substring(0' v.Length - 1)) * 1024;                          else if (v.ToUpper().EndsWith("KB"))                              sz = Int64.Parse(v.Substring(0' v.Length - 2)) * 1024;                          else if (v.ToUpper().EndsWith("M"))                              sz = Int64.Parse(v.Substring(0' v.Length - 1)) * 1024 * 1024;                          else if (v.ToUpper().EndsWith("MB"))                              sz = Int64.Parse(v.Substring(0' v.Length - 2)) * 1024 * 1024;                          else if (v.ToUpper().EndsWith("G"))                              sz = Int64.Parse(v.Substring(0' v.Length - 1)) * 1024 * 1024 * 1024;                          else if (v.ToUpper().EndsWith("GB"))                              sz = Int64.Parse(v.Substring(0' v.Length - 2)) * 1024 * 1024 * 1024;                          else sz = Int64.Parse(tokens[i + 2]);                            current = new SizeCriterion                          {                              Size = sz'                              Operator = (ComparisonOperator)EnumUtil.Parse(typeof(ComparisonOperator)' tokens[i + 1])                          };                          i += 2;                          stateStack.Push(ParseState.CriterionDone);                          break;                        case "filename":                      case "name":                          {                              if (tokens.Length <= i + 2)                                  throw new ArgumentException(String.Join(" "' tokens' i' tokens.Length - i));                                ComparisonOperator c =                                  (ComparisonOperator)EnumUtil.Parse(typeof(ComparisonOperator)' tokens[i + 1]);                                if (c != ComparisonOperator.NotEqualTo && c != ComparisonOperator.EqualTo)                                  throw new ArgumentException(String.Join(" "' tokens' i' tokens.Length - i));                                string m = tokens[i + 2];                                // handle single-quoted filespecs (used to include                              // spaces in filename patterns)                              if (m.StartsWith("'") && m.EndsWith("'"))                              {                                  // trim off leading and trailing single quotes and                                  // revert the control characters to spaces.                                  m = m.Substring(1' m.Length - 2)                                      .Replace("\u0006"' " ");                              }                                // if (m.StartsWith("'"))                              //     m = m.Replace("\u0006"' " ");                                //Fix for Unix -> NormalizeCriteriaExpression replaces all slashes with backslashes                              if (Path.DirectorySeparatorChar == '/')                                  m = m.Replace('\\'' Path.DirectorySeparatorChar);                                current = new NameCriterion                              {                                  MatchingFileSpec = m'                                  Operator = c                              };                              i += 2;                              stateStack.Push(ParseState.CriterionDone);                          }                          break;                        case "attrs":                      case "attributes":                      case "type":                          {                              if (tokens.Length <= i + 2)                                  throw new ArgumentException(String.Join(" "' tokens' i' tokens.Length - i));                                ComparisonOperator c =                                  (ComparisonOperator)EnumUtil.Parse(typeof(ComparisonOperator)' tokens[i + 1]);                                if (c != ComparisonOperator.NotEqualTo && c != ComparisonOperator.EqualTo)                                  throw new ArgumentException(String.Join(" "' tokens' i' tokens.Length - i));                                current = (tok1 == "type")                                  ? (SelectionCriterion) new TypeCriterion                                      {                                          AttributeString = tokens[i + 2]'                                          Operator = c                                      }                                  : (SelectionCriterion) new AttributesCriterion                                      {                                          AttributeString = tokens[i + 2]'                                          Operator = c                                      };                              i += 2;                              stateStack.Push(ParseState.CriterionDone);                          }                          break;                        case "":                          // NOP                          stateStack.Push(ParseState.Whitespace);                          break;                        default:                          throw new ArgumentException("'" + tokens[i] + "'");                  }
Magic Number,Ionic,FileSelector,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\FileSelector.cs,_ParseCriterion,The following statement contains a magic number: switch (tok1)                  {                      case "and":                      case "xor":                      case "or":                          state = stateStack.Peek();                          if (state != ParseState.CriterionDone)                              throw new ArgumentException(String.Join(" "' tokens' i' tokens.Length - i));                            if (tokens.Length <= i + 3)                              throw new ArgumentException(String.Join(" "' tokens' i' tokens.Length - i));                            pendingConjunction = (LogicalConjunction)Enum.Parse(typeof(LogicalConjunction)' tokens[i].ToUpper()' true);                          current = new CompoundCriterion { Left = current' Right = null' Conjunction = pendingConjunction };                          stateStack.Push(state);                          stateStack.Push(ParseState.ConjunctionPending);                          critStack.Push(current);                          break;                        case "(":                          state = stateStack.Peek();                          if (state != ParseState.Start && state != ParseState.ConjunctionPending && state != ParseState.OpenParen)                              throw new ArgumentException(String.Join(" "' tokens' i' tokens.Length - i));                            if (tokens.Length <= i + 4)                              throw new ArgumentException(String.Join(" "' tokens' i' tokens.Length - i));                            stateStack.Push(ParseState.OpenParen);                          break;                        case ")":                          state = stateStack.Pop();                          if (stateStack.Peek() != ParseState.OpenParen)                              throw new ArgumentException(String.Join(" "' tokens' i' tokens.Length - i));                            stateStack.Pop();                          stateStack.Push(ParseState.CriterionDone);                          break;                        case "atime":                      case "ctime":                      case "mtime":                          if (tokens.Length <= i + 2)                              throw new ArgumentException(String.Join(" "' tokens' i' tokens.Length - i));                            DateTime t;                          try                          {                              t = DateTime.ParseExact(tokens[i + 2]' "yyyy-MM-dd-HH:mm:ss"' null);                          }                          catch (FormatException)                          {                              try                              {                                  t = DateTime.ParseExact(tokens[i + 2]' "yyyy/MM/dd-HH:mm:ss"' null);                              }                              catch (FormatException)                              {                                  try                                  {                                      t = DateTime.ParseExact(tokens[i + 2]' "yyyy/MM/dd"' null);                                  }                                  catch (FormatException)                                  {                                      try                                      {                                          t = DateTime.ParseExact(tokens[i + 2]' "MM/dd/yyyy"' null);                                      }                                      catch (FormatException)                                      {                                          t = DateTime.ParseExact(tokens[i + 2]' "yyyy-MM-dd"' null);                                      }                                  }                              }                          }                          t= DateTime.SpecifyKind(t' DateTimeKind.Local).ToUniversalTime();                          current = new TimeCriterion                          {                              Which = (WhichTime)Enum.Parse(typeof(WhichTime)' tokens[i]' true)'                              Operator = (ComparisonOperator)EnumUtil.Parse(typeof(ComparisonOperator)' tokens[i + 1])'                              Time = t                          };                          i += 2;                          stateStack.Push(ParseState.CriterionDone);                          break;                          case "length":                      case "size":                          if (tokens.Length <= i + 2)                              throw new ArgumentException(String.Join(" "' tokens' i' tokens.Length - i));                            Int64 sz = 0;                          string v = tokens[i + 2];                          if (v.ToUpper().EndsWith("K"))                              sz = Int64.Parse(v.Substring(0' v.Length - 1)) * 1024;                          else if (v.ToUpper().EndsWith("KB"))                              sz = Int64.Parse(v.Substring(0' v.Length - 2)) * 1024;                          else if (v.ToUpper().EndsWith("M"))                              sz = Int64.Parse(v.Substring(0' v.Length - 1)) * 1024 * 1024;                          else if (v.ToUpper().EndsWith("MB"))                              sz = Int64.Parse(v.Substring(0' v.Length - 2)) * 1024 * 1024;                          else if (v.ToUpper().EndsWith("G"))                              sz = Int64.Parse(v.Substring(0' v.Length - 1)) * 1024 * 1024 * 1024;                          else if (v.ToUpper().EndsWith("GB"))                              sz = Int64.Parse(v.Substring(0' v.Length - 2)) * 1024 * 1024 * 1024;                          else sz = Int64.Parse(tokens[i + 2]);                            current = new SizeCriterion                          {                              Size = sz'                              Operator = (ComparisonOperator)EnumUtil.Parse(typeof(ComparisonOperator)' tokens[i + 1])                          };                          i += 2;                          stateStack.Push(ParseState.CriterionDone);                          break;                        case "filename":                      case "name":                          {                              if (tokens.Length <= i + 2)                                  throw new ArgumentException(String.Join(" "' tokens' i' tokens.Length - i));                                ComparisonOperator c =                                  (ComparisonOperator)EnumUtil.Parse(typeof(ComparisonOperator)' tokens[i + 1]);                                if (c != ComparisonOperator.NotEqualTo && c != ComparisonOperator.EqualTo)                                  throw new ArgumentException(String.Join(" "' tokens' i' tokens.Length - i));                                string m = tokens[i + 2];                                // handle single-quoted filespecs (used to include                              // spaces in filename patterns)                              if (m.StartsWith("'") && m.EndsWith("'"))                              {                                  // trim off leading and trailing single quotes and                                  // revert the control characters to spaces.                                  m = m.Substring(1' m.Length - 2)                                      .Replace("\u0006"' " ");                              }                                // if (m.StartsWith("'"))                              //     m = m.Replace("\u0006"' " ");                                //Fix for Unix -> NormalizeCriteriaExpression replaces all slashes with backslashes                              if (Path.DirectorySeparatorChar == '/')                                  m = m.Replace('\\'' Path.DirectorySeparatorChar);                                current = new NameCriterion                              {                                  MatchingFileSpec = m'                                  Operator = c                              };                              i += 2;                              stateStack.Push(ParseState.CriterionDone);                          }                          break;                        case "attrs":                      case "attributes":                      case "type":                          {                              if (tokens.Length <= i + 2)                                  throw new ArgumentException(String.Join(" "' tokens' i' tokens.Length - i));                                ComparisonOperator c =                                  (ComparisonOperator)EnumUtil.Parse(typeof(ComparisonOperator)' tokens[i + 1]);                                if (c != ComparisonOperator.NotEqualTo && c != ComparisonOperator.EqualTo)                                  throw new ArgumentException(String.Join(" "' tokens' i' tokens.Length - i));                                current = (tok1 == "type")                                  ? (SelectionCriterion) new TypeCriterion                                      {                                          AttributeString = tokens[i + 2]'                                          Operator = c                                      }                                  : (SelectionCriterion) new AttributesCriterion                                      {                                          AttributeString = tokens[i + 2]'                                          Operator = c                                      };                              i += 2;                              stateStack.Push(ParseState.CriterionDone);                          }                          break;                        case "":                          // NOP                          stateStack.Push(ParseState.Whitespace);                          break;                        default:                          throw new ArgumentException("'" + tokens[i] + "'");                  }
Magic Number,Ionic,FileSelector,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\FileSelector.cs,_ParseCriterion,The following statement contains a magic number: switch (tok1)                  {                      case "and":                      case "xor":                      case "or":                          state = stateStack.Peek();                          if (state != ParseState.CriterionDone)                              throw new ArgumentException(String.Join(" "' tokens' i' tokens.Length - i));                            if (tokens.Length <= i + 3)                              throw new ArgumentException(String.Join(" "' tokens' i' tokens.Length - i));                            pendingConjunction = (LogicalConjunction)Enum.Parse(typeof(LogicalConjunction)' tokens[i].ToUpper()' true);                          current = new CompoundCriterion { Left = current' Right = null' Conjunction = pendingConjunction };                          stateStack.Push(state);                          stateStack.Push(ParseState.ConjunctionPending);                          critStack.Push(current);                          break;                        case "(":                          state = stateStack.Peek();                          if (state != ParseState.Start && state != ParseState.ConjunctionPending && state != ParseState.OpenParen)                              throw new ArgumentException(String.Join(" "' tokens' i' tokens.Length - i));                            if (tokens.Length <= i + 4)                              throw new ArgumentException(String.Join(" "' tokens' i' tokens.Length - i));                            stateStack.Push(ParseState.OpenParen);                          break;                        case ")":                          state = stateStack.Pop();                          if (stateStack.Peek() != ParseState.OpenParen)                              throw new ArgumentException(String.Join(" "' tokens' i' tokens.Length - i));                            stateStack.Pop();                          stateStack.Push(ParseState.CriterionDone);                          break;                        case "atime":                      case "ctime":                      case "mtime":                          if (tokens.Length <= i + 2)                              throw new ArgumentException(String.Join(" "' tokens' i' tokens.Length - i));                            DateTime t;                          try                          {                              t = DateTime.ParseExact(tokens[i + 2]' "yyyy-MM-dd-HH:mm:ss"' null);                          }                          catch (FormatException)                          {                              try                              {                                  t = DateTime.ParseExact(tokens[i + 2]' "yyyy/MM/dd-HH:mm:ss"' null);                              }                              catch (FormatException)                              {                                  try                                  {                                      t = DateTime.ParseExact(tokens[i + 2]' "yyyy/MM/dd"' null);                                  }                                  catch (FormatException)                                  {                                      try                                      {                                          t = DateTime.ParseExact(tokens[i + 2]' "MM/dd/yyyy"' null);                                      }                                      catch (FormatException)                                      {                                          t = DateTime.ParseExact(tokens[i + 2]' "yyyy-MM-dd"' null);                                      }                                  }                              }                          }                          t= DateTime.SpecifyKind(t' DateTimeKind.Local).ToUniversalTime();                          current = new TimeCriterion                          {                              Which = (WhichTime)Enum.Parse(typeof(WhichTime)' tokens[i]' true)'                              Operator = (ComparisonOperator)EnumUtil.Parse(typeof(ComparisonOperator)' tokens[i + 1])'                              Time = t                          };                          i += 2;                          stateStack.Push(ParseState.CriterionDone);                          break;                          case "length":                      case "size":                          if (tokens.Length <= i + 2)                              throw new ArgumentException(String.Join(" "' tokens' i' tokens.Length - i));                            Int64 sz = 0;                          string v = tokens[i + 2];                          if (v.ToUpper().EndsWith("K"))                              sz = Int64.Parse(v.Substring(0' v.Length - 1)) * 1024;                          else if (v.ToUpper().EndsWith("KB"))                              sz = Int64.Parse(v.Substring(0' v.Length - 2)) * 1024;                          else if (v.ToUpper().EndsWith("M"))                              sz = Int64.Parse(v.Substring(0' v.Length - 1)) * 1024 * 1024;                          else if (v.ToUpper().EndsWith("MB"))                              sz = Int64.Parse(v.Substring(0' v.Length - 2)) * 1024 * 1024;                          else if (v.ToUpper().EndsWith("G"))                              sz = Int64.Parse(v.Substring(0' v.Length - 1)) * 1024 * 1024 * 1024;                          else if (v.ToUpper().EndsWith("GB"))                              sz = Int64.Parse(v.Substring(0' v.Length - 2)) * 1024 * 1024 * 1024;                          else sz = Int64.Parse(tokens[i + 2]);                            current = new SizeCriterion                          {                              Size = sz'                              Operator = (ComparisonOperator)EnumUtil.Parse(typeof(ComparisonOperator)' tokens[i + 1])                          };                          i += 2;                          stateStack.Push(ParseState.CriterionDone);                          break;                        case "filename":                      case "name":                          {                              if (tokens.Length <= i + 2)                                  throw new ArgumentException(String.Join(" "' tokens' i' tokens.Length - i));                                ComparisonOperator c =                                  (ComparisonOperator)EnumUtil.Parse(typeof(ComparisonOperator)' tokens[i + 1]);                                if (c != ComparisonOperator.NotEqualTo && c != ComparisonOperator.EqualTo)                                  throw new ArgumentException(String.Join(" "' tokens' i' tokens.Length - i));                                string m = tokens[i + 2];                                // handle single-quoted filespecs (used to include                              // spaces in filename patterns)                              if (m.StartsWith("'") && m.EndsWith("'"))                              {                                  // trim off leading and trailing single quotes and                                  // revert the control characters to spaces.                                  m = m.Substring(1' m.Length - 2)                                      .Replace("\u0006"' " ");                              }                                // if (m.StartsWith("'"))                              //     m = m.Replace("\u0006"' " ");                                //Fix for Unix -> NormalizeCriteriaExpression replaces all slashes with backslashes                              if (Path.DirectorySeparatorChar == '/')                                  m = m.Replace('\\'' Path.DirectorySeparatorChar);                                current = new NameCriterion                              {                                  MatchingFileSpec = m'                                  Operator = c                              };                              i += 2;                              stateStack.Push(ParseState.CriterionDone);                          }                          break;                        case "attrs":                      case "attributes":                      case "type":                          {                              if (tokens.Length <= i + 2)                                  throw new ArgumentException(String.Join(" "' tokens' i' tokens.Length - i));                                ComparisonOperator c =                                  (ComparisonOperator)EnumUtil.Parse(typeof(ComparisonOperator)' tokens[i + 1]);                                if (c != ComparisonOperator.NotEqualTo && c != ComparisonOperator.EqualTo)                                  throw new ArgumentException(String.Join(" "' tokens' i' tokens.Length - i));                                current = (tok1 == "type")                                  ? (SelectionCriterion) new TypeCriterion                                      {                                          AttributeString = tokens[i + 2]'                                          Operator = c                                      }                                  : (SelectionCriterion) new AttributesCriterion                                      {                                          AttributeString = tokens[i + 2]'                                          Operator = c                                      };                              i += 2;                              stateStack.Push(ParseState.CriterionDone);                          }                          break;                        case "":                          // NOP                          stateStack.Push(ParseState.Whitespace);                          break;                        default:                          throw new ArgumentException("'" + tokens[i] + "'");                  }
Magic Number,Ionic,FileSelector,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\FileSelector.cs,_ParseCriterion,The following statement contains a magic number: switch (tok1)                  {                      case "and":                      case "xor":                      case "or":                          state = stateStack.Peek();                          if (state != ParseState.CriterionDone)                              throw new ArgumentException(String.Join(" "' tokens' i' tokens.Length - i));                            if (tokens.Length <= i + 3)                              throw new ArgumentException(String.Join(" "' tokens' i' tokens.Length - i));                            pendingConjunction = (LogicalConjunction)Enum.Parse(typeof(LogicalConjunction)' tokens[i].ToUpper()' true);                          current = new CompoundCriterion { Left = current' Right = null' Conjunction = pendingConjunction };                          stateStack.Push(state);                          stateStack.Push(ParseState.ConjunctionPending);                          critStack.Push(current);                          break;                        case "(":                          state = stateStack.Peek();                          if (state != ParseState.Start && state != ParseState.ConjunctionPending && state != ParseState.OpenParen)                              throw new ArgumentException(String.Join(" "' tokens' i' tokens.Length - i));                            if (tokens.Length <= i + 4)                              throw new ArgumentException(String.Join(" "' tokens' i' tokens.Length - i));                            stateStack.Push(ParseState.OpenParen);                          break;                        case ")":                          state = stateStack.Pop();                          if (stateStack.Peek() != ParseState.OpenParen)                              throw new ArgumentException(String.Join(" "' tokens' i' tokens.Length - i));                            stateStack.Pop();                          stateStack.Push(ParseState.CriterionDone);                          break;                        case "atime":                      case "ctime":                      case "mtime":                          if (tokens.Length <= i + 2)                              throw new ArgumentException(String.Join(" "' tokens' i' tokens.Length - i));                            DateTime t;                          try                          {                              t = DateTime.ParseExact(tokens[i + 2]' "yyyy-MM-dd-HH:mm:ss"' null);                          }                          catch (FormatException)                          {                              try                              {                                  t = DateTime.ParseExact(tokens[i + 2]' "yyyy/MM/dd-HH:mm:ss"' null);                              }                              catch (FormatException)                              {                                  try                                  {                                      t = DateTime.ParseExact(tokens[i + 2]' "yyyy/MM/dd"' null);                                  }                                  catch (FormatException)                                  {                                      try                                      {                                          t = DateTime.ParseExact(tokens[i + 2]' "MM/dd/yyyy"' null);                                      }                                      catch (FormatException)                                      {                                          t = DateTime.ParseExact(tokens[i + 2]' "yyyy-MM-dd"' null);                                      }                                  }                              }                          }                          t= DateTime.SpecifyKind(t' DateTimeKind.Local).ToUniversalTime();                          current = new TimeCriterion                          {                              Which = (WhichTime)Enum.Parse(typeof(WhichTime)' tokens[i]' true)'                              Operator = (ComparisonOperator)EnumUtil.Parse(typeof(ComparisonOperator)' tokens[i + 1])'                              Time = t                          };                          i += 2;                          stateStack.Push(ParseState.CriterionDone);                          break;                          case "length":                      case "size":                          if (tokens.Length <= i + 2)                              throw new ArgumentException(String.Join(" "' tokens' i' tokens.Length - i));                            Int64 sz = 0;                          string v = tokens[i + 2];                          if (v.ToUpper().EndsWith("K"))                              sz = Int64.Parse(v.Substring(0' v.Length - 1)) * 1024;                          else if (v.ToUpper().EndsWith("KB"))                              sz = Int64.Parse(v.Substring(0' v.Length - 2)) * 1024;                          else if (v.ToUpper().EndsWith("M"))                              sz = Int64.Parse(v.Substring(0' v.Length - 1)) * 1024 * 1024;                          else if (v.ToUpper().EndsWith("MB"))                              sz = Int64.Parse(v.Substring(0' v.Length - 2)) * 1024 * 1024;                          else if (v.ToUpper().EndsWith("G"))                              sz = Int64.Parse(v.Substring(0' v.Length - 1)) * 1024 * 1024 * 1024;                          else if (v.ToUpper().EndsWith("GB"))                              sz = Int64.Parse(v.Substring(0' v.Length - 2)) * 1024 * 1024 * 1024;                          else sz = Int64.Parse(tokens[i + 2]);                            current = new SizeCriterion                          {                              Size = sz'                              Operator = (ComparisonOperator)EnumUtil.Parse(typeof(ComparisonOperator)' tokens[i + 1])                          };                          i += 2;                          stateStack.Push(ParseState.CriterionDone);                          break;                        case "filename":                      case "name":                          {                              if (tokens.Length <= i + 2)                                  throw new ArgumentException(String.Join(" "' tokens' i' tokens.Length - i));                                ComparisonOperator c =                                  (ComparisonOperator)EnumUtil.Parse(typeof(ComparisonOperator)' tokens[i + 1]);                                if (c != ComparisonOperator.NotEqualTo && c != ComparisonOperator.EqualTo)                                  throw new ArgumentException(String.Join(" "' tokens' i' tokens.Length - i));                                string m = tokens[i + 2];                                // handle single-quoted filespecs (used to include                              // spaces in filename patterns)                              if (m.StartsWith("'") && m.EndsWith("'"))                              {                                  // trim off leading and trailing single quotes and                                  // revert the control characters to spaces.                                  m = m.Substring(1' m.Length - 2)                                      .Replace("\u0006"' " ");                              }                                // if (m.StartsWith("'"))                              //     m = m.Replace("\u0006"' " ");                                //Fix for Unix -> NormalizeCriteriaExpression replaces all slashes with backslashes                              if (Path.DirectorySeparatorChar == '/')                                  m = m.Replace('\\'' Path.DirectorySeparatorChar);                                current = new NameCriterion                              {                                  MatchingFileSpec = m'                                  Operator = c                              };                              i += 2;                              stateStack.Push(ParseState.CriterionDone);                          }                          break;                        case "attrs":                      case "attributes":                      case "type":                          {                              if (tokens.Length <= i + 2)                                  throw new ArgumentException(String.Join(" "' tokens' i' tokens.Length - i));                                ComparisonOperator c =                                  (ComparisonOperator)EnumUtil.Parse(typeof(ComparisonOperator)' tokens[i + 1]);                                if (c != ComparisonOperator.NotEqualTo && c != ComparisonOperator.EqualTo)                                  throw new ArgumentException(String.Join(" "' tokens' i' tokens.Length - i));                                current = (tok1 == "type")                                  ? (SelectionCriterion) new TypeCriterion                                      {                                          AttributeString = tokens[i + 2]'                                          Operator = c                                      }                                  : (SelectionCriterion) new AttributesCriterion                                      {                                          AttributeString = tokens[i + 2]'                                          Operator = c                                      };                              i += 2;                              stateStack.Push(ParseState.CriterionDone);                          }                          break;                        case "":                          // NOP                          stateStack.Push(ParseState.Whitespace);                          break;                        default:                          throw new ArgumentException("'" + tokens[i] + "'");                  }
Magic Number,Ionic,FileSelector,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\FileSelector.cs,_ParseCriterion,The following statement contains a magic number: switch (tok1)                  {                      case "and":                      case "xor":                      case "or":                          state = stateStack.Peek();                          if (state != ParseState.CriterionDone)                              throw new ArgumentException(String.Join(" "' tokens' i' tokens.Length - i));                            if (tokens.Length <= i + 3)                              throw new ArgumentException(String.Join(" "' tokens' i' tokens.Length - i));                            pendingConjunction = (LogicalConjunction)Enum.Parse(typeof(LogicalConjunction)' tokens[i].ToUpper()' true);                          current = new CompoundCriterion { Left = current' Right = null' Conjunction = pendingConjunction };                          stateStack.Push(state);                          stateStack.Push(ParseState.ConjunctionPending);                          critStack.Push(current);                          break;                        case "(":                          state = stateStack.Peek();                          if (state != ParseState.Start && state != ParseState.ConjunctionPending && state != ParseState.OpenParen)                              throw new ArgumentException(String.Join(" "' tokens' i' tokens.Length - i));                            if (tokens.Length <= i + 4)                              throw new ArgumentException(String.Join(" "' tokens' i' tokens.Length - i));                            stateStack.Push(ParseState.OpenParen);                          break;                        case ")":                          state = stateStack.Pop();                          if (stateStack.Peek() != ParseState.OpenParen)                              throw new ArgumentException(String.Join(" "' tokens' i' tokens.Length - i));                            stateStack.Pop();                          stateStack.Push(ParseState.CriterionDone);                          break;                        case "atime":                      case "ctime":                      case "mtime":                          if (tokens.Length <= i + 2)                              throw new ArgumentException(String.Join(" "' tokens' i' tokens.Length - i));                            DateTime t;                          try                          {                              t = DateTime.ParseExact(tokens[i + 2]' "yyyy-MM-dd-HH:mm:ss"' null);                          }                          catch (FormatException)                          {                              try                              {                                  t = DateTime.ParseExact(tokens[i + 2]' "yyyy/MM/dd-HH:mm:ss"' null);                              }                              catch (FormatException)                              {                                  try                                  {                                      t = DateTime.ParseExact(tokens[i + 2]' "yyyy/MM/dd"' null);                                  }                                  catch (FormatException)                                  {                                      try                                      {                                          t = DateTime.ParseExact(tokens[i + 2]' "MM/dd/yyyy"' null);                                      }                                      catch (FormatException)                                      {                                          t = DateTime.ParseExact(tokens[i + 2]' "yyyy-MM-dd"' null);                                      }                                  }                              }                          }                          t= DateTime.SpecifyKind(t' DateTimeKind.Local).ToUniversalTime();                          current = new TimeCriterion                          {                              Which = (WhichTime)Enum.Parse(typeof(WhichTime)' tokens[i]' true)'                              Operator = (ComparisonOperator)EnumUtil.Parse(typeof(ComparisonOperator)' tokens[i + 1])'                              Time = t                          };                          i += 2;                          stateStack.Push(ParseState.CriterionDone);                          break;                          case "length":                      case "size":                          if (tokens.Length <= i + 2)                              throw new ArgumentException(String.Join(" "' tokens' i' tokens.Length - i));                            Int64 sz = 0;                          string v = tokens[i + 2];                          if (v.ToUpper().EndsWith("K"))                              sz = Int64.Parse(v.Substring(0' v.Length - 1)) * 1024;                          else if (v.ToUpper().EndsWith("KB"))                              sz = Int64.Parse(v.Substring(0' v.Length - 2)) * 1024;                          else if (v.ToUpper().EndsWith("M"))                              sz = Int64.Parse(v.Substring(0' v.Length - 1)) * 1024 * 1024;                          else if (v.ToUpper().EndsWith("MB"))                              sz = Int64.Parse(v.Substring(0' v.Length - 2)) * 1024 * 1024;                          else if (v.ToUpper().EndsWith("G"))                              sz = Int64.Parse(v.Substring(0' v.Length - 1)) * 1024 * 1024 * 1024;                          else if (v.ToUpper().EndsWith("GB"))                              sz = Int64.Parse(v.Substring(0' v.Length - 2)) * 1024 * 1024 * 1024;                          else sz = Int64.Parse(tokens[i + 2]);                            current = new SizeCriterion                          {                              Size = sz'                              Operator = (ComparisonOperator)EnumUtil.Parse(typeof(ComparisonOperator)' tokens[i + 1])                          };                          i += 2;                          stateStack.Push(ParseState.CriterionDone);                          break;                        case "filename":                      case "name":                          {                              if (tokens.Length <= i + 2)                                  throw new ArgumentException(String.Join(" "' tokens' i' tokens.Length - i));                                ComparisonOperator c =                                  (ComparisonOperator)EnumUtil.Parse(typeof(ComparisonOperator)' tokens[i + 1]);                                if (c != ComparisonOperator.NotEqualTo && c != ComparisonOperator.EqualTo)                                  throw new ArgumentException(String.Join(" "' tokens' i' tokens.Length - i));                                string m = tokens[i + 2];                                // handle single-quoted filespecs (used to include                              // spaces in filename patterns)                              if (m.StartsWith("'") && m.EndsWith("'"))                              {                                  // trim off leading and trailing single quotes and                                  // revert the control characters to spaces.                                  m = m.Substring(1' m.Length - 2)                                      .Replace("\u0006"' " ");                              }                                // if (m.StartsWith("'"))                              //     m = m.Replace("\u0006"' " ");                                //Fix for Unix -> NormalizeCriteriaExpression replaces all slashes with backslashes                              if (Path.DirectorySeparatorChar == '/')                                  m = m.Replace('\\'' Path.DirectorySeparatorChar);                                current = new NameCriterion                              {                                  MatchingFileSpec = m'                                  Operator = c                              };                              i += 2;                              stateStack.Push(ParseState.CriterionDone);                          }                          break;                        case "attrs":                      case "attributes":                      case "type":                          {                              if (tokens.Length <= i + 2)                                  throw new ArgumentException(String.Join(" "' tokens' i' tokens.Length - i));                                ComparisonOperator c =                                  (ComparisonOperator)EnumUtil.Parse(typeof(ComparisonOperator)' tokens[i + 1]);                                if (c != ComparisonOperator.NotEqualTo && c != ComparisonOperator.EqualTo)                                  throw new ArgumentException(String.Join(" "' tokens' i' tokens.Length - i));                                current = (tok1 == "type")                                  ? (SelectionCriterion) new TypeCriterion                                      {                                          AttributeString = tokens[i + 2]'                                          Operator = c                                      }                                  : (SelectionCriterion) new AttributesCriterion                                      {                                          AttributeString = tokens[i + 2]'                                          Operator = c                                      };                              i += 2;                              stateStack.Push(ParseState.CriterionDone);                          }                          break;                        case "":                          // NOP                          stateStack.Push(ParseState.Whitespace);                          break;                        default:                          throw new ArgumentException("'" + tokens[i] + "'");                  }
Magic Number,Ionic,FileSelector,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\FileSelector.cs,_ParseCriterion,The following statement contains a magic number: switch (tok1)                  {                      case "and":                      case "xor":                      case "or":                          state = stateStack.Peek();                          if (state != ParseState.CriterionDone)                              throw new ArgumentException(String.Join(" "' tokens' i' tokens.Length - i));                            if (tokens.Length <= i + 3)                              throw new ArgumentException(String.Join(" "' tokens' i' tokens.Length - i));                            pendingConjunction = (LogicalConjunction)Enum.Parse(typeof(LogicalConjunction)' tokens[i].ToUpper()' true);                          current = new CompoundCriterion { Left = current' Right = null' Conjunction = pendingConjunction };                          stateStack.Push(state);                          stateStack.Push(ParseState.ConjunctionPending);                          critStack.Push(current);                          break;                        case "(":                          state = stateStack.Peek();                          if (state != ParseState.Start && state != ParseState.ConjunctionPending && state != ParseState.OpenParen)                              throw new ArgumentException(String.Join(" "' tokens' i' tokens.Length - i));                            if (tokens.Length <= i + 4)                              throw new ArgumentException(String.Join(" "' tokens' i' tokens.Length - i));                            stateStack.Push(ParseState.OpenParen);                          break;                        case ")":                          state = stateStack.Pop();                          if (stateStack.Peek() != ParseState.OpenParen)                              throw new ArgumentException(String.Join(" "' tokens' i' tokens.Length - i));                            stateStack.Pop();                          stateStack.Push(ParseState.CriterionDone);                          break;                        case "atime":                      case "ctime":                      case "mtime":                          if (tokens.Length <= i + 2)                              throw new ArgumentException(String.Join(" "' tokens' i' tokens.Length - i));                            DateTime t;                          try                          {                              t = DateTime.ParseExact(tokens[i + 2]' "yyyy-MM-dd-HH:mm:ss"' null);                          }                          catch (FormatException)                          {                              try                              {                                  t = DateTime.ParseExact(tokens[i + 2]' "yyyy/MM/dd-HH:mm:ss"' null);                              }                              catch (FormatException)                              {                                  try                                  {                                      t = DateTime.ParseExact(tokens[i + 2]' "yyyy/MM/dd"' null);                                  }                                  catch (FormatException)                                  {                                      try                                      {                                          t = DateTime.ParseExact(tokens[i + 2]' "MM/dd/yyyy"' null);                                      }                                      catch (FormatException)                                      {                                          t = DateTime.ParseExact(tokens[i + 2]' "yyyy-MM-dd"' null);                                      }                                  }                              }                          }                          t= DateTime.SpecifyKind(t' DateTimeKind.Local).ToUniversalTime();                          current = new TimeCriterion                          {                              Which = (WhichTime)Enum.Parse(typeof(WhichTime)' tokens[i]' true)'                              Operator = (ComparisonOperator)EnumUtil.Parse(typeof(ComparisonOperator)' tokens[i + 1])'                              Time = t                          };                          i += 2;                          stateStack.Push(ParseState.CriterionDone);                          break;                          case "length":                      case "size":                          if (tokens.Length <= i + 2)                              throw new ArgumentException(String.Join(" "' tokens' i' tokens.Length - i));                            Int64 sz = 0;                          string v = tokens[i + 2];                          if (v.ToUpper().EndsWith("K"))                              sz = Int64.Parse(v.Substring(0' v.Length - 1)) * 1024;                          else if (v.ToUpper().EndsWith("KB"))                              sz = Int64.Parse(v.Substring(0' v.Length - 2)) * 1024;                          else if (v.ToUpper().EndsWith("M"))                              sz = Int64.Parse(v.Substring(0' v.Length - 1)) * 1024 * 1024;                          else if (v.ToUpper().EndsWith("MB"))                              sz = Int64.Parse(v.Substring(0' v.Length - 2)) * 1024 * 1024;                          else if (v.ToUpper().EndsWith("G"))                              sz = Int64.Parse(v.Substring(0' v.Length - 1)) * 1024 * 1024 * 1024;                          else if (v.ToUpper().EndsWith("GB"))                              sz = Int64.Parse(v.Substring(0' v.Length - 2)) * 1024 * 1024 * 1024;                          else sz = Int64.Parse(tokens[i + 2]);                            current = new SizeCriterion                          {                              Size = sz'                              Operator = (ComparisonOperator)EnumUtil.Parse(typeof(ComparisonOperator)' tokens[i + 1])                          };                          i += 2;                          stateStack.Push(ParseState.CriterionDone);                          break;                        case "filename":                      case "name":                          {                              if (tokens.Length <= i + 2)                                  throw new ArgumentException(String.Join(" "' tokens' i' tokens.Length - i));                                ComparisonOperator c =                                  (ComparisonOperator)EnumUtil.Parse(typeof(ComparisonOperator)' tokens[i + 1]);                                if (c != ComparisonOperator.NotEqualTo && c != ComparisonOperator.EqualTo)                                  throw new ArgumentException(String.Join(" "' tokens' i' tokens.Length - i));                                string m = tokens[i + 2];                                // handle single-quoted filespecs (used to include                              // spaces in filename patterns)                              if (m.StartsWith("'") && m.EndsWith("'"))                              {                                  // trim off leading and trailing single quotes and                                  // revert the control characters to spaces.                                  m = m.Substring(1' m.Length - 2)                                      .Replace("\u0006"' " ");                              }                                // if (m.StartsWith("'"))                              //     m = m.Replace("\u0006"' " ");                                //Fix for Unix -> NormalizeCriteriaExpression replaces all slashes with backslashes                              if (Path.DirectorySeparatorChar == '/')                                  m = m.Replace('\\'' Path.DirectorySeparatorChar);                                current = new NameCriterion                              {                                  MatchingFileSpec = m'                                  Operator = c                              };                              i += 2;                              stateStack.Push(ParseState.CriterionDone);                          }                          break;                        case "attrs":                      case "attributes":                      case "type":                          {                              if (tokens.Length <= i + 2)                                  throw new ArgumentException(String.Join(" "' tokens' i' tokens.Length - i));                                ComparisonOperator c =                                  (ComparisonOperator)EnumUtil.Parse(typeof(ComparisonOperator)' tokens[i + 1]);                                if (c != ComparisonOperator.NotEqualTo && c != ComparisonOperator.EqualTo)                                  throw new ArgumentException(String.Join(" "' tokens' i' tokens.Length - i));                                current = (tok1 == "type")                                  ? (SelectionCriterion) new TypeCriterion                                      {                                          AttributeString = tokens[i + 2]'                                          Operator = c                                      }                                  : (SelectionCriterion) new AttributesCriterion                                      {                                          AttributeString = tokens[i + 2]'                                          Operator = c                                      };                              i += 2;                              stateStack.Push(ParseState.CriterionDone);                          }                          break;                        case "":                          // NOP                          stateStack.Push(ParseState.Whitespace);                          break;                        default:                          throw new ArgumentException("'" + tokens[i] + "'");                  }
Magic Number,Ionic,FileSelector,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\FileSelector.cs,_ParseCriterion,The following statement contains a magic number: switch (tok1)                  {                      case "and":                      case "xor":                      case "or":                          state = stateStack.Peek();                          if (state != ParseState.CriterionDone)                              throw new ArgumentException(String.Join(" "' tokens' i' tokens.Length - i));                            if (tokens.Length <= i + 3)                              throw new ArgumentException(String.Join(" "' tokens' i' tokens.Length - i));                            pendingConjunction = (LogicalConjunction)Enum.Parse(typeof(LogicalConjunction)' tokens[i].ToUpper()' true);                          current = new CompoundCriterion { Left = current' Right = null' Conjunction = pendingConjunction };                          stateStack.Push(state);                          stateStack.Push(ParseState.ConjunctionPending);                          critStack.Push(current);                          break;                        case "(":                          state = stateStack.Peek();                          if (state != ParseState.Start && state != ParseState.ConjunctionPending && state != ParseState.OpenParen)                              throw new ArgumentException(String.Join(" "' tokens' i' tokens.Length - i));                            if (tokens.Length <= i + 4)                              throw new ArgumentException(String.Join(" "' tokens' i' tokens.Length - i));                            stateStack.Push(ParseState.OpenParen);                          break;                        case ")":                          state = stateStack.Pop();                          if (stateStack.Peek() != ParseState.OpenParen)                              throw new ArgumentException(String.Join(" "' tokens' i' tokens.Length - i));                            stateStack.Pop();                          stateStack.Push(ParseState.CriterionDone);                          break;                        case "atime":                      case "ctime":                      case "mtime":                          if (tokens.Length <= i + 2)                              throw new ArgumentException(String.Join(" "' tokens' i' tokens.Length - i));                            DateTime t;                          try                          {                              t = DateTime.ParseExact(tokens[i + 2]' "yyyy-MM-dd-HH:mm:ss"' null);                          }                          catch (FormatException)                          {                              try                              {                                  t = DateTime.ParseExact(tokens[i + 2]' "yyyy/MM/dd-HH:mm:ss"' null);                              }                              catch (FormatException)                              {                                  try                                  {                                      t = DateTime.ParseExact(tokens[i + 2]' "yyyy/MM/dd"' null);                                  }                                  catch (FormatException)                                  {                                      try                                      {                                          t = DateTime.ParseExact(tokens[i + 2]' "MM/dd/yyyy"' null);                                      }                                      catch (FormatException)                                      {                                          t = DateTime.ParseExact(tokens[i + 2]' "yyyy-MM-dd"' null);                                      }                                  }                              }                          }                          t= DateTime.SpecifyKind(t' DateTimeKind.Local).ToUniversalTime();                          current = new TimeCriterion                          {                              Which = (WhichTime)Enum.Parse(typeof(WhichTime)' tokens[i]' true)'                              Operator = (ComparisonOperator)EnumUtil.Parse(typeof(ComparisonOperator)' tokens[i + 1])'                              Time = t                          };                          i += 2;                          stateStack.Push(ParseState.CriterionDone);                          break;                          case "length":                      case "size":                          if (tokens.Length <= i + 2)                              throw new ArgumentException(String.Join(" "' tokens' i' tokens.Length - i));                            Int64 sz = 0;                          string v = tokens[i + 2];                          if (v.ToUpper().EndsWith("K"))                              sz = Int64.Parse(v.Substring(0' v.Length - 1)) * 1024;                          else if (v.ToUpper().EndsWith("KB"))                              sz = Int64.Parse(v.Substring(0' v.Length - 2)) * 1024;                          else if (v.ToUpper().EndsWith("M"))                              sz = Int64.Parse(v.Substring(0' v.Length - 1)) * 1024 * 1024;                          else if (v.ToUpper().EndsWith("MB"))                              sz = Int64.Parse(v.Substring(0' v.Length - 2)) * 1024 * 1024;                          else if (v.ToUpper().EndsWith("G"))                              sz = Int64.Parse(v.Substring(0' v.Length - 1)) * 1024 * 1024 * 1024;                          else if (v.ToUpper().EndsWith("GB"))                              sz = Int64.Parse(v.Substring(0' v.Length - 2)) * 1024 * 1024 * 1024;                          else sz = Int64.Parse(tokens[i + 2]);                            current = new SizeCriterion                          {                              Size = sz'                              Operator = (ComparisonOperator)EnumUtil.Parse(typeof(ComparisonOperator)' tokens[i + 1])                          };                          i += 2;                          stateStack.Push(ParseState.CriterionDone);                          break;                        case "filename":                      case "name":                          {                              if (tokens.Length <= i + 2)                                  throw new ArgumentException(String.Join(" "' tokens' i' tokens.Length - i));                                ComparisonOperator c =                                  (ComparisonOperator)EnumUtil.Parse(typeof(ComparisonOperator)' tokens[i + 1]);                                if (c != ComparisonOperator.NotEqualTo && c != ComparisonOperator.EqualTo)                                  throw new ArgumentException(String.Join(" "' tokens' i' tokens.Length - i));                                string m = tokens[i + 2];                                // handle single-quoted filespecs (used to include                              // spaces in filename patterns)                              if (m.StartsWith("'") && m.EndsWith("'"))                              {                                  // trim off leading and trailing single quotes and                                  // revert the control characters to spaces.                                  m = m.Substring(1' m.Length - 2)                                      .Replace("\u0006"' " ");                              }                                // if (m.StartsWith("'"))                              //     m = m.Replace("\u0006"' " ");                                //Fix for Unix -> NormalizeCriteriaExpression replaces all slashes with backslashes                              if (Path.DirectorySeparatorChar == '/')                                  m = m.Replace('\\'' Path.DirectorySeparatorChar);                                current = new NameCriterion                              {                                  MatchingFileSpec = m'                                  Operator = c                              };                              i += 2;                              stateStack.Push(ParseState.CriterionDone);                          }                          break;                        case "attrs":                      case "attributes":                      case "type":                          {                              if (tokens.Length <= i + 2)                                  throw new ArgumentException(String.Join(" "' tokens' i' tokens.Length - i));                                ComparisonOperator c =                                  (ComparisonOperator)EnumUtil.Parse(typeof(ComparisonOperator)' tokens[i + 1]);                                if (c != ComparisonOperator.NotEqualTo && c != ComparisonOperator.EqualTo)                                  throw new ArgumentException(String.Join(" "' tokens' i' tokens.Length - i));                                current = (tok1 == "type")                                  ? (SelectionCriterion) new TypeCriterion                                      {                                          AttributeString = tokens[i + 2]'                                          Operator = c                                      }                                  : (SelectionCriterion) new AttributesCriterion                                      {                                          AttributeString = tokens[i + 2]'                                          Operator = c                                      };                              i += 2;                              stateStack.Push(ParseState.CriterionDone);                          }                          break;                        case "":                          // NOP                          stateStack.Push(ParseState.Whitespace);                          break;                        default:                          throw new ArgumentException("'" + tokens[i] + "'");                  }
Magic Number,Ionic,FileSelector,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\FileSelector.cs,_ParseCriterion,The following statement contains a magic number: switch (tok1)                  {                      case "and":                      case "xor":                      case "or":                          state = stateStack.Peek();                          if (state != ParseState.CriterionDone)                              throw new ArgumentException(String.Join(" "' tokens' i' tokens.Length - i));                            if (tokens.Length <= i + 3)                              throw new ArgumentException(String.Join(" "' tokens' i' tokens.Length - i));                            pendingConjunction = (LogicalConjunction)Enum.Parse(typeof(LogicalConjunction)' tokens[i].ToUpper()' true);                          current = new CompoundCriterion { Left = current' Right = null' Conjunction = pendingConjunction };                          stateStack.Push(state);                          stateStack.Push(ParseState.ConjunctionPending);                          critStack.Push(current);                          break;                        case "(":                          state = stateStack.Peek();                          if (state != ParseState.Start && state != ParseState.ConjunctionPending && state != ParseState.OpenParen)                              throw new ArgumentException(String.Join(" "' tokens' i' tokens.Length - i));                            if (tokens.Length <= i + 4)                              throw new ArgumentException(String.Join(" "' tokens' i' tokens.Length - i));                            stateStack.Push(ParseState.OpenParen);                          break;                        case ")":                          state = stateStack.Pop();                          if (stateStack.Peek() != ParseState.OpenParen)                              throw new ArgumentException(String.Join(" "' tokens' i' tokens.Length - i));                            stateStack.Pop();                          stateStack.Push(ParseState.CriterionDone);                          break;                        case "atime":                      case "ctime":                      case "mtime":                          if (tokens.Length <= i + 2)                              throw new ArgumentException(String.Join(" "' tokens' i' tokens.Length - i));                            DateTime t;                          try                          {                              t = DateTime.ParseExact(tokens[i + 2]' "yyyy-MM-dd-HH:mm:ss"' null);                          }                          catch (FormatException)                          {                              try                              {                                  t = DateTime.ParseExact(tokens[i + 2]' "yyyy/MM/dd-HH:mm:ss"' null);                              }                              catch (FormatException)                              {                                  try                                  {                                      t = DateTime.ParseExact(tokens[i + 2]' "yyyy/MM/dd"' null);                                  }                                  catch (FormatException)                                  {                                      try                                      {                                          t = DateTime.ParseExact(tokens[i + 2]' "MM/dd/yyyy"' null);                                      }                                      catch (FormatException)                                      {                                          t = DateTime.ParseExact(tokens[i + 2]' "yyyy-MM-dd"' null);                                      }                                  }                              }                          }                          t= DateTime.SpecifyKind(t' DateTimeKind.Local).ToUniversalTime();                          current = new TimeCriterion                          {                              Which = (WhichTime)Enum.Parse(typeof(WhichTime)' tokens[i]' true)'                              Operator = (ComparisonOperator)EnumUtil.Parse(typeof(ComparisonOperator)' tokens[i + 1])'                              Time = t                          };                          i += 2;                          stateStack.Push(ParseState.CriterionDone);                          break;                          case "length":                      case "size":                          if (tokens.Length <= i + 2)                              throw new ArgumentException(String.Join(" "' tokens' i' tokens.Length - i));                            Int64 sz = 0;                          string v = tokens[i + 2];                          if (v.ToUpper().EndsWith("K"))                              sz = Int64.Parse(v.Substring(0' v.Length - 1)) * 1024;                          else if (v.ToUpper().EndsWith("KB"))                              sz = Int64.Parse(v.Substring(0' v.Length - 2)) * 1024;                          else if (v.ToUpper().EndsWith("M"))                              sz = Int64.Parse(v.Substring(0' v.Length - 1)) * 1024 * 1024;                          else if (v.ToUpper().EndsWith("MB"))                              sz = Int64.Parse(v.Substring(0' v.Length - 2)) * 1024 * 1024;                          else if (v.ToUpper().EndsWith("G"))                              sz = Int64.Parse(v.Substring(0' v.Length - 1)) * 1024 * 1024 * 1024;                          else if (v.ToUpper().EndsWith("GB"))                              sz = Int64.Parse(v.Substring(0' v.Length - 2)) * 1024 * 1024 * 1024;                          else sz = Int64.Parse(tokens[i + 2]);                            current = new SizeCriterion                          {                              Size = sz'                              Operator = (ComparisonOperator)EnumUtil.Parse(typeof(ComparisonOperator)' tokens[i + 1])                          };                          i += 2;                          stateStack.Push(ParseState.CriterionDone);                          break;                        case "filename":                      case "name":                          {                              if (tokens.Length <= i + 2)                                  throw new ArgumentException(String.Join(" "' tokens' i' tokens.Length - i));                                ComparisonOperator c =                                  (ComparisonOperator)EnumUtil.Parse(typeof(ComparisonOperator)' tokens[i + 1]);                                if (c != ComparisonOperator.NotEqualTo && c != ComparisonOperator.EqualTo)                                  throw new ArgumentException(String.Join(" "' tokens' i' tokens.Length - i));                                string m = tokens[i + 2];                                // handle single-quoted filespecs (used to include                              // spaces in filename patterns)                              if (m.StartsWith("'") && m.EndsWith("'"))                              {                                  // trim off leading and trailing single quotes and                                  // revert the control characters to spaces.                                  m = m.Substring(1' m.Length - 2)                                      .Replace("\u0006"' " ");                              }                                // if (m.StartsWith("'"))                              //     m = m.Replace("\u0006"' " ");                                //Fix for Unix -> NormalizeCriteriaExpression replaces all slashes with backslashes                              if (Path.DirectorySeparatorChar == '/')                                  m = m.Replace('\\'' Path.DirectorySeparatorChar);                                current = new NameCriterion                              {                                  MatchingFileSpec = m'                                  Operator = c                              };                              i += 2;                              stateStack.Push(ParseState.CriterionDone);                          }                          break;                        case "attrs":                      case "attributes":                      case "type":                          {                              if (tokens.Length <= i + 2)                                  throw new ArgumentException(String.Join(" "' tokens' i' tokens.Length - i));                                ComparisonOperator c =                                  (ComparisonOperator)EnumUtil.Parse(typeof(ComparisonOperator)' tokens[i + 1]);                                if (c != ComparisonOperator.NotEqualTo && c != ComparisonOperator.EqualTo)                                  throw new ArgumentException(String.Join(" "' tokens' i' tokens.Length - i));                                current = (tok1 == "type")                                  ? (SelectionCriterion) new TypeCriterion                                      {                                          AttributeString = tokens[i + 2]'                                          Operator = c                                      }                                  : (SelectionCriterion) new AttributesCriterion                                      {                                          AttributeString = tokens[i + 2]'                                          Operator = c                                      };                              i += 2;                              stateStack.Push(ParseState.CriterionDone);                          }                          break;                        case "":                          // NOP                          stateStack.Push(ParseState.Whitespace);                          break;                        default:                          throw new ArgumentException("'" + tokens[i] + "'");                  }
Magic Number,Ionic,FileSelector,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\FileSelector.cs,_ParseCriterion,The following statement contains a magic number: switch (tok1)                  {                      case "and":                      case "xor":                      case "or":                          state = stateStack.Peek();                          if (state != ParseState.CriterionDone)                              throw new ArgumentException(String.Join(" "' tokens' i' tokens.Length - i));                            if (tokens.Length <= i + 3)                              throw new ArgumentException(String.Join(" "' tokens' i' tokens.Length - i));                            pendingConjunction = (LogicalConjunction)Enum.Parse(typeof(LogicalConjunction)' tokens[i].ToUpper()' true);                          current = new CompoundCriterion { Left = current' Right = null' Conjunction = pendingConjunction };                          stateStack.Push(state);                          stateStack.Push(ParseState.ConjunctionPending);                          critStack.Push(current);                          break;                        case "(":                          state = stateStack.Peek();                          if (state != ParseState.Start && state != ParseState.ConjunctionPending && state != ParseState.OpenParen)                              throw new ArgumentException(String.Join(" "' tokens' i' tokens.Length - i));                            if (tokens.Length <= i + 4)                              throw new ArgumentException(String.Join(" "' tokens' i' tokens.Length - i));                            stateStack.Push(ParseState.OpenParen);                          break;                        case ")":                          state = stateStack.Pop();                          if (stateStack.Peek() != ParseState.OpenParen)                              throw new ArgumentException(String.Join(" "' tokens' i' tokens.Length - i));                            stateStack.Pop();                          stateStack.Push(ParseState.CriterionDone);                          break;                        case "atime":                      case "ctime":                      case "mtime":                          if (tokens.Length <= i + 2)                              throw new ArgumentException(String.Join(" "' tokens' i' tokens.Length - i));                            DateTime t;                          try                          {                              t = DateTime.ParseExact(tokens[i + 2]' "yyyy-MM-dd-HH:mm:ss"' null);                          }                          catch (FormatException)                          {                              try                              {                                  t = DateTime.ParseExact(tokens[i + 2]' "yyyy/MM/dd-HH:mm:ss"' null);                              }                              catch (FormatException)                              {                                  try                                  {                                      t = DateTime.ParseExact(tokens[i + 2]' "yyyy/MM/dd"' null);                                  }                                  catch (FormatException)                                  {                                      try                                      {                                          t = DateTime.ParseExact(tokens[i + 2]' "MM/dd/yyyy"' null);                                      }                                      catch (FormatException)                                      {                                          t = DateTime.ParseExact(tokens[i + 2]' "yyyy-MM-dd"' null);                                      }                                  }                              }                          }                          t= DateTime.SpecifyKind(t' DateTimeKind.Local).ToUniversalTime();                          current = new TimeCriterion                          {                              Which = (WhichTime)Enum.Parse(typeof(WhichTime)' tokens[i]' true)'                              Operator = (ComparisonOperator)EnumUtil.Parse(typeof(ComparisonOperator)' tokens[i + 1])'                              Time = t                          };                          i += 2;                          stateStack.Push(ParseState.CriterionDone);                          break;                          case "length":                      case "size":                          if (tokens.Length <= i + 2)                              throw new ArgumentException(String.Join(" "' tokens' i' tokens.Length - i));                            Int64 sz = 0;                          string v = tokens[i + 2];                          if (v.ToUpper().EndsWith("K"))                              sz = Int64.Parse(v.Substring(0' v.Length - 1)) * 1024;                          else if (v.ToUpper().EndsWith("KB"))                              sz = Int64.Parse(v.Substring(0' v.Length - 2)) * 1024;                          else if (v.ToUpper().EndsWith("M"))                              sz = Int64.Parse(v.Substring(0' v.Length - 1)) * 1024 * 1024;                          else if (v.ToUpper().EndsWith("MB"))                              sz = Int64.Parse(v.Substring(0' v.Length - 2)) * 1024 * 1024;                          else if (v.ToUpper().EndsWith("G"))                              sz = Int64.Parse(v.Substring(0' v.Length - 1)) * 1024 * 1024 * 1024;                          else if (v.ToUpper().EndsWith("GB"))                              sz = Int64.Parse(v.Substring(0' v.Length - 2)) * 1024 * 1024 * 1024;                          else sz = Int64.Parse(tokens[i + 2]);                            current = new SizeCriterion                          {                              Size = sz'                              Operator = (ComparisonOperator)EnumUtil.Parse(typeof(ComparisonOperator)' tokens[i + 1])                          };                          i += 2;                          stateStack.Push(ParseState.CriterionDone);                          break;                        case "filename":                      case "name":                          {                              if (tokens.Length <= i + 2)                                  throw new ArgumentException(String.Join(" "' tokens' i' tokens.Length - i));                                ComparisonOperator c =                                  (ComparisonOperator)EnumUtil.Parse(typeof(ComparisonOperator)' tokens[i + 1]);                                if (c != ComparisonOperator.NotEqualTo && c != ComparisonOperator.EqualTo)                                  throw new ArgumentException(String.Join(" "' tokens' i' tokens.Length - i));                                string m = tokens[i + 2];                                // handle single-quoted filespecs (used to include                              // spaces in filename patterns)                              if (m.StartsWith("'") && m.EndsWith("'"))                              {                                  // trim off leading and trailing single quotes and                                  // revert the control characters to spaces.                                  m = m.Substring(1' m.Length - 2)                                      .Replace("\u0006"' " ");                              }                                // if (m.StartsWith("'"))                              //     m = m.Replace("\u0006"' " ");                                //Fix for Unix -> NormalizeCriteriaExpression replaces all slashes with backslashes                              if (Path.DirectorySeparatorChar == '/')                                  m = m.Replace('\\'' Path.DirectorySeparatorChar);                                current = new NameCriterion                              {                                  MatchingFileSpec = m'                                  Operator = c                              };                              i += 2;                              stateStack.Push(ParseState.CriterionDone);                          }                          break;                        case "attrs":                      case "attributes":                      case "type":                          {                              if (tokens.Length <= i + 2)                                  throw new ArgumentException(String.Join(" "' tokens' i' tokens.Length - i));                                ComparisonOperator c =                                  (ComparisonOperator)EnumUtil.Parse(typeof(ComparisonOperator)' tokens[i + 1]);                                if (c != ComparisonOperator.NotEqualTo && c != ComparisonOperator.EqualTo)                                  throw new ArgumentException(String.Join(" "' tokens' i' tokens.Length - i));                                current = (tok1 == "type")                                  ? (SelectionCriterion) new TypeCriterion                                      {                                          AttributeString = tokens[i + 2]'                                          Operator = c                                      }                                  : (SelectionCriterion) new AttributesCriterion                                      {                                          AttributeString = tokens[i + 2]'                                          Operator = c                                      };                              i += 2;                              stateStack.Push(ParseState.CriterionDone);                          }                          break;                        case "":                          // NOP                          stateStack.Push(ParseState.Whitespace);                          break;                        default:                          throw new ArgumentException("'" + tokens[i] + "'");                  }
Magic Number,Ionic,FileSelector,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\FileSelector.cs,_ParseCriterion,The following statement contains a magic number: switch (tok1)                  {                      case "and":                      case "xor":                      case "or":                          state = stateStack.Peek();                          if (state != ParseState.CriterionDone)                              throw new ArgumentException(String.Join(" "' tokens' i' tokens.Length - i));                            if (tokens.Length <= i + 3)                              throw new ArgumentException(String.Join(" "' tokens' i' tokens.Length - i));                            pendingConjunction = (LogicalConjunction)Enum.Parse(typeof(LogicalConjunction)' tokens[i].ToUpper()' true);                          current = new CompoundCriterion { Left = current' Right = null' Conjunction = pendingConjunction };                          stateStack.Push(state);                          stateStack.Push(ParseState.ConjunctionPending);                          critStack.Push(current);                          break;                        case "(":                          state = stateStack.Peek();                          if (state != ParseState.Start && state != ParseState.ConjunctionPending && state != ParseState.OpenParen)                              throw new ArgumentException(String.Join(" "' tokens' i' tokens.Length - i));                            if (tokens.Length <= i + 4)                              throw new ArgumentException(String.Join(" "' tokens' i' tokens.Length - i));                            stateStack.Push(ParseState.OpenParen);                          break;                        case ")":                          state = stateStack.Pop();                          if (stateStack.Peek() != ParseState.OpenParen)                              throw new ArgumentException(String.Join(" "' tokens' i' tokens.Length - i));                            stateStack.Pop();                          stateStack.Push(ParseState.CriterionDone);                          break;                        case "atime":                      case "ctime":                      case "mtime":                          if (tokens.Length <= i + 2)                              throw new ArgumentException(String.Join(" "' tokens' i' tokens.Length - i));                            DateTime t;                          try                          {                              t = DateTime.ParseExact(tokens[i + 2]' "yyyy-MM-dd-HH:mm:ss"' null);                          }                          catch (FormatException)                          {                              try                              {                                  t = DateTime.ParseExact(tokens[i + 2]' "yyyy/MM/dd-HH:mm:ss"' null);                              }                              catch (FormatException)                              {                                  try                                  {                                      t = DateTime.ParseExact(tokens[i + 2]' "yyyy/MM/dd"' null);                                  }                                  catch (FormatException)                                  {                                      try                                      {                                          t = DateTime.ParseExact(tokens[i + 2]' "MM/dd/yyyy"' null);                                      }                                      catch (FormatException)                                      {                                          t = DateTime.ParseExact(tokens[i + 2]' "yyyy-MM-dd"' null);                                      }                                  }                              }                          }                          t= DateTime.SpecifyKind(t' DateTimeKind.Local).ToUniversalTime();                          current = new TimeCriterion                          {                              Which = (WhichTime)Enum.Parse(typeof(WhichTime)' tokens[i]' true)'                              Operator = (ComparisonOperator)EnumUtil.Parse(typeof(ComparisonOperator)' tokens[i + 1])'                              Time = t                          };                          i += 2;                          stateStack.Push(ParseState.CriterionDone);                          break;                          case "length":                      case "size":                          if (tokens.Length <= i + 2)                              throw new ArgumentException(String.Join(" "' tokens' i' tokens.Length - i));                            Int64 sz = 0;                          string v = tokens[i + 2];                          if (v.ToUpper().EndsWith("K"))                              sz = Int64.Parse(v.Substring(0' v.Length - 1)) * 1024;                          else if (v.ToUpper().EndsWith("KB"))                              sz = Int64.Parse(v.Substring(0' v.Length - 2)) * 1024;                          else if (v.ToUpper().EndsWith("M"))                              sz = Int64.Parse(v.Substring(0' v.Length - 1)) * 1024 * 1024;                          else if (v.ToUpper().EndsWith("MB"))                              sz = Int64.Parse(v.Substring(0' v.Length - 2)) * 1024 * 1024;                          else if (v.ToUpper().EndsWith("G"))                              sz = Int64.Parse(v.Substring(0' v.Length - 1)) * 1024 * 1024 * 1024;                          else if (v.ToUpper().EndsWith("GB"))                              sz = Int64.Parse(v.Substring(0' v.Length - 2)) * 1024 * 1024 * 1024;                          else sz = Int64.Parse(tokens[i + 2]);                            current = new SizeCriterion                          {                              Size = sz'                              Operator = (ComparisonOperator)EnumUtil.Parse(typeof(ComparisonOperator)' tokens[i + 1])                          };                          i += 2;                          stateStack.Push(ParseState.CriterionDone);                          break;                        case "filename":                      case "name":                          {                              if (tokens.Length <= i + 2)                                  throw new ArgumentException(String.Join(" "' tokens' i' tokens.Length - i));                                ComparisonOperator c =                                  (ComparisonOperator)EnumUtil.Parse(typeof(ComparisonOperator)' tokens[i + 1]);                                if (c != ComparisonOperator.NotEqualTo && c != ComparisonOperator.EqualTo)                                  throw new ArgumentException(String.Join(" "' tokens' i' tokens.Length - i));                                string m = tokens[i + 2];                                // handle single-quoted filespecs (used to include                              // spaces in filename patterns)                              if (m.StartsWith("'") && m.EndsWith("'"))                              {                                  // trim off leading and trailing single quotes and                                  // revert the control characters to spaces.                                  m = m.Substring(1' m.Length - 2)                                      .Replace("\u0006"' " ");                              }                                // if (m.StartsWith("'"))                              //     m = m.Replace("\u0006"' " ");                                //Fix for Unix -> NormalizeCriteriaExpression replaces all slashes with backslashes                              if (Path.DirectorySeparatorChar == '/')                                  m = m.Replace('\\'' Path.DirectorySeparatorChar);                                current = new NameCriterion                              {                                  MatchingFileSpec = m'                                  Operator = c                              };                              i += 2;                              stateStack.Push(ParseState.CriterionDone);                          }                          break;                        case "attrs":                      case "attributes":                      case "type":                          {                              if (tokens.Length <= i + 2)                                  throw new ArgumentException(String.Join(" "' tokens' i' tokens.Length - i));                                ComparisonOperator c =                                  (ComparisonOperator)EnumUtil.Parse(typeof(ComparisonOperator)' tokens[i + 1]);                                if (c != ComparisonOperator.NotEqualTo && c != ComparisonOperator.EqualTo)                                  throw new ArgumentException(String.Join(" "' tokens' i' tokens.Length - i));                                current = (tok1 == "type")                                  ? (SelectionCriterion) new TypeCriterion                                      {                                          AttributeString = tokens[i + 2]'                                          Operator = c                                      }                                  : (SelectionCriterion) new AttributesCriterion                                      {                                          AttributeString = tokens[i + 2]'                                          Operator = c                                      };                              i += 2;                              stateStack.Push(ParseState.CriterionDone);                          }                          break;                        case "":                          // NOP                          stateStack.Push(ParseState.Whitespace);                          break;                        default:                          throw new ArgumentException("'" + tokens[i] + "'");                  }
Magic Number,Ionic,FileSelector,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\FileSelector.cs,_ParseCriterion,The following statement contains a magic number: switch (tok1)                  {                      case "and":                      case "xor":                      case "or":                          state = stateStack.Peek();                          if (state != ParseState.CriterionDone)                              throw new ArgumentException(String.Join(" "' tokens' i' tokens.Length - i));                            if (tokens.Length <= i + 3)                              throw new ArgumentException(String.Join(" "' tokens' i' tokens.Length - i));                            pendingConjunction = (LogicalConjunction)Enum.Parse(typeof(LogicalConjunction)' tokens[i].ToUpper()' true);                          current = new CompoundCriterion { Left = current' Right = null' Conjunction = pendingConjunction };                          stateStack.Push(state);                          stateStack.Push(ParseState.ConjunctionPending);                          critStack.Push(current);                          break;                        case "(":                          state = stateStack.Peek();                          if (state != ParseState.Start && state != ParseState.ConjunctionPending && state != ParseState.OpenParen)                              throw new ArgumentException(String.Join(" "' tokens' i' tokens.Length - i));                            if (tokens.Length <= i + 4)                              throw new ArgumentException(String.Join(" "' tokens' i' tokens.Length - i));                            stateStack.Push(ParseState.OpenParen);                          break;                        case ")":                          state = stateStack.Pop();                          if (stateStack.Peek() != ParseState.OpenParen)                              throw new ArgumentException(String.Join(" "' tokens' i' tokens.Length - i));                            stateStack.Pop();                          stateStack.Push(ParseState.CriterionDone);                          break;                        case "atime":                      case "ctime":                      case "mtime":                          if (tokens.Length <= i + 2)                              throw new ArgumentException(String.Join(" "' tokens' i' tokens.Length - i));                            DateTime t;                          try                          {                              t = DateTime.ParseExact(tokens[i + 2]' "yyyy-MM-dd-HH:mm:ss"' null);                          }                          catch (FormatException)                          {                              try                              {                                  t = DateTime.ParseExact(tokens[i + 2]' "yyyy/MM/dd-HH:mm:ss"' null);                              }                              catch (FormatException)                              {                                  try                                  {                                      t = DateTime.ParseExact(tokens[i + 2]' "yyyy/MM/dd"' null);                                  }                                  catch (FormatException)                                  {                                      try                                      {                                          t = DateTime.ParseExact(tokens[i + 2]' "MM/dd/yyyy"' null);                                      }                                      catch (FormatException)                                      {                                          t = DateTime.ParseExact(tokens[i + 2]' "yyyy-MM-dd"' null);                                      }                                  }                              }                          }                          t= DateTime.SpecifyKind(t' DateTimeKind.Local).ToUniversalTime();                          current = new TimeCriterion                          {                              Which = (WhichTime)Enum.Parse(typeof(WhichTime)' tokens[i]' true)'                              Operator = (ComparisonOperator)EnumUtil.Parse(typeof(ComparisonOperator)' tokens[i + 1])'                              Time = t                          };                          i += 2;                          stateStack.Push(ParseState.CriterionDone);                          break;                          case "length":                      case "size":                          if (tokens.Length <= i + 2)                              throw new ArgumentException(String.Join(" "' tokens' i' tokens.Length - i));                            Int64 sz = 0;                          string v = tokens[i + 2];                          if (v.ToUpper().EndsWith("K"))                              sz = Int64.Parse(v.Substring(0' v.Length - 1)) * 1024;                          else if (v.ToUpper().EndsWith("KB"))                              sz = Int64.Parse(v.Substring(0' v.Length - 2)) * 1024;                          else if (v.ToUpper().EndsWith("M"))                              sz = Int64.Parse(v.Substring(0' v.Length - 1)) * 1024 * 1024;                          else if (v.ToUpper().EndsWith("MB"))                              sz = Int64.Parse(v.Substring(0' v.Length - 2)) * 1024 * 1024;                          else if (v.ToUpper().EndsWith("G"))                              sz = Int64.Parse(v.Substring(0' v.Length - 1)) * 1024 * 1024 * 1024;                          else if (v.ToUpper().EndsWith("GB"))                              sz = Int64.Parse(v.Substring(0' v.Length - 2)) * 1024 * 1024 * 1024;                          else sz = Int64.Parse(tokens[i + 2]);                            current = new SizeCriterion                          {                              Size = sz'                              Operator = (ComparisonOperator)EnumUtil.Parse(typeof(ComparisonOperator)' tokens[i + 1])                          };                          i += 2;                          stateStack.Push(ParseState.CriterionDone);                          break;                        case "filename":                      case "name":                          {                              if (tokens.Length <= i + 2)                                  throw new ArgumentException(String.Join(" "' tokens' i' tokens.Length - i));                                ComparisonOperator c =                                  (ComparisonOperator)EnumUtil.Parse(typeof(ComparisonOperator)' tokens[i + 1]);                                if (c != ComparisonOperator.NotEqualTo && c != ComparisonOperator.EqualTo)                                  throw new ArgumentException(String.Join(" "' tokens' i' tokens.Length - i));                                string m = tokens[i + 2];                                // handle single-quoted filespecs (used to include                              // spaces in filename patterns)                              if (m.StartsWith("'") && m.EndsWith("'"))                              {                                  // trim off leading and trailing single quotes and                                  // revert the control characters to spaces.                                  m = m.Substring(1' m.Length - 2)                                      .Replace("\u0006"' " ");                              }                                // if (m.StartsWith("'"))                              //     m = m.Replace("\u0006"' " ");                                //Fix for Unix -> NormalizeCriteriaExpression replaces all slashes with backslashes                              if (Path.DirectorySeparatorChar == '/')                                  m = m.Replace('\\'' Path.DirectorySeparatorChar);                                current = new NameCriterion                              {                                  MatchingFileSpec = m'                                  Operator = c                              };                              i += 2;                              stateStack.Push(ParseState.CriterionDone);                          }                          break;                        case "attrs":                      case "attributes":                      case "type":                          {                              if (tokens.Length <= i + 2)                                  throw new ArgumentException(String.Join(" "' tokens' i' tokens.Length - i));                                ComparisonOperator c =                                  (ComparisonOperator)EnumUtil.Parse(typeof(ComparisonOperator)' tokens[i + 1]);                                if (c != ComparisonOperator.NotEqualTo && c != ComparisonOperator.EqualTo)                                  throw new ArgumentException(String.Join(" "' tokens' i' tokens.Length - i));                                current = (tok1 == "type")                                  ? (SelectionCriterion) new TypeCriterion                                      {                                          AttributeString = tokens[i + 2]'                                          Operator = c                                      }                                  : (SelectionCriterion) new AttributesCriterion                                      {                                          AttributeString = tokens[i + 2]'                                          Operator = c                                      };                              i += 2;                              stateStack.Push(ParseState.CriterionDone);                          }                          break;                        case "":                          // NOP                          stateStack.Push(ParseState.Whitespace);                          break;                        default:                          throw new ArgumentException("'" + tokens[i] + "'");                  }
Magic Number,Ionic,FileSelector,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\FileSelector.cs,_ParseCriterion,The following statement contains a magic number: switch (tok1)                  {                      case "and":                      case "xor":                      case "or":                          state = stateStack.Peek();                          if (state != ParseState.CriterionDone)                              throw new ArgumentException(String.Join(" "' tokens' i' tokens.Length - i));                            if (tokens.Length <= i + 3)                              throw new ArgumentException(String.Join(" "' tokens' i' tokens.Length - i));                            pendingConjunction = (LogicalConjunction)Enum.Parse(typeof(LogicalConjunction)' tokens[i].ToUpper()' true);                          current = new CompoundCriterion { Left = current' Right = null' Conjunction = pendingConjunction };                          stateStack.Push(state);                          stateStack.Push(ParseState.ConjunctionPending);                          critStack.Push(current);                          break;                        case "(":                          state = stateStack.Peek();                          if (state != ParseState.Start && state != ParseState.ConjunctionPending && state != ParseState.OpenParen)                              throw new ArgumentException(String.Join(" "' tokens' i' tokens.Length - i));                            if (tokens.Length <= i + 4)                              throw new ArgumentException(String.Join(" "' tokens' i' tokens.Length - i));                            stateStack.Push(ParseState.OpenParen);                          break;                        case ")":                          state = stateStack.Pop();                          if (stateStack.Peek() != ParseState.OpenParen)                              throw new ArgumentException(String.Join(" "' tokens' i' tokens.Length - i));                            stateStack.Pop();                          stateStack.Push(ParseState.CriterionDone);                          break;                        case "atime":                      case "ctime":                      case "mtime":                          if (tokens.Length <= i + 2)                              throw new ArgumentException(String.Join(" "' tokens' i' tokens.Length - i));                            DateTime t;                          try                          {                              t = DateTime.ParseExact(tokens[i + 2]' "yyyy-MM-dd-HH:mm:ss"' null);                          }                          catch (FormatException)                          {                              try                              {                                  t = DateTime.ParseExact(tokens[i + 2]' "yyyy/MM/dd-HH:mm:ss"' null);                              }                              catch (FormatException)                              {                                  try                                  {                                      t = DateTime.ParseExact(tokens[i + 2]' "yyyy/MM/dd"' null);                                  }                                  catch (FormatException)                                  {                                      try                                      {                                          t = DateTime.ParseExact(tokens[i + 2]' "MM/dd/yyyy"' null);                                      }                                      catch (FormatException)                                      {                                          t = DateTime.ParseExact(tokens[i + 2]' "yyyy-MM-dd"' null);                                      }                                  }                              }                          }                          t= DateTime.SpecifyKind(t' DateTimeKind.Local).ToUniversalTime();                          current = new TimeCriterion                          {                              Which = (WhichTime)Enum.Parse(typeof(WhichTime)' tokens[i]' true)'                              Operator = (ComparisonOperator)EnumUtil.Parse(typeof(ComparisonOperator)' tokens[i + 1])'                              Time = t                          };                          i += 2;                          stateStack.Push(ParseState.CriterionDone);                          break;                          case "length":                      case "size":                          if (tokens.Length <= i + 2)                              throw new ArgumentException(String.Join(" "' tokens' i' tokens.Length - i));                            Int64 sz = 0;                          string v = tokens[i + 2];                          if (v.ToUpper().EndsWith("K"))                              sz = Int64.Parse(v.Substring(0' v.Length - 1)) * 1024;                          else if (v.ToUpper().EndsWith("KB"))                              sz = Int64.Parse(v.Substring(0' v.Length - 2)) * 1024;                          else if (v.ToUpper().EndsWith("M"))                              sz = Int64.Parse(v.Substring(0' v.Length - 1)) * 1024 * 1024;                          else if (v.ToUpper().EndsWith("MB"))                              sz = Int64.Parse(v.Substring(0' v.Length - 2)) * 1024 * 1024;                          else if (v.ToUpper().EndsWith("G"))                              sz = Int64.Parse(v.Substring(0' v.Length - 1)) * 1024 * 1024 * 1024;                          else if (v.ToUpper().EndsWith("GB"))                              sz = Int64.Parse(v.Substring(0' v.Length - 2)) * 1024 * 1024 * 1024;                          else sz = Int64.Parse(tokens[i + 2]);                            current = new SizeCriterion                          {                              Size = sz'                              Operator = (ComparisonOperator)EnumUtil.Parse(typeof(ComparisonOperator)' tokens[i + 1])                          };                          i += 2;                          stateStack.Push(ParseState.CriterionDone);                          break;                        case "filename":                      case "name":                          {                              if (tokens.Length <= i + 2)                                  throw new ArgumentException(String.Join(" "' tokens' i' tokens.Length - i));                                ComparisonOperator c =                                  (ComparisonOperator)EnumUtil.Parse(typeof(ComparisonOperator)' tokens[i + 1]);                                if (c != ComparisonOperator.NotEqualTo && c != ComparisonOperator.EqualTo)                                  throw new ArgumentException(String.Join(" "' tokens' i' tokens.Length - i));                                string m = tokens[i + 2];                                // handle single-quoted filespecs (used to include                              // spaces in filename patterns)                              if (m.StartsWith("'") && m.EndsWith("'"))                              {                                  // trim off leading and trailing single quotes and                                  // revert the control characters to spaces.                                  m = m.Substring(1' m.Length - 2)                                      .Replace("\u0006"' " ");                              }                                // if (m.StartsWith("'"))                              //     m = m.Replace("\u0006"' " ");                                //Fix for Unix -> NormalizeCriteriaExpression replaces all slashes with backslashes                              if (Path.DirectorySeparatorChar == '/')                                  m = m.Replace('\\'' Path.DirectorySeparatorChar);                                current = new NameCriterion                              {                                  MatchingFileSpec = m'                                  Operator = c                              };                              i += 2;                              stateStack.Push(ParseState.CriterionDone);                          }                          break;                        case "attrs":                      case "attributes":                      case "type":                          {                              if (tokens.Length <= i + 2)                                  throw new ArgumentException(String.Join(" "' tokens' i' tokens.Length - i));                                ComparisonOperator c =                                  (ComparisonOperator)EnumUtil.Parse(typeof(ComparisonOperator)' tokens[i + 1]);                                if (c != ComparisonOperator.NotEqualTo && c != ComparisonOperator.EqualTo)                                  throw new ArgumentException(String.Join(" "' tokens' i' tokens.Length - i));                                current = (tok1 == "type")                                  ? (SelectionCriterion) new TypeCriterion                                      {                                          AttributeString = tokens[i + 2]'                                          Operator = c                                      }                                  : (SelectionCriterion) new AttributesCriterion                                      {                                          AttributeString = tokens[i + 2]'                                          Operator = c                                      };                              i += 2;                              stateStack.Push(ParseState.CriterionDone);                          }                          break;                        case "":                          // NOP                          stateStack.Push(ParseState.Whitespace);                          break;                        default:                          throw new ArgumentException("'" + tokens[i] + "'");                  }
Magic Number,Ionic,FileSelector,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\FileSelector.cs,_ParseCriterion,The following statement contains a magic number: switch (tok1)                  {                      case "and":                      case "xor":                      case "or":                          state = stateStack.Peek();                          if (state != ParseState.CriterionDone)                              throw new ArgumentException(String.Join(" "' tokens' i' tokens.Length - i));                            if (tokens.Length <= i + 3)                              throw new ArgumentException(String.Join(" "' tokens' i' tokens.Length - i));                            pendingConjunction = (LogicalConjunction)Enum.Parse(typeof(LogicalConjunction)' tokens[i].ToUpper()' true);                          current = new CompoundCriterion { Left = current' Right = null' Conjunction = pendingConjunction };                          stateStack.Push(state);                          stateStack.Push(ParseState.ConjunctionPending);                          critStack.Push(current);                          break;                        case "(":                          state = stateStack.Peek();                          if (state != ParseState.Start && state != ParseState.ConjunctionPending && state != ParseState.OpenParen)                              throw new ArgumentException(String.Join(" "' tokens' i' tokens.Length - i));                            if (tokens.Length <= i + 4)                              throw new ArgumentException(String.Join(" "' tokens' i' tokens.Length - i));                            stateStack.Push(ParseState.OpenParen);                          break;                        case ")":                          state = stateStack.Pop();                          if (stateStack.Peek() != ParseState.OpenParen)                              throw new ArgumentException(String.Join(" "' tokens' i' tokens.Length - i));                            stateStack.Pop();                          stateStack.Push(ParseState.CriterionDone);                          break;                        case "atime":                      case "ctime":                      case "mtime":                          if (tokens.Length <= i + 2)                              throw new ArgumentException(String.Join(" "' tokens' i' tokens.Length - i));                            DateTime t;                          try                          {                              t = DateTime.ParseExact(tokens[i + 2]' "yyyy-MM-dd-HH:mm:ss"' null);                          }                          catch (FormatException)                          {                              try                              {                                  t = DateTime.ParseExact(tokens[i + 2]' "yyyy/MM/dd-HH:mm:ss"' null);                              }                              catch (FormatException)                              {                                  try                                  {                                      t = DateTime.ParseExact(tokens[i + 2]' "yyyy/MM/dd"' null);                                  }                                  catch (FormatException)                                  {                                      try                                      {                                          t = DateTime.ParseExact(tokens[i + 2]' "MM/dd/yyyy"' null);                                      }                                      catch (FormatException)                                      {                                          t = DateTime.ParseExact(tokens[i + 2]' "yyyy-MM-dd"' null);                                      }                                  }                              }                          }                          t= DateTime.SpecifyKind(t' DateTimeKind.Local).ToUniversalTime();                          current = new TimeCriterion                          {                              Which = (WhichTime)Enum.Parse(typeof(WhichTime)' tokens[i]' true)'                              Operator = (ComparisonOperator)EnumUtil.Parse(typeof(ComparisonOperator)' tokens[i + 1])'                              Time = t                          };                          i += 2;                          stateStack.Push(ParseState.CriterionDone);                          break;                          case "length":                      case "size":                          if (tokens.Length <= i + 2)                              throw new ArgumentException(String.Join(" "' tokens' i' tokens.Length - i));                            Int64 sz = 0;                          string v = tokens[i + 2];                          if (v.ToUpper().EndsWith("K"))                              sz = Int64.Parse(v.Substring(0' v.Length - 1)) * 1024;                          else if (v.ToUpper().EndsWith("KB"))                              sz = Int64.Parse(v.Substring(0' v.Length - 2)) * 1024;                          else if (v.ToUpper().EndsWith("M"))                              sz = Int64.Parse(v.Substring(0' v.Length - 1)) * 1024 * 1024;                          else if (v.ToUpper().EndsWith("MB"))                              sz = Int64.Parse(v.Substring(0' v.Length - 2)) * 1024 * 1024;                          else if (v.ToUpper().EndsWith("G"))                              sz = Int64.Parse(v.Substring(0' v.Length - 1)) * 1024 * 1024 * 1024;                          else if (v.ToUpper().EndsWith("GB"))                              sz = Int64.Parse(v.Substring(0' v.Length - 2)) * 1024 * 1024 * 1024;                          else sz = Int64.Parse(tokens[i + 2]);                            current = new SizeCriterion                          {                              Size = sz'                              Operator = (ComparisonOperator)EnumUtil.Parse(typeof(ComparisonOperator)' tokens[i + 1])                          };                          i += 2;                          stateStack.Push(ParseState.CriterionDone);                          break;                        case "filename":                      case "name":                          {                              if (tokens.Length <= i + 2)                                  throw new ArgumentException(String.Join(" "' tokens' i' tokens.Length - i));                                ComparisonOperator c =                                  (ComparisonOperator)EnumUtil.Parse(typeof(ComparisonOperator)' tokens[i + 1]);                                if (c != ComparisonOperator.NotEqualTo && c != ComparisonOperator.EqualTo)                                  throw new ArgumentException(String.Join(" "' tokens' i' tokens.Length - i));                                string m = tokens[i + 2];                                // handle single-quoted filespecs (used to include                              // spaces in filename patterns)                              if (m.StartsWith("'") && m.EndsWith("'"))                              {                                  // trim off leading and trailing single quotes and                                  // revert the control characters to spaces.                                  m = m.Substring(1' m.Length - 2)                                      .Replace("\u0006"' " ");                              }                                // if (m.StartsWith("'"))                              //     m = m.Replace("\u0006"' " ");                                //Fix for Unix -> NormalizeCriteriaExpression replaces all slashes with backslashes                              if (Path.DirectorySeparatorChar == '/')                                  m = m.Replace('\\'' Path.DirectorySeparatorChar);                                current = new NameCriterion                              {                                  MatchingFileSpec = m'                                  Operator = c                              };                              i += 2;                              stateStack.Push(ParseState.CriterionDone);                          }                          break;                        case "attrs":                      case "attributes":                      case "type":                          {                              if (tokens.Length <= i + 2)                                  throw new ArgumentException(String.Join(" "' tokens' i' tokens.Length - i));                                ComparisonOperator c =                                  (ComparisonOperator)EnumUtil.Parse(typeof(ComparisonOperator)' tokens[i + 1]);                                if (c != ComparisonOperator.NotEqualTo && c != ComparisonOperator.EqualTo)                                  throw new ArgumentException(String.Join(" "' tokens' i' tokens.Length - i));                                current = (tok1 == "type")                                  ? (SelectionCriterion) new TypeCriterion                                      {                                          AttributeString = tokens[i + 2]'                                          Operator = c                                      }                                  : (SelectionCriterion) new AttributesCriterion                                      {                                          AttributeString = tokens[i + 2]'                                          Operator = c                                      };                              i += 2;                              stateStack.Push(ParseState.CriterionDone);                          }                          break;                        case "":                          // NOP                          stateStack.Push(ParseState.Whitespace);                          break;                        default:                          throw new ArgumentException("'" + tokens[i] + "'");                  }
Missing Default,Ionic.Zip,ZipEntry,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipDirEntry.cs,GetExtractDecompressor,The following switch statement is missing a default case: switch (_CompressionMethod_FromZipFile)              {                  case (short)CompressionMethod.None:                      return input2;                  case (short)CompressionMethod.Deflate:                      return new Zlib.DeflateStream(input2' Zlib.CompressionMode.Decompress' true);  #if BZIP                  case (short)CompressionMethod.BZip2:                      return new BZip2.BZip2InputStream(input2' true);  #endif              }
Missing Default,Ionic.Zip,ZipEntry,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipDirEntry.cs,ProcessExtraField,The following switch statement is missing a default case: switch (headerId)                      {                          case 0x000a:  // NTFS ctime' atime' mtime                              j = ProcessExtraFieldWindowsTimes(buffer' j' dataSize' posn);                              break;                            case 0x5455:  // Unix ctime' atime' mtime                              j = ProcessExtraFieldUnixTimes(buffer' j' dataSize' posn);                              break;                            case 0x5855:  // Info-zip Extra field (outdated)                              // This is outdated' so the field is supported on                              // read only.                              j = ProcessExtraFieldInfoZipTimes(buffer' j' dataSize' posn);                              break;                            case 0x7855:  // Unix uid/gid                              // ignored. DotNetZip does not handle this field.                              break;                            case 0x7875:  // ??                              // ignored.  I could not find documentation on this field'                              // though it appears in some zip files.                              break;                            case 0x0001: // ZIP64                              j = ProcessExtraFieldZip64(buffer' j' dataSize' posn);                              break;    #if AESCRYPTO                          case 0x9901: // WinZip AES encryption is in use.  (workitem 6834)                              // we will handle this extra field only  if compressionmethod is 0x63                              j = ProcessExtraFieldWinZipAes(buffer' j' dataSize' posn);                              break;  #endif                          case 0x0017: // workitem 7968: handle PKWare Strong encryption header                              j = ProcessExtraFieldPkwareStrongEncryption(buffer' j);                              break;                      }
Missing Default,Ionic.Zip,ZipEntry,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipDirEntry.cs,GetEncodedFileNameBytes,The following switch statement is missing a default case: switch(AlternateEncodingUsage)              {                  case ZipOption.Always:                      if (!(_Comment == null || _Comment.Length == 0))                          _CommentBytes = AlternateEncoding.GetBytes(_Comment);                      _actualEncoding = AlternateEncoding;                      return AlternateEncoding.GetBytes(s1);                    case ZipOption.Never:                      if (!(_Comment == null || _Comment.Length == 0))                          _CommentBytes = ibm437.GetBytes(_Comment);                      _actualEncoding = ibm437;                      return ibm437.GetBytes(s1);              }
Missing Default,Ionic.Zip,ZipOutput,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\ZipFile.Save.cs,GetEncoding,The following switch statement is missing a default case: switch (container.AlternateEncodingUsage)              {                  case ZipOption.Always:                      return container.AlternateEncoding;                  case ZipOption.Never:                      return container.DefaultEncoding;              }
Missing Default,Ionic,CompoundCriterion,D:\research\architectureSmells\repos\haf_DotNetZip.Semverd\src\Zip.Shared\FileSelector.cs,Evaluate,The following switch statement is missing a default case: switch (Conjunction)              {                  case LogicalConjunction.AND:                      if (result)                          result = Right.Evaluate(entry);                      break;                  case LogicalConjunction.OR:                      if (!result)                          result = Right.Evaluate(entry);                      break;                  case LogicalConjunction.XOR:                      result ^= Right.Evaluate(entry);                      break;              }
