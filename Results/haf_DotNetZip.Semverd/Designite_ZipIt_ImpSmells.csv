Implementation smell,Namespace,Class,File,Method,Description
Long Method,Ionic.Zip.Examples,ZipIt,C:\repos\haf_DotNetZip.Semverd\src\Tools\ZipIt\ZipIt.cs,Main,The method has 272 lines of code.
Long Statement,Ionic.Zip.Examples,ZipIt,C:\repos\haf_DotNetZip.Semverd\src\Tools\ZipIt\ZipIt.cs,Main,The length of the statement  "                            throw new Exception("Cannot save SFX to stdout' sorry! See http://dotnetzip.codeplex.com/WorkItem/View.aspx?WorkItemId=7246"); " is 126.
Magic Number,Ionic.Zip.Examples,ZipIt,C:\repos\haf_DotNetZip.Semverd\src\Tools\ZipIt\ZipIt.cs,SaveProgress,The following statement contains a magic number: switch(e.EventType)              {                  case ZipProgressEventType.Saving_Started:                      Console.WriteLine("Saving: {0}"' e.ArchiveName);                      break;                    case ZipProgressEventType.Saving_Completed:                      justHadByteUpdate= false;                      Console.WriteLine();                      Console.WriteLine("Done: {0}"' e.ArchiveName);                      break;                    case ZipProgressEventType.Saving_BeforeWriteEntry:                      if (justHadByteUpdate)                          Console.WriteLine();                      Console.WriteLine("  Writing: {0} ({1}/{2})"'                                        e.CurrentEntry.FileName' e.EntriesSaved+1' e.EntriesTotal);                      justHadByteUpdate= false;                      break;                    case ZipProgressEventType.Saving_AfterWriteEntry:                      break;                    case ZipProgressEventType.Saving_EntryBytesRead:                      if (justHadByteUpdate)                          Console.SetCursorPosition(0' Console.CursorTop);                      Console.Write("     {0}/{1} ({2:N0}%)"' e.BytesTransferred' e.TotalBytesToTransfer'                                    e.BytesTransferred / (0.01 * e.TotalBytesToTransfer ));                      justHadByteUpdate= true;                      break;              }
Magic Number,Ionic.Zip.Examples,ZipIt,C:\repos\haf_DotNetZip.Semverd\src\Tools\ZipIt\ZipIt.cs,Main,The following statement contains a magic number: if (args.Length < 2) Usage();
Magic Number,Ionic.Zip.Examples,ZipIt,C:\repos\haf_DotNetZip.Semverd\src\Tools\ZipIt\ZipIt.cs,Main,The following statement contains a magic number: try              {                  Nullable<SelfExtractorFlavor> flavor = null;                  int codePage = 0;                  ZipEntry e = null;                  int _UseUniformTimestamp = 0;                  DateTime _fixedTimestamp= System.DateTime.Now;                  string entryDirectoryPathInArchive = "";                  string directoryOnDisk = null;                  bool recurseDirectories = false;                  bool wantRecurse = false;                  string actualItem;                    // read/update an existing zip' or create a new one.                  using (ZipFile zip = new ZipFile(args[0]))                  {                      zip.StatusMessageTextWriter = System.Console.Out;                      zip.SaveProgress += SaveProgress;                      for (int i = 1; i < args.Length; i++)                      {                          switch (args[i])                          {                              case "-es":                                  zip.ZipErrorAction = ZipErrorAction.Skip;                                  break;                                case "-er":                                  zip.ZipErrorAction = ZipErrorAction.Retry;                                  break;                                case "-eq":                                  zip.ZipErrorAction = ZipErrorAction.Throw;                                  break;                                case "-ea":                                  zip.ZipError += ZipError;                                  break;                                case "-64":                                  zip.UseZip64WhenSaving = Zip64Option.Always;                                  break;                                case "-aes":                                  zip.Encryption = EncryptionAlgorithm.WinZipAes256;                                  break;                                case "-C":                                  i++;                                  if (args.Length <= i) Usage();                                  switch(args[i].ToLower())                                  {                                      case "b":                                      case "bzip":                                      case "bzip2":                                          zip.CompressionMethod = CompressionMethod.BZip2;                                          break;                                      case "d":                                      case "deflate":                                          zip.CompressionMethod = CompressionMethod.Deflate;                                          break;                                      case "n":                                      case "none":                                          zip.CompressionMethod = CompressionMethod.None;                                          break;                                      default:                                          Usage();                                          break;                                  }                                  break;                                case "-cp":                                  i++;                                  if (args.Length <= i) Usage();                                  System.Int32.TryParse(args[i]' out codePage);                                  if (codePage != 0)                                  {                                      zip.AlternateEncoding = System.Text.Encoding.GetEncoding(codePage);                                      zip.AlternateEncodingUsage = ZipOption.Always;                                  }                                  break;                                case "-d":                                  i++;                                  if (args.Length <= i) Usage();                                  entryDirectoryPathInArchive = args[i];                                  break;                                case "-D":                                  i++;                                  if (args.Length <= i) Usage();                                  directoryOnDisk = args[i];                                  break;                                case "-E":                                  i++;                                  if (args.Length <= i) Usage();                                  wantRecurse = recurseDirectories || args[i].Contains("\\");                                  // Console.WriteLine("spec({0})"' args[i]);                                  // Console.WriteLine("dir({0})"' directoryOnDisk);                                  // Console.WriteLine("dirInArc({0})"' entryDirectoryPathInArchive);                                  // Console.WriteLine("recurse({0})"' recurseDirectories);                                  zip.UpdateSelectedFiles(args[i]'                                                          directoryOnDisk'                                                          entryDirectoryPathInArchive'                                                          wantRecurse);                                  break;                                case "-j-":                                  zip.AddDirectoryWillTraverseReparsePoints = false;                                  break;                                case "-j+":                                  zip.AddDirectoryWillTraverseReparsePoints = true;                                  break;                                case "-L":                                  i++;                                  if (args.Length <= i) Usage();                                  zip.CompressionLevel = (Ionic.Zlib.CompressionLevel)                                      System.Int32.Parse(args[i]);                                  break;                                case "-p":                                  i++;                                  if (args.Length <= i) Usage();                                  zip.Password = (args[i] == "") ? null : args[i];                                  break;                                case "-progress":                                  wantProgressReports = true;                                  break;                                case "-r-":                                  recurseDirectories = false;                                  break;                                case "-r+":                                  recurseDirectories = true;                                  break;                                case "-s":                                  i++;                                  if (args.Length <= i) Usage();                                  string entryName = args[i];                                  i++;                                  if (args.Length <= i) Usage();                                  string content = args[i];                                  e = zip.AddEntry(Path.Combine(entryDirectoryPathInArchive' entryName)' content);                                  //                                 if (entryComment != null)                                  //                                 {                                  //                                     e.Comment = entryComment;                                  //                                     entryComment = null;                                  //                                 }                                  break;                                case "-sfx":                                  i++;                                  if (args.Length <= i) Usage();                                  if (args[i] != "w" && args[i] != "c") Usage();                                  flavor = new Nullable<SelfExtractorFlavor>                                      ((args[i] == "w") ? SelfExtractorFlavor.WinFormsApplication : SelfExtractorFlavor.ConsoleApplication);                                  break;                                case "-split":                                  i++;                                  if (args.Length <= i) Usage();                                  if (args[i].EndsWith("K") || args[i].EndsWith("k"))                                      zip.MaxOutputSegmentSize = Int32.Parse(args[i].Substring(0' args[i].Length - 1)) * 1024;                                  else if (args[i].EndsWith("M") || args[i].EndsWith("m"))                                      zip.MaxOutputSegmentSize = Int32.Parse(args[i].Substring(0' args[i].Length - 1)) * 1024 * 1024;                                  else                                      zip.MaxOutputSegmentSize = Int32.Parse(args[i]);                                  break;                                case "-Tw+":                                  zip.EmitTimesInWindowsFormatWhenSaving = true;                                  break;                                case "-Tw-":                                  zip.EmitTimesInWindowsFormatWhenSaving = false;                                  break;                                case "-Tu+":                                  zip.EmitTimesInUnixFormatWhenSaving = true;                                  break;                                case "-Tu-":                                  zip.EmitTimesInUnixFormatWhenSaving = false;                                  break;                                case "-UTnow":                                  _UseUniformTimestamp = 1;                                  _fixedTimestamp = System.DateTime.UtcNow;                                  break;                                case "-UTnewest":                                  _UseUniformTimestamp = 2;                                  break;                                case "-UToldest":                                  _UseUniformTimestamp = 3;                                  break;                                case "-UT":                                  i++;                                  if (args.Length <= i) Usage();                                  _UseUniformTimestamp = 4;                                  try                                  {                                      _fixedTimestamp= System.DateTime.Parse(args[i]);                                  }                                  catch                                  {                                      throw new ArgumentException("-UT");                                  }                                  break;                                case "-utf8":                                  zip.AlternateEncoding = System.Text.Encoding.UTF8;                                  zip.AlternateEncodingUsage = ZipOption.Always;                                  break;    #if NOT                              case "-c":                                  i++;                                  if (args.Length <= i) Usage();                                  entryComment = args[i];  // for the next entry                                  break;  #endif                                case "-zc":                                  i++;                                  if (args.Length <= i) Usage();                                  zip.Comment = args[i];                                  break;                                default:                                  // UpdateItem will add Files or Dirs'                                  // recurses subdirectories                                  actualItem = Path.Combine(directoryOnDisk ?? "."' args[i]);                                  zip.UpdateItem(actualItem' entryDirectoryPathInArchive);                                  break;                          }                      }                        if (_UseUniformTimestamp > 0)                      {                          if (_UseUniformTimestamp==2)                          {                              // newest                              _fixedTimestamp = new System.DateTime(1601'1'1'0'0'0);                              foreach(var entry in zip)                              {                                  if (entry.LastModified > _fixedTimestamp)                                      _fixedTimestamp = entry.LastModified;                              }                          }                          else if (_UseUniformTimestamp==3)                          {                              // oldest                              foreach(var entry in zip)                              {                                  if (entry.LastModified < _fixedTimestamp)                                      _fixedTimestamp = entry.LastModified;                              }                          }                            foreach(var entry in zip)                          {                              entry.LastModified = _fixedTimestamp;                          }                      }                        if (!flavor.HasValue)                      {                          if (saveToStdout)                              zip.Save(Console.OpenStandardOutput());                          else                              zip.Save();                      }                      else                      {                          if (saveToStdout)                              throw new Exception("Cannot save SFX to stdout' sorry! See http://dotnetzip.codeplex.com/WorkItem/View.aspx?WorkItemId=7246");                          zip.SaveSelfExtractor(args[0]' flavor.Value);                        }                    }              }              catch (System.Exception ex1)              {                  System.Console.WriteLine("Exception: " + ex1);              }
Magic Number,Ionic.Zip.Examples,ZipIt,C:\repos\haf_DotNetZip.Semverd\src\Tools\ZipIt\ZipIt.cs,Main,The following statement contains a magic number: try              {                  Nullable<SelfExtractorFlavor> flavor = null;                  int codePage = 0;                  ZipEntry e = null;                  int _UseUniformTimestamp = 0;                  DateTime _fixedTimestamp= System.DateTime.Now;                  string entryDirectoryPathInArchive = "";                  string directoryOnDisk = null;                  bool recurseDirectories = false;                  bool wantRecurse = false;                  string actualItem;                    // read/update an existing zip' or create a new one.                  using (ZipFile zip = new ZipFile(args[0]))                  {                      zip.StatusMessageTextWriter = System.Console.Out;                      zip.SaveProgress += SaveProgress;                      for (int i = 1; i < args.Length; i++)                      {                          switch (args[i])                          {                              case "-es":                                  zip.ZipErrorAction = ZipErrorAction.Skip;                                  break;                                case "-er":                                  zip.ZipErrorAction = ZipErrorAction.Retry;                                  break;                                case "-eq":                                  zip.ZipErrorAction = ZipErrorAction.Throw;                                  break;                                case "-ea":                                  zip.ZipError += ZipError;                                  break;                                case "-64":                                  zip.UseZip64WhenSaving = Zip64Option.Always;                                  break;                                case "-aes":                                  zip.Encryption = EncryptionAlgorithm.WinZipAes256;                                  break;                                case "-C":                                  i++;                                  if (args.Length <= i) Usage();                                  switch(args[i].ToLower())                                  {                                      case "b":                                      case "bzip":                                      case "bzip2":                                          zip.CompressionMethod = CompressionMethod.BZip2;                                          break;                                      case "d":                                      case "deflate":                                          zip.CompressionMethod = CompressionMethod.Deflate;                                          break;                                      case "n":                                      case "none":                                          zip.CompressionMethod = CompressionMethod.None;                                          break;                                      default:                                          Usage();                                          break;                                  }                                  break;                                case "-cp":                                  i++;                                  if (args.Length <= i) Usage();                                  System.Int32.TryParse(args[i]' out codePage);                                  if (codePage != 0)                                  {                                      zip.AlternateEncoding = System.Text.Encoding.GetEncoding(codePage);                                      zip.AlternateEncodingUsage = ZipOption.Always;                                  }                                  break;                                case "-d":                                  i++;                                  if (args.Length <= i) Usage();                                  entryDirectoryPathInArchive = args[i];                                  break;                                case "-D":                                  i++;                                  if (args.Length <= i) Usage();                                  directoryOnDisk = args[i];                                  break;                                case "-E":                                  i++;                                  if (args.Length <= i) Usage();                                  wantRecurse = recurseDirectories || args[i].Contains("\\");                                  // Console.WriteLine("spec({0})"' args[i]);                                  // Console.WriteLine("dir({0})"' directoryOnDisk);                                  // Console.WriteLine("dirInArc({0})"' entryDirectoryPathInArchive);                                  // Console.WriteLine("recurse({0})"' recurseDirectories);                                  zip.UpdateSelectedFiles(args[i]'                                                          directoryOnDisk'                                                          entryDirectoryPathInArchive'                                                          wantRecurse);                                  break;                                case "-j-":                                  zip.AddDirectoryWillTraverseReparsePoints = false;                                  break;                                case "-j+":                                  zip.AddDirectoryWillTraverseReparsePoints = true;                                  break;                                case "-L":                                  i++;                                  if (args.Length <= i) Usage();                                  zip.CompressionLevel = (Ionic.Zlib.CompressionLevel)                                      System.Int32.Parse(args[i]);                                  break;                                case "-p":                                  i++;                                  if (args.Length <= i) Usage();                                  zip.Password = (args[i] == "") ? null : args[i];                                  break;                                case "-progress":                                  wantProgressReports = true;                                  break;                                case "-r-":                                  recurseDirectories = false;                                  break;                                case "-r+":                                  recurseDirectories = true;                                  break;                                case "-s":                                  i++;                                  if (args.Length <= i) Usage();                                  string entryName = args[i];                                  i++;                                  if (args.Length <= i) Usage();                                  string content = args[i];                                  e = zip.AddEntry(Path.Combine(entryDirectoryPathInArchive' entryName)' content);                                  //                                 if (entryComment != null)                                  //                                 {                                  //                                     e.Comment = entryComment;                                  //                                     entryComment = null;                                  //                                 }                                  break;                                case "-sfx":                                  i++;                                  if (args.Length <= i) Usage();                                  if (args[i] != "w" && args[i] != "c") Usage();                                  flavor = new Nullable<SelfExtractorFlavor>                                      ((args[i] == "w") ? SelfExtractorFlavor.WinFormsApplication : SelfExtractorFlavor.ConsoleApplication);                                  break;                                case "-split":                                  i++;                                  if (args.Length <= i) Usage();                                  if (args[i].EndsWith("K") || args[i].EndsWith("k"))                                      zip.MaxOutputSegmentSize = Int32.Parse(args[i].Substring(0' args[i].Length - 1)) * 1024;                                  else if (args[i].EndsWith("M") || args[i].EndsWith("m"))                                      zip.MaxOutputSegmentSize = Int32.Parse(args[i].Substring(0' args[i].Length - 1)) * 1024 * 1024;                                  else                                      zip.MaxOutputSegmentSize = Int32.Parse(args[i]);                                  break;                                case "-Tw+":                                  zip.EmitTimesInWindowsFormatWhenSaving = true;                                  break;                                case "-Tw-":                                  zip.EmitTimesInWindowsFormatWhenSaving = false;                                  break;                                case "-Tu+":                                  zip.EmitTimesInUnixFormatWhenSaving = true;                                  break;                                case "-Tu-":                                  zip.EmitTimesInUnixFormatWhenSaving = false;                                  break;                                case "-UTnow":                                  _UseUniformTimestamp = 1;                                  _fixedTimestamp = System.DateTime.UtcNow;                                  break;                                case "-UTnewest":                                  _UseUniformTimestamp = 2;                                  break;                                case "-UToldest":                                  _UseUniformTimestamp = 3;                                  break;                                case "-UT":                                  i++;                                  if (args.Length <= i) Usage();                                  _UseUniformTimestamp = 4;                                  try                                  {                                      _fixedTimestamp= System.DateTime.Parse(args[i]);                                  }                                  catch                                  {                                      throw new ArgumentException("-UT");                                  }                                  break;                                case "-utf8":                                  zip.AlternateEncoding = System.Text.Encoding.UTF8;                                  zip.AlternateEncodingUsage = ZipOption.Always;                                  break;    #if NOT                              case "-c":                                  i++;                                  if (args.Length <= i) Usage();                                  entryComment = args[i];  // for the next entry                                  break;  #endif                                case "-zc":                                  i++;                                  if (args.Length <= i) Usage();                                  zip.Comment = args[i];                                  break;                                default:                                  // UpdateItem will add Files or Dirs'                                  // recurses subdirectories                                  actualItem = Path.Combine(directoryOnDisk ?? "."' args[i]);                                  zip.UpdateItem(actualItem' entryDirectoryPathInArchive);                                  break;                          }                      }                        if (_UseUniformTimestamp > 0)                      {                          if (_UseUniformTimestamp==2)                          {                              // newest                              _fixedTimestamp = new System.DateTime(1601'1'1'0'0'0);                              foreach(var entry in zip)                              {                                  if (entry.LastModified > _fixedTimestamp)                                      _fixedTimestamp = entry.LastModified;                              }                          }                          else if (_UseUniformTimestamp==3)                          {                              // oldest                              foreach(var entry in zip)                              {                                  if (entry.LastModified < _fixedTimestamp)                                      _fixedTimestamp = entry.LastModified;                              }                          }                            foreach(var entry in zip)                          {                              entry.LastModified = _fixedTimestamp;                          }                      }                        if (!flavor.HasValue)                      {                          if (saveToStdout)                              zip.Save(Console.OpenStandardOutput());                          else                              zip.Save();                      }                      else                      {                          if (saveToStdout)                              throw new Exception("Cannot save SFX to stdout' sorry! See http://dotnetzip.codeplex.com/WorkItem/View.aspx?WorkItemId=7246");                          zip.SaveSelfExtractor(args[0]' flavor.Value);                        }                    }              }              catch (System.Exception ex1)              {                  System.Console.WriteLine("Exception: " + ex1);              }
Magic Number,Ionic.Zip.Examples,ZipIt,C:\repos\haf_DotNetZip.Semverd\src\Tools\ZipIt\ZipIt.cs,Main,The following statement contains a magic number: try              {                  Nullable<SelfExtractorFlavor> flavor = null;                  int codePage = 0;                  ZipEntry e = null;                  int _UseUniformTimestamp = 0;                  DateTime _fixedTimestamp= System.DateTime.Now;                  string entryDirectoryPathInArchive = "";                  string directoryOnDisk = null;                  bool recurseDirectories = false;                  bool wantRecurse = false;                  string actualItem;                    // read/update an existing zip' or create a new one.                  using (ZipFile zip = new ZipFile(args[0]))                  {                      zip.StatusMessageTextWriter = System.Console.Out;                      zip.SaveProgress += SaveProgress;                      for (int i = 1; i < args.Length; i++)                      {                          switch (args[i])                          {                              case "-es":                                  zip.ZipErrorAction = ZipErrorAction.Skip;                                  break;                                case "-er":                                  zip.ZipErrorAction = ZipErrorAction.Retry;                                  break;                                case "-eq":                                  zip.ZipErrorAction = ZipErrorAction.Throw;                                  break;                                case "-ea":                                  zip.ZipError += ZipError;                                  break;                                case "-64":                                  zip.UseZip64WhenSaving = Zip64Option.Always;                                  break;                                case "-aes":                                  zip.Encryption = EncryptionAlgorithm.WinZipAes256;                                  break;                                case "-C":                                  i++;                                  if (args.Length <= i) Usage();                                  switch(args[i].ToLower())                                  {                                      case "b":                                      case "bzip":                                      case "bzip2":                                          zip.CompressionMethod = CompressionMethod.BZip2;                                          break;                                      case "d":                                      case "deflate":                                          zip.CompressionMethod = CompressionMethod.Deflate;                                          break;                                      case "n":                                      case "none":                                          zip.CompressionMethod = CompressionMethod.None;                                          break;                                      default:                                          Usage();                                          break;                                  }                                  break;                                case "-cp":                                  i++;                                  if (args.Length <= i) Usage();                                  System.Int32.TryParse(args[i]' out codePage);                                  if (codePage != 0)                                  {                                      zip.AlternateEncoding = System.Text.Encoding.GetEncoding(codePage);                                      zip.AlternateEncodingUsage = ZipOption.Always;                                  }                                  break;                                case "-d":                                  i++;                                  if (args.Length <= i) Usage();                                  entryDirectoryPathInArchive = args[i];                                  break;                                case "-D":                                  i++;                                  if (args.Length <= i) Usage();                                  directoryOnDisk = args[i];                                  break;                                case "-E":                                  i++;                                  if (args.Length <= i) Usage();                                  wantRecurse = recurseDirectories || args[i].Contains("\\");                                  // Console.WriteLine("spec({0})"' args[i]);                                  // Console.WriteLine("dir({0})"' directoryOnDisk);                                  // Console.WriteLine("dirInArc({0})"' entryDirectoryPathInArchive);                                  // Console.WriteLine("recurse({0})"' recurseDirectories);                                  zip.UpdateSelectedFiles(args[i]'                                                          directoryOnDisk'                                                          entryDirectoryPathInArchive'                                                          wantRecurse);                                  break;                                case "-j-":                                  zip.AddDirectoryWillTraverseReparsePoints = false;                                  break;                                case "-j+":                                  zip.AddDirectoryWillTraverseReparsePoints = true;                                  break;                                case "-L":                                  i++;                                  if (args.Length <= i) Usage();                                  zip.CompressionLevel = (Ionic.Zlib.CompressionLevel)                                      System.Int32.Parse(args[i]);                                  break;                                case "-p":                                  i++;                                  if (args.Length <= i) Usage();                                  zip.Password = (args[i] == "") ? null : args[i];                                  break;                                case "-progress":                                  wantProgressReports = true;                                  break;                                case "-r-":                                  recurseDirectories = false;                                  break;                                case "-r+":                                  recurseDirectories = true;                                  break;                                case "-s":                                  i++;                                  if (args.Length <= i) Usage();                                  string entryName = args[i];                                  i++;                                  if (args.Length <= i) Usage();                                  string content = args[i];                                  e = zip.AddEntry(Path.Combine(entryDirectoryPathInArchive' entryName)' content);                                  //                                 if (entryComment != null)                                  //                                 {                                  //                                     e.Comment = entryComment;                                  //                                     entryComment = null;                                  //                                 }                                  break;                                case "-sfx":                                  i++;                                  if (args.Length <= i) Usage();                                  if (args[i] != "w" && args[i] != "c") Usage();                                  flavor = new Nullable<SelfExtractorFlavor>                                      ((args[i] == "w") ? SelfExtractorFlavor.WinFormsApplication : SelfExtractorFlavor.ConsoleApplication);                                  break;                                case "-split":                                  i++;                                  if (args.Length <= i) Usage();                                  if (args[i].EndsWith("K") || args[i].EndsWith("k"))                                      zip.MaxOutputSegmentSize = Int32.Parse(args[i].Substring(0' args[i].Length - 1)) * 1024;                                  else if (args[i].EndsWith("M") || args[i].EndsWith("m"))                                      zip.MaxOutputSegmentSize = Int32.Parse(args[i].Substring(0' args[i].Length - 1)) * 1024 * 1024;                                  else                                      zip.MaxOutputSegmentSize = Int32.Parse(args[i]);                                  break;                                case "-Tw+":                                  zip.EmitTimesInWindowsFormatWhenSaving = true;                                  break;                                case "-Tw-":                                  zip.EmitTimesInWindowsFormatWhenSaving = false;                                  break;                                case "-Tu+":                                  zip.EmitTimesInUnixFormatWhenSaving = true;                                  break;                                case "-Tu-":                                  zip.EmitTimesInUnixFormatWhenSaving = false;                                  break;                                case "-UTnow":                                  _UseUniformTimestamp = 1;                                  _fixedTimestamp = System.DateTime.UtcNow;                                  break;                                case "-UTnewest":                                  _UseUniformTimestamp = 2;                                  break;                                case "-UToldest":                                  _UseUniformTimestamp = 3;                                  break;                                case "-UT":                                  i++;                                  if (args.Length <= i) Usage();                                  _UseUniformTimestamp = 4;                                  try                                  {                                      _fixedTimestamp= System.DateTime.Parse(args[i]);                                  }                                  catch                                  {                                      throw new ArgumentException("-UT");                                  }                                  break;                                case "-utf8":                                  zip.AlternateEncoding = System.Text.Encoding.UTF8;                                  zip.AlternateEncodingUsage = ZipOption.Always;                                  break;    #if NOT                              case "-c":                                  i++;                                  if (args.Length <= i) Usage();                                  entryComment = args[i];  // for the next entry                                  break;  #endif                                case "-zc":                                  i++;                                  if (args.Length <= i) Usage();                                  zip.Comment = args[i];                                  break;                                default:                                  // UpdateItem will add Files or Dirs'                                  // recurses subdirectories                                  actualItem = Path.Combine(directoryOnDisk ?? "."' args[i]);                                  zip.UpdateItem(actualItem' entryDirectoryPathInArchive);                                  break;                          }                      }                        if (_UseUniformTimestamp > 0)                      {                          if (_UseUniformTimestamp==2)                          {                              // newest                              _fixedTimestamp = new System.DateTime(1601'1'1'0'0'0);                              foreach(var entry in zip)                              {                                  if (entry.LastModified > _fixedTimestamp)                                      _fixedTimestamp = entry.LastModified;                              }                          }                          else if (_UseUniformTimestamp==3)                          {                              // oldest                              foreach(var entry in zip)                              {                                  if (entry.LastModified < _fixedTimestamp)                                      _fixedTimestamp = entry.LastModified;                              }                          }                            foreach(var entry in zip)                          {                              entry.LastModified = _fixedTimestamp;                          }                      }                        if (!flavor.HasValue)                      {                          if (saveToStdout)                              zip.Save(Console.OpenStandardOutput());                          else                              zip.Save();                      }                      else                      {                          if (saveToStdout)                              throw new Exception("Cannot save SFX to stdout' sorry! See http://dotnetzip.codeplex.com/WorkItem/View.aspx?WorkItemId=7246");                          zip.SaveSelfExtractor(args[0]' flavor.Value);                        }                    }              }              catch (System.Exception ex1)              {                  System.Console.WriteLine("Exception: " + ex1);              }
Magic Number,Ionic.Zip.Examples,ZipIt,C:\repos\haf_DotNetZip.Semverd\src\Tools\ZipIt\ZipIt.cs,Main,The following statement contains a magic number: try              {                  Nullable<SelfExtractorFlavor> flavor = null;                  int codePage = 0;                  ZipEntry e = null;                  int _UseUniformTimestamp = 0;                  DateTime _fixedTimestamp= System.DateTime.Now;                  string entryDirectoryPathInArchive = "";                  string directoryOnDisk = null;                  bool recurseDirectories = false;                  bool wantRecurse = false;                  string actualItem;                    // read/update an existing zip' or create a new one.                  using (ZipFile zip = new ZipFile(args[0]))                  {                      zip.StatusMessageTextWriter = System.Console.Out;                      zip.SaveProgress += SaveProgress;                      for (int i = 1; i < args.Length; i++)                      {                          switch (args[i])                          {                              case "-es":                                  zip.ZipErrorAction = ZipErrorAction.Skip;                                  break;                                case "-er":                                  zip.ZipErrorAction = ZipErrorAction.Retry;                                  break;                                case "-eq":                                  zip.ZipErrorAction = ZipErrorAction.Throw;                                  break;                                case "-ea":                                  zip.ZipError += ZipError;                                  break;                                case "-64":                                  zip.UseZip64WhenSaving = Zip64Option.Always;                                  break;                                case "-aes":                                  zip.Encryption = EncryptionAlgorithm.WinZipAes256;                                  break;                                case "-C":                                  i++;                                  if (args.Length <= i) Usage();                                  switch(args[i].ToLower())                                  {                                      case "b":                                      case "bzip":                                      case "bzip2":                                          zip.CompressionMethod = CompressionMethod.BZip2;                                          break;                                      case "d":                                      case "deflate":                                          zip.CompressionMethod = CompressionMethod.Deflate;                                          break;                                      case "n":                                      case "none":                                          zip.CompressionMethod = CompressionMethod.None;                                          break;                                      default:                                          Usage();                                          break;                                  }                                  break;                                case "-cp":                                  i++;                                  if (args.Length <= i) Usage();                                  System.Int32.TryParse(args[i]' out codePage);                                  if (codePage != 0)                                  {                                      zip.AlternateEncoding = System.Text.Encoding.GetEncoding(codePage);                                      zip.AlternateEncodingUsage = ZipOption.Always;                                  }                                  break;                                case "-d":                                  i++;                                  if (args.Length <= i) Usage();                                  entryDirectoryPathInArchive = args[i];                                  break;                                case "-D":                                  i++;                                  if (args.Length <= i) Usage();                                  directoryOnDisk = args[i];                                  break;                                case "-E":                                  i++;                                  if (args.Length <= i) Usage();                                  wantRecurse = recurseDirectories || args[i].Contains("\\");                                  // Console.WriteLine("spec({0})"' args[i]);                                  // Console.WriteLine("dir({0})"' directoryOnDisk);                                  // Console.WriteLine("dirInArc({0})"' entryDirectoryPathInArchive);                                  // Console.WriteLine("recurse({0})"' recurseDirectories);                                  zip.UpdateSelectedFiles(args[i]'                                                          directoryOnDisk'                                                          entryDirectoryPathInArchive'                                                          wantRecurse);                                  break;                                case "-j-":                                  zip.AddDirectoryWillTraverseReparsePoints = false;                                  break;                                case "-j+":                                  zip.AddDirectoryWillTraverseReparsePoints = true;                                  break;                                case "-L":                                  i++;                                  if (args.Length <= i) Usage();                                  zip.CompressionLevel = (Ionic.Zlib.CompressionLevel)                                      System.Int32.Parse(args[i]);                                  break;                                case "-p":                                  i++;                                  if (args.Length <= i) Usage();                                  zip.Password = (args[i] == "") ? null : args[i];                                  break;                                case "-progress":                                  wantProgressReports = true;                                  break;                                case "-r-":                                  recurseDirectories = false;                                  break;                                case "-r+":                                  recurseDirectories = true;                                  break;                                case "-s":                                  i++;                                  if (args.Length <= i) Usage();                                  string entryName = args[i];                                  i++;                                  if (args.Length <= i) Usage();                                  string content = args[i];                                  e = zip.AddEntry(Path.Combine(entryDirectoryPathInArchive' entryName)' content);                                  //                                 if (entryComment != null)                                  //                                 {                                  //                                     e.Comment = entryComment;                                  //                                     entryComment = null;                                  //                                 }                                  break;                                case "-sfx":                                  i++;                                  if (args.Length <= i) Usage();                                  if (args[i] != "w" && args[i] != "c") Usage();                                  flavor = new Nullable<SelfExtractorFlavor>                                      ((args[i] == "w") ? SelfExtractorFlavor.WinFormsApplication : SelfExtractorFlavor.ConsoleApplication);                                  break;                                case "-split":                                  i++;                                  if (args.Length <= i) Usage();                                  if (args[i].EndsWith("K") || args[i].EndsWith("k"))                                      zip.MaxOutputSegmentSize = Int32.Parse(args[i].Substring(0' args[i].Length - 1)) * 1024;                                  else if (args[i].EndsWith("M") || args[i].EndsWith("m"))                                      zip.MaxOutputSegmentSize = Int32.Parse(args[i].Substring(0' args[i].Length - 1)) * 1024 * 1024;                                  else                                      zip.MaxOutputSegmentSize = Int32.Parse(args[i]);                                  break;                                case "-Tw+":                                  zip.EmitTimesInWindowsFormatWhenSaving = true;                                  break;                                case "-Tw-":                                  zip.EmitTimesInWindowsFormatWhenSaving = false;                                  break;                                case "-Tu+":                                  zip.EmitTimesInUnixFormatWhenSaving = true;                                  break;                                case "-Tu-":                                  zip.EmitTimesInUnixFormatWhenSaving = false;                                  break;                                case "-UTnow":                                  _UseUniformTimestamp = 1;                                  _fixedTimestamp = System.DateTime.UtcNow;                                  break;                                case "-UTnewest":                                  _UseUniformTimestamp = 2;                                  break;                                case "-UToldest":                                  _UseUniformTimestamp = 3;                                  break;                                case "-UT":                                  i++;                                  if (args.Length <= i) Usage();                                  _UseUniformTimestamp = 4;                                  try                                  {                                      _fixedTimestamp= System.DateTime.Parse(args[i]);                                  }                                  catch                                  {                                      throw new ArgumentException("-UT");                                  }                                  break;                                case "-utf8":                                  zip.AlternateEncoding = System.Text.Encoding.UTF8;                                  zip.AlternateEncodingUsage = ZipOption.Always;                                  break;    #if NOT                              case "-c":                                  i++;                                  if (args.Length <= i) Usage();                                  entryComment = args[i];  // for the next entry                                  break;  #endif                                case "-zc":                                  i++;                                  if (args.Length <= i) Usage();                                  zip.Comment = args[i];                                  break;                                default:                                  // UpdateItem will add Files or Dirs'                                  // recurses subdirectories                                  actualItem = Path.Combine(directoryOnDisk ?? "."' args[i]);                                  zip.UpdateItem(actualItem' entryDirectoryPathInArchive);                                  break;                          }                      }                        if (_UseUniformTimestamp > 0)                      {                          if (_UseUniformTimestamp==2)                          {                              // newest                              _fixedTimestamp = new System.DateTime(1601'1'1'0'0'0);                              foreach(var entry in zip)                              {                                  if (entry.LastModified > _fixedTimestamp)                                      _fixedTimestamp = entry.LastModified;                              }                          }                          else if (_UseUniformTimestamp==3)                          {                              // oldest                              foreach(var entry in zip)                              {                                  if (entry.LastModified < _fixedTimestamp)                                      _fixedTimestamp = entry.LastModified;                              }                          }                            foreach(var entry in zip)                          {                              entry.LastModified = _fixedTimestamp;                          }                      }                        if (!flavor.HasValue)                      {                          if (saveToStdout)                              zip.Save(Console.OpenStandardOutput());                          else                              zip.Save();                      }                      else                      {                          if (saveToStdout)                              throw new Exception("Cannot save SFX to stdout' sorry! See http://dotnetzip.codeplex.com/WorkItem/View.aspx?WorkItemId=7246");                          zip.SaveSelfExtractor(args[0]' flavor.Value);                        }                    }              }              catch (System.Exception ex1)              {                  System.Console.WriteLine("Exception: " + ex1);              }
Magic Number,Ionic.Zip.Examples,ZipIt,C:\repos\haf_DotNetZip.Semverd\src\Tools\ZipIt\ZipIt.cs,Main,The following statement contains a magic number: try              {                  Nullable<SelfExtractorFlavor> flavor = null;                  int codePage = 0;                  ZipEntry e = null;                  int _UseUniformTimestamp = 0;                  DateTime _fixedTimestamp= System.DateTime.Now;                  string entryDirectoryPathInArchive = "";                  string directoryOnDisk = null;                  bool recurseDirectories = false;                  bool wantRecurse = false;                  string actualItem;                    // read/update an existing zip' or create a new one.                  using (ZipFile zip = new ZipFile(args[0]))                  {                      zip.StatusMessageTextWriter = System.Console.Out;                      zip.SaveProgress += SaveProgress;                      for (int i = 1; i < args.Length; i++)                      {                          switch (args[i])                          {                              case "-es":                                  zip.ZipErrorAction = ZipErrorAction.Skip;                                  break;                                case "-er":                                  zip.ZipErrorAction = ZipErrorAction.Retry;                                  break;                                case "-eq":                                  zip.ZipErrorAction = ZipErrorAction.Throw;                                  break;                                case "-ea":                                  zip.ZipError += ZipError;                                  break;                                case "-64":                                  zip.UseZip64WhenSaving = Zip64Option.Always;                                  break;                                case "-aes":                                  zip.Encryption = EncryptionAlgorithm.WinZipAes256;                                  break;                                case "-C":                                  i++;                                  if (args.Length <= i) Usage();                                  switch(args[i].ToLower())                                  {                                      case "b":                                      case "bzip":                                      case "bzip2":                                          zip.CompressionMethod = CompressionMethod.BZip2;                                          break;                                      case "d":                                      case "deflate":                                          zip.CompressionMethod = CompressionMethod.Deflate;                                          break;                                      case "n":                                      case "none":                                          zip.CompressionMethod = CompressionMethod.None;                                          break;                                      default:                                          Usage();                                          break;                                  }                                  break;                                case "-cp":                                  i++;                                  if (args.Length <= i) Usage();                                  System.Int32.TryParse(args[i]' out codePage);                                  if (codePage != 0)                                  {                                      zip.AlternateEncoding = System.Text.Encoding.GetEncoding(codePage);                                      zip.AlternateEncodingUsage = ZipOption.Always;                                  }                                  break;                                case "-d":                                  i++;                                  if (args.Length <= i) Usage();                                  entryDirectoryPathInArchive = args[i];                                  break;                                case "-D":                                  i++;                                  if (args.Length <= i) Usage();                                  directoryOnDisk = args[i];                                  break;                                case "-E":                                  i++;                                  if (args.Length <= i) Usage();                                  wantRecurse = recurseDirectories || args[i].Contains("\\");                                  // Console.WriteLine("spec({0})"' args[i]);                                  // Console.WriteLine("dir({0})"' directoryOnDisk);                                  // Console.WriteLine("dirInArc({0})"' entryDirectoryPathInArchive);                                  // Console.WriteLine("recurse({0})"' recurseDirectories);                                  zip.UpdateSelectedFiles(args[i]'                                                          directoryOnDisk'                                                          entryDirectoryPathInArchive'                                                          wantRecurse);                                  break;                                case "-j-":                                  zip.AddDirectoryWillTraverseReparsePoints = false;                                  break;                                case "-j+":                                  zip.AddDirectoryWillTraverseReparsePoints = true;                                  break;                                case "-L":                                  i++;                                  if (args.Length <= i) Usage();                                  zip.CompressionLevel = (Ionic.Zlib.CompressionLevel)                                      System.Int32.Parse(args[i]);                                  break;                                case "-p":                                  i++;                                  if (args.Length <= i) Usage();                                  zip.Password = (args[i] == "") ? null : args[i];                                  break;                                case "-progress":                                  wantProgressReports = true;                                  break;                                case "-r-":                                  recurseDirectories = false;                                  break;                                case "-r+":                                  recurseDirectories = true;                                  break;                                case "-s":                                  i++;                                  if (args.Length <= i) Usage();                                  string entryName = args[i];                                  i++;                                  if (args.Length <= i) Usage();                                  string content = args[i];                                  e = zip.AddEntry(Path.Combine(entryDirectoryPathInArchive' entryName)' content);                                  //                                 if (entryComment != null)                                  //                                 {                                  //                                     e.Comment = entryComment;                                  //                                     entryComment = null;                                  //                                 }                                  break;                                case "-sfx":                                  i++;                                  if (args.Length <= i) Usage();                                  if (args[i] != "w" && args[i] != "c") Usage();                                  flavor = new Nullable<SelfExtractorFlavor>                                      ((args[i] == "w") ? SelfExtractorFlavor.WinFormsApplication : SelfExtractorFlavor.ConsoleApplication);                                  break;                                case "-split":                                  i++;                                  if (args.Length <= i) Usage();                                  if (args[i].EndsWith("K") || args[i].EndsWith("k"))                                      zip.MaxOutputSegmentSize = Int32.Parse(args[i].Substring(0' args[i].Length - 1)) * 1024;                                  else if (args[i].EndsWith("M") || args[i].EndsWith("m"))                                      zip.MaxOutputSegmentSize = Int32.Parse(args[i].Substring(0' args[i].Length - 1)) * 1024 * 1024;                                  else                                      zip.MaxOutputSegmentSize = Int32.Parse(args[i]);                                  break;                                case "-Tw+":                                  zip.EmitTimesInWindowsFormatWhenSaving = true;                                  break;                                case "-Tw-":                                  zip.EmitTimesInWindowsFormatWhenSaving = false;                                  break;                                case "-Tu+":                                  zip.EmitTimesInUnixFormatWhenSaving = true;                                  break;                                case "-Tu-":                                  zip.EmitTimesInUnixFormatWhenSaving = false;                                  break;                                case "-UTnow":                                  _UseUniformTimestamp = 1;                                  _fixedTimestamp = System.DateTime.UtcNow;                                  break;                                case "-UTnewest":                                  _UseUniformTimestamp = 2;                                  break;                                case "-UToldest":                                  _UseUniformTimestamp = 3;                                  break;                                case "-UT":                                  i++;                                  if (args.Length <= i) Usage();                                  _UseUniformTimestamp = 4;                                  try                                  {                                      _fixedTimestamp= System.DateTime.Parse(args[i]);                                  }                                  catch                                  {                                      throw new ArgumentException("-UT");                                  }                                  break;                                case "-utf8":                                  zip.AlternateEncoding = System.Text.Encoding.UTF8;                                  zip.AlternateEncodingUsage = ZipOption.Always;                                  break;    #if NOT                              case "-c":                                  i++;                                  if (args.Length <= i) Usage();                                  entryComment = args[i];  // for the next entry                                  break;  #endif                                case "-zc":                                  i++;                                  if (args.Length <= i) Usage();                                  zip.Comment = args[i];                                  break;                                default:                                  // UpdateItem will add Files or Dirs'                                  // recurses subdirectories                                  actualItem = Path.Combine(directoryOnDisk ?? "."' args[i]);                                  zip.UpdateItem(actualItem' entryDirectoryPathInArchive);                                  break;                          }                      }                        if (_UseUniformTimestamp > 0)                      {                          if (_UseUniformTimestamp==2)                          {                              // newest                              _fixedTimestamp = new System.DateTime(1601'1'1'0'0'0);                              foreach(var entry in zip)                              {                                  if (entry.LastModified > _fixedTimestamp)                                      _fixedTimestamp = entry.LastModified;                              }                          }                          else if (_UseUniformTimestamp==3)                          {                              // oldest                              foreach(var entry in zip)                              {                                  if (entry.LastModified < _fixedTimestamp)                                      _fixedTimestamp = entry.LastModified;                              }                          }                            foreach(var entry in zip)                          {                              entry.LastModified = _fixedTimestamp;                          }                      }                        if (!flavor.HasValue)                      {                          if (saveToStdout)                              zip.Save(Console.OpenStandardOutput());                          else                              zip.Save();                      }                      else                      {                          if (saveToStdout)                              throw new Exception("Cannot save SFX to stdout' sorry! See http://dotnetzip.codeplex.com/WorkItem/View.aspx?WorkItemId=7246");                          zip.SaveSelfExtractor(args[0]' flavor.Value);                        }                    }              }              catch (System.Exception ex1)              {                  System.Console.WriteLine("Exception: " + ex1);              }
Magic Number,Ionic.Zip.Examples,ZipIt,C:\repos\haf_DotNetZip.Semverd\src\Tools\ZipIt\ZipIt.cs,Main,The following statement contains a magic number: try              {                  Nullable<SelfExtractorFlavor> flavor = null;                  int codePage = 0;                  ZipEntry e = null;                  int _UseUniformTimestamp = 0;                  DateTime _fixedTimestamp= System.DateTime.Now;                  string entryDirectoryPathInArchive = "";                  string directoryOnDisk = null;                  bool recurseDirectories = false;                  bool wantRecurse = false;                  string actualItem;                    // read/update an existing zip' or create a new one.                  using (ZipFile zip = new ZipFile(args[0]))                  {                      zip.StatusMessageTextWriter = System.Console.Out;                      zip.SaveProgress += SaveProgress;                      for (int i = 1; i < args.Length; i++)                      {                          switch (args[i])                          {                              case "-es":                                  zip.ZipErrorAction = ZipErrorAction.Skip;                                  break;                                case "-er":                                  zip.ZipErrorAction = ZipErrorAction.Retry;                                  break;                                case "-eq":                                  zip.ZipErrorAction = ZipErrorAction.Throw;                                  break;                                case "-ea":                                  zip.ZipError += ZipError;                                  break;                                case "-64":                                  zip.UseZip64WhenSaving = Zip64Option.Always;                                  break;                                case "-aes":                                  zip.Encryption = EncryptionAlgorithm.WinZipAes256;                                  break;                                case "-C":                                  i++;                                  if (args.Length <= i) Usage();                                  switch(args[i].ToLower())                                  {                                      case "b":                                      case "bzip":                                      case "bzip2":                                          zip.CompressionMethod = CompressionMethod.BZip2;                                          break;                                      case "d":                                      case "deflate":                                          zip.CompressionMethod = CompressionMethod.Deflate;                                          break;                                      case "n":                                      case "none":                                          zip.CompressionMethod = CompressionMethod.None;                                          break;                                      default:                                          Usage();                                          break;                                  }                                  break;                                case "-cp":                                  i++;                                  if (args.Length <= i) Usage();                                  System.Int32.TryParse(args[i]' out codePage);                                  if (codePage != 0)                                  {                                      zip.AlternateEncoding = System.Text.Encoding.GetEncoding(codePage);                                      zip.AlternateEncodingUsage = ZipOption.Always;                                  }                                  break;                                case "-d":                                  i++;                                  if (args.Length <= i) Usage();                                  entryDirectoryPathInArchive = args[i];                                  break;                                case "-D":                                  i++;                                  if (args.Length <= i) Usage();                                  directoryOnDisk = args[i];                                  break;                                case "-E":                                  i++;                                  if (args.Length <= i) Usage();                                  wantRecurse = recurseDirectories || args[i].Contains("\\");                                  // Console.WriteLine("spec({0})"' args[i]);                                  // Console.WriteLine("dir({0})"' directoryOnDisk);                                  // Console.WriteLine("dirInArc({0})"' entryDirectoryPathInArchive);                                  // Console.WriteLine("recurse({0})"' recurseDirectories);                                  zip.UpdateSelectedFiles(args[i]'                                                          directoryOnDisk'                                                          entryDirectoryPathInArchive'                                                          wantRecurse);                                  break;                                case "-j-":                                  zip.AddDirectoryWillTraverseReparsePoints = false;                                  break;                                case "-j+":                                  zip.AddDirectoryWillTraverseReparsePoints = true;                                  break;                                case "-L":                                  i++;                                  if (args.Length <= i) Usage();                                  zip.CompressionLevel = (Ionic.Zlib.CompressionLevel)                                      System.Int32.Parse(args[i]);                                  break;                                case "-p":                                  i++;                                  if (args.Length <= i) Usage();                                  zip.Password = (args[i] == "") ? null : args[i];                                  break;                                case "-progress":                                  wantProgressReports = true;                                  break;                                case "-r-":                                  recurseDirectories = false;                                  break;                                case "-r+":                                  recurseDirectories = true;                                  break;                                case "-s":                                  i++;                                  if (args.Length <= i) Usage();                                  string entryName = args[i];                                  i++;                                  if (args.Length <= i) Usage();                                  string content = args[i];                                  e = zip.AddEntry(Path.Combine(entryDirectoryPathInArchive' entryName)' content);                                  //                                 if (entryComment != null)                                  //                                 {                                  //                                     e.Comment = entryComment;                                  //                                     entryComment = null;                                  //                                 }                                  break;                                case "-sfx":                                  i++;                                  if (args.Length <= i) Usage();                                  if (args[i] != "w" && args[i] != "c") Usage();                                  flavor = new Nullable<SelfExtractorFlavor>                                      ((args[i] == "w") ? SelfExtractorFlavor.WinFormsApplication : SelfExtractorFlavor.ConsoleApplication);                                  break;                                case "-split":                                  i++;                                  if (args.Length <= i) Usage();                                  if (args[i].EndsWith("K") || args[i].EndsWith("k"))                                      zip.MaxOutputSegmentSize = Int32.Parse(args[i].Substring(0' args[i].Length - 1)) * 1024;                                  else if (args[i].EndsWith("M") || args[i].EndsWith("m"))                                      zip.MaxOutputSegmentSize = Int32.Parse(args[i].Substring(0' args[i].Length - 1)) * 1024 * 1024;                                  else                                      zip.MaxOutputSegmentSize = Int32.Parse(args[i]);                                  break;                                case "-Tw+":                                  zip.EmitTimesInWindowsFormatWhenSaving = true;                                  break;                                case "-Tw-":                                  zip.EmitTimesInWindowsFormatWhenSaving = false;                                  break;                                case "-Tu+":                                  zip.EmitTimesInUnixFormatWhenSaving = true;                                  break;                                case "-Tu-":                                  zip.EmitTimesInUnixFormatWhenSaving = false;                                  break;                                case "-UTnow":                                  _UseUniformTimestamp = 1;                                  _fixedTimestamp = System.DateTime.UtcNow;                                  break;                                case "-UTnewest":                                  _UseUniformTimestamp = 2;                                  break;                                case "-UToldest":                                  _UseUniformTimestamp = 3;                                  break;                                case "-UT":                                  i++;                                  if (args.Length <= i) Usage();                                  _UseUniformTimestamp = 4;                                  try                                  {                                      _fixedTimestamp= System.DateTime.Parse(args[i]);                                  }                                  catch                                  {                                      throw new ArgumentException("-UT");                                  }                                  break;                                case "-utf8":                                  zip.AlternateEncoding = System.Text.Encoding.UTF8;                                  zip.AlternateEncodingUsage = ZipOption.Always;                                  break;    #if NOT                              case "-c":                                  i++;                                  if (args.Length <= i) Usage();                                  entryComment = args[i];  // for the next entry                                  break;  #endif                                case "-zc":                                  i++;                                  if (args.Length <= i) Usage();                                  zip.Comment = args[i];                                  break;                                default:                                  // UpdateItem will add Files or Dirs'                                  // recurses subdirectories                                  actualItem = Path.Combine(directoryOnDisk ?? "."' args[i]);                                  zip.UpdateItem(actualItem' entryDirectoryPathInArchive);                                  break;                          }                      }                        if (_UseUniformTimestamp > 0)                      {                          if (_UseUniformTimestamp==2)                          {                              // newest                              _fixedTimestamp = new System.DateTime(1601'1'1'0'0'0);                              foreach(var entry in zip)                              {                                  if (entry.LastModified > _fixedTimestamp)                                      _fixedTimestamp = entry.LastModified;                              }                          }                          else if (_UseUniformTimestamp==3)                          {                              // oldest                              foreach(var entry in zip)                              {                                  if (entry.LastModified < _fixedTimestamp)                                      _fixedTimestamp = entry.LastModified;                              }                          }                            foreach(var entry in zip)                          {                              entry.LastModified = _fixedTimestamp;                          }                      }                        if (!flavor.HasValue)                      {                          if (saveToStdout)                              zip.Save(Console.OpenStandardOutput());                          else                              zip.Save();                      }                      else                      {                          if (saveToStdout)                              throw new Exception("Cannot save SFX to stdout' sorry! See http://dotnetzip.codeplex.com/WorkItem/View.aspx?WorkItemId=7246");                          zip.SaveSelfExtractor(args[0]' flavor.Value);                        }                    }              }              catch (System.Exception ex1)              {                  System.Console.WriteLine("Exception: " + ex1);              }
Magic Number,Ionic.Zip.Examples,ZipIt,C:\repos\haf_DotNetZip.Semverd\src\Tools\ZipIt\ZipIt.cs,Main,The following statement contains a magic number: try              {                  Nullable<SelfExtractorFlavor> flavor = null;                  int codePage = 0;                  ZipEntry e = null;                  int _UseUniformTimestamp = 0;                  DateTime _fixedTimestamp= System.DateTime.Now;                  string entryDirectoryPathInArchive = "";                  string directoryOnDisk = null;                  bool recurseDirectories = false;                  bool wantRecurse = false;                  string actualItem;                    // read/update an existing zip' or create a new one.                  using (ZipFile zip = new ZipFile(args[0]))                  {                      zip.StatusMessageTextWriter = System.Console.Out;                      zip.SaveProgress += SaveProgress;                      for (int i = 1; i < args.Length; i++)                      {                          switch (args[i])                          {                              case "-es":                                  zip.ZipErrorAction = ZipErrorAction.Skip;                                  break;                                case "-er":                                  zip.ZipErrorAction = ZipErrorAction.Retry;                                  break;                                case "-eq":                                  zip.ZipErrorAction = ZipErrorAction.Throw;                                  break;                                case "-ea":                                  zip.ZipError += ZipError;                                  break;                                case "-64":                                  zip.UseZip64WhenSaving = Zip64Option.Always;                                  break;                                case "-aes":                                  zip.Encryption = EncryptionAlgorithm.WinZipAes256;                                  break;                                case "-C":                                  i++;                                  if (args.Length <= i) Usage();                                  switch(args[i].ToLower())                                  {                                      case "b":                                      case "bzip":                                      case "bzip2":                                          zip.CompressionMethod = CompressionMethod.BZip2;                                          break;                                      case "d":                                      case "deflate":                                          zip.CompressionMethod = CompressionMethod.Deflate;                                          break;                                      case "n":                                      case "none":                                          zip.CompressionMethod = CompressionMethod.None;                                          break;                                      default:                                          Usage();                                          break;                                  }                                  break;                                case "-cp":                                  i++;                                  if (args.Length <= i) Usage();                                  System.Int32.TryParse(args[i]' out codePage);                                  if (codePage != 0)                                  {                                      zip.AlternateEncoding = System.Text.Encoding.GetEncoding(codePage);                                      zip.AlternateEncodingUsage = ZipOption.Always;                                  }                                  break;                                case "-d":                                  i++;                                  if (args.Length <= i) Usage();                                  entryDirectoryPathInArchive = args[i];                                  break;                                case "-D":                                  i++;                                  if (args.Length <= i) Usage();                                  directoryOnDisk = args[i];                                  break;                                case "-E":                                  i++;                                  if (args.Length <= i) Usage();                                  wantRecurse = recurseDirectories || args[i].Contains("\\");                                  // Console.WriteLine("spec({0})"' args[i]);                                  // Console.WriteLine("dir({0})"' directoryOnDisk);                                  // Console.WriteLine("dirInArc({0})"' entryDirectoryPathInArchive);                                  // Console.WriteLine("recurse({0})"' recurseDirectories);                                  zip.UpdateSelectedFiles(args[i]'                                                          directoryOnDisk'                                                          entryDirectoryPathInArchive'                                                          wantRecurse);                                  break;                                case "-j-":                                  zip.AddDirectoryWillTraverseReparsePoints = false;                                  break;                                case "-j+":                                  zip.AddDirectoryWillTraverseReparsePoints = true;                                  break;                                case "-L":                                  i++;                                  if (args.Length <= i) Usage();                                  zip.CompressionLevel = (Ionic.Zlib.CompressionLevel)                                      System.Int32.Parse(args[i]);                                  break;                                case "-p":                                  i++;                                  if (args.Length <= i) Usage();                                  zip.Password = (args[i] == "") ? null : args[i];                                  break;                                case "-progress":                                  wantProgressReports = true;                                  break;                                case "-r-":                                  recurseDirectories = false;                                  break;                                case "-r+":                                  recurseDirectories = true;                                  break;                                case "-s":                                  i++;                                  if (args.Length <= i) Usage();                                  string entryName = args[i];                                  i++;                                  if (args.Length <= i) Usage();                                  string content = args[i];                                  e = zip.AddEntry(Path.Combine(entryDirectoryPathInArchive' entryName)' content);                                  //                                 if (entryComment != null)                                  //                                 {                                  //                                     e.Comment = entryComment;                                  //                                     entryComment = null;                                  //                                 }                                  break;                                case "-sfx":                                  i++;                                  if (args.Length <= i) Usage();                                  if (args[i] != "w" && args[i] != "c") Usage();                                  flavor = new Nullable<SelfExtractorFlavor>                                      ((args[i] == "w") ? SelfExtractorFlavor.WinFormsApplication : SelfExtractorFlavor.ConsoleApplication);                                  break;                                case "-split":                                  i++;                                  if (args.Length <= i) Usage();                                  if (args[i].EndsWith("K") || args[i].EndsWith("k"))                                      zip.MaxOutputSegmentSize = Int32.Parse(args[i].Substring(0' args[i].Length - 1)) * 1024;                                  else if (args[i].EndsWith("M") || args[i].EndsWith("m"))                                      zip.MaxOutputSegmentSize = Int32.Parse(args[i].Substring(0' args[i].Length - 1)) * 1024 * 1024;                                  else                                      zip.MaxOutputSegmentSize = Int32.Parse(args[i]);                                  break;                                case "-Tw+":                                  zip.EmitTimesInWindowsFormatWhenSaving = true;                                  break;                                case "-Tw-":                                  zip.EmitTimesInWindowsFormatWhenSaving = false;                                  break;                                case "-Tu+":                                  zip.EmitTimesInUnixFormatWhenSaving = true;                                  break;                                case "-Tu-":                                  zip.EmitTimesInUnixFormatWhenSaving = false;                                  break;                                case "-UTnow":                                  _UseUniformTimestamp = 1;                                  _fixedTimestamp = System.DateTime.UtcNow;                                  break;                                case "-UTnewest":                                  _UseUniformTimestamp = 2;                                  break;                                case "-UToldest":                                  _UseUniformTimestamp = 3;                                  break;                                case "-UT":                                  i++;                                  if (args.Length <= i) Usage();                                  _UseUniformTimestamp = 4;                                  try                                  {                                      _fixedTimestamp= System.DateTime.Parse(args[i]);                                  }                                  catch                                  {                                      throw new ArgumentException("-UT");                                  }                                  break;                                case "-utf8":                                  zip.AlternateEncoding = System.Text.Encoding.UTF8;                                  zip.AlternateEncodingUsage = ZipOption.Always;                                  break;    #if NOT                              case "-c":                                  i++;                                  if (args.Length <= i) Usage();                                  entryComment = args[i];  // for the next entry                                  break;  #endif                                case "-zc":                                  i++;                                  if (args.Length <= i) Usage();                                  zip.Comment = args[i];                                  break;                                default:                                  // UpdateItem will add Files or Dirs'                                  // recurses subdirectories                                  actualItem = Path.Combine(directoryOnDisk ?? "."' args[i]);                                  zip.UpdateItem(actualItem' entryDirectoryPathInArchive);                                  break;                          }                      }                        if (_UseUniformTimestamp > 0)                      {                          if (_UseUniformTimestamp==2)                          {                              // newest                              _fixedTimestamp = new System.DateTime(1601'1'1'0'0'0);                              foreach(var entry in zip)                              {                                  if (entry.LastModified > _fixedTimestamp)                                      _fixedTimestamp = entry.LastModified;                              }                          }                          else if (_UseUniformTimestamp==3)                          {                              // oldest                              foreach(var entry in zip)                              {                                  if (entry.LastModified < _fixedTimestamp)                                      _fixedTimestamp = entry.LastModified;                              }                          }                            foreach(var entry in zip)                          {                              entry.LastModified = _fixedTimestamp;                          }                      }                        if (!flavor.HasValue)                      {                          if (saveToStdout)                              zip.Save(Console.OpenStandardOutput());                          else                              zip.Save();                      }                      else                      {                          if (saveToStdout)                              throw new Exception("Cannot save SFX to stdout' sorry! See http://dotnetzip.codeplex.com/WorkItem/View.aspx?WorkItemId=7246");                          zip.SaveSelfExtractor(args[0]' flavor.Value);                        }                    }              }              catch (System.Exception ex1)              {                  System.Console.WriteLine("Exception: " + ex1);              }
Magic Number,Ionic.Zip.Examples,ZipIt,C:\repos\haf_DotNetZip.Semverd\src\Tools\ZipIt\ZipIt.cs,Main,The following statement contains a magic number: try              {                  Nullable<SelfExtractorFlavor> flavor = null;                  int codePage = 0;                  ZipEntry e = null;                  int _UseUniformTimestamp = 0;                  DateTime _fixedTimestamp= System.DateTime.Now;                  string entryDirectoryPathInArchive = "";                  string directoryOnDisk = null;                  bool recurseDirectories = false;                  bool wantRecurse = false;                  string actualItem;                    // read/update an existing zip' or create a new one.                  using (ZipFile zip = new ZipFile(args[0]))                  {                      zip.StatusMessageTextWriter = System.Console.Out;                      zip.SaveProgress += SaveProgress;                      for (int i = 1; i < args.Length; i++)                      {                          switch (args[i])                          {                              case "-es":                                  zip.ZipErrorAction = ZipErrorAction.Skip;                                  break;                                case "-er":                                  zip.ZipErrorAction = ZipErrorAction.Retry;                                  break;                                case "-eq":                                  zip.ZipErrorAction = ZipErrorAction.Throw;                                  break;                                case "-ea":                                  zip.ZipError += ZipError;                                  break;                                case "-64":                                  zip.UseZip64WhenSaving = Zip64Option.Always;                                  break;                                case "-aes":                                  zip.Encryption = EncryptionAlgorithm.WinZipAes256;                                  break;                                case "-C":                                  i++;                                  if (args.Length <= i) Usage();                                  switch(args[i].ToLower())                                  {                                      case "b":                                      case "bzip":                                      case "bzip2":                                          zip.CompressionMethod = CompressionMethod.BZip2;                                          break;                                      case "d":                                      case "deflate":                                          zip.CompressionMethod = CompressionMethod.Deflate;                                          break;                                      case "n":                                      case "none":                                          zip.CompressionMethod = CompressionMethod.None;                                          break;                                      default:                                          Usage();                                          break;                                  }                                  break;                                case "-cp":                                  i++;                                  if (args.Length <= i) Usage();                                  System.Int32.TryParse(args[i]' out codePage);                                  if (codePage != 0)                                  {                                      zip.AlternateEncoding = System.Text.Encoding.GetEncoding(codePage);                                      zip.AlternateEncodingUsage = ZipOption.Always;                                  }                                  break;                                case "-d":                                  i++;                                  if (args.Length <= i) Usage();                                  entryDirectoryPathInArchive = args[i];                                  break;                                case "-D":                                  i++;                                  if (args.Length <= i) Usage();                                  directoryOnDisk = args[i];                                  break;                                case "-E":                                  i++;                                  if (args.Length <= i) Usage();                                  wantRecurse = recurseDirectories || args[i].Contains("\\");                                  // Console.WriteLine("spec({0})"' args[i]);                                  // Console.WriteLine("dir({0})"' directoryOnDisk);                                  // Console.WriteLine("dirInArc({0})"' entryDirectoryPathInArchive);                                  // Console.WriteLine("recurse({0})"' recurseDirectories);                                  zip.UpdateSelectedFiles(args[i]'                                                          directoryOnDisk'                                                          entryDirectoryPathInArchive'                                                          wantRecurse);                                  break;                                case "-j-":                                  zip.AddDirectoryWillTraverseReparsePoints = false;                                  break;                                case "-j+":                                  zip.AddDirectoryWillTraverseReparsePoints = true;                                  break;                                case "-L":                                  i++;                                  if (args.Length <= i) Usage();                                  zip.CompressionLevel = (Ionic.Zlib.CompressionLevel)                                      System.Int32.Parse(args[i]);                                  break;                                case "-p":                                  i++;                                  if (args.Length <= i) Usage();                                  zip.Password = (args[i] == "") ? null : args[i];                                  break;                                case "-progress":                                  wantProgressReports = true;                                  break;                                case "-r-":                                  recurseDirectories = false;                                  break;                                case "-r+":                                  recurseDirectories = true;                                  break;                                case "-s":                                  i++;                                  if (args.Length <= i) Usage();                                  string entryName = args[i];                                  i++;                                  if (args.Length <= i) Usage();                                  string content = args[i];                                  e = zip.AddEntry(Path.Combine(entryDirectoryPathInArchive' entryName)' content);                                  //                                 if (entryComment != null)                                  //                                 {                                  //                                     e.Comment = entryComment;                                  //                                     entryComment = null;                                  //                                 }                                  break;                                case "-sfx":                                  i++;                                  if (args.Length <= i) Usage();                                  if (args[i] != "w" && args[i] != "c") Usage();                                  flavor = new Nullable<SelfExtractorFlavor>                                      ((args[i] == "w") ? SelfExtractorFlavor.WinFormsApplication : SelfExtractorFlavor.ConsoleApplication);                                  break;                                case "-split":                                  i++;                                  if (args.Length <= i) Usage();                                  if (args[i].EndsWith("K") || args[i].EndsWith("k"))                                      zip.MaxOutputSegmentSize = Int32.Parse(args[i].Substring(0' args[i].Length - 1)) * 1024;                                  else if (args[i].EndsWith("M") || args[i].EndsWith("m"))                                      zip.MaxOutputSegmentSize = Int32.Parse(args[i].Substring(0' args[i].Length - 1)) * 1024 * 1024;                                  else                                      zip.MaxOutputSegmentSize = Int32.Parse(args[i]);                                  break;                                case "-Tw+":                                  zip.EmitTimesInWindowsFormatWhenSaving = true;                                  break;                                case "-Tw-":                                  zip.EmitTimesInWindowsFormatWhenSaving = false;                                  break;                                case "-Tu+":                                  zip.EmitTimesInUnixFormatWhenSaving = true;                                  break;                                case "-Tu-":                                  zip.EmitTimesInUnixFormatWhenSaving = false;                                  break;                                case "-UTnow":                                  _UseUniformTimestamp = 1;                                  _fixedTimestamp = System.DateTime.UtcNow;                                  break;                                case "-UTnewest":                                  _UseUniformTimestamp = 2;                                  break;                                case "-UToldest":                                  _UseUniformTimestamp = 3;                                  break;                                case "-UT":                                  i++;                                  if (args.Length <= i) Usage();                                  _UseUniformTimestamp = 4;                                  try                                  {                                      _fixedTimestamp= System.DateTime.Parse(args[i]);                                  }                                  catch                                  {                                      throw new ArgumentException("-UT");                                  }                                  break;                                case "-utf8":                                  zip.AlternateEncoding = System.Text.Encoding.UTF8;                                  zip.AlternateEncodingUsage = ZipOption.Always;                                  break;    #if NOT                              case "-c":                                  i++;                                  if (args.Length <= i) Usage();                                  entryComment = args[i];  // for the next entry                                  break;  #endif                                case "-zc":                                  i++;                                  if (args.Length <= i) Usage();                                  zip.Comment = args[i];                                  break;                                default:                                  // UpdateItem will add Files or Dirs'                                  // recurses subdirectories                                  actualItem = Path.Combine(directoryOnDisk ?? "."' args[i]);                                  zip.UpdateItem(actualItem' entryDirectoryPathInArchive);                                  break;                          }                      }                        if (_UseUniformTimestamp > 0)                      {                          if (_UseUniformTimestamp==2)                          {                              // newest                              _fixedTimestamp = new System.DateTime(1601'1'1'0'0'0);                              foreach(var entry in zip)                              {                                  if (entry.LastModified > _fixedTimestamp)                                      _fixedTimestamp = entry.LastModified;                              }                          }                          else if (_UseUniformTimestamp==3)                          {                              // oldest                              foreach(var entry in zip)                              {                                  if (entry.LastModified < _fixedTimestamp)                                      _fixedTimestamp = entry.LastModified;                              }                          }                            foreach(var entry in zip)                          {                              entry.LastModified = _fixedTimestamp;                          }                      }                        if (!flavor.HasValue)                      {                          if (saveToStdout)                              zip.Save(Console.OpenStandardOutput());                          else                              zip.Save();                      }                      else                      {                          if (saveToStdout)                              throw new Exception("Cannot save SFX to stdout' sorry! See http://dotnetzip.codeplex.com/WorkItem/View.aspx?WorkItemId=7246");                          zip.SaveSelfExtractor(args[0]' flavor.Value);                        }                    }              }              catch (System.Exception ex1)              {                  System.Console.WriteLine("Exception: " + ex1);              }
Magic Number,Ionic.Zip.Examples,ZipIt,C:\repos\haf_DotNetZip.Semverd\src\Tools\ZipIt\ZipIt.cs,Main,The following statement contains a magic number: try              {                  Nullable<SelfExtractorFlavor> flavor = null;                  int codePage = 0;                  ZipEntry e = null;                  int _UseUniformTimestamp = 0;                  DateTime _fixedTimestamp= System.DateTime.Now;                  string entryDirectoryPathInArchive = "";                  string directoryOnDisk = null;                  bool recurseDirectories = false;                  bool wantRecurse = false;                  string actualItem;                    // read/update an existing zip' or create a new one.                  using (ZipFile zip = new ZipFile(args[0]))                  {                      zip.StatusMessageTextWriter = System.Console.Out;                      zip.SaveProgress += SaveProgress;                      for (int i = 1; i < args.Length; i++)                      {                          switch (args[i])                          {                              case "-es":                                  zip.ZipErrorAction = ZipErrorAction.Skip;                                  break;                                case "-er":                                  zip.ZipErrorAction = ZipErrorAction.Retry;                                  break;                                case "-eq":                                  zip.ZipErrorAction = ZipErrorAction.Throw;                                  break;                                case "-ea":                                  zip.ZipError += ZipError;                                  break;                                case "-64":                                  zip.UseZip64WhenSaving = Zip64Option.Always;                                  break;                                case "-aes":                                  zip.Encryption = EncryptionAlgorithm.WinZipAes256;                                  break;                                case "-C":                                  i++;                                  if (args.Length <= i) Usage();                                  switch(args[i].ToLower())                                  {                                      case "b":                                      case "bzip":                                      case "bzip2":                                          zip.CompressionMethod = CompressionMethod.BZip2;                                          break;                                      case "d":                                      case "deflate":                                          zip.CompressionMethod = CompressionMethod.Deflate;                                          break;                                      case "n":                                      case "none":                                          zip.CompressionMethod = CompressionMethod.None;                                          break;                                      default:                                          Usage();                                          break;                                  }                                  break;                                case "-cp":                                  i++;                                  if (args.Length <= i) Usage();                                  System.Int32.TryParse(args[i]' out codePage);                                  if (codePage != 0)                                  {                                      zip.AlternateEncoding = System.Text.Encoding.GetEncoding(codePage);                                      zip.AlternateEncodingUsage = ZipOption.Always;                                  }                                  break;                                case "-d":                                  i++;                                  if (args.Length <= i) Usage();                                  entryDirectoryPathInArchive = args[i];                                  break;                                case "-D":                                  i++;                                  if (args.Length <= i) Usage();                                  directoryOnDisk = args[i];                                  break;                                case "-E":                                  i++;                                  if (args.Length <= i) Usage();                                  wantRecurse = recurseDirectories || args[i].Contains("\\");                                  // Console.WriteLine("spec({0})"' args[i]);                                  // Console.WriteLine("dir({0})"' directoryOnDisk);                                  // Console.WriteLine("dirInArc({0})"' entryDirectoryPathInArchive);                                  // Console.WriteLine("recurse({0})"' recurseDirectories);                                  zip.UpdateSelectedFiles(args[i]'                                                          directoryOnDisk'                                                          entryDirectoryPathInArchive'                                                          wantRecurse);                                  break;                                case "-j-":                                  zip.AddDirectoryWillTraverseReparsePoints = false;                                  break;                                case "-j+":                                  zip.AddDirectoryWillTraverseReparsePoints = true;                                  break;                                case "-L":                                  i++;                                  if (args.Length <= i) Usage();                                  zip.CompressionLevel = (Ionic.Zlib.CompressionLevel)                                      System.Int32.Parse(args[i]);                                  break;                                case "-p":                                  i++;                                  if (args.Length <= i) Usage();                                  zip.Password = (args[i] == "") ? null : args[i];                                  break;                                case "-progress":                                  wantProgressReports = true;                                  break;                                case "-r-":                                  recurseDirectories = false;                                  break;                                case "-r+":                                  recurseDirectories = true;                                  break;                                case "-s":                                  i++;                                  if (args.Length <= i) Usage();                                  string entryName = args[i];                                  i++;                                  if (args.Length <= i) Usage();                                  string content = args[i];                                  e = zip.AddEntry(Path.Combine(entryDirectoryPathInArchive' entryName)' content);                                  //                                 if (entryComment != null)                                  //                                 {                                  //                                     e.Comment = entryComment;                                  //                                     entryComment = null;                                  //                                 }                                  break;                                case "-sfx":                                  i++;                                  if (args.Length <= i) Usage();                                  if (args[i] != "w" && args[i] != "c") Usage();                                  flavor = new Nullable<SelfExtractorFlavor>                                      ((args[i] == "w") ? SelfExtractorFlavor.WinFormsApplication : SelfExtractorFlavor.ConsoleApplication);                                  break;                                case "-split":                                  i++;                                  if (args.Length <= i) Usage();                                  if (args[i].EndsWith("K") || args[i].EndsWith("k"))                                      zip.MaxOutputSegmentSize = Int32.Parse(args[i].Substring(0' args[i].Length - 1)) * 1024;                                  else if (args[i].EndsWith("M") || args[i].EndsWith("m"))                                      zip.MaxOutputSegmentSize = Int32.Parse(args[i].Substring(0' args[i].Length - 1)) * 1024 * 1024;                                  else                                      zip.MaxOutputSegmentSize = Int32.Parse(args[i]);                                  break;                                case "-Tw+":                                  zip.EmitTimesInWindowsFormatWhenSaving = true;                                  break;                                case "-Tw-":                                  zip.EmitTimesInWindowsFormatWhenSaving = false;                                  break;                                case "-Tu+":                                  zip.EmitTimesInUnixFormatWhenSaving = true;                                  break;                                case "-Tu-":                                  zip.EmitTimesInUnixFormatWhenSaving = false;                                  break;                                case "-UTnow":                                  _UseUniformTimestamp = 1;                                  _fixedTimestamp = System.DateTime.UtcNow;                                  break;                                case "-UTnewest":                                  _UseUniformTimestamp = 2;                                  break;                                case "-UToldest":                                  _UseUniformTimestamp = 3;                                  break;                                case "-UT":                                  i++;                                  if (args.Length <= i) Usage();                                  _UseUniformTimestamp = 4;                                  try                                  {                                      _fixedTimestamp= System.DateTime.Parse(args[i]);                                  }                                  catch                                  {                                      throw new ArgumentException("-UT");                                  }                                  break;                                case "-utf8":                                  zip.AlternateEncoding = System.Text.Encoding.UTF8;                                  zip.AlternateEncodingUsage = ZipOption.Always;                                  break;    #if NOT                              case "-c":                                  i++;                                  if (args.Length <= i) Usage();                                  entryComment = args[i];  // for the next entry                                  break;  #endif                                case "-zc":                                  i++;                                  if (args.Length <= i) Usage();                                  zip.Comment = args[i];                                  break;                                default:                                  // UpdateItem will add Files or Dirs'                                  // recurses subdirectories                                  actualItem = Path.Combine(directoryOnDisk ?? "."' args[i]);                                  zip.UpdateItem(actualItem' entryDirectoryPathInArchive);                                  break;                          }                      }                        if (_UseUniformTimestamp > 0)                      {                          if (_UseUniformTimestamp==2)                          {                              // newest                              _fixedTimestamp = new System.DateTime(1601'1'1'0'0'0);                              foreach(var entry in zip)                              {                                  if (entry.LastModified > _fixedTimestamp)                                      _fixedTimestamp = entry.LastModified;                              }                          }                          else if (_UseUniformTimestamp==3)                          {                              // oldest                              foreach(var entry in zip)                              {                                  if (entry.LastModified < _fixedTimestamp)                                      _fixedTimestamp = entry.LastModified;                              }                          }                            foreach(var entry in zip)                          {                              entry.LastModified = _fixedTimestamp;                          }                      }                        if (!flavor.HasValue)                      {                          if (saveToStdout)                              zip.Save(Console.OpenStandardOutput());                          else                              zip.Save();                      }                      else                      {                          if (saveToStdout)                              throw new Exception("Cannot save SFX to stdout' sorry! See http://dotnetzip.codeplex.com/WorkItem/View.aspx?WorkItemId=7246");                          zip.SaveSelfExtractor(args[0]' flavor.Value);                        }                    }              }              catch (System.Exception ex1)              {                  System.Console.WriteLine("Exception: " + ex1);              }
Missing Default,Ionic.Zip.Examples,ZipIt,C:\repos\haf_DotNetZip.Semverd\src\Tools\ZipIt\ZipIt.cs,SaveProgress,The following switch statement is missing a default case: switch(e.EventType)              {                  case ZipProgressEventType.Saving_Started:                      Console.WriteLine("Saving: {0}"' e.ArchiveName);                      break;                    case ZipProgressEventType.Saving_Completed:                      justHadByteUpdate= false;                      Console.WriteLine();                      Console.WriteLine("Done: {0}"' e.ArchiveName);                      break;                    case ZipProgressEventType.Saving_BeforeWriteEntry:                      if (justHadByteUpdate)                          Console.WriteLine();                      Console.WriteLine("  Writing: {0} ({1}/{2})"'                                        e.CurrentEntry.FileName' e.EntriesSaved+1' e.EntriesTotal);                      justHadByteUpdate= false;                      break;                    case ZipProgressEventType.Saving_AfterWriteEntry:                      break;                    case ZipProgressEventType.Saving_EntryBytesRead:                      if (justHadByteUpdate)                          Console.SetCursorPosition(0' Console.CursorTop);                      Console.Write("     {0}/{1} ({2:N0}%)"' e.BytesTransferred' e.TotalBytesToTransfer'                                    e.BytesTransferred / (0.01 * e.TotalBytesToTransfer ));                      justHadByteUpdate= true;                      break;              }
