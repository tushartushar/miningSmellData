Implementation smell,Namespace,Class,File,Method,Description
Long Method,Ionic.Zip.Examples,UnZip,F:\newReposMay17\haf_DotNetZip.Semverd\src\Tools\UnZip\UnZip.cs,Main,The method has 233 lines of code.
Complex Method,Ionic.Zip.Examples,UnZip,F:\newReposMay17\haf_DotNetZip.Semverd\src\Tools\UnZip\UnZip.cs,Main,Cyclomatic complexity of the method is 124
Long Statement,Ionic.Zip.Examples,UnZip,F:\newReposMay17\haf_DotNetZip.Semverd\src\Tools\UnZip\UnZip.cs,Usage,The length of the statement  "	Console.WriteLine ("            Depends on Ionic's DotNetZip library. This is version {0} of the utility."' System.Reflection.Assembly.GetExecutingAssembly ().GetName ().Version.ToString ()); " is 191.
Long Statement,Ionic.Zip.Examples,UnZip,F:\newReposMay17\haf_DotNetZip.Semverd\src\Tools\UnZip\UnZip.cs,Usage,The length of the statement  "	Console.WriteLine ("usage:\n" + "  unzip [options] <zipfile> [<entryname>...]  \n" + "     unzips all files in the archive.\n" + "     options:\n" + "       -                 emit extracted content to stdout.\n" + "       -o                overwrite existing files if necessary.\n" + "       -f                flatten directory structure when extracting.\n" + "       -p <password>     specify password for extraction.\n" + "       -t                test the file for consistency. \n" + "       -q                operate quietly (no verbose messages). \n" + "       -cp <codepage>    extract with the specified numeric codepage.  Only do this if you\n" + "                         know the codepage' and it is neither IBM437 nor UTF-8. If the \n" + "                         codepage you specify here is different than the codepage of \n" + "                         the cmd.exe' then the verbose messages will look odd' but the \n" + "                         files will be extracted properly.\n" + "       -d <directory>    unpack to the specified directory. If none provided' it will\n" + "                         unzip to the current directory.\n" + "       <entryname>       unzip only the specified filename.\n\n" + "  unzip -l <zipfile>\n" + "     lists the entries in the zip archive.\n" + "  unzip -i <zipfile>\n" + "     displays full information about all the entries in the zip archive.\n" + "  unzip -t <zipfile> [-p <password>] [-cp <codepage>]\n" + "     tests the zip archive.\n" + "  unzip -r <zipfile>\n" + "     repairs the zip archive - rewriting the directory.\n" + "  unzip -?\n" + "     displays this message.\n"); " is 1638.
Long Statement,Ionic.Zip.Examples,UnZip,F:\newReposMay17\haf_DotNetZip.Semverd\src\Tools\UnZip\UnZip.cs,Main,The length of the statement  "								System.Console.WriteLine ("\n{1'-22} {2'10}  {3'5}   {4'10}  {5'3} {6'8} {0}"' "Filename"' "Modified"' "Size"' "Ratio"' "Packed"' "pw?"' "CRC"); " is 144.
Long Statement,Ionic.Zip.Examples,UnZip,F:\newReposMay17\haf_DotNetZip.Semverd\src\Tools\UnZip\UnZip.cs,Main,The length of the statement  "							System.Console.WriteLine ("{1'-22} {2'10} {3'5:F0}%   {4'10}  {5'3} {6:X8} {0}"' e.FileName' e.LastModified.ToString ("yyyy-MM-dd HH:mm:ss")' e.UncompressedSize' e.CompressionRatio' e.CompressedSize' (e.UsesEncryption) ? "Y" : "N"' e.Crc); " is 239.
Long Statement,Ionic.Zip.Examples,UnZip,F:\newReposMay17\haf_DotNetZip.Semverd\src\Tools\UnZip\UnZip.cs,Main,The length of the statement  "						System.Console.WriteLine ("{1'-22} {2'10}  {3'5}   {4'10}  {5'3} {6'8} {0}"' zip.Entries.Count.ToString () + " files"' ""' totalUncompressedSize' ""' ""' ""' ""); " is 162.
Magic Number,Ionic.Zip.Examples,UnZip,F:\newReposMay17\haf_DotNetZip.Semverd\src\Tools\UnZip\UnZip.cs,Main,The following statement contains a magic number: try {  	if (action == ActionDesired.Repair) {  		ZipFile.FixZipDirectory (zipfile);  	} else {  		var options = new ReadOptions {  			Encoding = (codePage != 0) ? System.Text.Encoding.GetEncoding (codePage) : null  		};  		using (ZipFile zip = ZipFile.Read (zipfile' options)) {  			if (entriesToExtract.Count > 0) {  				// extract specified entries  				foreach (var entryToExtract in entriesToExtract) {  					// find the entry  					ZipEntry e = zip [entryToExtract];  					if (e == null) {  						System.Console.WriteLine ("  entry ({0}) does not exist in the zip archive."' entryToExtract);  					} else {  						if (wantFlatten)  							e.FileName = System.IO.Path.GetFileName (e.FileName);  						if (password == null) {  							if (e.UsesEncryption)  								System.Console.WriteLine ("  That entry ({0}) requires a password to extract."' entryToExtract);  							else if (extractToConsole)  								e.Extract (outstream);  							else  								e.Extract (targdir' behaviorForExistingFile);  						} else {  							if (extractToConsole)  								e.ExtractWithPassword (outstream' password);  							else  								e.ExtractWithPassword (targdir' behaviorForExistingFile' password);  						}  					}  				}  			} else if (action == ActionDesired.Info) {  				System.Console.WriteLine ("{0}"' zip.Info);  			} else {  				// extract all' or list' or test  				// The logic here does almost the same thing as the ExtractAll() method  				// on the ZipFile class.  But in this case we *could* have control over  				// it' for example only extract files of a certain type' or whose names  				// matched a certain pattern' or whose lastmodified times fit a certain  				// condition' or use a different password for each entry' etc.  We can  				// also display status for each entry' as here.  				Int64 totalUncompressedSize = 0;  				bool header = true;  				foreach (ZipEntry e in zip.EntriesSorted) {  					if (!wantQuiet) {  						if (header) {  							System.Console.WriteLine ("Zipfile: {0}"' zip.Name);  							if ((zip.Comment != null) && (zip.Comment != ""))  								System.Console.WriteLine ("Comment: {0}"' zip.Comment);  							System.Console.WriteLine ("\n{1'-22} {2'10}  {3'5}   {4'10}  {5'3} {6'8} {0}"' "Filename"' "Modified"' "Size"' "Ratio"' "Packed"' "pw?"' "CRC");  							System.Console.WriteLine (new System.String ('-'' 80));  							header = false;  						}  						totalUncompressedSize += e.UncompressedSize;  						System.Console.WriteLine ("{1'-22} {2'10} {3'5:F0}%   {4'10}  {5'3} {6:X8} {0}"' e.FileName' e.LastModified.ToString ("yyyy-MM-dd HH:mm:ss")' e.UncompressedSize' e.CompressionRatio' e.CompressedSize' (e.UsesEncryption) ? "Y" : "N"' e.Crc);  						if ((e.Comment != null) && (e.Comment != ""))  							System.Console.WriteLine ("  Comment: {0}"' e.Comment);  					}  					if (action == ActionDesired.Extract) {  						if (e.UsesEncryption) {  							if (password == null)  								System.Console.WriteLine ("unzip: {0}: Cannot extract this entry without a password."' e.FileName);  							else {  								if (wantFlatten)  									e.FileName = System.IO.Path.GetFileName (e.FileName);  								if (extractToConsole)  									e.ExtractWithPassword (outstream' password);  								else  									e.ExtractWithPassword (targdir' behaviorForExistingFile' password);  							}  						} else {  							if (wantFlatten)  								e.FileName = System.IO.Path.GetFileName (e.FileName);  							if (extractToConsole)  								e.Extract (outstream);  							else  								e.Extract (targdir' behaviorForExistingFile);  						}  					} else if (action == ActionDesired.Test) {  						e.ExtractWithPassword (bitbucket' password);  					}  				}  				// foreach  				if (!wantQuiet) {  					System.Console.WriteLine (new System.String ('-'' 80));  					System.Console.WriteLine ("{1'-22} {2'10}  {3'5}   {4'10}  {5'3} {6'8} {0}"' zip.Entries.Count.ToString () + " files"' ""' totalUncompressedSize' ""' ""' ""' "");  				}  			}  			// else (extract all)  		}  		// end using()' the underlying file is closed.  	}  } catch (System.Exception ex1) {  	System.Console.Error.WriteLine ("exception: " + ex1);  }  
Magic Number,Ionic.Zip.Examples,UnZip,F:\newReposMay17\haf_DotNetZip.Semverd\src\Tools\UnZip\UnZip.cs,Main,The following statement contains a magic number: try {  	if (action == ActionDesired.Repair) {  		ZipFile.FixZipDirectory (zipfile);  	} else {  		var options = new ReadOptions {  			Encoding = (codePage != 0) ? System.Text.Encoding.GetEncoding (codePage) : null  		};  		using (ZipFile zip = ZipFile.Read (zipfile' options)) {  			if (entriesToExtract.Count > 0) {  				// extract specified entries  				foreach (var entryToExtract in entriesToExtract) {  					// find the entry  					ZipEntry e = zip [entryToExtract];  					if (e == null) {  						System.Console.WriteLine ("  entry ({0}) does not exist in the zip archive."' entryToExtract);  					} else {  						if (wantFlatten)  							e.FileName = System.IO.Path.GetFileName (e.FileName);  						if (password == null) {  							if (e.UsesEncryption)  								System.Console.WriteLine ("  That entry ({0}) requires a password to extract."' entryToExtract);  							else if (extractToConsole)  								e.Extract (outstream);  							else  								e.Extract (targdir' behaviorForExistingFile);  						} else {  							if (extractToConsole)  								e.ExtractWithPassword (outstream' password);  							else  								e.ExtractWithPassword (targdir' behaviorForExistingFile' password);  						}  					}  				}  			} else if (action == ActionDesired.Info) {  				System.Console.WriteLine ("{0}"' zip.Info);  			} else {  				// extract all' or list' or test  				// The logic here does almost the same thing as the ExtractAll() method  				// on the ZipFile class.  But in this case we *could* have control over  				// it' for example only extract files of a certain type' or whose names  				// matched a certain pattern' or whose lastmodified times fit a certain  				// condition' or use a different password for each entry' etc.  We can  				// also display status for each entry' as here.  				Int64 totalUncompressedSize = 0;  				bool header = true;  				foreach (ZipEntry e in zip.EntriesSorted) {  					if (!wantQuiet) {  						if (header) {  							System.Console.WriteLine ("Zipfile: {0}"' zip.Name);  							if ((zip.Comment != null) && (zip.Comment != ""))  								System.Console.WriteLine ("Comment: {0}"' zip.Comment);  							System.Console.WriteLine ("\n{1'-22} {2'10}  {3'5}   {4'10}  {5'3} {6'8} {0}"' "Filename"' "Modified"' "Size"' "Ratio"' "Packed"' "pw?"' "CRC");  							System.Console.WriteLine (new System.String ('-'' 80));  							header = false;  						}  						totalUncompressedSize += e.UncompressedSize;  						System.Console.WriteLine ("{1'-22} {2'10} {3'5:F0}%   {4'10}  {5'3} {6:X8} {0}"' e.FileName' e.LastModified.ToString ("yyyy-MM-dd HH:mm:ss")' e.UncompressedSize' e.CompressionRatio' e.CompressedSize' (e.UsesEncryption) ? "Y" : "N"' e.Crc);  						if ((e.Comment != null) && (e.Comment != ""))  							System.Console.WriteLine ("  Comment: {0}"' e.Comment);  					}  					if (action == ActionDesired.Extract) {  						if (e.UsesEncryption) {  							if (password == null)  								System.Console.WriteLine ("unzip: {0}: Cannot extract this entry without a password."' e.FileName);  							else {  								if (wantFlatten)  									e.FileName = System.IO.Path.GetFileName (e.FileName);  								if (extractToConsole)  									e.ExtractWithPassword (outstream' password);  								else  									e.ExtractWithPassword (targdir' behaviorForExistingFile' password);  							}  						} else {  							if (wantFlatten)  								e.FileName = System.IO.Path.GetFileName (e.FileName);  							if (extractToConsole)  								e.Extract (outstream);  							else  								e.Extract (targdir' behaviorForExistingFile);  						}  					} else if (action == ActionDesired.Test) {  						e.ExtractWithPassword (bitbucket' password);  					}  				}  				// foreach  				if (!wantQuiet) {  					System.Console.WriteLine (new System.String ('-'' 80));  					System.Console.WriteLine ("{1'-22} {2'10}  {3'5}   {4'10}  {5'3} {6'8} {0}"' zip.Entries.Count.ToString () + " files"' ""' totalUncompressedSize' ""' ""' ""' "");  				}  			}  			// else (extract all)  		}  		// end using()' the underlying file is closed.  	}  } catch (System.Exception ex1) {  	System.Console.Error.WriteLine ("exception: " + ex1);  }  
Magic Number,Ionic.Zip.Examples,UnZip,F:\newReposMay17\haf_DotNetZip.Semverd\src\Tools\UnZip\UnZip.cs,Main,The following statement contains a magic number: if (action == ActionDesired.Repair) {  	ZipFile.FixZipDirectory (zipfile);  } else {  	var options = new ReadOptions {  		Encoding = (codePage != 0) ? System.Text.Encoding.GetEncoding (codePage) : null  	};  	using (ZipFile zip = ZipFile.Read (zipfile' options)) {  		if (entriesToExtract.Count > 0) {  			// extract specified entries  			foreach (var entryToExtract in entriesToExtract) {  				// find the entry  				ZipEntry e = zip [entryToExtract];  				if (e == null) {  					System.Console.WriteLine ("  entry ({0}) does not exist in the zip archive."' entryToExtract);  				} else {  					if (wantFlatten)  						e.FileName = System.IO.Path.GetFileName (e.FileName);  					if (password == null) {  						if (e.UsesEncryption)  							System.Console.WriteLine ("  That entry ({0}) requires a password to extract."' entryToExtract);  						else if (extractToConsole)  							e.Extract (outstream);  						else  							e.Extract (targdir' behaviorForExistingFile);  					} else {  						if (extractToConsole)  							e.ExtractWithPassword (outstream' password);  						else  							e.ExtractWithPassword (targdir' behaviorForExistingFile' password);  					}  				}  			}  		} else if (action == ActionDesired.Info) {  			System.Console.WriteLine ("{0}"' zip.Info);  		} else {  			// extract all' or list' or test  			// The logic here does almost the same thing as the ExtractAll() method  			// on the ZipFile class.  But in this case we *could* have control over  			// it' for example only extract files of a certain type' or whose names  			// matched a certain pattern' or whose lastmodified times fit a certain  			// condition' or use a different password for each entry' etc.  We can  			// also display status for each entry' as here.  			Int64 totalUncompressedSize = 0;  			bool header = true;  			foreach (ZipEntry e in zip.EntriesSorted) {  				if (!wantQuiet) {  					if (header) {  						System.Console.WriteLine ("Zipfile: {0}"' zip.Name);  						if ((zip.Comment != null) && (zip.Comment != ""))  							System.Console.WriteLine ("Comment: {0}"' zip.Comment);  						System.Console.WriteLine ("\n{1'-22} {2'10}  {3'5}   {4'10}  {5'3} {6'8} {0}"' "Filename"' "Modified"' "Size"' "Ratio"' "Packed"' "pw?"' "CRC");  						System.Console.WriteLine (new System.String ('-'' 80));  						header = false;  					}  					totalUncompressedSize += e.UncompressedSize;  					System.Console.WriteLine ("{1'-22} {2'10} {3'5:F0}%   {4'10}  {5'3} {6:X8} {0}"' e.FileName' e.LastModified.ToString ("yyyy-MM-dd HH:mm:ss")' e.UncompressedSize' e.CompressionRatio' e.CompressedSize' (e.UsesEncryption) ? "Y" : "N"' e.Crc);  					if ((e.Comment != null) && (e.Comment != ""))  						System.Console.WriteLine ("  Comment: {0}"' e.Comment);  				}  				if (action == ActionDesired.Extract) {  					if (e.UsesEncryption) {  						if (password == null)  							System.Console.WriteLine ("unzip: {0}: Cannot extract this entry without a password."' e.FileName);  						else {  							if (wantFlatten)  								e.FileName = System.IO.Path.GetFileName (e.FileName);  							if (extractToConsole)  								e.ExtractWithPassword (outstream' password);  							else  								e.ExtractWithPassword (targdir' behaviorForExistingFile' password);  						}  					} else {  						if (wantFlatten)  							e.FileName = System.IO.Path.GetFileName (e.FileName);  						if (extractToConsole)  							e.Extract (outstream);  						else  							e.Extract (targdir' behaviorForExistingFile);  					}  				} else if (action == ActionDesired.Test) {  					e.ExtractWithPassword (bitbucket' password);  				}  			}  			// foreach  			if (!wantQuiet) {  				System.Console.WriteLine (new System.String ('-'' 80));  				System.Console.WriteLine ("{1'-22} {2'10}  {3'5}   {4'10}  {5'3} {6'8} {0}"' zip.Entries.Count.ToString () + " files"' ""' totalUncompressedSize' ""' ""' ""' "");  			}  		}  		// else (extract all)  	}  	// end using()' the underlying file is closed.  }  
Magic Number,Ionic.Zip.Examples,UnZip,F:\newReposMay17\haf_DotNetZip.Semverd\src\Tools\UnZip\UnZip.cs,Main,The following statement contains a magic number: if (action == ActionDesired.Repair) {  	ZipFile.FixZipDirectory (zipfile);  } else {  	var options = new ReadOptions {  		Encoding = (codePage != 0) ? System.Text.Encoding.GetEncoding (codePage) : null  	};  	using (ZipFile zip = ZipFile.Read (zipfile' options)) {  		if (entriesToExtract.Count > 0) {  			// extract specified entries  			foreach (var entryToExtract in entriesToExtract) {  				// find the entry  				ZipEntry e = zip [entryToExtract];  				if (e == null) {  					System.Console.WriteLine ("  entry ({0}) does not exist in the zip archive."' entryToExtract);  				} else {  					if (wantFlatten)  						e.FileName = System.IO.Path.GetFileName (e.FileName);  					if (password == null) {  						if (e.UsesEncryption)  							System.Console.WriteLine ("  That entry ({0}) requires a password to extract."' entryToExtract);  						else if (extractToConsole)  							e.Extract (outstream);  						else  							e.Extract (targdir' behaviorForExistingFile);  					} else {  						if (extractToConsole)  							e.ExtractWithPassword (outstream' password);  						else  							e.ExtractWithPassword (targdir' behaviorForExistingFile' password);  					}  				}  			}  		} else if (action == ActionDesired.Info) {  			System.Console.WriteLine ("{0}"' zip.Info);  		} else {  			// extract all' or list' or test  			// The logic here does almost the same thing as the ExtractAll() method  			// on the ZipFile class.  But in this case we *could* have control over  			// it' for example only extract files of a certain type' or whose names  			// matched a certain pattern' or whose lastmodified times fit a certain  			// condition' or use a different password for each entry' etc.  We can  			// also display status for each entry' as here.  			Int64 totalUncompressedSize = 0;  			bool header = true;  			foreach (ZipEntry e in zip.EntriesSorted) {  				if (!wantQuiet) {  					if (header) {  						System.Console.WriteLine ("Zipfile: {0}"' zip.Name);  						if ((zip.Comment != null) && (zip.Comment != ""))  							System.Console.WriteLine ("Comment: {0}"' zip.Comment);  						System.Console.WriteLine ("\n{1'-22} {2'10}  {3'5}   {4'10}  {5'3} {6'8} {0}"' "Filename"' "Modified"' "Size"' "Ratio"' "Packed"' "pw?"' "CRC");  						System.Console.WriteLine (new System.String ('-'' 80));  						header = false;  					}  					totalUncompressedSize += e.UncompressedSize;  					System.Console.WriteLine ("{1'-22} {2'10} {3'5:F0}%   {4'10}  {5'3} {6:X8} {0}"' e.FileName' e.LastModified.ToString ("yyyy-MM-dd HH:mm:ss")' e.UncompressedSize' e.CompressionRatio' e.CompressedSize' (e.UsesEncryption) ? "Y" : "N"' e.Crc);  					if ((e.Comment != null) && (e.Comment != ""))  						System.Console.WriteLine ("  Comment: {0}"' e.Comment);  				}  				if (action == ActionDesired.Extract) {  					if (e.UsesEncryption) {  						if (password == null)  							System.Console.WriteLine ("unzip: {0}: Cannot extract this entry without a password."' e.FileName);  						else {  							if (wantFlatten)  								e.FileName = System.IO.Path.GetFileName (e.FileName);  							if (extractToConsole)  								e.ExtractWithPassword (outstream' password);  							else  								e.ExtractWithPassword (targdir' behaviorForExistingFile' password);  						}  					} else {  						if (wantFlatten)  							e.FileName = System.IO.Path.GetFileName (e.FileName);  						if (extractToConsole)  							e.Extract (outstream);  						else  							e.Extract (targdir' behaviorForExistingFile);  					}  				} else if (action == ActionDesired.Test) {  					e.ExtractWithPassword (bitbucket' password);  				}  			}  			// foreach  			if (!wantQuiet) {  				System.Console.WriteLine (new System.String ('-'' 80));  				System.Console.WriteLine ("{1'-22} {2'10}  {3'5}   {4'10}  {5'3} {6'8} {0}"' zip.Entries.Count.ToString () + " files"' ""' totalUncompressedSize' ""' ""' ""' "");  			}  		}  		// else (extract all)  	}  	// end using()' the underlying file is closed.  }  
Magic Number,Ionic.Zip.Examples,UnZip,F:\newReposMay17\haf_DotNetZip.Semverd\src\Tools\UnZip\UnZip.cs,Main,The following statement contains a magic number: using (ZipFile zip = ZipFile.Read (zipfile' options)) {  	if (entriesToExtract.Count > 0) {  		// extract specified entries  		foreach (var entryToExtract in entriesToExtract) {  			// find the entry  			ZipEntry e = zip [entryToExtract];  			if (e == null) {  				System.Console.WriteLine ("  entry ({0}) does not exist in the zip archive."' entryToExtract);  			} else {  				if (wantFlatten)  					e.FileName = System.IO.Path.GetFileName (e.FileName);  				if (password == null) {  					if (e.UsesEncryption)  						System.Console.WriteLine ("  That entry ({0}) requires a password to extract."' entryToExtract);  					else if (extractToConsole)  						e.Extract (outstream);  					else  						e.Extract (targdir' behaviorForExistingFile);  				} else {  					if (extractToConsole)  						e.ExtractWithPassword (outstream' password);  					else  						e.ExtractWithPassword (targdir' behaviorForExistingFile' password);  				}  			}  		}  	} else if (action == ActionDesired.Info) {  		System.Console.WriteLine ("{0}"' zip.Info);  	} else {  		// extract all' or list' or test  		// The logic here does almost the same thing as the ExtractAll() method  		// on the ZipFile class.  But in this case we *could* have control over  		// it' for example only extract files of a certain type' or whose names  		// matched a certain pattern' or whose lastmodified times fit a certain  		// condition' or use a different password for each entry' etc.  We can  		// also display status for each entry' as here.  		Int64 totalUncompressedSize = 0;  		bool header = true;  		foreach (ZipEntry e in zip.EntriesSorted) {  			if (!wantQuiet) {  				if (header) {  					System.Console.WriteLine ("Zipfile: {0}"' zip.Name);  					if ((zip.Comment != null) && (zip.Comment != ""))  						System.Console.WriteLine ("Comment: {0}"' zip.Comment);  					System.Console.WriteLine ("\n{1'-22} {2'10}  {3'5}   {4'10}  {5'3} {6'8} {0}"' "Filename"' "Modified"' "Size"' "Ratio"' "Packed"' "pw?"' "CRC");  					System.Console.WriteLine (new System.String ('-'' 80));  					header = false;  				}  				totalUncompressedSize += e.UncompressedSize;  				System.Console.WriteLine ("{1'-22} {2'10} {3'5:F0}%   {4'10}  {5'3} {6:X8} {0}"' e.FileName' e.LastModified.ToString ("yyyy-MM-dd HH:mm:ss")' e.UncompressedSize' e.CompressionRatio' e.CompressedSize' (e.UsesEncryption) ? "Y" : "N"' e.Crc);  				if ((e.Comment != null) && (e.Comment != ""))  					System.Console.WriteLine ("  Comment: {0}"' e.Comment);  			}  			if (action == ActionDesired.Extract) {  				if (e.UsesEncryption) {  					if (password == null)  						System.Console.WriteLine ("unzip: {0}: Cannot extract this entry without a password."' e.FileName);  					else {  						if (wantFlatten)  							e.FileName = System.IO.Path.GetFileName (e.FileName);  						if (extractToConsole)  							e.ExtractWithPassword (outstream' password);  						else  							e.ExtractWithPassword (targdir' behaviorForExistingFile' password);  					}  				} else {  					if (wantFlatten)  						e.FileName = System.IO.Path.GetFileName (e.FileName);  					if (extractToConsole)  						e.Extract (outstream);  					else  						e.Extract (targdir' behaviorForExistingFile);  				}  			} else if (action == ActionDesired.Test) {  				e.ExtractWithPassword (bitbucket' password);  			}  		}  		// foreach  		if (!wantQuiet) {  			System.Console.WriteLine (new System.String ('-'' 80));  			System.Console.WriteLine ("{1'-22} {2'10}  {3'5}   {4'10}  {5'3} {6'8} {0}"' zip.Entries.Count.ToString () + " files"' ""' totalUncompressedSize' ""' ""' ""' "");  		}  	}  	// else (extract all)  }  
Magic Number,Ionic.Zip.Examples,UnZip,F:\newReposMay17\haf_DotNetZip.Semverd\src\Tools\UnZip\UnZip.cs,Main,The following statement contains a magic number: using (ZipFile zip = ZipFile.Read (zipfile' options)) {  	if (entriesToExtract.Count > 0) {  		// extract specified entries  		foreach (var entryToExtract in entriesToExtract) {  			// find the entry  			ZipEntry e = zip [entryToExtract];  			if (e == null) {  				System.Console.WriteLine ("  entry ({0}) does not exist in the zip archive."' entryToExtract);  			} else {  				if (wantFlatten)  					e.FileName = System.IO.Path.GetFileName (e.FileName);  				if (password == null) {  					if (e.UsesEncryption)  						System.Console.WriteLine ("  That entry ({0}) requires a password to extract."' entryToExtract);  					else if (extractToConsole)  						e.Extract (outstream);  					else  						e.Extract (targdir' behaviorForExistingFile);  				} else {  					if (extractToConsole)  						e.ExtractWithPassword (outstream' password);  					else  						e.ExtractWithPassword (targdir' behaviorForExistingFile' password);  				}  			}  		}  	} else if (action == ActionDesired.Info) {  		System.Console.WriteLine ("{0}"' zip.Info);  	} else {  		// extract all' or list' or test  		// The logic here does almost the same thing as the ExtractAll() method  		// on the ZipFile class.  But in this case we *could* have control over  		// it' for example only extract files of a certain type' or whose names  		// matched a certain pattern' or whose lastmodified times fit a certain  		// condition' or use a different password for each entry' etc.  We can  		// also display status for each entry' as here.  		Int64 totalUncompressedSize = 0;  		bool header = true;  		foreach (ZipEntry e in zip.EntriesSorted) {  			if (!wantQuiet) {  				if (header) {  					System.Console.WriteLine ("Zipfile: {0}"' zip.Name);  					if ((zip.Comment != null) && (zip.Comment != ""))  						System.Console.WriteLine ("Comment: {0}"' zip.Comment);  					System.Console.WriteLine ("\n{1'-22} {2'10}  {3'5}   {4'10}  {5'3} {6'8} {0}"' "Filename"' "Modified"' "Size"' "Ratio"' "Packed"' "pw?"' "CRC");  					System.Console.WriteLine (new System.String ('-'' 80));  					header = false;  				}  				totalUncompressedSize += e.UncompressedSize;  				System.Console.WriteLine ("{1'-22} {2'10} {3'5:F0}%   {4'10}  {5'3} {6:X8} {0}"' e.FileName' e.LastModified.ToString ("yyyy-MM-dd HH:mm:ss")' e.UncompressedSize' e.CompressionRatio' e.CompressedSize' (e.UsesEncryption) ? "Y" : "N"' e.Crc);  				if ((e.Comment != null) && (e.Comment != ""))  					System.Console.WriteLine ("  Comment: {0}"' e.Comment);  			}  			if (action == ActionDesired.Extract) {  				if (e.UsesEncryption) {  					if (password == null)  						System.Console.WriteLine ("unzip: {0}: Cannot extract this entry without a password."' e.FileName);  					else {  						if (wantFlatten)  							e.FileName = System.IO.Path.GetFileName (e.FileName);  						if (extractToConsole)  							e.ExtractWithPassword (outstream' password);  						else  							e.ExtractWithPassword (targdir' behaviorForExistingFile' password);  					}  				} else {  					if (wantFlatten)  						e.FileName = System.IO.Path.GetFileName (e.FileName);  					if (extractToConsole)  						e.Extract (outstream);  					else  						e.Extract (targdir' behaviorForExistingFile);  				}  			} else if (action == ActionDesired.Test) {  				e.ExtractWithPassword (bitbucket' password);  			}  		}  		// foreach  		if (!wantQuiet) {  			System.Console.WriteLine (new System.String ('-'' 80));  			System.Console.WriteLine ("{1'-22} {2'10}  {3'5}   {4'10}  {5'3} {6'8} {0}"' zip.Entries.Count.ToString () + " files"' ""' totalUncompressedSize' ""' ""' ""' "");  		}  	}  	// else (extract all)  }  
Magic Number,Ionic.Zip.Examples,UnZip,F:\newReposMay17\haf_DotNetZip.Semverd\src\Tools\UnZip\UnZip.cs,Main,The following statement contains a magic number: if (entriesToExtract.Count > 0) {  	// extract specified entries  	foreach (var entryToExtract in entriesToExtract) {  		// find the entry  		ZipEntry e = zip [entryToExtract];  		if (e == null) {  			System.Console.WriteLine ("  entry ({0}) does not exist in the zip archive."' entryToExtract);  		} else {  			if (wantFlatten)  				e.FileName = System.IO.Path.GetFileName (e.FileName);  			if (password == null) {  				if (e.UsesEncryption)  					System.Console.WriteLine ("  That entry ({0}) requires a password to extract."' entryToExtract);  				else if (extractToConsole)  					e.Extract (outstream);  				else  					e.Extract (targdir' behaviorForExistingFile);  			} else {  				if (extractToConsole)  					e.ExtractWithPassword (outstream' password);  				else  					e.ExtractWithPassword (targdir' behaviorForExistingFile' password);  			}  		}  	}  } else if (action == ActionDesired.Info) {  	System.Console.WriteLine ("{0}"' zip.Info);  } else {  	// extract all' or list' or test  	// The logic here does almost the same thing as the ExtractAll() method  	// on the ZipFile class.  But in this case we *could* have control over  	// it' for example only extract files of a certain type' or whose names  	// matched a certain pattern' or whose lastmodified times fit a certain  	// condition' or use a different password for each entry' etc.  We can  	// also display status for each entry' as here.  	Int64 totalUncompressedSize = 0;  	bool header = true;  	foreach (ZipEntry e in zip.EntriesSorted) {  		if (!wantQuiet) {  			if (header) {  				System.Console.WriteLine ("Zipfile: {0}"' zip.Name);  				if ((zip.Comment != null) && (zip.Comment != ""))  					System.Console.WriteLine ("Comment: {0}"' zip.Comment);  				System.Console.WriteLine ("\n{1'-22} {2'10}  {3'5}   {4'10}  {5'3} {6'8} {0}"' "Filename"' "Modified"' "Size"' "Ratio"' "Packed"' "pw?"' "CRC");  				System.Console.WriteLine (new System.String ('-'' 80));  				header = false;  			}  			totalUncompressedSize += e.UncompressedSize;  			System.Console.WriteLine ("{1'-22} {2'10} {3'5:F0}%   {4'10}  {5'3} {6:X8} {0}"' e.FileName' e.LastModified.ToString ("yyyy-MM-dd HH:mm:ss")' e.UncompressedSize' e.CompressionRatio' e.CompressedSize' (e.UsesEncryption) ? "Y" : "N"' e.Crc);  			if ((e.Comment != null) && (e.Comment != ""))  				System.Console.WriteLine ("  Comment: {0}"' e.Comment);  		}  		if (action == ActionDesired.Extract) {  			if (e.UsesEncryption) {  				if (password == null)  					System.Console.WriteLine ("unzip: {0}: Cannot extract this entry without a password."' e.FileName);  				else {  					if (wantFlatten)  						e.FileName = System.IO.Path.GetFileName (e.FileName);  					if (extractToConsole)  						e.ExtractWithPassword (outstream' password);  					else  						e.ExtractWithPassword (targdir' behaviorForExistingFile' password);  				}  			} else {  				if (wantFlatten)  					e.FileName = System.IO.Path.GetFileName (e.FileName);  				if (extractToConsole)  					e.Extract (outstream);  				else  					e.Extract (targdir' behaviorForExistingFile);  			}  		} else if (action == ActionDesired.Test) {  			e.ExtractWithPassword (bitbucket' password);  		}  	}  	// foreach  	if (!wantQuiet) {  		System.Console.WriteLine (new System.String ('-'' 80));  		System.Console.WriteLine ("{1'-22} {2'10}  {3'5}   {4'10}  {5'3} {6'8} {0}"' zip.Entries.Count.ToString () + " files"' ""' totalUncompressedSize' ""' ""' ""' "");  	}  }  
Magic Number,Ionic.Zip.Examples,UnZip,F:\newReposMay17\haf_DotNetZip.Semverd\src\Tools\UnZip\UnZip.cs,Main,The following statement contains a magic number: if (entriesToExtract.Count > 0) {  	// extract specified entries  	foreach (var entryToExtract in entriesToExtract) {  		// find the entry  		ZipEntry e = zip [entryToExtract];  		if (e == null) {  			System.Console.WriteLine ("  entry ({0}) does not exist in the zip archive."' entryToExtract);  		} else {  			if (wantFlatten)  				e.FileName = System.IO.Path.GetFileName (e.FileName);  			if (password == null) {  				if (e.UsesEncryption)  					System.Console.WriteLine ("  That entry ({0}) requires a password to extract."' entryToExtract);  				else if (extractToConsole)  					e.Extract (outstream);  				else  					e.Extract (targdir' behaviorForExistingFile);  			} else {  				if (extractToConsole)  					e.ExtractWithPassword (outstream' password);  				else  					e.ExtractWithPassword (targdir' behaviorForExistingFile' password);  			}  		}  	}  } else if (action == ActionDesired.Info) {  	System.Console.WriteLine ("{0}"' zip.Info);  } else {  	// extract all' or list' or test  	// The logic here does almost the same thing as the ExtractAll() method  	// on the ZipFile class.  But in this case we *could* have control over  	// it' for example only extract files of a certain type' or whose names  	// matched a certain pattern' or whose lastmodified times fit a certain  	// condition' or use a different password for each entry' etc.  We can  	// also display status for each entry' as here.  	Int64 totalUncompressedSize = 0;  	bool header = true;  	foreach (ZipEntry e in zip.EntriesSorted) {  		if (!wantQuiet) {  			if (header) {  				System.Console.WriteLine ("Zipfile: {0}"' zip.Name);  				if ((zip.Comment != null) && (zip.Comment != ""))  					System.Console.WriteLine ("Comment: {0}"' zip.Comment);  				System.Console.WriteLine ("\n{1'-22} {2'10}  {3'5}   {4'10}  {5'3} {6'8} {0}"' "Filename"' "Modified"' "Size"' "Ratio"' "Packed"' "pw?"' "CRC");  				System.Console.WriteLine (new System.String ('-'' 80));  				header = false;  			}  			totalUncompressedSize += e.UncompressedSize;  			System.Console.WriteLine ("{1'-22} {2'10} {3'5:F0}%   {4'10}  {5'3} {6:X8} {0}"' e.FileName' e.LastModified.ToString ("yyyy-MM-dd HH:mm:ss")' e.UncompressedSize' e.CompressionRatio' e.CompressedSize' (e.UsesEncryption) ? "Y" : "N"' e.Crc);  			if ((e.Comment != null) && (e.Comment != ""))  				System.Console.WriteLine ("  Comment: {0}"' e.Comment);  		}  		if (action == ActionDesired.Extract) {  			if (e.UsesEncryption) {  				if (password == null)  					System.Console.WriteLine ("unzip: {0}: Cannot extract this entry without a password."' e.FileName);  				else {  					if (wantFlatten)  						e.FileName = System.IO.Path.GetFileName (e.FileName);  					if (extractToConsole)  						e.ExtractWithPassword (outstream' password);  					else  						e.ExtractWithPassword (targdir' behaviorForExistingFile' password);  				}  			} else {  				if (wantFlatten)  					e.FileName = System.IO.Path.GetFileName (e.FileName);  				if (extractToConsole)  					e.Extract (outstream);  				else  					e.Extract (targdir' behaviorForExistingFile);  			}  		} else if (action == ActionDesired.Test) {  			e.ExtractWithPassword (bitbucket' password);  		}  	}  	// foreach  	if (!wantQuiet) {  		System.Console.WriteLine (new System.String ('-'' 80));  		System.Console.WriteLine ("{1'-22} {2'10}  {3'5}   {4'10}  {5'3} {6'8} {0}"' zip.Entries.Count.ToString () + " files"' ""' totalUncompressedSize' ""' ""' ""' "");  	}  }  
Magic Number,Ionic.Zip.Examples,UnZip,F:\newReposMay17\haf_DotNetZip.Semverd\src\Tools\UnZip\UnZip.cs,Main,The following statement contains a magic number: if (action == ActionDesired.Info) {  	System.Console.WriteLine ("{0}"' zip.Info);  } else {  	// extract all' or list' or test  	// The logic here does almost the same thing as the ExtractAll() method  	// on the ZipFile class.  But in this case we *could* have control over  	// it' for example only extract files of a certain type' or whose names  	// matched a certain pattern' or whose lastmodified times fit a certain  	// condition' or use a different password for each entry' etc.  We can  	// also display status for each entry' as here.  	Int64 totalUncompressedSize = 0;  	bool header = true;  	foreach (ZipEntry e in zip.EntriesSorted) {  		if (!wantQuiet) {  			if (header) {  				System.Console.WriteLine ("Zipfile: {0}"' zip.Name);  				if ((zip.Comment != null) && (zip.Comment != ""))  					System.Console.WriteLine ("Comment: {0}"' zip.Comment);  				System.Console.WriteLine ("\n{1'-22} {2'10}  {3'5}   {4'10}  {5'3} {6'8} {0}"' "Filename"' "Modified"' "Size"' "Ratio"' "Packed"' "pw?"' "CRC");  				System.Console.WriteLine (new System.String ('-'' 80));  				header = false;  			}  			totalUncompressedSize += e.UncompressedSize;  			System.Console.WriteLine ("{1'-22} {2'10} {3'5:F0}%   {4'10}  {5'3} {6:X8} {0}"' e.FileName' e.LastModified.ToString ("yyyy-MM-dd HH:mm:ss")' e.UncompressedSize' e.CompressionRatio' e.CompressedSize' (e.UsesEncryption) ? "Y" : "N"' e.Crc);  			if ((e.Comment != null) && (e.Comment != ""))  				System.Console.WriteLine ("  Comment: {0}"' e.Comment);  		}  		if (action == ActionDesired.Extract) {  			if (e.UsesEncryption) {  				if (password == null)  					System.Console.WriteLine ("unzip: {0}: Cannot extract this entry without a password."' e.FileName);  				else {  					if (wantFlatten)  						e.FileName = System.IO.Path.GetFileName (e.FileName);  					if (extractToConsole)  						e.ExtractWithPassword (outstream' password);  					else  						e.ExtractWithPassword (targdir' behaviorForExistingFile' password);  				}  			} else {  				if (wantFlatten)  					e.FileName = System.IO.Path.GetFileName (e.FileName);  				if (extractToConsole)  					e.Extract (outstream);  				else  					e.Extract (targdir' behaviorForExistingFile);  			}  		} else if (action == ActionDesired.Test) {  			e.ExtractWithPassword (bitbucket' password);  		}  	}  	// foreach  	if (!wantQuiet) {  		System.Console.WriteLine (new System.String ('-'' 80));  		System.Console.WriteLine ("{1'-22} {2'10}  {3'5}   {4'10}  {5'3} {6'8} {0}"' zip.Entries.Count.ToString () + " files"' ""' totalUncompressedSize' ""' ""' ""' "");  	}  }  
Magic Number,Ionic.Zip.Examples,UnZip,F:\newReposMay17\haf_DotNetZip.Semverd\src\Tools\UnZip\UnZip.cs,Main,The following statement contains a magic number: if (action == ActionDesired.Info) {  	System.Console.WriteLine ("{0}"' zip.Info);  } else {  	// extract all' or list' or test  	// The logic here does almost the same thing as the ExtractAll() method  	// on the ZipFile class.  But in this case we *could* have control over  	// it' for example only extract files of a certain type' or whose names  	// matched a certain pattern' or whose lastmodified times fit a certain  	// condition' or use a different password for each entry' etc.  We can  	// also display status for each entry' as here.  	Int64 totalUncompressedSize = 0;  	bool header = true;  	foreach (ZipEntry e in zip.EntriesSorted) {  		if (!wantQuiet) {  			if (header) {  				System.Console.WriteLine ("Zipfile: {0}"' zip.Name);  				if ((zip.Comment != null) && (zip.Comment != ""))  					System.Console.WriteLine ("Comment: {0}"' zip.Comment);  				System.Console.WriteLine ("\n{1'-22} {2'10}  {3'5}   {4'10}  {5'3} {6'8} {0}"' "Filename"' "Modified"' "Size"' "Ratio"' "Packed"' "pw?"' "CRC");  				System.Console.WriteLine (new System.String ('-'' 80));  				header = false;  			}  			totalUncompressedSize += e.UncompressedSize;  			System.Console.WriteLine ("{1'-22} {2'10} {3'5:F0}%   {4'10}  {5'3} {6:X8} {0}"' e.FileName' e.LastModified.ToString ("yyyy-MM-dd HH:mm:ss")' e.UncompressedSize' e.CompressionRatio' e.CompressedSize' (e.UsesEncryption) ? "Y" : "N"' e.Crc);  			if ((e.Comment != null) && (e.Comment != ""))  				System.Console.WriteLine ("  Comment: {0}"' e.Comment);  		}  		if (action == ActionDesired.Extract) {  			if (e.UsesEncryption) {  				if (password == null)  					System.Console.WriteLine ("unzip: {0}: Cannot extract this entry without a password."' e.FileName);  				else {  					if (wantFlatten)  						e.FileName = System.IO.Path.GetFileName (e.FileName);  					if (extractToConsole)  						e.ExtractWithPassword (outstream' password);  					else  						e.ExtractWithPassword (targdir' behaviorForExistingFile' password);  				}  			} else {  				if (wantFlatten)  					e.FileName = System.IO.Path.GetFileName (e.FileName);  				if (extractToConsole)  					e.Extract (outstream);  				else  					e.Extract (targdir' behaviorForExistingFile);  			}  		} else if (action == ActionDesired.Test) {  			e.ExtractWithPassword (bitbucket' password);  		}  	}  	// foreach  	if (!wantQuiet) {  		System.Console.WriteLine (new System.String ('-'' 80));  		System.Console.WriteLine ("{1'-22} {2'10}  {3'5}   {4'10}  {5'3} {6'8} {0}"' zip.Entries.Count.ToString () + " files"' ""' totalUncompressedSize' ""' ""' ""' "");  	}  }  
Magic Number,Ionic.Zip.Examples,UnZip,F:\newReposMay17\haf_DotNetZip.Semverd\src\Tools\UnZip\UnZip.cs,Main,The following statement contains a magic number: foreach (ZipEntry e in zip.EntriesSorted) {  	if (!wantQuiet) {  		if (header) {  			System.Console.WriteLine ("Zipfile: {0}"' zip.Name);  			if ((zip.Comment != null) && (zip.Comment != ""))  				System.Console.WriteLine ("Comment: {0}"' zip.Comment);  			System.Console.WriteLine ("\n{1'-22} {2'10}  {3'5}   {4'10}  {5'3} {6'8} {0}"' "Filename"' "Modified"' "Size"' "Ratio"' "Packed"' "pw?"' "CRC");  			System.Console.WriteLine (new System.String ('-'' 80));  			header = false;  		}  		totalUncompressedSize += e.UncompressedSize;  		System.Console.WriteLine ("{1'-22} {2'10} {3'5:F0}%   {4'10}  {5'3} {6:X8} {0}"' e.FileName' e.LastModified.ToString ("yyyy-MM-dd HH:mm:ss")' e.UncompressedSize' e.CompressionRatio' e.CompressedSize' (e.UsesEncryption) ? "Y" : "N"' e.Crc);  		if ((e.Comment != null) && (e.Comment != ""))  			System.Console.WriteLine ("  Comment: {0}"' e.Comment);  	}  	if (action == ActionDesired.Extract) {  		if (e.UsesEncryption) {  			if (password == null)  				System.Console.WriteLine ("unzip: {0}: Cannot extract this entry without a password."' e.FileName);  			else {  				if (wantFlatten)  					e.FileName = System.IO.Path.GetFileName (e.FileName);  				if (extractToConsole)  					e.ExtractWithPassword (outstream' password);  				else  					e.ExtractWithPassword (targdir' behaviorForExistingFile' password);  			}  		} else {  			if (wantFlatten)  				e.FileName = System.IO.Path.GetFileName (e.FileName);  			if (extractToConsole)  				e.Extract (outstream);  			else  				e.Extract (targdir' behaviorForExistingFile);  		}  	} else if (action == ActionDesired.Test) {  		e.ExtractWithPassword (bitbucket' password);  	}  }  
Magic Number,Ionic.Zip.Examples,UnZip,F:\newReposMay17\haf_DotNetZip.Semverd\src\Tools\UnZip\UnZip.cs,Main,The following statement contains a magic number: if (!wantQuiet) {  	if (header) {  		System.Console.WriteLine ("Zipfile: {0}"' zip.Name);  		if ((zip.Comment != null) && (zip.Comment != ""))  			System.Console.WriteLine ("Comment: {0}"' zip.Comment);  		System.Console.WriteLine ("\n{1'-22} {2'10}  {3'5}   {4'10}  {5'3} {6'8} {0}"' "Filename"' "Modified"' "Size"' "Ratio"' "Packed"' "pw?"' "CRC");  		System.Console.WriteLine (new System.String ('-'' 80));  		header = false;  	}  	totalUncompressedSize += e.UncompressedSize;  	System.Console.WriteLine ("{1'-22} {2'10} {3'5:F0}%   {4'10}  {5'3} {6:X8} {0}"' e.FileName' e.LastModified.ToString ("yyyy-MM-dd HH:mm:ss")' e.UncompressedSize' e.CompressionRatio' e.CompressedSize' (e.UsesEncryption) ? "Y" : "N"' e.Crc);  	if ((e.Comment != null) && (e.Comment != ""))  		System.Console.WriteLine ("  Comment: {0}"' e.Comment);  }  
Magic Number,Ionic.Zip.Examples,UnZip,F:\newReposMay17\haf_DotNetZip.Semverd\src\Tools\UnZip\UnZip.cs,Main,The following statement contains a magic number: if (header) {  	System.Console.WriteLine ("Zipfile: {0}"' zip.Name);  	if ((zip.Comment != null) && (zip.Comment != ""))  		System.Console.WriteLine ("Comment: {0}"' zip.Comment);  	System.Console.WriteLine ("\n{1'-22} {2'10}  {3'5}   {4'10}  {5'3} {6'8} {0}"' "Filename"' "Modified"' "Size"' "Ratio"' "Packed"' "pw?"' "CRC");  	System.Console.WriteLine (new System.String ('-'' 80));  	header = false;  }  
Magic Number,Ionic.Zip.Examples,UnZip,F:\newReposMay17\haf_DotNetZip.Semverd\src\Tools\UnZip\UnZip.cs,Main,The following statement contains a magic number: System.Console.WriteLine (new System.String ('-'' 80));  
Magic Number,Ionic.Zip.Examples,UnZip,F:\newReposMay17\haf_DotNetZip.Semverd\src\Tools\UnZip\UnZip.cs,Main,The following statement contains a magic number: if (!wantQuiet) {  	System.Console.WriteLine (new System.String ('-'' 80));  	System.Console.WriteLine ("{1'-22} {2'10}  {3'5}   {4'10}  {5'3} {6'8} {0}"' zip.Entries.Count.ToString () + " files"' ""' totalUncompressedSize' ""' ""' ""' "");  }  
Magic Number,Ionic.Zip.Examples,UnZip,F:\newReposMay17\haf_DotNetZip.Semverd\src\Tools\UnZip\UnZip.cs,Main,The following statement contains a magic number: System.Console.WriteLine (new System.String ('-'' 80));  
