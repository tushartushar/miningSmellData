Implementation smell,Namespace,Class,File,Method,Description
Complex Method,Odyssey.Tools.Compiler.Model,ModelCompiler,C:\repos\AvengerDr_Odyssey\Source\Tools\Odyssey.Tools.Compiler\Model\ModelCompiler.cs,CollectNodes,Cyclomatic complexity of the method is 9
Complex Method,Odyssey.Tools.Compiler.Model,ModelCompiler,C:\repos\AvengerDr_Odyssey\Source\Tools\Odyssey.Tools.Compiler\Model\ModelCompiler.cs,Process,Cyclomatic complexity of the method is 11
Complex Method,Odyssey.Tools.Compiler.Model,ModelCompiler,C:\repos\AvengerDr_Odyssey\Source\Tools\Odyssey.Tools.Compiler\Model\ModelCompiler.cs,WriteVertices,Cyclomatic complexity of the method is 14
Long Statement,Odyssey.Tools.Compiler,FileDependencyList,C:\repos\AvengerDr_Odyssey\Source\Tools\Odyssey.Tools.Compiler\FileDependencyList.cs,FromFile,The length of the statement  "            using (var stream = new NativeFileStream(file' NativeFileMode.Open' NativeFileAccess.Read' NativeFileShare.ReadWrite)) return FromStream(stream); " is 145.
Long Statement,Odyssey.Tools.Compiler,FileDependencyList,C:\repos\AvengerDr_Odyssey\Source\Tools\Odyssey.Tools.Compiler\FileDependencyList.cs,Save,The length of the statement  "            using (var stream = new NativeFileStream(file' NativeFileMode.Create' NativeFileAccess.Write' NativeFileShare.ReadWrite)) Save(stream); " is 135.
Long Statement,Odyssey.Tools.Compiler.Model,ModelCompiler,C:\repos\AvengerDr_Odyssey\Source\Tools\Odyssey.Tools.Compiler\Model\ModelCompiler.cs,CompileFromStream,The length of the statement  "                AssimpLibrary.Instance.LoadLibrary(Path.Combine(rootPath' AssimpLibrary.Instance.DefaultLibraryPath32Bit)' Path.Combine(rootPath' AssimpLibrary.Instance.DefaultLibraryPath64Bit)); " is 179.
Long Statement,Odyssey.Tools.Compiler.Model,ModelCompiler,C:\repos\AvengerDr_Odyssey\Source\Tools\Odyssey.Tools.Compiler\Model\ModelCompiler.cs,CompileFromFileInternal,The length of the statement  "                AssimpLibrary.Instance.LoadLibrary(Path.Combine(rootPath' AssimpLibrary.Instance.DefaultLibraryPath32Bit)' Path.Combine(rootPath' AssimpLibrary.Instance.DefaultLibraryPath64Bit)); " is 179.
Magic Number,Odyssey.Tools.Compiler,FileDependencyList,C:\repos\AvengerDr_Odyssey\Source\Tools\Odyssey.Tools.Compiler\FileDependencyList.cs,FromReader,The following statement contains a magic number: while ((line = textReader.ReadLine()) != null)              {                    var match = MatchLine.Match(line);                  if (match.Success)                  {                      effectDependency.Add(match.Groups[1].Value' new DateTime(long.Parse(match.Groups[2].Value)));                  }              }
Magic Number,Odyssey.Tools.Compiler.Model,ModelCompiler,C:\repos\AvengerDr_Odyssey\Source\Tools\Odyssey.Tools.Compiler\Model\ModelCompiler.cs,Process,The following statement contains a magic number: if (assimpMesh.TextureCoordsChannelCount > 0)              {                  for (int localIndex = 0' i = 0; i < assimpMesh.TextureCoordsChannelCount; i++)                  {                      if (assimpMesh.HasTextureCoords(i))                      {                          var uvCount = assimpMesh.GetUVComponentCount(i);                            if (uvCount == 2)                          {                              layout.Add(VertexElement.TextureCoordinate(localIndex' Format.R32G32_Float' vertexBufferElementSize));                              vertexBufferElementSize += SharpDX.Utilities.SizeOf<Vector2>();                          }                          else if (uvCount == 3)                          {                              layout.Add(VertexElement.TextureCoordinate(localIndex' Format.R32G32B32_Float' vertexBufferElementSize));                              vertexBufferElementSize += SharpDX.Utilities.SizeOf<Vector3>();                          }                          else                          {                              throw new InvalidOperationException("Unexpected uv count");                          }                            localIndex++;                      }                  }              }
Magic Number,Odyssey.Tools.Compiler.Model,ModelCompiler,C:\repos\AvengerDr_Odyssey\Source\Tools\Odyssey.Tools.Compiler\Model\ModelCompiler.cs,Process,The following statement contains a magic number: if (assimpMesh.TextureCoordsChannelCount > 0)              {                  for (int localIndex = 0' i = 0; i < assimpMesh.TextureCoordsChannelCount; i++)                  {                      if (assimpMesh.HasTextureCoords(i))                      {                          var uvCount = assimpMesh.GetUVComponentCount(i);                            if (uvCount == 2)                          {                              layout.Add(VertexElement.TextureCoordinate(localIndex' Format.R32G32_Float' vertexBufferElementSize));                              vertexBufferElementSize += SharpDX.Utilities.SizeOf<Vector2>();                          }                          else if (uvCount == 3)                          {                              layout.Add(VertexElement.TextureCoordinate(localIndex' Format.R32G32B32_Float' vertexBufferElementSize));                              vertexBufferElementSize += SharpDX.Utilities.SizeOf<Vector3>();                          }                          else                          {                              throw new InvalidOperationException("Unexpected uv count");                          }                            localIndex++;                      }                  }              }
Magic Number,Odyssey.Tools.Compiler.Model,ModelCompiler,C:\repos\AvengerDr_Odyssey\Source\Tools\Odyssey.Tools.Compiler\Model\ModelCompiler.cs,WriteVertices,The following statement contains a magic number: for (int i = 0; i < assimpMesh.VertexCount; i++)              {                  var position = assimpMesh.Vertices[i];                  vertexStream.Write(position);                    // Store bounding points for BoundingSphere pre-calculation                  boundingPoints[currentBoundingPointIndex++] = new Vector3(position.X' position.Y' position.Z);                    // Add normals                  if (assimpMesh.HasNormals)                  {                      vertexStream.Write(assimpMesh.Normals[i]);                  }                    // Add colors                  if (assimpMesh.VertexColorChannelCount > 0)                  {                      for (int j = 0; j < assimpMesh.VertexColorChannelCount; j++)                      {                          if (assimpMesh.HasVertexColors(j))                          {                              vertexStream.Write(assimpMesh.GetVertexColors(j)[i]);                          }                      }                  }                    // Add textures                  if (assimpMesh.TextureCoordsChannelCount > 0)                  {                      for (int j = 0; j < assimpMesh.TextureCoordsChannelCount; j++)                      {                          if (assimpMesh.HasTextureCoords(j))                          {                              var uvCount = assimpMesh.GetUVComponentCount(j);                                var uv = assimpMesh.GetTextureCoords(j)[i];                                if (uvCount == 2)                              {                                  vertexStream.Write(new Vector2(uv.X' uv.Y));                              }                              else                              {                                  vertexStream.Write(uv);                              }                          }                      }                  }                    // Add tangent / bitangent                  if (assimpMesh.HasTangentBasis)                  {                      if (!options.ExcludeElements.Contains("Tangent"))                      {                          double w = Vector3D.Dot(assimpMesh.Normals[i]'                              Vector3D.Cross(assimpMesh.Tangents[i]' assimpMesh.Tangents[i]));                          Vector3D t = assimpMesh.Tangents[i];                          Vector4 t4D = new Vector4(t.X' t.Y' t.Z' (float)w);                          vertexStream.Write(t4D);                      }                      if (!options.ExcludeElements.Contains("BiTangent"))                          vertexStream.Write(assimpMesh.BiTangents[i]);                  }              }
Magic Number,Odyssey.Tools.Compiler.Model,ModelCompiler,C:\repos\AvengerDr_Odyssey\Source\Tools\Odyssey.Tools.Compiler\Model\ModelCompiler.cs,WriteIndices,The following statement contains a magic number: if (meshPart.VertexBufferRange.Count < 65536)              {                  // Write only short indices if count is less than the size of a short                  indexBuffer.Buffer = new byte[indices.Length * 2];                  using (var indexStream = DataStream.Create(indexBuffer.Buffer' true' true))                      foreach (int index in indices) indexStream.Write((ushort)index);              }              else              {                  // Otherwise' use full 32-bit precision to store indices                  indexBuffer.Buffer = new byte[indices.Length * 4];                  using (var indexStream = DataStream.Create(indexBuffer.Buffer' true' true))                      indexStream.WriteRange(indices);              }
Magic Number,Odyssey.Tools.Compiler.Model,ModelCompiler,C:\repos\AvengerDr_Odyssey\Source\Tools\Odyssey.Tools.Compiler\Model\ModelCompiler.cs,WriteIndices,The following statement contains a magic number: if (meshPart.VertexBufferRange.Count < 65536)              {                  // Write only short indices if count is less than the size of a short                  indexBuffer.Buffer = new byte[indices.Length * 2];                  using (var indexStream = DataStream.Create(indexBuffer.Buffer' true' true))                      foreach (int index in indices) indexStream.Write((ushort)index);              }              else              {                  // Otherwise' use full 32-bit precision to store indices                  indexBuffer.Buffer = new byte[indices.Length * 4];                  using (var indexStream = DataStream.Create(indexBuffer.Buffer' true' true))                      indexStream.WriteRange(indices);              }
Magic Number,Odyssey.Tools.Compiler.Model,ModelCompiler,C:\repos\AvengerDr_Odyssey\Source\Tools\Odyssey.Tools.Compiler\Model\ModelCompiler.cs,WriteIndices,The following statement contains a magic number: if (meshPart.VertexBufferRange.Count < 65536)              {                  // Write only short indices if count is less than the size of a short                  indexBuffer.Buffer = new byte[indices.Length * 2];                  using (var indexStream = DataStream.Create(indexBuffer.Buffer' true' true))                      foreach (int index in indices) indexStream.Write((ushort)index);              }              else              {                  // Otherwise' use full 32-bit precision to store indices                  indexBuffer.Buffer = new byte[indices.Length * 4];                  using (var indexStream = DataStream.Create(indexBuffer.Buffer' true' true))                      indexStream.WriteRange(indices);              }
