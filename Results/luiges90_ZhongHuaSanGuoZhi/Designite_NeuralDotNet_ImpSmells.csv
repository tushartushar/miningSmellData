Implementation smell,Namespace,Class,File,Method,Description
Complex Method,NeuronDotNet.Core,Network,C:\repos\luiges90_ZhongHuaSanGuoZhi\NeuralDotNet\Network.cs,Learn,Cyclomatic complexity of the method is 8
Complex Conditional,NeuronDotNet.Core,Network,C:\repos\luiges90_ZhongHuaSanGuoZhi\NeuralDotNet\Network.cs,Learn,The conditional expression  "(trainingSet.InputVectorLength != inputLayer.NeuronCount)                  || (trainingMethod == TrainingMethod.Supervised && trainingSet.OutputVectorLength != outputLayer.NeuronCount)                  || (trainingMethod == TrainingMethod.Unsupervised && trainingSet.OutputVectorLength != 0)"  is complex.
Virtual Method Call from Constructor,NeuronDotNet.Core,Network,C:\repos\luiges90_ZhongHuaSanGuoZhi\NeuralDotNet\Network.cs,Network,The constructor "Network" calls a virtual method "Initialize".
Magic Number,NeuronDotNet.Core,Network,C:\repos\luiges90_ZhongHuaSanGuoZhi\NeuralDotNet\Network.cs,Network,The following statement contains a magic number: this.jitterEpoch = 73;
Magic Number,NeuronDotNet.Core.LearningRateFunctions,ExponentialFunction,C:\repos\luiges90_ZhongHuaSanGuoZhi\NeuralDotNet\LearningRateFunctions\ExponentialFunction.cs,ExponentialFunction,The following statement contains a magic number: logFinalByInitial                  = Math.Log(Math.Max(initialLearningRate' initialLearningRate + 1e-4)                  / Math.Max(finalLearningRate' finalLearningRate + 1e-4));
Magic Number,NeuronDotNet.Core.LearningRateFunctions,ExponentialFunction,C:\repos\luiges90_ZhongHuaSanGuoZhi\NeuralDotNet\LearningRateFunctions\ExponentialFunction.cs,ExponentialFunction,The following statement contains a magic number: logFinalByInitial                  = Math.Log(Math.Max(initialLearningRate' initialLearningRate + 1e-4)                  / Math.Max(finalLearningRate' finalLearningRate + 1e-4));
Magic Number,NeuronDotNet.Core.LearningRateFunctions,ExponentialFunction,C:\repos\luiges90_ZhongHuaSanGuoZhi\NeuralDotNet\LearningRateFunctions\ExponentialFunction.cs,ExponentialFunction,The following statement contains a magic number: logFinalByInitial                  = Math.Log(Math.Max(initialLearningRate' initialLearningRate + 1e-4)                  / Math.Max(finalLearningRate' finalLearningRate + 1e-4));
Magic Number,NeuronDotNet.Core.LearningRateFunctions,ExponentialFunction,C:\repos\luiges90_ZhongHuaSanGuoZhi\NeuralDotNet\LearningRateFunctions\ExponentialFunction.cs,ExponentialFunction,The following statement contains a magic number: logFinalByInitial                  = Math.Log(Math.Max(initialLearningRate' initialLearningRate + 1e-4)                  / Math.Max(finalLearningRate' finalLearningRate + 1e-4));
Magic Number,NeuronDotNet.Core.SOM.NeighborhoodFunctions,MexicanHatFunction,C:\repos\luiges90_ZhongHuaSanGuoZhi\NeuralDotNet\SOM\NeighborhoodFunctions\MexicanHatFunction.cs,EvaluateNeighborhood,The following statement contains a magic number: double sigmaSquare = sigma * sigma + 1e-9;
Magic Number,NeuronDotNet.Core.SOM.NeighborhoodFunctions,MexicanHatFunction,C:\repos\luiges90_ZhongHuaSanGuoZhi\NeuralDotNet\SOM\NeighborhoodFunctions\MexicanHatFunction.cs,EvaluateNeighborhood,The following statement contains a magic number: foreach (PositionNeuron neuron in layer.Neurons)              {                  int dx = Math.Abs(winnerX - neuron.Coordinate.X);                  int dy = Math.Abs(winnerY - neuron.Coordinate.Y);                    if (layer.IsRowCircular)                  {                      dx = Math.Min(dx' layerWidth - dx);                  }                  if (layer.IsColumnCircular)                  {                      dy = Math.Min(dy' layerHeight - dy);                  }                    double dxSquare = dx * dx;                  double dySquare = dy * dy;                  if (layer.Topology == LatticeTopology.Hexagonal)                  {                      if (dy % 2 == 1)                      {                          dxSquare += 0.25 + (((neuron.Coordinate.X > winnerX) == (winnerY % 2 == 0)) ? dx : -dx);                      }                      dySquare *= 0.75;                  }                  double distanceBySigmaSquare = (dxSquare + dySquare) / sigmaSquare;                  neuron.neighborhoodValue = (1 - distanceBySigmaSquare) * Math.Exp(-distanceBySigmaSquare / 2);              }
Magic Number,NeuronDotNet.Core.SOM.NeighborhoodFunctions,MexicanHatFunction,C:\repos\luiges90_ZhongHuaSanGuoZhi\NeuralDotNet\SOM\NeighborhoodFunctions\MexicanHatFunction.cs,EvaluateNeighborhood,The following statement contains a magic number: foreach (PositionNeuron neuron in layer.Neurons)              {                  int dx = Math.Abs(winnerX - neuron.Coordinate.X);                  int dy = Math.Abs(winnerY - neuron.Coordinate.Y);                    if (layer.IsRowCircular)                  {                      dx = Math.Min(dx' layerWidth - dx);                  }                  if (layer.IsColumnCircular)                  {                      dy = Math.Min(dy' layerHeight - dy);                  }                    double dxSquare = dx * dx;                  double dySquare = dy * dy;                  if (layer.Topology == LatticeTopology.Hexagonal)                  {                      if (dy % 2 == 1)                      {                          dxSquare += 0.25 + (((neuron.Coordinate.X > winnerX) == (winnerY % 2 == 0)) ? dx : -dx);                      }                      dySquare *= 0.75;                  }                  double distanceBySigmaSquare = (dxSquare + dySquare) / sigmaSquare;                  neuron.neighborhoodValue = (1 - distanceBySigmaSquare) * Math.Exp(-distanceBySigmaSquare / 2);              }
Magic Number,NeuronDotNet.Core.SOM.NeighborhoodFunctions,MexicanHatFunction,C:\repos\luiges90_ZhongHuaSanGuoZhi\NeuralDotNet\SOM\NeighborhoodFunctions\MexicanHatFunction.cs,EvaluateNeighborhood,The following statement contains a magic number: foreach (PositionNeuron neuron in layer.Neurons)              {                  int dx = Math.Abs(winnerX - neuron.Coordinate.X);                  int dy = Math.Abs(winnerY - neuron.Coordinate.Y);                    if (layer.IsRowCircular)                  {                      dx = Math.Min(dx' layerWidth - dx);                  }                  if (layer.IsColumnCircular)                  {                      dy = Math.Min(dy' layerHeight - dy);                  }                    double dxSquare = dx * dx;                  double dySquare = dy * dy;                  if (layer.Topology == LatticeTopology.Hexagonal)                  {                      if (dy % 2 == 1)                      {                          dxSquare += 0.25 + (((neuron.Coordinate.X > winnerX) == (winnerY % 2 == 0)) ? dx : -dx);                      }                      dySquare *= 0.75;                  }                  double distanceBySigmaSquare = (dxSquare + dySquare) / sigmaSquare;                  neuron.neighborhoodValue = (1 - distanceBySigmaSquare) * Math.Exp(-distanceBySigmaSquare / 2);              }
Magic Number,NeuronDotNet.Core.SOM.NeighborhoodFunctions,MexicanHatFunction,C:\repos\luiges90_ZhongHuaSanGuoZhi\NeuralDotNet\SOM\NeighborhoodFunctions\MexicanHatFunction.cs,EvaluateNeighborhood,The following statement contains a magic number: foreach (PositionNeuron neuron in layer.Neurons)              {                  int dx = Math.Abs(winnerX - neuron.Coordinate.X);                  int dy = Math.Abs(winnerY - neuron.Coordinate.Y);                    if (layer.IsRowCircular)                  {                      dx = Math.Min(dx' layerWidth - dx);                  }                  if (layer.IsColumnCircular)                  {                      dy = Math.Min(dy' layerHeight - dy);                  }                    double dxSquare = dx * dx;                  double dySquare = dy * dy;                  if (layer.Topology == LatticeTopology.Hexagonal)                  {                      if (dy % 2 == 1)                      {                          dxSquare += 0.25 + (((neuron.Coordinate.X > winnerX) == (winnerY % 2 == 0)) ? dx : -dx);                      }                      dySquare *= 0.75;                  }                  double distanceBySigmaSquare = (dxSquare + dySquare) / sigmaSquare;                  neuron.neighborhoodValue = (1 - distanceBySigmaSquare) * Math.Exp(-distanceBySigmaSquare / 2);              }
Magic Number,NeuronDotNet.Core.SOM.NeighborhoodFunctions,MexicanHatFunction,C:\repos\luiges90_ZhongHuaSanGuoZhi\NeuralDotNet\SOM\NeighborhoodFunctions\MexicanHatFunction.cs,EvaluateNeighborhood,The following statement contains a magic number: foreach (PositionNeuron neuron in layer.Neurons)              {                  int dx = Math.Abs(winnerX - neuron.Coordinate.X);                  int dy = Math.Abs(winnerY - neuron.Coordinate.Y);                    if (layer.IsRowCircular)                  {                      dx = Math.Min(dx' layerWidth - dx);                  }                  if (layer.IsColumnCircular)                  {                      dy = Math.Min(dy' layerHeight - dy);                  }                    double dxSquare = dx * dx;                  double dySquare = dy * dy;                  if (layer.Topology == LatticeTopology.Hexagonal)                  {                      if (dy % 2 == 1)                      {                          dxSquare += 0.25 + (((neuron.Coordinate.X > winnerX) == (winnerY % 2 == 0)) ? dx : -dx);                      }                      dySquare *= 0.75;                  }                  double distanceBySigmaSquare = (dxSquare + dySquare) / sigmaSquare;                  neuron.neighborhoodValue = (1 - distanceBySigmaSquare) * Math.Exp(-distanceBySigmaSquare / 2);              }
Magic Number,NeuronDotNet.Core.SOM.NeighborhoodFunctions,GaussianFunction,C:\repos\luiges90_ZhongHuaSanGuoZhi\NeuralDotNet\SOM\NeighborhoodFunctions\GaussianFunction.cs,EvaluateNeighborhood,The following statement contains a magic number: double twoSigmaSquare = 2 * currentSigma * currentSigma;
Magic Number,NeuronDotNet.Core.SOM.NeighborhoodFunctions,GaussianFunction,C:\repos\luiges90_ZhongHuaSanGuoZhi\NeuralDotNet\SOM\NeighborhoodFunctions\GaussianFunction.cs,EvaluateNeighborhood,The following statement contains a magic number: foreach (PositionNeuron neuron in layer.Neurons)              {                  int dx = Math.Abs(winnerX - neuron.Coordinate.X);                  int dy = Math.Abs(winnerY - neuron.Coordinate.Y);                    if (layer.IsRowCircular)                  {                      dx = Math.Min(dx' layerWidth - dx);                  }                  if (layer.IsColumnCircular)                  {                      dy = Math.Min(dy' layerHeight - dy);                  }                                    double dxSquare = dx * dx;                  double dySquare = dy * dy;                  if (layer.Topology == LatticeTopology.Hexagonal)                  {                      if (dy % 2 == 1)                      {                          dxSquare += 0.25 + (((neuron.Coordinate.X > winnerX )== (winnerY % 2 ==0))? dx: -dx);                      }                      dySquare *= 0.75;                  }                  neuron.neighborhoodValue = Math.Exp(-(dxSquare + dySquare) / twoSigmaSquare);              }
Magic Number,NeuronDotNet.Core.SOM.NeighborhoodFunctions,GaussianFunction,C:\repos\luiges90_ZhongHuaSanGuoZhi\NeuralDotNet\SOM\NeighborhoodFunctions\GaussianFunction.cs,EvaluateNeighborhood,The following statement contains a magic number: foreach (PositionNeuron neuron in layer.Neurons)              {                  int dx = Math.Abs(winnerX - neuron.Coordinate.X);                  int dy = Math.Abs(winnerY - neuron.Coordinate.Y);                    if (layer.IsRowCircular)                  {                      dx = Math.Min(dx' layerWidth - dx);                  }                  if (layer.IsColumnCircular)                  {                      dy = Math.Min(dy' layerHeight - dy);                  }                                    double dxSquare = dx * dx;                  double dySquare = dy * dy;                  if (layer.Topology == LatticeTopology.Hexagonal)                  {                      if (dy % 2 == 1)                      {                          dxSquare += 0.25 + (((neuron.Coordinate.X > winnerX )== (winnerY % 2 ==0))? dx: -dx);                      }                      dySquare *= 0.75;                  }                  neuron.neighborhoodValue = Math.Exp(-(dxSquare + dySquare) / twoSigmaSquare);              }
Magic Number,NeuronDotNet.Core.SOM.NeighborhoodFunctions,GaussianFunction,C:\repos\luiges90_ZhongHuaSanGuoZhi\NeuralDotNet\SOM\NeighborhoodFunctions\GaussianFunction.cs,EvaluateNeighborhood,The following statement contains a magic number: foreach (PositionNeuron neuron in layer.Neurons)              {                  int dx = Math.Abs(winnerX - neuron.Coordinate.X);                  int dy = Math.Abs(winnerY - neuron.Coordinate.Y);                    if (layer.IsRowCircular)                  {                      dx = Math.Min(dx' layerWidth - dx);                  }                  if (layer.IsColumnCircular)                  {                      dy = Math.Min(dy' layerHeight - dy);                  }                                    double dxSquare = dx * dx;                  double dySquare = dy * dy;                  if (layer.Topology == LatticeTopology.Hexagonal)                  {                      if (dy % 2 == 1)                      {                          dxSquare += 0.25 + (((neuron.Coordinate.X > winnerX )== (winnerY % 2 ==0))? dx: -dx);                      }                      dySquare *= 0.75;                  }                  neuron.neighborhoodValue = Math.Exp(-(dxSquare + dySquare) / twoSigmaSquare);              }
Magic Number,NeuronDotNet.Core.SOM.NeighborhoodFunctions,GaussianFunction,C:\repos\luiges90_ZhongHuaSanGuoZhi\NeuralDotNet\SOM\NeighborhoodFunctions\GaussianFunction.cs,EvaluateNeighborhood,The following statement contains a magic number: foreach (PositionNeuron neuron in layer.Neurons)              {                  int dx = Math.Abs(winnerX - neuron.Coordinate.X);                  int dy = Math.Abs(winnerY - neuron.Coordinate.Y);                    if (layer.IsRowCircular)                  {                      dx = Math.Min(dx' layerWidth - dx);                  }                  if (layer.IsColumnCircular)                  {                      dy = Math.Min(dy' layerHeight - dy);                  }                                    double dxSquare = dx * dx;                  double dySquare = dy * dy;                  if (layer.Topology == LatticeTopology.Hexagonal)                  {                      if (dy % 2 == 1)                      {                          dxSquare += 0.25 + (((neuron.Coordinate.X > winnerX )== (winnerY % 2 ==0))? dx: -dx);                      }                      dySquare *= 0.75;                  }                  neuron.neighborhoodValue = Math.Exp(-(dxSquare + dySquare) / twoSigmaSquare);              }
