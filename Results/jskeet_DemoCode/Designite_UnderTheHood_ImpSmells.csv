Implementation smell,Namespace,Class,File,Method,Description
Magic Number,UnderTheHood,DemoStateMachine,C:\repos\jskeet_DemoCode\AsyncIntro\Code\UnderTheHood\DecompilationSampleDecompiled.cs,MoveNext,The following statement contains a magic number: try                  {                      bool doFinallyBodies = true;                      switch (state)                      {                          case -3:                              goto Done;                          case 0:                              goto FirstAwaitContinuation;                          case 1:                              goto SecondAwaitContinuation;                      }                      // Default case - first call (state is -1)                      total = 0;                      iterator = text.GetEnumerator();                    // We really want to jump straight to FirstAwaitRealContinuation' but we can't                  // goto a label inside a try block...                  FirstAwaitContinuation:                      // foreach loop                      try                      {                          // for/foreach loops typically have the condition at the end of the generated code.                          // We want to go there *unless* we're trying to reach the first continuation.                          if (state != 0)                          {                              goto LoopCondition;                          }                          goto FirstAwaitRealContinuation;                      LoopBody:                          ch = iterator.Current;                          unicode = ch;                          TaskAwaiter localTaskAwaiter = Task.Delay(unicode).GetAwaiter();                          if (localTaskAwaiter.IsCompleted)                          {                              goto FirstAwaitCompletion;                          }                          state = 0;                          taskAwaiter = localTaskAwaiter;                          builder.AwaitUnsafeOnCompleted(ref localTaskAwaiter' ref this);                          doFinallyBodies = false;                          return;                      FirstAwaitRealContinuation:                          localTaskAwaiter = taskAwaiter;                          taskAwaiter = default(TaskAwaiter);                          state = -1;                      FirstAwaitCompletion:                          localTaskAwaiter.GetResult();                          localTaskAwaiter = default(TaskAwaiter);                          total += unicode;                      LoopCondition:                          if (iterator.MoveNext())                          {                              goto LoopBody;                          }                      }                      finally                      {                          if (doFinallyBodies && iterator != null)                          {                              iterator.Dispose();                          }                      }                        // After the loop                      YieldAwaitable.YieldAwaiter localYieldAwaiter = Task.Yield().GetAwaiter();                      if (localYieldAwaiter.IsCompleted)                      {                          goto SecondAwaitCompletion;                      }                      state = 1;                      yieldAwaiter = localYieldAwaiter;                      builder.AwaitUnsafeOnCompleted(ref localYieldAwaiter' ref this);                      doFinallyBodies = false;                      return;                    SecondAwaitContinuation:                      localYieldAwaiter = yieldAwaiter;                      yieldAwaiter = default(YieldAwaitable.YieldAwaiter);                      state = -1;                  SecondAwaitCompletion:                      localYieldAwaiter.GetResult();                      localYieldAwaiter = default(YieldAwaitable.YieldAwaiter);                      result = total;                  }                  catch (Exception ex)                  {                      state = -2;                      builder.SetException(ex);                      return;                  }
Magic Number,UnderTheHood,DemoStateMachine,C:\repos\jskeet_DemoCode\AsyncIntro\Code\UnderTheHood\DecompilationSampleDecompiled.cs,MoveNext,The following statement contains a magic number: try                  {                      bool doFinallyBodies = true;                      switch (state)                      {                          case -3:                              goto Done;                          case 0:                              goto FirstAwaitContinuation;                          case 1:                              goto SecondAwaitContinuation;                      }                      // Default case - first call (state is -1)                      total = 0;                      iterator = text.GetEnumerator();                    // We really want to jump straight to FirstAwaitRealContinuation' but we can't                  // goto a label inside a try block...                  FirstAwaitContinuation:                      // foreach loop                      try                      {                          // for/foreach loops typically have the condition at the end of the generated code.                          // We want to go there *unless* we're trying to reach the first continuation.                          if (state != 0)                          {                              goto LoopCondition;                          }                          goto FirstAwaitRealContinuation;                      LoopBody:                          ch = iterator.Current;                          unicode = ch;                          TaskAwaiter localTaskAwaiter = Task.Delay(unicode).GetAwaiter();                          if (localTaskAwaiter.IsCompleted)                          {                              goto FirstAwaitCompletion;                          }                          state = 0;                          taskAwaiter = localTaskAwaiter;                          builder.AwaitUnsafeOnCompleted(ref localTaskAwaiter' ref this);                          doFinallyBodies = false;                          return;                      FirstAwaitRealContinuation:                          localTaskAwaiter = taskAwaiter;                          taskAwaiter = default(TaskAwaiter);                          state = -1;                      FirstAwaitCompletion:                          localTaskAwaiter.GetResult();                          localTaskAwaiter = default(TaskAwaiter);                          total += unicode;                      LoopCondition:                          if (iterator.MoveNext())                          {                              goto LoopBody;                          }                      }                      finally                      {                          if (doFinallyBodies && iterator != null)                          {                              iterator.Dispose();                          }                      }                        // After the loop                      YieldAwaitable.YieldAwaiter localYieldAwaiter = Task.Yield().GetAwaiter();                      if (localYieldAwaiter.IsCompleted)                      {                          goto SecondAwaitCompletion;                      }                      state = 1;                      yieldAwaiter = localYieldAwaiter;                      builder.AwaitUnsafeOnCompleted(ref localYieldAwaiter' ref this);                      doFinallyBodies = false;                      return;                    SecondAwaitContinuation:                      localYieldAwaiter = yieldAwaiter;                      yieldAwaiter = default(YieldAwaitable.YieldAwaiter);                      state = -1;                  SecondAwaitCompletion:                      localYieldAwaiter.GetResult();                      localYieldAwaiter = default(YieldAwaitable.YieldAwaiter);                      result = total;                  }                  catch (Exception ex)                  {                      state = -2;                      builder.SetException(ex);                      return;                  }
Magic Number,UnderTheHood,DemoStateMachine,C:\repos\jskeet_DemoCode\AsyncIntro\Code\UnderTheHood\DecompilationSampleDecompiled.cs,MoveNext,The following statement contains a magic number: Done:                  state = -2;
Magic Number,UnderTheHood,DemoStateMachine,C:\repos\jskeet_DemoCode\AsyncIntro\Code\UnderTheHood\DecompilationSampleDecompiled.cs,MoveNext,The following statement contains a magic number: try                  {                      bool doFinallyBodies = true;                      TaskAwaiter<int> localAwaiter;                      int localLhs;                        switch (state)                      {                          case -3:                              goto Done;                          case 0:                              goto FirstAwaitContinuation;                          case 1:                              goto SecondAwaitContinuation;                      }                      // Default case - first call (state = -1)                      y = 10;                      z = Task.FromResult(10);                      localAwaiter = z.GetAwaiter();                      localLhs = y;                      if (localAwaiter.IsCompleted)                      {                          goto FirstAwaitCompletion;                      }                      stack = localLhs;                      state = 0;                      awaiter = localAwaiter;                      builder.AwaitUnsafeOnCompleted(ref awaiter' ref this);                      doFinallyBodies = false;                      return;                  FirstAwaitContinuation:                      localLhs = (int)stack;                      stack = null;                      localAwaiter = awaiter;                      awaiter = default(TaskAwaiter<int>);                      state = -1;                  FirstAwaitCompletion:                      int localRhs = localAwaiter.GetResult();                      x = localLhs * localRhs;                        // Second section of code...                      task = Task.FromResult(20);                        string localArg0 = "{0} {1}";                      int localArg1 = x;                      localAwaiter = task.GetAwaiter();                      if (localAwaiter.IsCompleted)                      {                          goto SecondAwaitCompletion;                      }                      var localTuple = new Tuple<string' int>(localArg0' localArg1);                      stack = localTuple;                      state = 1;                      awaiter = localAwaiter;                      builder.AwaitUnsafeOnCompleted(ref awaiter' ref this);                      doFinallyBodies = false;                      return;                  SecondAwaitContinuation:                      localTuple = (Tuple<string' int>) stack;                      localArg0 = localTuple.Item1;                      localArg1 = localTuple.Item2;                      localAwaiter = awaiter;                      awaiter = default(TaskAwaiter<int>);                      state = -1;                  SecondAwaitCompletion:                      int localArg2 = localAwaiter.GetResult();                      Console.WriteLine(localArg0' localArg1' localArg2);                  }                  catch (Exception ex)                  {                      state = -2;                      builder.SetException(ex);                      return;                  }
Magic Number,UnderTheHood,DemoStateMachine,C:\repos\jskeet_DemoCode\AsyncIntro\Code\UnderTheHood\DecompilationSampleDecompiled.cs,MoveNext,The following statement contains a magic number: try                  {                      bool doFinallyBodies = true;                      TaskAwaiter<int> localAwaiter;                      int localLhs;                        switch (state)                      {                          case -3:                              goto Done;                          case 0:                              goto FirstAwaitContinuation;                          case 1:                              goto SecondAwaitContinuation;                      }                      // Default case - first call (state = -1)                      y = 10;                      z = Task.FromResult(10);                      localAwaiter = z.GetAwaiter();                      localLhs = y;                      if (localAwaiter.IsCompleted)                      {                          goto FirstAwaitCompletion;                      }                      stack = localLhs;                      state = 0;                      awaiter = localAwaiter;                      builder.AwaitUnsafeOnCompleted(ref awaiter' ref this);                      doFinallyBodies = false;                      return;                  FirstAwaitContinuation:                      localLhs = (int)stack;                      stack = null;                      localAwaiter = awaiter;                      awaiter = default(TaskAwaiter<int>);                      state = -1;                  FirstAwaitCompletion:                      int localRhs = localAwaiter.GetResult();                      x = localLhs * localRhs;                        // Second section of code...                      task = Task.FromResult(20);                        string localArg0 = "{0} {1}";                      int localArg1 = x;                      localAwaiter = task.GetAwaiter();                      if (localAwaiter.IsCompleted)                      {                          goto SecondAwaitCompletion;                      }                      var localTuple = new Tuple<string' int>(localArg0' localArg1);                      stack = localTuple;                      state = 1;                      awaiter = localAwaiter;                      builder.AwaitUnsafeOnCompleted(ref awaiter' ref this);                      doFinallyBodies = false;                      return;                  SecondAwaitContinuation:                      localTuple = (Tuple<string' int>) stack;                      localArg0 = localTuple.Item1;                      localArg1 = localTuple.Item2;                      localAwaiter = awaiter;                      awaiter = default(TaskAwaiter<int>);                      state = -1;                  SecondAwaitCompletion:                      int localArg2 = localAwaiter.GetResult();                      Console.WriteLine(localArg0' localArg1' localArg2);                  }                  catch (Exception ex)                  {                      state = -2;                      builder.SetException(ex);                      return;                  }
Magic Number,UnderTheHood,DemoStateMachine,C:\repos\jskeet_DemoCode\AsyncIntro\Code\UnderTheHood\DecompilationSampleDecompiled.cs,MoveNext,The following statement contains a magic number: try                  {                      bool doFinallyBodies = true;                      TaskAwaiter<int> localAwaiter;                      int localLhs;                        switch (state)                      {                          case -3:                              goto Done;                          case 0:                              goto FirstAwaitContinuation;                          case 1:                              goto SecondAwaitContinuation;                      }                      // Default case - first call (state = -1)                      y = 10;                      z = Task.FromResult(10);                      localAwaiter = z.GetAwaiter();                      localLhs = y;                      if (localAwaiter.IsCompleted)                      {                          goto FirstAwaitCompletion;                      }                      stack = localLhs;                      state = 0;                      awaiter = localAwaiter;                      builder.AwaitUnsafeOnCompleted(ref awaiter' ref this);                      doFinallyBodies = false;                      return;                  FirstAwaitContinuation:                      localLhs = (int)stack;                      stack = null;                      localAwaiter = awaiter;                      awaiter = default(TaskAwaiter<int>);                      state = -1;                  FirstAwaitCompletion:                      int localRhs = localAwaiter.GetResult();                      x = localLhs * localRhs;                        // Second section of code...                      task = Task.FromResult(20);                        string localArg0 = "{0} {1}";                      int localArg1 = x;                      localAwaiter = task.GetAwaiter();                      if (localAwaiter.IsCompleted)                      {                          goto SecondAwaitCompletion;                      }                      var localTuple = new Tuple<string' int>(localArg0' localArg1);                      stack = localTuple;                      state = 1;                      awaiter = localAwaiter;                      builder.AwaitUnsafeOnCompleted(ref awaiter' ref this);                      doFinallyBodies = false;                      return;                  SecondAwaitContinuation:                      localTuple = (Tuple<string' int>) stack;                      localArg0 = localTuple.Item1;                      localArg1 = localTuple.Item2;                      localAwaiter = awaiter;                      awaiter = default(TaskAwaiter<int>);                      state = -1;                  SecondAwaitCompletion:                      int localArg2 = localAwaiter.GetResult();                      Console.WriteLine(localArg0' localArg1' localArg2);                  }                  catch (Exception ex)                  {                      state = -2;                      builder.SetException(ex);                      return;                  }
Magic Number,UnderTheHood,DemoStateMachine,C:\repos\jskeet_DemoCode\AsyncIntro\Code\UnderTheHood\DecompilationSampleDecompiled.cs,MoveNext,The following statement contains a magic number: try                  {                      bool doFinallyBodies = true;                      TaskAwaiter<int> localAwaiter;                      int localLhs;                        switch (state)                      {                          case -3:                              goto Done;                          case 0:                              goto FirstAwaitContinuation;                          case 1:                              goto SecondAwaitContinuation;                      }                      // Default case - first call (state = -1)                      y = 10;                      z = Task.FromResult(10);                      localAwaiter = z.GetAwaiter();                      localLhs = y;                      if (localAwaiter.IsCompleted)                      {                          goto FirstAwaitCompletion;                      }                      stack = localLhs;                      state = 0;                      awaiter = localAwaiter;                      builder.AwaitUnsafeOnCompleted(ref awaiter' ref this);                      doFinallyBodies = false;                      return;                  FirstAwaitContinuation:                      localLhs = (int)stack;                      stack = null;                      localAwaiter = awaiter;                      awaiter = default(TaskAwaiter<int>);                      state = -1;                  FirstAwaitCompletion:                      int localRhs = localAwaiter.GetResult();                      x = localLhs * localRhs;                        // Second section of code...                      task = Task.FromResult(20);                        string localArg0 = "{0} {1}";                      int localArg1 = x;                      localAwaiter = task.GetAwaiter();                      if (localAwaiter.IsCompleted)                      {                          goto SecondAwaitCompletion;                      }                      var localTuple = new Tuple<string' int>(localArg0' localArg1);                      stack = localTuple;                      state = 1;                      awaiter = localAwaiter;                      builder.AwaitUnsafeOnCompleted(ref awaiter' ref this);                      doFinallyBodies = false;                      return;                  SecondAwaitContinuation:                      localTuple = (Tuple<string' int>) stack;                      localArg0 = localTuple.Item1;                      localArg1 = localTuple.Item2;                      localAwaiter = awaiter;                      awaiter = default(TaskAwaiter<int>);                      state = -1;                  SecondAwaitCompletion:                      int localArg2 = localAwaiter.GetResult();                      Console.WriteLine(localArg0' localArg1' localArg2);                  }                  catch (Exception ex)                  {                      state = -2;                      builder.SetException(ex);                      return;                  }
Magic Number,UnderTheHood,DemoStateMachine,C:\repos\jskeet_DemoCode\AsyncIntro\Code\UnderTheHood\DecompilationSampleDecompiled.cs,MoveNext,The following statement contains a magic number: try                  {                      bool doFinallyBodies = true;                      TaskAwaiter<int> localAwaiter;                      int localLhs;                        switch (state)                      {                          case -3:                              goto Done;                          case 0:                              goto FirstAwaitContinuation;                          case 1:                              goto SecondAwaitContinuation;                      }                      // Default case - first call (state = -1)                      y = 10;                      z = Task.FromResult(10);                      localAwaiter = z.GetAwaiter();                      localLhs = y;                      if (localAwaiter.IsCompleted)                      {                          goto FirstAwaitCompletion;                      }                      stack = localLhs;                      state = 0;                      awaiter = localAwaiter;                      builder.AwaitUnsafeOnCompleted(ref awaiter' ref this);                      doFinallyBodies = false;                      return;                  FirstAwaitContinuation:                      localLhs = (int)stack;                      stack = null;                      localAwaiter = awaiter;                      awaiter = default(TaskAwaiter<int>);                      state = -1;                  FirstAwaitCompletion:                      int localRhs = localAwaiter.GetResult();                      x = localLhs * localRhs;                        // Second section of code...                      task = Task.FromResult(20);                        string localArg0 = "{0} {1}";                      int localArg1 = x;                      localAwaiter = task.GetAwaiter();                      if (localAwaiter.IsCompleted)                      {                          goto SecondAwaitCompletion;                      }                      var localTuple = new Tuple<string' int>(localArg0' localArg1);                      stack = localTuple;                      state = 1;                      awaiter = localAwaiter;                      builder.AwaitUnsafeOnCompleted(ref awaiter' ref this);                      doFinallyBodies = false;                      return;                  SecondAwaitContinuation:                      localTuple = (Tuple<string' int>) stack;                      localArg0 = localTuple.Item1;                      localArg1 = localTuple.Item2;                      localAwaiter = awaiter;                      awaiter = default(TaskAwaiter<int>);                      state = -1;                  SecondAwaitCompletion:                      int localArg2 = localAwaiter.GetResult();                      Console.WriteLine(localArg0' localArg1' localArg2);                  }                  catch (Exception ex)                  {                      state = -2;                      builder.SetException(ex);                      return;                  }
Magic Number,UnderTheHood,DemoStateMachine,C:\repos\jskeet_DemoCode\AsyncIntro\Code\UnderTheHood\DecompilationSampleDecompiled.cs,MoveNext,The following statement contains a magic number: Done:                  state = -2;
Magic Number,UnderTheHood,LogicalStack,C:\repos\jskeet_DemoCode\AsyncIntro\Code\UnderTheHood\LogicalStack.cs,DemonstrateStacks,The following statement contains a magic number: int y = 10;
Magic Number,UnderTheHood,LogicalStack,C:\repos\jskeet_DemoCode\AsyncIntro\Code\UnderTheHood\LogicalStack.cs,DemonstrateStacks,The following statement contains a magic number: Task<int> z = Task.FromResult(10);
Magic Number,UnderTheHood,LogicalStack,C:\repos\jskeet_DemoCode\AsyncIntro\Code\UnderTheHood\LogicalStack.cs,DemonstrateStacks,The following statement contains a magic number: Task<int> task = Task.FromResult(20);
Missing Default,UnderTheHood,DemoStateMachine,C:\repos\jskeet_DemoCode\AsyncIntro\Code\UnderTheHood\DecompilationSampleDecompiled.cs,MoveNext,The following switch statement is missing a default case: switch (state)                      {                          case -3:                              goto Done;                          case 0:                              goto FirstAwaitContinuation;                          case 1:                              goto SecondAwaitContinuation;                      }
Missing Default,UnderTheHood,DemoStateMachine,C:\repos\jskeet_DemoCode\AsyncIntro\Code\UnderTheHood\DecompilationSampleDecompiled.cs,MoveNext,The following switch statement is missing a default case: switch (state)                      {                          case -3:                              goto Done;                          case 0:                              goto FirstAwaitContinuation;                          case 1:                              goto SecondAwaitContinuation;                      }
