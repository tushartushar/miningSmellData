Implementation smell,Namespace,Class,File,Method,Description
Long Parameter List,Fusillade,RateLimitedHttpMessageHandler,C:\repos\paulcbetts_Fusillade\src\Fusillade\RateLimitedHttpMessageHandler.cs,RateLimitedHttpMessageHandler,The method has 6 parameters. Parameters: handler' basePriority' priority' maxBytesToRead' opQueue' cacheResultFunc
Magic Number,Fusillade,NetCache,C:\repos\paulcbetts_Fusillade\src\Fusillade\Interfaces.cs,NetCache,The following statement contains a magic number: speculative = new RateLimitedHttpMessageHandler(innerHandler' Priority.Speculative' 0' 1048576 * 5);
Magic Number,Fusillade,NetCache,C:\repos\paulcbetts_Fusillade\src\Fusillade\Interfaces.cs,NetCache,The following statement contains a magic number: speculative = new RateLimitedHttpMessageHandler(innerHandler' Priority.Speculative' 0' 1048576 * 5);
Magic Number,Fusillade,RateLimitedHttpMessageHandler,C:\repos\paulcbetts_Fusillade\src\Fusillade\RateLimitedHttpMessageHandler.cs,SendAsync,The following statement contains a magic number: queue.Enqueue(priority' null' realToken.Token' async () => {                 try {                     var resp = await base.SendAsync(request' realToken.Token);                      if (maxBytesToRead != null && resp.Content != null && resp.Content.Headers.ContentLength != null) {                         maxBytesToRead -= resp.Content.Headers.ContentLength;                     }                      if (cacheResult != null && resp.Content != null) {                         var ms = new MemoryStream();                         var stream = await resp.Content.ReadAsStreamAsync();                         await stream.CopyToAsync(ms' 32 * 1024' realToken.Token);                          realToken.Token.ThrowIfCancellationRequested();                          var newResp = new HttpResponseMessage();                         foreach (var kvp in resp.Headers) { newResp.Headers.Add(kvp.Key' kvp.Value); }                          var newContent = new ByteArrayContent(ms.ToArray());                         foreach (var kvp in resp.Content.Headers) { newContent.Headers.Add(kvp.Key' kvp.Value); }                         newResp.Content = newContent;                          resp = newResp;                         await cacheResult(request' resp' key' realToken.Token);                     }                      return resp;                 } finally {                     lock(inflightResponses) inflightResponses.Remove(key);                 }             }).ToObservable().Subscribe(ret.Response);
Magic Number,Fusillade,RateLimitedHttpMessageHandler,C:\repos\paulcbetts_Fusillade\src\Fusillade\RateLimitedHttpMessageHandler.cs,SendAsync,The following statement contains a magic number: queue.Enqueue(priority' null' realToken.Token' async () => {                 try {                     var resp = await base.SendAsync(request' realToken.Token);                      if (maxBytesToRead != null && resp.Content != null && resp.Content.Headers.ContentLength != null) {                         maxBytesToRead -= resp.Content.Headers.ContentLength;                     }                      if (cacheResult != null && resp.Content != null) {                         var ms = new MemoryStream();                         var stream = await resp.Content.ReadAsStreamAsync();                         await stream.CopyToAsync(ms' 32 * 1024' realToken.Token);                          realToken.Token.ThrowIfCancellationRequested();                          var newResp = new HttpResponseMessage();                         foreach (var kvp in resp.Headers) { newResp.Headers.Add(kvp.Key' kvp.Value); }                          var newContent = new ByteArrayContent(ms.ToArray());                         foreach (var kvp in resp.Content.Headers) { newContent.Headers.Add(kvp.Key' kvp.Value); }                         newResp.Content = newContent;                          resp = newResp;                         await cacheResult(request' resp' key' realToken.Token);                     }                      return resp;                 } finally {                     lock(inflightResponses) inflightResponses.Remove(key);                 }             }).ToObservable().Subscribe(ret.Response);
