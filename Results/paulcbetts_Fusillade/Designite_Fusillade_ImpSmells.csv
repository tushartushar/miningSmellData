Implementation smell,Namespace,Class,File,Method,Description
Long Method,Fusillade,RateLimitedHttpMessageHandler,C:\research\architectureSmells\repos\paulcbetts_Fusillade\src\Fusillade\RateLimitedHttpMessageHandler.cs,SendAsync,The method has 104 lines of code.
Long Parameter List,Fusillade,RateLimitedHttpMessageHandler,C:\research\architectureSmells\repos\paulcbetts_Fusillade\src\Fusillade\RateLimitedHttpMessageHandler.cs,RateLimitedHttpMessageHandler,The method has 6 parameters. Parameters: handler' basePriority' priority' maxBytesToRead' opQueue' cacheResultFunc
Long Statement,Fusillade,OfflineHttpMessageHandler,C:\research\architectureSmells\repos\paulcbetts_Fusillade\src\Fusillade\OfflineHttpMessageHandler.cs,SendAsync,The length of the statement  "            var body = await retrieveBody(request' RateLimitedHttpMessageHandler.UniqueKeyForRequest(request)' cancellationToken).ConfigureAwait(false);" is 140.
Magic Number,Fusillade,NetCache,C:\research\architectureSmells\repos\paulcbetts_Fusillade\src\Fusillade\NetCache.cs,NetCache,The following statement contains a magic number: speculative = new RateLimitedHttpMessageHandler(innerHandler' Priority.Speculative' 0' 1048576 * 5);
Magic Number,Fusillade,NetCache,C:\research\architectureSmells\repos\paulcbetts_Fusillade\src\Fusillade\NetCache.cs,NetCache,The following statement contains a magic number: speculative = new RateLimitedHttpMessageHandler(innerHandler' Priority.Speculative' 0' 1048576 * 5);
Magic Number,Fusillade,RateLimitedHttpMessageHandler,C:\research\architectureSmells\repos\paulcbetts_Fusillade\src\Fusillade\RateLimitedHttpMessageHandler.cs,SendAsync,The following statement contains a magic number: queue.Enqueue(                 _priority'                 null'                 async () =>                 {                     try                     {                         var resp = await base.SendAsync(request' realToken.Token).ConfigureAwait(false);                          if (_maxBytesToRead != null && resp.Content != null && resp.Content.Headers.ContentLength != null)                         {                             _maxBytesToRead -= resp.Content.Headers.ContentLength;                         }                          if (cacheResult != null && resp.Content != null)                         {                             var ms = new MemoryStream();                             var stream = await resp.Content.ReadAsStreamAsync().ConfigureAwait(false);                             await stream.CopyToAsync(ms' 32 * 1024' realToken.Token).ConfigureAwait(false);                              realToken.Token.ThrowIfCancellationRequested();                              var newResp = new HttpResponseMessage();                             foreach (var kvp in resp.Headers)                             {                                 newResp.Headers.Add(kvp.Key' kvp.Value);                             }                              var newContent = new ByteArrayContent(ms.ToArray());                             foreach (var kvp in resp.Content.Headers)                             {                                 newContent.Headers.Add(kvp.Key' kvp.Value);                             }                              newResp.Content = newContent;                              resp = newResp;                             await cacheResult(request' resp' key' realToken.Token).ConfigureAwait(false);                         }                          return resp;                     }                     finally                     {                         lock (_inflightResponses)                         {                             _inflightResponses.Remove(key);                         }                     }                 }'                 realToken.Token).ToObservable().Subscribe(ret.Response);
Magic Number,Fusillade,RateLimitedHttpMessageHandler,C:\research\architectureSmells\repos\paulcbetts_Fusillade\src\Fusillade\RateLimitedHttpMessageHandler.cs,SendAsync,The following statement contains a magic number: queue.Enqueue(                 _priority'                 null'                 async () =>                 {                     try                     {                         var resp = await base.SendAsync(request' realToken.Token).ConfigureAwait(false);                          if (_maxBytesToRead != null && resp.Content != null && resp.Content.Headers.ContentLength != null)                         {                             _maxBytesToRead -= resp.Content.Headers.ContentLength;                         }                          if (cacheResult != null && resp.Content != null)                         {                             var ms = new MemoryStream();                             var stream = await resp.Content.ReadAsStreamAsync().ConfigureAwait(false);                             await stream.CopyToAsync(ms' 32 * 1024' realToken.Token).ConfigureAwait(false);                              realToken.Token.ThrowIfCancellationRequested();                              var newResp = new HttpResponseMessage();                             foreach (var kvp in resp.Headers)                             {                                 newResp.Headers.Add(kvp.Key' kvp.Value);                             }                              var newContent = new ByteArrayContent(ms.ToArray());                             foreach (var kvp in resp.Content.Headers)                             {                                 newContent.Headers.Add(kvp.Key' kvp.Value);                             }                              newResp.Content = newContent;                              resp = newResp;                             await cacheResult(request' resp' key' realToken.Token).ConfigureAwait(false);                         }                          return resp;                     }                     finally                     {                         lock (_inflightResponses)                         {                             _inflightResponses.Remove(key);                         }                     }                 }'                 realToken.Token).ToObservable().Subscribe(ret.Response);
