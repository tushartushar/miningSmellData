Implementation smell,Namespace,Class,File,Method,Description
Long Method,TSqlFlex.Core,FieldScripting,C:\repos\nycdotnet_TSqlFlex\Code\TSqlFlex.Core\FieldScripting.cs,valueAsTSQLLiteral,The method has 102 lines of code.
Long Method,TSqlFlex.Core,QueryWorker,C:\repos\nycdotnet_TSqlFlex\Code\TSqlFlex.Core\QueryWorker.cs,DoSqlQueryWork,The method has 122 lines of code.
Complex Method,TSqlFlex.Core,CSVRenderer,C:\repos\nycdotnet_TSqlFlex\Code\TSqlFlex.Core\CSVRenderer.cs,renderAsCSV,Cyclomatic complexity of the method is 10
Complex Method,TSqlFlex.Core,FieldScripting,C:\repos\nycdotnet_TSqlFlex\Code\TSqlFlex.Core\FieldScripting.cs,scriptDataAsInsertForSQL2008Plus,Cyclomatic complexity of the method is 9
Long Identifier,TSqlFlex.Core,FieldScripting,C:\repos\nycdotnet_TSqlFlex\Code\TSqlFlex.Core\FieldScripting.cs,scriptDataAsInsertForSQL2008Plus,The length of the parameter calibrateBufferCapacityAfterRow is 31.
Long Identifier,TSqlFlex.Core,QueryWorker,C:\repos\nycdotnet_TSqlFlex\Code\TSqlFlex.Core\QueryWorker.cs,renderExceptionToSqlRunParameters,The length of the parameter generalDescriptionOfWhenTheErrorOccurred is 40.
Long Identifier,TSqlFlex.Core,SqlRunParameters,C:\repos\nycdotnet_TSqlFlex\Code\TSqlFlex.Core\SqlRunParameters.cs,saveOutputStreamsTo,The length of the parameter saveAsFileNameWithAsteriskForIndex is 34.
Long Statement,TSqlFlex.Core,FieldScripting,C:\repos\nycdotnet_TSqlFlex\Code\TSqlFlex.Core\FieldScripting.cs,DataTypeName,The length of the statement  "                return "float";  //this could be a float or a real.  There is no simple way to tell via ado.net.  Will try to keep it consistent with float. " is 140.
Long Statement,TSqlFlex.Core,FieldScripting,C:\repos\nycdotnet_TSqlFlex\Code\TSqlFlex.Core\FieldScripting.cs,DataTypeParameterIfAny,The length of the statement  "            if (fieldInfo.DataType == "nvarchar" || fieldInfo.DataType == "varchar" || fieldInfo.DataType == "nchar" || fieldInfo.DataType == "char" || fieldInfo.DataType == "binary" || fieldInfo.DataType == "varbinary") " is 208.
Long Statement,TSqlFlex.Core,FieldScripting,C:\repos\nycdotnet_TSqlFlex\Code\TSqlFlex.Core\FieldScripting.cs,DataTypeParameterIfAny,The length of the statement  "                //from MSDN: SQL Server treats n as one of two possible values. If 1<=n<=24' n is treated as 24. If 25<=n<=53' n is treated as 53. " is 130.
Long Statement,TSqlFlex.Core,FieldScripting,C:\repos\nycdotnet_TSqlFlex\Code\TSqlFlex.Core\FieldScripting.cs,EscapeObjectName,The length of the statement  "            if (TSqlRules.IsReservedWord(rawObjectName) || TSqlRules.ContainsWhitespace(rawObjectName) || TSqlRules.ContainsSquareBracket(rawObjectName)) " is 141.
Long Statement,TSqlFlex.Core,FieldScripting,C:\repos\nycdotnet_TSqlFlex\Code\TSqlFlex.Core\FieldScripting.cs,IsBracketEscaped,The length of the statement  "            return (objectName.StartsWith("[") && objectName.EndsWith("]"));  //bug: this is good enough for now' but may not properly consider edge case escaped ] as the final character for example " is 186.
Long Statement,TSqlFlex.Core,FieldScripting,C:\repos\nycdotnet_TSqlFlex\Code\TSqlFlex.Core\FieldScripting.cs,scriptDataAsInsertForSQL2008Plus,The length of the statement  "            const int INITIAL_CAPACITY = 50000; //This is small enough that it won't matter' but big enough to ensure minimal initial resizes. " is 130.
Long Statement,TSqlFlex.Core,FieldScripting,C:\repos\nycdotnet_TSqlFlex\Code\TSqlFlex.Core\FieldScripting.cs,valueAsTSQLLiteral,The length of the statement  "            else if (fieldInfo.DataType == "bigint" || fieldInfo.DataType == "numeric" || fieldInfo.DataType == "smallint" || fieldInfo.DataType == "decimal" || fieldInfo.DataType == "smallmoney" || " is 186.
Long Statement,TSqlFlex.Core,FieldScripting,C:\repos\nycdotnet_TSqlFlex\Code\TSqlFlex.Core\FieldScripting.cs,valueAsTSQLLiteral,The length of the statement  "                fieldInfo.DataType == "int" || fieldInfo.DataType == "tinyint" || fieldInfo.DataType == "float" || fieldInfo.DataType == "real" || fieldInfo.DataType == "money") " is 161.
Long Statement,TSqlFlex.Core,FieldScripting,C:\repos\nycdotnet_TSqlFlex\Code\TSqlFlex.Core\FieldScripting.cs,formatDateTime,The length of the statement  "            return possiblyEncloseInQuotes(String.Format("{0}.{1}"'d.ToString("s")' d.ToString("fff").TrimEnd('0'))' forTSQLScript); " is 120.
Long Statement,TSqlFlex.Core,FieldScripting,C:\repos\nycdotnet_TSqlFlex\Code\TSqlFlex.Core\FieldScripting.cs,formatTime,The length of the statement  "            return String.Format("{1}{0}{1}"' data.ToString()' quoting); //todo: this should not get hit' but should have a consistent strategy for dealing with this. " is 154.
Long Statement,TSqlFlex.Core,FieldScripting,C:\repos\nycdotnet_TSqlFlex\Code\TSqlFlex.Core\FieldScripting.cs,formatDatetimeoffset,The length of the statement  "            return String.Format("{1}{0}.{3}{2}{1}"' d.ToString("s")' quoting' d.ToString("zzzz")' d.ToString("fffffff").TrimEnd('0')); " is 123.
Long Statement,TSqlFlex.Core,FlexResultSet,C:\repos\nycdotnet_TSqlFlex\Code\TSqlFlex.Core\FlexResultSet.cs,ScriptResultAsCreateTable,The length of the statement  "            //todo: columnnames must be unique in a table.  It's possible to have a result set with duplicate column names' but not a table. " is 128.
Long Statement,TSqlFlex.Core,Logging,C:\repos\nycdotnet_TSqlFlex\Code\TSqlFlex.Core\Logging.cs,Log,The length of the statement  "                string logEntry = "\"" + DateTime.Now.ToString("yyyy-MM-ddThh:mm:ss.fffffff") + "\"'\"" + TextToLog.Replace("\""'"\"\"") + "\""; " is 128.
Long Statement,TSqlFlex.Core,QueryWorker,C:\repos\nycdotnet_TSqlFlex\Code\TSqlFlex.Core\QueryWorker.cs,renderAndCountExceptions,The length of the statement  "                sb.Append(String.Format("--There were {0} exception(s) encountered while running the query.\r\n"' resultSet.exceptions.Count)); " is 127.
Long Statement,TSqlFlex.Core,QueryWorker,C:\repos\nycdotnet_TSqlFlex\Code\TSqlFlex.Core\QueryWorker.cs,renderSchemaAndData,The length of the statement  "                    sb.AppendLine(FieldScripting.ScriptResultDataAsInsert(resultSet.results[i]' resultTableName' FlexResultSet.SQL2008MaxRowsInValuesClause).ToString()); " is 149.
Long Statement,TSqlFlex.Core,SQLColumnList,C:\repos\nycdotnet_TSqlFlex\Code\TSqlFlex.Core\SQLColumn.cs,CreateFromSchemaTable,The length of the statement  "                    IsHidden = fieldDefinition[(int)FieldScripting.ADONetFieldInfo.IsHidden] == DBNull.Value ? false : (bool)fieldDefinition[(int)FieldScripting.ADONetFieldInfo.IsHidden]  " is 166.
Long Statement,TSqlFlex.Core,SqlRunParameters,C:\repos\nycdotnet_TSqlFlex\Code\TSqlFlex.Core\SqlRunParameters.cs,openNewOutputStream,The length of the statement  "            Stream isoStream = new IsolatedStorageFileStream(this.currentFileName' FileMode.OpenOrCreate' FileAccess.Write' isolatedStore); " is 127.
Long Statement,TSqlFlex.Core,Utils,C:\repos\nycdotnet_TSqlFlex\Code\TSqlFlex.Core\Utils.cs,IsValidConnectionStringBuilder,The length of the statement  "                    return (builder.IntegratedSecurity || !string.IsNullOrEmpty(builder.UserID)); //technically someone could have a blank password? " is 128.
Long Statement,TSqlFlex.Core,XmlSpreadsheetRenderer,C:\repos\nycdotnet_TSqlFlex\Code\TSqlFlex.Core\XmlSpreadsheetRenderer.cs,renderAsXMLSpreadsheet,The length of the statement  "                    srp.WriteToStream(String.Format("<Table ss:ExpandedColumnCount=\"{0}\" ss:ExpandedRowCount=\"{1}\" x:FullColumns=\"1\" x:FullRows=\"1\" ss:DefaultRowHeight=\"15\">"' " is 165.
Long Statement,TSqlFlex.Core,XmlSpreadsheetRenderer,C:\repos\nycdotnet_TSqlFlex\Code\TSqlFlex.Core\XmlSpreadsheetRenderer.cs,renderAsXMLSpreadsheet,The length of the statement  "                        srp.WriteToStream(String.Format("<Cell ss:StyleID=\"s62\"><Data ss:Type=\"String\">{0}</Data></Cell>"' columnName(result' colIndex))); " is 134.
Long Statement,TSqlFlex.Core,XmlSpreadsheetRenderer,C:\repos\nycdotnet_TSqlFlex\Code\TSqlFlex.Core\XmlSpreadsheetRenderer.cs,renderAsXMLSpreadsheet,The length of the statement  "                            else if (fieldInfo.DataType == "bigint" || fieldInfo.DataType == "numeric" || fieldInfo.DataType == "smallint" || fieldInfo.DataType == "decimal" || fieldInfo.DataType == "smallmoney" || " is 186.
Long Statement,TSqlFlex.Core,XmlSpreadsheetRenderer,C:\repos\nycdotnet_TSqlFlex\Code\TSqlFlex.Core\XmlSpreadsheetRenderer.cs,renderAsXMLSpreadsheet,The length of the statement  "                                fieldInfo.DataType == "int" || fieldInfo.DataType == "tinyint" || fieldInfo.DataType == "float" || fieldInfo.DataType == "real" || fieldInfo.DataType == "money" || fieldInfo.DataType == "bit") " is 192.
Long Statement,TSqlFlex.Core,XmlSpreadsheetRenderer,C:\repos\nycdotnet_TSqlFlex\Code\TSqlFlex.Core\XmlSpreadsheetRenderer.cs,renderAsXMLSpreadsheet,The length of the statement  "                                srp.WriteToStream(String.Format("<Cell><Data ss:Type=\"Number\">{0}</Data></Cell>\r\n"' escapeForXML(FieldScripting.valueAsTSQLLiteral(fieldData' fieldInfo' false)))); " is 167.
Long Statement,TSqlFlex.Core,XmlSpreadsheetRenderer,C:\repos\nycdotnet_TSqlFlex\Code\TSqlFlex.Core\XmlSpreadsheetRenderer.cs,renderAsXMLSpreadsheet,The length of the statement  "                                srp.WriteToStream(String.Format("<Cell ss:StyleID=\"s64\"><Data ss:Type=\"String\">{0}</Data></Cell>\r\n"' escapeForXML(FieldScripting.formatBinary(d'd.Length)))); " is 163.
Long Statement,TSqlFlex.Core,XmlSpreadsheetRenderer,C:\repos\nycdotnet_TSqlFlex\Code\TSqlFlex.Core\XmlSpreadsheetRenderer.cs,renderAsXMLSpreadsheet,The length of the statement  "                                srp.WriteToStream(String.Format("<Cell ss:StyleID=\"s64\"><Data ss:Type=\"String\">{0}</Data></Cell>\r\n"' escapeForXML(FieldScripting.formatVarbinary(fieldData)))); " is 165.
Long Statement,TSqlFlex.Core,XmlSpreadsheetRenderer,C:\repos\nycdotnet_TSqlFlex\Code\TSqlFlex.Core\XmlSpreadsheetRenderer.cs,renderAsXMLSpreadsheet,The length of the statement  "                                srp.WriteToStream(String.Format("<Cell ss:StyleID=\"s65\"><Data ss:Type=\"DateTime\">1899-12-31T{0}:{1}:{2}.{3}</Data></Cell>\r\n"' " is 131.
Long Statement,TSqlFlex.Core,XmlSpreadsheetRenderer,C:\repos\nycdotnet_TSqlFlex\Code\TSqlFlex.Core\XmlSpreadsheetRenderer.cs,renderAsXMLSpreadsheet,The length of the statement  "                                srp.WriteToStream(String.Format("<Cell ss:StyleID=\"s64\"><Data ss:Type=\"String\">{0}</Data></Cell>\r\n"' escapeForXML(FieldScripting.valueAsTSQLLiteral(fieldData' fieldInfo' false)))); " is 186.
Long Statement,TSqlFlex.Core,XmlSpreadsheetRenderer,C:\repos\nycdotnet_TSqlFlex\Code\TSqlFlex.Core\XmlSpreadsheetRenderer.cs,escapeForXML,The length of the statement  "            return input.Replace("&"' "&amp;").Replace("<"' "&lt;").Replace(">"' "&gt;").Replace("\""' "&quot;").Replace("'"' "&apos;"); " is 124.
Complex Conditional,TSqlFlex.Core,CSVRenderer,C:\repos\nycdotnet_TSqlFlex\Code\TSqlFlex.Core\CSVRenderer.cs,escapeForCSV,The conditional expression  "input.Substring(0' 1) == "0" ||                  input.Contains('"') ||                  input.Contains(''') ||                  input.Contains('\n') ||                  input.Contains('\r')"  is complex.
Complex Conditional,TSqlFlex.Core,FieldScripting,C:\repos\nycdotnet_TSqlFlex\Code\TSqlFlex.Core\FieldScripting.cs,DataTypeParameterIfAny,The conditional expression  "fieldInfo.DataType == "nvarchar" || fieldInfo.DataType == "varchar" || fieldInfo.DataType == "nchar" || fieldInfo.DataType == "char" || fieldInfo.DataType == "binary" || fieldInfo.DataType == "varbinary""  is complex.
Complex Conditional,TSqlFlex.Core,FieldScripting,C:\repos\nycdotnet_TSqlFlex\Code\TSqlFlex.Core\FieldScripting.cs,valueAsTSQLLiteral,The conditional expression  "fieldInfo.DataType == "bigint" || fieldInfo.DataType == "numeric" || fieldInfo.DataType == "smallint" || fieldInfo.DataType == "decimal" || fieldInfo.DataType == "smallmoney" ||                  fieldInfo.DataType == "int" || fieldInfo.DataType == "tinyint" || fieldInfo.DataType == "float" || fieldInfo.DataType == "real" || fieldInfo.DataType == "money""  is complex.
Complex Conditional,TSqlFlex.Core,XmlSpreadsheetRenderer,C:\repos\nycdotnet_TSqlFlex\Code\TSqlFlex.Core\XmlSpreadsheetRenderer.cs,renderAsXMLSpreadsheet,The conditional expression  "fieldInfo.DataType == "bigint" || fieldInfo.DataType == "numeric" || fieldInfo.DataType == "smallint" || fieldInfo.DataType == "decimal" || fieldInfo.DataType == "smallmoney" ||                                  fieldInfo.DataType == "int" || fieldInfo.DataType == "tinyint" || fieldInfo.DataType == "float" || fieldInfo.DataType == "real" || fieldInfo.DataType == "money" || fieldInfo.DataType == "bit""  is complex.
Complex Conditional,TSqlFlex.Core,XmlSpreadsheetRenderer,C:\repos\nycdotnet_TSqlFlex\Code\TSqlFlex.Core\XmlSpreadsheetRenderer.cs,renderAsXMLSpreadsheet,The conditional expression  "fieldInfo.DataType == "date" || fieldInfo.DataType == "datetime2" || fieldInfo.DataType == "datetime" ||                                  fieldInfo.DataType == "smalldatetime""  is complex.
Virtual Method Call from Constructor,TSqlFlex.Core,ExternalProgramLauncher,C:\repos\nycdotnet_TSqlFlex\Code\TSqlFlex.Core\ExternalProgramLauncher.cs,ExternalProgramLauncher,The constructor "ExternalProgramLauncher" calls a virtual method "findProgram".
Empty Catch Block,TSqlFlex.Core,SqlRunParameters,C:\repos\nycdotnet_TSqlFlex\Code\TSqlFlex.Core\SqlRunParameters.cs,flushAndCloseOutputStreamIfNeeded,The method has an empty catch block.
Magic Number,TSqlFlex.Core,Config,C:\repos\nycdotnet_TSqlFlex\Code\TSqlFlex.Core\Config.cs,Config,The following statement contains a magic number: CommandTimeoutInSeconds = getLocalMachineDWORD(TSqlFlexKey' "CommandTimeoutInSeconds").GetValueOrDefault(60 * 5);
Magic Number,TSqlFlex.Core,Config,C:\repos\nycdotnet_TSqlFlex\Code\TSqlFlex.Core\Config.cs,Config,The following statement contains a magic number: CommandTimeoutInSeconds = getLocalMachineDWORD(TSqlFlexKey' "CommandTimeoutInSeconds").GetValueOrDefault(60 * 5);
Magic Number,TSqlFlex.Core,ExternalProgramLauncher,C:\repos\nycdotnet_TSqlFlex\Code\TSqlFlex.Core\ExternalProgramLauncher.cs,IsOdd,The following statement contains a magic number: return value % 2 != 0;
Magic Number,TSqlFlex.Core,FieldScripting,C:\repos\nycdotnet_TSqlFlex\Code\TSqlFlex.Core\FieldScripting.cs,DataTypeParameterIfAny,The following statement contains a magic number: if (fieldInfo.DataType == "nvarchar" || fieldInfo.DataType == "varchar" || fieldInfo.DataType == "nchar" || fieldInfo.DataType == "char" || fieldInfo.DataType == "binary" || fieldInfo.DataType == "varbinary")              {                  if (fieldInfo.ColumnSize == Int32.MaxValue)                  {                      return "(MAX)";                  }                  return "(" + fieldInfo.ColumnSize.ToString() + ")";              }              else if (fieldInfo.DataType == "numeric" || fieldInfo.DataType == "decimal")              {                  return "(" + fieldInfo.NumericPrecision.ToString() + "'" + fieldInfo.NumericScale.ToString() + ")";              }              else if (fieldInfo.DataType == "real")              {                  return "(24)";              }              else if (fieldInfo.DataType == "float")              {                  //from MSDN: SQL Server treats n as one of two possible values. If 1<=n<=24' n is treated as 24. If 25<=n<=53' n is treated as 53.                  return "(53)";              }              else if (fieldInfo.DataType == "datetimeoffset" || fieldInfo.DataType == "time")              {                  //see: http://msdn.microsoft.com/en-us/library/bb630289.aspx                    if (fieldInfo.NumericScale <= 2)                  {                      return "(2)";                  }                  if (fieldInfo.NumericScale <= 4)                  {                      return "(4)";                  }                  return "";              }              else if (fieldInfo.DataType == "datetime2")              {                  if (fieldInfo.NumericScale < 7)                  {                      return $"({fieldInfo.NumericScale.ToString()})";                  }                  return "";              }
Magic Number,TSqlFlex.Core,FieldScripting,C:\repos\nycdotnet_TSqlFlex\Code\TSqlFlex.Core\FieldScripting.cs,DataTypeParameterIfAny,The following statement contains a magic number: if (fieldInfo.DataType == "nvarchar" || fieldInfo.DataType == "varchar" || fieldInfo.DataType == "nchar" || fieldInfo.DataType == "char" || fieldInfo.DataType == "binary" || fieldInfo.DataType == "varbinary")              {                  if (fieldInfo.ColumnSize == Int32.MaxValue)                  {                      return "(MAX)";                  }                  return "(" + fieldInfo.ColumnSize.ToString() + ")";              }              else if (fieldInfo.DataType == "numeric" || fieldInfo.DataType == "decimal")              {                  return "(" + fieldInfo.NumericPrecision.ToString() + "'" + fieldInfo.NumericScale.ToString() + ")";              }              else if (fieldInfo.DataType == "real")              {                  return "(24)";              }              else if (fieldInfo.DataType == "float")              {                  //from MSDN: SQL Server treats n as one of two possible values. If 1<=n<=24' n is treated as 24. If 25<=n<=53' n is treated as 53.                  return "(53)";              }              else if (fieldInfo.DataType == "datetimeoffset" || fieldInfo.DataType == "time")              {                  //see: http://msdn.microsoft.com/en-us/library/bb630289.aspx                    if (fieldInfo.NumericScale <= 2)                  {                      return "(2)";                  }                  if (fieldInfo.NumericScale <= 4)                  {                      return "(4)";                  }                  return "";              }              else if (fieldInfo.DataType == "datetime2")              {                  if (fieldInfo.NumericScale < 7)                  {                      return $"({fieldInfo.NumericScale.ToString()})";                  }                  return "";              }
Magic Number,TSqlFlex.Core,FieldScripting,C:\repos\nycdotnet_TSqlFlex\Code\TSqlFlex.Core\FieldScripting.cs,DataTypeParameterIfAny,The following statement contains a magic number: if (fieldInfo.DataType == "nvarchar" || fieldInfo.DataType == "varchar" || fieldInfo.DataType == "nchar" || fieldInfo.DataType == "char" || fieldInfo.DataType == "binary" || fieldInfo.DataType == "varbinary")              {                  if (fieldInfo.ColumnSize == Int32.MaxValue)                  {                      return "(MAX)";                  }                  return "(" + fieldInfo.ColumnSize.ToString() + ")";              }              else if (fieldInfo.DataType == "numeric" || fieldInfo.DataType == "decimal")              {                  return "(" + fieldInfo.NumericPrecision.ToString() + "'" + fieldInfo.NumericScale.ToString() + ")";              }              else if (fieldInfo.DataType == "real")              {                  return "(24)";              }              else if (fieldInfo.DataType == "float")              {                  //from MSDN: SQL Server treats n as one of two possible values. If 1<=n<=24' n is treated as 24. If 25<=n<=53' n is treated as 53.                  return "(53)";              }              else if (fieldInfo.DataType == "datetimeoffset" || fieldInfo.DataType == "time")              {                  //see: http://msdn.microsoft.com/en-us/library/bb630289.aspx                    if (fieldInfo.NumericScale <= 2)                  {                      return "(2)";                  }                  if (fieldInfo.NumericScale <= 4)                  {                      return "(4)";                  }                  return "";              }              else if (fieldInfo.DataType == "datetime2")              {                  if (fieldInfo.NumericScale < 7)                  {                      return $"({fieldInfo.NumericScale.ToString()})";                  }                  return "";              }
Magic Number,TSqlFlex.Core,FieldScripting,C:\repos\nycdotnet_TSqlFlex\Code\TSqlFlex.Core\FieldScripting.cs,scriptDataAsInsertForSQL2008Plus,The following statement contains a magic number: const int INITIAL_CAPACITY = 50000;
Magic Number,TSqlFlex.Core,FieldScripting,C:\repos\nycdotnet_TSqlFlex\Code\TSqlFlex.Core\FieldScripting.cs,scriptDataAsInsertForSQL2008Plus,The following statement contains a magic number: for (int rowIndex = 0; rowIndex < rowCount; rowIndex++)              {                  if (rowIndex % MaxRowsInValuesClause == 0)                  {                      buffer.Append("INSERT INTO " + tableName + " VALUES\r\n");                  }                  buffer.Append(" (");                  for (int columnIndex = 0; columnIndex < columnCount; columnIndex++)                  {                      buffer.Append(valueAsTSQLLiteral(data[rowIndex][columnIndex]' schema[columnIndex]));                      if (columnIndex + 1 < columnCount)                      {                          buffer.Append("'");                      }                  }                  if (rowIndex + 1 == rowCount || (rowIndex + 1) % MaxRowsInValuesClause == 0)                  {                      buffer.Append(");\r\n\r\n");                  }                  else                  {                      buffer.Append(")'\r\n");                  }                    if (rowIndex == calibrateBufferCapacityAfterRow && rowIndex + 1 < rowCount)                  {                      //We are going to attempt to ensure there is an appropriate capacity to                      // minimize the number of capacity adjustments required.                        const int CHARACTERS_IN_INSERT_BLOCK = 27;                      const double TEN_PERCENT_SLACK = 1.1;                        int singleInsertLineLength = CHARACTERS_IN_INSERT_BLOCK + tableName.Length;                      int averageDataRowLength = (buffer.Length - singleInsertLineLength) / (rowIndex + 1);                        int totalInsertLineLengths = singleInsertLineLength * rowCount / 100;                      int totalDataRowLengths = (Int32)(averageDataRowLength * rowCount * TEN_PERCENT_SLACK);                        int newCapacity = totalInsertLineLengths + totalDataRowLengths;                        if (newCapacity > buffer.Capacity)                      {                          buffer.EnsureCapacity(newCapacity);                      }                        //re-evaluate after the first "calibrateBufferCapacityAfterRow" rows to hopefully get a better average.                      if (calibrateBufferCapacityAfterRow == 0)                      {                          calibrateBufferCapacityAfterRow = 99;                      }                      else if (calibrateBufferCapacityAfterRow == 99)                      {                          calibrateBufferCapacityAfterRow = 999;                      }                      else if (calibrateBufferCapacityAfterRow == 999)                      {                          calibrateBufferCapacityAfterRow = 9999;                      }                      else                      {                          calibrateBufferCapacityAfterRow = -1; //no more re-evaluations.                      }                  }              }
Magic Number,TSqlFlex.Core,FieldScripting,C:\repos\nycdotnet_TSqlFlex\Code\TSqlFlex.Core\FieldScripting.cs,scriptDataAsInsertForSQL2008Plus,The following statement contains a magic number: for (int rowIndex = 0; rowIndex < rowCount; rowIndex++)              {                  if (rowIndex % MaxRowsInValuesClause == 0)                  {                      buffer.Append("INSERT INTO " + tableName + " VALUES\r\n");                  }                  buffer.Append(" (");                  for (int columnIndex = 0; columnIndex < columnCount; columnIndex++)                  {                      buffer.Append(valueAsTSQLLiteral(data[rowIndex][columnIndex]' schema[columnIndex]));                      if (columnIndex + 1 < columnCount)                      {                          buffer.Append("'");                      }                  }                  if (rowIndex + 1 == rowCount || (rowIndex + 1) % MaxRowsInValuesClause == 0)                  {                      buffer.Append(");\r\n\r\n");                  }                  else                  {                      buffer.Append(")'\r\n");                  }                    if (rowIndex == calibrateBufferCapacityAfterRow && rowIndex + 1 < rowCount)                  {                      //We are going to attempt to ensure there is an appropriate capacity to                      // minimize the number of capacity adjustments required.                        const int CHARACTERS_IN_INSERT_BLOCK = 27;                      const double TEN_PERCENT_SLACK = 1.1;                        int singleInsertLineLength = CHARACTERS_IN_INSERT_BLOCK + tableName.Length;                      int averageDataRowLength = (buffer.Length - singleInsertLineLength) / (rowIndex + 1);                        int totalInsertLineLengths = singleInsertLineLength * rowCount / 100;                      int totalDataRowLengths = (Int32)(averageDataRowLength * rowCount * TEN_PERCENT_SLACK);                        int newCapacity = totalInsertLineLengths + totalDataRowLengths;                        if (newCapacity > buffer.Capacity)                      {                          buffer.EnsureCapacity(newCapacity);                      }                        //re-evaluate after the first "calibrateBufferCapacityAfterRow" rows to hopefully get a better average.                      if (calibrateBufferCapacityAfterRow == 0)                      {                          calibrateBufferCapacityAfterRow = 99;                      }                      else if (calibrateBufferCapacityAfterRow == 99)                      {                          calibrateBufferCapacityAfterRow = 999;                      }                      else if (calibrateBufferCapacityAfterRow == 999)                      {                          calibrateBufferCapacityAfterRow = 9999;                      }                      else                      {                          calibrateBufferCapacityAfterRow = -1; //no more re-evaluations.                      }                  }              }
Magic Number,TSqlFlex.Core,FieldScripting,C:\repos\nycdotnet_TSqlFlex\Code\TSqlFlex.Core\FieldScripting.cs,scriptDataAsInsertForSQL2008Plus,The following statement contains a magic number: for (int rowIndex = 0; rowIndex < rowCount; rowIndex++)              {                  if (rowIndex % MaxRowsInValuesClause == 0)                  {                      buffer.Append("INSERT INTO " + tableName + " VALUES\r\n");                  }                  buffer.Append(" (");                  for (int columnIndex = 0; columnIndex < columnCount; columnIndex++)                  {                      buffer.Append(valueAsTSQLLiteral(data[rowIndex][columnIndex]' schema[columnIndex]));                      if (columnIndex + 1 < columnCount)                      {                          buffer.Append("'");                      }                  }                  if (rowIndex + 1 == rowCount || (rowIndex + 1) % MaxRowsInValuesClause == 0)                  {                      buffer.Append(");\r\n\r\n");                  }                  else                  {                      buffer.Append(")'\r\n");                  }                    if (rowIndex == calibrateBufferCapacityAfterRow && rowIndex + 1 < rowCount)                  {                      //We are going to attempt to ensure there is an appropriate capacity to                      // minimize the number of capacity adjustments required.                        const int CHARACTERS_IN_INSERT_BLOCK = 27;                      const double TEN_PERCENT_SLACK = 1.1;                        int singleInsertLineLength = CHARACTERS_IN_INSERT_BLOCK + tableName.Length;                      int averageDataRowLength = (buffer.Length - singleInsertLineLength) / (rowIndex + 1);                        int totalInsertLineLengths = singleInsertLineLength * rowCount / 100;                      int totalDataRowLengths = (Int32)(averageDataRowLength * rowCount * TEN_PERCENT_SLACK);                        int newCapacity = totalInsertLineLengths + totalDataRowLengths;                        if (newCapacity > buffer.Capacity)                      {                          buffer.EnsureCapacity(newCapacity);                      }                        //re-evaluate after the first "calibrateBufferCapacityAfterRow" rows to hopefully get a better average.                      if (calibrateBufferCapacityAfterRow == 0)                      {                          calibrateBufferCapacityAfterRow = 99;                      }                      else if (calibrateBufferCapacityAfterRow == 99)                      {                          calibrateBufferCapacityAfterRow = 999;                      }                      else if (calibrateBufferCapacityAfterRow == 999)                      {                          calibrateBufferCapacityAfterRow = 9999;                      }                      else                      {                          calibrateBufferCapacityAfterRow = -1; //no more re-evaluations.                      }                  }              }
Magic Number,TSqlFlex.Core,FieldScripting,C:\repos\nycdotnet_TSqlFlex\Code\TSqlFlex.Core\FieldScripting.cs,scriptDataAsInsertForSQL2008Plus,The following statement contains a magic number: for (int rowIndex = 0; rowIndex < rowCount; rowIndex++)              {                  if (rowIndex % MaxRowsInValuesClause == 0)                  {                      buffer.Append("INSERT INTO " + tableName + " VALUES\r\n");                  }                  buffer.Append(" (");                  for (int columnIndex = 0; columnIndex < columnCount; columnIndex++)                  {                      buffer.Append(valueAsTSQLLiteral(data[rowIndex][columnIndex]' schema[columnIndex]));                      if (columnIndex + 1 < columnCount)                      {                          buffer.Append("'");                      }                  }                  if (rowIndex + 1 == rowCount || (rowIndex + 1) % MaxRowsInValuesClause == 0)                  {                      buffer.Append(");\r\n\r\n");                  }                  else                  {                      buffer.Append(")'\r\n");                  }                    if (rowIndex == calibrateBufferCapacityAfterRow && rowIndex + 1 < rowCount)                  {                      //We are going to attempt to ensure there is an appropriate capacity to                      // minimize the number of capacity adjustments required.                        const int CHARACTERS_IN_INSERT_BLOCK = 27;                      const double TEN_PERCENT_SLACK = 1.1;                        int singleInsertLineLength = CHARACTERS_IN_INSERT_BLOCK + tableName.Length;                      int averageDataRowLength = (buffer.Length - singleInsertLineLength) / (rowIndex + 1);                        int totalInsertLineLengths = singleInsertLineLength * rowCount / 100;                      int totalDataRowLengths = (Int32)(averageDataRowLength * rowCount * TEN_PERCENT_SLACK);                        int newCapacity = totalInsertLineLengths + totalDataRowLengths;                        if (newCapacity > buffer.Capacity)                      {                          buffer.EnsureCapacity(newCapacity);                      }                        //re-evaluate after the first "calibrateBufferCapacityAfterRow" rows to hopefully get a better average.                      if (calibrateBufferCapacityAfterRow == 0)                      {                          calibrateBufferCapacityAfterRow = 99;                      }                      else if (calibrateBufferCapacityAfterRow == 99)                      {                          calibrateBufferCapacityAfterRow = 999;                      }                      else if (calibrateBufferCapacityAfterRow == 999)                      {                          calibrateBufferCapacityAfterRow = 9999;                      }                      else                      {                          calibrateBufferCapacityAfterRow = -1; //no more re-evaluations.                      }                  }              }
Magic Number,TSqlFlex.Core,FieldScripting,C:\repos\nycdotnet_TSqlFlex\Code\TSqlFlex.Core\FieldScripting.cs,scriptDataAsInsertForSQL2008Plus,The following statement contains a magic number: for (int rowIndex = 0; rowIndex < rowCount; rowIndex++)              {                  if (rowIndex % MaxRowsInValuesClause == 0)                  {                      buffer.Append("INSERT INTO " + tableName + " VALUES\r\n");                  }                  buffer.Append(" (");                  for (int columnIndex = 0; columnIndex < columnCount; columnIndex++)                  {                      buffer.Append(valueAsTSQLLiteral(data[rowIndex][columnIndex]' schema[columnIndex]));                      if (columnIndex + 1 < columnCount)                      {                          buffer.Append("'");                      }                  }                  if (rowIndex + 1 == rowCount || (rowIndex + 1) % MaxRowsInValuesClause == 0)                  {                      buffer.Append(");\r\n\r\n");                  }                  else                  {                      buffer.Append(")'\r\n");                  }                    if (rowIndex == calibrateBufferCapacityAfterRow && rowIndex + 1 < rowCount)                  {                      //We are going to attempt to ensure there is an appropriate capacity to                      // minimize the number of capacity adjustments required.                        const int CHARACTERS_IN_INSERT_BLOCK = 27;                      const double TEN_PERCENT_SLACK = 1.1;                        int singleInsertLineLength = CHARACTERS_IN_INSERT_BLOCK + tableName.Length;                      int averageDataRowLength = (buffer.Length - singleInsertLineLength) / (rowIndex + 1);                        int totalInsertLineLengths = singleInsertLineLength * rowCount / 100;                      int totalDataRowLengths = (Int32)(averageDataRowLength * rowCount * TEN_PERCENT_SLACK);                        int newCapacity = totalInsertLineLengths + totalDataRowLengths;                        if (newCapacity > buffer.Capacity)                      {                          buffer.EnsureCapacity(newCapacity);                      }                        //re-evaluate after the first "calibrateBufferCapacityAfterRow" rows to hopefully get a better average.                      if (calibrateBufferCapacityAfterRow == 0)                      {                          calibrateBufferCapacityAfterRow = 99;                      }                      else if (calibrateBufferCapacityAfterRow == 99)                      {                          calibrateBufferCapacityAfterRow = 999;                      }                      else if (calibrateBufferCapacityAfterRow == 999)                      {                          calibrateBufferCapacityAfterRow = 9999;                      }                      else                      {                          calibrateBufferCapacityAfterRow = -1; //no more re-evaluations.                      }                  }              }
Magic Number,TSqlFlex.Core,FieldScripting,C:\repos\nycdotnet_TSqlFlex\Code\TSqlFlex.Core\FieldScripting.cs,scriptDataAsInsertForSQL2008Plus,The following statement contains a magic number: for (int rowIndex = 0; rowIndex < rowCount; rowIndex++)              {                  if (rowIndex % MaxRowsInValuesClause == 0)                  {                      buffer.Append("INSERT INTO " + tableName + " VALUES\r\n");                  }                  buffer.Append(" (");                  for (int columnIndex = 0; columnIndex < columnCount; columnIndex++)                  {                      buffer.Append(valueAsTSQLLiteral(data[rowIndex][columnIndex]' schema[columnIndex]));                      if (columnIndex + 1 < columnCount)                      {                          buffer.Append("'");                      }                  }                  if (rowIndex + 1 == rowCount || (rowIndex + 1) % MaxRowsInValuesClause == 0)                  {                      buffer.Append(");\r\n\r\n");                  }                  else                  {                      buffer.Append(")'\r\n");                  }                    if (rowIndex == calibrateBufferCapacityAfterRow && rowIndex + 1 < rowCount)                  {                      //We are going to attempt to ensure there is an appropriate capacity to                      // minimize the number of capacity adjustments required.                        const int CHARACTERS_IN_INSERT_BLOCK = 27;                      const double TEN_PERCENT_SLACK = 1.1;                        int singleInsertLineLength = CHARACTERS_IN_INSERT_BLOCK + tableName.Length;                      int averageDataRowLength = (buffer.Length - singleInsertLineLength) / (rowIndex + 1);                        int totalInsertLineLengths = singleInsertLineLength * rowCount / 100;                      int totalDataRowLengths = (Int32)(averageDataRowLength * rowCount * TEN_PERCENT_SLACK);                        int newCapacity = totalInsertLineLengths + totalDataRowLengths;                        if (newCapacity > buffer.Capacity)                      {                          buffer.EnsureCapacity(newCapacity);                      }                        //re-evaluate after the first "calibrateBufferCapacityAfterRow" rows to hopefully get a better average.                      if (calibrateBufferCapacityAfterRow == 0)                      {                          calibrateBufferCapacityAfterRow = 99;                      }                      else if (calibrateBufferCapacityAfterRow == 99)                      {                          calibrateBufferCapacityAfterRow = 999;                      }                      else if (calibrateBufferCapacityAfterRow == 999)                      {                          calibrateBufferCapacityAfterRow = 9999;                      }                      else                      {                          calibrateBufferCapacityAfterRow = -1; //no more re-evaluations.                      }                  }              }
Magic Number,TSqlFlex.Core,FieldScripting,C:\repos\nycdotnet_TSqlFlex\Code\TSqlFlex.Core\FieldScripting.cs,scriptDataAsInsertForSQL2008Plus,The following statement contains a magic number: for (int rowIndex = 0; rowIndex < rowCount; rowIndex++)              {                  if (rowIndex % MaxRowsInValuesClause == 0)                  {                      buffer.Append("INSERT INTO " + tableName + " VALUES\r\n");                  }                  buffer.Append(" (");                  for (int columnIndex = 0; columnIndex < columnCount; columnIndex++)                  {                      buffer.Append(valueAsTSQLLiteral(data[rowIndex][columnIndex]' schema[columnIndex]));                      if (columnIndex + 1 < columnCount)                      {                          buffer.Append("'");                      }                  }                  if (rowIndex + 1 == rowCount || (rowIndex + 1) % MaxRowsInValuesClause == 0)                  {                      buffer.Append(");\r\n\r\n");                  }                  else                  {                      buffer.Append(")'\r\n");                  }                    if (rowIndex == calibrateBufferCapacityAfterRow && rowIndex + 1 < rowCount)                  {                      //We are going to attempt to ensure there is an appropriate capacity to                      // minimize the number of capacity adjustments required.                        const int CHARACTERS_IN_INSERT_BLOCK = 27;                      const double TEN_PERCENT_SLACK = 1.1;                        int singleInsertLineLength = CHARACTERS_IN_INSERT_BLOCK + tableName.Length;                      int averageDataRowLength = (buffer.Length - singleInsertLineLength) / (rowIndex + 1);                        int totalInsertLineLengths = singleInsertLineLength * rowCount / 100;                      int totalDataRowLengths = (Int32)(averageDataRowLength * rowCount * TEN_PERCENT_SLACK);                        int newCapacity = totalInsertLineLengths + totalDataRowLengths;                        if (newCapacity > buffer.Capacity)                      {                          buffer.EnsureCapacity(newCapacity);                      }                        //re-evaluate after the first "calibrateBufferCapacityAfterRow" rows to hopefully get a better average.                      if (calibrateBufferCapacityAfterRow == 0)                      {                          calibrateBufferCapacityAfterRow = 99;                      }                      else if (calibrateBufferCapacityAfterRow == 99)                      {                          calibrateBufferCapacityAfterRow = 999;                      }                      else if (calibrateBufferCapacityAfterRow == 999)                      {                          calibrateBufferCapacityAfterRow = 9999;                      }                      else                      {                          calibrateBufferCapacityAfterRow = -1; //no more re-evaluations.                      }                  }              }
Magic Number,TSqlFlex.Core,FieldScripting,C:\repos\nycdotnet_TSqlFlex\Code\TSqlFlex.Core\FieldScripting.cs,scriptDataAsInsertForSQL2008Plus,The following statement contains a magic number: for (int rowIndex = 0; rowIndex < rowCount; rowIndex++)              {                  if (rowIndex % MaxRowsInValuesClause == 0)                  {                      buffer.Append("INSERT INTO " + tableName + " VALUES\r\n");                  }                  buffer.Append(" (");                  for (int columnIndex = 0; columnIndex < columnCount; columnIndex++)                  {                      buffer.Append(valueAsTSQLLiteral(data[rowIndex][columnIndex]' schema[columnIndex]));                      if (columnIndex + 1 < columnCount)                      {                          buffer.Append("'");                      }                  }                  if (rowIndex + 1 == rowCount || (rowIndex + 1) % MaxRowsInValuesClause == 0)                  {                      buffer.Append(");\r\n\r\n");                  }                  else                  {                      buffer.Append(")'\r\n");                  }                    if (rowIndex == calibrateBufferCapacityAfterRow && rowIndex + 1 < rowCount)                  {                      //We are going to attempt to ensure there is an appropriate capacity to                      // minimize the number of capacity adjustments required.                        const int CHARACTERS_IN_INSERT_BLOCK = 27;                      const double TEN_PERCENT_SLACK = 1.1;                        int singleInsertLineLength = CHARACTERS_IN_INSERT_BLOCK + tableName.Length;                      int averageDataRowLength = (buffer.Length - singleInsertLineLength) / (rowIndex + 1);                        int totalInsertLineLengths = singleInsertLineLength * rowCount / 100;                      int totalDataRowLengths = (Int32)(averageDataRowLength * rowCount * TEN_PERCENT_SLACK);                        int newCapacity = totalInsertLineLengths + totalDataRowLengths;                        if (newCapacity > buffer.Capacity)                      {                          buffer.EnsureCapacity(newCapacity);                      }                        //re-evaluate after the first "calibrateBufferCapacityAfterRow" rows to hopefully get a better average.                      if (calibrateBufferCapacityAfterRow == 0)                      {                          calibrateBufferCapacityAfterRow = 99;                      }                      else if (calibrateBufferCapacityAfterRow == 99)                      {                          calibrateBufferCapacityAfterRow = 999;                      }                      else if (calibrateBufferCapacityAfterRow == 999)                      {                          calibrateBufferCapacityAfterRow = 9999;                      }                      else                      {                          calibrateBufferCapacityAfterRow = -1; //no more re-evaluations.                      }                  }              }
Magic Number,TSqlFlex.Core,FieldScripting,C:\repos\nycdotnet_TSqlFlex\Code\TSqlFlex.Core\FieldScripting.cs,formatTime,The following statement contains a magic number: if (data is TimeSpan)              {                  TimeSpan t = (TimeSpan)data;                  long ticksAfterWholeSecond = t.Ticks - ((long)Math.Floor(t.TotalSeconds) * TimeSpan.TicksPerSecond);                  if (ticksAfterWholeSecond == 0)                  {                      return String.Format("{3}{0}:{1}:{2}{3}"'                          t.Hours.ToString().PadLeft(2' '0')'                          t.Minutes.ToString().PadLeft(2' '0')'                          t.Seconds.ToString().PadLeft(2' '0')'                          quoting);                  }                  return String.Format("{4}{0}:{1}:{2}.{3}{4}"'                          t.Hours.ToString().PadLeft(2' '0')'                          t.Minutes.ToString().PadLeft(2' '0')'                          t.Seconds.ToString().PadLeft(2' '0')'                          ticksAfterWholeSecond.ToString().PadLeft(7''0').TrimEnd('0')'                          quoting);              }              else if (data is DateTime)              {                  DateTime d = (DateTime)data;                    if (d.ToString("fffffff") == "0000000")                  {                      return String.Format("{3}{0}:{1}:{2}{3}"'                          d.Hour.ToString().PadLeft(2' '0')'                          d.Minute.ToString().PadLeft(2' '0')'                          d.Second.ToString().PadLeft(2' '0')'                          quoting);                  }                  return String.Format("{4}{0}:{1}:{2}.{3}{4}"'                          d.Hour.ToString().PadLeft(2' '0')'                          d.Minute.ToString().PadLeft(2' '0')'                          d.Second.ToString().PadLeft(2' '0')'                          d.ToString("fffffff").TrimEnd('0')'                          quoting);              }
Magic Number,TSqlFlex.Core,FieldScripting,C:\repos\nycdotnet_TSqlFlex\Code\TSqlFlex.Core\FieldScripting.cs,formatTime,The following statement contains a magic number: if (data is TimeSpan)              {                  TimeSpan t = (TimeSpan)data;                  long ticksAfterWholeSecond = t.Ticks - ((long)Math.Floor(t.TotalSeconds) * TimeSpan.TicksPerSecond);                  if (ticksAfterWholeSecond == 0)                  {                      return String.Format("{3}{0}:{1}:{2}{3}"'                          t.Hours.ToString().PadLeft(2' '0')'                          t.Minutes.ToString().PadLeft(2' '0')'                          t.Seconds.ToString().PadLeft(2' '0')'                          quoting);                  }                  return String.Format("{4}{0}:{1}:{2}.{3}{4}"'                          t.Hours.ToString().PadLeft(2' '0')'                          t.Minutes.ToString().PadLeft(2' '0')'                          t.Seconds.ToString().PadLeft(2' '0')'                          ticksAfterWholeSecond.ToString().PadLeft(7''0').TrimEnd('0')'                          quoting);              }              else if (data is DateTime)              {                  DateTime d = (DateTime)data;                    if (d.ToString("fffffff") == "0000000")                  {                      return String.Format("{3}{0}:{1}:{2}{3}"'                          d.Hour.ToString().PadLeft(2' '0')'                          d.Minute.ToString().PadLeft(2' '0')'                          d.Second.ToString().PadLeft(2' '0')'                          quoting);                  }                  return String.Format("{4}{0}:{1}:{2}.{3}{4}"'                          d.Hour.ToString().PadLeft(2' '0')'                          d.Minute.ToString().PadLeft(2' '0')'                          d.Second.ToString().PadLeft(2' '0')'                          d.ToString("fffffff").TrimEnd('0')'                          quoting);              }
Magic Number,TSqlFlex.Core,FieldScripting,C:\repos\nycdotnet_TSqlFlex\Code\TSqlFlex.Core\FieldScripting.cs,formatTime,The following statement contains a magic number: if (data is TimeSpan)              {                  TimeSpan t = (TimeSpan)data;                  long ticksAfterWholeSecond = t.Ticks - ((long)Math.Floor(t.TotalSeconds) * TimeSpan.TicksPerSecond);                  if (ticksAfterWholeSecond == 0)                  {                      return String.Format("{3}{0}:{1}:{2}{3}"'                          t.Hours.ToString().PadLeft(2' '0')'                          t.Minutes.ToString().PadLeft(2' '0')'                          t.Seconds.ToString().PadLeft(2' '0')'                          quoting);                  }                  return String.Format("{4}{0}:{1}:{2}.{3}{4}"'                          t.Hours.ToString().PadLeft(2' '0')'                          t.Minutes.ToString().PadLeft(2' '0')'                          t.Seconds.ToString().PadLeft(2' '0')'                          ticksAfterWholeSecond.ToString().PadLeft(7''0').TrimEnd('0')'                          quoting);              }              else if (data is DateTime)              {                  DateTime d = (DateTime)data;                    if (d.ToString("fffffff") == "0000000")                  {                      return String.Format("{3}{0}:{1}:{2}{3}"'                          d.Hour.ToString().PadLeft(2' '0')'                          d.Minute.ToString().PadLeft(2' '0')'                          d.Second.ToString().PadLeft(2' '0')'                          quoting);                  }                  return String.Format("{4}{0}:{1}:{2}.{3}{4}"'                          d.Hour.ToString().PadLeft(2' '0')'                          d.Minute.ToString().PadLeft(2' '0')'                          d.Second.ToString().PadLeft(2' '0')'                          d.ToString("fffffff").TrimEnd('0')'                          quoting);              }
Magic Number,TSqlFlex.Core,FieldScripting,C:\repos\nycdotnet_TSqlFlex\Code\TSqlFlex.Core\FieldScripting.cs,formatTime,The following statement contains a magic number: if (data is TimeSpan)              {                  TimeSpan t = (TimeSpan)data;                  long ticksAfterWholeSecond = t.Ticks - ((long)Math.Floor(t.TotalSeconds) * TimeSpan.TicksPerSecond);                  if (ticksAfterWholeSecond == 0)                  {                      return String.Format("{3}{0}:{1}:{2}{3}"'                          t.Hours.ToString().PadLeft(2' '0')'                          t.Minutes.ToString().PadLeft(2' '0')'                          t.Seconds.ToString().PadLeft(2' '0')'                          quoting);                  }                  return String.Format("{4}{0}:{1}:{2}.{3}{4}"'                          t.Hours.ToString().PadLeft(2' '0')'                          t.Minutes.ToString().PadLeft(2' '0')'                          t.Seconds.ToString().PadLeft(2' '0')'                          ticksAfterWholeSecond.ToString().PadLeft(7''0').TrimEnd('0')'                          quoting);              }              else if (data is DateTime)              {                  DateTime d = (DateTime)data;                    if (d.ToString("fffffff") == "0000000")                  {                      return String.Format("{3}{0}:{1}:{2}{3}"'                          d.Hour.ToString().PadLeft(2' '0')'                          d.Minute.ToString().PadLeft(2' '0')'                          d.Second.ToString().PadLeft(2' '0')'                          quoting);                  }                  return String.Format("{4}{0}:{1}:{2}.{3}{4}"'                          d.Hour.ToString().PadLeft(2' '0')'                          d.Minute.ToString().PadLeft(2' '0')'                          d.Second.ToString().PadLeft(2' '0')'                          d.ToString("fffffff").TrimEnd('0')'                          quoting);              }
Magic Number,TSqlFlex.Core,FieldScripting,C:\repos\nycdotnet_TSqlFlex\Code\TSqlFlex.Core\FieldScripting.cs,formatTime,The following statement contains a magic number: if (data is TimeSpan)              {                  TimeSpan t = (TimeSpan)data;                  long ticksAfterWholeSecond = t.Ticks - ((long)Math.Floor(t.TotalSeconds) * TimeSpan.TicksPerSecond);                  if (ticksAfterWholeSecond == 0)                  {                      return String.Format("{3}{0}:{1}:{2}{3}"'                          t.Hours.ToString().PadLeft(2' '0')'                          t.Minutes.ToString().PadLeft(2' '0')'                          t.Seconds.ToString().PadLeft(2' '0')'                          quoting);                  }                  return String.Format("{4}{0}:{1}:{2}.{3}{4}"'                          t.Hours.ToString().PadLeft(2' '0')'                          t.Minutes.ToString().PadLeft(2' '0')'                          t.Seconds.ToString().PadLeft(2' '0')'                          ticksAfterWholeSecond.ToString().PadLeft(7''0').TrimEnd('0')'                          quoting);              }              else if (data is DateTime)              {                  DateTime d = (DateTime)data;                    if (d.ToString("fffffff") == "0000000")                  {                      return String.Format("{3}{0}:{1}:{2}{3}"'                          d.Hour.ToString().PadLeft(2' '0')'                          d.Minute.ToString().PadLeft(2' '0')'                          d.Second.ToString().PadLeft(2' '0')'                          quoting);                  }                  return String.Format("{4}{0}:{1}:{2}.{3}{4}"'                          d.Hour.ToString().PadLeft(2' '0')'                          d.Minute.ToString().PadLeft(2' '0')'                          d.Second.ToString().PadLeft(2' '0')'                          d.ToString("fffffff").TrimEnd('0')'                          quoting);              }
Magic Number,TSqlFlex.Core,FieldScripting,C:\repos\nycdotnet_TSqlFlex\Code\TSqlFlex.Core\FieldScripting.cs,formatTime,The following statement contains a magic number: if (data is TimeSpan)              {                  TimeSpan t = (TimeSpan)data;                  long ticksAfterWholeSecond = t.Ticks - ((long)Math.Floor(t.TotalSeconds) * TimeSpan.TicksPerSecond);                  if (ticksAfterWholeSecond == 0)                  {                      return String.Format("{3}{0}:{1}:{2}{3}"'                          t.Hours.ToString().PadLeft(2' '0')'                          t.Minutes.ToString().PadLeft(2' '0')'                          t.Seconds.ToString().PadLeft(2' '0')'                          quoting);                  }                  return String.Format("{4}{0}:{1}:{2}.{3}{4}"'                          t.Hours.ToString().PadLeft(2' '0')'                          t.Minutes.ToString().PadLeft(2' '0')'                          t.Seconds.ToString().PadLeft(2' '0')'                          ticksAfterWholeSecond.ToString().PadLeft(7''0').TrimEnd('0')'                          quoting);              }              else if (data is DateTime)              {                  DateTime d = (DateTime)data;                    if (d.ToString("fffffff") == "0000000")                  {                      return String.Format("{3}{0}:{1}:{2}{3}"'                          d.Hour.ToString().PadLeft(2' '0')'                          d.Minute.ToString().PadLeft(2' '0')'                          d.Second.ToString().PadLeft(2' '0')'                          quoting);                  }                  return String.Format("{4}{0}:{1}:{2}.{3}{4}"'                          d.Hour.ToString().PadLeft(2' '0')'                          d.Minute.ToString().PadLeft(2' '0')'                          d.Second.ToString().PadLeft(2' '0')'                          d.ToString("fffffff").TrimEnd('0')'                          quoting);              }
Magic Number,TSqlFlex.Core,FieldScripting,C:\repos\nycdotnet_TSqlFlex\Code\TSqlFlex.Core\FieldScripting.cs,formatTime,The following statement contains a magic number: if (data is TimeSpan)              {                  TimeSpan t = (TimeSpan)data;                  long ticksAfterWholeSecond = t.Ticks - ((long)Math.Floor(t.TotalSeconds) * TimeSpan.TicksPerSecond);                  if (ticksAfterWholeSecond == 0)                  {                      return String.Format("{3}{0}:{1}:{2}{3}"'                          t.Hours.ToString().PadLeft(2' '0')'                          t.Minutes.ToString().PadLeft(2' '0')'                          t.Seconds.ToString().PadLeft(2' '0')'                          quoting);                  }                  return String.Format("{4}{0}:{1}:{2}.{3}{4}"'                          t.Hours.ToString().PadLeft(2' '0')'                          t.Minutes.ToString().PadLeft(2' '0')'                          t.Seconds.ToString().PadLeft(2' '0')'                          ticksAfterWholeSecond.ToString().PadLeft(7''0').TrimEnd('0')'                          quoting);              }              else if (data is DateTime)              {                  DateTime d = (DateTime)data;                    if (d.ToString("fffffff") == "0000000")                  {                      return String.Format("{3}{0}:{1}:{2}{3}"'                          d.Hour.ToString().PadLeft(2' '0')'                          d.Minute.ToString().PadLeft(2' '0')'                          d.Second.ToString().PadLeft(2' '0')'                          quoting);                  }                  return String.Format("{4}{0}:{1}:{2}.{3}{4}"'                          d.Hour.ToString().PadLeft(2' '0')'                          d.Minute.ToString().PadLeft(2' '0')'                          d.Second.ToString().PadLeft(2' '0')'                          d.ToString("fffffff").TrimEnd('0')'                          quoting);              }
Magic Number,TSqlFlex.Core,FieldScripting,C:\repos\nycdotnet_TSqlFlex\Code\TSqlFlex.Core\FieldScripting.cs,formatTime,The following statement contains a magic number: if (data is TimeSpan)              {                  TimeSpan t = (TimeSpan)data;                  long ticksAfterWholeSecond = t.Ticks - ((long)Math.Floor(t.TotalSeconds) * TimeSpan.TicksPerSecond);                  if (ticksAfterWholeSecond == 0)                  {                      return String.Format("{3}{0}:{1}:{2}{3}"'                          t.Hours.ToString().PadLeft(2' '0')'                          t.Minutes.ToString().PadLeft(2' '0')'                          t.Seconds.ToString().PadLeft(2' '0')'                          quoting);                  }                  return String.Format("{4}{0}:{1}:{2}.{3}{4}"'                          t.Hours.ToString().PadLeft(2' '0')'                          t.Minutes.ToString().PadLeft(2' '0')'                          t.Seconds.ToString().PadLeft(2' '0')'                          ticksAfterWholeSecond.ToString().PadLeft(7''0').TrimEnd('0')'                          quoting);              }              else if (data is DateTime)              {                  DateTime d = (DateTime)data;                    if (d.ToString("fffffff") == "0000000")                  {                      return String.Format("{3}{0}:{1}:{2}{3}"'                          d.Hour.ToString().PadLeft(2' '0')'                          d.Minute.ToString().PadLeft(2' '0')'                          d.Second.ToString().PadLeft(2' '0')'                          quoting);                  }                  return String.Format("{4}{0}:{1}:{2}.{3}{4}"'                          d.Hour.ToString().PadLeft(2' '0')'                          d.Minute.ToString().PadLeft(2' '0')'                          d.Second.ToString().PadLeft(2' '0')'                          d.ToString("fffffff").TrimEnd('0')'                          quoting);              }
Magic Number,TSqlFlex.Core,FieldScripting,C:\repos\nycdotnet_TSqlFlex\Code\TSqlFlex.Core\FieldScripting.cs,formatTime,The following statement contains a magic number: if (data is TimeSpan)              {                  TimeSpan t = (TimeSpan)data;                  long ticksAfterWholeSecond = t.Ticks - ((long)Math.Floor(t.TotalSeconds) * TimeSpan.TicksPerSecond);                  if (ticksAfterWholeSecond == 0)                  {                      return String.Format("{3}{0}:{1}:{2}{3}"'                          t.Hours.ToString().PadLeft(2' '0')'                          t.Minutes.ToString().PadLeft(2' '0')'                          t.Seconds.ToString().PadLeft(2' '0')'                          quoting);                  }                  return String.Format("{4}{0}:{1}:{2}.{3}{4}"'                          t.Hours.ToString().PadLeft(2' '0')'                          t.Minutes.ToString().PadLeft(2' '0')'                          t.Seconds.ToString().PadLeft(2' '0')'                          ticksAfterWholeSecond.ToString().PadLeft(7''0').TrimEnd('0')'                          quoting);              }              else if (data is DateTime)              {                  DateTime d = (DateTime)data;                    if (d.ToString("fffffff") == "0000000")                  {                      return String.Format("{3}{0}:{1}:{2}{3}"'                          d.Hour.ToString().PadLeft(2' '0')'                          d.Minute.ToString().PadLeft(2' '0')'                          d.Second.ToString().PadLeft(2' '0')'                          quoting);                  }                  return String.Format("{4}{0}:{1}:{2}.{3}{4}"'                          d.Hour.ToString().PadLeft(2' '0')'                          d.Minute.ToString().PadLeft(2' '0')'                          d.Second.ToString().PadLeft(2' '0')'                          d.ToString("fffffff").TrimEnd('0')'                          quoting);              }
Magic Number,TSqlFlex.Core,FieldScripting,C:\repos\nycdotnet_TSqlFlex\Code\TSqlFlex.Core\FieldScripting.cs,formatTime,The following statement contains a magic number: if (data is TimeSpan)              {                  TimeSpan t = (TimeSpan)data;                  long ticksAfterWholeSecond = t.Ticks - ((long)Math.Floor(t.TotalSeconds) * TimeSpan.TicksPerSecond);                  if (ticksAfterWholeSecond == 0)                  {                      return String.Format("{3}{0}:{1}:{2}{3}"'                          t.Hours.ToString().PadLeft(2' '0')'                          t.Minutes.ToString().PadLeft(2' '0')'                          t.Seconds.ToString().PadLeft(2' '0')'                          quoting);                  }                  return String.Format("{4}{0}:{1}:{2}.{3}{4}"'                          t.Hours.ToString().PadLeft(2' '0')'                          t.Minutes.ToString().PadLeft(2' '0')'                          t.Seconds.ToString().PadLeft(2' '0')'                          ticksAfterWholeSecond.ToString().PadLeft(7''0').TrimEnd('0')'                          quoting);              }              else if (data is DateTime)              {                  DateTime d = (DateTime)data;                    if (d.ToString("fffffff") == "0000000")                  {                      return String.Format("{3}{0}:{1}:{2}{3}"'                          d.Hour.ToString().PadLeft(2' '0')'                          d.Minute.ToString().PadLeft(2' '0')'                          d.Second.ToString().PadLeft(2' '0')'                          quoting);                  }                  return String.Format("{4}{0}:{1}:{2}.{3}{4}"'                          d.Hour.ToString().PadLeft(2' '0')'                          d.Minute.ToString().PadLeft(2' '0')'                          d.Second.ToString().PadLeft(2' '0')'                          d.ToString("fffffff").TrimEnd('0')'                          quoting);              }
Magic Number,TSqlFlex.Core,FieldScripting,C:\repos\nycdotnet_TSqlFlex\Code\TSqlFlex.Core\FieldScripting.cs,formatTime,The following statement contains a magic number: if (data is TimeSpan)              {                  TimeSpan t = (TimeSpan)data;                  long ticksAfterWholeSecond = t.Ticks - ((long)Math.Floor(t.TotalSeconds) * TimeSpan.TicksPerSecond);                  if (ticksAfterWholeSecond == 0)                  {                      return String.Format("{3}{0}:{1}:{2}{3}"'                          t.Hours.ToString().PadLeft(2' '0')'                          t.Minutes.ToString().PadLeft(2' '0')'                          t.Seconds.ToString().PadLeft(2' '0')'                          quoting);                  }                  return String.Format("{4}{0}:{1}:{2}.{3}{4}"'                          t.Hours.ToString().PadLeft(2' '0')'                          t.Minutes.ToString().PadLeft(2' '0')'                          t.Seconds.ToString().PadLeft(2' '0')'                          ticksAfterWholeSecond.ToString().PadLeft(7''0').TrimEnd('0')'                          quoting);              }              else if (data is DateTime)              {                  DateTime d = (DateTime)data;                    if (d.ToString("fffffff") == "0000000")                  {                      return String.Format("{3}{0}:{1}:{2}{3}"'                          d.Hour.ToString().PadLeft(2' '0')'                          d.Minute.ToString().PadLeft(2' '0')'                          d.Second.ToString().PadLeft(2' '0')'                          quoting);                  }                  return String.Format("{4}{0}:{1}:{2}.{3}{4}"'                          d.Hour.ToString().PadLeft(2' '0')'                          d.Minute.ToString().PadLeft(2' '0')'                          d.Second.ToString().PadLeft(2' '0')'                          d.ToString("fffffff").TrimEnd('0')'                          quoting);              }
Magic Number,TSqlFlex.Core,FieldScripting,C:\repos\nycdotnet_TSqlFlex\Code\TSqlFlex.Core\FieldScripting.cs,formatTime,The following statement contains a magic number: if (data is TimeSpan)              {                  TimeSpan t = (TimeSpan)data;                  long ticksAfterWholeSecond = t.Ticks - ((long)Math.Floor(t.TotalSeconds) * TimeSpan.TicksPerSecond);                  if (ticksAfterWholeSecond == 0)                  {                      return String.Format("{3}{0}:{1}:{2}{3}"'                          t.Hours.ToString().PadLeft(2' '0')'                          t.Minutes.ToString().PadLeft(2' '0')'                          t.Seconds.ToString().PadLeft(2' '0')'                          quoting);                  }                  return String.Format("{4}{0}:{1}:{2}.{3}{4}"'                          t.Hours.ToString().PadLeft(2' '0')'                          t.Minutes.ToString().PadLeft(2' '0')'                          t.Seconds.ToString().PadLeft(2' '0')'                          ticksAfterWholeSecond.ToString().PadLeft(7''0').TrimEnd('0')'                          quoting);              }              else if (data is DateTime)              {                  DateTime d = (DateTime)data;                    if (d.ToString("fffffff") == "0000000")                  {                      return String.Format("{3}{0}:{1}:{2}{3}"'                          d.Hour.ToString().PadLeft(2' '0')'                          d.Minute.ToString().PadLeft(2' '0')'                          d.Second.ToString().PadLeft(2' '0')'                          quoting);                  }                  return String.Format("{4}{0}:{1}:{2}.{3}{4}"'                          d.Hour.ToString().PadLeft(2' '0')'                          d.Minute.ToString().PadLeft(2' '0')'                          d.Second.ToString().PadLeft(2' '0')'                          d.ToString("fffffff").TrimEnd('0')'                          quoting);              }
Magic Number,TSqlFlex.Core,FieldScripting,C:\repos\nycdotnet_TSqlFlex\Code\TSqlFlex.Core\FieldScripting.cs,formatTime,The following statement contains a magic number: if (data is TimeSpan)              {                  TimeSpan t = (TimeSpan)data;                  long ticksAfterWholeSecond = t.Ticks - ((long)Math.Floor(t.TotalSeconds) * TimeSpan.TicksPerSecond);                  if (ticksAfterWholeSecond == 0)                  {                      return String.Format("{3}{0}:{1}:{2}{3}"'                          t.Hours.ToString().PadLeft(2' '0')'                          t.Minutes.ToString().PadLeft(2' '0')'                          t.Seconds.ToString().PadLeft(2' '0')'                          quoting);                  }                  return String.Format("{4}{0}:{1}:{2}.{3}{4}"'                          t.Hours.ToString().PadLeft(2' '0')'                          t.Minutes.ToString().PadLeft(2' '0')'                          t.Seconds.ToString().PadLeft(2' '0')'                          ticksAfterWholeSecond.ToString().PadLeft(7''0').TrimEnd('0')'                          quoting);              }              else if (data is DateTime)              {                  DateTime d = (DateTime)data;                    if (d.ToString("fffffff") == "0000000")                  {                      return String.Format("{3}{0}:{1}:{2}{3}"'                          d.Hour.ToString().PadLeft(2' '0')'                          d.Minute.ToString().PadLeft(2' '0')'                          d.Second.ToString().PadLeft(2' '0')'                          quoting);                  }                  return String.Format("{4}{0}:{1}:{2}.{3}{4}"'                          d.Hour.ToString().PadLeft(2' '0')'                          d.Minute.ToString().PadLeft(2' '0')'                          d.Second.ToString().PadLeft(2' '0')'                          d.ToString("fffffff").TrimEnd('0')'                          quoting);              }
Magic Number,TSqlFlex.Core,FieldScripting,C:\repos\nycdotnet_TSqlFlex\Code\TSqlFlex.Core\FieldScripting.cs,formatTimestamp,The following statement contains a magic number: const int SIZE_OF_TIMESTAMP_IN_BYTES = 8;
Magic Number,TSqlFlex.Core,FieldScripting,C:\repos\nycdotnet_TSqlFlex\Code\TSqlFlex.Core\FieldScripting.cs,formatBinary,The following statement contains a magic number: int charCountToShowAsHex = fieldLength * 2;
Magic Number,TSqlFlex.Core,FlexResultSet,C:\repos\nycdotnet_TSqlFlex\Code\TSqlFlex.Core\FlexResultSet.cs,AnalyzeResultWithRollback,The following statement contains a magic number: try              {                  srp.command = new SqlCommand(srp.sqlToRun' openConnection' transaction);                  var cmd = srp.command;                  cmd.CommandTimeout = config.CommandTimeoutInSeconds;                    //todo: this is a bad way of doing this.  Need to abstract further.                  bw.ReportProgress(5' "Running query...");                    reader = executeSQL(resultSet' cmd' reader);                  int progress = 50;                  bw.ReportProgress(progress' "Processing results...");                  do                  {                      FlexResult result = new FlexResult();                      if (reader != null)                      {                          try                          {                              result.recordsAffected = reader.RecordsAffected;                              processSchemaInfo(reader' result);                              if (progress < 90)                              {                                  progress += 5;                              }                              bw.ReportProgress(progress' "Processing results...");                              processData(reader' result);                                if (progress < 90)                              {                                  progress += 5;                              }                              bw.ReportProgress(progress' "Processing results...");                          }                          catch (Exception ex)                          {                              resultSet.exceptions.Add(new SqlResultProcessingException(ex));                          }                      }                      foreach (Exception ex in result.exceptions)                      {                          resultSet.exceptions.Add(ex);                      }                      resultSet.results.Add(result);                    } while (reader != null && reader.NextResult());                                }              catch (Exception ex)              {                  resultSet.exceptions.Add(new SqlResultProcessingException(ex));              }              finally              {                  cleanupReader(reader);                  rollbackTransaction(transaction);              }
Magic Number,TSqlFlex.Core,FlexResultSet,C:\repos\nycdotnet_TSqlFlex\Code\TSqlFlex.Core\FlexResultSet.cs,AnalyzeResultWithRollback,The following statement contains a magic number: try              {                  srp.command = new SqlCommand(srp.sqlToRun' openConnection' transaction);                  var cmd = srp.command;                  cmd.CommandTimeout = config.CommandTimeoutInSeconds;                    //todo: this is a bad way of doing this.  Need to abstract further.                  bw.ReportProgress(5' "Running query...");                    reader = executeSQL(resultSet' cmd' reader);                  int progress = 50;                  bw.ReportProgress(progress' "Processing results...");                  do                  {                      FlexResult result = new FlexResult();                      if (reader != null)                      {                          try                          {                              result.recordsAffected = reader.RecordsAffected;                              processSchemaInfo(reader' result);                              if (progress < 90)                              {                                  progress += 5;                              }                              bw.ReportProgress(progress' "Processing results...");                              processData(reader' result);                                if (progress < 90)                              {                                  progress += 5;                              }                              bw.ReportProgress(progress' "Processing results...");                          }                          catch (Exception ex)                          {                              resultSet.exceptions.Add(new SqlResultProcessingException(ex));                          }                      }                      foreach (Exception ex in result.exceptions)                      {                          resultSet.exceptions.Add(ex);                      }                      resultSet.results.Add(result);                    } while (reader != null && reader.NextResult());                                }              catch (Exception ex)              {                  resultSet.exceptions.Add(new SqlResultProcessingException(ex));              }              finally              {                  cleanupReader(reader);                  rollbackTransaction(transaction);              }
Magic Number,TSqlFlex.Core,FlexResultSet,C:\repos\nycdotnet_TSqlFlex\Code\TSqlFlex.Core\FlexResultSet.cs,AnalyzeResultWithRollback,The following statement contains a magic number: try              {                  srp.command = new SqlCommand(srp.sqlToRun' openConnection' transaction);                  var cmd = srp.command;                  cmd.CommandTimeout = config.CommandTimeoutInSeconds;                    //todo: this is a bad way of doing this.  Need to abstract further.                  bw.ReportProgress(5' "Running query...");                    reader = executeSQL(resultSet' cmd' reader);                  int progress = 50;                  bw.ReportProgress(progress' "Processing results...");                  do                  {                      FlexResult result = new FlexResult();                      if (reader != null)                      {                          try                          {                              result.recordsAffected = reader.RecordsAffected;                              processSchemaInfo(reader' result);                              if (progress < 90)                              {                                  progress += 5;                              }                              bw.ReportProgress(progress' "Processing results...");                              processData(reader' result);                                if (progress < 90)                              {                                  progress += 5;                              }                              bw.ReportProgress(progress' "Processing results...");                          }                          catch (Exception ex)                          {                              resultSet.exceptions.Add(new SqlResultProcessingException(ex));                          }                      }                      foreach (Exception ex in result.exceptions)                      {                          resultSet.exceptions.Add(ex);                      }                      resultSet.results.Add(result);                    } while (reader != null && reader.NextResult());                                }              catch (Exception ex)              {                  resultSet.exceptions.Add(new SqlResultProcessingException(ex));              }              finally              {                  cleanupReader(reader);                  rollbackTransaction(transaction);              }
Magic Number,TSqlFlex.Core,FlexResultSet,C:\repos\nycdotnet_TSqlFlex\Code\TSqlFlex.Core\FlexResultSet.cs,AnalyzeResultWithRollback,The following statement contains a magic number: try              {                  srp.command = new SqlCommand(srp.sqlToRun' openConnection' transaction);                  var cmd = srp.command;                  cmd.CommandTimeout = config.CommandTimeoutInSeconds;                    //todo: this is a bad way of doing this.  Need to abstract further.                  bw.ReportProgress(5' "Running query...");                    reader = executeSQL(resultSet' cmd' reader);                  int progress = 50;                  bw.ReportProgress(progress' "Processing results...");                  do                  {                      FlexResult result = new FlexResult();                      if (reader != null)                      {                          try                          {                              result.recordsAffected = reader.RecordsAffected;                              processSchemaInfo(reader' result);                              if (progress < 90)                              {                                  progress += 5;                              }                              bw.ReportProgress(progress' "Processing results...");                              processData(reader' result);                                if (progress < 90)                              {                                  progress += 5;                              }                              bw.ReportProgress(progress' "Processing results...");                          }                          catch (Exception ex)                          {                              resultSet.exceptions.Add(new SqlResultProcessingException(ex));                          }                      }                      foreach (Exception ex in result.exceptions)                      {                          resultSet.exceptions.Add(ex);                      }                      resultSet.results.Add(result);                    } while (reader != null && reader.NextResult());                                }              catch (Exception ex)              {                  resultSet.exceptions.Add(new SqlResultProcessingException(ex));              }              finally              {                  cleanupReader(reader);                  rollbackTransaction(transaction);              }
Magic Number,TSqlFlex.Core,FlexResultSet,C:\repos\nycdotnet_TSqlFlex\Code\TSqlFlex.Core\FlexResultSet.cs,AnalyzeResultWithRollback,The following statement contains a magic number: try              {                  srp.command = new SqlCommand(srp.sqlToRun' openConnection' transaction);                  var cmd = srp.command;                  cmd.CommandTimeout = config.CommandTimeoutInSeconds;                    //todo: this is a bad way of doing this.  Need to abstract further.                  bw.ReportProgress(5' "Running query...");                    reader = executeSQL(resultSet' cmd' reader);                  int progress = 50;                  bw.ReportProgress(progress' "Processing results...");                  do                  {                      FlexResult result = new FlexResult();                      if (reader != null)                      {                          try                          {                              result.recordsAffected = reader.RecordsAffected;                              processSchemaInfo(reader' result);                              if (progress < 90)                              {                                  progress += 5;                              }                              bw.ReportProgress(progress' "Processing results...");                              processData(reader' result);                                if (progress < 90)                              {                                  progress += 5;                              }                              bw.ReportProgress(progress' "Processing results...");                          }                          catch (Exception ex)                          {                              resultSet.exceptions.Add(new SqlResultProcessingException(ex));                          }                      }                      foreach (Exception ex in result.exceptions)                      {                          resultSet.exceptions.Add(ex);                      }                      resultSet.results.Add(result);                    } while (reader != null && reader.NextResult());                                }              catch (Exception ex)              {                  resultSet.exceptions.Add(new SqlResultProcessingException(ex));              }              finally              {                  cleanupReader(reader);                  rollbackTransaction(transaction);              }
Magic Number,TSqlFlex.Core,FlexResultSet,C:\repos\nycdotnet_TSqlFlex\Code\TSqlFlex.Core\FlexResultSet.cs,AnalyzeResultWithRollback,The following statement contains a magic number: try              {                  srp.command = new SqlCommand(srp.sqlToRun' openConnection' transaction);                  var cmd = srp.command;                  cmd.CommandTimeout = config.CommandTimeoutInSeconds;                    //todo: this is a bad way of doing this.  Need to abstract further.                  bw.ReportProgress(5' "Running query...");                    reader = executeSQL(resultSet' cmd' reader);                  int progress = 50;                  bw.ReportProgress(progress' "Processing results...");                  do                  {                      FlexResult result = new FlexResult();                      if (reader != null)                      {                          try                          {                              result.recordsAffected = reader.RecordsAffected;                              processSchemaInfo(reader' result);                              if (progress < 90)                              {                                  progress += 5;                              }                              bw.ReportProgress(progress' "Processing results...");                              processData(reader' result);                                if (progress < 90)                              {                                  progress += 5;                              }                              bw.ReportProgress(progress' "Processing results...");                          }                          catch (Exception ex)                          {                              resultSet.exceptions.Add(new SqlResultProcessingException(ex));                          }                      }                      foreach (Exception ex in result.exceptions)                      {                          resultSet.exceptions.Add(ex);                      }                      resultSet.results.Add(result);                    } while (reader != null && reader.NextResult());                                }              catch (Exception ex)              {                  resultSet.exceptions.Add(new SqlResultProcessingException(ex));              }              finally              {                  cleanupReader(reader);                  rollbackTransaction(transaction);              }
Magic Number,TSqlFlex.Core,QueryWorker,C:\repos\nycdotnet_TSqlFlex\Code\TSqlFlex.Core\QueryWorker.cs,DoSqlQueryWork,The following statement contains a magic number: try              {                  using (conn = new SqlConnection(srp.connStringBuilder.ConnectionString))                  {                      if (bw.CancellationPending)                      {                          e.Cancel = true;                          return;                      }                        currentTask = "while opening SQL connection";                      conn.Open();                                            bw.ReportProgress(2' "Running query...");                        if (bw.CancellationPending)                      {                          e.Cancel = true;                          return;                      }                        currentTask = "while running the query or analyzing the data";                      resultSet = FlexResultSet.AnalyzeResultWithRollback(conn' srp' config' bw);                                            currentTask = "while closing the database connection";                      conn.Close();                    }              }              catch (Exception ex)              {                  renderExceptionToSqlRunParameters(currentTask' srp' ex);              }              finally              {                  if (conn != null && conn.State != System.Data.ConnectionState.Closed)                  {                      conn.Close();                  }              }
Magic Number,TSqlFlex.Core,QueryWorker,C:\repos\nycdotnet_TSqlFlex\Code\TSqlFlex.Core\QueryWorker.cs,DoSqlQueryWork,The following statement contains a magic number: try              {                  bw.ReportProgress(90' "Scripting results...");                  renderAndCountExceptions(resultSet' srp);              }              catch (Exception ex)              {                  renderExceptionToSqlRunParameters("scripting results"' srp' ex);                  e.Result = srp;                  return;              }
Magic Number,TSqlFlex.Core,QueryWorker,C:\repos\nycdotnet_TSqlFlex\Code\TSqlFlex.Core\QueryWorker.cs,DoSqlQueryWork,The following statement contains a magic number: bw.ReportProgress(92' "Scripting results...");
Magic Number,TSqlFlex.Core,SQLColumnList,C:\repos\nycdotnet_TSqlFlex\Code\TSqlFlex.Core\SQLColumn.cs,CreateFromSchemaTable,The following statement contains a magic number: foreach (DataRow fieldDefinition in table.Rows)              {                  result.Add(new SQLColumn()                  {                      ColumnName = fieldDefinition[(int)FieldScripting.ADONetFieldInfo.Name].ToString()'                      BaseTableName = fieldDefinition[11].ToString()'                      ColumnSize = (int)fieldDefinition[(int)FieldScripting.ADONetFieldInfo.ColumnSize]'                      NumericPrecision = (short)fieldDefinition[(int)FieldScripting.ADONetFieldInfo.NumericPrecision]'                      NumericScale = (short)fieldDefinition[(int)FieldScripting.ADONetFieldInfo.NumericScale]'                      DataType = fieldDefinition[(int)FieldScripting.ADONetFieldInfo.DataType].ToString()'                      AllowNulls = (bool)fieldDefinition[(int)FieldScripting.ADONetFieldInfo.AllowsNulls]'                      IsHidden = fieldDefinition[(int)FieldScripting.ADONetFieldInfo.IsHidden] == DBNull.Value ? false : (bool)fieldDefinition[(int)FieldScripting.ADONetFieldInfo.IsHidden]                   });              }
Magic Number,TSqlFlex.Core,SqlRunParameters,C:\repos\nycdotnet_TSqlFlex\Code\TSqlFlex.Core\SqlRunParameters.cs,SqlRunParameters,The following statement contains a magic number: this.exceptionsText.EnsureCapacity(8000);
Magic Number,TSqlFlex.Core,SqlRunParameters,C:\repos\nycdotnet_TSqlFlex\Code\TSqlFlex.Core\SqlRunParameters.cs,CopyStreamToEnd,The following statement contains a magic number: byte[] buffer = new byte[32768];
