Implementation smell,Namespace,Class,File,Method,Description
Long Method,Engineer,Tools,F:\newReposMay17\CYBUTEK_Engineer\Engineer\Tools.cs,FormatSI,The method has 102 lines of code.
Long Method,Engineer,FlightEngineer,F:\newReposMay17\CYBUTEK_Engineer\Engineer\FlightEngineer.cs,DrawSurface,The method has 246 lines of code.
Long Method,Engineer,FlightEngineer,F:\newReposMay17\CYBUTEK_Engineer\Engineer\FlightEngineer.cs,InitSettings,The method has 106 lines of code.
Long Method,Engineer,Rendezvous,F:\newReposMay17\CYBUTEK_Engineer\Engineer\Rendezvous.cs,DrawBodyDetails,The method has 121 lines of code.
Long Method,Engineer,Rendezvous,F:\newReposMay17\CYBUTEK_Engineer\Engineer\Rendezvous.cs,DrawVesselDetails,The method has 128 lines of code.
Long Method,Engineer.VesselSimulator,EngineSim,F:\newReposMay17\CYBUTEK_Engineer\Engineer\VesselSimulator\EngineSim.cs,SetResourceDrains,The method has 103 lines of code.
Long Method,Engineer.VesselSimulator,PartSim,F:\newReposMay17\CYBUTEK_Engineer\Engineer\VesselSimulator\PartSim.cs,GetSourceSet,The method has 121 lines of code.
Long Method,Engineer.VesselSimulator,Simulation,F:\newReposMay17\CYBUTEK_Engineer\Engineer\VesselSimulator\Simulation.cs,RunSimulation,The method has 208 lines of code.
Complex Method,Engineer,BuildEngineer,F:\newReposMay17\CYBUTEK_Engineer\Engineer\BuildEngineer.cs,DrawGUI,Cyclomatic complexity of the method is 8
Complex Method,Engineer,BuildEngineer,F:\newReposMay17\CYBUTEK_Engineer\Engineer\BuildEngineer.cs,Window,Cyclomatic complexity of the method is 12
Complex Method,Engineer,StockToolbar,F:\newReposMay17\CYBUTEK_Engineer\Engineer\StockToolbar.cs,LateUpdate,Cyclomatic complexity of the method is 13
Complex Method,Engineer,Tools,F:\newReposMay17\CYBUTEK_Engineer\Engineer\Tools.cs,FormatSI,Cyclomatic complexity of the method is 23
Complex Method,Engineer,Tools,F:\newReposMay17\CYBUTEK_Engineer\Engineer\Tools.cs,ToDistance,Cyclomatic complexity of the method is 15
Complex Method,Engineer,Tools,F:\newReposMay17\CYBUTEK_Engineer\Engineer\Tools.cs,FormatTime,Cyclomatic complexity of the method is 10
Complex Method,Engineer,Version,F:\newReposMay17\CYBUTEK_Engineer\Engineer\Version.cs,CompareVersions,Cyclomatic complexity of the method is 11
Complex Method,Engineer,FlightEngineer,F:\newReposMay17\CYBUTEK_Engineer\Engineer\FlightEngineer.cs,Window,Cyclomatic complexity of the method is 9
Complex Method,Engineer,FlightEngineer,F:\newReposMay17\CYBUTEK_Engineer\Engineer\FlightEngineer.cs,DrawOrbital,Cyclomatic complexity of the method is 33
Complex Method,Engineer,FlightEngineer,F:\newReposMay17\CYBUTEK_Engineer\Engineer\FlightEngineer.cs,DrawSurface,Cyclomatic complexity of the method is 63
Complex Method,Engineer,FlightEngineer,F:\newReposMay17\CYBUTEK_Engineer\Engineer\FlightEngineer.cs,DrawVessel,Cyclomatic complexity of the method is 31
Complex Method,Engineer,Rendezvous,F:\newReposMay17\CYBUTEK_Engineer\Engineer\Rendezvous.cs,DrawCelestialBodies,Cyclomatic complexity of the method is 8
Complex Method,Engineer,Rendezvous,F:\newReposMay17\CYBUTEK_Engineer\Engineer\Rendezvous.cs,DrawBodyDetails,Cyclomatic complexity of the method is 35
Complex Method,Engineer,Rendezvous,F:\newReposMay17\CYBUTEK_Engineer\Engineer\Rendezvous.cs,DrawVesselDetails,Cyclomatic complexity of the method is 45
Complex Method,Engineer,Settings,F:\newReposMay17\CYBUTEK_Engineer\Engineer\Settings.cs,Window,Cyclomatic complexity of the method is 9
Complex Method,Engineer.VesselSimulator,EngineSim,F:\newReposMay17\CYBUTEK_Engineer\Engineer\VesselSimulator\EngineSim.cs,EngineSim,Cyclomatic complexity of the method is 23
Complex Method,Engineer.VesselSimulator,EngineSim,F:\newReposMay17\CYBUTEK_Engineer\Engineer\VesselSimulator\EngineSim.cs,SetResourceDrains,Cyclomatic complexity of the method is 41
Complex Method,Engineer.VesselSimulator,PartSim,F:\newReposMay17\CYBUTEK_Engineer\Engineer\VesselSimulator\PartSim.cs,PartSim,Cyclomatic complexity of the method is 10
Complex Method,Engineer.VesselSimulator,PartSim,F:\newReposMay17\CYBUTEK_Engineer\Engineer\VesselSimulator\PartSim.cs,CreateEngineSims,Cyclomatic complexity of the method is 14
Complex Method,Engineer.VesselSimulator,PartSim,F:\newReposMay17\CYBUTEK_Engineer\Engineer\VesselSimulator\PartSim.cs,SetupAttachNodes,Cyclomatic complexity of the method is 13
Complex Method,Engineer.VesselSimulator,PartSim,F:\newReposMay17\CYBUTEK_Engineer\Engineer\VesselSimulator\PartSim.cs,GetSourceSet,Cyclomatic complexity of the method is 26
Complex Method,Engineer.VesselSimulator,PartSim,F:\newReposMay17\CYBUTEK_Engineer\Engineer\VesselSimulator\PartSim.cs,DumpPartToBuffer,Cyclomatic complexity of the method is 8
Complex Method,Engineer.VesselSimulator,SimManager,F:\newReposMay17\CYBUTEK_Engineer\Engineer\VesselSimulator\SimManager.cs,RunSimulation,Cyclomatic complexity of the method is 8
Complex Method,Engineer.VesselSimulator,SimManager,F:\newReposMay17\CYBUTEK_Engineer\Engineer\VesselSimulator\SimManager.cs,GetVesselTypeString,Cyclomatic complexity of the method is 11
Complex Method,Engineer.VesselSimulator,Simulation,F:\newReposMay17\CYBUTEK_Engineer\Engineer\VesselSimulator\Simulation.cs,PrepareSimulation,Cyclomatic complexity of the method is 22
Complex Method,Engineer.VesselSimulator,Simulation,F:\newReposMay17\CYBUTEK_Engineer\Engineer\VesselSimulator\Simulation.cs,RunSimulation,Cyclomatic complexity of the method is 40
Complex Method,Engineer.VesselSimulator,Simulation,F:\newReposMay17\CYBUTEK_Engineer\Engineer\VesselSimulator\Simulation.cs,BuildDontStageLists,Cyclomatic complexity of the method is 11
Complex Method,Engineer.VesselSimulator,Simulation,F:\newReposMay17\CYBUTEK_Engineer\Engineer\VesselSimulator\Simulation.cs,UpdateResourceDrains,Cyclomatic complexity of the method is 10
Complex Method,Engineer.VesselSimulator,Simulation,F:\newReposMay17\CYBUTEK_Engineer\Engineer\VesselSimulator\Simulation.cs,AllowedToStage,Cyclomatic complexity of the method is 14
Complex Method,Engineer.VesselSimulator,Simulation,F:\newReposMay17\CYBUTEK_Engineer\Engineer\VesselSimulator\Simulation.cs,ActivateStage,Cyclomatic complexity of the method is 11
Long Parameter List,Engineer,EngineerTools,F:\newReposMay17\CYBUTEK_Engineer\Engineer\EngineerTools.cs,SimpleFormatter,The method has 5 parameters.
Long Parameter List,Engineer.VesselSimulator,EngineSim,F:\newReposMay17\CYBUTEK_Engineer\Engineer\VesselSimulator\EngineSim.cs,EngineSim,The method has 15 parameters.
Long Parameter List,Engineer.VesselSimulator,PartSim,F:\newReposMay17\CYBUTEK_Engineer\Engineer\VesselSimulator\PartSim.cs,CreateEngineSims,The method has 5 parameters.
Long Parameter List,Engineer.VesselSimulator,PartSim,F:\newReposMay17\CYBUTEK_Engineer\Engineer\VesselSimulator\PartSim.cs,GetSourceSet,The method has 5 parameters.
Long Parameter List,Engineer.VesselSimulator,Simulation,F:\newReposMay17\CYBUTEK_Engineer\Engineer\VesselSimulator\Simulation.cs,PrepareSimulation,The method has 6 parameters.
Long Statement,Engineer,BuildEngineer,F:\newReposMay17\CYBUTEK_Engineer\Engineer\BuildEngineer.cs,OnStart,The length of the statement  "				windowTitle = "Kerbal Engineer Redux - Build Engineer (inc. Flight Engineer) Version " + Version.VERSION + Version.SUFFIX; " is 122.
Long Statement,Engineer,BuildEngineer,F:\newReposMay17\CYBUTEK_Engineer\Engineer\BuildEngineer.cs,Window,The length of the statement  "		settings.Set ("_SAVEONCHANGE_SHOW_MAIN"' GUILayout.Toggle (settings.Get ("_SAVEONCHANGE_SHOW_MAIN"' true)' "Main Display"' buttonStyle)); " is 137.
Long Statement,Engineer,BuildEngineer,F:\newReposMay17\CYBUTEK_Engineer\Engineer\BuildEngineer.cs,Window,The length of the statement  "		settings.Set ("_SAVEONCHANGE_SHOW_REFERENCES"' GUILayout.Toggle (settings.Get ("_SAVEONCHANGE_SHOW_REFERENCES"' true)' "Reference Bodies"' buttonStyle)); " is 153.
Long Statement,Engineer,BuildEngineer,F:\newReposMay17\CYBUTEK_Engineer\Engineer\BuildEngineer.cs,Window,The length of the statement  "		settings.Set ("_SAVEONCHANGE_USE_ATMOSPHERE"' GUILayout.Toggle (settings.Get ("_SAVEONCHANGE_USE_ATMOSPHERE"' false)' "Atmospheric Stats"' buttonStyle)); " is 153.
Long Statement,Engineer,BuildEngineer,F:\newReposMay17\CYBUTEK_Engineer\Engineer\BuildEngineer.cs,Window,The length of the statement  "		settings.Set ("_SAVEONCHANGE_SHOW_ALL_STAGES"' GUILayout.Toggle (settings.Get ("_SAVEONCHANGE_SHOW_ALL_STAGES"' false)' "Show All Stages"' buttonStyle)); " is 153.
Long Statement,Engineer,BuildEngineer,F:\newReposMay17\CYBUTEK_Engineer\Engineer\BuildEngineer.cs,Window,The length of the statement  "	settings.Set ("_SAVEONCHANGE_COMPACT"' GUILayout.Toggle (settings.Get ("_SAVEONCHANGE_COMPACT"' false)' "Compact"' buttonStyle)); " is 129.
Long Statement,Engineer,BuildEngineer,F:\newReposMay17\CYBUTEK_Engineer\Engineer\BuildEngineer.cs,Window,The length of the statement  "			GUILayout.Label ("UPDATE AVAILABLE:  Your version is now obsolete' please update to " + version.Remote + " for the best gameplay experience!"); " is 143.
Long Statement,Engineer,BuildEngineer,F:\newReposMay17\CYBUTEK_Engineer\Engineer\BuildEngineer.cs,Window,The length of the statement  "		if ((Event.current.type == EventType.repaint) && GUILayoutUtility.GetLastRect ().Contains (Event.current.mousePosition) && Input.GetMouseButtonDown (0)) { " is 154.
Long Statement,Engineer,BuildEngineer,F:\newReposMay17\CYBUTEK_Engineer\Engineer\BuildEngineer.cs,DrawTWR,The length of the statement  "		GUILayout.Label (EngineerTools.SimpleFormatter (stages [i].thrustToWeight' ""' 2) + " (" + EngineerTools.SimpleFormatter (stages [i].maxThrustToWeight' ""' 2) + ")"' dataStyle); " is 177.
Long Statement,Engineer,StockToolbar,F:\newReposMay17\CYBUTEK_Engineer\Engineer\StockToolbar.cs,Awake,The length of the statement  "		texture.LoadImage (File.ReadAllBytes (Path.Combine (Path.GetDirectoryName (Assembly.GetExecutingAssembly ().Location)' "StockToolbar.png"))); " is 141.
Long Statement,Engineer,StockToolbar,F:\newReposMay17\CYBUTEK_Engineer\Engineer\StockToolbar.cs,CreateButtons,The length of the statement  "	if (this.buildButton == null && (HighLogic.LoadedScene == GameScenes.EDITOR || HighLogic.LoadedScene == GameScenes.SPH)) { " is 122.
Long Statement,Engineer,StockToolbar,F:\newReposMay17\CYBUTEK_Engineer\Engineer\StockToolbar.cs,CreateButtons,The length of the statement  "		this.buildButton = ApplicationLauncher.Instance.AddModApplication (this.BuildOn' this.BuildOff' null' null' null' null' ApplicationLauncher.AppScenes.ALWAYS' texture); " is 167.
Long Statement,Engineer,StockToolbar,F:\newReposMay17\CYBUTEK_Engineer\Engineer\StockToolbar.cs,CreateButtons,The length of the statement  "		this.flightButton = ApplicationLauncher.Instance.AddModApplication (this.FlightOn' this.FlightOff' null' null' null' null' ApplicationLauncher.AppScenes.ALWAYS' texture); " is 170.
Long Statement,Engineer,FlightEngineer,F:\newReposMay17\CYBUTEK_Engineer\Engineer\FlightEngineer.cs,OnLoad,The length of the statement  "			windowPosition = settings.ConvertToRect (settings.Get ("_SAVEONCHANGE_NOCHANGEUPDATE_WINDOW_POSITION"' settings.ConvertToString (windowPosition))); " is 147.
Long Statement,Engineer,FlightEngineer,F:\newReposMay17\CYBUTEK_Engineer\Engineer\FlightEngineer.cs,Update,The length of the statement  "				SimManager.Gravity = vessel.mainBody.gravParameter / Math.Pow (vessel.mainBody.Radius + vessel.mainBody.GetAltitude (vessel.CoM)' 2); " is 133.
Long Statement,Engineer,FlightEngineer,F:\newReposMay17\CYBUTEK_Engineer\Engineer\FlightEngineer.cs,DrawGUI,The length of the statement  "					windowPosition = settings.ConvertToRect (settings.Get ("_SAVEONCHANGE_NOCHANGEUPDATE_WINDOW_POSITION"' settings.ConvertToString (windowPosition))); " is 147.
Long Statement,Engineer,FlightEngineer,F:\newReposMay17\CYBUTEK_Engineer\Engineer\FlightEngineer.cs,DrawGUI,The length of the statement  "					windowPosition = GUILayout.Window (windowID' windowPosition' Window' "Flight Engineer  -  Version " + Version.VERSION + Version.SUFFIX' windowStyle); " is 149.
Long Statement,Engineer,FlightEngineer,F:\newReposMay17\CYBUTEK_Engineer\Engineer\FlightEngineer.cs,Window,The length of the statement  "	settings.Set ("_SAVEONCHANGE_SHOW_ORBITAL"' GUILayout.Toggle (settings.Get ("_SAVEONCHANGE_SHOW_ORBITAL"' false)' "ORB"' buttonStyle)); " is 135.
Long Statement,Engineer,FlightEngineer,F:\newReposMay17\CYBUTEK_Engineer\Engineer\FlightEngineer.cs,Window,The length of the statement  "	settings.Set ("_SAVEONCHANGE_SHOW_SURFACE"' GUILayout.Toggle (settings.Get ("_SAVEONCHANGE_SHOW_SURFACE"' false)' "SUR"' buttonStyle)); " is 135.
Long Statement,Engineer,FlightEngineer,F:\newReposMay17\CYBUTEK_Engineer\Engineer\FlightEngineer.cs,Window,The length of the statement  "	settings.Set ("_SAVEONCHANGE_SHOW_VESSEL"' GUILayout.Toggle (settings.Get ("_SAVEONCHANGE_SHOW_VESSEL"' false)' "VES"' buttonStyle)); " is 133.
Long Statement,Engineer,FlightEngineer,F:\newReposMay17\CYBUTEK_Engineer\Engineer\FlightEngineer.cs,Window,The length of the statement  "	settings.Set ("_SAVEONCHANGE_SHOW_RENDEZVOUS"' GUILayout.Toggle (settings.Get ("_SAVEONCHANGE_SHOW_RENDEZVOUS"' false)' "RDV"' buttonStyle)); " is 141.
Long Statement,Engineer,FlightEngineer,F:\newReposMay17\CYBUTEK_Engineer\Engineer\FlightEngineer.cs,Window,The length of the statement  "	if ((Event.current.type == EventType.repaint) && GUILayoutUtility.GetLastRect ().Contains (Event.current.mousePosition) && Input.GetMouseButtonDown (0)) { " is 154.
Long Statement,Engineer,FlightEngineer,F:\newReposMay17\CYBUTEK_Engineer\Engineer\FlightEngineer.cs,Window,The length of the statement  "		if ((Event.current.type == EventType.repaint) && GUILayoutUtility.GetLastRect ().Contains (Event.current.mousePosition) && Input.GetMouseButtonDown (0)) { " is 154.
Long Statement,Engineer,FlightEngineer,F:\newReposMay17\CYBUTEK_Engineer\Engineer\FlightEngineer.cs,DrawSurface,The length of the statement  "		//experimentally determined; even for very flat trajectories' the errors go into the sub-millimeter area after 5 iterations or so " is 129.
Long Statement,Engineer,FlightEngineer,F:\newReposMay17\CYBUTEK_Engineer\Engineer\FlightEngineer.cs,DrawSurface,The length of the statement  "			Vector3d rad = QuaternionD.AngleAxis (impactlong' Vector3d.down) * QuaternionD.AngleAxis (impactlat' Vector3d.forward) * Vector3d.right; " is 136.
Long Statement,Engineer,FlightEngineer,F:\newReposMay17\CYBUTEK_Engineer\Engineer\FlightEngineer.cs,DrawSurface,The length of the statement  "            if (settings.Get<bool>("Surface: terrainAltitude")) GUILayout.Label(Tools.FormatSI(terrainAltitude' Tools.SIUnitType.Distance)' dataStyle);" is 139.
Long Statement,Engineer,FlightEngineer,F:\newReposMay17\CYBUTEK_Engineer\Engineer\FlightEngineer.cs,DrawSurface,The length of the statement  "            if (settings.Get<bool>("Surface: pqsAltitude")) GUILayout.Label(Tools.FormatSI(pqsAltitude' Tools.SIUnitType.Distance)' dataStyle);" is 131.
Long Statement,Engineer,FlightEngineer,F:\newReposMay17\CYBUTEK_Engineer\Engineer\FlightEngineer.cs,DrawSurface,The length of the statement  "            if (settings.Get<bool>("Surface: maxDiff")) GUILayout.Label(Tools.FormatSI(maxDiff' Tools.SIUnitType.Distance)' dataStyle);" is 123.
Long Statement,Engineer,FlightEngineer,F:\newReposMay17\CYBUTEK_Engineer\Engineer\FlightEngineer.cs,DrawSurface,The length of the statement  "            if (settings.Get<bool>("Surface: heightFromTerrain")) GUILayout.Label(Tools.FormatSI(heightFromTerrain' Tools.SIUnitType.Distance)' dataStyle);" is 143.
Long Statement,Engineer,FlightEngineer,F:\newReposMay17\CYBUTEK_Engineer\Engineer\FlightEngineer.cs,DrawSurface,The length of the statement  "            if (settings.Get<bool>("Surface: heightDiff")) GUILayout.Label(Tools.FormatSI(heightDiff' Tools.SIUnitType.Distance)' dataStyle);" is 129.
Long Statement,Engineer,FlightEngineer,F:\newReposMay17\CYBUTEK_Engineer\Engineer\FlightEngineer.cs,DrawSurface,The length of the statement  "            if (settings.Get<bool>("Surface: heightMaxDiff")) GUILayout.Label(Tools.FormatSI(heightMaxDiff' Tools.SIUnitType.Distance)' dataStyle);" is 135.
Long Statement,Engineer,FlightEngineer,F:\newReposMay17\CYBUTEK_Engineer\Engineer\FlightEngineer.cs,DrawSurface,The length of the statement  "		double terminalVelocity = Math.Sqrt ((2 * totalMass * gravity) / (atmosphere * massDrag * FlightGlobals.DragMultiplier)); " is 121.
Long Statement,Engineer,FlightEngineer,F:\newReposMay17\CYBUTEK_Engineer\Engineer\FlightEngineer.cs,DrawSurface,The length of the statement  "		double dragForce = 0.5 * atmosphere * Math.Pow (FlightGlobals.ship_srfSpeed' 2) * massDrag * FlightGlobals.DragMultiplier; " is 122.
Long Statement,Engineer,FlightEngineer,F:\newReposMay17\CYBUTEK_Engineer\Engineer\FlightEngineer.cs,DrawVessel,The length of the statement  "						GUILayout.Label (Tools.FormatNumber (stages [i].deltaV' "m/s"' 0) + " (" + Tools.FormatTime (stages [i].time) + ")"' dataStyle); " is 128.
Long Statement,Engineer,FlightEngineer,F:\newReposMay17\CYBUTEK_Engineer\Engineer\FlightEngineer.cs,DrawVessel,The length of the statement  "				GUILayout.Label (Tools.FormatNumber (currentStage.deltaV' "m/s"' 0) + " (" + Tools.FormatTime (currentStage.time) + ")"' dataStyle); " is 132.
Long Statement,Engineer,FlightEngineer,F:\newReposMay17\CYBUTEK_Engineer\Engineer\FlightEngineer.cs,DrawVessel,The length of the statement  "			GUILayout.Label (Tools.FormatNumber (currentStage.totalDeltaV' "m/s"' 0) + " (" + Tools.FormatTime (currentStage.totalTime) + ")"' dataStyle); " is 142.
Long Statement,Engineer,FlightEngineer,F:\newReposMay17\CYBUTEK_Engineer\Engineer\FlightEngineer.cs,DrawVessel,The length of the statement  "			GUILayout.Label (Tools.FormatNumber (currentStage.thrust / (currentStage.totalMass * (vessel.mainBody.gravParameter / Math.Pow (vessel.mainBody.Radius' 2)))' 3)' dataStyle); " is 173.
Long Statement,Engineer,Rendezvous,F:\newReposMay17\CYBUTEK_Engineer\Engineer\Rendezvous.cs,DrawTargetTypes,The length of the statement  "		if (!vesselTypes.Contains (vessel.vesselType) && vessel.vesselType != VesselType.Unknown && vessel != fe.vessel && vessel.mainBody == fe.vessel.mainBody) { " is 155.
Long Statement,Engineer,Rendezvous,F:\newReposMay17\CYBUTEK_Engineer\Engineer\Rendezvous.cs,CalcMeanAltitude,The length of the statement  "	return vessel.mainBody.orbit.semiMajorAxis * (1 + vessel.mainBody.orbit.eccentricity * vessel.mainBody.orbit.eccentricity / 2); " is 127.
Long Statement,Engineer,Rendezvous,F:\newReposMay17\CYBUTEK_Engineer\Engineer\Rendezvous.cs,CalcEjectionAngle,The length of the statement  "	double v2 = Math.Sqrt (targetGravity / soiExitAltitude) * (Math.Sqrt ((2 * destinationAltitude) / (soiExitAltitude + destinationAltitude)) - 1); " is 144.
Long Statement,Engineer,Rendezvous,F:\newReposMay17\CYBUTEK_Engineer\Engineer\Rendezvous.cs,CalcEjectionAngle,The length of the statement  "	double v = Math.Sqrt ((r * (originSOI * v2 * v2 - 2 * originGravity) + 2 * originSOI * originGravity) / (r * originSOI)); " is 121.
Long Statement,Engineer,Rendezvous,F:\newReposMay17\CYBUTEK_Engineer\Engineer\Rendezvous.cs,CalcInterceptDistance,The length of the statement  "	return Math.Sqrt (Math.Pow (targetRadius * Math.Cos (interceptAngle * radian) - originRadius' 2) + Math.Pow (targetRadius * Math.Sin (interceptAngle * radian)' 2)); " is 164.
Long Statement,Engineer,Rendezvous,F:\newReposMay17\CYBUTEK_Engineer\Engineer\Rendezvous.cs,AngleToPrograde,The length of the statement  "	if (NormaliseAngle (vesselPosition' Quaternion.AngleAxis (180' Vector3d.forward) * bodyPosition) > NormaliseAngle (vesselPosition' bodyPosition)) { " is 147.
Long Statement,Engineer,Rendezvous,F:\newReposMay17\CYBUTEK_Engineer\Engineer\Rendezvous.cs,AngleToRetrograde,The length of the statement  "	if (NormaliseAngle (vesselPosition' Quaternion.AngleAxis (180' Vector3d.back) * bodyPosition) > NormaliseAngle (vesselPosition' bodyPosition)) { " is 144.
Long Statement,Engineer,Settings,F:\newReposMay17\CYBUTEK_Engineer\Engineer\Settings.cs,ConvertToRect,The length of the statement  "	return new Rect (Convert.ToSingle (args [0])' Convert.ToSingle (args [1])' Convert.ToSingle (args [2])' Convert.ToSingle (args [3])); " is 133.
Long Statement,Engineer.VesselSimulator,EngineSim,F:\newReposMay17\CYBUTEK_Engineer\Engineer\VesselSimulator\EngineSim.cs,SetResourceDrains,The length of the statement  "				log.buf.AppendLine ("Find " + ResourceContainer.GetResourceName (type) + " sources for " + partSim.name + ":" + partSim.partId); " is 128.
Long Statement,Engineer.VesselSimulator,EngineSim,F:\newReposMay17\CYBUTEK_Engineer\Engineer\VesselSimulator\EngineSim.cs,SetResourceDrains,The length of the statement  "			MonoBehaviour.print ("SetResourceDrains(" + partSim.name + ":" + partSim.partId + ") Unexpected flow type for " + ResourceContainer.GetResourceName (type) + ")"); " is 162.
Long Statement,Engineer.VesselSimulator,EngineSim,F:\newReposMay17\CYBUTEK_Engineer\Engineer\VesselSimulator\EngineSim.cs,SetResourceDrains,The length of the statement  "				MonoBehaviour.print ("Adding drain of " + amount + " " + ResourceContainer.GetResourceName (type) + " to " + partSim.name + ":" + partSim.partId); " is 146.
Long Statement,Engineer.VesselSimulator,PartSim,F:\newReposMay17\CYBUTEK_Engineer\Engineer\VesselSimulator\PartSim.cs,CreateEngineSims,The length of the statement  "				EngineSim engineSim = new EngineSim (this' atmosphere' velocity' engine.maxThrust' engine.minThrust' engine.thrustPercentage' engine.requestedThrust' thrustvec' engine.realIsp' engine.atmosphereCurve' engine.useVelocityCurve ? engine.velocityCurve : null' engine.throttleLocked' engine.propellants' engine.isOperational' correctThrust); " is 336.
Long Statement,Engineer.VesselSimulator,PartSim,F:\newReposMay17\CYBUTEK_Engineer\Engineer\VesselSimulator\PartSim.cs,CreateEngineSims,The length of the statement  "				EngineSim engineSim = new EngineSim (this' atmosphere' velocity' engine.maxThrust' engine.minThrust' engine.thrustPercentage' engine.requestedThrust' thrustvec' engine.realIsp' engine.atmosphereCurve' engine.useVelocityCurve ? engine.velocityCurve : null' engine.throttleLocked' engine.propellants' engine.isOperational' correctThrust); " is 336.
Long Statement,Engineer.VesselSimulator,PartSim,F:\newReposMay17\CYBUTEK_Engineer\Engineer\VesselSimulator\PartSim.cs,CreateEngineSims,The length of the statement  "				EngineSim engineSim = new EngineSim (this' atmosphere' velocity' engine.maxThrust' engine.minThrust' engine.thrustPercentage' engine.requestedThrust' thrustvec' engine.realIsp' engine.atmosphereCurve' engine.useVelocityCurve ? engine.velocityCurve : null' engine.throttleLocked' engine.propellants' engine.isOperational' correctThrust); " is 336.
Long Statement,Engineer.VesselSimulator,PartSim,F:\newReposMay17\CYBUTEK_Engineer\Engineer\VesselSimulator\PartSim.cs,CalculateThrustVector,The length of the statement  "			log.buf.AppendFormat ("Transform = ({0:g6}' {1:g6}' {2:g6})   length = {3:g6}\n"' trans.forward.x' trans.forward.y' trans.forward.z' trans.forward.magnitude); " is 158.
Long Statement,Engineer.VesselSimulator,PartSim,F:\newReposMay17\CYBUTEK_Engineer\Engineer\VesselSimulator\PartSim.cs,CalculateThrustVector,The length of the statement  "		log.buf.AppendFormat ("ThrustVec  = ({0:g6}' {1:g6}' {2:g6})   length = {3:g6}\n"' thrustvec.x' thrustvec.y' thrustvec.z' thrustvec.magnitude); " is 143.
Long Statement,Engineer.VesselSimulator,PartSim,F:\newReposMay17\CYBUTEK_Engineer\Engineer\VesselSimulator\PartSim.cs,CalculateThrustVector,The length of the statement  "		log.buf.AppendFormat ("ThrustVecN = ({0:g6}' {1:g6}' {2:g6})   length = {3:g6}\n"' thrustvec.x' thrustvec.y' thrustvec.z' thrustvec.magnitude); " is 143.
Long Statement,Engineer.VesselSimulator,PartSim,F:\newReposMay17\CYBUTEK_Engineer\Engineer\VesselSimulator\PartSim.cs,SetupAttachNodes,The length of the statement  "			log.buf.AppendLine ("AttachNode " + attachNode.id + " = " + (attachNode.attachedPart != null ? attachNode.attachedPart.partInfo.name : "null")); " is 144.
Long Statement,Engineer.VesselSimulator,PartSim,F:\newReposMay17\CYBUTEK_Engineer\Engineer\VesselSimulator\PartSim.cs,IsActiveDecoupler,The length of the statement  "	return thePart.FindModulesImplementing<ModuleDecouple> ().Any (mod => !mod.isDecoupled) || thePart.FindModulesImplementing<ModuleAnchoredDecoupler> ().Any (mod => !mod.isDecoupled); " is 181.
Long Statement,Engineer.VesselSimulator,PartSim,F:\newReposMay17\CYBUTEK_Engineer\Engineer\VesselSimulator\PartSim.cs,GetSourceSet,The length of the statement  "		log.buf.AppendLine (indent + "GetSourceSet(" + ResourceContainer.GetResourceName (type) + ") for " + name + ":" + partId); " is 122.
Long Statement,Engineer.VesselSimulator,PartSim,F:\newReposMay17\CYBUTEK_Engineer\Engineer\VesselSimulator\PartSim.cs,GetSourceSet,The length of the statement  "	// Rule 1: Each part can be only visited once' If it is visited for second time in particular search it returns empty list. " is 123.
Long Statement,Engineer.VesselSimulator,PartSim,F:\newReposMay17\CYBUTEK_Engineer\Engineer\VesselSimulator\PartSim.cs,GetSourceSet,The length of the statement  "	// Rule 2: Part performs scan on start of every fuel pipe ending in it. This scan is done in order in which pipes were installed. " is 129.
Long Statement,Engineer.VesselSimulator,PartSim,F:\newReposMay17\CYBUTEK_Engineer\Engineer\VesselSimulator\PartSim.cs,GetSourceSet,The length of the statement  "	// Then it makes an union of fuel tank sets each pipe scan returned. If the resulting list is not empty' it is returned as result. " is 130.
Long Statement,Engineer.VesselSimulator,PartSim,F:\newReposMay17\CYBUTEK_Engineer\Engineer\VesselSimulator\PartSim.cs,GetSourceSet,The length of the statement  "			//    log.buf.AppendLine(indent + "Fuel target already visited' skipping (" + partSim.name + ":" + partSim.partId + ")"); " is 121.
Long Statement,Engineer.VesselSimulator,PartSim,F:\newReposMay17\CYBUTEK_Engineer\Engineer\VesselSimulator\PartSim.cs,GetSourceSet,The length of the statement  "	// Rule 3: This rule has been removed and merged with rules 4 and 7 to fix issue with fuel tanks with disabled crossfeed " is 120.
Long Statement,Engineer.VesselSimulator,PartSim,F:\newReposMay17\CYBUTEK_Engineer\Engineer\VesselSimulator\PartSim.cs,GetSourceSet,The length of the statement  "	//  Couplers (bicoupler' tricoupler' ...) are an exception' they only scan one attach point on the single attachment side'  " is 122.
Long Statement,Engineer.VesselSimulator,PartSim,F:\newReposMay17\CYBUTEK_Engineer\Engineer\VesselSimulator\PartSim.cs,GetSourceSet,The length of the statement  "	//  The order in which mount points of a part are scanned appears to be fixed and defined by the part specification file. [Experiment] " is 134.
Long Statement,Engineer.VesselSimulator,PartSim,F:\newReposMay17\CYBUTEK_Engineer\Engineer\VesselSimulator\PartSim.cs,GetSourceSet,The length of the statement  "							//    log.buf.AppendLine(indent + "Attached part already visited' skipping (" + attachSim.attachedPartSim.name + ":" + attachSim.attachedPartSim.partId + ")"); " is 159.
Long Statement,Engineer.VesselSimulator,PartSim,F:\newReposMay17\CYBUTEK_Engineer\Engineer\VesselSimulator\PartSim.cs,GetSourceSet,The length of the statement  "							//    log.buf.AppendLine(indent + "Adding attached part as source (" + attachSim.attachedPartSim.name + ":" + attachSim.attachedPartSim.partId + ")"); " is 150.
Long Statement,Engineer.VesselSimulator,PartSim,F:\newReposMay17\CYBUTEK_Engineer\Engineer\VesselSimulator\PartSim.cs,GetSourceSet,The length of the statement  "						//    log.buf.AppendLine(indent + "AttachNode is noCrossFeedKey' skipping (" + attachSim.attachedPartSim.name + ":" + attachSim.attachedPartSim.partId + ")"); " is 158.
Long Statement,Engineer.VesselSimulator,PartSim,F:\newReposMay17\CYBUTEK_Engineer\Engineer\VesselSimulator\PartSim.cs,GetSourceSet,The length of the statement  "					//    log.buf.AppendLine(indent + "AttachNode is not NodeType.Stack' skipping (" + attachSim.attachedPartSim.name + ":" + attachSim.attachedPartSim.partId + ")"); " is 162.
Long Statement,Engineer.VesselSimulator,PartSim,F:\newReposMay17\CYBUTEK_Engineer\Engineer\VesselSimulator\PartSim.cs,GetSourceSet,The length of the statement  "	// Rule 5: If the part is fuel container for searched type of fuel (i.e. it has capability to contain that type of fuel and the fuel  " is 132.
Long Statement,Engineer.VesselSimulator,PartSim,F:\newReposMay17\CYBUTEK_Engineer\Engineer\VesselSimulator\PartSim.cs,GetSourceSet,The length of the statement  "	// Rule 6: If the part is fuel container for searched type of fuel (i.e. it has capability to contain that type of fuel and the fuel  " is 132.
Long Statement,Engineer.VesselSimulator,PartSim,F:\newReposMay17\CYBUTEK_Engineer\Engineer\VesselSimulator\PartSim.cs,GetSourceSet,The length of the statement  "	// Rule 7: If the part is radially attached to another part and it is child of that part in the ship's tree structure' it scans its  " is 131.
Long Statement,Engineer.VesselSimulator,PartSim,F:\newReposMay17\CYBUTEK_Engineer\Engineer\VesselSimulator\PartSim.cs,TimeToDrainResource,The length of the statement  "			//MonoBehaviour.print("type = " + ResourceContainer.GetResourceName(type) + "  amount = " + resources[type] + "  rate = " + resourceDrains[type] + "  time = " + time); " is 167.
Long Statement,Engineer.VesselSimulator,SimManager,F:\newReposMay17\CYBUTEK_Engineer\Engineer\VesselSimulator\SimManager.cs,TryStartSimulation,The length of the statement  "	if (bRequested && !bRunning && (HighLogic.LoadedSceneIsEditor || FlightGlobals.ActiveVessel != null) && timer.ElapsedMilliseconds > delayBetweenSims) { " is 151.
Long Statement,Engineer.VesselSimulator,Simulation,F:\newReposMay17\CYBUTEK_Engineer\Engineer\VesselSimulator\Simulation.cs,RunSimulation,The length of the statement  "				vecStageDeltaV += vecThrust * (float)((currentisp * STD_GRAVITY * Math.Log (stepStartMass / stepEndMass)) / simpleTotalThrust); " is 127.
Long Statement,Engineer.VesselSimulator,Simulation,F:\newReposMay17\CYBUTEK_Engineer\Engineer\VesselSimulator\Simulation.cs,BuildDontStageLists,The length of the statement  "				log.buf.AppendLine (partSim.name + ":" + partSim.partId + " is engine or tank' decoupled = " + partSim.decoupledInStage); " is 121.
Long Statement,Engineer.VesselSimulator,Simulation,F:\newReposMay17\CYBUTEK_Engineer\Engineer\VesselSimulator\Simulation.cs,Dump,The length of the statement  "			buffer.AppendFormat ("vesselName = '{0}'  vesselType = {1}\n"' vesselName' SimManager.GetVesselTypeString (vesselType)); " is 120.
Complex Conditional,Engineer,Rendezvous,F:\newReposMay17\CYBUTEK_Engineer\Engineer\Rendezvous.cs,DrawTargetTypes,The conditional expression  "!vesselTypes.Contains (vessel.vesselType) && vessel.vesselType != VesselType.Unknown && vessel != fe.vessel && vessel.mainBody == fe.vessel.mainBody"  is complex.
Complex Conditional,Engineer.VesselSimulator,SimManager,F:\newReposMay17\CYBUTEK_Engineer\Engineer\VesselSimulator\SimManager.cs,TryStartSimulation,The conditional expression  "bRequested && !bRunning && (HighLogic.LoadedSceneIsEditor || FlightGlobals.ActiveVessel != null) && timer.ElapsedMilliseconds > delayBetweenSims"  is complex.
Complex Conditional,Engineer.VesselSimulator,Simulation,F:\newReposMay17\CYBUTEK_Engineer\Engineer\VesselSimulator\Simulation.cs,RunSimulation,The conditional expression  "resourceDrainTime > 0d && stepStartMass > stepEndMass && stepStartMass > 0d && stepEndMass > 0d"  is complex.
Empty Catch Block,Engineer,Version,F:\newReposMay17\CYBUTEK_Engineer\Engineer\Version.cs,CompareVersions,The method has an empty catch block.
Magic Number,Engineer,BuildEngineer,F:\newReposMay17\CYBUTEK_Engineer\Engineer\BuildEngineer.cs,Update,The following statement contains a magic number: if (IsPrimary) {  	hasEngineer = true;  	// Update the simulation timing from the tweakable  	SimManager.minSimTime = (long)minBESimTime;  	// If the results are ready then read them and start the simulation again (will be delayed by minSimTime)  	if (SimManager.ResultsReady ()) {  		stages = SimManager.Stages;  		failMessage = SimManager.failMessage;  		SimManager.Gravity = referenceBody.gravity;  		if (settings.Get<bool> ("_SAVEONCHANGE_USE_ATMOSPHERE")) {  			SimManager.Atmosphere = referenceBody.atmosphere * percentASP / 100.0;  		} else {  			SimManager.Atmosphere = 0d;  		}  		SimManager.Velocity = velocity;  		SimManager.vectoredThrust = vectoredThrust;  		SimManager.TryStartSimulation ();  	}  }  
Magic Number,Engineer,BuildEngineer,F:\newReposMay17\CYBUTEK_Engineer\Engineer\BuildEngineer.cs,Update,The following statement contains a magic number: if (SimManager.ResultsReady ()) {  	stages = SimManager.Stages;  	failMessage = SimManager.failMessage;  	SimManager.Gravity = referenceBody.gravity;  	if (settings.Get<bool> ("_SAVEONCHANGE_USE_ATMOSPHERE")) {  		SimManager.Atmosphere = referenceBody.atmosphere * percentASP / 100.0;  	} else {  		SimManager.Atmosphere = 0d;  	}  	SimManager.Velocity = velocity;  	SimManager.vectoredThrust = vectoredThrust;  	SimManager.TryStartSimulation ();  }  
Magic Number,Engineer,BuildEngineer,F:\newReposMay17\CYBUTEK_Engineer\Engineer\BuildEngineer.cs,Update,The following statement contains a magic number: if (settings.Get<bool> ("_SAVEONCHANGE_USE_ATMOSPHERE")) {  	SimManager.Atmosphere = referenceBody.atmosphere * percentASP / 100.0;  } else {  	SimManager.Atmosphere = 0d;  }  
Magic Number,Engineer,BuildEngineer,F:\newReposMay17\CYBUTEK_Engineer\Engineer\BuildEngineer.cs,Update,The following statement contains a magic number: SimManager.Atmosphere = referenceBody.atmosphere * percentASP / 100.0;  
Magic Number,Engineer,BuildEngineer,F:\newReposMay17\CYBUTEK_Engineer\Engineer\BuildEngineer.cs,DrawGUI,The following statement contains a magic number: if (isVisible) {  	CheckEditorLock ();  	if (!settings.IsDrawing) {  		string title = "";  		bool compact = settings.Get<bool> ("_SAVEONCHANGE_COMPACT");  		bool compactChanged = (compact != isCompact);  		if (!compact) {  			title = windowTitle;  			if (compactChanged) {  				windowPosition.x -= (740 - 255);  				windowPosition.width += (740 - 255);  			}  		} else {  			title = windowTitleCompact;  			if (compactChanged) {  				windowPosition.x += (740 - 255);  				windowPosition.width -= (740 - 255);  			}  		}  		isCompact = compact;  		windowPosition = GUILayout.Window (windowID' windowPosition' Window' title' windowStyle);  	} else {  		settings.DrawWindow ();  	}  	CheckWindowMargin ();  }  
Magic Number,Engineer,BuildEngineer,F:\newReposMay17\CYBUTEK_Engineer\Engineer\BuildEngineer.cs,DrawGUI,The following statement contains a magic number: if (isVisible) {  	CheckEditorLock ();  	if (!settings.IsDrawing) {  		string title = "";  		bool compact = settings.Get<bool> ("_SAVEONCHANGE_COMPACT");  		bool compactChanged = (compact != isCompact);  		if (!compact) {  			title = windowTitle;  			if (compactChanged) {  				windowPosition.x -= (740 - 255);  				windowPosition.width += (740 - 255);  			}  		} else {  			title = windowTitleCompact;  			if (compactChanged) {  				windowPosition.x += (740 - 255);  				windowPosition.width -= (740 - 255);  			}  		}  		isCompact = compact;  		windowPosition = GUILayout.Window (windowID' windowPosition' Window' title' windowStyle);  	} else {  		settings.DrawWindow ();  	}  	CheckWindowMargin ();  }  
Magic Number,Engineer,BuildEngineer,F:\newReposMay17\CYBUTEK_Engineer\Engineer\BuildEngineer.cs,DrawGUI,The following statement contains a magic number: if (isVisible) {  	CheckEditorLock ();  	if (!settings.IsDrawing) {  		string title = "";  		bool compact = settings.Get<bool> ("_SAVEONCHANGE_COMPACT");  		bool compactChanged = (compact != isCompact);  		if (!compact) {  			title = windowTitle;  			if (compactChanged) {  				windowPosition.x -= (740 - 255);  				windowPosition.width += (740 - 255);  			}  		} else {  			title = windowTitleCompact;  			if (compactChanged) {  				windowPosition.x += (740 - 255);  				windowPosition.width -= (740 - 255);  			}  		}  		isCompact = compact;  		windowPosition = GUILayout.Window (windowID' windowPosition' Window' title' windowStyle);  	} else {  		settings.DrawWindow ();  	}  	CheckWindowMargin ();  }  
Magic Number,Engineer,BuildEngineer,F:\newReposMay17\CYBUTEK_Engineer\Engineer\BuildEngineer.cs,DrawGUI,The following statement contains a magic number: if (isVisible) {  	CheckEditorLock ();  	if (!settings.IsDrawing) {  		string title = "";  		bool compact = settings.Get<bool> ("_SAVEONCHANGE_COMPACT");  		bool compactChanged = (compact != isCompact);  		if (!compact) {  			title = windowTitle;  			if (compactChanged) {  				windowPosition.x -= (740 - 255);  				windowPosition.width += (740 - 255);  			}  		} else {  			title = windowTitleCompact;  			if (compactChanged) {  				windowPosition.x += (740 - 255);  				windowPosition.width -= (740 - 255);  			}  		}  		isCompact = compact;  		windowPosition = GUILayout.Window (windowID' windowPosition' Window' title' windowStyle);  	} else {  		settings.DrawWindow ();  	}  	CheckWindowMargin ();  }  
Magic Number,Engineer,BuildEngineer,F:\newReposMay17\CYBUTEK_Engineer\Engineer\BuildEngineer.cs,DrawGUI,The following statement contains a magic number: if (isVisible) {  	CheckEditorLock ();  	if (!settings.IsDrawing) {  		string title = "";  		bool compact = settings.Get<bool> ("_SAVEONCHANGE_COMPACT");  		bool compactChanged = (compact != isCompact);  		if (!compact) {  			title = windowTitle;  			if (compactChanged) {  				windowPosition.x -= (740 - 255);  				windowPosition.width += (740 - 255);  			}  		} else {  			title = windowTitleCompact;  			if (compactChanged) {  				windowPosition.x += (740 - 255);  				windowPosition.width -= (740 - 255);  			}  		}  		isCompact = compact;  		windowPosition = GUILayout.Window (windowID' windowPosition' Window' title' windowStyle);  	} else {  		settings.DrawWindow ();  	}  	CheckWindowMargin ();  }  
Magic Number,Engineer,BuildEngineer,F:\newReposMay17\CYBUTEK_Engineer\Engineer\BuildEngineer.cs,DrawGUI,The following statement contains a magic number: if (isVisible) {  	CheckEditorLock ();  	if (!settings.IsDrawing) {  		string title = "";  		bool compact = settings.Get<bool> ("_SAVEONCHANGE_COMPACT");  		bool compactChanged = (compact != isCompact);  		if (!compact) {  			title = windowTitle;  			if (compactChanged) {  				windowPosition.x -= (740 - 255);  				windowPosition.width += (740 - 255);  			}  		} else {  			title = windowTitleCompact;  			if (compactChanged) {  				windowPosition.x += (740 - 255);  				windowPosition.width -= (740 - 255);  			}  		}  		isCompact = compact;  		windowPosition = GUILayout.Window (windowID' windowPosition' Window' title' windowStyle);  	} else {  		settings.DrawWindow ();  	}  	CheckWindowMargin ();  }  
Magic Number,Engineer,BuildEngineer,F:\newReposMay17\CYBUTEK_Engineer\Engineer\BuildEngineer.cs,DrawGUI,The following statement contains a magic number: if (isVisible) {  	CheckEditorLock ();  	if (!settings.IsDrawing) {  		string title = "";  		bool compact = settings.Get<bool> ("_SAVEONCHANGE_COMPACT");  		bool compactChanged = (compact != isCompact);  		if (!compact) {  			title = windowTitle;  			if (compactChanged) {  				windowPosition.x -= (740 - 255);  				windowPosition.width += (740 - 255);  			}  		} else {  			title = windowTitleCompact;  			if (compactChanged) {  				windowPosition.x += (740 - 255);  				windowPosition.width -= (740 - 255);  			}  		}  		isCompact = compact;  		windowPosition = GUILayout.Window (windowID' windowPosition' Window' title' windowStyle);  	} else {  		settings.DrawWindow ();  	}  	CheckWindowMargin ();  }  
Magic Number,Engineer,BuildEngineer,F:\newReposMay17\CYBUTEK_Engineer\Engineer\BuildEngineer.cs,DrawGUI,The following statement contains a magic number: if (isVisible) {  	CheckEditorLock ();  	if (!settings.IsDrawing) {  		string title = "";  		bool compact = settings.Get<bool> ("_SAVEONCHANGE_COMPACT");  		bool compactChanged = (compact != isCompact);  		if (!compact) {  			title = windowTitle;  			if (compactChanged) {  				windowPosition.x -= (740 - 255);  				windowPosition.width += (740 - 255);  			}  		} else {  			title = windowTitleCompact;  			if (compactChanged) {  				windowPosition.x += (740 - 255);  				windowPosition.width -= (740 - 255);  			}  		}  		isCompact = compact;  		windowPosition = GUILayout.Window (windowID' windowPosition' Window' title' windowStyle);  	} else {  		settings.DrawWindow ();  	}  	CheckWindowMargin ();  }  
Magic Number,Engineer,BuildEngineer,F:\newReposMay17\CYBUTEK_Engineer\Engineer\BuildEngineer.cs,DrawGUI,The following statement contains a magic number: if (!settings.IsDrawing) {  	string title = "";  	bool compact = settings.Get<bool> ("_SAVEONCHANGE_COMPACT");  	bool compactChanged = (compact != isCompact);  	if (!compact) {  		title = windowTitle;  		if (compactChanged) {  			windowPosition.x -= (740 - 255);  			windowPosition.width += (740 - 255);  		}  	} else {  		title = windowTitleCompact;  		if (compactChanged) {  			windowPosition.x += (740 - 255);  			windowPosition.width -= (740 - 255);  		}  	}  	isCompact = compact;  	windowPosition = GUILayout.Window (windowID' windowPosition' Window' title' windowStyle);  } else {  	settings.DrawWindow ();  }  
Magic Number,Engineer,BuildEngineer,F:\newReposMay17\CYBUTEK_Engineer\Engineer\BuildEngineer.cs,DrawGUI,The following statement contains a magic number: if (!settings.IsDrawing) {  	string title = "";  	bool compact = settings.Get<bool> ("_SAVEONCHANGE_COMPACT");  	bool compactChanged = (compact != isCompact);  	if (!compact) {  		title = windowTitle;  		if (compactChanged) {  			windowPosition.x -= (740 - 255);  			windowPosition.width += (740 - 255);  		}  	} else {  		title = windowTitleCompact;  		if (compactChanged) {  			windowPosition.x += (740 - 255);  			windowPosition.width -= (740 - 255);  		}  	}  	isCompact = compact;  	windowPosition = GUILayout.Window (windowID' windowPosition' Window' title' windowStyle);  } else {  	settings.DrawWindow ();  }  
Magic Number,Engineer,BuildEngineer,F:\newReposMay17\CYBUTEK_Engineer\Engineer\BuildEngineer.cs,DrawGUI,The following statement contains a magic number: if (!settings.IsDrawing) {  	string title = "";  	bool compact = settings.Get<bool> ("_SAVEONCHANGE_COMPACT");  	bool compactChanged = (compact != isCompact);  	if (!compact) {  		title = windowTitle;  		if (compactChanged) {  			windowPosition.x -= (740 - 255);  			windowPosition.width += (740 - 255);  		}  	} else {  		title = windowTitleCompact;  		if (compactChanged) {  			windowPosition.x += (740 - 255);  			windowPosition.width -= (740 - 255);  		}  	}  	isCompact = compact;  	windowPosition = GUILayout.Window (windowID' windowPosition' Window' title' windowStyle);  } else {  	settings.DrawWindow ();  }  
Magic Number,Engineer,BuildEngineer,F:\newReposMay17\CYBUTEK_Engineer\Engineer\BuildEngineer.cs,DrawGUI,The following statement contains a magic number: if (!settings.IsDrawing) {  	string title = "";  	bool compact = settings.Get<bool> ("_SAVEONCHANGE_COMPACT");  	bool compactChanged = (compact != isCompact);  	if (!compact) {  		title = windowTitle;  		if (compactChanged) {  			windowPosition.x -= (740 - 255);  			windowPosition.width += (740 - 255);  		}  	} else {  		title = windowTitleCompact;  		if (compactChanged) {  			windowPosition.x += (740 - 255);  			windowPosition.width -= (740 - 255);  		}  	}  	isCompact = compact;  	windowPosition = GUILayout.Window (windowID' windowPosition' Window' title' windowStyle);  } else {  	settings.DrawWindow ();  }  
Magic Number,Engineer,BuildEngineer,F:\newReposMay17\CYBUTEK_Engineer\Engineer\BuildEngineer.cs,DrawGUI,The following statement contains a magic number: if (!settings.IsDrawing) {  	string title = "";  	bool compact = settings.Get<bool> ("_SAVEONCHANGE_COMPACT");  	bool compactChanged = (compact != isCompact);  	if (!compact) {  		title = windowTitle;  		if (compactChanged) {  			windowPosition.x -= (740 - 255);  			windowPosition.width += (740 - 255);  		}  	} else {  		title = windowTitleCompact;  		if (compactChanged) {  			windowPosition.x += (740 - 255);  			windowPosition.width -= (740 - 255);  		}  	}  	isCompact = compact;  	windowPosition = GUILayout.Window (windowID' windowPosition' Window' title' windowStyle);  } else {  	settings.DrawWindow ();  }  
Magic Number,Engineer,BuildEngineer,F:\newReposMay17\CYBUTEK_Engineer\Engineer\BuildEngineer.cs,DrawGUI,The following statement contains a magic number: if (!settings.IsDrawing) {  	string title = "";  	bool compact = settings.Get<bool> ("_SAVEONCHANGE_COMPACT");  	bool compactChanged = (compact != isCompact);  	if (!compact) {  		title = windowTitle;  		if (compactChanged) {  			windowPosition.x -= (740 - 255);  			windowPosition.width += (740 - 255);  		}  	} else {  		title = windowTitleCompact;  		if (compactChanged) {  			windowPosition.x += (740 - 255);  			windowPosition.width -= (740 - 255);  		}  	}  	isCompact = compact;  	windowPosition = GUILayout.Window (windowID' windowPosition' Window' title' windowStyle);  } else {  	settings.DrawWindow ();  }  
Magic Number,Engineer,BuildEngineer,F:\newReposMay17\CYBUTEK_Engineer\Engineer\BuildEngineer.cs,DrawGUI,The following statement contains a magic number: if (!settings.IsDrawing) {  	string title = "";  	bool compact = settings.Get<bool> ("_SAVEONCHANGE_COMPACT");  	bool compactChanged = (compact != isCompact);  	if (!compact) {  		title = windowTitle;  		if (compactChanged) {  			windowPosition.x -= (740 - 255);  			windowPosition.width += (740 - 255);  		}  	} else {  		title = windowTitleCompact;  		if (compactChanged) {  			windowPosition.x += (740 - 255);  			windowPosition.width -= (740 - 255);  		}  	}  	isCompact = compact;  	windowPosition = GUILayout.Window (windowID' windowPosition' Window' title' windowStyle);  } else {  	settings.DrawWindow ();  }  
Magic Number,Engineer,BuildEngineer,F:\newReposMay17\CYBUTEK_Engineer\Engineer\BuildEngineer.cs,DrawGUI,The following statement contains a magic number: if (!settings.IsDrawing) {  	string title = "";  	bool compact = settings.Get<bool> ("_SAVEONCHANGE_COMPACT");  	bool compactChanged = (compact != isCompact);  	if (!compact) {  		title = windowTitle;  		if (compactChanged) {  			windowPosition.x -= (740 - 255);  			windowPosition.width += (740 - 255);  		}  	} else {  		title = windowTitleCompact;  		if (compactChanged) {  			windowPosition.x += (740 - 255);  			windowPosition.width -= (740 - 255);  		}  	}  	isCompact = compact;  	windowPosition = GUILayout.Window (windowID' windowPosition' Window' title' windowStyle);  } else {  	settings.DrawWindow ();  }  
Magic Number,Engineer,BuildEngineer,F:\newReposMay17\CYBUTEK_Engineer\Engineer\BuildEngineer.cs,DrawGUI,The following statement contains a magic number: if (!compact) {  	title = windowTitle;  	if (compactChanged) {  		windowPosition.x -= (740 - 255);  		windowPosition.width += (740 - 255);  	}  } else {  	title = windowTitleCompact;  	if (compactChanged) {  		windowPosition.x += (740 - 255);  		windowPosition.width -= (740 - 255);  	}  }  
Magic Number,Engineer,BuildEngineer,F:\newReposMay17\CYBUTEK_Engineer\Engineer\BuildEngineer.cs,DrawGUI,The following statement contains a magic number: if (!compact) {  	title = windowTitle;  	if (compactChanged) {  		windowPosition.x -= (740 - 255);  		windowPosition.width += (740 - 255);  	}  } else {  	title = windowTitleCompact;  	if (compactChanged) {  		windowPosition.x += (740 - 255);  		windowPosition.width -= (740 - 255);  	}  }  
Magic Number,Engineer,BuildEngineer,F:\newReposMay17\CYBUTEK_Engineer\Engineer\BuildEngineer.cs,DrawGUI,The following statement contains a magic number: if (!compact) {  	title = windowTitle;  	if (compactChanged) {  		windowPosition.x -= (740 - 255);  		windowPosition.width += (740 - 255);  	}  } else {  	title = windowTitleCompact;  	if (compactChanged) {  		windowPosition.x += (740 - 255);  		windowPosition.width -= (740 - 255);  	}  }  
Magic Number,Engineer,BuildEngineer,F:\newReposMay17\CYBUTEK_Engineer\Engineer\BuildEngineer.cs,DrawGUI,The following statement contains a magic number: if (!compact) {  	title = windowTitle;  	if (compactChanged) {  		windowPosition.x -= (740 - 255);  		windowPosition.width += (740 - 255);  	}  } else {  	title = windowTitleCompact;  	if (compactChanged) {  		windowPosition.x += (740 - 255);  		windowPosition.width -= (740 - 255);  	}  }  
Magic Number,Engineer,BuildEngineer,F:\newReposMay17\CYBUTEK_Engineer\Engineer\BuildEngineer.cs,DrawGUI,The following statement contains a magic number: if (!compact) {  	title = windowTitle;  	if (compactChanged) {  		windowPosition.x -= (740 - 255);  		windowPosition.width += (740 - 255);  	}  } else {  	title = windowTitleCompact;  	if (compactChanged) {  		windowPosition.x += (740 - 255);  		windowPosition.width -= (740 - 255);  	}  }  
Magic Number,Engineer,BuildEngineer,F:\newReposMay17\CYBUTEK_Engineer\Engineer\BuildEngineer.cs,DrawGUI,The following statement contains a magic number: if (!compact) {  	title = windowTitle;  	if (compactChanged) {  		windowPosition.x -= (740 - 255);  		windowPosition.width += (740 - 255);  	}  } else {  	title = windowTitleCompact;  	if (compactChanged) {  		windowPosition.x += (740 - 255);  		windowPosition.width -= (740 - 255);  	}  }  
Magic Number,Engineer,BuildEngineer,F:\newReposMay17\CYBUTEK_Engineer\Engineer\BuildEngineer.cs,DrawGUI,The following statement contains a magic number: if (!compact) {  	title = windowTitle;  	if (compactChanged) {  		windowPosition.x -= (740 - 255);  		windowPosition.width += (740 - 255);  	}  } else {  	title = windowTitleCompact;  	if (compactChanged) {  		windowPosition.x += (740 - 255);  		windowPosition.width -= (740 - 255);  	}  }  
Magic Number,Engineer,BuildEngineer,F:\newReposMay17\CYBUTEK_Engineer\Engineer\BuildEngineer.cs,DrawGUI,The following statement contains a magic number: if (!compact) {  	title = windowTitle;  	if (compactChanged) {  		windowPosition.x -= (740 - 255);  		windowPosition.width += (740 - 255);  	}  } else {  	title = windowTitleCompact;  	if (compactChanged) {  		windowPosition.x += (740 - 255);  		windowPosition.width -= (740 - 255);  	}  }  
Magic Number,Engineer,BuildEngineer,F:\newReposMay17\CYBUTEK_Engineer\Engineer\BuildEngineer.cs,DrawGUI,The following statement contains a magic number: if (compactChanged) {  	windowPosition.x -= (740 - 255);  	windowPosition.width += (740 - 255);  }  
Magic Number,Engineer,BuildEngineer,F:\newReposMay17\CYBUTEK_Engineer\Engineer\BuildEngineer.cs,DrawGUI,The following statement contains a magic number: if (compactChanged) {  	windowPosition.x -= (740 - 255);  	windowPosition.width += (740 - 255);  }  
Magic Number,Engineer,BuildEngineer,F:\newReposMay17\CYBUTEK_Engineer\Engineer\BuildEngineer.cs,DrawGUI,The following statement contains a magic number: if (compactChanged) {  	windowPosition.x -= (740 - 255);  	windowPosition.width += (740 - 255);  }  
Magic Number,Engineer,BuildEngineer,F:\newReposMay17\CYBUTEK_Engineer\Engineer\BuildEngineer.cs,DrawGUI,The following statement contains a magic number: if (compactChanged) {  	windowPosition.x -= (740 - 255);  	windowPosition.width += (740 - 255);  }  
Magic Number,Engineer,BuildEngineer,F:\newReposMay17\CYBUTEK_Engineer\Engineer\BuildEngineer.cs,DrawGUI,The following statement contains a magic number: windowPosition.x -= (740 - 255);  
Magic Number,Engineer,BuildEngineer,F:\newReposMay17\CYBUTEK_Engineer\Engineer\BuildEngineer.cs,DrawGUI,The following statement contains a magic number: windowPosition.x -= (740 - 255);  
Magic Number,Engineer,BuildEngineer,F:\newReposMay17\CYBUTEK_Engineer\Engineer\BuildEngineer.cs,DrawGUI,The following statement contains a magic number: windowPosition.width += (740 - 255);  
Magic Number,Engineer,BuildEngineer,F:\newReposMay17\CYBUTEK_Engineer\Engineer\BuildEngineer.cs,DrawGUI,The following statement contains a magic number: windowPosition.width += (740 - 255);  
Magic Number,Engineer,BuildEngineer,F:\newReposMay17\CYBUTEK_Engineer\Engineer\BuildEngineer.cs,DrawGUI,The following statement contains a magic number: if (compactChanged) {  	windowPosition.x += (740 - 255);  	windowPosition.width -= (740 - 255);  }  
Magic Number,Engineer,BuildEngineer,F:\newReposMay17\CYBUTEK_Engineer\Engineer\BuildEngineer.cs,DrawGUI,The following statement contains a magic number: if (compactChanged) {  	windowPosition.x += (740 - 255);  	windowPosition.width -= (740 - 255);  }  
Magic Number,Engineer,BuildEngineer,F:\newReposMay17\CYBUTEK_Engineer\Engineer\BuildEngineer.cs,DrawGUI,The following statement contains a magic number: if (compactChanged) {  	windowPosition.x += (740 - 255);  	windowPosition.width -= (740 - 255);  }  
Magic Number,Engineer,BuildEngineer,F:\newReposMay17\CYBUTEK_Engineer\Engineer\BuildEngineer.cs,DrawGUI,The following statement contains a magic number: if (compactChanged) {  	windowPosition.x += (740 - 255);  	windowPosition.width -= (740 - 255);  }  
Magic Number,Engineer,BuildEngineer,F:\newReposMay17\CYBUTEK_Engineer\Engineer\BuildEngineer.cs,DrawGUI,The following statement contains a magic number: windowPosition.x += (740 - 255);  
Magic Number,Engineer,BuildEngineer,F:\newReposMay17\CYBUTEK_Engineer\Engineer\BuildEngineer.cs,DrawGUI,The following statement contains a magic number: windowPosition.x += (740 - 255);  
Magic Number,Engineer,BuildEngineer,F:\newReposMay17\CYBUTEK_Engineer\Engineer\BuildEngineer.cs,DrawGUI,The following statement contains a magic number: windowPosition.width -= (740 - 255);  
Magic Number,Engineer,BuildEngineer,F:\newReposMay17\CYBUTEK_Engineer\Engineer\BuildEngineer.cs,DrawGUI,The following statement contains a magic number: windowPosition.width -= (740 - 255);  
Magic Number,Engineer,BuildEngineer,F:\newReposMay17\CYBUTEK_Engineer\Engineer\BuildEngineer.cs,Window,The following statement contains a magic number: if (settings.Get ("_SAVEONCHANGE_COMPACT"' false)) {  	GUILayout.BeginHorizontal (GUILayout.Width (255));  } else {  	GUILayout.BeginHorizontal (GUILayout.Width (740));  	settings.Set ("_SAVEONCHANGE_SHOW_MAIN"' GUILayout.Toggle (settings.Get ("_SAVEONCHANGE_SHOW_MAIN"' true)' "Main Display"' buttonStyle));  	settings.Set ("_SAVEONCHANGE_SHOW_REFERENCES"' GUILayout.Toggle (settings.Get ("_SAVEONCHANGE_SHOW_REFERENCES"' true)' "Reference Bodies"' buttonStyle));  	settings.Set ("_SAVEONCHANGE_USE_ATMOSPHERE"' GUILayout.Toggle (settings.Get ("_SAVEONCHANGE_USE_ATMOSPHERE"' false)' "Atmospheric Stats"' buttonStyle));  	settings.Set ("_SAVEONCHANGE_SHOW_ALL_STAGES"' GUILayout.Toggle (settings.Get ("_SAVEONCHANGE_SHOW_ALL_STAGES"' false)' "Show All Stages"' buttonStyle));  }  
Magic Number,Engineer,BuildEngineer,F:\newReposMay17\CYBUTEK_Engineer\Engineer\BuildEngineer.cs,Window,The following statement contains a magic number: if (settings.Get ("_SAVEONCHANGE_COMPACT"' false)) {  	GUILayout.BeginHorizontal (GUILayout.Width (255));  } else {  	GUILayout.BeginHorizontal (GUILayout.Width (740));  	settings.Set ("_SAVEONCHANGE_SHOW_MAIN"' GUILayout.Toggle (settings.Get ("_SAVEONCHANGE_SHOW_MAIN"' true)' "Main Display"' buttonStyle));  	settings.Set ("_SAVEONCHANGE_SHOW_REFERENCES"' GUILayout.Toggle (settings.Get ("_SAVEONCHANGE_SHOW_REFERENCES"' true)' "Reference Bodies"' buttonStyle));  	settings.Set ("_SAVEONCHANGE_USE_ATMOSPHERE"' GUILayout.Toggle (settings.Get ("_SAVEONCHANGE_USE_ATMOSPHERE"' false)' "Atmospheric Stats"' buttonStyle));  	settings.Set ("_SAVEONCHANGE_SHOW_ALL_STAGES"' GUILayout.Toggle (settings.Get ("_SAVEONCHANGE_SHOW_ALL_STAGES"' false)' "Show All Stages"' buttonStyle));  }  
Magic Number,Engineer,BuildEngineer,F:\newReposMay17\CYBUTEK_Engineer\Engineer\BuildEngineer.cs,Window,The following statement contains a magic number: GUILayout.BeginHorizontal (GUILayout.Width (255));  
Magic Number,Engineer,BuildEngineer,F:\newReposMay17\CYBUTEK_Engineer\Engineer\BuildEngineer.cs,Window,The following statement contains a magic number: GUILayout.BeginHorizontal (GUILayout.Width (740));  
Magic Number,Engineer,BuildEngineer,F:\newReposMay17\CYBUTEK_Engineer\Engineer\BuildEngineer.cs,DrawCost,The following statement contains a magic number: GUILayout.BeginVertical (GUILayout.Width (120));  
Magic Number,Engineer,BuildEngineer,F:\newReposMay17\CYBUTEK_Engineer\Engineer\BuildEngineer.cs,DrawMass,The following statement contains a magic number: GUILayout.BeginVertical (GUILayout.Width (150));  
Magic Number,Engineer,BuildEngineer,F:\newReposMay17\CYBUTEK_Engineer\Engineer\BuildEngineer.cs,DrawIsp,The following statement contains a magic number: GUILayout.BeginVertical (GUILayout.Width (50));  
Magic Number,Engineer,BuildEngineer,F:\newReposMay17\CYBUTEK_Engineer\Engineer\BuildEngineer.cs,DrawThrust,The following statement contains a magic number: GUILayout.BeginVertical (GUILayout.Width (85));  
Magic Number,Engineer,BuildEngineer,F:\newReposMay17\CYBUTEK_Engineer\Engineer\BuildEngineer.cs,DrawDeltaV,The following statement contains a magic number: GUILayout.BeginVertical (GUILayout.Width (115));  
Magic Number,Engineer,BuildEngineer,F:\newReposMay17\CYBUTEK_Engineer\Engineer\BuildEngineer.cs,DrawTWR,The following statement contains a magic number: GUILayout.BeginVertical (GUILayout.Width (90));  
Magic Number,Engineer,BuildEngineer,F:\newReposMay17\CYBUTEK_Engineer\Engineer\BuildEngineer.cs,DrawTWR,The following statement contains a magic number: for (int i = 0; i < stages.Length; i++) {  	if (!settings.Get<bool> ("_SAVEONCHANGE_SHOW_ALL_STAGES") && stages [i].deltaV == 0) {  		continue;  	}  	GUILayout.Label (EngineerTools.SimpleFormatter (stages [i].thrustToWeight' ""' 2) + " (" + EngineerTools.SimpleFormatter (stages [i].maxThrustToWeight' ""' 2) + ")"' dataStyle);  }  
Magic Number,Engineer,BuildEngineer,F:\newReposMay17\CYBUTEK_Engineer\Engineer\BuildEngineer.cs,DrawTWR,The following statement contains a magic number: for (int i = 0; i < stages.Length; i++) {  	if (!settings.Get<bool> ("_SAVEONCHANGE_SHOW_ALL_STAGES") && stages [i].deltaV == 0) {  		continue;  	}  	GUILayout.Label (EngineerTools.SimpleFormatter (stages [i].thrustToWeight' ""' 2) + " (" + EngineerTools.SimpleFormatter (stages [i].maxThrustToWeight' ""' 2) + ")"' dataStyle);  }  
Magic Number,Engineer,BuildEngineer,F:\newReposMay17\CYBUTEK_Engineer\Engineer\BuildEngineer.cs,DrawTWR,The following statement contains a magic number: GUILayout.Label (EngineerTools.SimpleFormatter (stages [i].thrustToWeight' ""' 2) + " (" + EngineerTools.SimpleFormatter (stages [i].maxThrustToWeight' ""' 2) + ")"' dataStyle);  
Magic Number,Engineer,BuildEngineer,F:\newReposMay17\CYBUTEK_Engineer\Engineer\BuildEngineer.cs,DrawTWR,The following statement contains a magic number: GUILayout.Label (EngineerTools.SimpleFormatter (stages [i].thrustToWeight' ""' 2) + " (" + EngineerTools.SimpleFormatter (stages [i].maxThrustToWeight' ""' 2) + ")"' dataStyle);  
Magic Number,Engineer,BuildEngineer,F:\newReposMay17\CYBUTEK_Engineer\Engineer\BuildEngineer.cs,DrawTime,The following statement contains a magic number: GUILayout.BeginVertical (GUILayout.Width (60));  
Magic Number,Engineer,EngineerTools,F:\newReposMay17\CYBUTEK_Engineer\Engineer\EngineerTools.cs,WeightFormatter,The following statement contains a magic number: weight *= 1000;  
Magic Number,Engineer,EngineerTools,F:\newReposMay17\CYBUTEK_Engineer\Engineer\EngineerTools.cs,WeightFormatter,The following statement contains a magic number: weight1 *= 1000;  
Magic Number,Engineer,EngineerTools,F:\newReposMay17\CYBUTEK_Engineer\Engineer\EngineerTools.cs,WeightFormatter,The following statement contains a magic number: weight2 *= 1000;  
Magic Number,Engineer,StockToolbar,F:\newReposMay17\CYBUTEK_Engineer\Engineer\StockToolbar.cs,Awake,The following statement contains a magic number: if (texture == null) {  	texture = new Texture2D (36' 36' TextureFormat.RGBA32' false);  	texture.LoadImage (File.ReadAllBytes (Path.Combine (Path.GetDirectoryName (Assembly.GetExecutingAssembly ().Location)' "StockToolbar.png")));  }  
Magic Number,Engineer,StockToolbar,F:\newReposMay17\CYBUTEK_Engineer\Engineer\StockToolbar.cs,Awake,The following statement contains a magic number: if (texture == null) {  	texture = new Texture2D (36' 36' TextureFormat.RGBA32' false);  	texture.LoadImage (File.ReadAllBytes (Path.Combine (Path.GetDirectoryName (Assembly.GetExecutingAssembly ().Location)' "StockToolbar.png")));  }  
Magic Number,Engineer,StockToolbar,F:\newReposMay17\CYBUTEK_Engineer\Engineer\StockToolbar.cs,Awake,The following statement contains a magic number: texture = new Texture2D (36' 36' TextureFormat.RGBA32' false);  
Magic Number,Engineer,StockToolbar,F:\newReposMay17\CYBUTEK_Engineer\Engineer\StockToolbar.cs,Awake,The following statement contains a magic number: texture = new Texture2D (36' 36' TextureFormat.RGBA32' false);  
Magic Number,Engineer,Tools,F:\newReposMay17\CYBUTEK_Engineer\Engineer\Tools.cs,FormatSI,The following statement contains a magic number: switch (type) {  case SIUnitType.Distance:  	return ToDistance (number);  // Quick and dirty implementation of the new distance formatter from KER 1.0  //notation = new string[] { "mm"' "m"' "km"' "Mm"' "Gm"' "Tm"' "Pm"' "Em"' "Zm"' "Ym" };  //number *= 1000;  case SIUnitType.Speed:  	notation = new string[] {  		"mm/s"'  		"m/s"'  		"km/s"'  		"Mm/s"'  		"Gm/s"'  		"Tm/s"'  		"Pm/s"'  		"Em/s"'  		"Zm/s"'  		"Ym/s"  	};  	number *= 1000;  	break;  case SIUnitType.Pressure:  	notation = new string[] {  		"Pa"'  		"kPa"'  		"MPa"'  		"GPa"'  		"TPa"'  		"PPa"'  		"EPa"'  		"ZPa"'  		"YPa"  	};  	number *= 1000;  	break;  case SIUnitType.Density:  	notation = new string[] {  		"mg/m"'  		"g/m"'  		"kg/m"'  		"Mg/m"'  		"Gg/m"'  		"Tg/m"'  		"Pg/m"'  		"Eg/m"'  		"Zg/m"'  		"Yg/m"  	};  	number *= 1000000;  	break;  case SIUnitType.Force:  	notation = new string[] {  		"N"'  		"kN"'  		"MN"'  		"GN"'  		"TN"'  		"PT"'  		"EN"'  		"ZN"'  		"YN"  	};  	number *= 1000;  	break;  case SIUnitType.Mass:  	notation = new string[] {  		"g"'  		"kg"'  		"Mg"'  		"Gg"'  		"Tg"'  		"Pg"'  		"Eg"'  		"Zg"'  		"Yg"  	};  	number *= 1000;  	break;  }  
Magic Number,Engineer,Tools,F:\newReposMay17\CYBUTEK_Engineer\Engineer\Tools.cs,FormatSI,The following statement contains a magic number: switch (type) {  case SIUnitType.Distance:  	return ToDistance (number);  // Quick and dirty implementation of the new distance formatter from KER 1.0  //notation = new string[] { "mm"' "m"' "km"' "Mm"' "Gm"' "Tm"' "Pm"' "Em"' "Zm"' "Ym" };  //number *= 1000;  case SIUnitType.Speed:  	notation = new string[] {  		"mm/s"'  		"m/s"'  		"km/s"'  		"Mm/s"'  		"Gm/s"'  		"Tm/s"'  		"Pm/s"'  		"Em/s"'  		"Zm/s"'  		"Ym/s"  	};  	number *= 1000;  	break;  case SIUnitType.Pressure:  	notation = new string[] {  		"Pa"'  		"kPa"'  		"MPa"'  		"GPa"'  		"TPa"'  		"PPa"'  		"EPa"'  		"ZPa"'  		"YPa"  	};  	number *= 1000;  	break;  case SIUnitType.Density:  	notation = new string[] {  		"mg/m"'  		"g/m"'  		"kg/m"'  		"Mg/m"'  		"Gg/m"'  		"Tg/m"'  		"Pg/m"'  		"Eg/m"'  		"Zg/m"'  		"Yg/m"  	};  	number *= 1000000;  	break;  case SIUnitType.Force:  	notation = new string[] {  		"N"'  		"kN"'  		"MN"'  		"GN"'  		"TN"'  		"PT"'  		"EN"'  		"ZN"'  		"YN"  	};  	number *= 1000;  	break;  case SIUnitType.Mass:  	notation = new string[] {  		"g"'  		"kg"'  		"Mg"'  		"Gg"'  		"Tg"'  		"Pg"'  		"Eg"'  		"Zg"'  		"Yg"  	};  	number *= 1000;  	break;  }  
Magic Number,Engineer,Tools,F:\newReposMay17\CYBUTEK_Engineer\Engineer\Tools.cs,FormatSI,The following statement contains a magic number: switch (type) {  case SIUnitType.Distance:  	return ToDistance (number);  // Quick and dirty implementation of the new distance formatter from KER 1.0  //notation = new string[] { "mm"' "m"' "km"' "Mm"' "Gm"' "Tm"' "Pm"' "Em"' "Zm"' "Ym" };  //number *= 1000;  case SIUnitType.Speed:  	notation = new string[] {  		"mm/s"'  		"m/s"'  		"km/s"'  		"Mm/s"'  		"Gm/s"'  		"Tm/s"'  		"Pm/s"'  		"Em/s"'  		"Zm/s"'  		"Ym/s"  	};  	number *= 1000;  	break;  case SIUnitType.Pressure:  	notation = new string[] {  		"Pa"'  		"kPa"'  		"MPa"'  		"GPa"'  		"TPa"'  		"PPa"'  		"EPa"'  		"ZPa"'  		"YPa"  	};  	number *= 1000;  	break;  case SIUnitType.Density:  	notation = new string[] {  		"mg/m"'  		"g/m"'  		"kg/m"'  		"Mg/m"'  		"Gg/m"'  		"Tg/m"'  		"Pg/m"'  		"Eg/m"'  		"Zg/m"'  		"Yg/m"  	};  	number *= 1000000;  	break;  case SIUnitType.Force:  	notation = new string[] {  		"N"'  		"kN"'  		"MN"'  		"GN"'  		"TN"'  		"PT"'  		"EN"'  		"ZN"'  		"YN"  	};  	number *= 1000;  	break;  case SIUnitType.Mass:  	notation = new string[] {  		"g"'  		"kg"'  		"Mg"'  		"Gg"'  		"Tg"'  		"Pg"'  		"Eg"'  		"Zg"'  		"Yg"  	};  	number *= 1000;  	break;  }  
Magic Number,Engineer,Tools,F:\newReposMay17\CYBUTEK_Engineer\Engineer\Tools.cs,FormatSI,The following statement contains a magic number: switch (type) {  case SIUnitType.Distance:  	return ToDistance (number);  // Quick and dirty implementation of the new distance formatter from KER 1.0  //notation = new string[] { "mm"' "m"' "km"' "Mm"' "Gm"' "Tm"' "Pm"' "Em"' "Zm"' "Ym" };  //number *= 1000;  case SIUnitType.Speed:  	notation = new string[] {  		"mm/s"'  		"m/s"'  		"km/s"'  		"Mm/s"'  		"Gm/s"'  		"Tm/s"'  		"Pm/s"'  		"Em/s"'  		"Zm/s"'  		"Ym/s"  	};  	number *= 1000;  	break;  case SIUnitType.Pressure:  	notation = new string[] {  		"Pa"'  		"kPa"'  		"MPa"'  		"GPa"'  		"TPa"'  		"PPa"'  		"EPa"'  		"ZPa"'  		"YPa"  	};  	number *= 1000;  	break;  case SIUnitType.Density:  	notation = new string[] {  		"mg/m"'  		"g/m"'  		"kg/m"'  		"Mg/m"'  		"Gg/m"'  		"Tg/m"'  		"Pg/m"'  		"Eg/m"'  		"Zg/m"'  		"Yg/m"  	};  	number *= 1000000;  	break;  case SIUnitType.Force:  	notation = new string[] {  		"N"'  		"kN"'  		"MN"'  		"GN"'  		"TN"'  		"PT"'  		"EN"'  		"ZN"'  		"YN"  	};  	number *= 1000;  	break;  case SIUnitType.Mass:  	notation = new string[] {  		"g"'  		"kg"'  		"Mg"'  		"Gg"'  		"Tg"'  		"Pg"'  		"Eg"'  		"Zg"'  		"Yg"  	};  	number *= 1000;  	break;  }  
Magic Number,Engineer,Tools,F:\newReposMay17\CYBUTEK_Engineer\Engineer\Tools.cs,FormatSI,The following statement contains a magic number: switch (type) {  case SIUnitType.Distance:  	return ToDistance (number);  // Quick and dirty implementation of the new distance formatter from KER 1.0  //notation = new string[] { "mm"' "m"' "km"' "Mm"' "Gm"' "Tm"' "Pm"' "Em"' "Zm"' "Ym" };  //number *= 1000;  case SIUnitType.Speed:  	notation = new string[] {  		"mm/s"'  		"m/s"'  		"km/s"'  		"Mm/s"'  		"Gm/s"'  		"Tm/s"'  		"Pm/s"'  		"Em/s"'  		"Zm/s"'  		"Ym/s"  	};  	number *= 1000;  	break;  case SIUnitType.Pressure:  	notation = new string[] {  		"Pa"'  		"kPa"'  		"MPa"'  		"GPa"'  		"TPa"'  		"PPa"'  		"EPa"'  		"ZPa"'  		"YPa"  	};  	number *= 1000;  	break;  case SIUnitType.Density:  	notation = new string[] {  		"mg/m"'  		"g/m"'  		"kg/m"'  		"Mg/m"'  		"Gg/m"'  		"Tg/m"'  		"Pg/m"'  		"Eg/m"'  		"Zg/m"'  		"Yg/m"  	};  	number *= 1000000;  	break;  case SIUnitType.Force:  	notation = new string[] {  		"N"'  		"kN"'  		"MN"'  		"GN"'  		"TN"'  		"PT"'  		"EN"'  		"ZN"'  		"YN"  	};  	number *= 1000;  	break;  case SIUnitType.Mass:  	notation = new string[] {  		"g"'  		"kg"'  		"Mg"'  		"Gg"'  		"Tg"'  		"Pg"'  		"Eg"'  		"Zg"'  		"Yg"  	};  	number *= 1000;  	break;  }  
Magic Number,Engineer,Tools,F:\newReposMay17\CYBUTEK_Engineer\Engineer\Tools.cs,FormatSI,The following statement contains a magic number: number *= 1000;  
Magic Number,Engineer,Tools,F:\newReposMay17\CYBUTEK_Engineer\Engineer\Tools.cs,FormatSI,The following statement contains a magic number: number *= 1000;  
Magic Number,Engineer,Tools,F:\newReposMay17\CYBUTEK_Engineer\Engineer\Tools.cs,FormatSI,The following statement contains a magic number: number *= 1000000;  
Magic Number,Engineer,Tools,F:\newReposMay17\CYBUTEK_Engineer\Engineer\Tools.cs,FormatSI,The following statement contains a magic number: number *= 1000;  
Magic Number,Engineer,Tools,F:\newReposMay17\CYBUTEK_Engineer\Engineer\Tools.cs,FormatSI,The following statement contains a magic number: number *= 1000;  
Magic Number,Engineer,Tools,F:\newReposMay17\CYBUTEK_Engineer\Engineer\Tools.cs,FormatSI,The following statement contains a magic number: for (notationIndex = 0; notationIndex < notation.Length; notationIndex++) {  	// If the number is now in a sensible range then return a string of the concatenated number and selected notation.  	if (number <= 1000d && number >= -1000d)  		return number.ToString ("0.000") + notation [notationIndex];  	// Switch to bigger unit  	number /= 1000;  }  
Magic Number,Engineer,Tools,F:\newReposMay17\CYBUTEK_Engineer\Engineer\Tools.cs,FormatSI,The following statement contains a magic number: number /= 1000;  
Magic Number,Engineer,Tools,F:\newReposMay17\CYBUTEK_Engineer\Engineer\Tools.cs,FormatTime,The following statement contains a magic number: if (s >= 31536000) {  	while (s >= 31536000) {  		y++;  		s -= 31536000;  	}  	y += (s / 31536000);  	return y.ToString ("0.000") + "y";  }  
Magic Number,Engineer,Tools,F:\newReposMay17\CYBUTEK_Engineer\Engineer\Tools.cs,FormatTime,The following statement contains a magic number: if (s >= 31536000) {  	while (s >= 31536000) {  		y++;  		s -= 31536000;  	}  	y += (s / 31536000);  	return y.ToString ("0.000") + "y";  }  
Magic Number,Engineer,Tools,F:\newReposMay17\CYBUTEK_Engineer\Engineer\Tools.cs,FormatTime,The following statement contains a magic number: if (s >= 31536000) {  	while (s >= 31536000) {  		y++;  		s -= 31536000;  	}  	y += (s / 31536000);  	return y.ToString ("0.000") + "y";  }  
Magic Number,Engineer,Tools,F:\newReposMay17\CYBUTEK_Engineer\Engineer\Tools.cs,FormatTime,The following statement contains a magic number: if (s >= 31536000) {  	while (s >= 31536000) {  		y++;  		s -= 31536000;  	}  	y += (s / 31536000);  	return y.ToString ("0.000") + "y";  }  
Magic Number,Engineer,Tools,F:\newReposMay17\CYBUTEK_Engineer\Engineer\Tools.cs,FormatTime,The following statement contains a magic number: while (s >= 31536000) {  	y++;  	s -= 31536000;  }  
Magic Number,Engineer,Tools,F:\newReposMay17\CYBUTEK_Engineer\Engineer\Tools.cs,FormatTime,The following statement contains a magic number: while (s >= 31536000) {  	y++;  	s -= 31536000;  }  
Magic Number,Engineer,Tools,F:\newReposMay17\CYBUTEK_Engineer\Engineer\Tools.cs,FormatTime,The following statement contains a magic number: s -= 31536000;  
Magic Number,Engineer,Tools,F:\newReposMay17\CYBUTEK_Engineer\Engineer\Tools.cs,FormatTime,The following statement contains a magic number: y += (s / 31536000);  
Magic Number,Engineer,Tools,F:\newReposMay17\CYBUTEK_Engineer\Engineer\Tools.cs,FormatTime,The following statement contains a magic number: if (s >= 86400) {  	while (s >= 86400) {  		d++;  		s -= 86400;  	}  	d += (s / 86400);  	return d.ToString ("0.000") + "d";  }  
Magic Number,Engineer,Tools,F:\newReposMay17\CYBUTEK_Engineer\Engineer\Tools.cs,FormatTime,The following statement contains a magic number: if (s >= 86400) {  	while (s >= 86400) {  		d++;  		s -= 86400;  	}  	d += (s / 86400);  	return d.ToString ("0.000") + "d";  }  
Magic Number,Engineer,Tools,F:\newReposMay17\CYBUTEK_Engineer\Engineer\Tools.cs,FormatTime,The following statement contains a magic number: if (s >= 86400) {  	while (s >= 86400) {  		d++;  		s -= 86400;  	}  	d += (s / 86400);  	return d.ToString ("0.000") + "d";  }  
Magic Number,Engineer,Tools,F:\newReposMay17\CYBUTEK_Engineer\Engineer\Tools.cs,FormatTime,The following statement contains a magic number: if (s >= 86400) {  	while (s >= 86400) {  		d++;  		s -= 86400;  	}  	d += (s / 86400);  	return d.ToString ("0.000") + "d";  }  
Magic Number,Engineer,Tools,F:\newReposMay17\CYBUTEK_Engineer\Engineer\Tools.cs,FormatTime,The following statement contains a magic number: while (s >= 86400) {  	d++;  	s -= 86400;  }  
Magic Number,Engineer,Tools,F:\newReposMay17\CYBUTEK_Engineer\Engineer\Tools.cs,FormatTime,The following statement contains a magic number: while (s >= 86400) {  	d++;  	s -= 86400;  }  
Magic Number,Engineer,Tools,F:\newReposMay17\CYBUTEK_Engineer\Engineer\Tools.cs,FormatTime,The following statement contains a magic number: s -= 86400;  
Magic Number,Engineer,Tools,F:\newReposMay17\CYBUTEK_Engineer\Engineer\Tools.cs,FormatTime,The following statement contains a magic number: d += (s / 86400);  
Magic Number,Engineer,Tools,F:\newReposMay17\CYBUTEK_Engineer\Engineer\Tools.cs,FormatTime,The following statement contains a magic number: while (s >= 60) {  	m++;  	s -= 60;  }  
Magic Number,Engineer,Tools,F:\newReposMay17\CYBUTEK_Engineer\Engineer\Tools.cs,FormatTime,The following statement contains a magic number: while (s >= 60) {  	m++;  	s -= 60;  }  
Magic Number,Engineer,Tools,F:\newReposMay17\CYBUTEK_Engineer\Engineer\Tools.cs,FormatTime,The following statement contains a magic number: s -= 60;  
Magic Number,Engineer,Tools,F:\newReposMay17\CYBUTEK_Engineer\Engineer\Tools.cs,FormatTime,The following statement contains a magic number: while (m >= 60) {  	h++;  	m -= 60;  }  
Magic Number,Engineer,Tools,F:\newReposMay17\CYBUTEK_Engineer\Engineer\Tools.cs,FormatTime,The following statement contains a magic number: while (m >= 60) {  	h++;  	m -= 60;  }  
Magic Number,Engineer,Tools,F:\newReposMay17\CYBUTEK_Engineer\Engineer\Tools.cs,FormatTime,The following statement contains a magic number: m -= 60;  
Magic Number,Engineer,Tools,F:\newReposMay17\CYBUTEK_Engineer\Engineer\Tools.cs,FormatTime,The following statement contains a magic number: while (h >= 24) {  	d++;  	h -= 24;  }  
Magic Number,Engineer,Tools,F:\newReposMay17\CYBUTEK_Engineer\Engineer\Tools.cs,FormatTime,The following statement contains a magic number: while (h >= 24) {  	d++;  	h -= 24;  }  
Magic Number,Engineer,Tools,F:\newReposMay17\CYBUTEK_Engineer\Engineer\Tools.cs,FormatTime,The following statement contains a magic number: h -= 24;  
Magic Number,Engineer,Tools,F:\newReposMay17\CYBUTEK_Engineer\Engineer\Tools.cs,GetSlopeAngleAndHeading,The following statement contains a magic number: if (Physics.Raycast (vessel.CoM' -rad' out hit' Mathf.Infinity' 1 << 15))// Just "Local Scenery" please   {  	Vector3d norm = hit.normal;  	norm = norm.normalized;  	//log.buf.AppendLine("norm = " + norm.ToString() + " len = " + norm.magnitude);  	double raddotnorm = Vector3d.Dot (rad' norm);  	//log.buf.AppendLine("dot = " + raddotnorm);  	if (raddotnorm > 1.0)  		raddotnorm = 1.0;  	else if (raddotnorm < 0.0)  		raddotnorm = 0.0;  	double slope = Math.Acos (raddotnorm) * 180 / Math.PI;  	//log.buf.AppendLine("slope = " + slope);  	result = FormatNumber (slope' ""' 1);  	if (slope < 0.05) {  		result += " @ ---";  	} else {  		Vector3d side = Vector3d.Cross (rad' norm).normalized;  		//log.buf.AppendLine("side = " + side.ToString() + "   len = " + side.magnitude);  		Vector3d east = Vector3d.Cross (rad' Vector3d.up).normalized;  		//log.buf.AppendLine("east = " + east.ToString() + "   len = " + east.magnitude);  		Vector3d north = Vector3d.Cross (rad' east).normalized;  		//log.buf.AppendLine("north = " + north.ToString() + "   len = " + north.magnitude);  		double sidedoteast = Vector3d.Dot (side' east);  		//log.buf.AppendLine("side.east = " + sidedoteast);  		double direction = Math.Acos (sidedoteast) * 180 / Math.PI;  		//log.buf.AppendLine("angle side:east = " + direction);  		double sidedotnorth = Vector3d.Dot (side' north);  		//log.buf.AppendLine("side.north = " + sidedotnorth);  		if (sidedotnorth < 0)  			direction = 360 - direction;  		result += " @ " + FormatNumber (direction' ""' 0);  	}  } else {  	result = "-- @ ---";  }  
Magic Number,Engineer,Tools,F:\newReposMay17\CYBUTEK_Engineer\Engineer\Tools.cs,GetSlopeAngleAndHeading,The following statement contains a magic number: if (Physics.Raycast (vessel.CoM' -rad' out hit' Mathf.Infinity' 1 << 15))// Just "Local Scenery" please   {  	Vector3d norm = hit.normal;  	norm = norm.normalized;  	//log.buf.AppendLine("norm = " + norm.ToString() + " len = " + norm.magnitude);  	double raddotnorm = Vector3d.Dot (rad' norm);  	//log.buf.AppendLine("dot = " + raddotnorm);  	if (raddotnorm > 1.0)  		raddotnorm = 1.0;  	else if (raddotnorm < 0.0)  		raddotnorm = 0.0;  	double slope = Math.Acos (raddotnorm) * 180 / Math.PI;  	//log.buf.AppendLine("slope = " + slope);  	result = FormatNumber (slope' ""' 1);  	if (slope < 0.05) {  		result += " @ ---";  	} else {  		Vector3d side = Vector3d.Cross (rad' norm).normalized;  		//log.buf.AppendLine("side = " + side.ToString() + "   len = " + side.magnitude);  		Vector3d east = Vector3d.Cross (rad' Vector3d.up).normalized;  		//log.buf.AppendLine("east = " + east.ToString() + "   len = " + east.magnitude);  		Vector3d north = Vector3d.Cross (rad' east).normalized;  		//log.buf.AppendLine("north = " + north.ToString() + "   len = " + north.magnitude);  		double sidedoteast = Vector3d.Dot (side' east);  		//log.buf.AppendLine("side.east = " + sidedoteast);  		double direction = Math.Acos (sidedoteast) * 180 / Math.PI;  		//log.buf.AppendLine("angle side:east = " + direction);  		double sidedotnorth = Vector3d.Dot (side' north);  		//log.buf.AppendLine("side.north = " + sidedotnorth);  		if (sidedotnorth < 0)  			direction = 360 - direction;  		result += " @ " + FormatNumber (direction' ""' 0);  	}  } else {  	result = "-- @ ---";  }  
Magic Number,Engineer,Tools,F:\newReposMay17\CYBUTEK_Engineer\Engineer\Tools.cs,GetSlopeAngleAndHeading,The following statement contains a magic number: if (Physics.Raycast (vessel.CoM' -rad' out hit' Mathf.Infinity' 1 << 15))// Just "Local Scenery" please   {  	Vector3d norm = hit.normal;  	norm = norm.normalized;  	//log.buf.AppendLine("norm = " + norm.ToString() + " len = " + norm.magnitude);  	double raddotnorm = Vector3d.Dot (rad' norm);  	//log.buf.AppendLine("dot = " + raddotnorm);  	if (raddotnorm > 1.0)  		raddotnorm = 1.0;  	else if (raddotnorm < 0.0)  		raddotnorm = 0.0;  	double slope = Math.Acos (raddotnorm) * 180 / Math.PI;  	//log.buf.AppendLine("slope = " + slope);  	result = FormatNumber (slope' ""' 1);  	if (slope < 0.05) {  		result += " @ ---";  	} else {  		Vector3d side = Vector3d.Cross (rad' norm).normalized;  		//log.buf.AppendLine("side = " + side.ToString() + "   len = " + side.magnitude);  		Vector3d east = Vector3d.Cross (rad' Vector3d.up).normalized;  		//log.buf.AppendLine("east = " + east.ToString() + "   len = " + east.magnitude);  		Vector3d north = Vector3d.Cross (rad' east).normalized;  		//log.buf.AppendLine("north = " + north.ToString() + "   len = " + north.magnitude);  		double sidedoteast = Vector3d.Dot (side' east);  		//log.buf.AppendLine("side.east = " + sidedoteast);  		double direction = Math.Acos (sidedoteast) * 180 / Math.PI;  		//log.buf.AppendLine("angle side:east = " + direction);  		double sidedotnorth = Vector3d.Dot (side' north);  		//log.buf.AppendLine("side.north = " + sidedotnorth);  		if (sidedotnorth < 0)  			direction = 360 - direction;  		result += " @ " + FormatNumber (direction' ""' 0);  	}  } else {  	result = "-- @ ---";  }  
Magic Number,Engineer,Tools,F:\newReposMay17\CYBUTEK_Engineer\Engineer\Tools.cs,GetSlopeAngleAndHeading,The following statement contains a magic number: if (Physics.Raycast (vessel.CoM' -rad' out hit' Mathf.Infinity' 1 << 15))// Just "Local Scenery" please   {  	Vector3d norm = hit.normal;  	norm = norm.normalized;  	//log.buf.AppendLine("norm = " + norm.ToString() + " len = " + norm.magnitude);  	double raddotnorm = Vector3d.Dot (rad' norm);  	//log.buf.AppendLine("dot = " + raddotnorm);  	if (raddotnorm > 1.0)  		raddotnorm = 1.0;  	else if (raddotnorm < 0.0)  		raddotnorm = 0.0;  	double slope = Math.Acos (raddotnorm) * 180 / Math.PI;  	//log.buf.AppendLine("slope = " + slope);  	result = FormatNumber (slope' ""' 1);  	if (slope < 0.05) {  		result += " @ ---";  	} else {  		Vector3d side = Vector3d.Cross (rad' norm).normalized;  		//log.buf.AppendLine("side = " + side.ToString() + "   len = " + side.magnitude);  		Vector3d east = Vector3d.Cross (rad' Vector3d.up).normalized;  		//log.buf.AppendLine("east = " + east.ToString() + "   len = " + east.magnitude);  		Vector3d north = Vector3d.Cross (rad' east).normalized;  		//log.buf.AppendLine("north = " + north.ToString() + "   len = " + north.magnitude);  		double sidedoteast = Vector3d.Dot (side' east);  		//log.buf.AppendLine("side.east = " + sidedoteast);  		double direction = Math.Acos (sidedoteast) * 180 / Math.PI;  		//log.buf.AppendLine("angle side:east = " + direction);  		double sidedotnorth = Vector3d.Dot (side' north);  		//log.buf.AppendLine("side.north = " + sidedotnorth);  		if (sidedotnorth < 0)  			direction = 360 - direction;  		result += " @ " + FormatNumber (direction' ""' 0);  	}  } else {  	result = "-- @ ---";  }  
Magic Number,Engineer,Tools,F:\newReposMay17\CYBUTEK_Engineer\Engineer\Tools.cs,GetSlopeAngleAndHeading,The following statement contains a magic number: if (Physics.Raycast (vessel.CoM' -rad' out hit' Mathf.Infinity' 1 << 15))// Just "Local Scenery" please   {  	Vector3d norm = hit.normal;  	norm = norm.normalized;  	//log.buf.AppendLine("norm = " + norm.ToString() + " len = " + norm.magnitude);  	double raddotnorm = Vector3d.Dot (rad' norm);  	//log.buf.AppendLine("dot = " + raddotnorm);  	if (raddotnorm > 1.0)  		raddotnorm = 1.0;  	else if (raddotnorm < 0.0)  		raddotnorm = 0.0;  	double slope = Math.Acos (raddotnorm) * 180 / Math.PI;  	//log.buf.AppendLine("slope = " + slope);  	result = FormatNumber (slope' ""' 1);  	if (slope < 0.05) {  		result += " @ ---";  	} else {  		Vector3d side = Vector3d.Cross (rad' norm).normalized;  		//log.buf.AppendLine("side = " + side.ToString() + "   len = " + side.magnitude);  		Vector3d east = Vector3d.Cross (rad' Vector3d.up).normalized;  		//log.buf.AppendLine("east = " + east.ToString() + "   len = " + east.magnitude);  		Vector3d north = Vector3d.Cross (rad' east).normalized;  		//log.buf.AppendLine("north = " + north.ToString() + "   len = " + north.magnitude);  		double sidedoteast = Vector3d.Dot (side' east);  		//log.buf.AppendLine("side.east = " + sidedoteast);  		double direction = Math.Acos (sidedoteast) * 180 / Math.PI;  		//log.buf.AppendLine("angle side:east = " + direction);  		double sidedotnorth = Vector3d.Dot (side' north);  		//log.buf.AppendLine("side.north = " + sidedotnorth);  		if (sidedotnorth < 0)  			direction = 360 - direction;  		result += " @ " + FormatNumber (direction' ""' 0);  	}  } else {  	result = "-- @ ---";  }  
Magic Number,Engineer,Tools,F:\newReposMay17\CYBUTEK_Engineer\Engineer\Tools.cs,GetSlopeAngleAndHeading,The following statement contains a magic number: if (slope < 0.05) {  	result += " @ ---";  } else {  	Vector3d side = Vector3d.Cross (rad' norm).normalized;  	//log.buf.AppendLine("side = " + side.ToString() + "   len = " + side.magnitude);  	Vector3d east = Vector3d.Cross (rad' Vector3d.up).normalized;  	//log.buf.AppendLine("east = " + east.ToString() + "   len = " + east.magnitude);  	Vector3d north = Vector3d.Cross (rad' east).normalized;  	//log.buf.AppendLine("north = " + north.ToString() + "   len = " + north.magnitude);  	double sidedoteast = Vector3d.Dot (side' east);  	//log.buf.AppendLine("side.east = " + sidedoteast);  	double direction = Math.Acos (sidedoteast) * 180 / Math.PI;  	//log.buf.AppendLine("angle side:east = " + direction);  	double sidedotnorth = Vector3d.Dot (side' north);  	//log.buf.AppendLine("side.north = " + sidedotnorth);  	if (sidedotnorth < 0)  		direction = 360 - direction;  	result += " @ " + FormatNumber (direction' ""' 0);  }  
Magic Number,Engineer,Tools,F:\newReposMay17\CYBUTEK_Engineer\Engineer\Tools.cs,GetSlopeAngleAndHeading,The following statement contains a magic number: if (slope < 0.05) {  	result += " @ ---";  } else {  	Vector3d side = Vector3d.Cross (rad' norm).normalized;  	//log.buf.AppendLine("side = " + side.ToString() + "   len = " + side.magnitude);  	Vector3d east = Vector3d.Cross (rad' Vector3d.up).normalized;  	//log.buf.AppendLine("east = " + east.ToString() + "   len = " + east.magnitude);  	Vector3d north = Vector3d.Cross (rad' east).normalized;  	//log.buf.AppendLine("north = " + north.ToString() + "   len = " + north.magnitude);  	double sidedoteast = Vector3d.Dot (side' east);  	//log.buf.AppendLine("side.east = " + sidedoteast);  	double direction = Math.Acos (sidedoteast) * 180 / Math.PI;  	//log.buf.AppendLine("angle side:east = " + direction);  	double sidedotnorth = Vector3d.Dot (side' north);  	//log.buf.AppendLine("side.north = " + sidedotnorth);  	if (sidedotnorth < 0)  		direction = 360 - direction;  	result += " @ " + FormatNumber (direction' ""' 0);  }  
Magic Number,Engineer,Tools,F:\newReposMay17\CYBUTEK_Engineer\Engineer\Tools.cs,GetSlopeAngleAndHeading,The following statement contains a magic number: if (slope < 0.05) {  	result += " @ ---";  } else {  	Vector3d side = Vector3d.Cross (rad' norm).normalized;  	//log.buf.AppendLine("side = " + side.ToString() + "   len = " + side.magnitude);  	Vector3d east = Vector3d.Cross (rad' Vector3d.up).normalized;  	//log.buf.AppendLine("east = " + east.ToString() + "   len = " + east.magnitude);  	Vector3d north = Vector3d.Cross (rad' east).normalized;  	//log.buf.AppendLine("north = " + north.ToString() + "   len = " + north.magnitude);  	double sidedoteast = Vector3d.Dot (side' east);  	//log.buf.AppendLine("side.east = " + sidedoteast);  	double direction = Math.Acos (sidedoteast) * 180 / Math.PI;  	//log.buf.AppendLine("angle side:east = " + direction);  	double sidedotnorth = Vector3d.Dot (side' north);  	//log.buf.AppendLine("side.north = " + sidedotnorth);  	if (sidedotnorth < 0)  		direction = 360 - direction;  	result += " @ " + FormatNumber (direction' ""' 0);  }  
Magic Number,Engineer,Tools,F:\newReposMay17\CYBUTEK_Engineer\Engineer\Tools.cs,GetSlopeAngleAndHeading,The following statement contains a magic number: if (sidedotnorth < 0)  	direction = 360 - direction;  
Magic Number,Engineer,Tools,F:\newReposMay17\CYBUTEK_Engineer\Engineer\Tools.cs,GetSlopeAngleAndHeading,The following statement contains a magic number: direction = 360 - direction;  
Magic Number,Engineer,FlightEngineer,F:\newReposMay17\CYBUTEK_Engineer\Engineer\FlightEngineer.cs,Update,The following statement contains a magic number: if (vessel != null && vessel == FlightGlobals.ActiveVessel) {  	if (IsPrimary) {  		hasEngineer = true;  		// Update the simulation timing from the tweakable  		SimManager.minSimTime = (long)minFESimTime;  		// If the results are ready then read them and start the simulation again (will be delayed by minSimTime)  		if (SimManager.ResultsReady ()) {  			// Get the results into our members  			stages = SimManager.Stages;  			failMessage = SimManager.failMessage;  			SimManager.Gravity = vessel.mainBody.gravParameter / Math.Pow (vessel.mainBody.Radius + vessel.mainBody.GetAltitude (vessel.CoM)' 2);  			SimManager.Velocity = vessel.srfSpeed;  			SimManager.vectoredThrust = vectoredThrust;  			SimManager.TryStartSimulation ();  		}  	}  }  
Magic Number,Engineer,FlightEngineer,F:\newReposMay17\CYBUTEK_Engineer\Engineer\FlightEngineer.cs,Update,The following statement contains a magic number: if (IsPrimary) {  	hasEngineer = true;  	// Update the simulation timing from the tweakable  	SimManager.minSimTime = (long)minFESimTime;  	// If the results are ready then read them and start the simulation again (will be delayed by minSimTime)  	if (SimManager.ResultsReady ()) {  		// Get the results into our members  		stages = SimManager.Stages;  		failMessage = SimManager.failMessage;  		SimManager.Gravity = vessel.mainBody.gravParameter / Math.Pow (vessel.mainBody.Radius + vessel.mainBody.GetAltitude (vessel.CoM)' 2);  		SimManager.Velocity = vessel.srfSpeed;  		SimManager.vectoredThrust = vectoredThrust;  		SimManager.TryStartSimulation ();  	}  }  
Magic Number,Engineer,FlightEngineer,F:\newReposMay17\CYBUTEK_Engineer\Engineer\FlightEngineer.cs,Update,The following statement contains a magic number: if (SimManager.ResultsReady ()) {  	// Get the results into our members  	stages = SimManager.Stages;  	failMessage = SimManager.failMessage;  	SimManager.Gravity = vessel.mainBody.gravParameter / Math.Pow (vessel.mainBody.Radius + vessel.mainBody.GetAltitude (vessel.CoM)' 2);  	SimManager.Velocity = vessel.srfSpeed;  	SimManager.vectoredThrust = vectoredThrust;  	SimManager.TryStartSimulation ();  }  
Magic Number,Engineer,FlightEngineer,F:\newReposMay17\CYBUTEK_Engineer\Engineer\FlightEngineer.cs,Update,The following statement contains a magic number: SimManager.Gravity = vessel.mainBody.gravParameter / Math.Pow (vessel.mainBody.Radius + vessel.mainBody.GetAltitude (vessel.CoM)' 2);  
Magic Number,Engineer,FlightEngineer,F:\newReposMay17\CYBUTEK_Engineer\Engineer\FlightEngineer.cs,DrawOrbital,The following statement contains a magic number: if (settings.Get<bool> ("Orbital: Inclination"))  	GUILayout.Label (Tools.FormatNumber (vessel.orbit.inclination' ""' 6)' dataStyle);  
Magic Number,Engineer,FlightEngineer,F:\newReposMay17\CYBUTEK_Engineer\Engineer\FlightEngineer.cs,DrawOrbital,The following statement contains a magic number: GUILayout.Label (Tools.FormatNumber (vessel.orbit.inclination' ""' 6)' dataStyle);  
Magic Number,Engineer,FlightEngineer,F:\newReposMay17\CYBUTEK_Engineer\Engineer\FlightEngineer.cs,DrawOrbital,The following statement contains a magic number: if (settings.Get<bool> ("Orbital: Eccentricity"))  	GUILayout.Label (Tools.FormatNumber (vessel.orbit.eccentricity' 6)' dataStyle);  
Magic Number,Engineer,FlightEngineer,F:\newReposMay17\CYBUTEK_Engineer\Engineer\FlightEngineer.cs,DrawOrbital,The following statement contains a magic number: GUILayout.Label (Tools.FormatNumber (vessel.orbit.eccentricity' 6)' dataStyle);  
Magic Number,Engineer,FlightEngineer,F:\newReposMay17\CYBUTEK_Engineer\Engineer\FlightEngineer.cs,DrawOrbital,The following statement contains a magic number: if (settings.Get<bool> ("Orbital: Longitude of AN"))  	GUILayout.Label (Tools.FormatNumber (vessel.orbit.LAN' ""' 6)' dataStyle);  
Magic Number,Engineer,FlightEngineer,F:\newReposMay17\CYBUTEK_Engineer\Engineer\FlightEngineer.cs,DrawOrbital,The following statement contains a magic number: GUILayout.Label (Tools.FormatNumber (vessel.orbit.LAN' ""' 6)' dataStyle);  
Magic Number,Engineer,FlightEngineer,F:\newReposMay17\CYBUTEK_Engineer\Engineer\FlightEngineer.cs,DrawOrbital,The following statement contains a magic number: if (settings.Get<bool> ("Orbital: Longitude of Pe"))  	GUILayout.Label (Tools.FormatNumber (vessel.orbit.LAN + vessel.orbit.argumentOfPeriapsis' ""' 6)' dataStyle);  
Magic Number,Engineer,FlightEngineer,F:\newReposMay17\CYBUTEK_Engineer\Engineer\FlightEngineer.cs,DrawOrbital,The following statement contains a magic number: GUILayout.Label (Tools.FormatNumber (vessel.orbit.LAN + vessel.orbit.argumentOfPeriapsis' ""' 6)' dataStyle);  
Magic Number,Engineer,FlightEngineer,F:\newReposMay17\CYBUTEK_Engineer\Engineer\FlightEngineer.cs,normangle,The following statement contains a magic number: if (ang > 180) {  	ang -= 360 * Math.Ceiling ((ang - 180) / 360);  }  
Magic Number,Engineer,FlightEngineer,F:\newReposMay17\CYBUTEK_Engineer\Engineer\FlightEngineer.cs,normangle,The following statement contains a magic number: if (ang > 180) {  	ang -= 360 * Math.Ceiling ((ang - 180) / 360);  }  
Magic Number,Engineer,FlightEngineer,F:\newReposMay17\CYBUTEK_Engineer\Engineer\FlightEngineer.cs,normangle,The following statement contains a magic number: if (ang > 180) {  	ang -= 360 * Math.Ceiling ((ang - 180) / 360);  }  
Magic Number,Engineer,FlightEngineer,F:\newReposMay17\CYBUTEK_Engineer\Engineer\FlightEngineer.cs,normangle,The following statement contains a magic number: if (ang > 180) {  	ang -= 360 * Math.Ceiling ((ang - 180) / 360);  }  
Magic Number,Engineer,FlightEngineer,F:\newReposMay17\CYBUTEK_Engineer\Engineer\FlightEngineer.cs,normangle,The following statement contains a magic number: ang -= 360 * Math.Ceiling ((ang - 180) / 360);  
Magic Number,Engineer,FlightEngineer,F:\newReposMay17\CYBUTEK_Engineer\Engineer\FlightEngineer.cs,normangle,The following statement contains a magic number: ang -= 360 * Math.Ceiling ((ang - 180) / 360);  
Magic Number,Engineer,FlightEngineer,F:\newReposMay17\CYBUTEK_Engineer\Engineer\FlightEngineer.cs,normangle,The following statement contains a magic number: ang -= 360 * Math.Ceiling ((ang - 180) / 360);  
Magic Number,Engineer,FlightEngineer,F:\newReposMay17\CYBUTEK_Engineer\Engineer\FlightEngineer.cs,normangle,The following statement contains a magic number: if (ang <= -180) {  	ang -= 360 * Math.Floor ((ang + 180) / 360);  }  
Magic Number,Engineer,FlightEngineer,F:\newReposMay17\CYBUTEK_Engineer\Engineer\FlightEngineer.cs,normangle,The following statement contains a magic number: if (ang <= -180) {  	ang -= 360 * Math.Floor ((ang + 180) / 360);  }  
Magic Number,Engineer,FlightEngineer,F:\newReposMay17\CYBUTEK_Engineer\Engineer\FlightEngineer.cs,normangle,The following statement contains a magic number: if (ang <= -180) {  	ang -= 360 * Math.Floor ((ang + 180) / 360);  }  
Magic Number,Engineer,FlightEngineer,F:\newReposMay17\CYBUTEK_Engineer\Engineer\FlightEngineer.cs,normangle,The following statement contains a magic number: if (ang <= -180) {  	ang -= 360 * Math.Floor ((ang + 180) / 360);  }  
Magic Number,Engineer,FlightEngineer,F:\newReposMay17\CYBUTEK_Engineer\Engineer\FlightEngineer.cs,normangle,The following statement contains a magic number: ang -= 360 * Math.Floor ((ang + 180) / 360);  
Magic Number,Engineer,FlightEngineer,F:\newReposMay17\CYBUTEK_Engineer\Engineer\FlightEngineer.cs,normangle,The following statement contains a magic number: ang -= 360 * Math.Floor ((ang + 180) / 360);  
Magic Number,Engineer,FlightEngineer,F:\newReposMay17\CYBUTEK_Engineer\Engineer\FlightEngineer.cs,normangle,The following statement contains a magic number: ang -= 360 * Math.Floor ((ang + 180) / 360);  
Magic Number,Engineer,FlightEngineer,F:\newReposMay17\CYBUTEK_Engineer\Engineer\FlightEngineer.cs,radiusdirection,The following statement contains a magic number: theta = Math.PI * theta / 180;  
Magic Number,Engineer,FlightEngineer,F:\newReposMay17\CYBUTEK_Engineer\Engineer\FlightEngineer.cs,timetoperiapsis,The following statement contains a magic number: if (e == 1.0) {  	double D = Math.Tan (Math.PI * theta / 360.0);  	double M = D + D * D * D / 3.0;  	return (Math.Sqrt (2.0 * rp * rp * rp / mu) * M);  } else if (a > 0) {  	double cosTheta = Math.Cos (Math.PI * theta / 180.0);  	double cosE = (e + cosTheta) / (1.0 + e * cosTheta);  	double radE = Math.Acos (cosE);  	double M = radE - e * Math.Sin (radE);  	return (Math.Sqrt (a * a * a / mu) * M);  } else if (a < 0) {  	double cosTheta = Math.Cos (Math.PI * theta / 180.0);  	double coshF = (e + cosTheta) / (1.0 + e * cosTheta);  	double radF = ACosh (coshF);  	double M = e * Math.Sinh (radF) - radF;  	return (Math.Sqrt (-a * a * a / mu) * M);  }  
Magic Number,Engineer,FlightEngineer,F:\newReposMay17\CYBUTEK_Engineer\Engineer\FlightEngineer.cs,timetoperiapsis,The following statement contains a magic number: if (e == 1.0) {  	double D = Math.Tan (Math.PI * theta / 360.0);  	double M = D + D * D * D / 3.0;  	return (Math.Sqrt (2.0 * rp * rp * rp / mu) * M);  } else if (a > 0) {  	double cosTheta = Math.Cos (Math.PI * theta / 180.0);  	double cosE = (e + cosTheta) / (1.0 + e * cosTheta);  	double radE = Math.Acos (cosE);  	double M = radE - e * Math.Sin (radE);  	return (Math.Sqrt (a * a * a / mu) * M);  } else if (a < 0) {  	double cosTheta = Math.Cos (Math.PI * theta / 180.0);  	double coshF = (e + cosTheta) / (1.0 + e * cosTheta);  	double radF = ACosh (coshF);  	double M = e * Math.Sinh (radF) - radF;  	return (Math.Sqrt (-a * a * a / mu) * M);  }  
Magic Number,Engineer,FlightEngineer,F:\newReposMay17\CYBUTEK_Engineer\Engineer\FlightEngineer.cs,timetoperiapsis,The following statement contains a magic number: if (e == 1.0) {  	double D = Math.Tan (Math.PI * theta / 360.0);  	double M = D + D * D * D / 3.0;  	return (Math.Sqrt (2.0 * rp * rp * rp / mu) * M);  } else if (a > 0) {  	double cosTheta = Math.Cos (Math.PI * theta / 180.0);  	double cosE = (e + cosTheta) / (1.0 + e * cosTheta);  	double radE = Math.Acos (cosE);  	double M = radE - e * Math.Sin (radE);  	return (Math.Sqrt (a * a * a / mu) * M);  } else if (a < 0) {  	double cosTheta = Math.Cos (Math.PI * theta / 180.0);  	double coshF = (e + cosTheta) / (1.0 + e * cosTheta);  	double radF = ACosh (coshF);  	double M = e * Math.Sinh (radF) - radF;  	return (Math.Sqrt (-a * a * a / mu) * M);  }  
Magic Number,Engineer,FlightEngineer,F:\newReposMay17\CYBUTEK_Engineer\Engineer\FlightEngineer.cs,timetoperiapsis,The following statement contains a magic number: if (e == 1.0) {  	double D = Math.Tan (Math.PI * theta / 360.0);  	double M = D + D * D * D / 3.0;  	return (Math.Sqrt (2.0 * rp * rp * rp / mu) * M);  } else if (a > 0) {  	double cosTheta = Math.Cos (Math.PI * theta / 180.0);  	double cosE = (e + cosTheta) / (1.0 + e * cosTheta);  	double radE = Math.Acos (cosE);  	double M = radE - e * Math.Sin (radE);  	return (Math.Sqrt (a * a * a / mu) * M);  } else if (a < 0) {  	double cosTheta = Math.Cos (Math.PI * theta / 180.0);  	double coshF = (e + cosTheta) / (1.0 + e * cosTheta);  	double radF = ACosh (coshF);  	double M = e * Math.Sinh (radF) - radF;  	return (Math.Sqrt (-a * a * a / mu) * M);  }  
Magic Number,Engineer,FlightEngineer,F:\newReposMay17\CYBUTEK_Engineer\Engineer\FlightEngineer.cs,timetoperiapsis,The following statement contains a magic number: if (e == 1.0) {  	double D = Math.Tan (Math.PI * theta / 360.0);  	double M = D + D * D * D / 3.0;  	return (Math.Sqrt (2.0 * rp * rp * rp / mu) * M);  } else if (a > 0) {  	double cosTheta = Math.Cos (Math.PI * theta / 180.0);  	double cosE = (e + cosTheta) / (1.0 + e * cosTheta);  	double radE = Math.Acos (cosE);  	double M = radE - e * Math.Sin (radE);  	return (Math.Sqrt (a * a * a / mu) * M);  } else if (a < 0) {  	double cosTheta = Math.Cos (Math.PI * theta / 180.0);  	double coshF = (e + cosTheta) / (1.0 + e * cosTheta);  	double radF = ACosh (coshF);  	double M = e * Math.Sinh (radF) - radF;  	return (Math.Sqrt (-a * a * a / mu) * M);  }  
Magic Number,Engineer,FlightEngineer,F:\newReposMay17\CYBUTEK_Engineer\Engineer\FlightEngineer.cs,timetoperiapsis,The following statement contains a magic number: return (Math.Sqrt (2.0 * rp * rp * rp / mu) * M);  
Magic Number,Engineer,FlightEngineer,F:\newReposMay17\CYBUTEK_Engineer\Engineer\FlightEngineer.cs,timetoperiapsis,The following statement contains a magic number: if (a > 0) {  	double cosTheta = Math.Cos (Math.PI * theta / 180.0);  	double cosE = (e + cosTheta) / (1.0 + e * cosTheta);  	double radE = Math.Acos (cosE);  	double M = radE - e * Math.Sin (radE);  	return (Math.Sqrt (a * a * a / mu) * M);  } else if (a < 0) {  	double cosTheta = Math.Cos (Math.PI * theta / 180.0);  	double coshF = (e + cosTheta) / (1.0 + e * cosTheta);  	double radF = ACosh (coshF);  	double M = e * Math.Sinh (radF) - radF;  	return (Math.Sqrt (-a * a * a / mu) * M);  }  
Magic Number,Engineer,FlightEngineer,F:\newReposMay17\CYBUTEK_Engineer\Engineer\FlightEngineer.cs,timetoperiapsis,The following statement contains a magic number: if (a > 0) {  	double cosTheta = Math.Cos (Math.PI * theta / 180.0);  	double cosE = (e + cosTheta) / (1.0 + e * cosTheta);  	double radE = Math.Acos (cosE);  	double M = radE - e * Math.Sin (radE);  	return (Math.Sqrt (a * a * a / mu) * M);  } else if (a < 0) {  	double cosTheta = Math.Cos (Math.PI * theta / 180.0);  	double coshF = (e + cosTheta) / (1.0 + e * cosTheta);  	double radF = ACosh (coshF);  	double M = e * Math.Sinh (radF) - radF;  	return (Math.Sqrt (-a * a * a / mu) * M);  }  
Magic Number,Engineer,FlightEngineer,F:\newReposMay17\CYBUTEK_Engineer\Engineer\FlightEngineer.cs,timetoperiapsis,The following statement contains a magic number: if (a < 0) {  	double cosTheta = Math.Cos (Math.PI * theta / 180.0);  	double coshF = (e + cosTheta) / (1.0 + e * cosTheta);  	double radF = ACosh (coshF);  	double M = e * Math.Sinh (radF) - radF;  	return (Math.Sqrt (-a * a * a / mu) * M);  }  
Magic Number,Engineer,FlightEngineer,F:\newReposMay17\CYBUTEK_Engineer\Engineer\FlightEngineer.cs,DrawSurface,The following statement contains a magic number: if (FlightGlobals.ActiveVessel.mainBody.pqsController != null) {  	//do impact site calculations  	impacthappening = true;  	double e = vessel.orbit.eccentricity;  	//get current position direction vector  	Vector3d currentpos = radiusdirection (vessel.orbit.trueAnomaly);  	//calculate longitude in inertial reference frame from that  	double currentirflong = 180 * Math.Atan2 (currentpos.x' currentpos.y) / Math.PI;  	//experimentally determined; even for very flat trajectories' the errors go into the sub-millimeter area after 5 iterations or so  	const int impactiterations = 6;  	//do a few iterations of impact site calculations  	for (int i = 0; i < impactiterations; i++) {  		if (vessel.orbit.PeA >= impactalt) {  			//periapsis must be lower than impact alt  			impacthappening = false;  		}  		if ((vessel.orbit.eccentricity < 1) && (vessel.orbit.ApA <= impactalt)) {  			//apoapsis must be higher than impact alt  			impacthappening = false;  		}  		if ((vessel.orbit.eccentricity >= 1) && (vessel.orbit.timeToPe <= 0)) {  			//if currently escaping' we still need to be before periapsis  			impacthappening = false;  		}  		if (!impacthappening) {  			impacttime = 0;  			impactlong = 0;  			impactlat = 0;  			impactalt = 0;  			break;  		}  		double impacttheta = 0;  		if (e > 0) {  			//in this step' we are using the calculated impact altitude of the last step' to refine the impact site position  			impacttheta = -180 * Math.Acos ((vessel.orbit.PeR * (1 + e) / (vessel.mainBody.Radius + impactalt) - 1) / e) / Math.PI;  		}  		//calculate time to impact  		impacttime = vessel.orbit.timeToPe - timetoperiapsis (impacttheta);  		//calculate position vector of impact site  		Vector3d impactpos = radiusdirection (impacttheta);  		//calculate longitude of impact site in inertial reference frame  		double impactirflong = 180 * Math.Atan2 (impactpos.x' impactpos.y) / Math.PI;  		double deltairflong = impactirflong - currentirflong;  		//get body rotation until impact  		double bodyrot = 360 * impacttime / vessel.mainBody.rotationPeriod;  		//get current longitude in body coordinates  		double currentlong = vessel.longitude;  		//finally' calculate the impact longitude in body coordinates  		impactlong = normangle (currentlong - deltairflong - bodyrot);  		//calculate impact latitude from impact position  		impactlat = 180 * Math.Asin (impactpos.z / impactpos.magnitude) / Math.PI;  		//calculate the actual altitude of the impact site  		//altitude for long/lat code stolen from some ISA MapSat forum post; who knows why this works' but it seems to.  		Vector3d rad = QuaternionD.AngleAxis (impactlong' Vector3d.down) * QuaternionD.AngleAxis (impactlat' Vector3d.forward) * Vector3d.right;  		impactalt = vessel.mainBody.pqsController.GetSurfaceHeight (rad) - vessel.mainBody.pqsController.radius;  		if ((impactalt < 0) && (vessel.mainBody.ocean == true)) {  			impactalt = 0;  		}  		if (impacthappening)  			impactbiome = ScienceUtil.GetExperimentBiome (vessel.mainBody' impactlat' impactlong);  	}  	if (impacthappening)  		impactbiome = ScienceUtil.GetExperimentBiome (vessel.mainBody' impactlat' impactlong);  }  
Magic Number,Engineer,FlightEngineer,F:\newReposMay17\CYBUTEK_Engineer\Engineer\FlightEngineer.cs,DrawSurface,The following statement contains a magic number: if (FlightGlobals.ActiveVessel.mainBody.pqsController != null) {  	//do impact site calculations  	impacthappening = true;  	double e = vessel.orbit.eccentricity;  	//get current position direction vector  	Vector3d currentpos = radiusdirection (vessel.orbit.trueAnomaly);  	//calculate longitude in inertial reference frame from that  	double currentirflong = 180 * Math.Atan2 (currentpos.x' currentpos.y) / Math.PI;  	//experimentally determined; even for very flat trajectories' the errors go into the sub-millimeter area after 5 iterations or so  	const int impactiterations = 6;  	//do a few iterations of impact site calculations  	for (int i = 0; i < impactiterations; i++) {  		if (vessel.orbit.PeA >= impactalt) {  			//periapsis must be lower than impact alt  			impacthappening = false;  		}  		if ((vessel.orbit.eccentricity < 1) && (vessel.orbit.ApA <= impactalt)) {  			//apoapsis must be higher than impact alt  			impacthappening = false;  		}  		if ((vessel.orbit.eccentricity >= 1) && (vessel.orbit.timeToPe <= 0)) {  			//if currently escaping' we still need to be before periapsis  			impacthappening = false;  		}  		if (!impacthappening) {  			impacttime = 0;  			impactlong = 0;  			impactlat = 0;  			impactalt = 0;  			break;  		}  		double impacttheta = 0;  		if (e > 0) {  			//in this step' we are using the calculated impact altitude of the last step' to refine the impact site position  			impacttheta = -180 * Math.Acos ((vessel.orbit.PeR * (1 + e) / (vessel.mainBody.Radius + impactalt) - 1) / e) / Math.PI;  		}  		//calculate time to impact  		impacttime = vessel.orbit.timeToPe - timetoperiapsis (impacttheta);  		//calculate position vector of impact site  		Vector3d impactpos = radiusdirection (impacttheta);  		//calculate longitude of impact site in inertial reference frame  		double impactirflong = 180 * Math.Atan2 (impactpos.x' impactpos.y) / Math.PI;  		double deltairflong = impactirflong - currentirflong;  		//get body rotation until impact  		double bodyrot = 360 * impacttime / vessel.mainBody.rotationPeriod;  		//get current longitude in body coordinates  		double currentlong = vessel.longitude;  		//finally' calculate the impact longitude in body coordinates  		impactlong = normangle (currentlong - deltairflong - bodyrot);  		//calculate impact latitude from impact position  		impactlat = 180 * Math.Asin (impactpos.z / impactpos.magnitude) / Math.PI;  		//calculate the actual altitude of the impact site  		//altitude for long/lat code stolen from some ISA MapSat forum post; who knows why this works' but it seems to.  		Vector3d rad = QuaternionD.AngleAxis (impactlong' Vector3d.down) * QuaternionD.AngleAxis (impactlat' Vector3d.forward) * Vector3d.right;  		impactalt = vessel.mainBody.pqsController.GetSurfaceHeight (rad) - vessel.mainBody.pqsController.radius;  		if ((impactalt < 0) && (vessel.mainBody.ocean == true)) {  			impactalt = 0;  		}  		if (impacthappening)  			impactbiome = ScienceUtil.GetExperimentBiome (vessel.mainBody' impactlat' impactlong);  	}  	if (impacthappening)  		impactbiome = ScienceUtil.GetExperimentBiome (vessel.mainBody' impactlat' impactlong);  }  
Magic Number,Engineer,FlightEngineer,F:\newReposMay17\CYBUTEK_Engineer\Engineer\FlightEngineer.cs,DrawSurface,The following statement contains a magic number: if (FlightGlobals.ActiveVessel.mainBody.pqsController != null) {  	//do impact site calculations  	impacthappening = true;  	double e = vessel.orbit.eccentricity;  	//get current position direction vector  	Vector3d currentpos = radiusdirection (vessel.orbit.trueAnomaly);  	//calculate longitude in inertial reference frame from that  	double currentirflong = 180 * Math.Atan2 (currentpos.x' currentpos.y) / Math.PI;  	//experimentally determined; even for very flat trajectories' the errors go into the sub-millimeter area after 5 iterations or so  	const int impactiterations = 6;  	//do a few iterations of impact site calculations  	for (int i = 0; i < impactiterations; i++) {  		if (vessel.orbit.PeA >= impactalt) {  			//periapsis must be lower than impact alt  			impacthappening = false;  		}  		if ((vessel.orbit.eccentricity < 1) && (vessel.orbit.ApA <= impactalt)) {  			//apoapsis must be higher than impact alt  			impacthappening = false;  		}  		if ((vessel.orbit.eccentricity >= 1) && (vessel.orbit.timeToPe <= 0)) {  			//if currently escaping' we still need to be before periapsis  			impacthappening = false;  		}  		if (!impacthappening) {  			impacttime = 0;  			impactlong = 0;  			impactlat = 0;  			impactalt = 0;  			break;  		}  		double impacttheta = 0;  		if (e > 0) {  			//in this step' we are using the calculated impact altitude of the last step' to refine the impact site position  			impacttheta = -180 * Math.Acos ((vessel.orbit.PeR * (1 + e) / (vessel.mainBody.Radius + impactalt) - 1) / e) / Math.PI;  		}  		//calculate time to impact  		impacttime = vessel.orbit.timeToPe - timetoperiapsis (impacttheta);  		//calculate position vector of impact site  		Vector3d impactpos = radiusdirection (impacttheta);  		//calculate longitude of impact site in inertial reference frame  		double impactirflong = 180 * Math.Atan2 (impactpos.x' impactpos.y) / Math.PI;  		double deltairflong = impactirflong - currentirflong;  		//get body rotation until impact  		double bodyrot = 360 * impacttime / vessel.mainBody.rotationPeriod;  		//get current longitude in body coordinates  		double currentlong = vessel.longitude;  		//finally' calculate the impact longitude in body coordinates  		impactlong = normangle (currentlong - deltairflong - bodyrot);  		//calculate impact latitude from impact position  		impactlat = 180 * Math.Asin (impactpos.z / impactpos.magnitude) / Math.PI;  		//calculate the actual altitude of the impact site  		//altitude for long/lat code stolen from some ISA MapSat forum post; who knows why this works' but it seems to.  		Vector3d rad = QuaternionD.AngleAxis (impactlong' Vector3d.down) * QuaternionD.AngleAxis (impactlat' Vector3d.forward) * Vector3d.right;  		impactalt = vessel.mainBody.pqsController.GetSurfaceHeight (rad) - vessel.mainBody.pqsController.radius;  		if ((impactalt < 0) && (vessel.mainBody.ocean == true)) {  			impactalt = 0;  		}  		if (impacthappening)  			impactbiome = ScienceUtil.GetExperimentBiome (vessel.mainBody' impactlat' impactlong);  	}  	if (impacthappening)  		impactbiome = ScienceUtil.GetExperimentBiome (vessel.mainBody' impactlat' impactlong);  }  
Magic Number,Engineer,FlightEngineer,F:\newReposMay17\CYBUTEK_Engineer\Engineer\FlightEngineer.cs,DrawSurface,The following statement contains a magic number: if (FlightGlobals.ActiveVessel.mainBody.pqsController != null) {  	//do impact site calculations  	impacthappening = true;  	double e = vessel.orbit.eccentricity;  	//get current position direction vector  	Vector3d currentpos = radiusdirection (vessel.orbit.trueAnomaly);  	//calculate longitude in inertial reference frame from that  	double currentirflong = 180 * Math.Atan2 (currentpos.x' currentpos.y) / Math.PI;  	//experimentally determined; even for very flat trajectories' the errors go into the sub-millimeter area after 5 iterations or so  	const int impactiterations = 6;  	//do a few iterations of impact site calculations  	for (int i = 0; i < impactiterations; i++) {  		if (vessel.orbit.PeA >= impactalt) {  			//periapsis must be lower than impact alt  			impacthappening = false;  		}  		if ((vessel.orbit.eccentricity < 1) && (vessel.orbit.ApA <= impactalt)) {  			//apoapsis must be higher than impact alt  			impacthappening = false;  		}  		if ((vessel.orbit.eccentricity >= 1) && (vessel.orbit.timeToPe <= 0)) {  			//if currently escaping' we still need to be before periapsis  			impacthappening = false;  		}  		if (!impacthappening) {  			impacttime = 0;  			impactlong = 0;  			impactlat = 0;  			impactalt = 0;  			break;  		}  		double impacttheta = 0;  		if (e > 0) {  			//in this step' we are using the calculated impact altitude of the last step' to refine the impact site position  			impacttheta = -180 * Math.Acos ((vessel.orbit.PeR * (1 + e) / (vessel.mainBody.Radius + impactalt) - 1) / e) / Math.PI;  		}  		//calculate time to impact  		impacttime = vessel.orbit.timeToPe - timetoperiapsis (impacttheta);  		//calculate position vector of impact site  		Vector3d impactpos = radiusdirection (impacttheta);  		//calculate longitude of impact site in inertial reference frame  		double impactirflong = 180 * Math.Atan2 (impactpos.x' impactpos.y) / Math.PI;  		double deltairflong = impactirflong - currentirflong;  		//get body rotation until impact  		double bodyrot = 360 * impacttime / vessel.mainBody.rotationPeriod;  		//get current longitude in body coordinates  		double currentlong = vessel.longitude;  		//finally' calculate the impact longitude in body coordinates  		impactlong = normangle (currentlong - deltairflong - bodyrot);  		//calculate impact latitude from impact position  		impactlat = 180 * Math.Asin (impactpos.z / impactpos.magnitude) / Math.PI;  		//calculate the actual altitude of the impact site  		//altitude for long/lat code stolen from some ISA MapSat forum post; who knows why this works' but it seems to.  		Vector3d rad = QuaternionD.AngleAxis (impactlong' Vector3d.down) * QuaternionD.AngleAxis (impactlat' Vector3d.forward) * Vector3d.right;  		impactalt = vessel.mainBody.pqsController.GetSurfaceHeight (rad) - vessel.mainBody.pqsController.radius;  		if ((impactalt < 0) && (vessel.mainBody.ocean == true)) {  			impactalt = 0;  		}  		if (impacthappening)  			impactbiome = ScienceUtil.GetExperimentBiome (vessel.mainBody' impactlat' impactlong);  	}  	if (impacthappening)  		impactbiome = ScienceUtil.GetExperimentBiome (vessel.mainBody' impactlat' impactlong);  }  
Magic Number,Engineer,FlightEngineer,F:\newReposMay17\CYBUTEK_Engineer\Engineer\FlightEngineer.cs,DrawSurface,The following statement contains a magic number: if (FlightGlobals.ActiveVessel.mainBody.pqsController != null) {  	//do impact site calculations  	impacthappening = true;  	double e = vessel.orbit.eccentricity;  	//get current position direction vector  	Vector3d currentpos = radiusdirection (vessel.orbit.trueAnomaly);  	//calculate longitude in inertial reference frame from that  	double currentirflong = 180 * Math.Atan2 (currentpos.x' currentpos.y) / Math.PI;  	//experimentally determined; even for very flat trajectories' the errors go into the sub-millimeter area after 5 iterations or so  	const int impactiterations = 6;  	//do a few iterations of impact site calculations  	for (int i = 0; i < impactiterations; i++) {  		if (vessel.orbit.PeA >= impactalt) {  			//periapsis must be lower than impact alt  			impacthappening = false;  		}  		if ((vessel.orbit.eccentricity < 1) && (vessel.orbit.ApA <= impactalt)) {  			//apoapsis must be higher than impact alt  			impacthappening = false;  		}  		if ((vessel.orbit.eccentricity >= 1) && (vessel.orbit.timeToPe <= 0)) {  			//if currently escaping' we still need to be before periapsis  			impacthappening = false;  		}  		if (!impacthappening) {  			impacttime = 0;  			impactlong = 0;  			impactlat = 0;  			impactalt = 0;  			break;  		}  		double impacttheta = 0;  		if (e > 0) {  			//in this step' we are using the calculated impact altitude of the last step' to refine the impact site position  			impacttheta = -180 * Math.Acos ((vessel.orbit.PeR * (1 + e) / (vessel.mainBody.Radius + impactalt) - 1) / e) / Math.PI;  		}  		//calculate time to impact  		impacttime = vessel.orbit.timeToPe - timetoperiapsis (impacttheta);  		//calculate position vector of impact site  		Vector3d impactpos = radiusdirection (impacttheta);  		//calculate longitude of impact site in inertial reference frame  		double impactirflong = 180 * Math.Atan2 (impactpos.x' impactpos.y) / Math.PI;  		double deltairflong = impactirflong - currentirflong;  		//get body rotation until impact  		double bodyrot = 360 * impacttime / vessel.mainBody.rotationPeriod;  		//get current longitude in body coordinates  		double currentlong = vessel.longitude;  		//finally' calculate the impact longitude in body coordinates  		impactlong = normangle (currentlong - deltairflong - bodyrot);  		//calculate impact latitude from impact position  		impactlat = 180 * Math.Asin (impactpos.z / impactpos.magnitude) / Math.PI;  		//calculate the actual altitude of the impact site  		//altitude for long/lat code stolen from some ISA MapSat forum post; who knows why this works' but it seems to.  		Vector3d rad = QuaternionD.AngleAxis (impactlong' Vector3d.down) * QuaternionD.AngleAxis (impactlat' Vector3d.forward) * Vector3d.right;  		impactalt = vessel.mainBody.pqsController.GetSurfaceHeight (rad) - vessel.mainBody.pqsController.radius;  		if ((impactalt < 0) && (vessel.mainBody.ocean == true)) {  			impactalt = 0;  		}  		if (impacthappening)  			impactbiome = ScienceUtil.GetExperimentBiome (vessel.mainBody' impactlat' impactlong);  	}  	if (impacthappening)  		impactbiome = ScienceUtil.GetExperimentBiome (vessel.mainBody' impactlat' impactlong);  }  
Magic Number,Engineer,FlightEngineer,F:\newReposMay17\CYBUTEK_Engineer\Engineer\FlightEngineer.cs,DrawSurface,The following statement contains a magic number: if (FlightGlobals.ActiveVessel.mainBody.pqsController != null) {  	//do impact site calculations  	impacthappening = true;  	double e = vessel.orbit.eccentricity;  	//get current position direction vector  	Vector3d currentpos = radiusdirection (vessel.orbit.trueAnomaly);  	//calculate longitude in inertial reference frame from that  	double currentirflong = 180 * Math.Atan2 (currentpos.x' currentpos.y) / Math.PI;  	//experimentally determined; even for very flat trajectories' the errors go into the sub-millimeter area after 5 iterations or so  	const int impactiterations = 6;  	//do a few iterations of impact site calculations  	for (int i = 0; i < impactiterations; i++) {  		if (vessel.orbit.PeA >= impactalt) {  			//periapsis must be lower than impact alt  			impacthappening = false;  		}  		if ((vessel.orbit.eccentricity < 1) && (vessel.orbit.ApA <= impactalt)) {  			//apoapsis must be higher than impact alt  			impacthappening = false;  		}  		if ((vessel.orbit.eccentricity >= 1) && (vessel.orbit.timeToPe <= 0)) {  			//if currently escaping' we still need to be before periapsis  			impacthappening = false;  		}  		if (!impacthappening) {  			impacttime = 0;  			impactlong = 0;  			impactlat = 0;  			impactalt = 0;  			break;  		}  		double impacttheta = 0;  		if (e > 0) {  			//in this step' we are using the calculated impact altitude of the last step' to refine the impact site position  			impacttheta = -180 * Math.Acos ((vessel.orbit.PeR * (1 + e) / (vessel.mainBody.Radius + impactalt) - 1) / e) / Math.PI;  		}  		//calculate time to impact  		impacttime = vessel.orbit.timeToPe - timetoperiapsis (impacttheta);  		//calculate position vector of impact site  		Vector3d impactpos = radiusdirection (impacttheta);  		//calculate longitude of impact site in inertial reference frame  		double impactirflong = 180 * Math.Atan2 (impactpos.x' impactpos.y) / Math.PI;  		double deltairflong = impactirflong - currentirflong;  		//get body rotation until impact  		double bodyrot = 360 * impacttime / vessel.mainBody.rotationPeriod;  		//get current longitude in body coordinates  		double currentlong = vessel.longitude;  		//finally' calculate the impact longitude in body coordinates  		impactlong = normangle (currentlong - deltairflong - bodyrot);  		//calculate impact latitude from impact position  		impactlat = 180 * Math.Asin (impactpos.z / impactpos.magnitude) / Math.PI;  		//calculate the actual altitude of the impact site  		//altitude for long/lat code stolen from some ISA MapSat forum post; who knows why this works' but it seems to.  		Vector3d rad = QuaternionD.AngleAxis (impactlong' Vector3d.down) * QuaternionD.AngleAxis (impactlat' Vector3d.forward) * Vector3d.right;  		impactalt = vessel.mainBody.pqsController.GetSurfaceHeight (rad) - vessel.mainBody.pqsController.radius;  		if ((impactalt < 0) && (vessel.mainBody.ocean == true)) {  			impactalt = 0;  		}  		if (impacthappening)  			impactbiome = ScienceUtil.GetExperimentBiome (vessel.mainBody' impactlat' impactlong);  	}  	if (impacthappening)  		impactbiome = ScienceUtil.GetExperimentBiome (vessel.mainBody' impactlat' impactlong);  }  
Magic Number,Engineer,FlightEngineer,F:\newReposMay17\CYBUTEK_Engineer\Engineer\FlightEngineer.cs,DrawSurface,The following statement contains a magic number: for (int i = 0; i < impactiterations; i++) {  	if (vessel.orbit.PeA >= impactalt) {  		//periapsis must be lower than impact alt  		impacthappening = false;  	}  	if ((vessel.orbit.eccentricity < 1) && (vessel.orbit.ApA <= impactalt)) {  		//apoapsis must be higher than impact alt  		impacthappening = false;  	}  	if ((vessel.orbit.eccentricity >= 1) && (vessel.orbit.timeToPe <= 0)) {  		//if currently escaping' we still need to be before periapsis  		impacthappening = false;  	}  	if (!impacthappening) {  		impacttime = 0;  		impactlong = 0;  		impactlat = 0;  		impactalt = 0;  		break;  	}  	double impacttheta = 0;  	if (e > 0) {  		//in this step' we are using the calculated impact altitude of the last step' to refine the impact site position  		impacttheta = -180 * Math.Acos ((vessel.orbit.PeR * (1 + e) / (vessel.mainBody.Radius + impactalt) - 1) / e) / Math.PI;  	}  	//calculate time to impact  	impacttime = vessel.orbit.timeToPe - timetoperiapsis (impacttheta);  	//calculate position vector of impact site  	Vector3d impactpos = radiusdirection (impacttheta);  	//calculate longitude of impact site in inertial reference frame  	double impactirflong = 180 * Math.Atan2 (impactpos.x' impactpos.y) / Math.PI;  	double deltairflong = impactirflong - currentirflong;  	//get body rotation until impact  	double bodyrot = 360 * impacttime / vessel.mainBody.rotationPeriod;  	//get current longitude in body coordinates  	double currentlong = vessel.longitude;  	//finally' calculate the impact longitude in body coordinates  	impactlong = normangle (currentlong - deltairflong - bodyrot);  	//calculate impact latitude from impact position  	impactlat = 180 * Math.Asin (impactpos.z / impactpos.magnitude) / Math.PI;  	//calculate the actual altitude of the impact site  	//altitude for long/lat code stolen from some ISA MapSat forum post; who knows why this works' but it seems to.  	Vector3d rad = QuaternionD.AngleAxis (impactlong' Vector3d.down) * QuaternionD.AngleAxis (impactlat' Vector3d.forward) * Vector3d.right;  	impactalt = vessel.mainBody.pqsController.GetSurfaceHeight (rad) - vessel.mainBody.pqsController.radius;  	if ((impactalt < 0) && (vessel.mainBody.ocean == true)) {  		impactalt = 0;  	}  	if (impacthappening)  		impactbiome = ScienceUtil.GetExperimentBiome (vessel.mainBody' impactlat' impactlong);  }  
Magic Number,Engineer,FlightEngineer,F:\newReposMay17\CYBUTEK_Engineer\Engineer\FlightEngineer.cs,DrawSurface,The following statement contains a magic number: for (int i = 0; i < impactiterations; i++) {  	if (vessel.orbit.PeA >= impactalt) {  		//periapsis must be lower than impact alt  		impacthappening = false;  	}  	if ((vessel.orbit.eccentricity < 1) && (vessel.orbit.ApA <= impactalt)) {  		//apoapsis must be higher than impact alt  		impacthappening = false;  	}  	if ((vessel.orbit.eccentricity >= 1) && (vessel.orbit.timeToPe <= 0)) {  		//if currently escaping' we still need to be before periapsis  		impacthappening = false;  	}  	if (!impacthappening) {  		impacttime = 0;  		impactlong = 0;  		impactlat = 0;  		impactalt = 0;  		break;  	}  	double impacttheta = 0;  	if (e > 0) {  		//in this step' we are using the calculated impact altitude of the last step' to refine the impact site position  		impacttheta = -180 * Math.Acos ((vessel.orbit.PeR * (1 + e) / (vessel.mainBody.Radius + impactalt) - 1) / e) / Math.PI;  	}  	//calculate time to impact  	impacttime = vessel.orbit.timeToPe - timetoperiapsis (impacttheta);  	//calculate position vector of impact site  	Vector3d impactpos = radiusdirection (impacttheta);  	//calculate longitude of impact site in inertial reference frame  	double impactirflong = 180 * Math.Atan2 (impactpos.x' impactpos.y) / Math.PI;  	double deltairflong = impactirflong - currentirflong;  	//get body rotation until impact  	double bodyrot = 360 * impacttime / vessel.mainBody.rotationPeriod;  	//get current longitude in body coordinates  	double currentlong = vessel.longitude;  	//finally' calculate the impact longitude in body coordinates  	impactlong = normangle (currentlong - deltairflong - bodyrot);  	//calculate impact latitude from impact position  	impactlat = 180 * Math.Asin (impactpos.z / impactpos.magnitude) / Math.PI;  	//calculate the actual altitude of the impact site  	//altitude for long/lat code stolen from some ISA MapSat forum post; who knows why this works' but it seems to.  	Vector3d rad = QuaternionD.AngleAxis (impactlong' Vector3d.down) * QuaternionD.AngleAxis (impactlat' Vector3d.forward) * Vector3d.right;  	impactalt = vessel.mainBody.pqsController.GetSurfaceHeight (rad) - vessel.mainBody.pqsController.radius;  	if ((impactalt < 0) && (vessel.mainBody.ocean == true)) {  		impactalt = 0;  	}  	if (impacthappening)  		impactbiome = ScienceUtil.GetExperimentBiome (vessel.mainBody' impactlat' impactlong);  }  
Magic Number,Engineer,FlightEngineer,F:\newReposMay17\CYBUTEK_Engineer\Engineer\FlightEngineer.cs,DrawSurface,The following statement contains a magic number: for (int i = 0; i < impactiterations; i++) {  	if (vessel.orbit.PeA >= impactalt) {  		//periapsis must be lower than impact alt  		impacthappening = false;  	}  	if ((vessel.orbit.eccentricity < 1) && (vessel.orbit.ApA <= impactalt)) {  		//apoapsis must be higher than impact alt  		impacthappening = false;  	}  	if ((vessel.orbit.eccentricity >= 1) && (vessel.orbit.timeToPe <= 0)) {  		//if currently escaping' we still need to be before periapsis  		impacthappening = false;  	}  	if (!impacthappening) {  		impacttime = 0;  		impactlong = 0;  		impactlat = 0;  		impactalt = 0;  		break;  	}  	double impacttheta = 0;  	if (e > 0) {  		//in this step' we are using the calculated impact altitude of the last step' to refine the impact site position  		impacttheta = -180 * Math.Acos ((vessel.orbit.PeR * (1 + e) / (vessel.mainBody.Radius + impactalt) - 1) / e) / Math.PI;  	}  	//calculate time to impact  	impacttime = vessel.orbit.timeToPe - timetoperiapsis (impacttheta);  	//calculate position vector of impact site  	Vector3d impactpos = radiusdirection (impacttheta);  	//calculate longitude of impact site in inertial reference frame  	double impactirflong = 180 * Math.Atan2 (impactpos.x' impactpos.y) / Math.PI;  	double deltairflong = impactirflong - currentirflong;  	//get body rotation until impact  	double bodyrot = 360 * impacttime / vessel.mainBody.rotationPeriod;  	//get current longitude in body coordinates  	double currentlong = vessel.longitude;  	//finally' calculate the impact longitude in body coordinates  	impactlong = normangle (currentlong - deltairflong - bodyrot);  	//calculate impact latitude from impact position  	impactlat = 180 * Math.Asin (impactpos.z / impactpos.magnitude) / Math.PI;  	//calculate the actual altitude of the impact site  	//altitude for long/lat code stolen from some ISA MapSat forum post; who knows why this works' but it seems to.  	Vector3d rad = QuaternionD.AngleAxis (impactlong' Vector3d.down) * QuaternionD.AngleAxis (impactlat' Vector3d.forward) * Vector3d.right;  	impactalt = vessel.mainBody.pqsController.GetSurfaceHeight (rad) - vessel.mainBody.pqsController.radius;  	if ((impactalt < 0) && (vessel.mainBody.ocean == true)) {  		impactalt = 0;  	}  	if (impacthappening)  		impactbiome = ScienceUtil.GetExperimentBiome (vessel.mainBody' impactlat' impactlong);  }  
Magic Number,Engineer,FlightEngineer,F:\newReposMay17\CYBUTEK_Engineer\Engineer\FlightEngineer.cs,DrawSurface,The following statement contains a magic number: for (int i = 0; i < impactiterations; i++) {  	if (vessel.orbit.PeA >= impactalt) {  		//periapsis must be lower than impact alt  		impacthappening = false;  	}  	if ((vessel.orbit.eccentricity < 1) && (vessel.orbit.ApA <= impactalt)) {  		//apoapsis must be higher than impact alt  		impacthappening = false;  	}  	if ((vessel.orbit.eccentricity >= 1) && (vessel.orbit.timeToPe <= 0)) {  		//if currently escaping' we still need to be before periapsis  		impacthappening = false;  	}  	if (!impacthappening) {  		impacttime = 0;  		impactlong = 0;  		impactlat = 0;  		impactalt = 0;  		break;  	}  	double impacttheta = 0;  	if (e > 0) {  		//in this step' we are using the calculated impact altitude of the last step' to refine the impact site position  		impacttheta = -180 * Math.Acos ((vessel.orbit.PeR * (1 + e) / (vessel.mainBody.Radius + impactalt) - 1) / e) / Math.PI;  	}  	//calculate time to impact  	impacttime = vessel.orbit.timeToPe - timetoperiapsis (impacttheta);  	//calculate position vector of impact site  	Vector3d impactpos = radiusdirection (impacttheta);  	//calculate longitude of impact site in inertial reference frame  	double impactirflong = 180 * Math.Atan2 (impactpos.x' impactpos.y) / Math.PI;  	double deltairflong = impactirflong - currentirflong;  	//get body rotation until impact  	double bodyrot = 360 * impacttime / vessel.mainBody.rotationPeriod;  	//get current longitude in body coordinates  	double currentlong = vessel.longitude;  	//finally' calculate the impact longitude in body coordinates  	impactlong = normangle (currentlong - deltairflong - bodyrot);  	//calculate impact latitude from impact position  	impactlat = 180 * Math.Asin (impactpos.z / impactpos.magnitude) / Math.PI;  	//calculate the actual altitude of the impact site  	//altitude for long/lat code stolen from some ISA MapSat forum post; who knows why this works' but it seems to.  	Vector3d rad = QuaternionD.AngleAxis (impactlong' Vector3d.down) * QuaternionD.AngleAxis (impactlat' Vector3d.forward) * Vector3d.right;  	impactalt = vessel.mainBody.pqsController.GetSurfaceHeight (rad) - vessel.mainBody.pqsController.radius;  	if ((impactalt < 0) && (vessel.mainBody.ocean == true)) {  		impactalt = 0;  	}  	if (impacthappening)  		impactbiome = ScienceUtil.GetExperimentBiome (vessel.mainBody' impactlat' impactlong);  }  
Magic Number,Engineer,FlightEngineer,F:\newReposMay17\CYBUTEK_Engineer\Engineer\FlightEngineer.cs,DrawSurface,The following statement contains a magic number: if (e > 0) {  	//in this step' we are using the calculated impact altitude of the last step' to refine the impact site position  	impacttheta = -180 * Math.Acos ((vessel.orbit.PeR * (1 + e) / (vessel.mainBody.Radius + impactalt) - 1) / e) / Math.PI;  }  
Magic Number,Engineer,FlightEngineer,F:\newReposMay17\CYBUTEK_Engineer\Engineer\FlightEngineer.cs,DrawSurface,The following statement contains a magic number: impacttheta = -180 * Math.Acos ((vessel.orbit.PeR * (1 + e) / (vessel.mainBody.Radius + impactalt) - 1) / e) / Math.PI;  
Magic Number,Engineer,FlightEngineer,F:\newReposMay17\CYBUTEK_Engineer\Engineer\FlightEngineer.cs,DrawSurface,The following statement contains a magic number: impactlat = 180 * Math.Asin (impactpos.z / impactpos.magnitude) / Math.PI;  
Magic Number,Engineer,FlightEngineer,F:\newReposMay17\CYBUTEK_Engineer\Engineer\FlightEngineer.cs,DrawSurface,The following statement contains a magic number: if (settings.Get<bool> ("Surface: Longitude"))  	GUILayout.Label (Tools.FormatNumber (vessel.longitude' ""' 6)' dataStyle);  
Magic Number,Engineer,FlightEngineer,F:\newReposMay17\CYBUTEK_Engineer\Engineer\FlightEngineer.cs,DrawSurface,The following statement contains a magic number: GUILayout.Label (Tools.FormatNumber (vessel.longitude' ""' 6)' dataStyle);  
Magic Number,Engineer,FlightEngineer,F:\newReposMay17\CYBUTEK_Engineer\Engineer\FlightEngineer.cs,DrawSurface,The following statement contains a magic number: if (settings.Get<bool> ("Surface: Latitude"))  	GUILayout.Label (Tools.FormatNumber (vessel.latitude' ""' 6)' dataStyle);  
Magic Number,Engineer,FlightEngineer,F:\newReposMay17\CYBUTEK_Engineer\Engineer\FlightEngineer.cs,DrawSurface,The following statement contains a magic number: GUILayout.Label (Tools.FormatNumber (vessel.latitude' ""' 6)' dataStyle);  
Magic Number,Engineer,FlightEngineer,F:\newReposMay17\CYBUTEK_Engineer\Engineer\FlightEngineer.cs,DrawSurface,The following statement contains a magic number: if (impacthappening) {  	if (settings.Get<bool> ("Surface: Impact Time"' true))  		GUILayout.Label (Tools.FormatTime (impacttime)' dataStyle);  	if (settings.Get<bool> ("Surface: Impact Longitude"' true))  		GUILayout.Label (Tools.FormatNumber (impactlong' ""' 6)' dataStyle);  	if (settings.Get<bool> ("Surface: Impact Latitude"' true))  		GUILayout.Label (Tools.FormatNumber (impactlat' ""' 6)' dataStyle);  	if (settings.Get<bool> ("Surface: Impact Altitude"' true))  		GUILayout.Label (Tools.FormatSI (impactalt' Tools.SIUnitType.Distance)' dataStyle);  	if (settings.Get<bool> ("Surface: Impact Biome"' true))  		GUILayout.Label (impactbiome' dataStyle);  }  
Magic Number,Engineer,FlightEngineer,F:\newReposMay17\CYBUTEK_Engineer\Engineer\FlightEngineer.cs,DrawSurface,The following statement contains a magic number: if (impacthappening) {  	if (settings.Get<bool> ("Surface: Impact Time"' true))  		GUILayout.Label (Tools.FormatTime (impacttime)' dataStyle);  	if (settings.Get<bool> ("Surface: Impact Longitude"' true))  		GUILayout.Label (Tools.FormatNumber (impactlong' ""' 6)' dataStyle);  	if (settings.Get<bool> ("Surface: Impact Latitude"' true))  		GUILayout.Label (Tools.FormatNumber (impactlat' ""' 6)' dataStyle);  	if (settings.Get<bool> ("Surface: Impact Altitude"' true))  		GUILayout.Label (Tools.FormatSI (impactalt' Tools.SIUnitType.Distance)' dataStyle);  	if (settings.Get<bool> ("Surface: Impact Biome"' true))  		GUILayout.Label (impactbiome' dataStyle);  }  
Magic Number,Engineer,FlightEngineer,F:\newReposMay17\CYBUTEK_Engineer\Engineer\FlightEngineer.cs,DrawSurface,The following statement contains a magic number: if (settings.Get<bool> ("Surface: Impact Longitude"' true))  	GUILayout.Label (Tools.FormatNumber (impactlong' ""' 6)' dataStyle);  
Magic Number,Engineer,FlightEngineer,F:\newReposMay17\CYBUTEK_Engineer\Engineer\FlightEngineer.cs,DrawSurface,The following statement contains a magic number: GUILayout.Label (Tools.FormatNumber (impactlong' ""' 6)' dataStyle);  
Magic Number,Engineer,FlightEngineer,F:\newReposMay17\CYBUTEK_Engineer\Engineer\FlightEngineer.cs,DrawSurface,The following statement contains a magic number: if (settings.Get<bool> ("Surface: Impact Latitude"' true))  	GUILayout.Label (Tools.FormatNumber (impactlat' ""' 6)' dataStyle);  
Magic Number,Engineer,FlightEngineer,F:\newReposMay17\CYBUTEK_Engineer\Engineer\FlightEngineer.cs,DrawSurface,The following statement contains a magic number: GUILayout.Label (Tools.FormatNumber (impactlat' ""' 6)' dataStyle);  
Magic Number,Engineer,FlightEngineer,F:\newReposMay17\CYBUTEK_Engineer\Engineer\FlightEngineer.cs,DrawSurface,The following statement contains a magic number: if (settings.Get<bool> ("Surface: G-Force"))  	GUILayout.Label (Tools.FormatNumber (vessel.geeForce' 3) + " / " + Tools.FormatNumber (maxGForce' "g"' 3)' dataStyle);  
Magic Number,Engineer,FlightEngineer,F:\newReposMay17\CYBUTEK_Engineer\Engineer\FlightEngineer.cs,DrawSurface,The following statement contains a magic number: if (settings.Get<bool> ("Surface: G-Force"))  	GUILayout.Label (Tools.FormatNumber (vessel.geeForce' 3) + " / " + Tools.FormatNumber (maxGForce' "g"' 3)' dataStyle);  
Magic Number,Engineer,FlightEngineer,F:\newReposMay17\CYBUTEK_Engineer\Engineer\FlightEngineer.cs,DrawSurface,The following statement contains a magic number: GUILayout.Label (Tools.FormatNumber (vessel.geeForce' 3) + " / " + Tools.FormatNumber (maxGForce' "g"' 3)' dataStyle);  
Magic Number,Engineer,FlightEngineer,F:\newReposMay17\CYBUTEK_Engineer\Engineer\FlightEngineer.cs,DrawSurface,The following statement contains a magic number: GUILayout.Label (Tools.FormatNumber (vessel.geeForce' 3) + " / " + Tools.FormatNumber (maxGForce' "g"' 3)' dataStyle);  
Magic Number,Engineer,FlightEngineer,F:\newReposMay17\CYBUTEK_Engineer\Engineer\FlightEngineer.cs,DrawSurface,The following statement contains a magic number: if (!hasInstalledFAR && !hasInstalledNEAR && vessel.atmDensity > 0) {  	double totalMass = 0d;  	double massDrag = 0d;  	foreach (Part thePart in vessel.parts) {  		if (thePart.physicalSignificance != Part.PhysicalSignificance.NONE) {  			double partMass = thePart.mass + thePart.GetResourceMass ();  			totalMass += partMass;  			massDrag += partMass * thePart.maximum_drag;  		}  	}  	double gravity = FlightGlobals.getGeeForceAtPosition (vessel.CoM).magnitude;  	double atmosphere = vessel.atmDensity;  	double terminalVelocity = Math.Sqrt ((2 * totalMass * gravity) / (atmosphere * massDrag * FlightGlobals.DragMultiplier));  	double atmosphericEfficiency = 0d;  	if (terminalVelocity > 0) {  		atmosphericEfficiency = FlightGlobals.ship_srfSpeed / terminalVelocity;  	}  	double dragForce = 0.5 * atmosphere * Math.Pow (FlightGlobals.ship_srfSpeed' 2) * massDrag * FlightGlobals.DragMultiplier;  	if (settings.Get<bool> ("Surface: Terminal Velocity"))  		GUILayout.Label (Tools.FormatSI (terminalVelocity' Tools.SIUnitType.Speed)' dataStyle);  	if (settings.Get<bool> ("Surface: Atmospheric Efficiency"))  		GUILayout.Label (Tools.FormatNumber (atmosphericEfficiency * 100' "%"' 2)' dataStyle);  	if (settings.Get<bool> ("Surface: Atmospheric Drag"))  		GUILayout.Label (Tools.FormatSI (dragForce' Tools.SIUnitType.Force)' dataStyle);  	if (settings.Get<bool> ("Surface: Atmospheric Pressure"))  		GUILayout.Label (Tools.FormatSI (part.dynamicPressureAtm * 100' Tools.SIUnitType.Pressure)' dataStyle);  	if (settings.Get<bool> ("Surface: Atmospheric Density"))  		GUILayout.Label (Tools.FormatSI (vessel.atmDensity' Tools.SIUnitType.Density)' dataStyle);  }  
Magic Number,Engineer,FlightEngineer,F:\newReposMay17\CYBUTEK_Engineer\Engineer\FlightEngineer.cs,DrawSurface,The following statement contains a magic number: if (!hasInstalledFAR && !hasInstalledNEAR && vessel.atmDensity > 0) {  	double totalMass = 0d;  	double massDrag = 0d;  	foreach (Part thePart in vessel.parts) {  		if (thePart.physicalSignificance != Part.PhysicalSignificance.NONE) {  			double partMass = thePart.mass + thePart.GetResourceMass ();  			totalMass += partMass;  			massDrag += partMass * thePart.maximum_drag;  		}  	}  	double gravity = FlightGlobals.getGeeForceAtPosition (vessel.CoM).magnitude;  	double atmosphere = vessel.atmDensity;  	double terminalVelocity = Math.Sqrt ((2 * totalMass * gravity) / (atmosphere * massDrag * FlightGlobals.DragMultiplier));  	double atmosphericEfficiency = 0d;  	if (terminalVelocity > 0) {  		atmosphericEfficiency = FlightGlobals.ship_srfSpeed / terminalVelocity;  	}  	double dragForce = 0.5 * atmosphere * Math.Pow (FlightGlobals.ship_srfSpeed' 2) * massDrag * FlightGlobals.DragMultiplier;  	if (settings.Get<bool> ("Surface: Terminal Velocity"))  		GUILayout.Label (Tools.FormatSI (terminalVelocity' Tools.SIUnitType.Speed)' dataStyle);  	if (settings.Get<bool> ("Surface: Atmospheric Efficiency"))  		GUILayout.Label (Tools.FormatNumber (atmosphericEfficiency * 100' "%"' 2)' dataStyle);  	if (settings.Get<bool> ("Surface: Atmospheric Drag"))  		GUILayout.Label (Tools.FormatSI (dragForce' Tools.SIUnitType.Force)' dataStyle);  	if (settings.Get<bool> ("Surface: Atmospheric Pressure"))  		GUILayout.Label (Tools.FormatSI (part.dynamicPressureAtm * 100' Tools.SIUnitType.Pressure)' dataStyle);  	if (settings.Get<bool> ("Surface: Atmospheric Density"))  		GUILayout.Label (Tools.FormatSI (vessel.atmDensity' Tools.SIUnitType.Density)' dataStyle);  }  
Magic Number,Engineer,FlightEngineer,F:\newReposMay17\CYBUTEK_Engineer\Engineer\FlightEngineer.cs,DrawSurface,The following statement contains a magic number: if (!hasInstalledFAR && !hasInstalledNEAR && vessel.atmDensity > 0) {  	double totalMass = 0d;  	double massDrag = 0d;  	foreach (Part thePart in vessel.parts) {  		if (thePart.physicalSignificance != Part.PhysicalSignificance.NONE) {  			double partMass = thePart.mass + thePart.GetResourceMass ();  			totalMass += partMass;  			massDrag += partMass * thePart.maximum_drag;  		}  	}  	double gravity = FlightGlobals.getGeeForceAtPosition (vessel.CoM).magnitude;  	double atmosphere = vessel.atmDensity;  	double terminalVelocity = Math.Sqrt ((2 * totalMass * gravity) / (atmosphere * massDrag * FlightGlobals.DragMultiplier));  	double atmosphericEfficiency = 0d;  	if (terminalVelocity > 0) {  		atmosphericEfficiency = FlightGlobals.ship_srfSpeed / terminalVelocity;  	}  	double dragForce = 0.5 * atmosphere * Math.Pow (FlightGlobals.ship_srfSpeed' 2) * massDrag * FlightGlobals.DragMultiplier;  	if (settings.Get<bool> ("Surface: Terminal Velocity"))  		GUILayout.Label (Tools.FormatSI (terminalVelocity' Tools.SIUnitType.Speed)' dataStyle);  	if (settings.Get<bool> ("Surface: Atmospheric Efficiency"))  		GUILayout.Label (Tools.FormatNumber (atmosphericEfficiency * 100' "%"' 2)' dataStyle);  	if (settings.Get<bool> ("Surface: Atmospheric Drag"))  		GUILayout.Label (Tools.FormatSI (dragForce' Tools.SIUnitType.Force)' dataStyle);  	if (settings.Get<bool> ("Surface: Atmospheric Pressure"))  		GUILayout.Label (Tools.FormatSI (part.dynamicPressureAtm * 100' Tools.SIUnitType.Pressure)' dataStyle);  	if (settings.Get<bool> ("Surface: Atmospheric Density"))  		GUILayout.Label (Tools.FormatSI (vessel.atmDensity' Tools.SIUnitType.Density)' dataStyle);  }  
Magic Number,Engineer,FlightEngineer,F:\newReposMay17\CYBUTEK_Engineer\Engineer\FlightEngineer.cs,DrawSurface,The following statement contains a magic number: if (!hasInstalledFAR && !hasInstalledNEAR && vessel.atmDensity > 0) {  	double totalMass = 0d;  	double massDrag = 0d;  	foreach (Part thePart in vessel.parts) {  		if (thePart.physicalSignificance != Part.PhysicalSignificance.NONE) {  			double partMass = thePart.mass + thePart.GetResourceMass ();  			totalMass += partMass;  			massDrag += partMass * thePart.maximum_drag;  		}  	}  	double gravity = FlightGlobals.getGeeForceAtPosition (vessel.CoM).magnitude;  	double atmosphere = vessel.atmDensity;  	double terminalVelocity = Math.Sqrt ((2 * totalMass * gravity) / (atmosphere * massDrag * FlightGlobals.DragMultiplier));  	double atmosphericEfficiency = 0d;  	if (terminalVelocity > 0) {  		atmosphericEfficiency = FlightGlobals.ship_srfSpeed / terminalVelocity;  	}  	double dragForce = 0.5 * atmosphere * Math.Pow (FlightGlobals.ship_srfSpeed' 2) * massDrag * FlightGlobals.DragMultiplier;  	if (settings.Get<bool> ("Surface: Terminal Velocity"))  		GUILayout.Label (Tools.FormatSI (terminalVelocity' Tools.SIUnitType.Speed)' dataStyle);  	if (settings.Get<bool> ("Surface: Atmospheric Efficiency"))  		GUILayout.Label (Tools.FormatNumber (atmosphericEfficiency * 100' "%"' 2)' dataStyle);  	if (settings.Get<bool> ("Surface: Atmospheric Drag"))  		GUILayout.Label (Tools.FormatSI (dragForce' Tools.SIUnitType.Force)' dataStyle);  	if (settings.Get<bool> ("Surface: Atmospheric Pressure"))  		GUILayout.Label (Tools.FormatSI (part.dynamicPressureAtm * 100' Tools.SIUnitType.Pressure)' dataStyle);  	if (settings.Get<bool> ("Surface: Atmospheric Density"))  		GUILayout.Label (Tools.FormatSI (vessel.atmDensity' Tools.SIUnitType.Density)' dataStyle);  }  
Magic Number,Engineer,FlightEngineer,F:\newReposMay17\CYBUTEK_Engineer\Engineer\FlightEngineer.cs,DrawSurface,The following statement contains a magic number: if (!hasInstalledFAR && !hasInstalledNEAR && vessel.atmDensity > 0) {  	double totalMass = 0d;  	double massDrag = 0d;  	foreach (Part thePart in vessel.parts) {  		if (thePart.physicalSignificance != Part.PhysicalSignificance.NONE) {  			double partMass = thePart.mass + thePart.GetResourceMass ();  			totalMass += partMass;  			massDrag += partMass * thePart.maximum_drag;  		}  	}  	double gravity = FlightGlobals.getGeeForceAtPosition (vessel.CoM).magnitude;  	double atmosphere = vessel.atmDensity;  	double terminalVelocity = Math.Sqrt ((2 * totalMass * gravity) / (atmosphere * massDrag * FlightGlobals.DragMultiplier));  	double atmosphericEfficiency = 0d;  	if (terminalVelocity > 0) {  		atmosphericEfficiency = FlightGlobals.ship_srfSpeed / terminalVelocity;  	}  	double dragForce = 0.5 * atmosphere * Math.Pow (FlightGlobals.ship_srfSpeed' 2) * massDrag * FlightGlobals.DragMultiplier;  	if (settings.Get<bool> ("Surface: Terminal Velocity"))  		GUILayout.Label (Tools.FormatSI (terminalVelocity' Tools.SIUnitType.Speed)' dataStyle);  	if (settings.Get<bool> ("Surface: Atmospheric Efficiency"))  		GUILayout.Label (Tools.FormatNumber (atmosphericEfficiency * 100' "%"' 2)' dataStyle);  	if (settings.Get<bool> ("Surface: Atmospheric Drag"))  		GUILayout.Label (Tools.FormatSI (dragForce' Tools.SIUnitType.Force)' dataStyle);  	if (settings.Get<bool> ("Surface: Atmospheric Pressure"))  		GUILayout.Label (Tools.FormatSI (part.dynamicPressureAtm * 100' Tools.SIUnitType.Pressure)' dataStyle);  	if (settings.Get<bool> ("Surface: Atmospheric Density"))  		GUILayout.Label (Tools.FormatSI (vessel.atmDensity' Tools.SIUnitType.Density)' dataStyle);  }  
Magic Number,Engineer,FlightEngineer,F:\newReposMay17\CYBUTEK_Engineer\Engineer\FlightEngineer.cs,DrawSurface,The following statement contains a magic number: if (!hasInstalledFAR && !hasInstalledNEAR && vessel.atmDensity > 0) {  	double totalMass = 0d;  	double massDrag = 0d;  	foreach (Part thePart in vessel.parts) {  		if (thePart.physicalSignificance != Part.PhysicalSignificance.NONE) {  			double partMass = thePart.mass + thePart.GetResourceMass ();  			totalMass += partMass;  			massDrag += partMass * thePart.maximum_drag;  		}  	}  	double gravity = FlightGlobals.getGeeForceAtPosition (vessel.CoM).magnitude;  	double atmosphere = vessel.atmDensity;  	double terminalVelocity = Math.Sqrt ((2 * totalMass * gravity) / (atmosphere * massDrag * FlightGlobals.DragMultiplier));  	double atmosphericEfficiency = 0d;  	if (terminalVelocity > 0) {  		atmosphericEfficiency = FlightGlobals.ship_srfSpeed / terminalVelocity;  	}  	double dragForce = 0.5 * atmosphere * Math.Pow (FlightGlobals.ship_srfSpeed' 2) * massDrag * FlightGlobals.DragMultiplier;  	if (settings.Get<bool> ("Surface: Terminal Velocity"))  		GUILayout.Label (Tools.FormatSI (terminalVelocity' Tools.SIUnitType.Speed)' dataStyle);  	if (settings.Get<bool> ("Surface: Atmospheric Efficiency"))  		GUILayout.Label (Tools.FormatNumber (atmosphericEfficiency * 100' "%"' 2)' dataStyle);  	if (settings.Get<bool> ("Surface: Atmospheric Drag"))  		GUILayout.Label (Tools.FormatSI (dragForce' Tools.SIUnitType.Force)' dataStyle);  	if (settings.Get<bool> ("Surface: Atmospheric Pressure"))  		GUILayout.Label (Tools.FormatSI (part.dynamicPressureAtm * 100' Tools.SIUnitType.Pressure)' dataStyle);  	if (settings.Get<bool> ("Surface: Atmospheric Density"))  		GUILayout.Label (Tools.FormatSI (vessel.atmDensity' Tools.SIUnitType.Density)' dataStyle);  }  
Magic Number,Engineer,FlightEngineer,F:\newReposMay17\CYBUTEK_Engineer\Engineer\FlightEngineer.cs,DrawSurface,The following statement contains a magic number: if (settings.Get<bool> ("Surface: Atmospheric Efficiency"))  	GUILayout.Label (Tools.FormatNumber (atmosphericEfficiency * 100' "%"' 2)' dataStyle);  
Magic Number,Engineer,FlightEngineer,F:\newReposMay17\CYBUTEK_Engineer\Engineer\FlightEngineer.cs,DrawSurface,The following statement contains a magic number: if (settings.Get<bool> ("Surface: Atmospheric Efficiency"))  	GUILayout.Label (Tools.FormatNumber (atmosphericEfficiency * 100' "%"' 2)' dataStyle);  
Magic Number,Engineer,FlightEngineer,F:\newReposMay17\CYBUTEK_Engineer\Engineer\FlightEngineer.cs,DrawSurface,The following statement contains a magic number: GUILayout.Label (Tools.FormatNumber (atmosphericEfficiency * 100' "%"' 2)' dataStyle);  
Magic Number,Engineer,FlightEngineer,F:\newReposMay17\CYBUTEK_Engineer\Engineer\FlightEngineer.cs,DrawSurface,The following statement contains a magic number: GUILayout.Label (Tools.FormatNumber (atmosphericEfficiency * 100' "%"' 2)' dataStyle);  
Magic Number,Engineer,FlightEngineer,F:\newReposMay17\CYBUTEK_Engineer\Engineer\FlightEngineer.cs,DrawSurface,The following statement contains a magic number: if (settings.Get<bool> ("Surface: Atmospheric Pressure"))  	GUILayout.Label (Tools.FormatSI (part.dynamicPressureAtm * 100' Tools.SIUnitType.Pressure)' dataStyle);  
Magic Number,Engineer,FlightEngineer,F:\newReposMay17\CYBUTEK_Engineer\Engineer\FlightEngineer.cs,DrawSurface,The following statement contains a magic number: GUILayout.Label (Tools.FormatSI (part.dynamicPressureAtm * 100' Tools.SIUnitType.Pressure)' dataStyle);  
Magic Number,Engineer,FlightEngineer,F:\newReposMay17\CYBUTEK_Engineer\Engineer\FlightEngineer.cs,DrawVessel,The following statement contains a magic number: if (stages == null) {  	GUILayout.Label ("Simulation failed:"' headingStyle);  	GUILayout.Label (failMessage == "" ? "No fail message" : failMessage' dataStyle);  } else {  	int stageCount = stages.Length;  	int stageCountUseful = 0;  	Stage currentStage = stages [stageCount - 1];  	if (settings.Get<bool> ("Vessel: Show All DeltaV Stages"' true)) {  		for (int i = stageCount - 1; i >= 0; i--) {  			stageDeltaV = stages [i].deltaV;  			if (stageDeltaV > 0) {  				if (settings.Get<bool> ("Vessel: DeltaV (Stage)"' true)) {  					if (stages [i].number == -1)  						GUILayout.Label ("DeltaV (active)"' headingStyle);  					else  						GUILayout.Label ("DeltaV (S" + i + ")"' headingStyle);  				}  				stageCountUseful++;  			}  		}  		if (stageCount != numberOfStages || stageCountUseful != numberOfStagesUseful) {  			numberOfStages = stageCount;  			numberOfStagesUseful = stageCountUseful;  			settings.Changed = true;  		}  	} else {  		if (settings.Get<bool> ("Vessel: DeltaV (Stage)"' true))  			GUILayout.Label ("DeltaV (Stage)"' headingStyle);  	}  	if (settings.Get<bool> ("Vessel: DeltaV (Total)"' true))  		GUILayout.Label ("DeltaV (Total)"' headingStyle);  	if (settings.Get<bool> ("Vessel: Specific Impulse"' true))  		GUILayout.Label ("Specific Impulse"' headingStyle);  	if (settings.Get<bool> ("Vessel: Mass"' true))  		GUILayout.Label ("Mass"' headingStyle);  	if (settings.Get<bool> ("Vessel: Thrust (Maximum)"' true))  		GUILayout.Label ("Thrust (Maximum)"' headingStyle);  	if (settings.Get<bool> ("Vessel: Thrust (Throttle)"' true))  		GUILayout.Label ("Thrust (Throttle)"' headingStyle);  	if (settings.Get<bool> ("Vessel: Thrust to Weight (Throttle)"' true))  		GUILayout.Label ("TWR (Throttle)"' headingStyle);  	if (settings.Get<bool> ("Vessel: Thrust to Weight (Current)"' true))  		GUILayout.Label ("TWR (Current)"' headingStyle);  	if (settings.Get<bool> ("Vessel: Thrust to Weight (Surface)"' true))  		GUILayout.Label ("TWR (Surface)"' headingStyle);  	GUILayout.EndVertical ();  	GUILayout.BeginVertical ();  	if (settings.Get<bool> ("Vessel: Show All DeltaV Stages")) {  		for (int i = stageCount - 1; i >= 0; i--) {  			stageDeltaV = stages [i].deltaV;  			if (stageDeltaV > 0) {  				if (settings.Get<bool> ("Vessel: DeltaV (Stage)"))  					GUILayout.Label (Tools.FormatNumber (stages [i].deltaV' "m/s"' 0) + " (" + Tools.FormatTime (stages [i].time) + ")"' dataStyle);  			}  		}  	} else {  		if (settings.Get<bool> ("Vessel: DeltaV (Stage)"))  			GUILayout.Label (Tools.FormatNumber (currentStage.deltaV' "m/s"' 0) + " (" + Tools.FormatTime (currentStage.time) + ")"' dataStyle);  	}  	if (settings.Get<bool> ("Vessel: DeltaV (Total)"))  		GUILayout.Label (Tools.FormatNumber (currentStage.totalDeltaV' "m/s"' 0) + " (" + Tools.FormatTime (currentStage.totalTime) + ")"' dataStyle);  	if (settings.Get<bool> ("Vessel: Specific Impulse"))  		GUILayout.Label (Tools.FormatNumber (currentStage.isp' "s"' 3)' dataStyle);  	if (settings.Get<bool> ("Vessel: Mass"))  		GUILayout.Label (EngineerTools.WeightFormatter (currentStage.mass' currentStage.totalMass)' dataStyle);  	if (settings.Get<bool> ("Vessel: Thrust (Maximum)"))  		GUILayout.Label (Tools.FormatSI (currentStage.thrust' Tools.SIUnitType.Force)' dataStyle);  	if (settings.Get<bool> ("Vessel: Thrust (Throttle)"))  		GUILayout.Label (Tools.FormatSI (currentStage.actualThrust' Tools.SIUnitType.Force)' dataStyle);  	if (settings.Get<bool> ("Vessel: Thrust to Weight (Throttle)"))  		GUILayout.Label (Tools.FormatNumber (currentStage.actualThrustToWeight' 3)' dataStyle);  	if (settings.Get<bool> ("Vessel: Thrust to Weight (Current)"))  		GUILayout.Label (Tools.FormatNumber (currentStage.thrustToWeight' 3)' dataStyle);  	if (settings.Get<bool> ("Vessel: Thrust to Weight (Surface)"))  		GUILayout.Label (Tools.FormatNumber (currentStage.thrust / (currentStage.totalMass * (vessel.mainBody.gravParameter / Math.Pow (vessel.mainBody.Radius' 2)))' 3)' dataStyle);  }  
Magic Number,Engineer,FlightEngineer,F:\newReposMay17\CYBUTEK_Engineer\Engineer\FlightEngineer.cs,DrawVessel,The following statement contains a magic number: if (stages == null) {  	GUILayout.Label ("Simulation failed:"' headingStyle);  	GUILayout.Label (failMessage == "" ? "No fail message" : failMessage' dataStyle);  } else {  	int stageCount = stages.Length;  	int stageCountUseful = 0;  	Stage currentStage = stages [stageCount - 1];  	if (settings.Get<bool> ("Vessel: Show All DeltaV Stages"' true)) {  		for (int i = stageCount - 1; i >= 0; i--) {  			stageDeltaV = stages [i].deltaV;  			if (stageDeltaV > 0) {  				if (settings.Get<bool> ("Vessel: DeltaV (Stage)"' true)) {  					if (stages [i].number == -1)  						GUILayout.Label ("DeltaV (active)"' headingStyle);  					else  						GUILayout.Label ("DeltaV (S" + i + ")"' headingStyle);  				}  				stageCountUseful++;  			}  		}  		if (stageCount != numberOfStages || stageCountUseful != numberOfStagesUseful) {  			numberOfStages = stageCount;  			numberOfStagesUseful = stageCountUseful;  			settings.Changed = true;  		}  	} else {  		if (settings.Get<bool> ("Vessel: DeltaV (Stage)"' true))  			GUILayout.Label ("DeltaV (Stage)"' headingStyle);  	}  	if (settings.Get<bool> ("Vessel: DeltaV (Total)"' true))  		GUILayout.Label ("DeltaV (Total)"' headingStyle);  	if (settings.Get<bool> ("Vessel: Specific Impulse"' true))  		GUILayout.Label ("Specific Impulse"' headingStyle);  	if (settings.Get<bool> ("Vessel: Mass"' true))  		GUILayout.Label ("Mass"' headingStyle);  	if (settings.Get<bool> ("Vessel: Thrust (Maximum)"' true))  		GUILayout.Label ("Thrust (Maximum)"' headingStyle);  	if (settings.Get<bool> ("Vessel: Thrust (Throttle)"' true))  		GUILayout.Label ("Thrust (Throttle)"' headingStyle);  	if (settings.Get<bool> ("Vessel: Thrust to Weight (Throttle)"' true))  		GUILayout.Label ("TWR (Throttle)"' headingStyle);  	if (settings.Get<bool> ("Vessel: Thrust to Weight (Current)"' true))  		GUILayout.Label ("TWR (Current)"' headingStyle);  	if (settings.Get<bool> ("Vessel: Thrust to Weight (Surface)"' true))  		GUILayout.Label ("TWR (Surface)"' headingStyle);  	GUILayout.EndVertical ();  	GUILayout.BeginVertical ();  	if (settings.Get<bool> ("Vessel: Show All DeltaV Stages")) {  		for (int i = stageCount - 1; i >= 0; i--) {  			stageDeltaV = stages [i].deltaV;  			if (stageDeltaV > 0) {  				if (settings.Get<bool> ("Vessel: DeltaV (Stage)"))  					GUILayout.Label (Tools.FormatNumber (stages [i].deltaV' "m/s"' 0) + " (" + Tools.FormatTime (stages [i].time) + ")"' dataStyle);  			}  		}  	} else {  		if (settings.Get<bool> ("Vessel: DeltaV (Stage)"))  			GUILayout.Label (Tools.FormatNumber (currentStage.deltaV' "m/s"' 0) + " (" + Tools.FormatTime (currentStage.time) + ")"' dataStyle);  	}  	if (settings.Get<bool> ("Vessel: DeltaV (Total)"))  		GUILayout.Label (Tools.FormatNumber (currentStage.totalDeltaV' "m/s"' 0) + " (" + Tools.FormatTime (currentStage.totalTime) + ")"' dataStyle);  	if (settings.Get<bool> ("Vessel: Specific Impulse"))  		GUILayout.Label (Tools.FormatNumber (currentStage.isp' "s"' 3)' dataStyle);  	if (settings.Get<bool> ("Vessel: Mass"))  		GUILayout.Label (EngineerTools.WeightFormatter (currentStage.mass' currentStage.totalMass)' dataStyle);  	if (settings.Get<bool> ("Vessel: Thrust (Maximum)"))  		GUILayout.Label (Tools.FormatSI (currentStage.thrust' Tools.SIUnitType.Force)' dataStyle);  	if (settings.Get<bool> ("Vessel: Thrust (Throttle)"))  		GUILayout.Label (Tools.FormatSI (currentStage.actualThrust' Tools.SIUnitType.Force)' dataStyle);  	if (settings.Get<bool> ("Vessel: Thrust to Weight (Throttle)"))  		GUILayout.Label (Tools.FormatNumber (currentStage.actualThrustToWeight' 3)' dataStyle);  	if (settings.Get<bool> ("Vessel: Thrust to Weight (Current)"))  		GUILayout.Label (Tools.FormatNumber (currentStage.thrustToWeight' 3)' dataStyle);  	if (settings.Get<bool> ("Vessel: Thrust to Weight (Surface)"))  		GUILayout.Label (Tools.FormatNumber (currentStage.thrust / (currentStage.totalMass * (vessel.mainBody.gravParameter / Math.Pow (vessel.mainBody.Radius' 2)))' 3)' dataStyle);  }  
Magic Number,Engineer,FlightEngineer,F:\newReposMay17\CYBUTEK_Engineer\Engineer\FlightEngineer.cs,DrawVessel,The following statement contains a magic number: if (stages == null) {  	GUILayout.Label ("Simulation failed:"' headingStyle);  	GUILayout.Label (failMessage == "" ? "No fail message" : failMessage' dataStyle);  } else {  	int stageCount = stages.Length;  	int stageCountUseful = 0;  	Stage currentStage = stages [stageCount - 1];  	if (settings.Get<bool> ("Vessel: Show All DeltaV Stages"' true)) {  		for (int i = stageCount - 1; i >= 0; i--) {  			stageDeltaV = stages [i].deltaV;  			if (stageDeltaV > 0) {  				if (settings.Get<bool> ("Vessel: DeltaV (Stage)"' true)) {  					if (stages [i].number == -1)  						GUILayout.Label ("DeltaV (active)"' headingStyle);  					else  						GUILayout.Label ("DeltaV (S" + i + ")"' headingStyle);  				}  				stageCountUseful++;  			}  		}  		if (stageCount != numberOfStages || stageCountUseful != numberOfStagesUseful) {  			numberOfStages = stageCount;  			numberOfStagesUseful = stageCountUseful;  			settings.Changed = true;  		}  	} else {  		if (settings.Get<bool> ("Vessel: DeltaV (Stage)"' true))  			GUILayout.Label ("DeltaV (Stage)"' headingStyle);  	}  	if (settings.Get<bool> ("Vessel: DeltaV (Total)"' true))  		GUILayout.Label ("DeltaV (Total)"' headingStyle);  	if (settings.Get<bool> ("Vessel: Specific Impulse"' true))  		GUILayout.Label ("Specific Impulse"' headingStyle);  	if (settings.Get<bool> ("Vessel: Mass"' true))  		GUILayout.Label ("Mass"' headingStyle);  	if (settings.Get<bool> ("Vessel: Thrust (Maximum)"' true))  		GUILayout.Label ("Thrust (Maximum)"' headingStyle);  	if (settings.Get<bool> ("Vessel: Thrust (Throttle)"' true))  		GUILayout.Label ("Thrust (Throttle)"' headingStyle);  	if (settings.Get<bool> ("Vessel: Thrust to Weight (Throttle)"' true))  		GUILayout.Label ("TWR (Throttle)"' headingStyle);  	if (settings.Get<bool> ("Vessel: Thrust to Weight (Current)"' true))  		GUILayout.Label ("TWR (Current)"' headingStyle);  	if (settings.Get<bool> ("Vessel: Thrust to Weight (Surface)"' true))  		GUILayout.Label ("TWR (Surface)"' headingStyle);  	GUILayout.EndVertical ();  	GUILayout.BeginVertical ();  	if (settings.Get<bool> ("Vessel: Show All DeltaV Stages")) {  		for (int i = stageCount - 1; i >= 0; i--) {  			stageDeltaV = stages [i].deltaV;  			if (stageDeltaV > 0) {  				if (settings.Get<bool> ("Vessel: DeltaV (Stage)"))  					GUILayout.Label (Tools.FormatNumber (stages [i].deltaV' "m/s"' 0) + " (" + Tools.FormatTime (stages [i].time) + ")"' dataStyle);  			}  		}  	} else {  		if (settings.Get<bool> ("Vessel: DeltaV (Stage)"))  			GUILayout.Label (Tools.FormatNumber (currentStage.deltaV' "m/s"' 0) + " (" + Tools.FormatTime (currentStage.time) + ")"' dataStyle);  	}  	if (settings.Get<bool> ("Vessel: DeltaV (Total)"))  		GUILayout.Label (Tools.FormatNumber (currentStage.totalDeltaV' "m/s"' 0) + " (" + Tools.FormatTime (currentStage.totalTime) + ")"' dataStyle);  	if (settings.Get<bool> ("Vessel: Specific Impulse"))  		GUILayout.Label (Tools.FormatNumber (currentStage.isp' "s"' 3)' dataStyle);  	if (settings.Get<bool> ("Vessel: Mass"))  		GUILayout.Label (EngineerTools.WeightFormatter (currentStage.mass' currentStage.totalMass)' dataStyle);  	if (settings.Get<bool> ("Vessel: Thrust (Maximum)"))  		GUILayout.Label (Tools.FormatSI (currentStage.thrust' Tools.SIUnitType.Force)' dataStyle);  	if (settings.Get<bool> ("Vessel: Thrust (Throttle)"))  		GUILayout.Label (Tools.FormatSI (currentStage.actualThrust' Tools.SIUnitType.Force)' dataStyle);  	if (settings.Get<bool> ("Vessel: Thrust to Weight (Throttle)"))  		GUILayout.Label (Tools.FormatNumber (currentStage.actualThrustToWeight' 3)' dataStyle);  	if (settings.Get<bool> ("Vessel: Thrust to Weight (Current)"))  		GUILayout.Label (Tools.FormatNumber (currentStage.thrustToWeight' 3)' dataStyle);  	if (settings.Get<bool> ("Vessel: Thrust to Weight (Surface)"))  		GUILayout.Label (Tools.FormatNumber (currentStage.thrust / (currentStage.totalMass * (vessel.mainBody.gravParameter / Math.Pow (vessel.mainBody.Radius' 2)))' 3)' dataStyle);  }  
Magic Number,Engineer,FlightEngineer,F:\newReposMay17\CYBUTEK_Engineer\Engineer\FlightEngineer.cs,DrawVessel,The following statement contains a magic number: if (stages == null) {  	GUILayout.Label ("Simulation failed:"' headingStyle);  	GUILayout.Label (failMessage == "" ? "No fail message" : failMessage' dataStyle);  } else {  	int stageCount = stages.Length;  	int stageCountUseful = 0;  	Stage currentStage = stages [stageCount - 1];  	if (settings.Get<bool> ("Vessel: Show All DeltaV Stages"' true)) {  		for (int i = stageCount - 1; i >= 0; i--) {  			stageDeltaV = stages [i].deltaV;  			if (stageDeltaV > 0) {  				if (settings.Get<bool> ("Vessel: DeltaV (Stage)"' true)) {  					if (stages [i].number == -1)  						GUILayout.Label ("DeltaV (active)"' headingStyle);  					else  						GUILayout.Label ("DeltaV (S" + i + ")"' headingStyle);  				}  				stageCountUseful++;  			}  		}  		if (stageCount != numberOfStages || stageCountUseful != numberOfStagesUseful) {  			numberOfStages = stageCount;  			numberOfStagesUseful = stageCountUseful;  			settings.Changed = true;  		}  	} else {  		if (settings.Get<bool> ("Vessel: DeltaV (Stage)"' true))  			GUILayout.Label ("DeltaV (Stage)"' headingStyle);  	}  	if (settings.Get<bool> ("Vessel: DeltaV (Total)"' true))  		GUILayout.Label ("DeltaV (Total)"' headingStyle);  	if (settings.Get<bool> ("Vessel: Specific Impulse"' true))  		GUILayout.Label ("Specific Impulse"' headingStyle);  	if (settings.Get<bool> ("Vessel: Mass"' true))  		GUILayout.Label ("Mass"' headingStyle);  	if (settings.Get<bool> ("Vessel: Thrust (Maximum)"' true))  		GUILayout.Label ("Thrust (Maximum)"' headingStyle);  	if (settings.Get<bool> ("Vessel: Thrust (Throttle)"' true))  		GUILayout.Label ("Thrust (Throttle)"' headingStyle);  	if (settings.Get<bool> ("Vessel: Thrust to Weight (Throttle)"' true))  		GUILayout.Label ("TWR (Throttle)"' headingStyle);  	if (settings.Get<bool> ("Vessel: Thrust to Weight (Current)"' true))  		GUILayout.Label ("TWR (Current)"' headingStyle);  	if (settings.Get<bool> ("Vessel: Thrust to Weight (Surface)"' true))  		GUILayout.Label ("TWR (Surface)"' headingStyle);  	GUILayout.EndVertical ();  	GUILayout.BeginVertical ();  	if (settings.Get<bool> ("Vessel: Show All DeltaV Stages")) {  		for (int i = stageCount - 1; i >= 0; i--) {  			stageDeltaV = stages [i].deltaV;  			if (stageDeltaV > 0) {  				if (settings.Get<bool> ("Vessel: DeltaV (Stage)"))  					GUILayout.Label (Tools.FormatNumber (stages [i].deltaV' "m/s"' 0) + " (" + Tools.FormatTime (stages [i].time) + ")"' dataStyle);  			}  		}  	} else {  		if (settings.Get<bool> ("Vessel: DeltaV (Stage)"))  			GUILayout.Label (Tools.FormatNumber (currentStage.deltaV' "m/s"' 0) + " (" + Tools.FormatTime (currentStage.time) + ")"' dataStyle);  	}  	if (settings.Get<bool> ("Vessel: DeltaV (Total)"))  		GUILayout.Label (Tools.FormatNumber (currentStage.totalDeltaV' "m/s"' 0) + " (" + Tools.FormatTime (currentStage.totalTime) + ")"' dataStyle);  	if (settings.Get<bool> ("Vessel: Specific Impulse"))  		GUILayout.Label (Tools.FormatNumber (currentStage.isp' "s"' 3)' dataStyle);  	if (settings.Get<bool> ("Vessel: Mass"))  		GUILayout.Label (EngineerTools.WeightFormatter (currentStage.mass' currentStage.totalMass)' dataStyle);  	if (settings.Get<bool> ("Vessel: Thrust (Maximum)"))  		GUILayout.Label (Tools.FormatSI (currentStage.thrust' Tools.SIUnitType.Force)' dataStyle);  	if (settings.Get<bool> ("Vessel: Thrust (Throttle)"))  		GUILayout.Label (Tools.FormatSI (currentStage.actualThrust' Tools.SIUnitType.Force)' dataStyle);  	if (settings.Get<bool> ("Vessel: Thrust to Weight (Throttle)"))  		GUILayout.Label (Tools.FormatNumber (currentStage.actualThrustToWeight' 3)' dataStyle);  	if (settings.Get<bool> ("Vessel: Thrust to Weight (Current)"))  		GUILayout.Label (Tools.FormatNumber (currentStage.thrustToWeight' 3)' dataStyle);  	if (settings.Get<bool> ("Vessel: Thrust to Weight (Surface)"))  		GUILayout.Label (Tools.FormatNumber (currentStage.thrust / (currentStage.totalMass * (vessel.mainBody.gravParameter / Math.Pow (vessel.mainBody.Radius' 2)))' 3)' dataStyle);  }  
Magic Number,Engineer,FlightEngineer,F:\newReposMay17\CYBUTEK_Engineer\Engineer\FlightEngineer.cs,DrawVessel,The following statement contains a magic number: if (stages == null) {  	GUILayout.Label ("Simulation failed:"' headingStyle);  	GUILayout.Label (failMessage == "" ? "No fail message" : failMessage' dataStyle);  } else {  	int stageCount = stages.Length;  	int stageCountUseful = 0;  	Stage currentStage = stages [stageCount - 1];  	if (settings.Get<bool> ("Vessel: Show All DeltaV Stages"' true)) {  		for (int i = stageCount - 1; i >= 0; i--) {  			stageDeltaV = stages [i].deltaV;  			if (stageDeltaV > 0) {  				if (settings.Get<bool> ("Vessel: DeltaV (Stage)"' true)) {  					if (stages [i].number == -1)  						GUILayout.Label ("DeltaV (active)"' headingStyle);  					else  						GUILayout.Label ("DeltaV (S" + i + ")"' headingStyle);  				}  				stageCountUseful++;  			}  		}  		if (stageCount != numberOfStages || stageCountUseful != numberOfStagesUseful) {  			numberOfStages = stageCount;  			numberOfStagesUseful = stageCountUseful;  			settings.Changed = true;  		}  	} else {  		if (settings.Get<bool> ("Vessel: DeltaV (Stage)"' true))  			GUILayout.Label ("DeltaV (Stage)"' headingStyle);  	}  	if (settings.Get<bool> ("Vessel: DeltaV (Total)"' true))  		GUILayout.Label ("DeltaV (Total)"' headingStyle);  	if (settings.Get<bool> ("Vessel: Specific Impulse"' true))  		GUILayout.Label ("Specific Impulse"' headingStyle);  	if (settings.Get<bool> ("Vessel: Mass"' true))  		GUILayout.Label ("Mass"' headingStyle);  	if (settings.Get<bool> ("Vessel: Thrust (Maximum)"' true))  		GUILayout.Label ("Thrust (Maximum)"' headingStyle);  	if (settings.Get<bool> ("Vessel: Thrust (Throttle)"' true))  		GUILayout.Label ("Thrust (Throttle)"' headingStyle);  	if (settings.Get<bool> ("Vessel: Thrust to Weight (Throttle)"' true))  		GUILayout.Label ("TWR (Throttle)"' headingStyle);  	if (settings.Get<bool> ("Vessel: Thrust to Weight (Current)"' true))  		GUILayout.Label ("TWR (Current)"' headingStyle);  	if (settings.Get<bool> ("Vessel: Thrust to Weight (Surface)"' true))  		GUILayout.Label ("TWR (Surface)"' headingStyle);  	GUILayout.EndVertical ();  	GUILayout.BeginVertical ();  	if (settings.Get<bool> ("Vessel: Show All DeltaV Stages")) {  		for (int i = stageCount - 1; i >= 0; i--) {  			stageDeltaV = stages [i].deltaV;  			if (stageDeltaV > 0) {  				if (settings.Get<bool> ("Vessel: DeltaV (Stage)"))  					GUILayout.Label (Tools.FormatNumber (stages [i].deltaV' "m/s"' 0) + " (" + Tools.FormatTime (stages [i].time) + ")"' dataStyle);  			}  		}  	} else {  		if (settings.Get<bool> ("Vessel: DeltaV (Stage)"))  			GUILayout.Label (Tools.FormatNumber (currentStage.deltaV' "m/s"' 0) + " (" + Tools.FormatTime (currentStage.time) + ")"' dataStyle);  	}  	if (settings.Get<bool> ("Vessel: DeltaV (Total)"))  		GUILayout.Label (Tools.FormatNumber (currentStage.totalDeltaV' "m/s"' 0) + " (" + Tools.FormatTime (currentStage.totalTime) + ")"' dataStyle);  	if (settings.Get<bool> ("Vessel: Specific Impulse"))  		GUILayout.Label (Tools.FormatNumber (currentStage.isp' "s"' 3)' dataStyle);  	if (settings.Get<bool> ("Vessel: Mass"))  		GUILayout.Label (EngineerTools.WeightFormatter (currentStage.mass' currentStage.totalMass)' dataStyle);  	if (settings.Get<bool> ("Vessel: Thrust (Maximum)"))  		GUILayout.Label (Tools.FormatSI (currentStage.thrust' Tools.SIUnitType.Force)' dataStyle);  	if (settings.Get<bool> ("Vessel: Thrust (Throttle)"))  		GUILayout.Label (Tools.FormatSI (currentStage.actualThrust' Tools.SIUnitType.Force)' dataStyle);  	if (settings.Get<bool> ("Vessel: Thrust to Weight (Throttle)"))  		GUILayout.Label (Tools.FormatNumber (currentStage.actualThrustToWeight' 3)' dataStyle);  	if (settings.Get<bool> ("Vessel: Thrust to Weight (Current)"))  		GUILayout.Label (Tools.FormatNumber (currentStage.thrustToWeight' 3)' dataStyle);  	if (settings.Get<bool> ("Vessel: Thrust to Weight (Surface)"))  		GUILayout.Label (Tools.FormatNumber (currentStage.thrust / (currentStage.totalMass * (vessel.mainBody.gravParameter / Math.Pow (vessel.mainBody.Radius' 2)))' 3)' dataStyle);  }  
Magic Number,Engineer,FlightEngineer,F:\newReposMay17\CYBUTEK_Engineer\Engineer\FlightEngineer.cs,DrawVessel,The following statement contains a magic number: if (settings.Get<bool> ("Vessel: Specific Impulse"))  	GUILayout.Label (Tools.FormatNumber (currentStage.isp' "s"' 3)' dataStyle);  
Magic Number,Engineer,FlightEngineer,F:\newReposMay17\CYBUTEK_Engineer\Engineer\FlightEngineer.cs,DrawVessel,The following statement contains a magic number: GUILayout.Label (Tools.FormatNumber (currentStage.isp' "s"' 3)' dataStyle);  
Magic Number,Engineer,FlightEngineer,F:\newReposMay17\CYBUTEK_Engineer\Engineer\FlightEngineer.cs,DrawVessel,The following statement contains a magic number: if (settings.Get<bool> ("Vessel: Thrust to Weight (Throttle)"))  	GUILayout.Label (Tools.FormatNumber (currentStage.actualThrustToWeight' 3)' dataStyle);  
Magic Number,Engineer,FlightEngineer,F:\newReposMay17\CYBUTEK_Engineer\Engineer\FlightEngineer.cs,DrawVessel,The following statement contains a magic number: GUILayout.Label (Tools.FormatNumber (currentStage.actualThrustToWeight' 3)' dataStyle);  
Magic Number,Engineer,FlightEngineer,F:\newReposMay17\CYBUTEK_Engineer\Engineer\FlightEngineer.cs,DrawVessel,The following statement contains a magic number: if (settings.Get<bool> ("Vessel: Thrust to Weight (Current)"))  	GUILayout.Label (Tools.FormatNumber (currentStage.thrustToWeight' 3)' dataStyle);  
Magic Number,Engineer,FlightEngineer,F:\newReposMay17\CYBUTEK_Engineer\Engineer\FlightEngineer.cs,DrawVessel,The following statement contains a magic number: GUILayout.Label (Tools.FormatNumber (currentStage.thrustToWeight' 3)' dataStyle);  
Magic Number,Engineer,FlightEngineer,F:\newReposMay17\CYBUTEK_Engineer\Engineer\FlightEngineer.cs,DrawVessel,The following statement contains a magic number: if (settings.Get<bool> ("Vessel: Thrust to Weight (Surface)"))  	GUILayout.Label (Tools.FormatNumber (currentStage.thrust / (currentStage.totalMass * (vessel.mainBody.gravParameter / Math.Pow (vessel.mainBody.Radius' 2)))' 3)' dataStyle);  
Magic Number,Engineer,FlightEngineer,F:\newReposMay17\CYBUTEK_Engineer\Engineer\FlightEngineer.cs,DrawVessel,The following statement contains a magic number: if (settings.Get<bool> ("Vessel: Thrust to Weight (Surface)"))  	GUILayout.Label (Tools.FormatNumber (currentStage.thrust / (currentStage.totalMass * (vessel.mainBody.gravParameter / Math.Pow (vessel.mainBody.Radius' 2)))' 3)' dataStyle);  
Magic Number,Engineer,FlightEngineer,F:\newReposMay17\CYBUTEK_Engineer\Engineer\FlightEngineer.cs,DrawVessel,The following statement contains a magic number: GUILayout.Label (Tools.FormatNumber (currentStage.thrust / (currentStage.totalMass * (vessel.mainBody.gravParameter / Math.Pow (vessel.mainBody.Radius' 2)))' 3)' dataStyle);  
Magic Number,Engineer,FlightEngineer,F:\newReposMay17\CYBUTEK_Engineer\Engineer\FlightEngineer.cs,DrawVessel,The following statement contains a magic number: GUILayout.Label (Tools.FormatNumber (currentStage.thrust / (currentStage.totalMass * (vessel.mainBody.gravParameter / Math.Pow (vessel.mainBody.Radius' 2)))' 3)' dataStyle);  
Magic Number,Engineer,FlightEngineer,F:\newReposMay17\CYBUTEK_Engineer\Engineer\FlightEngineer.cs,InitStyles,The following statement contains a magic number: windowStyle.fixedWidth = 275;  
Magic Number,Engineer,Rendezvous,F:\newReposMay17\CYBUTEK_Engineer\Engineer\Rendezvous.cs,DrawBodyDetails,The following statement contains a magic number: if (interceptAngle < 0) {  	phaseAngle = CalcPhaseAngle (activePosition' targetPosition) - 360;  	interceptAngle = (phaseAngle - interceptAngle) + 360;  } else {  	phaseAngle = CalcPhaseAngle (activePosition' targetPosition);  	interceptAngle = phaseAngle - interceptAngle;  }  
Magic Number,Engineer,Rendezvous,F:\newReposMay17\CYBUTEK_Engineer\Engineer\Rendezvous.cs,DrawBodyDetails,The following statement contains a magic number: if (interceptAngle < 0) {  	phaseAngle = CalcPhaseAngle (activePosition' targetPosition) - 360;  	interceptAngle = (phaseAngle - interceptAngle) + 360;  } else {  	phaseAngle = CalcPhaseAngle (activePosition' targetPosition);  	interceptAngle = phaseAngle - interceptAngle;  }  
Magic Number,Engineer,Rendezvous,F:\newReposMay17\CYBUTEK_Engineer\Engineer\Rendezvous.cs,DrawBodyDetails,The following statement contains a magic number: phaseAngle = CalcPhaseAngle (activePosition' targetPosition) - 360;  
Magic Number,Engineer,Rendezvous,F:\newReposMay17\CYBUTEK_Engineer\Engineer\Rendezvous.cs,DrawBodyDetails,The following statement contains a magic number: interceptAngle = (phaseAngle - interceptAngle) + 360;  
Magic Number,Engineer,Rendezvous,F:\newReposMay17\CYBUTEK_Engineer\Engineer\Rendezvous.cs,DrawBodyDetails,The following statement contains a magic number: if (interceptAngle < 0) {  	interceptAngle += 360;  }  
Magic Number,Engineer,Rendezvous,F:\newReposMay17\CYBUTEK_Engineer\Engineer\Rendezvous.cs,DrawBodyDetails,The following statement contains a magic number: interceptAngle += 360;  
Magic Number,Engineer,Rendezvous,F:\newReposMay17\CYBUTEK_Engineer\Engineer\Rendezvous.cs,DrawBodyDetails,The following statement contains a magic number: if (FlightEngineer.settings.Get<bool> ("Rendezvous: Celestial Body - Current Phase Angle"))  	GUILayout.Label (Tools.FormatNumber (phaseAngle' ""' 6)' fe.dataStyle);  
Magic Number,Engineer,Rendezvous,F:\newReposMay17\CYBUTEK_Engineer\Engineer\Rendezvous.cs,DrawBodyDetails,The following statement contains a magic number: GUILayout.Label (Tools.FormatNumber (phaseAngle' ""' 6)' fe.dataStyle);  
Magic Number,Engineer,Rendezvous,F:\newReposMay17\CYBUTEK_Engineer\Engineer\Rendezvous.cs,DrawBodyDetails,The following statement contains a magic number: if (FlightEngineer.settings.Get<bool> ("Rendezvous: Celestial Body - Intercept Angle"))  	GUILayout.Label (Tools.FormatNumber (interceptAngle' ""' 6)' fe.dataStyle);  
Magic Number,Engineer,Rendezvous,F:\newReposMay17\CYBUTEK_Engineer\Engineer\Rendezvous.cs,DrawBodyDetails,The following statement contains a magic number: GUILayout.Label (Tools.FormatNumber (interceptAngle' ""' 6)' fe.dataStyle);  
Magic Number,Engineer,Rendezvous,F:\newReposMay17\CYBUTEK_Engineer\Engineer\Rendezvous.cs,DrawBodyDetails,The following statement contains a magic number: if (fe.vessel.mainBody != targetBody.referenceBody && fe.vessel.mainBody != Planetarium.fetch.Sun) {  	if (FlightEngineer.settings.Get<bool> ("Rendezvous: Celestial Body - Ejection Angle"))  		GUILayout.Label (Tools.FormatNumber (ejectionAngle' ""' 6)' fe.dataStyle);  	if (FlightEngineer.settings.Get<bool> ("Rendezvous: Celestial Body - Angle to Prograde/Retrograde"' true)) {  		if (phaseAngle > 0) {  			GUILayout.Label (Tools.FormatNumber (angleToPrograde' ""' 6)' fe.dataStyle);  		} else {  			GUILayout.Label (Tools.FormatNumber (angleToRetrograde' ""' 6)' fe.dataStyle);  		}  	}  }  
Magic Number,Engineer,Rendezvous,F:\newReposMay17\CYBUTEK_Engineer\Engineer\Rendezvous.cs,DrawBodyDetails,The following statement contains a magic number: if (fe.vessel.mainBody != targetBody.referenceBody && fe.vessel.mainBody != Planetarium.fetch.Sun) {  	if (FlightEngineer.settings.Get<bool> ("Rendezvous: Celestial Body - Ejection Angle"))  		GUILayout.Label (Tools.FormatNumber (ejectionAngle' ""' 6)' fe.dataStyle);  	if (FlightEngineer.settings.Get<bool> ("Rendezvous: Celestial Body - Angle to Prograde/Retrograde"' true)) {  		if (phaseAngle > 0) {  			GUILayout.Label (Tools.FormatNumber (angleToPrograde' ""' 6)' fe.dataStyle);  		} else {  			GUILayout.Label (Tools.FormatNumber (angleToRetrograde' ""' 6)' fe.dataStyle);  		}  	}  }  
Magic Number,Engineer,Rendezvous,F:\newReposMay17\CYBUTEK_Engineer\Engineer\Rendezvous.cs,DrawBodyDetails,The following statement contains a magic number: if (fe.vessel.mainBody != targetBody.referenceBody && fe.vessel.mainBody != Planetarium.fetch.Sun) {  	if (FlightEngineer.settings.Get<bool> ("Rendezvous: Celestial Body - Ejection Angle"))  		GUILayout.Label (Tools.FormatNumber (ejectionAngle' ""' 6)' fe.dataStyle);  	if (FlightEngineer.settings.Get<bool> ("Rendezvous: Celestial Body - Angle to Prograde/Retrograde"' true)) {  		if (phaseAngle > 0) {  			GUILayout.Label (Tools.FormatNumber (angleToPrograde' ""' 6)' fe.dataStyle);  		} else {  			GUILayout.Label (Tools.FormatNumber (angleToRetrograde' ""' 6)' fe.dataStyle);  		}  	}  }  
Magic Number,Engineer,Rendezvous,F:\newReposMay17\CYBUTEK_Engineer\Engineer\Rendezvous.cs,DrawBodyDetails,The following statement contains a magic number: if (FlightEngineer.settings.Get<bool> ("Rendezvous: Celestial Body - Ejection Angle"))  	GUILayout.Label (Tools.FormatNumber (ejectionAngle' ""' 6)' fe.dataStyle);  
Magic Number,Engineer,Rendezvous,F:\newReposMay17\CYBUTEK_Engineer\Engineer\Rendezvous.cs,DrawBodyDetails,The following statement contains a magic number: GUILayout.Label (Tools.FormatNumber (ejectionAngle' ""' 6)' fe.dataStyle);  
Magic Number,Engineer,Rendezvous,F:\newReposMay17\CYBUTEK_Engineer\Engineer\Rendezvous.cs,DrawBodyDetails,The following statement contains a magic number: if (FlightEngineer.settings.Get<bool> ("Rendezvous: Celestial Body - Angle to Prograde/Retrograde"' true)) {  	if (phaseAngle > 0) {  		GUILayout.Label (Tools.FormatNumber (angleToPrograde' ""' 6)' fe.dataStyle);  	} else {  		GUILayout.Label (Tools.FormatNumber (angleToRetrograde' ""' 6)' fe.dataStyle);  	}  }  
Magic Number,Engineer,Rendezvous,F:\newReposMay17\CYBUTEK_Engineer\Engineer\Rendezvous.cs,DrawBodyDetails,The following statement contains a magic number: if (FlightEngineer.settings.Get<bool> ("Rendezvous: Celestial Body - Angle to Prograde/Retrograde"' true)) {  	if (phaseAngle > 0) {  		GUILayout.Label (Tools.FormatNumber (angleToPrograde' ""' 6)' fe.dataStyle);  	} else {  		GUILayout.Label (Tools.FormatNumber (angleToRetrograde' ""' 6)' fe.dataStyle);  	}  }  
Magic Number,Engineer,Rendezvous,F:\newReposMay17\CYBUTEK_Engineer\Engineer\Rendezvous.cs,DrawBodyDetails,The following statement contains a magic number: if (phaseAngle > 0) {  	GUILayout.Label (Tools.FormatNumber (angleToPrograde' ""' 6)' fe.dataStyle);  } else {  	GUILayout.Label (Tools.FormatNumber (angleToRetrograde' ""' 6)' fe.dataStyle);  }  
Magic Number,Engineer,Rendezvous,F:\newReposMay17\CYBUTEK_Engineer\Engineer\Rendezvous.cs,DrawBodyDetails,The following statement contains a magic number: if (phaseAngle > 0) {  	GUILayout.Label (Tools.FormatNumber (angleToPrograde' ""' 6)' fe.dataStyle);  } else {  	GUILayout.Label (Tools.FormatNumber (angleToRetrograde' ""' 6)' fe.dataStyle);  }  
Magic Number,Engineer,Rendezvous,F:\newReposMay17\CYBUTEK_Engineer\Engineer\Rendezvous.cs,DrawBodyDetails,The following statement contains a magic number: GUILayout.Label (Tools.FormatNumber (angleToPrograde' ""' 6)' fe.dataStyle);  
Magic Number,Engineer,Rendezvous,F:\newReposMay17\CYBUTEK_Engineer\Engineer\Rendezvous.cs,DrawBodyDetails,The following statement contains a magic number: GUILayout.Label (Tools.FormatNumber (angleToRetrograde' ""' 6)' fe.dataStyle);  
Magic Number,Engineer,Rendezvous,F:\newReposMay17\CYBUTEK_Engineer\Engineer\Rendezvous.cs,DrawBodyDetails,The following statement contains a magic number: if (FlightEngineer.settings.Get<bool> ("Rendezvous: Celestial Body - Relative Inclination"))  	GUILayout.Label (Tools.FormatNumber (relInclination' ""' 6)' fe.dataStyle);  
Magic Number,Engineer,Rendezvous,F:\newReposMay17\CYBUTEK_Engineer\Engineer\Rendezvous.cs,DrawBodyDetails,The following statement contains a magic number: GUILayout.Label (Tools.FormatNumber (relInclination' ""' 6)' fe.dataStyle);  
Magic Number,Engineer,Rendezvous,F:\newReposMay17\CYBUTEK_Engineer\Engineer\Rendezvous.cs,DrawBodyDetails,The following statement contains a magic number: if (FlightEngineer.settings.Get<bool> ("Rendezvous: Celestial Body - Ascending Node"' true))  	GUILayout.Label (Tools.FormatNumber (ascendingNode' ""' 6)' fe.dataStyle);  
Magic Number,Engineer,Rendezvous,F:\newReposMay17\CYBUTEK_Engineer\Engineer\Rendezvous.cs,DrawBodyDetails,The following statement contains a magic number: GUILayout.Label (Tools.FormatNumber (ascendingNode' ""' 6)' fe.dataStyle);  
Magic Number,Engineer,Rendezvous,F:\newReposMay17\CYBUTEK_Engineer\Engineer\Rendezvous.cs,DrawBodyDetails,The following statement contains a magic number: if (FlightEngineer.settings.Get<bool> ("Rendezvous: Celestial Body - Descending Node"' true))  	GUILayout.Label (Tools.FormatNumber (descendingNode' ""' 6)' fe.dataStyle);  
Magic Number,Engineer,Rendezvous,F:\newReposMay17\CYBUTEK_Engineer\Engineer\Rendezvous.cs,DrawBodyDetails,The following statement contains a magic number: GUILayout.Label (Tools.FormatNumber (descendingNode' ""' 6)' fe.dataStyle);  
Magic Number,Engineer,Rendezvous,F:\newReposMay17\CYBUTEK_Engineer\Engineer\Rendezvous.cs,DrawVesselDetails,The following statement contains a magic number: if (interceptAngle < 0) {  	phaseAngle -= 360;  	interceptAngle = (phaseAngle - interceptAngle) + 360;  } else {  	interceptAngle = phaseAngle - interceptAngle;  }  
Magic Number,Engineer,Rendezvous,F:\newReposMay17\CYBUTEK_Engineer\Engineer\Rendezvous.cs,DrawVesselDetails,The following statement contains a magic number: if (interceptAngle < 0) {  	phaseAngle -= 360;  	interceptAngle = (phaseAngle - interceptAngle) + 360;  } else {  	interceptAngle = phaseAngle - interceptAngle;  }  
Magic Number,Engineer,Rendezvous,F:\newReposMay17\CYBUTEK_Engineer\Engineer\Rendezvous.cs,DrawVesselDetails,The following statement contains a magic number: phaseAngle -= 360;  
Magic Number,Engineer,Rendezvous,F:\newReposMay17\CYBUTEK_Engineer\Engineer\Rendezvous.cs,DrawVesselDetails,The following statement contains a magic number: interceptAngle = (phaseAngle - interceptAngle) + 360;  
Magic Number,Engineer,Rendezvous,F:\newReposMay17\CYBUTEK_Engineer\Engineer\Rendezvous.cs,DrawVesselDetails,The following statement contains a magic number: if (interceptAngle < 0) {  	interceptAngle += 360;  }  
Magic Number,Engineer,Rendezvous,F:\newReposMay17\CYBUTEK_Engineer\Engineer\Rendezvous.cs,DrawVesselDetails,The following statement contains a magic number: interceptAngle += 360;  
Magic Number,Engineer,Rendezvous,F:\newReposMay17\CYBUTEK_Engineer\Engineer\Rendezvous.cs,DrawVesselDetails,The following statement contains a magic number: if (FlightEngineer.settings.Get<bool> ("Rendezvous: Vessel - Phase Angle"))  	GUILayout.Label (Tools.FormatNumber (phaseAngle' ""' 6)' fe.dataStyle);  
Magic Number,Engineer,Rendezvous,F:\newReposMay17\CYBUTEK_Engineer\Engineer\Rendezvous.cs,DrawVesselDetails,The following statement contains a magic number: GUILayout.Label (Tools.FormatNumber (phaseAngle' ""' 6)' fe.dataStyle);  
Magic Number,Engineer,Rendezvous,F:\newReposMay17\CYBUTEK_Engineer\Engineer\Rendezvous.cs,DrawVesselDetails,The following statement contains a magic number: if (FlightEngineer.settings.Get<bool> ("Rendezvous: Vessel - Intercept Angle"))  	GUILayout.Label (Tools.FormatNumber (interceptAngle' ""' 6)' fe.dataStyle);  
Magic Number,Engineer,Rendezvous,F:\newReposMay17\CYBUTEK_Engineer\Engineer\Rendezvous.cs,DrawVesselDetails,The following statement contains a magic number: GUILayout.Label (Tools.FormatNumber (interceptAngle' ""' 6)' fe.dataStyle);  
Magic Number,Engineer,Rendezvous,F:\newReposMay17\CYBUTEK_Engineer\Engineer\Rendezvous.cs,DrawVesselDetails,The following statement contains a magic number: if (FlightEngineer.settings.Get<bool> ("Rendezvous: Vessel - Rel. Inclination"))  	GUILayout.Label (Tools.FormatNumber (relInclination' ""' 6)' fe.dataStyle);  
Magic Number,Engineer,Rendezvous,F:\newReposMay17\CYBUTEK_Engineer\Engineer\Rendezvous.cs,DrawVesselDetails,The following statement contains a magic number: GUILayout.Label (Tools.FormatNumber (relInclination' ""' 6)' fe.dataStyle);  
Magic Number,Engineer,Rendezvous,F:\newReposMay17\CYBUTEK_Engineer\Engineer\Rendezvous.cs,DrawVesselDetails,The following statement contains a magic number: if (FlightEngineer.settings.Get<bool> ("Rendezvous: Vessel - Rel. Latitude"))  	GUILayout.Label (Tools.FormatNumber (fe.vessel.latitude - targetVessel.latitude' ""' 6)' fe.dataStyle);  
Magic Number,Engineer,Rendezvous,F:\newReposMay17\CYBUTEK_Engineer\Engineer\Rendezvous.cs,DrawVesselDetails,The following statement contains a magic number: GUILayout.Label (Tools.FormatNumber (fe.vessel.latitude - targetVessel.latitude' ""' 6)' fe.dataStyle);  
Magic Number,Engineer,Rendezvous,F:\newReposMay17\CYBUTEK_Engineer\Engineer\Rendezvous.cs,DrawVesselDetails,The following statement contains a magic number: if (FlightEngineer.settings.Get<bool> ("Rendezvous: Vessel - Ascending Node"' true))  	GUILayout.Label (Tools.FormatNumber (ascendingNode' ""' 6)' fe.dataStyle);  
Magic Number,Engineer,Rendezvous,F:\newReposMay17\CYBUTEK_Engineer\Engineer\Rendezvous.cs,DrawVesselDetails,The following statement contains a magic number: GUILayout.Label (Tools.FormatNumber (ascendingNode' ""' 6)' fe.dataStyle);  
Magic Number,Engineer,Rendezvous,F:\newReposMay17\CYBUTEK_Engineer\Engineer\Rendezvous.cs,DrawVesselDetails,The following statement contains a magic number: if (FlightEngineer.settings.Get<bool> ("Rendezvous: Vessel - Descending Node"' true))  	GUILayout.Label (Tools.FormatNumber (descendingNode' ""' 6)' fe.dataStyle);  
Magic Number,Engineer,Rendezvous,F:\newReposMay17\CYBUTEK_Engineer\Engineer\Rendezvous.cs,DrawVesselDetails,The following statement contains a magic number: GUILayout.Label (Tools.FormatNumber (descendingNode' ""' 6)' fe.dataStyle);  
Magic Number,Engineer,Rendezvous,F:\newReposMay17\CYBUTEK_Engineer\Engineer\Rendezvous.cs,CalcMeanAltitude,The following statement contains a magic number: return body.orbit.semiMajorAxis * (1 + body.orbit.eccentricity * body.orbit.eccentricity / 2);  
Magic Number,Engineer,Rendezvous,F:\newReposMay17\CYBUTEK_Engineer\Engineer\Rendezvous.cs,CalcMeanAltitude,The following statement contains a magic number: return vessel.mainBody.orbit.semiMajorAxis * (1 + vessel.mainBody.orbit.eccentricity * vessel.mainBody.orbit.eccentricity / 2);  
Magic Number,Engineer,Rendezvous,F:\newReposMay17\CYBUTEK_Engineer\Engineer\Rendezvous.cs,CalcPhaseAngle,The following statement contains a magic number: if (Vector3d.Angle (Quaternion.AngleAxis (90' Vector3d.forward) * origin' target) > 90) {  	phaseAngle = 360 - phaseAngle;  }  
Magic Number,Engineer,Rendezvous,F:\newReposMay17\CYBUTEK_Engineer\Engineer\Rendezvous.cs,CalcPhaseAngle,The following statement contains a magic number: if (Vector3d.Angle (Quaternion.AngleAxis (90' Vector3d.forward) * origin' target) > 90) {  	phaseAngle = 360 - phaseAngle;  }  
Magic Number,Engineer,Rendezvous,F:\newReposMay17\CYBUTEK_Engineer\Engineer\Rendezvous.cs,CalcPhaseAngle,The following statement contains a magic number: if (Vector3d.Angle (Quaternion.AngleAxis (90' Vector3d.forward) * origin' target) > 90) {  	phaseAngle = 360 - phaseAngle;  }  
Magic Number,Engineer,Rendezvous,F:\newReposMay17\CYBUTEK_Engineer\Engineer\Rendezvous.cs,CalcPhaseAngle,The following statement contains a magic number: phaseAngle = 360 - phaseAngle;  
Magic Number,Engineer,Rendezvous,F:\newReposMay17\CYBUTEK_Engineer\Engineer\Rendezvous.cs,CalcPhaseAngle,The following statement contains a magic number: return (phaseAngle + 360) % 360;  
Magic Number,Engineer,Rendezvous,F:\newReposMay17\CYBUTEK_Engineer\Engineer\Rendezvous.cs,CalcPhaseAngle,The following statement contains a magic number: return (phaseAngle + 360) % 360;  
Magic Number,Engineer,Rendezvous,F:\newReposMay17\CYBUTEK_Engineer\Engineer\Rendezvous.cs,CalcEjectionAngle,The following statement contains a magic number: return 180 - (Math.Acos (1 / e) * (180 / Math.PI));  
Magic Number,Engineer,Rendezvous,F:\newReposMay17\CYBUTEK_Engineer\Engineer\Rendezvous.cs,CalcEjectionAngle,The following statement contains a magic number: return 180 - (Math.Acos (1 / e) * (180 / Math.PI));  
Magic Number,Engineer,Rendezvous,F:\newReposMay17\CYBUTEK_Engineer\Engineer\Rendezvous.cs,CalcInterceptAngle,The following statement contains a magic number: return 180 * (1 - Math.Pow ((originRadius + targetRadius) / (2 * targetRadius)' 1.5d));  
Magic Number,Engineer,Rendezvous,F:\newReposMay17\CYBUTEK_Engineer\Engineer\Rendezvous.cs,CalcInterceptAngle,The following statement contains a magic number: return 180 * (1 - Math.Pow ((originRadius + targetRadius) / (2 * targetRadius)' 1.5d));  
Magic Number,Engineer,Rendezvous,F:\newReposMay17\CYBUTEK_Engineer\Engineer\Rendezvous.cs,CalcInterceptDistance,The following statement contains a magic number: return Math.Sqrt (Math.Pow (targetRadius * Math.Cos (interceptAngle * radian) - originRadius' 2) + Math.Pow (targetRadius * Math.Sin (interceptAngle * radian)' 2));  
Magic Number,Engineer,Rendezvous,F:\newReposMay17\CYBUTEK_Engineer\Engineer\Rendezvous.cs,CalcInterceptDistance,The following statement contains a magic number: return Math.Sqrt (Math.Pow (targetRadius * Math.Cos (interceptAngle * radian) - originRadius' 2) + Math.Pow (targetRadius * Math.Sin (interceptAngle * radian)' 2));  
Magic Number,Engineer,Rendezvous,F:\newReposMay17\CYBUTEK_Engineer\Engineer\Rendezvous.cs,AngleToPrograde,The following statement contains a magic number: if (NormaliseAngle (vesselPosition' Quaternion.AngleAxis (180' Vector3d.forward) * bodyPosition) > NormaliseAngle (vesselPosition' bodyPosition)) {  	angleToPrograde = 360 - angleToPrograde;  }  
Magic Number,Engineer,Rendezvous,F:\newReposMay17\CYBUTEK_Engineer\Engineer\Rendezvous.cs,AngleToPrograde,The following statement contains a magic number: if (NormaliseAngle (vesselPosition' Quaternion.AngleAxis (180' Vector3d.forward) * bodyPosition) > NormaliseAngle (vesselPosition' bodyPosition)) {  	angleToPrograde = 360 - angleToPrograde;  }  
Magic Number,Engineer,Rendezvous,F:\newReposMay17\CYBUTEK_Engineer\Engineer\Rendezvous.cs,AngleToPrograde,The following statement contains a magic number: angleToPrograde = 360 - angleToPrograde;  
Magic Number,Engineer,Rendezvous,F:\newReposMay17\CYBUTEK_Engineer\Engineer\Rendezvous.cs,AngleToPrograde,The following statement contains a magic number: return 360 - angleToPrograde;  
Magic Number,Engineer,Rendezvous,F:\newReposMay17\CYBUTEK_Engineer\Engineer\Rendezvous.cs,AngleToRetrograde,The following statement contains a magic number: if (NormaliseAngle (vesselPosition' Quaternion.AngleAxis (180' Vector3d.back) * bodyPosition) > NormaliseAngle (vesselPosition' bodyPosition)) {  	angleToPrograde = 360 - angleToPrograde;  }  
Magic Number,Engineer,Rendezvous,F:\newReposMay17\CYBUTEK_Engineer\Engineer\Rendezvous.cs,AngleToRetrograde,The following statement contains a magic number: if (NormaliseAngle (vesselPosition' Quaternion.AngleAxis (180' Vector3d.back) * bodyPosition) > NormaliseAngle (vesselPosition' bodyPosition)) {  	angleToPrograde = 360 - angleToPrograde;  }  
Magic Number,Engineer,Rendezvous,F:\newReposMay17\CYBUTEK_Engineer\Engineer\Rendezvous.cs,AngleToRetrograde,The following statement contains a magic number: angleToPrograde = 360 - angleToPrograde;  
Magic Number,Engineer,Rendezvous,F:\newReposMay17\CYBUTEK_Engineer\Engineer\Rendezvous.cs,AngleToRetrograde,The following statement contains a magic number: return 360 - angleToPrograde;  
Magic Number,Engineer,Rendezvous,F:\newReposMay17\CYBUTEK_Engineer\Engineer\Rendezvous.cs,CalcAngleToAscendingNode,The following statement contains a magic number: if (origin.inclination < 90) {  	angleToNode = CalcPhaseAngle (position' GetAscendingNode (origin' target));  } else {  	angleToNode = 360 - CalcPhaseAngle (position' GetAscendingNode (origin' target));  }  
Magic Number,Engineer,Rendezvous,F:\newReposMay17\CYBUTEK_Engineer\Engineer\Rendezvous.cs,CalcAngleToAscendingNode,The following statement contains a magic number: if (origin.inclination < 90) {  	angleToNode = CalcPhaseAngle (position' GetAscendingNode (origin' target));  } else {  	angleToNode = 360 - CalcPhaseAngle (position' GetAscendingNode (origin' target));  }  
Magic Number,Engineer,Rendezvous,F:\newReposMay17\CYBUTEK_Engineer\Engineer\Rendezvous.cs,CalcAngleToAscendingNode,The following statement contains a magic number: angleToNode = 360 - CalcPhaseAngle (position' GetAscendingNode (origin' target));  
Magic Number,Engineer,Rendezvous,F:\newReposMay17\CYBUTEK_Engineer\Engineer\Rendezvous.cs,CalcAngleToDescendingNode,The following statement contains a magic number: if (origin.inclination < 90) {  	angleToNode = CalcPhaseAngle (position' GetDescendingNode (origin' target));  } else {  	angleToNode = 360 - CalcPhaseAngle (position' GetDescendingNode (origin' target));  }  
Magic Number,Engineer,Rendezvous,F:\newReposMay17\CYBUTEK_Engineer\Engineer\Rendezvous.cs,CalcAngleToDescendingNode,The following statement contains a magic number: if (origin.inclination < 90) {  	angleToNode = CalcPhaseAngle (position' GetDescendingNode (origin' target));  } else {  	angleToNode = 360 - CalcPhaseAngle (position' GetDescendingNode (origin' target));  }  
Magic Number,Engineer,Rendezvous,F:\newReposMay17\CYBUTEK_Engineer\Engineer\Rendezvous.cs,CalcAngleToDescendingNode,The following statement contains a magic number: angleToNode = 360 - CalcPhaseAngle (position' GetDescendingNode (origin' target));  
Magic Number,Engineer,Settings,F:\newReposMay17\CYBUTEK_Engineer\Engineer\Settings.cs,Load,The following statement contains a magic number: if (File.Exists<Settings> (filename)) {  	//settings.Clear();  	string[] lines = File.ReadAllLines<Settings> (filename' vessel);  	for (int i = 0; i < lines.Length; i++) {  		string[] line = lines [i].Split ('=');  		if (line.Length == 2) {  			string key = line [0].Trim ();  			string val = line [1].Trim ();  			if (settings.ContainsKey (key))  				settings [key] = val;  			else  				settings.Add (key' val);  			loaded = true;  		} else  			MonoBehaviour.print ("[KER] Ignoring invalid line in settings: '" + lines [i] + "'");  	}  }  
Magic Number,Engineer,Settings,F:\newReposMay17\CYBUTEK_Engineer\Engineer\Settings.cs,Load,The following statement contains a magic number: for (int i = 0; i < lines.Length; i++) {  	string[] line = lines [i].Split ('=');  	if (line.Length == 2) {  		string key = line [0].Trim ();  		string val = line [1].Trim ();  		if (settings.ContainsKey (key))  			settings [key] = val;  		else  			settings.Add (key' val);  		loaded = true;  	} else  		MonoBehaviour.print ("[KER] Ignoring invalid line in settings: '" + lines [i] + "'");  }  
Magic Number,Engineer,Settings,F:\newReposMay17\CYBUTEK_Engineer\Engineer\Settings.cs,Load,The following statement contains a magic number: if (line.Length == 2) {  	string key = line [0].Trim ();  	string val = line [1].Trim ();  	if (settings.ContainsKey (key))  		settings [key] = val;  	else  		settings.Add (key' val);  	loaded = true;  } else  	MonoBehaviour.print ("[KER] Ignoring invalid line in settings: '" + lines [i] + "'");  
Magic Number,Engineer,Settings,F:\newReposMay17\CYBUTEK_Engineer\Engineer\Settings.cs,ConvertToRect,The following statement contains a magic number: return new Rect (Convert.ToSingle (args [0])' Convert.ToSingle (args [1])' Convert.ToSingle (args [2])' Convert.ToSingle (args [3]));  
Magic Number,Engineer,Settings,F:\newReposMay17\CYBUTEK_Engineer\Engineer\Settings.cs,ConvertToRect,The following statement contains a magic number: return new Rect (Convert.ToSingle (args [0])' Convert.ToSingle (args [1])' Convert.ToSingle (args [2])' Convert.ToSingle (args [3]));  
Magic Number,Engineer,Settings,F:\newReposMay17\CYBUTEK_Engineer\Engineer\Settings.cs,DrawWindow,The following statement contains a magic number: data.fixedWidth = 400;  
Magic Number,Engineer.VesselSimulator,EngineSim,F:\newReposMay17\CYBUTEK_Engineer\Engineer\VesselSimulator\EngineSim.cs,EngineSim,The following statement contains a magic number: if (SimManager.logOutput) {  	buffer = new StringBuilder (1024);  	buffer.AppendFormat ("flowRate = {0:g6}\n"' flowRate);  }  
Magic Number,Engineer.VesselSimulator,EngineSim,F:\newReposMay17\CYBUTEK_Engineer\Engineer\VesselSimulator\EngineSim.cs,EngineSim,The following statement contains a magic number: buffer = new StringBuilder (1024);  
Magic Number,Engineer.VesselSimulator,Simulation,F:\newReposMay17\CYBUTEK_Engineer\Engineer\VesselSimulator\Simulation.cs,RunSimulation,The following statement contains a magic number: while (currentStage >= 0) {  	if (log != null) {  		log.buf.AppendLine ("Simulating stage " + currentStage);  		log.buf.AppendLine ("ShipMass = " + ShipMass);  		log.Flush ();  		_timer.Reset ();  		_timer.Start ();  	}  	// Update active engines and resource drains  	UpdateResourceDrains ();  	// Create the Stage object for this stage  	Stage stage = new Stage ();  	stageTime = 0d;  	vecStageDeltaV = Vector3.zero;  	stageStartMass = ShipMass;  	stepStartMass = stageStartMass;  	stepEndMass = 0;  	CalculateThrustAndISP ();  	// Store various things in the Stage object  	stage.thrust = totalStageThrust;  	//MonoBehaviour.print("stage.thrust = " + stage.thrust);  	stage.thrustToWeight = totalStageThrust / (stageStartMass * gravity);  	stage.maxThrustToWeight = stage.thrustToWeight;  	//MonoBehaviour.print("StageMass = " + stageStartMass);  	//MonoBehaviour.print("Initial maxTWR = " + stage.maxThrustToWeight);  	stage.actualThrust = totalStageActualThrust;  	stage.actualThrustToWeight = totalStageActualThrust / (stageStartMass * gravity);  	// Calculate the cost and mass of this stage and add all engines and tanks that are decoupled  	// in the next stage to the dontStageParts list  	foreach (PartSim partSim in allParts) {  		if (partSim.decoupledInStage == currentStage - 1) {  			stage.cost += partSim.cost;  			stage.mass += partSim.GetStartMass ();  		}  	}  	dontStageParts = dontStagePartsLists [currentStage];  	if (log != null) {  		log.buf.AppendLine ("Stage setup took " + _timer.ElapsedMilliseconds + "ms");  		if (dontStageParts.Count > 0) {  			log.buf.AppendLine ("Parts preventing staging:");  			foreach (PartSim partSim in dontStageParts)  				partSim.DumpPartToBuffer (log.buf' "");  		} else  			log.buf.AppendLine ("No parts preventing staging");  		log.Flush ();  	}  	// Now we will loop until we are allowed to stage  	int loopCounter = 0;  	while (!AllowedToStage ()) {  		loopCounter++;  		//MonoBehaviour.print("loop = " + loopCounter);  		// Calculate how long each draining tank will take to drain and run for the minimum time  		double resourceDrainTime = double.MaxValue;  		PartSim partMinDrain = null;  		foreach (PartSim partSim in drainingParts) {  			double time = partSim.TimeToDrainResource ();  			if (time < resourceDrainTime) {  				resourceDrainTime = time;  				partMinDrain = partSim;  			}  		}  		if (log != null)  			MonoBehaviour.print ("Drain time = " + resourceDrainTime + " (" + partMinDrain.name + ":" + partMinDrain.partId + ")");  		foreach (PartSim partSim in drainingParts)  			partSim.DrainResources (resourceDrainTime);  		// Get the mass after draining  		stepEndMass = ShipMass;  		stageTime += resourceDrainTime;  		double stepEndTWR = totalStageThrust / (stepEndMass * gravity);  		//MonoBehaviour.print("After drain mass = " + stepEndMass);  		//MonoBehaviour.print("currentThrust = " + totalStageThrust);  		//MonoBehaviour.print("currentTWR = " + stepEndTWR);  		if (stepEndTWR > stage.maxThrustToWeight)  			stage.maxThrustToWeight = stepEndTWR;  		//MonoBehaviour.print("newMaxTWR = " + stage.maxThrustToWeight);  		// If we have drained anything and the masses make sense then add this step's deltaV to the stage total  		if (resourceDrainTime > 0d && stepStartMass > stepEndMass && stepStartMass > 0d && stepEndMass > 0d)  			vecStageDeltaV += vecThrust * (float)((currentisp * STD_GRAVITY * Math.Log (stepStartMass / stepEndMass)) / simpleTotalThrust);  		// Update the active engines and resource drains for the next step  		UpdateResourceDrains ();  		// Recalculate the current thrust and isp for the next step  		CalculateThrustAndISP ();  		// Check if we actually changed anything  		if (stepStartMass == stepEndMass) {  			//MonoBehaviour.print("No change in mass");  			break;  		}  		// Check to stop rampant looping  		if (loopCounter == 1000) {  			MonoBehaviour.print ("exceeded loop count");  			MonoBehaviour.print ("stageStartMass = " + stageStartMass);  			MonoBehaviour.print ("stepStartMass = " + stepStartMass);  			MonoBehaviour.print ("StepEndMass   = " + stepEndMass);  			break;  		}  		// The next step starts at the mass this one ended at  		stepStartMass = stepEndMass;  	}  	// Store more values in the Stage object and stick it in the array  	// Store the magnitude of the deltaV vector  	stage.deltaV = vecStageDeltaV.magnitude;  	// Recalculate effective stage isp from the stage deltaV (flip the standard deltaV calculation around)  	// Note: If the mass doesn't change then this is a divide by zero  	if (stageStartMass != stepStartMass)  		stage.isp = stage.deltaV / (STD_GRAVITY * Math.Log (stageStartMass / stepStartMass));  	else  		stage.isp = 0;  	// Zero stage time if more than a day (this should be moved into the window code)  	stage.time = (stageTime < SECONDS_PER_DAY) ? stageTime : 0d;  	stage.number = doingCurrent ? -1 : currentStage;  	// Set the stage number to -1 if doing current engines  	stages [currentStage] = stage;  	// Now activate the next stage  	currentStage--;  	doingCurrent = false;  	if (log != null) {  		// Log how long the stage took  		_timer.Stop ();  		MonoBehaviour.print ("Simulating stage took " + _timer.ElapsedMilliseconds + "ms");  		stage.Dump ();  		_timer.Reset ();  		_timer.Start ();  	}  	// Activate the next stage  	ActivateStage ();  	if (log != null) {  		// Log how long it took to activate  		_timer.Stop ();  		MonoBehaviour.print ("ActivateStage took " + _timer.ElapsedMilliseconds + "ms");  	}  }  
Magic Number,Engineer.VesselSimulator,Simulation,F:\newReposMay17\CYBUTEK_Engineer\Engineer\VesselSimulator\Simulation.cs,RunSimulation,The following statement contains a magic number: while (!AllowedToStage ()) {  	loopCounter++;  	//MonoBehaviour.print("loop = " + loopCounter);  	// Calculate how long each draining tank will take to drain and run for the minimum time  	double resourceDrainTime = double.MaxValue;  	PartSim partMinDrain = null;  	foreach (PartSim partSim in drainingParts) {  		double time = partSim.TimeToDrainResource ();  		if (time < resourceDrainTime) {  			resourceDrainTime = time;  			partMinDrain = partSim;  		}  	}  	if (log != null)  		MonoBehaviour.print ("Drain time = " + resourceDrainTime + " (" + partMinDrain.name + ":" + partMinDrain.partId + ")");  	foreach (PartSim partSim in drainingParts)  		partSim.DrainResources (resourceDrainTime);  	// Get the mass after draining  	stepEndMass = ShipMass;  	stageTime += resourceDrainTime;  	double stepEndTWR = totalStageThrust / (stepEndMass * gravity);  	//MonoBehaviour.print("After drain mass = " + stepEndMass);  	//MonoBehaviour.print("currentThrust = " + totalStageThrust);  	//MonoBehaviour.print("currentTWR = " + stepEndTWR);  	if (stepEndTWR > stage.maxThrustToWeight)  		stage.maxThrustToWeight = stepEndTWR;  	//MonoBehaviour.print("newMaxTWR = " + stage.maxThrustToWeight);  	// If we have drained anything and the masses make sense then add this step's deltaV to the stage total  	if (resourceDrainTime > 0d && stepStartMass > stepEndMass && stepStartMass > 0d && stepEndMass > 0d)  		vecStageDeltaV += vecThrust * (float)((currentisp * STD_GRAVITY * Math.Log (stepStartMass / stepEndMass)) / simpleTotalThrust);  	// Update the active engines and resource drains for the next step  	UpdateResourceDrains ();  	// Recalculate the current thrust and isp for the next step  	CalculateThrustAndISP ();  	// Check if we actually changed anything  	if (stepStartMass == stepEndMass) {  		//MonoBehaviour.print("No change in mass");  		break;  	}  	// Check to stop rampant looping  	if (loopCounter == 1000) {  		MonoBehaviour.print ("exceeded loop count");  		MonoBehaviour.print ("stageStartMass = " + stageStartMass);  		MonoBehaviour.print ("stepStartMass = " + stepStartMass);  		MonoBehaviour.print ("StepEndMass   = " + stepEndMass);  		break;  	}  	// The next step starts at the mass this one ended at  	stepStartMass = stepEndMass;  }  
Magic Number,Engineer.VesselSimulator,Simulation,F:\newReposMay17\CYBUTEK_Engineer\Engineer\VesselSimulator\Simulation.cs,RunSimulation,The following statement contains a magic number: if (loopCounter == 1000) {  	MonoBehaviour.print ("exceeded loop count");  	MonoBehaviour.print ("stageStartMass = " + stageStartMass);  	MonoBehaviour.print ("stepStartMass = " + stepStartMass);  	MonoBehaviour.print ("StepEndMass   = " + stepEndMass);  	break;  }  
Magic Number,Engineer.VesselSimulator,Simulation,F:\newReposMay17\CYBUTEK_Engineer\Engineer\VesselSimulator\Simulation.cs,UpdateResourceDrains,The following statement contains a magic number: if (SimManager.logOutput) {  	StringBuilder buffer = new StringBuilder (1024);  	buffer.AppendFormat ("Active engines = {0:d}\n"' activeEngines.Count);  	int i = 0;  	foreach (EngineSim engine in activeEngines)  		engine.DumpEngineToBuffer (buffer' "Engine " + (i++) + ":");  	MonoBehaviour.print (buffer);  }  
Magic Number,Engineer.VesselSimulator,Simulation,F:\newReposMay17\CYBUTEK_Engineer\Engineer\VesselSimulator\Simulation.cs,AllowedToStage,The following statement contains a magic number: if (SimManager.logOutput) {  	buffer = new StringBuilder (1024);  	buffer.AppendLine ("AllowedToStage");  	buffer.AppendFormat ("currentStage = {0:d}\n"' currentStage);  }  
Magic Number,Engineer.VesselSimulator,Simulation,F:\newReposMay17\CYBUTEK_Engineer\Engineer\VesselSimulator\Simulation.cs,AllowedToStage,The following statement contains a magic number: buffer = new StringBuilder (1024);  
Missing Default,Engineer,Tools,F:\newReposMay17\CYBUTEK_Engineer\Engineer\Tools.cs,FormatSI,The following switch statement is missing a default case: switch (type) {  case SIUnitType.Distance:  	return ToDistance (number);  // Quick and dirty implementation of the new distance formatter from KER 1.0  //notation = new string[] { "mm"' "m"' "km"' "Mm"' "Gm"' "Tm"' "Pm"' "Em"' "Zm"' "Ym" };  //number *= 1000;  case SIUnitType.Speed:  	notation = new string[] {  		"mm/s"'  		"m/s"'  		"km/s"'  		"Mm/s"'  		"Gm/s"'  		"Tm/s"'  		"Pm/s"'  		"Em/s"'  		"Zm/s"'  		"Ym/s"  	};  	number *= 1000;  	break;  case SIUnitType.Pressure:  	notation = new string[] {  		"Pa"'  		"kPa"'  		"MPa"'  		"GPa"'  		"TPa"'  		"PPa"'  		"EPa"'  		"ZPa"'  		"YPa"  	};  	number *= 1000;  	break;  case SIUnitType.Density:  	notation = new string[] {  		"mg/m"'  		"g/m"'  		"kg/m"'  		"Mg/m"'  		"Gg/m"'  		"Tg/m"'  		"Pg/m"'  		"Eg/m"'  		"Zg/m"'  		"Yg/m"  	};  	number *= 1000000;  	break;  case SIUnitType.Force:  	notation = new string[] {  		"N"'  		"kN"'  		"MN"'  		"GN"'  		"TN"'  		"PT"'  		"EN"'  		"ZN"'  		"YN"  	};  	number *= 1000;  	break;  case SIUnitType.Mass:  	notation = new string[] {  		"g"'  		"kg"'  		"Mg"'  		"Gg"'  		"Tg"'  		"Pg"'  		"Eg"'  		"Zg"'  		"Yg"  	};  	number *= 1000;  	break;  }  
Missing Default,Engineer.VesselSimulator,SimManager,F:\newReposMay17\CYBUTEK_Engineer\Engineer\VesselSimulator\SimManager.cs,GetVesselTypeString,The following switch statement is missing a default case: switch (vesselType) {  case VesselType.Debris:  	return "Debris";  case VesselType.SpaceObject:  	return "SpaceObject";  case VesselType.Unknown:  	return "Unknown";  case VesselType.Probe:  	return "Probe";  case VesselType.Rover:  	return "Rover";  case VesselType.Lander:  	return "Lander";  case VesselType.Ship:  	return "Ship";  case VesselType.Station:  	return "Station";  case VesselType.Base:  	return "Base";  case VesselType.EVA:  	return "EVA";  case VesselType.Flag:  	return "Flag";  }  
